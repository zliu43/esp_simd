
build/working.elf:     file format elf32-xtensa-le


Disassembly of section .iram0.vectors:

40374000 <_WindowOverflow4>:

    .org    0x0
    .global _WindowOverflow4
_WindowOverflow4:

    s32e    a0, a5, -16     /* save a0 to call[j+1]'s stack frame */
40374000:	49c500        	s32e	a0, a5, -16
    s32e    a1, a5, -12     /* save a1 to call[j+1]'s stack frame */
40374003:	49d510        	s32e	a1, a5, -12
    s32e    a2, a5,  -8     /* save a2 to call[j+1]'s stack frame */
40374006:	49e520        	s32e	a2, a5, -8
    s32e    a3, a5,  -4     /* save a3 to call[j+1]'s stack frame */
40374009:	49f530        	s32e	a3, a5, -4
    rfwo                    /* rotates back to call[i] position */
4037400c:	003400        	rfwo
	...

40374040 <_WindowUnderflow4>:

    .org    0x40
    .global _WindowUnderflow4
_WindowUnderflow4:

    l32e    a0, a5, -16     /* restore a0 from call[i+1]'s stack frame */
40374040:	09c500        	l32e	a0, a5, -16
    l32e    a1, a5, -12     /* restore a1 from call[i+1]'s stack frame */
40374043:	09d510        	l32e	a1, a5, -12
    l32e    a2, a5,  -8     /* restore a2 from call[i+1]'s stack frame */
40374046:	09e520        	l32e	a2, a5, -8
    l32e    a3, a5,  -4     /* restore a3 from call[i+1]'s stack frame */
40374049:	09f530        	l32e	a3, a5, -4
    rfwu
4037404c:	003500        	rfwu
	...

40374050 <_xt_alloca_exc>:

    .align  4
    .global _xt_alloca_exc
_xt_alloca_exc:

    rsr     a0, WINDOWBASE  /* grab WINDOWBASE before rotw changes it */
40374050:	034800        	rsr.windowbase	a0
    rotw    -1              /* WINDOWBASE goes to a4, new a0-a3 are scratch */
40374053:	4080f0        	rotw	-1
    rsr     a2, PS
40374056:	03e620        	rsr.ps	a2
    extui   a3, a2, XCHAL_PS_OWB_SHIFT, XCHAL_PS_OWB_BITS
40374059:	343820        	extui	a3, a2, 8, 4
    xor     a3, a3, a4      /* bits changed from old to current windowbase */
4037405c:	303340        	xor	a3, a3, a4
    rsr     a4, EXCSAVE_1   /* restore original a0 (now in a4) */
4037405f:	03d140        	rsr.excsave1	a4
    slli    a3, a3, XCHAL_PS_OWB_SHIFT
40374062:	113380        	slli	a3, a3, 8
    xor     a2, a2, a3      /* flip changed bits in old window base */
40374065:	302230        	xor	a2, a2, a3
    wsr     a2, PS          /* update PS.OWB to new window base */
40374068:	13e620        	wsr.ps	a2
    rsync
4037406b:	002010        	rsync

    bbci.l a4, 31, _WindowUnderflow4
4037406e:	ce74f7        	bbci	a4, 31, 40374040 <_WindowUnderflow4>
    rotw    -1              /* original a0 goes to a8 */
40374071:	4080f0        	rotw	-1
    bbci.l a8, 30, _WindowUnderflow8
40374074:	4878e7        	bbci	a8, 30, 403740c0 <_WindowUnderflow8>
    rotw    -1
40374077:	4080f0        	rotw	-1
    j               _WindowUnderflow12
4037407a:	003086        	j	40374140 <_WindowUnderflow12>
4037407d:	000000        	ill

40374080 <_WindowOverflow8>:

    .org    0x80
    .global _WindowOverflow8
_WindowOverflow8:

    s32e    a0, a9, -16     /* save a0 to call[j+1]'s stack frame */
40374080:	49c900        	s32e	a0, a9, -16
    l32e    a0, a1, -12     /* a0 <- call[j-1]'s sp
40374083:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1, a9, -12     /* save a1 to call[j+1]'s stack frame */
40374086:	49d910        	s32e	a1, a9, -12
    s32e    a2, a9,  -8     /* save a2 to call[j+1]'s stack frame */
40374089:	49e920        	s32e	a2, a9, -8
    s32e    a3, a9,  -4     /* save a3 to call[j+1]'s stack frame */
4037408c:	49f930        	s32e	a3, a9, -4
    s32e    a4, a0, -32     /* save a4 to call[j]'s stack frame */
4037408f:	498040        	s32e	a4, a0, -32
    s32e    a5, a0, -28     /* save a5 to call[j]'s stack frame */
40374092:	499050        	s32e	a5, a0, -28
    s32e    a6, a0, -24     /* save a6 to call[j]'s stack frame */
40374095:	49a060        	s32e	a6, a0, -24
    s32e    a7, a0, -20     /* save a7 to call[j]'s stack frame */
40374098:	49b070        	s32e	a7, a0, -20
    rfwo                    /* rotates back to call[i] position */
4037409b:	003400        	rfwo
	...

403740c0 <_WindowUnderflow8>:

    .org    0xC0
    .global _WindowUnderflow8
_WindowUnderflow8:

    l32e    a0, a9, -16     /* restore a0 from call[i+1]'s stack frame */
403740c0:	09c900        	l32e	a0, a9, -16
    l32e    a1, a9, -12     /* restore a1 from call[i+1]'s stack frame */
403740c3:	09d910        	l32e	a1, a9, -12
    l32e    a2, a9,  -8     /* restore a2 from call[i+1]'s stack frame */
403740c6:	09e920        	l32e	a2, a9, -8
    l32e    a7, a1, -12     /* a7 <- call[i-1]'s sp
403740c9:	09d170        	l32e	a7, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3, a9,  -4     /* restore a3 from call[i+1]'s stack frame */
403740cc:	09f930        	l32e	a3, a9, -4
    l32e    a4, a7, -32     /* restore a4 from call[i]'s stack frame */
403740cf:	098740        	l32e	a4, a7, -32
    l32e    a5, a7, -28     /* restore a5 from call[i]'s stack frame */
403740d2:	099750        	l32e	a5, a7, -28
    l32e    a6, a7, -24     /* restore a6 from call[i]'s stack frame */
403740d5:	09a760        	l32e	a6, a7, -24
    l32e    a7, a7, -20     /* restore a7 from call[i]'s stack frame */
403740d8:	09b770        	l32e	a7, a7, -20
    rfwu
403740db:	003500        	rfwu
	...

40374100 <_WindowOverflow12>:

    .org    0x100
    .global _WindowOverflow12
_WindowOverflow12:

    s32e    a0,  a13, -16   /* save a0 to call[j+1]'s stack frame */
40374100:	49cd00        	s32e	a0, a13, -16
    l32e    a0,  a1,  -12   /* a0 <- call[j-1]'s sp
40374103:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1,  a13, -12   /* save a1 to call[j+1]'s stack frame */
40374106:	49dd10        	s32e	a1, a13, -12
    s32e    a2,  a13,  -8   /* save a2 to call[j+1]'s stack frame */
40374109:	49ed20        	s32e	a2, a13, -8
    s32e    a3,  a13,  -4   /* save a3 to call[j+1]'s stack frame */
4037410c:	49fd30        	s32e	a3, a13, -4
    s32e    a4,  a0,  -48   /* save a4 to end of call[j]'s stack frame */
4037410f:	494040        	s32e	a4, a0, -48
    s32e    a5,  a0,  -44   /* save a5 to end of call[j]'s stack frame */
40374112:	495050        	s32e	a5, a0, -44
    s32e    a6,  a0,  -40   /* save a6 to end of call[j]'s stack frame */
40374115:	496060        	s32e	a6, a0, -40
    s32e    a7,  a0,  -36   /* save a7 to end of call[j]'s stack frame */
40374118:	497070        	s32e	a7, a0, -36
    s32e    a8,  a0,  -32   /* save a8 to end of call[j]'s stack frame */
4037411b:	498080        	s32e	a8, a0, -32
    s32e    a9,  a0,  -28   /* save a9 to end of call[j]'s stack frame */
4037411e:	499090        	s32e	a9, a0, -28
    s32e    a10, a0,  -24   /* save a10 to end of call[j]'s stack frame */
40374121:	49a0a0        	s32e	a10, a0, -24
    s32e    a11, a0,  -20   /* save a11 to end of call[j]'s stack frame */
40374124:	49b0b0        	s32e	a11, a0, -20
    rfwo                    /* rotates back to call[i] position */
40374127:	003400        	rfwo
	...

40374140 <_WindowUnderflow12>:

    .org 0x140
    .global _WindowUnderflow12
_WindowUnderflow12:

    l32e    a0,  a13, -16   /* restore a0 from call[i+1]'s stack frame */
40374140:	09cd00        	l32e	a0, a13, -16
    l32e    a1,  a13, -12   /* restore a1 from call[i+1]'s stack frame */
40374143:	09dd10        	l32e	a1, a13, -12
    l32e    a2,  a13,  -8   /* restore a2 from call[i+1]'s stack frame */
40374146:	09ed20        	l32e	a2, a13, -8
    l32e    a11, a1,  -12   /* a11 <- call[i-1]'s sp
40374149:	09d1b0        	l32e	a11, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3,  a13,  -4   /* restore a3 from call[i+1]'s stack frame */
4037414c:	09fd30        	l32e	a3, a13, -4
    l32e    a4,  a11, -48   /* restore a4 from end of call[i]'s stack frame */
4037414f:	094b40        	l32e	a4, a11, -48
    l32e    a5,  a11, -44   /* restore a5 from end of call[i]'s stack frame */
40374152:	095b50        	l32e	a5, a11, -44
    l32e    a6,  a11, -40   /* restore a6 from end of call[i]'s stack frame */
40374155:	096b60        	l32e	a6, a11, -40
    l32e    a7,  a11, -36   /* restore a7 from end of call[i]'s stack frame */
40374158:	097b70        	l32e	a7, a11, -36
    l32e    a8,  a11, -32   /* restore a8 from end of call[i]'s stack frame */
4037415b:	098b80        	l32e	a8, a11, -32
    l32e    a9,  a11, -28   /* restore a9 from end of call[i]'s stack frame */
4037415e:	099b90        	l32e	a9, a11, -28
    l32e    a10, a11, -24   /* restore a10 from end of call[i]'s stack frame */
40374161:	09aba0        	l32e	a10, a11, -24
    l32e    a11, a11, -20   /* restore a11 from end of call[i]'s stack frame */
40374164:	09bbb0        	l32e	a11, a11, -20
    rfwu
40374167:	003500        	rfwu
	...

40374180 <_Level2Vector>:
    wsr     a0, EXCSAVE_2                   /* preserve a0 */
40374180:	13d200        	wsr.excsave2	a0
    call0   _xt_medint2                     /* load interrupt handler */
40374183:	02f085        	call0	4037708c <_xt_medint2>
	...

403741c0 <_Level3Vector>:
    wsr     a0, EXCSAVE_3                   /* preserve a0 */
403741c0:	13d300        	wsr.excsave3	a0
    call0   _xt_medint3                     /* load interrupt handler */
403741c3:	02f785        	call0	4037713c <_xt_medint3>
	...

40374200 <_Level4Vector>:
    wsr     a0, EXCSAVE_4                   /* preserve a0 */
40374200:	13d400        	wsr.excsave4	a0
    call0   xt_highint4                     /* load interrupt handler */
40374203:	014405        	call0	40375644 <xt_highint4>
	...

40374240 <_Level5Vector>:
    wsr     a0, EXCSAVE_5                   /* preserve a0 */
40374240:	13d500        	wsr.excsave5	a0
    call0   xt_highint5                    /* load interrupt handler */
40374243:	02fb05        	call0	403771f4 <xt_highint5>
	...

40374280 <_DebugExceptionVector>:
    wsr     a0, EXCSAVE+XCHAL_DEBUGLEVEL    /* preserve a0 */
40374280:	13d600        	wsr.excsave6	a0
    J   xt_debugexception            /* load exception handler */
40374283:	0a6646        	j	40376c20 <xt_debugexception>
	...

403742c0 <_NMIExceptionVector>:
    wsr     a0, EXCSAVE + XCHAL_NMILEVEL   /* preserve a0 */
403742c0:	13d700        	wsr.excsave7	a0
    call0   xt_nmi                         /* load interrupt handler */
403742c3:	02f385        	call0	403771fc <xt_nmi>
	...

40374300 <_KernelExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374300:	13d100        	wsr.excsave1	a0
    call0   _xt_kernel_exc                  /* kernel exception handler */
40374303:	029345        	call0	40376c38 <_xt_kernel_exc>
	...

40374340 <_UserExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374340:	13d100        	wsr.excsave1	a0
    call0   _xt_user_exc                    /* user exception handler */
40374343:	029145        	call0	40376c58 <_xt_user_exc>
	...

403743c0 <_DoubleExceptionVector>:
    break   1, 4                            /* unhandled double exception */
403743c0:	004140        	break	1, 4
    movi    a0,PANIC_RSN_DOUBLEEXCEPTION
403743c3:	200c      	movi.n	a0, 2
    wsr     a0,EXCCAUSE
403743c5:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
403743c8:	038e45        	call0	40377cb0 <_xt_panic>
    rfde                                    /* make a0 point here not later */
403743cb:	003200        	rfde
	...

40374400 <_invalid_pc_placeholder>:
_invalid_pc_placeholder:
    /* This should be an entry instruction for correct stack unwinding.
     * There could be just a line ".cfi_startproc", but unfortunately,
     * CFI is not supported for the Xtensa architecture. */
#define UNREACHABLE_INSTRUCTION_CHECK_PREVIOUS_FRAMES ENTRY0
    UNREACHABLE_INSTRUCTION_CHECK_PREVIOUS_FRAMES
40374400:	002136        	entry	a1, 16
	...

Disassembly of section .iram0.text:

40374404 <esp_system_get_time-0xdc8>:
40374404:	4cd8      	l32i.n	a13, a12, 16
40374406:	3fc9      	s32i.n	a12, a15, 12
40374408:	e0          	.byte	0xe0
40374409:	c94c      	movi.n	a9, 76
4037440b:	c94d003f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q4, q0, q4, q5
4037440f:	0016043f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 64, q4, q0, q1, q6
40374413:	060042        	l8ui	a4, a0, 6
40374416:	304000        	xor	a4, a0, a0
40374419:	0042018f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a8, 16, q4, q0, q4, q2
4037441d:	40          	.byte	0x40
4037441e:	d84037        	ball	a0, a3, 403743fa <_DoubleExceptionVector+0x3a>
40374421:	e0          	.byte	0xe0
40374422:	600c      	movi.n	a0, 6
40374424:	e0dc      	bnez.n	a0, 40374446 <_iram_text_start+0x42>
40374426:	600c      	movi.n	a0, 6
40374428:	4d18      	l32i.n	a1, a13, 16
4037442a:	3fc9      	s32i.n	a12, a15, 12
4037442c:	c94d14        	ee.vld.l.64.ip	q0, a1, 0xfffffe68
4037442f:	c94d103f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q4, q2, q4, q5
40374433:	0263dc3f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 192, q7, q2, q6, q3
40374437:	203c      	movi.n	a0, 50
40374439:	400007        	bnone	a0, a0, 4037447d <_iram_text_start+0x79>
4037443c:	9f0c      	movi.n	a15, 9
4037443e:	c04200        	sub	a4, a2, a0
40374441:	400006        	j	40384445 <_iram_bss_end+0x2045>
40374444:	0017c4        	ee.ld.qacc_l.l.128.ip	a12, 0x170
40374447:	1d1842        	l16ui	a4, a8, 58
4037444a:	644200        	extui	a4, a0, 2, 7
4037444d:	40          	.byte	0x40
4037444e:	600c      	movi.n	a0, 6
40374450:	0c4004        	ee.st.qacc_l.l.128.ip	a0, 0x400
40374453:	553860        	extui	a3, a6, 24, 6
40374456:	3fc9      	s32i.n	a12, a15, 12
40374458:	4cc8      	l32i.n	a12, a12, 16
4037445a:	3fc9      	s32i.n	a12, a15, 12
4037445c:	000000        	ill
4037445f:	50          	.byte	0x50
40374460:	000000        	ill
40374463:	50          	.byte	0x50
40374464:	004000        	break	0, 0
40374467:	800000        	add	a0, a0, a0
4037446a:	360000        	ee.ldf.64.xp	f0, f3, a0, a0
4037446d:	420197        	bnone	a1, a9, 403744b3 <_iram_text_start+0xaf>
40374470:	20          	.byte	0x20
40374471:	420000        	xorb	b0, b0, b0
40374474:	0000ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q0
40374478:	a4          	.byte	0xa4
40374479:	3c0292        	l8ui	a9, a2, 60
4037447c:	020020        	andb	b0, b0, b2
4037447f:	383c      	movi.n	a8, 51
40374481:	24          	.byte	0x24
40374482:	3fc9      	s32i.n	a12, a15, 12
40374484:	032c      	movi.n	a3, 32
40374486:	02          	.byte	0x2
40374487:	383c      	movi.n	a8, 51
40374489:	3c0205        	call0	403b04ac <_iram_bss_end+0x2e0ac>
4037448c:	4d08      	l32i.n	a0, a13, 16
4037448e:	3fc9      	s32i.n	a12, a15, 12
40374490:	000000        	ill
40374493:	60          	.byte	0x60
40374494:	ff0fffff 	ee.vmulas.u8.qacc.ld.ip	q7, a15, -16, q7, q6
40374498:	ff          	.byte	0xff
40374499:	54fff00f 	ee.vmulas.u16.qacc.ld.ip.qup	q1, a0, 0x100, q7, q7, q7, q7
4037449d:	3c0205        	call0	403b04c0 <_iram_bss_end+0x2e0c0>
403744a0:	026404        	ee.st.accx.ip	a0, 0x320
403744a3:	b83c      	movi.n	a8, 59
403744a5:	3c0205        	call0	403b04c8 <_iram_bss_end+0x2e0c8>
403744a8:	05fc      	bnez.n	a5, 403744dc <_iram_text_start+0xd8>
403744aa:	02          	.byte	0x2
403744ab:	ff3c      	movi.n	a15, 63
403744ad:	3d          	.byte	0x3d
403744ae:	3e001c1e 	ee.vmulas.s8.qacc.ld.ip.qup	q4, a1, -64, q0, q2, q0, q0
403744b2:	057c1c1e 	ee.vmulas.s16.accx.ld.ip.qup	q3, a1, 0x1c0, q0, q2, q7, q4
403744b6:	00          	.byte	00
403744b7:	11e840        	slli	a14, a8, 12
403744ba:	00          	.byte	00
403744bb:	1a1c40        	sub.s	f1, f12, f4
403744be:	00          	.byte	00
403744bf:	1a2840        	sub.s	f2, f8, f4
403744c2:	c04000        	sub	a4, a0, a0
403744c5:	0018      	l32i.n	a1, a0, 0
403744c7:	40          	.byte	0x40
403744c8:	001914        	ee.ld.qacc_l.l.128.ip	a1, 0x190
403744cb:	40          	.byte	0x40
403744cc:	14          	.byte	0x14
403744cd:	8442009f 	ee.ldf.128.ip	f8, f5, f0, f4, a9, 0
403744d1:	0019      	s32i.n	a1, a0, 0
403744d3:	42          	.byte	0x42
403744d4:	74          	.byte	0x74
403744d5:	4200a0        	xorb	b0, b0, b10
403744d8:	54          	.byte	0x54
403744d9:	4200b0        	xorb	b0, b0, b11
403744dc:	0005d0        	callx4	a5
403744df:	17e840        	ee.stf.64.xp	f14, f1, a4, a8
403744e2:	504200        	iitlb	a2
403744e5:	0019      	s32i.n	a1, a0, 0
403744e7:	40          	.byte	0x40
403744e8:	19ac      	beqz.n	a9, 4037450d <_iram_text_start+0x109>
403744ea:	d44200        	extui	a4, a0, 2, 14
403744ed:	001a      	add.n	a0, a0, a1
403744ef:	069c42        	l16si	a4, a12, 12
403744f2:	444000        	extui	a4, a0, 0, 5
403744f5:	400025        	call8	403b44f8 <_iram_bss_end+0x320f8>
403744f8:	3e0c      	movi.n	a14, 3
403744fa:	b44200        	extui	a4, a0, 2, 12
403744fd:	420052        	l8ui	a5, a0, 66
40374500:	0011f4        	ee.ld.qacc_l.l.128.ip	a15, 0x110
40374503:	543c40        	extui	a3, a4, 12, 6
40374506:	00          	.byte	00
40374507:	42          	.byte	0x42
40374508:	2b38      	l32i.n	a3, a11, 8
4037450a:	00          	.byte	00
4037450b:	ffff42        	s32ri	a4, a15, 0x3fc
4037450e:	4d28fdff 	ee.vmulas.u16.accx.ld.ip.qup	q3, a15, -48, q7, q6, q2, q0
40374512:	3fc9      	s32i.n	a12, a15, 12
40374514:	040025        	call8	40378518 <rtc_clk_bbpll_configure+0x14c>
40374517:	5a2000        	msub.s	f2, f0, f0
4037451a:	204037        	ball	a0, a3, 4037453e <_iram_text_start+0x13a>
4037451d:	00          	.byte	00
4037451e:	600c      	movi.n	a0, 6
40374520:	0018      	l32i.n	a1, a0, 0
40374522:	600c      	movi.n	a0, 6
40374524:	6018      	l32i.n	a1, a0, 24
40374526:	af6002        	s32i	a0, a0, 0x2bc
40374529:	0700003f 	ee.vmulas.s16.accx.ld.ip.qup	q6, a3, 0x100, q4, q0, q0, q0
4037452d:	201200        	or	a1, a2, a0
40374530:	0c0024        	ee.st.qacc_l.l.128.ip	a2, 0
40374533:	004460        	break	4, 6
40374536:	600c      	movi.n	a0, 6
40374538:	026430        	andb	b6, b4, b3
4037453b:	383c      	movi.n	a8, 51
4037453d:	64          	.byte	0x64
4037453e:	02          	.byte	0x2
4037453f:	543c      	movi.n	a4, 53
40374541:	600041        	l32r	a4, 4034c544 <rom_rx_gain_force+0x346118>
40374544:	4158      	l32i.n	a5, a1, 16
40374546:	00          	.byte	00
40374547:	415c60        	srli	a5, a6, 12
4037454a:	606000        	neg	a6, a0
4037454d:	600041        	l32r	a4, 4034c550 <rom_rx_gain_force+0x346124>
40374550:	004164        	ee.ld.qacc_l.l.128.ip	a6, 0x410
40374553:	416860        	srli	a6, a6, 8
40374556:	046000        	extui	a6, a0, 0, 1
40374559:	00          	.byte	00
4037455a:	600c      	movi.n	a0, 6
4037455c:	0dbc      	beqz.n	a13, 40374590 <_iram_text_start+0x18c>
4037455e:	e04000        	subx4	a4, a0, a0
40374561:	000d      	mov.n	a0, a0
40374563:	40          	.byte	0x40
40374564:	000dd4        	ee.ld.qacc_l.l.128.ip	a13, 208
40374567:	40          	.byte	0x40
40374568:	0e28      	l32i.n	a2, a14, 0
4037456a:	00          	.byte	00
4037456b:	40          	.byte	0x40
4037456c:	0dec      	bnez.n	a13, 40374590 <_iram_text_start+0x18c>
4037456e:	044000        	extui	a4, a0, 0, 1
40374571:	e440000e 	ee.cmul.s16.st.incp	q4, a0, q0, q0, q0, 0
40374575:	400006        	j	40384579 <_iram_bss_end+0x2179>
40374578:	186c      	movi.n	a8, -31
4037457a:	844000        	extui	a4, a0, 0, 9
4037457d:	0018      	l32i.n	a1, a0, 0
4037457f:	240040        	extui	a0, a4, 0, 3
40374582:	3fc9      	s32i.n	a12, a15, 12
40374584:	4d2c      	movi.n	a13, 36
40374586:	3fc9      	s32i.n	a12, a15, 12
40374588:	0e1c      	movi.n	a14, 16
4037458a:	00          	.byte	00
4037458b:	40          	.byte	0x40
4037458c:	4d3c      	movi.n	a13, 52
4037458e:	3fc9      	s32i.n	a12, a15, 12
40374590:	4d38      	l32i.n	a3, a13, 16
40374592:	3fc9      	s32i.n	a12, a15, 12
40374594:	1c68      	l32i.n	a6, a12, 4
40374596:	904200        	addx2	a4, a2, a0
40374599:	420023        	lsi	f2, a0, 0x108
4037459c:	4d48      	l32i.n	a4, a13, 16
4037459e:	3fc9      	s32i.n	a12, a15, 12
403745a0:	2418      	l32i.n	a1, a4, 8
403745a2:	3fc9      	s32i.n	a12, a15, 12
403745a4:	000000        	ill
403745a7:	003c10        	rfi	12
403745aa:	600c      	movi.n	a0, 6
403745ac:	0038      	l32i.n	a3, a0, 0
403745ae:	600c      	movi.n	a0, 6
403745b0:	c94d54        	ee.vld.l.64.ip	q0, a5, 0xfffffe68
403745b3:	c94d503f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q5, q2, q4, q5
403745b7:	c94d4c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q5, q0, q4, q5
403745bb:	c924143f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q4, q2, q2, q4
403745bf:	0209fc3f 	ee.vmulas.s16.accx.ld.ip.qup	q5, a3, 192, q7, q6, q0, q1
403745c3:	983c      	movi.n	a8, 57
403745c5:	9c3c020e 	ee.stf.128.xp	f9, f8, f0, f3, a0, a2
403745c9:	e83c020e 	ee.vsubs.s32.st.incp	q3, a0, q4, q0, q0
403745cd:	1442001f 	ee.vmulas.s16.qacc.ld.ip.qup	q0, a1, 0x100, q4, q0, q4, q2
403745d1:	420020        	xorb	b0, b0, b2
403745d4:	377ff0        	ee.stf.64.xp	f7, f3, a15, a15
403745d7:	c0          	.byte	0xc0
403745d8:	077fe0        	ee.stf.64.xp	f7, f0, a14, a15
403745db:	200000        	or	a0, a0, a0
403745de:	f0          	.byte	0xf0
403745df:	001fff9f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a9, 240, q7, q6, q1, q7
403745e3:	000000        	ill
403745e6:	b04000        	addx8	a4, a0, a0
403745e9:	c03c020e 	ee.vmulas.u16.accx.ld.xp.qup	q1, a0, a2, q0, q0, q3, q4
403745ed:	d03c020e 	ee.fft.ams.s16.ld.incp	q2, a0, q0, q2, q0, q3, q4, 0
403745f1:	e03c020e 	ee.src.q.ld.ip	q4, a0, 0x220, q0, q3
403745f5:	543c020e 	ee.vmulas.u16.qacc.ld.ip.qup	q1, a0, 0x120, q0, q0, q3, q4
403745f9:	e03c020f 	ee.src.q.ld.ip	q4, a0, 0x220, q4, q3
403745fd:	3c0265        	call8	403b0624 <_iram_bss_end+0x2e224>
40374600:	0f8c      	beqz.n	a15, 40374604 <_iram_text_start+0x200>
40374602:	02          	.byte	0x2
40374603:	603c      	movi.n	a0, 54
40374605:	4d          	.byte	0x4d
40374606:	3fc9      	s32i.n	a12, a15, 12
40374608:	c94d64        	ee.vld.l.64.ip	q0, a6, 0xfffffe68
4037460b:	c94d583f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q5, q2, q4, q5
4037460f:	c94d7c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q5, q6, q4, q5
40374613:	c94d743f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q5, q6, q4, q5
40374617:	c94d6c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q5, q4, q4, q5
4037461b:	c94d843f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q6, q0, q4, q5
4037461f:	0024f03f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0, q7, q6, q2, q4
40374623:	4d9c42        	l16si	a4, a12, 154
40374626:	3fc9      	s32i.n	a12, a15, 12
40374628:	007000        	waiti	0
4037462b:	60          	.byte	0x60
4037462c:	c94f34        	ee.vld.l.64.ip	q0, a3, 0xfffffe78
4037462f:	0000003f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0, q4, q0, q0, q0
40374633:	684c02        	s8i	a0, a12, 104
40374636:	02          	.byte	0x2
40374637:	3c3c      	movi.n	a12, 51
40374639:	24          	.byte	0x24
4037463a:	3fc9      	s32i.n	a12, a15, 12
4037463c:	001800        	movsp	a0, a8
4037463f:	140000        	extui	a0, a0, 0, 2
40374642:	000000        	ill
40374645:	10          	.byte	0x10
40374646:	300000        	xor	a0, a0, a0
40374649:	0268      	l32i.n	a6, a2, 0
4037464b:	003c      	movi.n	a0, 48
4037464d:	0268      	l32i.n	a6, a2, 0
4037464f:	143c      	movi.n	a4, 49
40374651:	0268      	l32i.n	a6, a2, 0
40374653:	ec3c      	movi.n	a12, 62
40374655:	3c0267        	bnone	a2, a6, 40374695 <_iram_text_start+0x291>
40374658:	0267d4        	ee.st.accx.ip	a13, 0x338
4037465b:	003c      	movi.n	a0, 48
4037465d:	c03780        	sub	a3, a7, a8
40374660:	00067fff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q5, q6, q0, q6
40374664:	2048      	l32i.n	a4, a0, 8
40374666:	02          	.byte	0x2
40374667:	4c3c      	movi.n	a12, 52
40374669:	026b      	addi.n	a0, a2, 6
4037466b:	b23c      	movi.n	a2, 59
4037466d:	20          	.byte	0x20
4037466e:	02          	.byte	0x2
4037466f:	fc3c      	movi.n	a12, 63
40374671:	7f          	.byte	0x7f
40374672:	fcc037        	bnall	a0, a3, 40374672 <_iram_text_start+0x26e>
40374675:	c49ff01f 	ee.vmulas.u16.qacc.ld.xp.qup	q1, a1, a0, q7, q7, q1, q7
40374679:	20          	.byte	0x20
4037467a:	02          	.byte	0x2
4037467b:	143c      	movi.n	a4, 49
4037467d:	3c0221        	l32r	a2, 40343688 <rom_rx_gain_force+0x33d25c>
40374680:	2128      	l32i.n	a2, a1, 8
40374682:	02          	.byte	0x2
40374683:	003c      	movi.n	a0, 48
40374685:	006f00        	rsil	a0, 15
40374688:	00          	.byte	00
40374689:	80          	.byte	0x80
4037468a:	bfc8      	l32i.n	a12, a15, 44
4037468c:	4f38      	l32i.n	a3, a15, 16
4037468e:	3fc9      	s32i.n	a12, a15, 12
40374690:	2138      	l32i.n	a3, a1, 8
40374692:	02          	.byte	0x2
40374693:	643c      	movi.n	a4, 54
40374695:	026b      	addi.n	a0, a2, 6
40374697:	ff3c      	movi.n	a15, 63
40374699:	7801ffff 	ee.vmulas.u8.qacc.ld.ip.qup	q0, a15, 0xfffffef0, q7, q6, q0, q1
4037469d:	3c0221        	l32r	a2, 403436a8 <rom_rx_gain_force+0x33d27c>
403746a0:	026b34        	ee.st.accx.ip	a3, 0x358
403746a3:	b43c      	movi.n	a4, 59
403746a5:	3c0221        	l32r	a2, 403436b0 <rom_rx_gain_force+0x33d284>
403746a8:	ffe8      	l32i.n	a14, a15, 60
403746aa:	4240600f 	ee.vmulas.u16.accx.ld.ip.qup	q4, a0, 0, q5, q4, q4, q0
403746ae:	1a40000f 	ee.vmulas.s16.qacc.ld.ip.qup	q4, a0, 0xfffffe00, q4, q0, q4, q0
403746b2:	004000        	break	0, 0
403746b5:	b4          	.byte	0xb4
403746b6:	c4          	.byte	0xc4
403746b7:	b3ff04        	ee.vld.128.ip	q7, a0, 0x7f0
403746ba:	4c04c4        	ee.st.qacc_l.l.128.ip	a12, 0xfffff840
403746bd:	24          	.byte	0x24
403746be:	3fc9      	s32i.n	a12, a15, 12
403746c0:	4f48      	l32i.n	a4, a15, 16
403746c2:	3fc9      	s32i.n	a12, a15, 12
403746c4:	4f3c      	movi.n	a15, 52
403746c6:	3fc9      	s32i.n	a12, a15, 12
403746c8:	40          	.byte	0x40
403746c9:	543fc94f 	ee.vmulas.u16.qacc.ld.ip.qup	q1, a4, 0x190, q7, q0, q3, q7
403746cd:	001b      	addi.n	a0, a0, 1
403746cf:	221840        	orb	b1, b8, b4
403746d2:	02          	.byte	0x2
403746d3:	943c      	movi.n	a4, 57
403746d5:	026b      	addi.n	a0, a2, 6
403746d7:	443c      	movi.n	a4, 52
403746d9:	3c0222        	l8ui	a2, a2, 60
403746dc:	8048      	l32i.n	a4, a0, 32
403746de:	006000        	rsil	a0, 0
403746e1:	2d          	.byte	0x2d
403746e2:	3fc9      	s32i.n	a12, a15, 12
403746e4:	2d08      	l32i.n	a0, a13, 8
403746e6:	3fc9      	s32i.n	a12, a15, 12
403746e8:	804c      	movi.n	a0, 72
403746ea:	00          	.byte	00
403746eb:	60          	.byte	0x60
403746ec:	2d0c      	movi.n	a13, 2
403746ee:	3fc9      	s32i.n	a12, a15, 12
403746f0:	008000        	any4	b0, b0:b1:b2:b3
403746f3:	60          	.byte	0x60
403746f4:	10          	.byte	0x10
403746f5:	2d          	.byte	0x2d
403746f6:	3fc9      	s32i.n	a12, a15, 12
403746f8:	c92d14        	ee.vld.l.64.ip	q0, a1, 0xfffffd68
403746fb:	c94f843f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q6, q0, q4, q7
403746ff:	c92d443f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q5, q0, q2, q5
40374703:	c92d183f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q4, q2, q2, q5
40374707:	0006d83f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 128, q7, q2, q0, q6
4037470b:	40          	.byte	0x40
4037470c:	70          	.byte	0x70
4037470d:	3fc952        	addi	a5, a9, 63
40374710:	2508      	l32i.n	a0, a5, 8
40374712:	3fc9      	s32i.n	a12, a15, 12
40374714:	3c6c      	movi.n	a12, -29
40374716:	02          	.byte	0x2
40374717:	bc3c      	movi.n	a12, 59
40374719:	3c0273        	lsi	f7, a2, 240
4037471c:	023cb4        	ee.st.accx.ip	a11, 0x1e0
4037471f:	bc3c      	movi.n	a12, 59
40374721:	023c      	movi.n	a2, 48
40374723:	e83c      	movi.n	a8, 62
40374725:	3c0273        	lsi	f7, a2, 240
40374728:	5cb8      	l32i.n	a11, a12, 20
4037472a:	02          	.byte	0x2
4037472b:	d03c      	movi.n	a0, 61
4037472d:	3c0273        	lsi	f7, a2, 240
40374730:	023cd0        	andb	b3, b12, b13
40374733:	003c      	movi.n	a0, 48
40374735:	74          	.byte	0x74
40374736:	02          	.byte	0x2
40374737:	333c      	movi.n	a3, 51
40374739:	bb10c4        	ee.vst.h.64.ip	q6, a12, 128
4037473c:	52e8      	l32i.n	a14, a2, 20
4037473e:	3fc9      	s32i.n	a12, a15, 12
40374740:	c95294        	ee.vld.l.64.ip	q0, a9, 0xfffffe90
40374743:	0380003f 	ee.vmulas.s16.accx.ld.ip.qup	q6, a3, 0, q4, q1, q0, q0
40374747:	536460        	max	a6, a4, a6
4037474a:	3fc9      	s32i.n	a12, a15, 12
4037474c:	60          	.byte	0x60
4037474d:	3fc953        	ssip	f5, a9, 252
40374750:	024c14        	ee.st.accx.ip	a1, 0x260
40374753:	243c      	movi.n	a4, 50
40374755:	00          	.byte	00
40374756:	000004        	ee.ld.qacc_l.l.128.ip	a0, 0
40374759:	c00000        	sub	a0, a0, a0
4037475c:	c0          	.byte	0xc0
4037475d:	3fc927        	bnall	a9, a2, 403747a0 <_iram_text_start+0x39c>
40374760:	f4          	.byte	0xf4
40374761:	376c      	movi.n	a7, -29
40374763:	770040        	ee.stf.64.xp	f0, f7, a4, a0
40374766:	02          	.byte	0x2
40374767:	c03c      	movi.n	a0, 60
40374769:	c929      	s32i.n	a2, a9, 48
4037476b:	c929e03f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q7, q4, q2, q1
4037476f:	0276e03f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 0, q7, q4, q7, q6
40374773:	213c      	movi.n	a1, 50
40374775:	00          	.byte	00
40374776:	04          	.byte	0x4
40374777:	37ff00        	ee.stf.64.xp	f15, f3, a0, a15
4037477a:	c00006        	j	4036477e <rom_rx_gain_force+0x35e352>
4037477d:	3fc925        	call8	403b4410 <_iram_bss_end+0x32010>
40374780:	7128      	l32i.n	a2, a1, 28
40374782:	224037        	ball	a0, a3, 403747a8 <_iram_text_start+0x3a4>
40374785:	00          	.byte	00
40374786:	000004        	ee.ld.qacc_l.l.128.ip	a0, 0
40374789:	00          	.byte	00
4037478a:	0038      	l32i.n	a3, a0, 0
4037478c:	71d8      	l32i.n	a13, a1, 28
4037478e:	234037        	ball	a0, a3, 403747b5 <_iram_text_start+0x3b1>
40374791:	00          	.byte	00
40374792:	000004        	ee.ld.qacc_l.l.128.ip	a0, 0
40374795:	c088      	l32i.n	a8, a0, 48
40374797:	3828      	l32i.n	a2, a8, 12
40374799:	024c      	movi.n	a2, 64
4037479b:	103c      	movi.n	a0, 49
4037479d:	3c0277        	bnone	a2, a7, 403747dd <_iram_text_start+0x3d9>
403747a0:	024c81        	l32r	a8, 403350d0 <rom_rx_gain_force+0x32eca4>
403747a3:	943c      	movi.n	a4, 57
403747a5:	024c      	movi.n	a2, 64
403747a7:	003c      	movi.n	a0, 48
403747a9:	600020        	neg	a0, a2
403747ac:	200000        	or	a0, a0, a0
403747af:	000000        	ill
403747b2:	008000        	any4	b0, b0:b1:b2:b3
403747b5:	00          	.byte	00
403747b6:	00          	.byte	00
403747b7:	70          	.byte	0x70
403747b8:	bfffffff 	ee.vmulas.s8.qacc.ld.xp.qup	q7, a15, a15, q7, q7, q7, q7
403747bc:	e4          	.byte	0xe4
403747bd:	ff          	.byte	0xff
403747be:	ce          	.byte	0xce
403747bf:	3f          	.byte	0x3f
403747c0:	dfffffff 	ee.fft.cmul.s16.ld.xp	q7, a15, a15, q7, q7, q7, 7
403747c4:	ff          	.byte	0xff
403747c5:	ff          	.byte	0xff
403747c6:	ff          	.byte	0xff
403747c7:	fffff7        	bbsi	a15, 31, 403747ca <_iram_text_start+0x3c6>
403747ca:	0000efff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q4, q0, q0
403747ce:	580004        	mula.da.ll.lddec	m0, a0, m0, a0
403747d1:	600020        	neg	a0, a2
403747d4:	7fffffff 	ee.vmulas.u8.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q7, q7
403747d8:	003000        	rfe
403747db:	60          	.byte	0x60
403747dc:	41ffffff 	ee.vmulas.u16.accx.ld.ip.qup	q3, a15, 240, q7, q7, q7, q7
403747e0:	43ffffff 	ee.vmulas.u16.accx.ld.ip.qup	q7, a15, 240, q7, q7, q7, q7
403747e4:	3bffffff 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a15, 0xfffffef0, q7, q7, q7, q7
403747e8:	3dffffff 	ee.vmulas.s8.qacc.ld.ip.qup	q3, a15, -16, q7, q7, q7, q7
403747ec:	0233b0        	andb	b3, b3, b11
403747ef:	903c      	movi.n	a0, 57
403747f1:	3c0277        	bnone	a2, a7, 40374831 <_iram_text_start+0x42d>
403747f4:	020504        	ee.st.accx.ip	a0, 40
403747f7:	803c      	movi.n	a0, 56
403747f9:	3fc953        	ssip	f5, a9, 252
403747fc:	0008      	l32i.n	a0, a0, 0
403747fe:	1e          	.byte	0x1e
403747ff:	00          	.byte	00
40374800:	ff          	.byte	0xff
40374801:	ff          	.byte	0xff
40374802:	fff9      	s32i.n	a15, a15, 60
40374804:	ff          	.byte	0xff
40374805:	ff          	.byte	0xff
40374806:	fffff7        	bbsi	a15, 31, 40374809 <_iram_text_start+0x405>
40374809:	7f          	.byte	0x7f
4037480a:	e40007        	bnone	a0, a0, 403747f2 <_iram_text_start+0x3ee>
4037480d:	3c0251        	l32r	a5, 40343818 <rom_rx_gain_force+0x33d3ec>
40374810:	7948      	l32i.n	a4, a9, 28
40374812:	02          	.byte	0x2
40374813:	d33c      	movi.n	a3, 61
40374815:	3c0251        	l32r	a5, 40343820 <rom_rx_gain_force+0x33d3f4>
40374818:	c92a14        	ee.vld.l.64.ip	q0, a1, 0xfffffd50
4037481b:	02520c3f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 192, q4, q0, q5, q2
4037481f:	243c      	movi.n	a4, 50
40374821:	3c0252        	l8ui	a5, a2, 60
40374824:	b3          	.byte	0xb3
40374825:	3fc953        	ssip	f5, a9, 252
40374828:	78d8      	l32i.n	a13, a8, 28
4037482a:	b84037        	ball	a0, a3, 403747e6 <_iram_text_start+0x3e2>
4037482d:	3fc953        	ssip	f5, a9, 252
40374830:	b4          	.byte	0xb4
40374831:	484200ae 	ee.vmulas.u16.accx.ld.ip.qup	q0, a10, 0xfffffe00, q0, q0, q4, q2
40374835:	0029      	s32i.n	a2, a0, 0
40374837:	53b242        	l32ai	a4, a2, 0x14c
4037483a:	3fc9      	s32i.n	a12, a15, 12
4037483c:	5238      	l32i.n	a3, a2, 20
4037483e:	02          	.byte	0x2
4037483f:	143c      	movi.n	a4, 49
40374841:	0279      	s32i.n	a7, a2, 0
40374843:	503c      	movi.n	a0, 53
40374845:	3c0252        	l8ui	a5, a2, 60
40374848:	aec8      	l32i.n	a12, a14, 40
4037484a:	004200        	break	2, 0
4037484d:	00          	.byte	00
4037484e:	0000ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q0
40374852:	c00001        	l32r	a0, 40364854 <rom_rx_gain_force+0x35e428>
40374855:	3fc953        	ssip	f5, a9, 252
40374858:	000894        	ee.ld.qacc_l.l.128.ip	a9, 128
4037485b:	40          	.byte	0x40
4037485c:	03          	.byte	0x3
4037485d:	60          	.byte	0x60
4037485e:	00          	.byte	00
4037485f:	00          	.byte	00
40374860:	3978      	l32i.n	a7, a9, 12
40374862:	3fc9      	s32i.n	a12, a15, 12
40374864:	0000270f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a0, 112, q4, q4, q0, q0
40374868:	00004e1f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a1, 224, q5, q0, q0, q0
4037486c:	30          	.byte	0x30
4037486d:	00          	.byte	00
4037486e:	600c      	movi.n	a0, 6
40374870:	0c0034        	ee.st.qacc_l.l.128.ip	a3, 0
40374873:	2a7c60        	mul.s	f7, f12, f6
40374876:	3fc9      	s32i.n	a12, a15, 12
40374878:	b5dc      	bnez.n	a5, 40374897 <_iram_text_start+0x493>
4037487a:	00          	.byte	00
4037487b:	56cc42        	addi	a4, a12, 86
4037487e:	02          	.byte	0x2
4037487f:	b83c      	movi.n	a8, 59
40374881:	027a      	add.n	a0, a2, a7
40374883:	143c      	movi.n	a4, 49
40374885:	3c0257        	bnone	a2, a5, 403748c5 <_iram_text_start+0x4c1>
40374888:	d0          	.byte	0xd0
40374889:	3fc953        	ssip	f5, a9, 252
4037488c:	000000        	ill
4037488f:	00fc      	bnez.n	a0, 403748c3 <_iram_text_start+0x4bf>
40374891:	03f000        	rsr.ccompare0	a0
40374894:	0221c4        	ee.st.accx.ip	a12, 0x108
40374897:	843c      	movi.n	a4, 56
40374899:	026b      	addi.n	a0, a2, 6
4037489b:	103c      	movi.n	a0, 49
4037489d:	3c0222        	l8ui	a2, a2, 60
403748a0:	008000        	any4	b0, b0:b1:b2:b3
403748a3:	80bc60        	add	a11, a12, a6
403748a6:	746000        	extui	a6, a0, 0, 8
403748a9:	026b      	addi.n	a0, a2, 6
403748ab:	543c      	movi.n	a4, 53
403748ad:	600080        	neg	a0, a8
403748b0:	c92444        	ee.vld.l.64.ip	q0, a4, 0xfffffd20
403748b3:	c924403f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q5, q0, q2, q4
403748b7:	0000003f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0, q4, q0, q0, q0
403748bb:	c90000be 	ee.vmulas.u8.accx.ld.xp.qup	q2, a11, a0, q0, q0, q0, q0
403748bf:	06ffffbf 	ee.vmulas.s16.accx.ld.ip.qup	q5, a11, 0x1f0, q7, q7, q7, q7
403748c3:	00          	.byte	00
403748c4:	0005ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q5
403748c8:	c93c94        	ee.vld.l.64.ip	q0, a9, 0xfffffde0
403748cb:	c93b243f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q4, q4, q3, q3
403748cf:	c93e343f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q4, q6, q3, q6
403748d3:	0600033f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 0x130, q4, q0, q0, q0
403748d7:	00          	.byte	00
403748d8:	3e68      	l32i.n	a6, a14, 12
403748da:	3fc9      	s32i.n	a12, a15, 12
403748dc:	c93b44        	ee.vld.l.64.ip	q0, a4, 0xfffffdd8
403748df:	c93eb43f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q6, q6, q3, q6
403748e3:	0030143f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 64, q4, q2, q3, q0
403748e7:	201460        	or	a1, a4, a6
403748ea:	006000        	rsil	a0, 0
403748ed:	c93b      	addi.n	a12, a9, 3
403748ef:	0030503f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0, q5, q2, q3, q0
403748f3:	33fc60        	clamps	a15, a12, 13
403748f6:	00          	.byte	00
403748f7:	3b6860        	ueq.s	b6, f8, f6
403748fa:	3fc9      	s32i.n	a12, a15, 12
403748fc:	00          	.byte	00
403748fd:	000c      	movi.n	a0, 0
403748ff:	00          	.byte	00
40374900:	c94f54        	ee.vld.l.64.ip	q0, a5, 0xfffffe78
40374903:	c924543f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q5, q2, q2, q4
40374907:	c924843f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q6, q0, q2, q4
4037490b:	005d543f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a3, 64, q5, q2, q5, q5
4037490f:	40          	.byte	0x40
40374910:	60          	.byte	0x60
40374911:	005d      	mov.n	a5, a0
40374913:	40          	.byte	0x40
40374914:	5d6c      	movi.n	a13, -27
40374916:	904000        	addx2	a4, a0, a0
40374919:	1c3fc94f 	ee.vmulas.s16.qacc.ld.ip.qup	q1, a4, -112, q7, q0, q3, q7
4037491d:	3d          	.byte	0x3d
4037491e:	3fc9      	s32i.n	a12, a15, 12
40374920:	3b8c      	beqz.n	a11, 40374927 <_iram_text_start+0x523>
40374922:	3fc9      	s32i.n	a12, a15, 12
40374924:	6d          	.byte	0x6d
40374925:	3d          	.byte	0x3d
40374926:	3fc9      	s32i.n	a12, a15, 12
40374928:	10          	.byte	0x10
40374929:	00          	.byte	00
4037492a:	600c      	movi.n	a0, 6
4037492c:	40          	.byte	0x40
4037492d:	6000e0        	neg	a0, a14
40374930:	4f88      	l32i.n	a8, a15, 16
40374932:	3fc9      	s32i.n	a12, a15, 12
40374934:	0084c0        	any4	b12, b4:b5:b6:b7
40374937:	60          	.byte	0x60
40374938:	080000        	lsx	f0, a0, a0
4037493b:	84c400        	extui	a12, a0, 4, 9
4037493e:	606000        	neg	a6, a0
40374941:	600080        	neg	a0, a8
40374944:	ff          	.byte	0xff
40374945:	ff          	.byte	0xff
40374946:	7f          	.byte	0x7f
40374947:	ff          	.byte	0xff
40374948:	ff          	.byte	0xff
40374949:	00fff1ff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 16, q7, q7, q7, q7
4037494d:	00          	.byte	00
4037494e:	ff0006        	j	40374552 <_iram_text_start+0x14e>
40374951:	1f          	.byte	0x1f
40374952:	ff          	.byte	0xff
40374953:	ff          	.byte	0xff
40374954:	ff          	.byte	0xff
40374955:	e3          	.byte	0xe3
40374956:	ff          	.byte	0xff
40374957:	ff          	.byte	0xff
40374958:	ff          	.byte	0xff
40374959:	40fffeff 	ee.vmulas.u16.accx.ld.ip.qup	q1, a15, 224, q7, q7, q7, q7
4037495d:	600090        	neg	a0, a9
40374960:	008800        	any4	b0, b8:b9:b10:b11
40374963:	80d860        	add	a13, a8, a6
40374966:	006000        	rsil	a0, 0
40374969:	008000        	any4	b0, b0:b1:b2:b3
4037496c:	ff          	.byte	0xff
4037496d:	74ffff7f 	ee.vmulas.u8.qacc.ld.ip.qup	q1, a7, 0x1f0, q7, q7, q7, q7
40374971:	600080        	neg	a0, a8
40374974:	801c      	movi.n	a0, 24
40374976:	00          	.byte	00
40374977:	c03f60        	sub	a3, a15, a6
4037497a:	3c94ffff 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a15, -16, q7, q7, q1, q4
4037497e:	3fc9      	s32i.n	a12, a15, 12
40374980:	3bbc      	beqz.n	a11, 403749b7 <_iram_text_start+0x5b3>
40374982:	3fc9      	s32i.n	a12, a15, 12
40374984:	3d78      	l32i.n	a7, a13, 12
40374986:	3fc9      	s32i.n	a12, a15, 12
40374988:	018cb0        	slli	a8, a12, 21
4037498b:	134042        	s8i	a4, a0, 19
4037498e:	070002        	l8ui	a0, a0, 7
40374991:	010b      	addi.n	a0, a1, -1
40374993:	000000        	ill
40374996:	c02000        	sub	a2, a0, a0
40374999:	600080        	neg	a0, a8
4037499c:	b0          	.byte	0xb0
4037499d:	3d          	.byte	0x3d
4037499e:	3fc9      	s32i.n	a12, a15, 12
403749a0:	3db8      	l32i.n	a11, a13, 12
403749a2:	3fc9      	s32i.n	a12, a15, 12
403749a4:	60          	.byte	0x60
403749a5:	00          	.byte	00
403749a6:	600c      	movi.n	a0, 6
403749a8:	c93df4        	ee.vld.l.64.ip	q0, a15, 0xfffffde8
403749ab:	c94f8c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q6, q0, q4, q7
403749af:	6666673f 	ee.vmulas.u8.accx.ld.ip.qup	q4, a3, 0x170, q5, q4, q6, q6
403749b3:	246466        	bnei	a4, 6, 403749db <_iram_text_start+0x5d7>
403749b6:	3fc9      	s32i.n	a12, a15, 12
403749b8:	2468      	l32i.n	a6, a4, 8
403749ba:	3fc9      	s32i.n	a12, a15, 12
403749bc:	81fc      	bnez.n	a1, 403749f8 <_iram_text_start+0x5f4>
403749be:	00          	.byte	00
403749bf:	60          	.byte	0x60
403749c0:	ff          	.byte	0xff
403749c1:	1f          	.byte	0x1f
403749c2:	fff8      	l32i.n	a15, a15, 60
403749c4:	ff          	.byte	0xff
403749c5:	f3          	.byte	0xf3
403749c6:	245cffff 	ee.vmulas.s8.accx.ld.ip.qup	q1, a15, 0x1f0, q7, q6, q5, q4
403749ca:	3fc9      	s32i.n	a12, a15, 12
403749cc:	60          	.byte	0x60
403749cd:	24          	.byte	0x24
403749ce:	3fc9      	s32i.n	a12, a15, 12
403749d0:	1a4c      	movi.n	a10, 65
403749d2:	00          	.byte	00
403749d3:	40          	.byte	0x40
403749d4:	3e28      	l32i.n	a2, a14, 12
403749d6:	3fc9      	s32i.n	a12, a15, 12
403749d8:	c93ba4        	ee.vld.l.64.ip	q0, a10, 0xfffffdd8
403749db:	00e0003f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0, q4, q1, q6, q0
403749df:	809000        	add	a9, a0, a0
403749e2:	00          	.byte	00
403749e3:	808860        	add	a8, a8, a6
403749e6:	00          	.byte	00
403749e7:	f7ff60        	ee.stf.64.xp	f15, f15, a6, a15
403749ea:	609cffff 	ee.vmulas.u8.accx.ld.ip.qup	q1, a15, 240, q7, q7, q1, q4
403749ee:	546002        	s32i	a0, a0, 0x150
403749f1:	6001d0        	abs	a0, a13
403749f4:	d4          	.byte	0xd4
403749f5:	01cc      	bnez.n	a1, 403749f9 <_iram_text_start+0x5f5>
403749f7:	609060        	neg	a9, a6
403749fa:	f06000        	subx8	a6, a0, a0
403749fd:	600050        	neg	a0, a5
40374a00:	0260b0        	andb	b6, b0, b11
40374a03:	60          	.byte	0x60
40374a04:	3ff8      	l32i.n	a15, a15, 12
40374a06:	070000        	ee.stf.64.xp	f0, f0, a0, a0
40374a09:	c0          	.byte	0xc0
40374a0a:	ff          	.byte	0xff
40374a0b:	01f068ff 	ee.vmulas.s16.accx.ld.ip.qup	q2, a15, 128, q5, q5, q7, q0
40374a0f:	f08060        	subx8	a8, a0, a6
40374a12:	ff6001        	l32r	a0, 40374794 <_iram_text_start+0x390> (28c08800 <UserFrameTotalSize+0x28c08700>)
40374a15:	9f          	.byte	0x9f
40374a16:	ff          	.byte	0xff
40374a17:	ff          	.byte	0xff
40374a18:	ff          	.byte	0xff
40374a19:	ef          	.byte	0xef
40374a1a:	ff          	.byte	0xff
40374a1b:	00ffffff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 240, q7, q7, q7, q7
40374a1f:	f06c80        	subx8	a6, a12, a8
40374a22:	d06001        	l32r	a0, 40368ba4 <rom_rx_gain_force+0x362778>
40374a25:	24          	.byte	0x24
40374a26:	02          	.byte	0x2
40374a27:	cc3c      	movi.n	a12, 60
40374a29:	026c      	movi.n	a2, -32
40374a2b:	0d3c      	movi.n	a13, 48
40374a2d:	3c0225        	call8	403b0a50 <_iram_bss_end+0x2e650>
40374a30:	2518      	l32i.n	a1, a5, 8
40374a32:	02          	.byte	0x2
40374a33:	b43c      	movi.n	a4, 59
40374a35:	026c      	movi.n	a2, -32
40374a37:	743c      	movi.n	a4, 55
40374a39:	400025        	call8	403b4a3c <_iram_bss_end+0x3263c>
40374a3c:	800c      	movi.n	a0, 8
40374a3e:	106000        	and	a6, a0, a0
40374a41:	600080        	neg	a0, a8
40374a44:	14          	.byte	0x14
40374a45:	600080        	neg	a0, a8
40374a48:	000000        	ill
40374a4b:	000012        	l8ui	a1, a0, 0
40374a4e:	600c      	movi.n	a0, 6
40374a50:	002000        	isync
40374a53:	00          	.byte	00
40374a54:	ff          	.byte	0xff
40374a55:	00ffffdf 	ee.vmulas.s16.accx.ld.ip.qup	q1, a13, 240, q7, q7, q7, q7
40374a59:	6001f0        	abs	a0, a15
40374a5c:	ff          	.byte	0xff
40374a5d:	d4ffffbf 	ee.fft.ams.s16.ld.incp.uaup	q7, a11, q7, q3, q7, q7, q7, 0
40374a61:	c93b      	addi.n	a12, a9, 3
40374a63:	c93f843f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q6, q0, q3, q7
40374a67:	c93f8c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q6, q0, q3, q7
40374a6b:	c93f2c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q4, q4, q3, q7
40374a6f:	c93bec3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q7, q4, q3, q3
40374a73:	c93f703f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q5, q6, q3, q7
40374a77:	c929e43f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q7, q4, q2, q1
40374a7b:	0c41303f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0xffffff00, q4, q6, q4, q1
40374a7f:	189c60        	lsxp	f9, a12, a6
40374a82:	b44000        	extui	a4, a0, 0, 12
40374a85:	0018      	l32i.n	a1, a0, 0
40374a87:	18e440        	lsxp	f14, a4, a4
40374a8a:	00          	.byte	00
40374a8b:	18fc40        	lsxp	f15, a12, a4
40374a8e:	184000        	lsxp	f4, a0, a0
40374a91:	600030        	neg	a0, a3
40374a94:	000000        	ill
40374a97:	301c50        	xor	a1, a12, a5
40374a9a:	206000        	or	a6, a0, a0
40374a9d:	600030        	neg	a0, a3
40374aa0:	e0          	.byte	0xe0
40374aa1:	600030        	neg	a0, a3
40374aa4:	0008a0        	jx	a8
40374aa7:	40          	.byte	0x40
40374aa8:	60          	.byte	0x60
40374aa9:	000c      	movi.n	a0, 0
40374aab:	243040        	extui	a3, a4, 0, 3
40374aae:	3fc9      	s32i.n	a12, a15, 12
40374ab0:	0006b4        	ee.ld.qacc_l.l.128.ip	a11, 96
40374ab3:	40          	.byte	0x40
40374ab4:	ffb9      	s32i.n	a11, a15, 60
40374ab6:	ce          	.byte	0xce
40374ab7:	ceffb83f 	ee.vmulas.u8.qacc.ld.xp.qup	q5, a3, a8, q6, q7, q7, q7
40374abb:	0005e83f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 128, q7, q4, q0, q5
40374abf:	428040        	xorb	b8, b0, b4
40374ac2:	3fc9      	s32i.n	a12, a15, 12
40374ac4:	429c      	beqz.n	a2, 40374adc <_iram_text_start+0x6d8>
40374ac6:	3fc9      	s32i.n	a12, a15, 12
40374ac8:	c942a4        	ee.vld.l.64.ip	q0, a10, 0xfffffe10
40374acb:	c942b03f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q6, q6, q4, q2
40374acf:	3796893f 	ee.vmulas.s8.qacc.ld.ip.qup	q6, a3, 0x190, q6, q1, q1, q6
40374ad3:	42dc40        	xorb	b13, b12, b4
40374ad6:	3fc9      	s32i.n	a12, a15, 12
40374ad8:	2f98      	l32i.n	a9, a15, 8
40374ada:	02          	.byte	0x2
40374adb:	fc3c      	movi.n	a12, 63
40374add:	213c026f 	ee.vmulas.s8.accx.ld.ip.qup	q3, a6, 32, q4, q0, q3, q4
40374ae1:	000d      	mov.n	a0, a0
40374ae3:	00          	.byte	00
40374ae4:	022fd6        	bgez	a15, 40374b0a <_iram_text_start+0x706>
40374ae7:	e03c      	movi.n	a0, 62
40374ae9:	223c022f 	ee.vmulas.s8.accx.ld.ip.qup	q5, a2, 32, q4, q0, q3, q4
40374aed:	000d      	mov.n	a0, a0
40374aef:	302800        	xor	a2, a8, a0
40374af2:	02          	.byte	0x2
40374af3:	c03c      	movi.n	a0, 60
40374af5:	70          	.byte	0x70
40374af6:	02          	.byte	0x2
40374af7:	ff3c      	movi.n	a15, 63
40374af9:	30b33fff 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a15, 240, q4, q7, q3, q3
40374afd:	30          	.byte	0x30
40374afe:	02          	.byte	0x2
40374aff:	543c      	movi.n	a4, 53
40374b01:	30          	.byte	0x30
40374b02:	02          	.byte	0x2
40374b03:	903c      	movi.n	a0, 57
40374b05:	70          	.byte	0x70
40374b06:	02          	.byte	0x2
40374b07:	643c      	movi.n	a4, 54
40374b09:	30          	.byte	0x30
40374b0a:	02          	.byte	0x2
40374b0b:	803c      	movi.n	a0, 56
40374b0d:	30          	.byte	0x30
40374b0e:	02          	.byte	0x2
40374b0f:	7c3c      	movi.n	a12, 55
40374b11:	70          	.byte	0x70
40374b12:	02          	.byte	0x2
40374b13:	8c3c      	movi.n	a12, 56
40374b15:	30          	.byte	0x30
40374b16:	02          	.byte	0x2
40374b17:	643c      	movi.n	a4, 54
40374b19:	70          	.byte	0x70
40374b1a:	02          	.byte	0x2
40374b1b:	183c      	movi.n	a8, 49
40374b1d:	70          	.byte	0x70
40374b1e:	02          	.byte	0x2
40374b1f:	983c      	movi.n	a8, 57
40374b21:	30          	.byte	0x30
40374b22:	02          	.byte	0x2
40374b23:	f03c      	movi.n	a0, 63
40374b25:	30          	.byte	0x30
40374b26:	02          	.byte	0x2
40374b27:	403c      	movi.n	a0, 52
40374b29:	3c0231        	l32r	a3, 40343b34 <rom_rx_gain_force+0x33d708>
40374b2c:	16a8      	l32i.n	a10, a6, 4
40374b2e:	02          	.byte	0x2
40374b2f:	ac3c      	movi.n	a12, 58
40374b31:	70          	.byte	0x70
40374b32:	02          	.byte	0x2
40374b33:	d83c      	movi.n	a8, 61
40374b35:	3c0216        	beqz	a2, 40374ef9 <_iram_text_start+0xaf5>
40374b38:	023194        	ee.st.accx.ip	a9, 0x188
40374b3b:	483c      	movi.n	a8, 52
40374b3d:	70          	.byte	0x70
40374b3e:	02          	.byte	0x2
40374b3f:	e83c      	movi.n	a8, 62
40374b41:	9c3c026f 	ee.stf.128.xp	f9, f9, f0, f3, a6, a2
40374b45:	3c0231        	l32r	a3, 40343b50 <rom_rx_gain_force+0x33d724>
40374b48:	31b8      	l32i.n	a11, a1, 12
40374b4a:	02          	.byte	0x2
40374b4b:	1c3c      	movi.n	a12, 49
40374b4d:	3c0232        	l8ui	a3, a2, 60
40374b50:	026fd4        	ee.st.accx.ip	a13, 0x378
40374b53:	2c3c      	movi.n	a12, 50
40374b55:	70          	.byte	0x70
40374b56:	02          	.byte	0x2
40374b57:	bc3c      	movi.n	a12, 59
40374b59:	6d3c026f 	ee.vmulas.u8.accx.ld.ip.qup	q3, a6, -224, q4, q0, q3, q4
40374b5d:	0008      	l32i.n	a0, a0, 0
40374b5f:	328400        	orbc	b8, b4, b0
40374b62:	02          	.byte	0x2
40374b63:	6e3c      	movi.n	a14, 54
40374b65:	0008      	l32i.n	a0, a0, 0
40374b67:	00          	.byte	00
40374b68:	6fac      	beqz.n	a15, 40374b92 <_iram_text_start+0x78e>
40374b6a:	02          	.byte	0x2
40374b6b:	333c      	movi.n	a3, 51
40374b6d:	0009      	s32i.n	a0, a0, 0
40374b6f:	00          	.byte	00
40374b70:	3918      	l32i.n	a1, a9, 12
40374b72:	02          	.byte	0x2
40374b73:	243c      	movi.n	a4, 50
40374b75:	0239      	s32i.n	a3, a2, 0
40374b77:	683c      	movi.n	a8, 54
40374b79:	0239      	s32i.n	a3, a2, 0
40374b7b:	783c      	movi.n	a8, 55
40374b7d:	3fc952        	addi	a5, a9, 63
40374b80:	0239d0        	andb	b3, b9, b13
40374b83:	583c      	movi.n	a8, 53
40374b85:	3c0273        	lsi	f7, a2, 240
40374b88:	3c023a2e 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a2, -96, q0, q6, q0, q2
40374b8c:	a4          	.byte	0xa4
40374b8d:	3c0292        	l8ui	a9, a2, 60
40374b90:	10          	.byte	0x10
40374b91:	000000        	ill
40374b94:	020120        	andb	b0, b1, b2
40374b97:	943c      	movi.n	a4, 57
40374b99:	3040379e 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a9, 112, q0, q6, q4, q0
40374b9d:	00          	.byte	00
40374b9e:	b30005        	call0	40327ba0 <rom_rx_gain_force+0x321774>
40374ba1:	3c0292        	l8ui	a9, a2, 60
40374ba4:	1c38      	l32i.n	a3, a12, 4
40374ba6:	00          	.byte	00
40374ba7:	16a840        	ee.ldf.64.xp	f10, f1, a4, a8
40374baa:	02          	.byte	0x2
40374bab:	443c      	movi.n	a4, 52
40374bad:	3c0273        	lsi	f7, a2, 240
40374bb0:	16d8      	l32i.n	a13, a6, 4
40374bb2:	02          	.byte	0x2
40374bb3:	383c      	movi.n	a8, 51
40374bb5:	023a      	add.n	a0, a2, a3
40374bb7:	603c      	movi.n	a0, 54
40374bb9:	023a      	add.n	a0, a2, a3
40374bbb:	803c      	movi.n	a0, 56
40374bbd:	023a      	add.n	a0, a2, a3
40374bbf:	663c      	movi.n	a6, 54
40374bc1:	000066        	bnei	a0, -1, 40374bc5 <_iram_text_start+0x7c1>
40374bc4:	023a94        	ee.st.accx.ip	a9, 0x1d0
40374bc7:	d83c      	movi.n	a8, 61
40374bc9:	023a      	add.n	a0, a2, a3
40374bcb:	683c      	movi.n	a8, 54
40374bcd:	3fc952        	addi	a5, a9, 63
40374bd0:	60          	.byte	0x60
40374bd1:	3fc952        	addi	a5, a9, 63
40374bd4:	731c      	movi.n	a3, 23
40374bd6:	02          	.byte	0x2
40374bd7:	ec3c      	movi.n	a12, 62
40374bd9:	023a      	add.n	a0, a2, a3
40374bdb:	0c3c      	movi.n	a12, 48
40374bdd:	023b      	addi.n	a0, a2, 3
40374bdf:	203c      	movi.n	a0, 50
40374be1:	023b      	addi.n	a0, a2, 3
40374be3:	303c      	movi.n	a0, 51
40374be5:	3c0273        	lsi	f7, a2, 240
40374be8:	3b2c      	movi.n	a11, 35
40374bea:	02          	.byte	0x2
40374beb:	543c      	movi.n	a4, 53
40374bed:	023b      	addi.n	a0, a2, 3
40374bef:	743c      	movi.n	a4, 55
40374bf1:	400013        	lsi	f1, a0, 0x100
40374bf4:	5258      	l32i.n	a5, a2, 20
40374bf6:	3fc9      	s32i.n	a12, a15, 12
40374bf8:	50          	.byte	0x50
40374bf9:	3fc952        	addi	a5, a9, 63
40374bfc:	60          	.byte	0x60
40374bfd:	3fc933        	ssip	f3, a9, 252
40374c00:	3968      	l32i.n	a6, a9, 12
40374c02:	3fc9      	s32i.n	a12, a15, 12
40374c04:	c93964        	ee.vld.l.64.ip	q0, a6, 0xfffffdc8
40374c07:	3f          	.byte	0x3f
40374c08:	f0          	.byte	0xf0
40374c09:	60fffbff 	ee.vmulas.u8.accx.ld.ip.qup	q1, a15, 176, q7, q7, q7, q7
40374c0d:	c939      	s32i.n	a3, a9, 48
40374c0f:	0008043f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a3, 64, q4, q0, q0, q0
40374c13:	00          	.byte	00
40374c14:	00757fff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q5, q6, q7, q5
40374c18:	000000        	ill
40374c1b:	3b68b0        	ueq.s	b6, f8, f11
40374c1e:	02          	.byte	0x2
40374c1f:	703c      	movi.n	a0, 55
40374c21:	3c0273        	lsi	f7, a2, 240
40374c24:	3b9a      	add.n	a3, a11, a9
40374c26:	02          	.byte	0x2
40374c27:	a83c      	movi.n	a8, 58
40374c29:	023b      	addi.n	a0, a2, 3
40374c2b:	803c      	movi.n	a0, 56
40374c2d:	3fc952        	addi	a5, a9, 63
40374c30:	a70c      	movi.n	a7, 10
40374c32:	c44037        	ball	a0, a3, 40374bfa <_iram_text_start+0x7f6>
40374c35:	023b      	addi.n	a0, a2, 3
40374c37:	983c      	movi.n	a8, 57
40374c39:	3c0273        	lsi	f7, a2, 240
40374c3c:	023c44        	ee.st.accx.ip	a4, 0x1e0
40374c3f:	903c      	movi.n	a0, 57
40374c41:	3c0273        	lsi	f7, a2, 240
40374c44:	10          	.byte	0x10
40374c45:	000027        	bnone	a0, a2, 40374c49 <_iram_text_start+0x845>
40374c48:	1388      	l32i.n	a8, a3, 4
40374c4a:	180000        	lsxp	f0, a0, a0
40374c4d:	003a      	add.n	a0, a0, a3
40374c4f:	42          	.byte	0x42
40374c50:	528c      	beqz.n	a2, 40374c59 <_iram_text_start+0x855>
40374c52:	3fc9      	s32i.n	a12, a15, 12
40374c54:	a0          	.byte	0xa0
40374c55:	303fc94f 	ee.vmulas.s8.qacc.ld.ip.qup	q1, a4, 144, q7, q0, q3, q7
40374c59:	50          	.byte	0x50
40374c5a:	3fc9      	s32i.n	a12, a15, 12
40374c5c:	b0          	.byte	0xb0
40374c5d:	d83fc94f 	ee.fft.ams.s16.ld.r32.decp	q1, a4, q0, q3, q7, q3, q7, 0
40374c61:	3c0232        	l8ui	a3, a2, 60
40374c64:	0272c4        	ee.st.accx.ip	a12, 0x390
40374c67:	1a3c      	movi.n	a10, 49
40374c69:	3c0233        	lsi	f3, a2, 240
40374c6c:	4fcc      	bnez.n	a15, 40374c74 <_iram_text_start+0x870>
40374c6e:	3fc9      	s32i.n	a12, a15, 12
40374c70:	505c      	movi.n	a0, 85
40374c72:	3fc9      	s32i.n	a12, a15, 12
40374c74:	023324        	ee.st.accx.ip	a2, 0x198
40374c77:	5c3c      	movi.n	a12, 53
40374c79:	3c0272        	l8ui	a7, a2, 60
40374c7c:	0e3a      	add.n	a0, a14, a3
40374c7e:	00          	.byte	00
40374c7f:	334c00        	clamps	a4, a12, 7
40374c82:	02          	.byte	0x2
40374c83:	fc3c      	movi.n	a12, 63
40374c85:	3c0272        	l8ui	a7, a2, 60
40374c88:	134b      	addi.n	a1, a3, 4
40374c8a:	00          	.byte	00
40374c8b:	d39800        	movt	a9, a8, b0
40374c8e:	004200        	break	2, 0
40374c91:	3fc925        	call8	403b4924 <_iram_bss_end+0x32524>
40374c94:	f0          	.byte	0xf0
40374c95:	d43fc94f 	ee.fft.ams.s16.ld.incp.uaup	q1, a4, q0, q3, q7, q3, q7, 0
40374c99:	4f          	.byte	0x4f
40374c9a:	3fc9      	s32i.n	a12, a15, 12
40374c9c:	4fec      	bnez.n	a15, 40374cc4 <_iram_text_start+0x8c0>
40374c9e:	3fc9      	s32i.n	a12, a15, 12
40374ca0:	4ff8      	l32i.n	a15, a15, 16
40374ca2:	3fc9      	s32i.n	a12, a15, 12
40374ca4:	d0          	.byte	0xd0
40374ca5:	d83fc94f 	ee.fft.ams.s16.ld.r32.decp	q1, a4, q0, q3, q7, q3, q7, 0
40374ca9:	2c3fc94f 	ee.vmulas.s8.accx.ld.ip.qup	q1, a4, -112, q7, q0, q3, q7
40374cad:	50          	.byte	0x50
40374cae:	3fc9      	s32i.n	a12, a15, 12
40374cb0:	29f8      	l32i.n	a15, a9, 8
40374cb2:	804200        	add	a4, a2, a0
40374cb5:	3c0233        	lsi	f3, a2, 240
40374cb8:	7138      	l32i.n	a3, a1, 28
40374cba:	02          	.byte	0x2
40374cbb:	e83c      	movi.n	a8, 62
40374cbd:	420061        	l32r	a6, 403454c0 <rom_rx_gain_force+0x33f094>
40374cc0:	5048      	l32i.n	a4, a0, 20
40374cc2:	3fc9      	s32i.n	a12, a15, 12
40374cc4:	c95034        	ee.vld.l.64.ip	q0, a3, 0xfffffe80
40374cc7:	c950043f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q4, q0, q5, q0
40374ccb:	c94fc83f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q7, q0, q4, q7
40374ccf:	c94fb43f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q6, q6, q4, q7
40374cd3:	02339c3f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 192, q6, q2, q3, q3
40374cd7:	7c3c      	movi.n	a12, 55
40374cd9:	3c0272        	l8ui	a7, a2, 60
40374cdc:	000c87        	bnone	a12, a8, 40374ce0 <_iram_text_start+0x8dc>
40374cdf:	33b400        	clamps	a11, a4, 7
40374ce2:	02          	.byte	0x2
40374ce3:	a73c      	movi.n	a7, 58
40374ce5:	000c      	movi.n	a0, 0
40374ce7:	00          	.byte	00
40374ce8:	4fb8      	l32i.n	a11, a15, 16
40374cea:	3fc9      	s32i.n	a12, a15, 12
40374cec:	4fbc      	beqz.n	a15, 40374d24 <_iram_text_start+0x920>
40374cee:	3fc9      	s32i.n	a12, a15, 12
40374cf0:	c94fc4        	ee.vld.l.64.ip	q0, a12, 0xfffffe78
40374cf3:	a5a5a53f 	ee.fft.ams.s16.st.incp	q2, q2, a3, a5, q5, q6, q5, 1
40374cf7:	342ca5        	call8	403a8fc0 <_iram_bss_end+0x26bc0>
40374cfa:	02          	.byte	0x2
40374cfb:	443c      	movi.n	a4, 52
40374cfd:	3c0272        	l8ui	a7, a2, 60
40374d00:	000ea1        	l32r	a10, 40334d38 <rom_rx_gain_force+0x32e90c>
40374d03:	343800        	extui	a3, a0, 8, 4
40374d06:	02          	.byte	0x2
40374d07:	283c      	movi.n	a8, 50
40374d09:	3c0272        	l8ui	a7, a2, 60
40374d0c:	000f36        	entry	a15, 0
40374d0f:	344800        	extui	a4, a0, 8, 4
40374d12:	02          	.byte	0x2
40374d13:	593c      	movi.n	a9, 53
40374d15:	8400000f 	ee.ldf.128.ip	f8, f1, f0, f0, a0, 0
40374d19:	34          	.byte	0x34
40374d1a:	02          	.byte	0x2
40374d1b:	103c      	movi.n	a0, 49
40374d1d:	3c0272        	l8ui	a7, a2, 60
40374d20:	001046        	j	40374d65 <_iram_text_start+0x961>
40374d23:	349000        	extui	a9, a0, 0, 4
40374d26:	02          	.byte	0x2
40374d27:	473c      	movi.n	a7, 52
40374d29:	10          	.byte	0x10
40374d2a:	a00000        	addx4	a0, a0, a0
40374d2d:	34          	.byte	0x34
40374d2e:	02          	.byte	0x2
40374d2f:	dc3c      	movi.n	a12, 61
40374d31:	3c0272        	l8ui	a7, a2, 60
40374d34:	023394        	ee.st.accx.ip	a9, 0x198
40374d37:	903c      	movi.n	a0, 57
40374d39:	3c0272        	l8ui	a7, a2, 60
40374d3c:	0adc      	bnez.n	a10, 40374d50 <_iram_text_start+0x94c>
40374d3e:	00          	.byte	00
40374d3f:	34b800        	extui	a11, a0, 8, 4
40374d42:	02          	.byte	0x2
40374d43:	0c3c      	movi.n	a12, 48
40374d45:	3c0273        	lsi	f7, a2, 240
40374d48:	0272f0        	andb	b7, b2, b15
40374d4b:	383c      	movi.n	a8, 51
40374d4d:	3c0235        	call12	403b0d70 <_iram_bss_end+0x2e970>
40374d50:	0272a0        	andb	b7, b2, b10
40374d53:	253c      	movi.n	a5, 50
40374d55:	000a      	add.n	a0, a0, a0
40374d57:	35b800        	extui	a11, a0, 24, 4
40374d5a:	02          	.byte	0x2
40374d5b:	f83c      	movi.n	a8, 63
40374d5d:	3c0271        	l32r	a7, 40343d68 <rom_rx_gain_force+0x33d93c>
40374d60:	001424        	ee.ld.qacc_l.l.128.ip	a2, 0x140
40374d63:	35e400        	extui	a14, a0, 20, 4
40374d66:	02          	.byte	0x2
40374d67:	253c      	movi.n	a5, 50
40374d69:	000014        	ee.ld.qacc_l.l.128.ip	a1, 0
40374d6c:	0271d4        	ee.st.accx.ip	a13, 0x388
40374d6f:	7b3c      	movi.n	a11, 55
40374d71:	000014        	ee.ld.qacc_l.l.128.ip	a1, 0
40374d74:	35fc      	bnez.n	a5, 40374dab <_iram_text_start+0x9a7>
40374d76:	02          	.byte	0x2
40374d77:	963c      	movi.n	a6, 57
40374d79:	000014        	ee.ld.qacc_l.l.128.ip	a1, 0
40374d7c:	3628      	l32i.n	a2, a6, 12
40374d7e:	02          	.byte	0x2
40374d7f:	bc3c      	movi.n	a12, 59
40374d81:	3c0271        	l32r	a7, 40343d8c <rom_rx_gain_force+0x33d960>
40374d84:	001666        	bnei	a6, 1, 40374d88 <_iram_text_start+0x984>
40374d87:	363c00        	ee.ldf.64.xp	f3, f3, a0, a12
40374d8a:	02          	.byte	0x2
40374d8b:	a83c      	movi.n	a8, 58
40374d8d:	3c0271        	l32r	a7, 40343d98 <rom_rx_gain_force+0x33d96c>
40374d90:	001714        	ee.ld.qacc_l.l.128.ip	a1, 0x170
40374d93:	365000        	ee.ldf.64.xp	f5, f3, a0, a0
40374d96:	02          	.byte	0x2
40374d97:	153c      	movi.n	a5, 49
40374d99:	000017        	bnone	a0, a1, 40374d9d <_iram_text_start+0x999>
40374d9c:	023660        	andb	b3, b6, b6
40374d9f:	4a3c      	movi.n	a10, 52
40374da1:	000017        	bnone	a0, a1, 40374da5 <_iram_text_start+0x9a1>
40374da4:	023680        	andb	b3, b6, b8
40374da7:	593c      	movi.n	a9, 53
40374da9:	000017        	bnone	a0, a1, 40374dad <_iram_text_start+0x9a9>
40374dac:	7188      	l32i.n	a8, a1, 28
40374dae:	02          	.byte	0x2
40374daf:	1b3c      	movi.n	a11, 49
40374db1:	0018      	l32i.n	a1, a0, 0
40374db3:	181c00        	lsxp	f1, a12, a0
40374db6:	450000        	extui	a0, a0, 16, 5
40374db9:	0018      	l32i.n	a1, a0, 0
40374dbb:	36c000        	ee.ldf.64.xp	f12, f3, a0, a0
40374dbe:	02          	.byte	0x2
40374dbf:	683c      	movi.n	a8, 54
40374dc1:	3c0271        	l32r	a7, 40343dcc <rom_rx_gain_force+0x33d9a0>
40374dc4:	36f8      	l32i.n	a15, a6, 12
40374dc6:	02          	.byte	0x2
40374dc7:	183c      	movi.n	a8, 49
40374dc9:	3c0237        	bnone	a2, a3, 40374e09 <_iram_text_start+0xa05>
40374dcc:	027150        	andb	b7, b1, b5
40374dcf:	d43c      	movi.n	a4, 61
40374dd1:	3c0237        	bnone	a2, a3, 40374e11 <_iram_text_start+0xa0d>
40374dd4:	7118      	l32i.n	a1, a1, 28
40374dd6:	02          	.byte	0x2
40374dd7:	fc3c      	movi.n	a12, 63
40374dd9:	3c0237        	bnone	a2, a3, 40374e19 <_iram_text_start+0xa15>
40374ddc:	023820        	andb	b3, b8, b2
40374ddf:	3c3c      	movi.n	a12, 51
40374de1:	0238      	l32i.n	a3, a2, 0
40374de3:	d03c      	movi.n	a0, 61
40374de5:	ad          	.byte	0xad
40374de6:	a84037        	ball	a0, a3, 40374d92 <_iram_text_start+0x98e>
40374de9:	443fc94f 	ee.vmulas.u16.accx.ld.ip.qup	q1, a4, 0x190, q7, q0, q3, q7
40374ded:	0238      	l32i.n	a3, a2, 0
40374def:	b03c      	movi.n	a0, 59
40374df1:	3c0272        	l8ui	a7, a2, 60
40374df4:	0009a3        	lsi	f10, a9, 0
40374df7:	731800        	maxu	a1, a8, a0
40374dfa:	02          	.byte	0x2
40374dfb:	583c      	movi.n	a8, 53
40374dfd:	0238      	l32i.n	a3, a2, 0
40374dff:	f83c      	movi.n	a8, 63
40374e01:	70          	.byte	0x70
40374e02:	02          	.byte	0x2
40374e03:	e83c      	movi.n	a8, 62
40374e05:	0238      	l32i.n	a3, a2, 0
40374e07:	d43c      	movi.n	a4, 61
40374e09:	70          	.byte	0x70
40374e0a:	02          	.byte	0x2
40374e0b:	b43c      	movi.n	a4, 59
40374e0d:	c92a      	add.n	a12, a9, a2
40374e0f:	0c404c3f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, -64, q5, q0, q4, q0
40374e13:	60          	.byte	0x60
40374e14:	4e1c      	movi.n	a14, 20
40374e16:	3fc9      	s32i.n	a12, a15, 12
40374e18:	a0          	.byte	0xa0
40374e19:	40          	.byte	0x40
40374e1a:	600c      	movi.n	a0, 6
40374e1c:	1878      	l32i.n	a7, a8, 4
40374e1e:	904000        	addx2	a4, a0, a0
40374e21:	0018      	l32i.n	a1, a0, 0
40374e23:	40          	.byte	0x40
40374e24:	3c18      	l32i.n	a1, a12, 12
40374e26:	3fc9      	s32i.n	a12, a15, 12
40374e28:	45ec      	bnez.n	a5, 40374e50 <_iram_text_start+0xa4c>
40374e2a:	3fc9      	s32i.n	a12, a15, 12
40374e2c:	3c4c      	movi.n	a12, 67
40374e2e:	3fc9      	s32i.n	a12, a15, 12
40374e30:	45d8      	l32i.n	a13, a5, 16
40374e32:	3fc9      	s32i.n	a12, a15, 12
40374e34:	c945c4        	ee.vld.l.64.ip	q0, a12, 0xfffffe28
40374e37:	c945b03f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q6, q6, q4, q5
40374e3b:	0018a83f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a3, 128, q6, q4, q1, q0
40374e3f:	40          	.byte	0x40
40374e40:	00          	.byte	00
40374e41:	40          	.byte	0x40
40374e42:	600c      	movi.n	a0, 6
40374e44:	60          	.byte	0x60
40374e45:	40          	.byte	0x40
40374e46:	600c      	movi.n	a0, 6
40374e48:	bdffffff 	ee.vmulas.s8.qacc.ld.xp.qup	q3, a15, a15, q7, q7, q7, q7
40374e4c:	000000        	ill
40374e4f:	c4          	.byte	0xc4
40374e50:	c3ffffff 	ee.vmulas.u16.accx.ld.xp.qup	q7, a15, a15, q7, q7, q7, q7
40374e54:	0016b0        	movsp	a11, a6
40374e57:	459c40        	extui	a9, a4, 28, 5
40374e5a:	3fc9      	s32i.n	a12, a15, 12
40374e5c:	4588      	l32i.n	a8, a5, 16
40374e5e:	3fc9      	s32i.n	a12, a15, 12
40374e60:	0018f0        	movsp	a15, a8
40374e63:	40          	.byte	0x40
40374e64:	1908      	l32i.n	a0, a9, 4
40374e66:	00          	.byte	00
40374e67:	40          	.byte	0x40
40374e68:	3c6c      	movi.n	a12, -29
40374e6a:	3fc9      	s32i.n	a12, a15, 12
40374e6c:	4568      	l32i.n	a6, a5, 16
40374e6e:	3fc9      	s32i.n	a12, a15, 12
40374e70:	c93c94        	ee.vld.l.64.ip	q0, a9, 0xfffffde0
40374e73:	c945503f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q5, q2, q4, q5
40374e77:	c93c9c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q6, q2, q3, q4
40374e7b:	0015fc3f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 192, q7, q6, q1, q5
40374e7f:	160840        	ee.ldf.64.xp	f0, f1, a4, a8
40374e82:	00          	.byte	00
40374e83:	42ec40        	xorb	b14, b12, b4
40374e86:	3fc9      	s32i.n	a12, a15, 12
40374e88:	50          	.byte	0x50
40374e89:	3fc946        	j	40384db2 <_iram_bss_end+0x29b2>
40374e8c:	430c      	movi.n	a3, 4
40374e8e:	3fc9      	s32i.n	a12, a15, 12
40374e90:	00          	.byte	00
40374e91:	14          	.byte	0x14
40374e92:	03          	.byte	0x3
40374e93:	3818      	l32i.n	a1, a8, 12
40374e95:	3fc946        	j	40384dbe <_iram_bss_end+0x29be>
40374e98:	4618      	l32i.n	a1, a6, 16
40374e9a:	3fc9      	s32i.n	a12, a15, 12
40374e9c:	3fffffff 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q7, q7
40374ea0:	40          	.byte	0x40
40374ea1:	3fc943        	ssip	f4, a9, 252
40374ea4:	00          	.byte	00
40374ea5:	3fc946        	j	40384dce <_iram_bss_end+0x29ce>
40374ea8:	c94374        	ee.vld.l.64.ip	q0, a7, 0xfffffe18
40374eab:	0000003f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0, q4, q0, q0, q0
40374eaf:	000042        	l8ui	a4, a0, 0
40374eb2:	943c00        	extui	a3, a0, 12, 10
40374eb5:	3fc943        	ssip	f4, a9, 252
40374eb8:	469c      	beqz.n	a6, 40374ed0 <_iram_text_start+0xacc>
40374eba:	3fc9      	s32i.n	a12, a15, 12
40374ebc:	c943b4        	ee.vld.l.64.ip	q0, a11, 0xfffffe18
40374ebf:	c943d43f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q7, q2, q4, q3
40374ec3:	c944083f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a8, q4, q0, q4, q4
40374ec7:	c946843f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q6, q0, q4, q6
40374ecb:	c9446c3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q5, q4, q4, q4
40374ecf:	c9466c3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q5, q4, q4, q6
40374ed3:	c944cc3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q7, q0, q4, q4
40374ed7:	c946b03f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q6, q6, q4, q6
40374edb:	c9450c3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q4, q0, q4, q5
40374edf:	0cc0003f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 0xffffff00, q4, q1, q4, q0
40374ee3:	004c60        	break	12, 6
40374ee6:	600c      	movi.n	a0, 6
40374ee8:	44          	.byte	0x44
40374ee9:	c0          	.byte	0xc0
40374eea:	600c      	movi.n	a0, 6
40374eec:	40          	.byte	0x40
40374eed:	c0          	.byte	0xc0
40374eee:	600c      	movi.n	a0, 6
40374ef0:	c048      	l32i.n	a4, a0, 48
40374ef2:	600c      	movi.n	a0, 6
40374ef4:	c04c      	movi.n	a0, 76
40374ef6:	600c      	movi.n	a0, 6
40374ef8:	c058      	l32i.n	a5, a0, 48
40374efa:	600c      	movi.n	a0, 6
40374efc:	50          	.byte	0x50
40374efd:	c0          	.byte	0xc0
40374efe:	600c      	movi.n	a0, 6
40374f00:	54          	.byte	0x54
40374f01:	c0          	.byte	0xc0
40374f02:	600c      	movi.n	a0, 6
40374f04:	9f          	.byte	0x9f
40374f05:	ff3c      	movi.n	a15, 63
40374f07:	ff          	.byte	0xff
40374f08:	ff          	.byte	0xff
40374f09:	00ffffcf 	ee.vmulas.s16.accx.ld.ip.qup	q1, a12, 240, q7, q7, q7, q7
40374f0d:	001000        	movsp	a0, a0
40374f10:	ff          	.byte	0xff
40374f11:	ff          	.byte	0xff
40374f12:	fffb      	addi.n	a15, a15, 15
40374f14:	ff          	.byte	0xff
40374f15:	ff          	.byte	0xff
40374f16:	3f          	.byte	0x3f
40374f17:	fff8      	l32i.n	a15, a15, 60
40374f19:	00ffc1ff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 16, q7, q1, q7, q7
40374f1d:	f00000        	subx8	a0, a0, a0
40374f20:	000000        	ill
40374f23:	bd8f01        	l32r	a0, 40364560 <rom_rx_gain_force+0x35e134>
40374f26:	0000fe6f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a6, 224, q7, q6, q0, q0
40374f2a:	40          	.byte	0x40
40374f2b:	000000        	ill
40374f2e:	00          	.byte	00
40374f2f:	ff5c      	movi.n	a15, 95
40374f31:	fffe01        	l32r	a0, 40374f2c <_iram_text_start+0xb28> (5c000000 <_rtc_bss_end+0xc000000>)
40374f34:	ff          	.byte	0xff
40374f35:	03          	.byte	0x3
40374f36:	f003ffff 	ee.vmulas.s8.qacc.ld.ip	q0, a15, 240, q7, q6
40374f3a:	4dd3ffff 	ee.vmulas.u16.accx.ld.ip.qup	q2, a15, -16, q7, q7, q5, q3
40374f3e:	ff1062        	l16ui	a6, a0, 0x1fe
40374f41:	0081ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q7, q0, q1
40374f45:	0008      	l32i.n	a0, a0, 0
40374f47:	300000        	xor	a0, a0, a0
40374f4a:	ff6002        	s32i	a0, a0, 0x3fc
40374f4d:	d003ffff 	ee.fft.ams.s16.ld.incp	q7, a15, q6, q1, q7, q0, q3, 0
40374f51:	c93c      	movi.n	a9, 60
40374f53:	c946d43f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q7, q2, q4, q6
40374f57:	c93ce43f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q7, q4, q3, q4
40374f5b:	02175c3f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 192, q5, q2, q1, q7
40374f5f:	c03c      	movi.n	a0, 60
40374f61:	3c0217        	bnone	a2, a1, 40374fa1 <_iram_text_start+0xb9d>
40374f64:	026894        	ee.st.accx.ip	a9, 0x340
40374f67:	b23c      	movi.n	a2, 59
40374f69:	3c0217        	bnone	a2, a1, 40374fa9 <_iram_text_start+0xba5>
40374f6c:	1de8      	l32i.n	a14, a13, 4
40374f6e:	02          	.byte	0x2
40374f6f:	203c      	movi.n	a0, 50
40374f71:	0269      	s32i.n	a6, a2, 0
40374f73:	4f3c      	movi.n	a15, 52
40374f75:	0218      	l32i.n	a1, a2, 0
40374f77:	c43c      	movi.n	a4, 60
40374f79:	0218      	l32i.n	a1, a2, 0
40374f7b:	f03c      	movi.n	a0, 63
40374f7d:	0269      	s32i.n	a6, a2, 0
40374f7f:	f73c      	movi.n	a7, 63
40374f81:	0218      	l32i.n	a1, a2, 0
40374f83:	203c      	movi.n	a0, 50
40374f85:	0c3c021e 	ee.vmulas.s16.accx.ld.ip.qup	q1, a1, -224, q0, q0, q3, q4
40374f89:	0269      	s32i.n	a6, a2, 0
40374f8b:	cf3c      	movi.n	a15, 60
40374f8d:	0219      	s32i.n	a1, a2, 0
40374f8f:	4c3c      	movi.n	a12, 52
40374f91:	483c021e 	ee.vmulas.u16.accx.ld.ip.qup	q1, a1, 0xfffffe20, q0, q0, q3, q4
40374f95:	021b      	addi.n	a0, a2, 1
40374f97:	b03c      	movi.n	a0, 59
40374f99:	0269      	s32i.n	a6, a2, 0
40374f9b:	743c      	movi.n	a4, 55
40374f9d:	021b      	addi.n	a0, a2, 1
40374f9f:	943c      	movi.n	a4, 57
40374fa1:	1e          	.byte	0x1e
40374fa2:	02          	.byte	0x2
40374fa3:	fc3c      	movi.n	a12, 63
40374fa5:	0268      	l32i.n	a6, a2, 0
40374fa7:	003c      	movi.n	a0, 48
40374fa9:	000000        	ill
40374fac:	1ecc      	bnez.n	a14, 40374fb1 <_iram_text_start+0xbad>
40374fae:	02          	.byte	0x2
40374faf:	e83c      	movi.n	a8, 62
40374fb1:	0268      	l32i.n	a6, a2, 0
40374fb3:	843c      	movi.n	a4, 56
40374fb5:	0219      	s32i.n	a1, a2, 0
40374fb7:	d03c      	movi.n	a0, 61
40374fb9:	0269      	s32i.n	a6, a2, 0
40374fbb:	e83c      	movi.n	a8, 62
40374fbd:	0219      	s32i.n	a1, a2, 0
40374fbf:	243c      	movi.n	a4, 50
40374fc1:	021a      	add.n	a0, a2, a1
40374fc3:	d43c      	movi.n	a4, 61
40374fc5:	021b      	addi.n	a0, a2, 1
40374fc7:	e43c      	movi.n	a4, 62
40374fc9:	0269      	s32i.n	a6, a2, 0
40374fcb:	143c      	movi.n	a4, 49
40374fcd:	021c      	movi.n	a2, 16
40374fcf:	703c      	movi.n	a0, 55
40374fd1:	0269      	s32i.n	a6, a2, 0
40374fd3:	503c      	movi.n	a0, 53
40374fd5:	021c      	movi.n	a2, 16
40374fd7:	883c      	movi.n	a8, 56
40374fd9:	0269      	s32i.n	a6, a2, 0
40374fdb:	6c3c      	movi.n	a12, 54
40374fdd:	021c      	movi.n	a2, 16
40374fdf:	5c3c      	movi.n	a12, 53
40374fe1:	0269      	s32i.n	a6, a2, 0
40374fe3:	8c3c      	movi.n	a12, 56
40374fe5:	021c      	movi.n	a2, 16
40374fe7:	4c3c      	movi.n	a12, 52
40374fe9:	0269      	s32i.n	a6, a2, 0
40374feb:	bc3c      	movi.n	a12, 59
40374fed:	021c      	movi.n	a2, 16
40374fef:	403c      	movi.n	a0, 52
40374ff1:	0269      	s32i.n	a6, a2, 0
40374ff3:	303c      	movi.n	a0, 51
40374ff5:	021d      	mov.n	a1, a2
40374ff7:	703c      	movi.n	a0, 55
40374ff9:	021d      	mov.n	a1, a2
40374ffb:	c43c      	movi.n	a4, 60
40374ffd:	0269      	s32i.n	a6, a2, 0
40374fff:	bc3c      	movi.n	a12, 59
40375001:	021d      	mov.n	a1, a2
40375003:	2c3c      	movi.n	a12, 50
40375005:	0269      	s32i.n	a6, a2, 0
40375007:	d83c      	movi.n	a8, 61
40375009:	0268      	l32i.n	a6, a2, 0
4037500b:	f83c      	movi.n	a8, 63
4037500d:	c83c021e 	ee.vmulas.u8.accx.ld.xp.qup	q1, a1, a2, q0, q0, q3, q4
40375011:	0268      	l32i.n	a6, a2, 0
40375013:	343c      	movi.n	a4, 51
40375015:	24          	.byte	0x24
40375016:	3fc9      	s32i.n	a12, a15, 12
40375018:	002b64        	ee.ld.qacc_l.l.128.ip	a6, 0x2b0
4037501b:	42          	.byte	0x42
4037501c:	30          	.byte	0x30
4037501d:	203fc94f 	ee.vmulas.s8.accx.ld.ip.qup	q1, a4, 144, q7, q0, q3, q7
40375021:	c43fc94e 	ee.vmulas.u16.qacc.ld.xp.qup	q1, a4, a9, q3, q0, q3, q7
40375025:	420195        	call4	403b7040 <_iram_bss_end+0x34c40>
40375028:	c94e24        	ee.vld.l.64.ip	q0, a2, 0xfffffe70
4037502b:	37fc993f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x190, q6, q3, q7, q4
4037502f:	40          	.byte	0x40
40375030:	3ecc      	bnez.n	a14, 40375037 <_iram_text_start+0xc33>
40375032:	3fc9      	s32i.n	a12, a15, 12
40375034:	3ee8      	l32i.n	a14, a14, 12
40375036:	3fc9      	s32i.n	a12, a15, 12
40375038:	0014c4        	ee.ld.qacc_l.l.128.ip	a12, 0x140
4037503b:	40          	.byte	0x40
4037503c:	37fd06        	j	40383034 <_iram_bss_end+0xc34>
4037503f:	40          	.byte	0x40
40375040:	c93ef4        	ee.vld.l.64.ip	q0, a15, 0xfffffdf0
40375043:	c93f083f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q4, q0, q3, q7
40375047:	c93f0c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q4, q0, q3, q7
4037504b:	c93f1c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q4, q2, q3, q7
4037504f:	c93f203f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q4, q4, q3, q7
40375053:	c93f243f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q4, q4, q3, q7
40375057:	c93f283f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q4, q4, q3, q7
4037505b:	0012483f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 128, q5, q0, q1, q2
4037505f:	535840        	max	a5, a8, a4
40375062:	3fc9      	s32i.n	a12, a15, 12
40375064:	50          	.byte	0x50
40375065:	3fc953        	ssip	f5, a9, 252
40375068:	8058      	l32i.n	a5, a0, 32
4037506a:	00          	.byte	00
4037506b:	805c60        	add	a5, a12, a6
4037506e:	606000        	neg	a6, a0
40375071:	400012        	l8ui	a1, a0, 64
40375074:	2a98      	l32i.n	a9, a10, 8
40375076:	3fc9      	s32i.n	a12, a15, 12
40375078:	c953c4        	ee.vld.l.64.ip	q0, a12, 0xfffffe98
4037507b:	c92a543f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q5, q2, q2, q2
4037507f:	c9398c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q6, q0, q3, q1
40375083:	0253a43f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 64, q6, q4, q5, q3
40375087:	053c      	movi.n	a5, 48
40375089:	60          	.byte	0x60
4037508a:	400000        	ssr	a0
4037508d:	54          	.byte	0x54
4037508e:	02          	.byte	0x2
4037508f:	c43c      	movi.n	a4, 60
40375091:	3c0253        	lsi	f5, a2, 240
40375094:	5468      	l32i.n	a6, a4, 20
40375096:	02          	.byte	0x2
40375097:	c03c      	movi.n	a0, 60
40375099:	0279      	s32i.n	a7, a2, 0
4037509b:	d83c      	movi.n	a8, 61
4037509d:	54          	.byte	0x54
4037509e:	02          	.byte	0x2
4037509f:	803c      	movi.n	a0, 56
403750a1:	420196        	bltz	a1, 403754c5 <call_start_cpu0+0x185>
403750a4:	c953b1        	l32r	a11, 403675f0 <rom_rx_gain_force+0x3611c4>
403750a7:	c953b03f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q6, q6, q5, q3
403750ab:	3f          	.byte	0x3f
403750ac:	00ffffff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 240, q7, q7, q7, q7
403750b0:	c94744        	ee.vld.l.64.ip	q0, a4, 0xfffffe38
403750b3:	c941dc3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q7, q2, q4, q1
403750b7:	c942143f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q4, q2, q4, q2
403750bb:	c947283f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a8, q4, q4, q4, q7
403750bf:	c9424b3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a11, q5, q0, q4, q2
403750c3:	c947103f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q4, q2, q4, q7
403750c7:	c942603f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q5, q4, q4, q2
403750cb:	c946f43f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a4, q7, q6, q4, q6
403750cf:	c93a8c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q6, q0, q3, q2
403750d3:	c9474c3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q5, q0, q4, q7
403750d7:	00bfa43f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a3, 64, q6, q5, q3, q7
403750db:	600042        	l8ui	a4, a0, 96
403750de:	00          	.byte	00
403750df:	0a8c00        	add.s	f8, f12, f0
403750e2:	4038      	l32i.n	a3, a0, 16
403750e4:	c4          	.byte	0xc4
403750e5:	380a      	add.n	a3, a8, a0
403750e7:	40          	.byte	0x40
403750e8:	64          	.byte	0x64
403750e9:	0d          	.byte	0xd
403750ea:	4038      	l32i.n	a3, a0, 16
403750ec:	0dcc      	bnez.n	a13, 403750f0 <_iram_text_start+0xcec>
403750ee:	4038      	l32i.n	a3, a0, 16
403750f0:	c93a74        	ee.vld.l.64.ip	q0, a7, 0xfffffdd0
403750f3:	c93a783f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q5, q6, q3, q2
403750f7:	c93a5c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q5, q2, q3, q2
403750fb:	c949583f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q5, q2, q4, q1
403750ff:	c940903f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q6, q2, q4, q0
40375103:	c940cc3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q7, q0, q4, q0
40375107:	c948a83f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q6, q4, q4, q0
4037510b:	c940ff3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a15, q7, q6, q4, q0
4037510f:	c941183f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a8, q4, q2, q4, q1
40375113:	0021cc3f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 192, q7, q0, q2, q1
40375117:	40          	.byte	0x40
40375118:	00          	.byte	00
40375119:	9c0000cf 	ee.stf.128.xp	f8, f1, f0, f0, a12, a0
4037511d:	0d          	.byte	0xd
4037511e:	4038      	l32i.n	a3, a0, 16
40375120:	b4          	.byte	0xb4
40375121:	0d          	.byte	0xd
40375122:	4038      	l32i.n	a3, a0, 16
40375124:	60          	.byte	0x60
40375125:	21ffff9f 	ee.vmulas.s8.accx.ld.ip.qup	q3, a9, 240, q7, q7, q7, q7
40375129:	dcffffde 	ee.fft.cmul.s16.ld.xp	q7, a13, a15, q7, q3, q7, 1
4037512d:	000023        	lsi	f2, a0, 0
40375130:	ffed12        	s32c1i	a1, a13, 0x3fc
40375133:	0013ecff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 192, q7, q4, q1, q3
40375137:	11ee00        	slli	a14, a14, 16
4037513a:	600000        	neg	a0, a0
4037513d:	3fc941        	l32r	a4, 40345064 <rom_rx_gain_force+0x33ec38>
40375140:	4a9c      	beqz.n	a10, 40375158 <_iram_text_start+0xd54>
40375142:	3fc9      	s32i.n	a12, a15, 12
40375144:	3fc941bf 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a11, -240, q5, q1, q4, q1
40375148:	0000609f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a9, 0, q5, q4, q0, q0
4037514c:	4b48      	l32i.n	a4, a11, 16
4037514e:	3fc9      	s32i.n	a12, a15, 12
40375150:	41dc      	bnez.n	a1, 40375168 <_iram_text_start+0xd64>
40375152:	3fc9      	s32i.n	a12, a15, 12
40375154:	21d8      	l32i.n	a13, a1, 8
40375156:	00          	.byte	00
40375157:	40          	.byte	0x40
40375158:	ff8e71        	l32r	a7, 40374f90 <_iram_text_start+0xb8c> (3c021e4c <_flash_rodata_start+0x1d2c>)
4037515b:	c941f8ff 	ee.vmulas.u8.accx.ld.xp.qup	q2, a15, a8, q7, q6, q4, q1
4037515f:	c94a703f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q5, q6, q4, q2
40375163:	c94c583f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q5, q2, q4, q4
40375167:	c940903f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q6, q2, q4, q0
4037516b:	ceffe83f 	ee.vmulas.u8.qacc.ld.xp.qup	q5, a3, a8, q7, q5, q7, q7
4037516f:	c92a183f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q4, q2, q2, q2
40375173:	0090783f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 128, q5, q7, q1, q0
40375177:	60          	.byte	0x60
40375178:	e0          	.byte	0xe0
40375179:	3f          	.byte	0x3f
4037517a:	3fc9      	s32i.n	a12, a15, 12
4037517c:	3fec      	bnez.n	a15, 403751a3 <_iram_text_start+0xd9f>
4037517e:	3fc9      	s32i.n	a12, a15, 12
40375180:	093c      	movi.n	a9, 48
40375182:	00          	.byte	00
40375183:	08b840        	lsx	f11, a8, a4
40375186:	444000        	extui	a4, a0, 0, 5
40375189:	000a      	add.n	a0, a0, a0
4037518b:	40          	.byte	0x40
4037518c:	60          	.byte	0x60
4037518d:	c94c      	movi.n	a9, 76
4037518f:	cefff43f 	ee.vmulas.u8.qacc.ld.xp.qup	q5, a3, a4, q7, q7, q7, q7
40375193:	0009543f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a3, 64, q5, q2, q0, q1
40375197:	096040        	l32e	a4, a0, -40
4037519a:	00          	.byte	00
4037519b:	08e840        	lsx	f14, a8, a4
4037519e:	00          	.byte	00
4037519f:	2a4c40        	mul.s	f4, f12, f4
403751a2:	3fc9      	s32i.n	a12, a15, 12
403751a4:	53cc      	bnez.n	a3, 403751ad <_iram_text_start+0xda9>
403751a6:	3fc9      	s32i.n	a12, a15, 12
403751a8:	53c8      	l32i.n	a12, a3, 20
403751aa:	3fc9      	s32i.n	a12, a15, 12
403751ac:	402c      	movi.n	a0, 36
403751ae:	3fc9      	s32i.n	a12, a15, 12
403751b0:	002dd4        	ee.ld.qacc_l.l.128.ip	a13, 0x2d0
403751b3:	c5a442        	movi	a4, 0x4c5
403751b6:	f44200        	extui	a4, a0, 2, 16
403751b9:	4200c5        	call0	403b71c8 <_iram_bss_end+0x34dc8>
403751bc:	025684        	ee.st.accx.ip	a8, 0x2b0
403751bf:	9c3c      	movi.n	a12, 57
403751c1:	027a      	add.n	a0, a2, a7
403751c3:	b33c      	movi.n	a3, 59
403751c5:	3c0256        	bnez	a2, 40375589 <call_start_cpu0+0x249>
403751c8:	040020        	extui	a0, a2, 0, 1
	...

403751cc <esp_system_get_time>:
    }
#endif
}

int64_t ESP_TIMER_IRAM_ATTR esp_system_get_time(void)
{
403751cc:	004136        	entry	a1, 32
    return esp_timer_get_time() + s_correction_us;
403751cf:	0001a5        	call8	403751e8 <esp_timer_get_time>
403751d2:	fc8c91        	l32r	a9, 40374404 <_iram_text_start> (3fc94cd8 <s_correction_us>)
403751d5:	002982        	l32i	a8, a9, 0
403751d8:	012992        	l32i	a9, a9, 4
403751db:	803b90        	add	a3, a11, a9
403751de:	2a8a      	add.n	a2, a10, a8
403751e0:	01b287        	bgeu	a2, a8, 403751e5 <esp_system_get_time+0x19>
403751e3:	331b      	addi.n	a3, a3, 1
}
403751e5:	f01d      	retw.n
	...

403751e8 <esp_timer_get_time>:
{
    return systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER);
}

int64_t ESP_TIMER_IRAM_ATTR esp_timer_impl_get_time(void)
{
403751e8:	004136        	entry	a1, 32
    // we hope the execution time of this function won't > 1us
    // thus, to save one function call, we didn't use the existing `systimer_hal_get_time`
    return systimer_hal.ticks_to_us(systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER));
403751eb:	fc87a1        	l32r	a10, 40374408 <_iram_text_start+0x4> (3fc94ce0 <systimer_hal>)
403751ee:	1a78      	l32i.n	a7, a10, 4
403751f0:	0b0c      	movi.n	a11, 0
403751f2:	091425        	call8	4037e334 <systimer_hal_get_counter_value>
403751f5:	0007e0        	callx8	a7
}
403751f8:	0a2d      	mov.n	a2, a10
403751fa:	0b3d      	mov.n	a3, a11
403751fc:	f01d      	retw.n
	...

40375200 <start_cpu_other_cores>:

/* This function has to be in IRAM, as while it is running on CPU1, CPU0 may do some flash operations
 * (e.g. initialize the core dump), which means that cache will be disabled.
 */
static void IRAM_ATTR start_cpu_other_cores_default(void)
{
40375200:	004136        	entry	a1, 32
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_SECONDARY);
40375203:	01a0a2        	movi	a10, 1
40375206:	fc8281        	l32r	a8, 40374410 <_iram_text_start+0xc> (42001604 <do_system_init_fn>)
40375209:	0008e0        	callx8	a8

    while (!s_system_full_inited) {
4037520c:	000206        	j	40375218 <start_cpu_other_cores+0x18>
        esp_rom_delay_us(100);
4037520f:	64a0a2        	movi	a10, 100
40375212:	fc8081        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40375215:	0008e0        	callx8	a8
    while (!s_system_full_inited) {
40375218:	fc7d81        	l32r	a8, 4037440c <_iram_text_start+0x8> (3fc94d00 <s_system_full_inited>)
4037521b:	0020c0        	memw
4037521e:	000882        	l8ui	a8, a8, 0
40375221:	748080        	extui	a8, a8, 0, 8
40375224:	fe7816        	beqz	a8, 4037520f <start_cpu_other_cores+0xf>
    }

    esp_startup_start_app_other_cores();
40375227:	fc7c81        	l32r	a8, 40374418 <_iram_text_start+0x14> (42018f30 <esp_startup_start_app_other_cores>)
4037522a:	0008e0        	callx8	a8
4037522d:	000000        	ill

40375230 <call_start_cpu1>:
{
    s_resume_cores = true;
}

void IRAM_ATTR call_start_cpu1(void)
{
40375230:	004136        	entry	a1, 32
 * @param ivt_addr Interrupt Vector Table's base address
 */
FORCE_INLINE_ATTR void esp_cpu_intr_set_ivt_addr(const void *ivt_addr)
{
#ifdef __XTENSA__
    xt_utils_set_vecbase((uint32_t)ivt_addr);
40375233:	fc7a81        	l32r	a8, 4037441c <_iram_text_start+0x18> (40374000 <_WindowOverflow4>)

// --------------- Interrupt Configuration -----------------

FORCE_INLINE_ATTR void xt_utils_set_vecbase(uint32_t vecbase)
{
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
40375236:	13e780        	wsr.vecbase	a8
    esp_cpu_intr_set_mtvt_addr(&_mtvt_table);
#endif
#if SOC_CPU_SUPPORT_WFE
    rv_utils_disable_wfe_mode();
#endif
    ets_set_appcpu_boot_addr(0);
40375239:	0a0c      	movi.n	a10, 0
4037523b:	fc7f81        	l32r	a8, 40374438 <_iram_text_start+0x34> (40000720 <ets_set_appcpu_boot_addr>)
4037523e:	0008e0        	callx8	a8

    bootloader_init_mem();
40375241:	fc7e81        	l32r	a8, 4037443c <_iram_text_start+0x38> (42009f0c <bootloader_init_mem>)
40375244:	0008e0        	callx8	a8

#if CONFIG_ESP_CONSOLE_NONE
    esp_rom_install_channel_putc(1, NULL);
    esp_rom_install_channel_putc(2, NULL);
#elif !CONFIG_ESP_CONSOLE_USB_CDC
    esp_rom_install_uart_printf();
40375247:	043c65        	call8	4037960c <esp_rom_install_uart_printf>
    esp_rom_output_set_as_console(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
4037524a:	0a0c      	movi.n	a10, 0
4037524c:	fc7d81        	l32r	a8, 40374440 <_iram_text_start+0x3c> (400006c0 <esp_rom_output_set_as_console>)
4037524f:	0008e0        	callx8	a8
FORCE_INLINE_ATTR void cpu_utility_ll_enable_debug(uint32_t cpu_no)
{
    if (cpu_no == 0) {
        REG_WRITE(ASSIST_DEBUG_CORE_0_RCD_PDEBUGENABLE_REG, 1);
    } else {
        REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_PDEBUGENABLE_REG, 1);
40375252:	170c      	movi.n	a7, 1
40375254:	fc7381        	l32r	a8, 40374420 <_iram_text_start+0x1c> (600ce0d8 <SYSTEM+0xe0d8>)
40375257:	0020c0        	memw
4037525a:	0879      	s32i.n	a7, a8, 0
FORCE_INLINE_ATTR void cpu_utility_ll_enable_record(uint32_t cpu_no)
{
    if (cpu_no == 0) {
        REG_WRITE(ASSIST_DEBUG_CORE_0_RCD_RECORDING_REG, 1);
    } else {
        REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_RECORDING_REG, 1);
4037525c:	fc7281        	l32r	a8, 40374424 <_iram_text_start+0x20> (600ce0dc <SYSTEM+0xe0dc>)
4037525f:	0020c0        	memw
40375262:	006872        	s32i	a7, a8, 0
#endif

    cpu_utility_ll_enable_debug(1);
    cpu_utility_ll_enable_record(1);

    s_cpu_up[1] = true;
40375265:	fc7081        	l32r	a8, 40374428 <_iram_text_start+0x24> (3fc94d18 <s_cpu_up>)
40375268:	0020c0        	memw
4037526b:	014872        	s8i	a7, a8, 1
    ESP_EARLY_LOGD(TAG, "App cpu up");

    // Clear interrupt matrix for APP CPU core
    core_intr_matrix_clear();
4037526e:	fc7581        	l32r	a8, 40374444 <_iram_text_start+0x40> (420017c4 <core_intr_matrix_clear>)
40375271:	0008e0        	callx8	a8

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    //Take care putting stuff here: if asked, FreeRTOS will happily tell you the scheduler
    //has started, but it isn't active *on this CPU* yet.
    esp_cache_err_int_init();
40375274:	fc7581        	l32r	a8, 40374448 <_iram_text_start+0x44> (42001d18 <esp_cache_err_int_init>)
40375277:	0008e0        	callx8	a8
#if (CONFIG_IDF_TARGET_ESP32 && CONFIG_ESP32_TRAX_TWOBANKS) || \
    (CONFIG_IDF_TARGET_ESP32S3 && CONFIG_ESP32S3_TRAX_TWOBANKS)
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif

    s_cpu_inited[1] = true;
4037527a:	fc6c81        	l32r	a8, 4037442c <_iram_text_start+0x28> (3fc94d14 <s_cpu_inited>)
4037527d:	0020c0        	memw
40375280:	014872        	s8i	a7, a8, 1

    while (!s_resume_cores) {
40375283:	000286        	j	40375291 <call_start_cpu1+0x61>
40375286:	a20000        	muluh	a0, a0, a0
        esp_rom_delay_us(100);
40375289:	8164a0        	src	a6, a4, a10
4037528c:	e0fc62        	s32ri	a6, a12, 0x380
4037528f:	0008      	l32i.n	a0, a0, 0
    while (!s_resume_cores) {
40375291:	fc6781        	l32r	a8, 40374430 <_iram_text_start+0x2c> (3fc94d10 <s_resume_cores>)
40375294:	0020c0        	memw
40375297:	000882        	l8ui	a8, a8, 0
4037529a:	748080        	extui	a8, a8, 0, 8
4037529d:	fe7816        	beqz	a8, 40375288 <call_start_cpu1+0x58>
    asm volatile (
403752a0:	03eb80        	rsr.prid	a8
403752a3:	048d80        	extui	a8, a8, 13, 1
    }

    SYS_STARTUP_FN();
403752a6:	fc6391        	l32r	a9, 40374434 <_iram_text_start+0x30> (3c0263dc <g_startup_fn>)
403752a9:	a08890        	addx4	a8, a8, a9
403752ac:	0888      	l32i.n	a8, a8, 0
403752ae:	0008e0        	callx8	a8
}
403752b1:	f01d      	retw.n
	...

403752b4 <do_multicore_settings>:
}
#endif
// This function is needed to make the multicore app runnable on a unicore bootloader (built with FREERTOS UNICORE).
// It does some cache settings for other CPUs.
void IRAM_ATTR do_multicore_settings(void)
{
403752b4:	004136        	entry	a1, 32
{
    cache_bus_mask_t mask = (cache_bus_mask_t)0;
    HAL_ASSERT(cache_id <= CACHE_LL_ID_ALL);
    //On esp32s3, only `CACHE_BUS_IBUS0` and `CACHE_BUS_DBUS0` are supported. Use `cache_ll_l1_get_bus()` to get your bus first

    uint32_t ibus_mask = REG_READ(EXTMEM_ICACHE_CTRL1_REG);
403752b7:	fc6581        	l32r	a8, 4037444c <_iram_text_start+0x48> (600c4064 <SYSTEM+0x4064>)
403752ba:	0020c0        	memw
403752bd:	0888      	l32i.n	a8, a8, 0
    if (cache_id == 0) {
        mask = (cache_bus_mask_t)(mask | ((!(ibus_mask & EXTMEM_ICACHE_SHUT_CORE0_BUS)) ? CACHE_BUS_IBUS0 : 0));
403752bf:	05e807        	bbsi	a8, 0, 403752c8 <do_multicore_settings+0x14>
403752c2:	170c      	movi.n	a7, 1
403752c4:	000086        	j	403752ca <do_multicore_settings+0x16>
403752c7:	070c00        	ee.stf.64.xp	f0, f0, a0, a12
    } else {
        mask = (cache_bus_mask_t)(mask | ((!(ibus_mask & EXTMEM_ICACHE_SHUT_CORE1_BUS)) ? CACHE_BUS_IBUS0 : 0));
    }

    uint32_t dbus_mask = REG_READ(EXTMEM_DCACHE_CTRL1_REG);
403752ca:	fc6181        	l32r	a8, 40374450 <_iram_text_start+0x4c> (600c4004 <SYSTEM+0x4004>)
403752cd:	0020c0        	memw
403752d0:	0888      	l32i.n	a8, a8, 0
    if (cache_id == 1) {
        mask = (cache_bus_mask_t)(mask | ((!(dbus_mask & EXTMEM_DCACHE_SHUT_CORE0_BUS)) ? CACHE_BUS_DBUS0 : 0));
    } else {
        mask = (cache_bus_mask_t)(mask | ((!(dbus_mask & EXTMEM_DCACHE_SHUT_CORE1_BUS)) ? CACHE_BUS_DBUS0 : 0));
403752d2:	04e817        	bbsi	a8, 1, 403752da <do_multicore_settings+0x26>
403752d5:	880c      	movi.n	a8, 8
403752d7:	000086        	j	403752dd <do_multicore_settings+0x29>
403752da:	00a082        	movi	a8, 0
403752dd:	207780        	or	a7, a7, a8
#endif

    cache_bus_mask_t cache_bus_mask_core0 = cache_ll_l1_get_enabled_bus(0);
#ifndef CONFIG_IDF_TARGET_ESP32
    // 1. disable the cache before changing its settings.
    cache_hal_disable(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403752e0:	02a0b2        	movi	a11, 2
403752e3:	01a0a2        	movi	a10, 1
403752e6:	075e25        	call8	4037c8c8 <cache_hal_disable>
#endif
    for (unsigned core = 1; core < SOC_CPU_CORES_NUM; core++) {
403752e9:	180c      	movi.n	a8, 1
403752eb:	001146        	j	40375334 <do_multicore_settings+0x80>
    if (cache_id == 0) {
403752ee:	48cc      	bnez.n	a8, 403752f6 <do_multicore_settings+0x42>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE0_BUS : 0);
403752f0:	049070        	extui	a9, a7, 0, 1
403752f3:	000186        	j	403752fd <do_multicore_settings+0x49>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE1_BUS : 0);
403752f6:	977a      	add.n	a9, a7, a7
403752f8:	2a0c      	movi.n	a10, 2
403752fa:	1099a0        	and	a9, a9, a10
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
403752fd:	fc53a1        	l32r	a10, 4037444c <_iram_text_start+0x48> (600c4064 <SYSTEM+0x4064>)
40375300:	0020c0        	memw
40375303:	0ab8      	l32i.n	a11, a10, 0
40375305:	1099b0        	and	a9, a9, a11
40375308:	3099b0        	xor	a9, a9, a11
4037530b:	0020c0        	memw
4037530e:	0a99      	s32i.n	a9, a10, 0
    if (cache_id == 1) {
40375310:	051866        	bnei	a8, 1, 40375319 <do_multicore_settings+0x65>
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE0_BUS : 0);
40375313:	419370        	srli	a9, a7, 3
40375316:	000086        	j	4037531c <do_multicore_settings+0x68>
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE1_BUS : 0);
40375319:	419270        	srli	a9, a7, 2
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037531c:	fc4da1        	l32r	a10, 40374450 <_iram_text_start+0x4c> (600c4004 <SYSTEM+0x4004>)
4037531f:	0020c0        	memw
40375322:	002ab2        	l32i	a11, a10, 0
40375325:	1099b0        	and	a9, a9, a11
40375328:	3099b0        	xor	a9, a9, a11
4037532b:	0020c0        	memw
4037532e:	006a92        	s32i	a9, a10, 0
40375331:	01c882        	addi	a8, a8, 1
40375334:	b628b6        	bltui	a8, 2, 403752ee <do_multicore_settings+0x3a>
        // 2. change cache settings. All cores must have the same settings.
        cache_ll_l1_enable_bus(core, cache_bus_mask_core0);
    }
#ifndef CONFIG_IDF_TARGET_ESP32
    // 3. enable the cache after changing its settings.
    cache_hal_enable(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40375337:	2b0c      	movi.n	a11, 2
40375339:	1a0c      	movi.n	a10, 1
4037533b:	075ca5        	call8	4037c904 <cache_hal_enable>
#endif
}
4037533e:	f01d      	retw.n

40375340 <call_start_cpu0>:
/*
 * We arrive here after the bootloader finished loading the program from flash. The hardware is mostly uninitialized,
 * and the app CPU is in reset. We do have a stack, so we can do the initialization in C.
 */
void IRAM_ATTR call_start_cpu0(void)
{
40375340:	00e136        	entry	a1, 112
40375343:	fc3681        	l32r	a8, 4037441c <_iram_text_start+0x18> (40374000 <_WindowOverflow4>)
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
40375346:	13e780        	wsr.vecbase	a8
#if CONFIG_SECURE_ENABLE_TEE
    extern uint32_t esp_tee_service_call(int argc, ...);
    esprv_int_setup_mgmt_cb((void *)esp_tee_service_call);
#endif

    rst_reas[0] = esp_rom_get_reset_reason(0);
40375349:	0a0c      	movi.n	a10, 0
4037534b:	fc5a81        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (4000057c <esp_rom_get_reset_reason>)
4037534e:	0008e0        	callx8	a8
40375351:	0a5d      	mov.n	a5, a10
40375353:	01a9      	s32i.n	a10, a1, 0
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    rst_reas[1] = esp_rom_get_reset_reason(1);
40375355:	1a0c      	movi.n	a10, 1
40375357:	fc5781        	l32r	a8, 403744b4 <_iram_text_start+0xb0> (4000057c <esp_rom_get_reset_reason>)
4037535a:	0008e0        	callx8	a8
4037535d:	11a9      	s32i.n	a10, a1, 4
    //Clear BSS. Please do not attempt to do any complex stuff (like early logging) before this.
#if SOC_MEM_NON_CONTIGUOUS_SRAM
    memset(&_bss_start_low, 0, (&_bss_end_low - &_bss_start_low) * sizeof(_bss_start_low));
    memset(&_bss_start_high, 0, (&_bss_end_high - &_bss_start_high) * sizeof(_bss_start_high));
#else
    memset(&_bss_start, 0, (&_bss_end - &_bss_start) * sizeof(_bss_start));
4037535f:	fc3ea1        	l32r	a10, 40374458 <_iram_text_start+0x54> (3fc94cc8 <app_elf_sha256_str>)
40375362:	fc3cc1        	l32r	a12, 40374454 <_iram_text_start+0x50> (3fc95538 <_bss_end>)
40375365:	c0cca0        	sub	a12, a12, a10
40375368:	0b0c      	movi.n	a11, 0
4037536a:	fc5381        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037536d:	0008e0        	callx8	a8
    memset(&_iram_bss_start, 0, (&_iram_bss_end - &_iram_bss_start) * sizeof(_iram_bss_start));
#endif

#if SOC_RTC_FAST_MEM_SUPPORTED || SOC_RTC_SLOW_MEM_SUPPORTED
    /* Unless waking from deep sleep (implying RTC memory is intact), clear RTC bss */
    if (rst_reas[0] != RESET_REASON_CORE_DEEP_SLEEP) {
40375370:	105526        	beqi	a5, 5, 40375384 <call_start_cpu0+0x44>
        memset(&_rtc_bss_start, 0, (&_rtc_bss_end - &_rtc_bss_start) * sizeof(_rtc_bss_start));
40375373:	fc3ba1        	l32r	a10, 40374460 <_iram_text_start+0x5c> (50000000 <_rtc_bss_end>)
40375376:	fc39c1        	l32r	a12, 4037445c <_iram_text_start+0x58> (50000000 <_rtc_bss_end>)
40375379:	c0cca0        	sub	a12, a12, a10
4037537c:	0b0c      	movi.n	a11, 0
4037537e:	fc4e81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40375381:	0008e0        	callx8	a8
    }
#endif

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE && !SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE
    // It helps to fix missed cache settings for other cores. It happens when bootloader is unicore.
    do_multicore_settings();
40375384:	fff2e5        	call8	403752b4 <do_multicore_settings>
#endif

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    //cache hal ctx needs to be initialised
    cache_hal_init();
40375387:	074aa5        	call8	4037c830 <cache_hal_init>
#endif

#if CONFIG_IDF_TARGET_ESP32S3
    /* Configure the mode of instruction cache : cache size, cache line size. */
    extern void rom_config_instruction_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_instruction_cache_mode(CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE, CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE);
4037538a:	0c2c      	movi.n	a12, 32
4037538c:	8b0c      	movi.n	a11, 8
4037538e:	fc35a1        	l32r	a10, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
40375391:	fc4a81        	l32r	a8, 403744bc <_iram_text_start+0xb8> (40001a1c <rom_config_instruction_cache_mode>)
40375394:	0008e0        	callx8	a8

    /* If we need use SPIRAM, we should use data cache.
       Configure the mode of data : cache size, cache line size.*/
    Cache_Suspend_DCache();
40375397:	041265        	call8	403794bc <Cache_Suspend_DCache>
    extern void rom_config_data_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_data_cache_mode(CONFIG_ESP32S3_DATA_CACHE_SIZE, CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE);
4037539a:	0c2c      	movi.n	a12, 32
4037539c:	8b0c      	movi.n	a11, 8
4037539e:	fc32a1        	l32r	a10, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
403753a1:	fc4781        	l32r	a8, 403744c0 <_iram_text_start+0xbc> (40001a28 <rom_config_data_cache_mode>)
403753a4:	0008e0        	callx8	a8
    Cache_Resume_DCache(0);
403753a7:	0a0c      	movi.n	a10, 0
403753a9:	fc4681        	l32r	a8, 403744c4 <_iram_text_start+0xc0> (400018c0 <Cache_Resume_DCache>)
403753ac:	0008e0        	callx8	a8
    // are all in internal RAM. If the RAM loadable ELF has any requirement to memory map the
    // external flash then it should use flash or partition mmap APIs.
    uint32_t cache_mmu_irom_size = 0;
    __attribute__((unused)) uint32_t cache_mmu_drom_size = 0;
#else // CONFIG_APP_BUILD_TYPE_ELF_RAM
    uint32_t _instruction_size = (uint32_t)&_instruction_reserved_end - (uint32_t)&_instruction_reserved_start;
403753af:	fc2f71        	l32r	a7, 4037446c <_iram_text_start+0x68> (42019736 <_etext>)
403753b2:	fc2f81        	l32r	a8, 40374470 <_iram_text_start+0x6c> (42000020 <_instruction_reserved_start>)
403753b5:	c07780        	sub	a7, a7, a8
    uint32_t cache_mmu_irom_size = ((_instruction_size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
403753b8:	fc2f81        	l32r	a8, 40374474 <_iram_text_start+0x70> (ffff <UserFrameTotalSize+0xfeff>)
403753bb:	778a      	add.n	a7, a7, a8
403753bd:	f57070        	extui	a7, a7, 16, 16
403753c0:	11a7e0        	slli	a10, a7, 2

    uint32_t _rodata_size = (uint32_t)&_rodata_reserved_end - (uint32_t)&_rodata_reserved_start;
403753c3:	fc2d31        	l32r	a3, 40374478 <_iram_text_start+0x74> (3c0292a4 <_esp_system_init_fn_array_end>)
403753c6:	fc2d61        	l32r	a6, 4037447c <_iram_text_start+0x78> (3c020020 <esp_app_desc>)
403753c9:	c04360        	sub	a4, a3, a6
    __attribute__((unused)) uint32_t cache_mmu_drom_size = ((_rodata_size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
403753cc:	448a      	add.n	a4, a4, a8
403753ce:	f54040        	extui	a4, a4, 16, 16
#endif // !CONFIG_APP_BUILD_TYPE_ELF_RAM

    /* Configure the Cache MMU size for instruction and rodata in flash. */
    Cache_Set_IDROM_MMU_Size(cache_mmu_irom_size, CACHE_DROM_MMU_MAX_END - cache_mmu_irom_size);
403753d1:	fcdab2        	addmi	a11, a10, 0xfffffc00
403753d4:	60b0b0        	neg	a11, a11
403753d7:	fc3c81        	l32r	a8, 403744c8 <_iram_text_start+0xc4> (40001914 <Cache_Set_IDROM_MMU_Size>)
403753da:	0008e0        	callx8	a8
        ESP_DRAM_LOGE(TAG, "Octal Flash option selected, but EFUSE not configured!");
        abort();
    }
#endif

    esp_mspi_pin_init();
403753dd:	0269a5        	call8	40377a78 <esp_mspi_pin_init>
    // For Octal flash, it's hard to implement a read_id function in OPI mode for all vendors.
    // So we have to read it here in SPI mode, before entering the OPI mode.
    bootloader_flash_update_id();
403753e0:	fc3b81        	l32r	a8, 403744cc <_iram_text_start+0xc8> (42009f14 <bootloader_flash_update_id>)
403753e3:	0008e0        	callx8	a8

    // Configure the power related stuff. After this the MSPI timing tuning can be done.
    esp_rtc_init();
403753e6:	fc3a81        	l32r	a8, 403744d0 <_iram_text_start+0xcc> (42001984 <esp_rtc_init>)
403753e9:	0008e0        	callx8	a8
     *
     * In bootloader, we only init Flash (and MSPI) to a preliminary state, for being flexible to
     * different chips.
     * In this stage, we re-configure the Flash (and MSPI) to required configuration
     */
    spi_flash_init_chip_state();
403753ec:	026a25        	call8	40377a90 <spi_flash_init_chip_state>
#if SOC_MEMSPI_SRC_FREQ_120M_SUPPORTED
    // This function needs to be called when PLL is enabled. Needs to be called after spi_flash_init_chip_state in case
    // some state of flash is modified.
    mspi_timing_flash_tuning();
403753ef:	02df25        	call8	403781e0 <mspi_timing_flash_tuning>
#endif

    esp_mmu_map_init();
403753f2:	fc3881        	l32r	a8, 403744d4 <_iram_text_start+0xd0> (4200a074 <esp_mmu_map_init>)
403753f5:	0008e0        	callx8	a8
    /**
     * @note
     * After this stage, you can access the flash through the cache, i.e. run code which is not placed in IRAM
     * or print string which locates on flash
     */
    esp_mspi_pin_reserve();
403753f8:	fc3881        	l32r	a8, 403744d8 <_iram_text_start+0xd4> (4200b054 <esp_mspi_pin_reserve>)
403753fb:	0008e0        	callx8	a8
    return (esp_log_level_t) CONFIG_BOOTLOADER_LOG_LEVEL;
#elif ESP_TEE_BUILD
    return (esp_log_level_t) CONFIG_SECURE_TEE_LOG_LEVEL;
#elif CONFIG_LOG_DYNAMIC_LEVEL_CONTROL
    extern esp_log_level_t esp_log_default_level;
    return esp_log_default_level;
403753fe:	fc2081        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40375401:	0888      	l32i.n	a8, a8, 0
#endif // !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP

#if CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    ESP_EARLY_LOGI(TAG, "Unicore app");
#else
    ESP_EARLY_LOGI(TAG, "Multicore app");
40375403:	1138b6        	bltui	a8, 3, 40375418 <call_start_cpu0+0xd8>
40375406:	0a7fe5        	call8	4037fc04 <esp_log_timestamp>
40375409:	fc1ec1        	l32r	a12, 40374484 <_iram_text_start+0x80> (3c02032c <_flash_rodata_start+0x20c>)
4037540c:	20baa0        	or	a11, a10, a10
4037540f:	fc1ea1        	l32r	a10, 40374488 <_iram_text_start+0x84> (3c020538 <_flash_rodata_start+0x418>)
40375412:	fc3281        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40375415:	0008e0        	callx8	a8
#endif
    /* NOTE: When ESP-TEE is enabled, it configures its own memory protection
     * scheme using the CPU-inherent features PMP and PMA and the APM peripheral.
     */
#if !CONFIG_SECURE_ENABLE_TEE
    bootloader_init_mem();
40375418:	fc0981        	l32r	a8, 4037443c <_iram_text_start+0x38> (42009f0c <bootloader_init_mem>)
4037541b:	0008e0        	callx8	a8
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_up[0] = true;
4037541e:	fc0281        	l32r	a8, 40374428 <_iram_text_start+0x24> (3fc94d18 <s_cpu_up>)
40375421:	190c      	movi.n	a9, 1
40375423:	0020c0        	memw
40375426:	004892        	s8i	a9, a8, 0

    ESP_EARLY_LOGD(TAG, "Pro cpu up");

#if SOC_CPU_CORES_NUM > 1 // there is no 'single-core mode' for natively single-core processors
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    start_other_core();
40375429:	fc2d81        	l32r	a8, 403744e0 <_iram_text_start+0xdc> (420017e8 <start_other_core>)
4037542c:	0008e0        	callx8	a8
    s_instr_flash2spiram_off = instruction_flash2spiram_offset();
#endif
#if CONFIG_SPIRAM_RODATA
    s_rodata_flash2spiram_off = rodata_flash2spiram_offset();
#endif
    Cache_Set_IDROM_MMU_Info(cache_mmu_irom_size / sizeof(uint32_t), \
4037542f:	0f0c      	movi.n	a15, 0
40375431:	0fed      	mov.n	a14, a15
40375433:	03dd      	mov.n	a13, a3
40375435:	06cd      	mov.n	a12, a6
40375437:	04bd      	mov.n	a11, a4
40375439:	07ad      	mov.n	a10, a7
4037543b:	fc2a81        	l32r	a8, 403744e4 <_iram_text_start+0xe0> (40001950 <Cache_Set_IDROM_MMU_Info>)
4037543e:	0008e0        	callx8	a8
    trax_enable(TRAX_ENA_PRO);
#endif
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif // CONFIG_ESP32_TRAX || CONFIG_ESP32S2_TRAX || CONFIG_ESP32S3_TRAX

    esp_clk_init();
40375441:	fc2981        	l32r	a8, 403744e8 <_iram_text_start+0xe4> (420019ac <esp_clk_init>)
40375444:	0008e0        	callx8	a8
    esp_perip_clk_init();
40375447:	fc2981        	l32r	a8, 403744ec <_iram_text_start+0xe8> (42001ad4 <esp_perip_clk_init>)
4037544a:	0008e0        	callx8	a8

    // Now that the clocks have been set-up, set the startup time from RTC
    // and default RTC-backed system time provider.
    g_startup_time = esp_rtc_get_time_us();
4037544d:	029e25        	call8	40377e30 <esp_rtc_get_time_us>
40375450:	fc0f81        	l32r	a8, 4037448c <_iram_text_start+0x88> (3fc94d08 <g_startup_time>)
40375453:	08a9      	s32i.n	a10, a8, 0
40375455:	18b9      	s32i.n	a11, a8, 4

    // Clear interrupt matrix for PRO CPU core
    core_intr_matrix_clear();
40375457:	fbfb81        	l32r	a8, 40374444 <_iram_text_start+0x40> (420017c4 <core_intr_matrix_clear>)
4037545a:	0008e0        	callx8	a8

#ifndef CONFIG_IDF_ENV_FPGA // TODO: on FPGA it should be possible to configure this, not currently working with APB_CLK_FREQ changed
#ifdef CONFIG_ESP_CONSOLE_UART
    uint32_t clock_hz = esp_clk_apb_freq();
4037545d:	00fca5        	call8	40376428 <esp_clk_apb_freq>
#if ESP_ROM_UART_CLK_IS_XTAL
    clock_hz = esp_clk_xtal_freq(); // From esp32-s3 on, UART clock source is selected to XTAL in ROM
40375460:	00ff25        	call8	40376454 <esp_clk_xtal_freq>
40375463:	0a7d      	mov.n	a7, a10
#endif
    esp_rom_output_tx_wait_idle(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
40375465:	0a0c      	movi.n	a10, 0
40375467:	fc2281        	l32r	a8, 403744f0 <_iram_text_start+0xec> (4000069c <esp_rom_output_tx_wait_idle>)
4037546a:	0008e0        	callx8	a8
#define DIV_UP(a, b)    (((a) + (b) - 1) / (b))
    if (baud == 0) {
        return false;
    }
    const uint32_t max_div = UART_CLKDIV_V;   // UART divider integer part only has 12 bits
    uint32_t sclk_div = DIV_UP(sclk_freq, (uint64_t)max_div * baud);
4037546d:	fc0f81        	l32r	a8, 403744ac <_iram_text_start+0xa8> (1c1e3dff <UserFrameTotalSize+0x1c1e3cff>)
40375470:	0b0c      	movi.n	a11, 0
40375472:	a78a      	add.n	a10, a7, a8
40375474:	01ba87        	bgeu	a10, a8, 40375479 <call_start_cpu0+0x139>
40375477:	1b0c      	movi.n	a11, 1
40375479:	fc0dc1        	l32r	a12, 403744b0 <_iram_text_start+0xac> (1c1e3e00 <UserFrameTotalSize+0x1c1e3d00>)
4037547c:	0d0c      	movi.n	a13, 0
4037547e:	fc1d81        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
40375481:	0008e0        	callx8	a8
#undef DIV_UP

    if (sclk_div == 0 || sclk_div > (UART_SCLK_DIV_NUM_V + 1)) {
40375484:	8a0b      	addi.n	a8, a10, -1
40375486:	ffa092        	movi	a9, 255
40375489:	7b3987        	bltu	a9, a8, 40375508 <call_start_cpu0+0x1c8>
        return false; // unachievable baud-rate
    }

    uint32_t clk_div = ((sclk_freq) << 4) / (baud * sclk_div);
4037548c:	1177c0        	slli	a7, a7, 4
4037548f:	119ac0        	slli	a9, a10, 4
40375492:	c099a0        	sub	a9, a9, a10
40375495:	1189c0        	slli	a8, a9, 4
40375498:	c08890        	sub	a8, a8, a9
4037549b:	118870        	slli	a8, a8, 9
4037549e:	c27780        	quou	a7, a7, a8
    // The baud rate configuration register is divided into an integer part and a fractional part.
    hw->clkdiv.clkdiv = clk_div >> 4;
403754a1:	fbfb91        	l32r	a9, 40374490 <_iram_text_start+0x8c> (60000000 <UART0>)
403754a4:	0020c0        	memw
403754a7:	5988      	l32i.n	a8, a9, 20
403754a9:	b4b470        	extui	a11, a7, 4, 12
403754ac:	418c80        	srli	a8, a8, 12
403754af:	118840        	slli	a8, a8, 12
403754b2:	2088b0        	or	a8, a8, a11
403754b5:	0020c0        	memw
403754b8:	5989      	s32i.n	a8, a9, 20
    hw->clkdiv.clkdiv_frag = clk_div & 0xf;
403754ba:	0020c0        	memw
403754bd:	5988      	l32i.n	a8, a9, 20
403754bf:	347070        	extui	a7, a7, 0, 4
403754c2:	0177c0        	slli	a7, a7, 20
403754c5:	fbf3b1        	l32r	a11, 40374494 <_iram_text_start+0x90> (ff0fffff <_rtc_reserved_end+0x9effffff>)
403754c8:	1088b0        	and	a8, a8, a11
403754cb:	208870        	or	a8, a8, a7
403754ce:	0020c0        	memw
403754d1:	5989      	s32i.n	a8, a9, 20
    HAL_FORCE_MODIFY_U32_REG_FIELD(hw->clk_conf, sclk_div_num, sclk_div - 1);
403754d3:	0020c0        	memw
403754d6:	1e2982        	l32i	a8, a9, 120
403754d9:	0020c0        	memw
403754dc:	106182        	s32i	a8, a1, 64
403754df:	8a0b      	addi.n	a8, a10, -1
403754e1:	0020c0        	memw
403754e4:	1021a2        	l32i	a10, a1, 64
403754e7:	748080        	extui	a8, a8, 0, 8
403754ea:	118840        	slli	a8, a8, 12
403754ed:	fbeab1        	l32r	a11, 40374498 <_iram_text_start+0x94> (fff00fff <_rtc_reserved_end+0x9fe00fff>)
403754f0:	10aab0        	and	a10, a10, a11
403754f3:	208a80        	or	a8, a10, a8
403754f6:	0020c0        	memw
403754f9:	106182        	s32i	a8, a1, 64
403754fc:	0020c0        	memw
403754ff:	102182        	l32i	a8, a1, 64
40375502:	0020c0        	memw
40375505:	1e6982        	s32i	a8, a9, 120
#endif
#endif

#if SOC_DEEP_SLEEP_SUPPORTED
    // Need to unhold the IOs that were hold right before entering deep sleep, which are used as wakeup pins
    if (rst_reas[0] == RESET_REASON_CORE_DEEP_SLEEP) {
40375508:	055566        	bnei	a5, 5, 40375511 <call_start_cpu0+0x1d1>
        esp_deep_sleep_wakeup_io_reset();
4037550b:	fbfb81        	l32r	a8, 403744f8 <_iram_text_start+0xf4> (42003e0c <esp_deep_sleep_wakeup_io_reset>)
4037550e:	0008e0        	callx8	a8
    }
#endif  //#if SOC_DEEP_SLEEP_SUPPORTED

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    esp_cache_err_int_init();
40375511:	fbcd81        	l32r	a8, 40374448 <_iram_text_start+0x44> (42001d18 <esp_cache_err_int_init>)
40375514:	0008e0        	callx8	a8
    // If such a situation appears, it is likely an malicious attempt to bypass the system safety setup -> print error & reset

#if CONFIG_IDF_TARGET_ESP32S2
    if (esp_memprot_is_locked_any()) {
#else
    bool is_locked = false;
40375517:	080c      	movi.n	a8, 0
40375519:	084182        	s8i	a8, a1, 8
    if (esp_mprot_is_conf_locked_any(&is_locked) != ESP_OK || is_locked) {
4037551c:	a18b      	addi.n	a10, a1, 8
4037551e:	fbf781        	l32r	a8, 403744fc <_iram_text_start+0xf8> (420052b4 <esp_mprot_is_conf_locked_any>)
40375521:	0008e0        	callx8	a8
40375524:	3acc      	bnez.n	a10, 4037552b <call_start_cpu0+0x1eb>
40375526:	080182        	l8ui	a8, a1, 8
40375529:	d89c      	beqz.n	a8, 4037554a <call_start_cpu0+0x20a>
4037552b:	fbd581        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
4037552e:	0888      	l32i.n	a8, a8, 0
#endif
        ESP_EARLY_LOGE(TAG, "Memprot feature locked after the system reset! Potential safety corruption, rebooting.");
40375530:	089c      	beqz.n	a8, 40375544 <call_start_cpu0+0x204>
40375532:	0a6d25        	call8	4037fc04 <esp_log_timestamp>
40375535:	fbd3c1        	l32r	a12, 40374484 <_iram_text_start+0x80> (3c02032c <_flash_rodata_start+0x20c>)
40375538:	20baa0        	or	a11, a10, a10
4037553b:	fbd8a1        	l32r	a10, 4037449c <_iram_text_start+0x98> (3c020554 <_flash_rodata_start+0x434>)
4037553e:	fbe781        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40375541:	0008e0        	callx8	a8
        esp_restart_noos();
40375544:	201110        	or	a1, a1, a1
40375547:	002725        	call8	403757b8 <esp_restart_noos>
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_LOCK, NULL);
#else
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_UNLOCK, NULL);
#endif
#else //CONFIG_IDF_TARGET_ESP32S2 specific end
    esp_memp_config_t memp_cfg = ESP_MEMPROT_DEFAULT_CONFIG();
4037554a:	71cb      	addi.n	a7, a1, 12
4037554c:	8c1c      	movi.n	a12, 24
4037554e:	fbd4b1        	l32r	a11, 403744a0 <_iram_text_start+0x9c> (3c026404 <__func__$0+0x20>)
40375551:	07ad      	mov.n	a10, a7
40375553:	fbeb81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40375556:	0008e0        	callx8	a8
#if !CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK
    memp_cfg.lock_feature = false;
#endif
    memp_err = esp_mprot_set_prot(&memp_cfg);
40375559:	07ad      	mov.n	a10, a7
4037555b:	fbea81        	l32r	a8, 40374504 <_iram_text_start+0x100> (4200543c <esp_mprot_set_prot>)
4037555e:	0008e0        	callx8	a8
40375561:	0a7d      	mov.n	a7, a10
#endif //other IDF_TARGETS end

    if (memp_err != ESP_OK) {
40375563:	9aac      	beqz.n	a10, 40375590 <call_start_cpu0+0x250>
40375565:	fbc681        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40375568:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Failed to set Memprot feature (0x%08X: %s), rebooting.", memp_err, esp_err_to_name(memp_err));
4037556b:	e89c      	beqz.n	a8, 4037558d <call_start_cpu0+0x24d>
4037556d:	0a6965        	call8	4037fc04 <esp_log_timestamp>
40375570:	0a6d      	mov.n	a6, a10
40375572:	07ad      	mov.n	a10, a7
40375574:	fbe581        	l32r	a8, 40374508 <_iram_text_start+0x104> (42002b38 <esp_err_to_name>)
40375577:	0008e0        	callx8	a8
4037557a:	0aed      	mov.n	a14, a10
4037557c:	07dd      	mov.n	a13, a7
4037557e:	fbc1c1        	l32r	a12, 40374484 <_iram_text_start+0x80> (3c02032c <_flash_rodata_start+0x20c>)
40375581:	20b660        	or	a11, a6, a6
40375584:	fbc8a1        	l32r	a10, 403744a4 <_iram_text_start+0xa0> (3c0205b8 <_flash_rodata_start+0x498>)
40375587:	fbd581        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
4037558a:	0008e0        	callx8	a8
        esp_restart_noos();
4037558d:	0022a5        	call8	403757b8 <esp_restart_noos>

#if !CONFIG_APP_BUILD_TYPE_RAM
    // Normal startup flow. We arrive here with the help of 1st, 2nd bootloader. There are valid headers (app/bootloader)

    // Read the application binary image header. This will also decrypt the header if the image is encrypted.
    __attribute__((unused)) esp_image_header_t fhdr = {0};
40375590:	24c152        	addi	a5, a1, 36
40375593:	841c      	movi.n	a4, 24
40375595:	04cd      	mov.n	a12, a4
40375597:	0b0c      	movi.n	a11, 0
40375599:	05ad      	mov.n	a10, a5
4037559b:	fbc781        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037559e:	0008e0        	callx8	a8

    // We can access the image header through the cache by reading from the memory-mapped virtual DROM start offset
    uint32_t fhdr_src_addr = (uint32_t)(&_rodata_reserved_start) - sizeof(esp_image_header_t) - sizeof(esp_image_segment_header_t);
    hal_memcpy(&fhdr, (void *) fhdr_src_addr, sizeof(fhdr));
403755a1:	04cd      	mov.n	a12, a4
403755a3:	e0c6b2        	addi	a11, a6, -32
403755a6:	05ad      	mov.n	a10, a5
403755a8:	fbd681        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403755ab:	0008e0        	callx8	a8
    if (fhdr.magic != ESP_IMAGE_HEADER_MAGIC) {
403755ae:	240192        	l8ui	a9, a1, 36
403755b1:	e9a082        	movi	a8, 233
403755b4:	1c1987        	beq	a9, a8, 403755d4 <call_start_cpu0+0x294>
403755b7:	fbb281        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
403755ba:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Invalid app image header");
403755bd:	010816        	beqz	a8, 403755d1 <call_start_cpu0+0x291>
403755c0:	0a6425        	call8	4037fc04 <esp_log_timestamp>
403755c3:	fbb0c1        	l32r	a12, 40374484 <_iram_text_start+0x80> (3c02032c <_flash_rodata_start+0x20c>)
403755c6:	0abd      	mov.n	a11, a10
403755c8:	fbb8a1        	l32r	a10, 403744a8 <_iram_text_start+0xa4> (3c0205fc <_flash_rodata_start+0x4dc>)
403755cb:	fbc481        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
403755ce:	0008e0        	callx8	a8
        abort();
403755d1:	0a69a5        	call8	4037fc6c <abort>
    bootloader_flash_unlock();
#endif
#endif //!CONFIG_APP_BUILD_TYPE_PURE_RAM_APP

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_inited[0] = true;
403755d4:	fb9681        	l32r	a8, 4037442c <_iram_text_start+0x28> (3fc94d14 <s_cpu_inited>)
403755d7:	190c      	movi.n	a9, 1
403755d9:	0020c0        	memw
403755dc:	004892        	s8i	a9, a8, 0

    volatile bool cpus_inited = false;
403755df:	080c      	movi.n	a8, 0
403755e1:	0020c0        	memw
403755e4:	3c4182        	s8i	a8, a1, 60

    while (!cpus_inited) {
403755e7:	000e46        	j	40375624 <call_start_cpu0+0x2e4>
        cpus_inited = true;
403755ea:	180c      	movi.n	a8, 1
403755ec:	0020c0        	memw
403755ef:	3c4182        	s8i	a8, a1, 60
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
403755f2:	079d      	mov.n	a9, a7
403755f4:	000806        	j	40375618 <call_start_cpu0+0x2d8>
403755f7:	810000        	src	a0, a0, a0
            cpus_inited &= s_cpu_inited[i];
403755fa:	fb8c      	beqz.n	a11, 4037560d <call_start_cpu0+0x2cd>
403755fc:	889a      	add.n	a8, a8, a9
403755fe:	0020c0        	memw
40375601:	0008a2        	l8ui	a10, a8, 0
40375604:	0020c0        	memw
40375607:	3c0182        	l8ui	a8, a1, 60
4037560a:	748080        	extui	a8, a8, 0, 8
4037560d:	1088a0        	and	a8, a8, a10
40375610:	0020c0        	memw
40375613:	3c4182        	s8i	a8, a1, 60
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
40375616:	991b      	addi.n	a9, a9, 1
40375618:	dd29a6        	blti	a9, 2, 403755f9 <call_start_cpu0+0x2b9>
        }
        esp_rom_delay_us(100);
4037561b:	64a0a2        	movi	a10, 100
4037561e:	fb7d81        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40375621:	0008e0        	callx8	a8
    while (!cpus_inited) {
40375624:	0020c0        	memw
40375627:	3c0182        	l8ui	a8, a1, 60
4037562a:	748080        	extui	a8, a8, 0, 8
4037562d:	fb9816        	beqz	a8, 403755ea <call_start_cpu0+0x2aa>
    asm volatile (
40375630:	03eb80        	rsr.prid	a8
40375633:	048d80        	extui	a8, a8, 13, 1
    }
#endif

    SYS_STARTUP_FN();
40375636:	fb7f91        	l32r	a9, 40374434 <_iram_text_start+0x30> (3c0263dc <g_startup_fn>)
40375639:	a08890        	addx4	a8, a8, a9
4037563c:	0888      	l32i.n	a8, a8, 0
4037563e:	0008e0        	callx8	a8
}
40375641:	f01d      	retw.n
	...

40375644 <xt_highint4>:
    .align      4
xt_highint4:

#ifndef CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    /* See if we're here for the IPC_ISR interrupt */
    rsr     a0, INTERRUPT
40375644:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_IPC_ISR_INUM, 1
40375647:	050c00        	extui	a0, a0, 28, 1
    bnez    a0, jump_to_esp_ipc_isr_handler
4037564a:	07f056        	bnez	a0, 403756cd <jump_to_esp_ipc_isr_handler>
#endif // not CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE

    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
4037564d:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
4037564f:	ffd112        	addmi	a1, a1, 0xffffff00
40375652:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40375655:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
40375657:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
4037565a:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
4037565d:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_4                       /* save interruptee's PC */
4037565f:	03b400        	rsr.epc4	a0
    s32i    a0, sp, XT_STK_PC
40375662:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_4                   /* save interruptee's a0 */
40375664:	03d400        	rsr.excsave4	a0
    s32i    a0, sp, XT_STK_A0
40375667:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
40375669:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
4037566c:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
4037566e:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40375671:	0cad45        	call0	40382148 <_xt_context_save>

    /* Save vaddr into exception frame */
    rsr     a0, EXCVADDR
40375674:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40375677:	156102        	s32i	a0, a1, 84

    /* Figure out reason, save into EXCCAUSE reg */

    rsr     a0, INTERRUPT
4037567a:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_CACHEERR_INUM, 1 /* get cacheerr int bit */
4037567d:	050900        	extui	a0, a0, 25, 1
    beqz    a0, 1f
40375680:	009c      	beqz.n	a0, 40375694 <xt_highint4+0x50>
    /* Kill this interrupt; we cannot reset it. */
    rsr     a0, INTENABLE
40375682:	03e400        	rsr.intenable	a0
    movi    a4, ~(1<<ETS_CACHEERR_INUM)
40375685:	fba141        	l32r	a4, 4037450c <_iram_text_start+0x108> (fdffffff <_rtc_reserved_end+0x9defffff>)
    and     a0, a4, a0
40375688:	100400        	and	a0, a4, a0
    wsr     a0, INTENABLE
4037568b:	13e400        	wsr.intenable	a0
    movi    a0, PANIC_RSN_CACHEERR
4037568e:	700c      	movi.n	a0, 7
    j 9f
40375690:	000406        	j	403756a4 <xt_highint4+0x60>
40375693:	00          	.byte	00

1:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    /* Check if the cause is the app cpu failing to tick.*/
    movi    a0, int_wdt_cpu1_ticked
40375694:	fb9f01        	l32r	a0, 40374510 <_iram_text_start+0x10c> (3fc94d28 <int_wdt_cpu1_ticked>)
    l32i    a0, a0, 0
40375697:	0008      	l32i.n	a0, a0, 0
    bnez    a0, 2f
40375699:	40cc      	bnez.n	a0, 403756a1 <xt_highint4+0x5d>
    /* It is. Modify cause. */
    movi    a0,PANIC_RSN_INTWDT_CPU1
4037569b:	600c      	movi.n	a0, 6
    j 9f
4037569d:	0000c6        	j	403756a4 <xt_highint4+0x60>
403756a0:	a00200        	addx4	a0, a2, a0
2:
#endif

    /* Set EXCCAUSE to reflect cause of the wdt int trigger */
    movi    a0,PANIC_RSN_INTWDT_CPU0
403756a3:	610205        	call0	403d66c4 <_iram_bss_end+0x542c4>
9:
    /* Found the reason, now save it. */
    s32i    a0, sp, XT_STK_EXCCAUSE
403756a6:	9b0114        	ee.vst.h.64.ip	q2, a1, 8

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(5) | PS_UM | PS_WOE
403756a9:	00fb      	addi.n	a0, a0, 15
    wsr     a0, PS
403756ab:	1013e6        	bgei	a3, 1, 403756bf <xt_highint4+0x7b>

    //Call panic handler
    mov     a6,sp
403756ae:	552061        	l32r	a6, 4034ab30 <rom_rx_gain_force+0x344704>
    call4   panicHandler
403756b1:	850033        	lsi	f3, a0, 0x214

    call0   _xt_context_restore
403756b4:	080cb3        	lsi	f11, a12, 32
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
403756b7:	e60021        	l32r	a2, 4036eeb8 <rom_rx_gain_force+0x368a8c>
    wsr     a0, PS
403756ba:	110813        	lsi	f1, a8, 68
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
    wsr     a0, EPC_4
403756bd:	13b400        	wsr.epc4	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
403756c0:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
403756c2:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
403756c4:	002010        	rsync

    rsr     a0, EXCSAVE_4                   /* restore a0 */
403756c7:	03d400        	rsr.excsave4	a0
    rfi     4
403756ca:	003410        	rfi	4

403756cd <jump_to_esp_ipc_isr_handler>:

#ifdef CONFIG_ESP_IPC_ISR_ENABLE
jump_to_esp_ipc_isr_handler:
    /* Address of `esp_ipc_isr_handler_address` will always be in `movi` range
     * as it is defined right above. */
    movi    a0, esp_ipc_isr_handler
403756cd:	fb9201        	l32r	a0, 40374518 <_iram_text_start+0x114> (40375a20 <esp_ipc_isr_handler>)
    jx      a0
403756d0:	0000a0        	jx	a0

403756d3 <ld_include_highint_hdl>:
	...

403756d4 <recalib_bbpll>:
}

// Workaround for bootloader not calibrated well issue.
// Placed in IRAM because disabling BBPLL may influence the cache
static void IRAM_ATTR NOINLINE_ATTR recalib_bbpll(void)
{
403756d4:	006136        	entry	a1, 48
    rtc_cpu_freq_config_t old_config;
    rtc_clk_cpu_freq_get_config(&old_config);
403756d7:	20a110        	or	a10, a1, a1
403756da:	032fa5        	call8	403789d4 <rtc_clk_cpu_freq_get_config>
    // There are two paths we arrive here: 1. CPU reset. 2. Other reset reasons.
    // - For other reasons, the bootloader will set CPU source to BBPLL and enable it. But there are calibration issues.
    //   Turn off the BBPLL and do calibration again to fix the issue.
    // - For CPU reset, the CPU source will be set to XTAL, while the BBPLL is kept to meet USB Serial JTAG's
    //   requirements. In this case, we don't touch BBPLL to avoid USJ disconnection.
    if (old_config.source == SOC_CPU_CLK_SRC_PLL) {
403756dd:	002182        	l32i	a8, a1, 0
403756e0:	081866        	bnei	a8, 1, 403756ec <recalib_bbpll+0x18>
        rtc_clk_cpu_freq_set_xtal();
403756e3:	036be5        	call8	40378da0 <rtc_clk_cpu_freq_set_xtal>
        rtc_clk_cpu_freq_set_config(&old_config);
403756e6:	20a110        	or	a10, a1, a1
403756e9:	036465        	call8	40378d30 <rtc_clk_cpu_freq_set_config>
    }
}
403756ec:	f01d      	retw.n
	...

403756f0 <esp_system_reset_modules_on_exit>:
#define ALIGN_DOWN(val, align)  ((val) & ~((align) - 1))

extern int _bss_end;

void IRAM_ATTR esp_system_reset_modules_on_exit(void)
{
403756f0:	004136        	entry	a1, 32
    // Flush any data left in UART FIFOs before reset the UART peripheral
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
403756f3:	070c      	movi.n	a7, 0
403756f5:	001386        	j	40375747 <esp_system_reset_modules_on_exit+0x57>
        if (uart_ll_is_enabled(i)) {
403756f8:	079d      	mov.n	a9, a7
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
403756fa:	679c      	beqz.n	a7, 40375714 <esp_system_reset_modules_on_exit+0x24>
                            (uart_num == 1) ? SYSTEM_UART1_RST :
403756fc:	1c1726        	beqi	a7, 1, 4037571c <esp_system_reset_modules_on_exit+0x2c>
                            (uart_num == 2) ? SYSTEM_UART2_RST : 0);
403756ff:	052766        	bnei	a7, 2, 40375708 <esp_system_reset_modules_on_exit+0x18>
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
40375702:	00a282        	movi	a8, 0x200
40375705:	000046        	j	4037570a <esp_system_reset_modules_on_exit+0x1a>
40375708:	080c      	movi.n	a8, 0
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
4037570a:	162966        	bnei	a9, 2, 40375724 <esp_system_reset_modules_on_exit+0x34>
4037570d:	00a2a2        	movi	a10, 0x200
40375710:	000486        	j	40375726 <esp_system_reset_modules_on_exit+0x36>
40375713:	480c00        	ssx	f0, a12, a0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
40375716:	08ad      	mov.n	a10, a8
40375718:	000286        	j	40375726 <esp_system_reset_modules_on_exit+0x36>
4037571b:	082c00        	lsx	f2, a12, a0
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
4037571e:	08ad      	mov.n	a10, a8
40375720:	000086        	j	40375726 <esp_system_reset_modules_on_exit+0x36>
40375723:	0a0c00        	add.s	f0, f12, f0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
40375726:	fb7d91        	l32r	a9, 4037451c <_iram_text_start+0x118> (600c0020 <SYSTEM+0x20>)
40375729:	0020c0        	memw
4037572c:	0998      	l32i.n	a9, a9, 0
4037572e:	138987        	bany	a9, a8, 40375745 <esp_system_reset_modules_on_exit+0x55>
        DPORT_REG_GET_BIT(SYSTEM_PERIP_CLK_EN0_REG, uart_en_bit) != 0;
40375731:	fb7b81        	l32r	a8, 40374520 <_iram_text_start+0x11c> (600c0018 <SYSTEM+0x18>)
40375734:	0020c0        	memw
40375737:	0888      	l32i.n	a8, a8, 0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
40375739:	0808a7        	bnone	a8, a10, 40375745 <esp_system_reset_modules_on_exit+0x55>
            esp_rom_output_tx_wait_idle(i);
4037573c:	74a070        	extui	a10, a7, 0, 8
4037573f:	fb6c81        	l32r	a8, 403744f0 <_iram_text_start+0xec> (4000069c <esp_rom_output_tx_wait_idle>)
40375742:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
40375745:	771b      	addi.n	a7, a7, 1
40375747:	ad37a6        	blti	a7, 3, 403756f8 <esp_system_reset_modules_on_exit+0x8>
        }
    }

    // Reset wifi/bluetooth/ethernet/sdio (bb/mac)
    SET_PERI_REG_MASK(SYSTEM_CORE_RST_EN_REG,
4037574a:	fb7681        	l32r	a8, 40374524 <_iram_text_start+0x120> (60026018 <SYSCON+0x18>)
4037574d:	0020c0        	memw
40375750:	0898      	l32i.n	a9, a8, 0
40375752:	fb75a1        	l32r	a10, 40374528 <_iram_text_start+0x124> (3faf <UserFrameTotalSize+0x3eaf>)
40375755:	2099a0        	or	a9, a9, a10
40375758:	0020c0        	memw
4037575b:	0899      	s32i.n	a9, a8, 0
                      SYSTEM_WIFIBB_RST | SYSTEM_FE_RST | SYSTEM_WIFIMAC_RST | SYSTEM_SDIO_RST |
                      SYSTEM_EMAC_RST | SYSTEM_MACPWR_RST | SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST |
                      SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    REG_WRITE(SYSTEM_CORE_RST_EN_REG, 0);
4037575d:	090c      	movi.n	a9, 0
4037575f:	0020c0        	memw
40375762:	0899      	s32i.n	a9, a8, 0

    // Reset timer, systimer, spi, uart, mcpwm
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG,
40375764:	fb6e81        	l32r	a8, 4037451c <_iram_text_start+0x118> (600c0020 <SYSTEM+0x20>)
40375767:	0020c0        	memw
4037576a:	08a8      	l32i.n	a10, a8, 0
4037576c:	fb70b1        	l32r	a11, 4037452c <_iram_text_start+0x128> (20120007 <UserFrameTotalSize+0x2011ff07>)
4037576f:	20aab0        	or	a10, a10, a11
40375772:	0020c0        	memw
40375775:	08a9      	s32i.n	a10, a8, 0
                      SYSTEM_TIMERS_RST | SYSTEM_SPI01_RST | SYSTEM_UART_RST | SYSTEM_SYSTIMER_RST |
                      SYSTEM_PWM0_RST | SYSTEM_PWM1_RST);
    REG_WRITE(SYSTEM_PERIP_RST_EN0_REG, 0);
40375777:	0020c0        	memw
4037577a:	0899      	s32i.n	a9, a8, 0

    // Reset dma and crypto peripherals. This ensures a clean state for the crypto peripherals after a CPU restart
    // and hence avoiding any possibility with crypto failure in ROM security workflows.
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_DMA_RST | SYSTEM_CRYPTO_AES_RST | SYSTEM_CRYPTO_DS_RST |
4037577c:	fb6d81        	l32r	a8, 40374530 <_iram_text_start+0x12c> (600c0024 <SYSTEM+0x24>)
4037577f:	0020c0        	memw
40375782:	08a8      	l32i.n	a10, a8, 0
40375784:	7ea0b2        	movi	a11, 126
40375787:	20aab0        	or	a10, a10, a11
4037578a:	0020c0        	memw
4037578d:	08a9      	s32i.n	a10, a8, 0
                      SYSTEM_CRYPTO_HMAC_RST | SYSTEM_CRYPTO_RSA_RST | SYSTEM_CRYPTO_SHA_RST);
    REG_WRITE(SYSTEM_PERIP_RST_EN1_REG, 0);
4037578f:	0020c0        	memw
40375792:	0899      	s32i.n	a9, a8, 0

    SET_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
40375794:	fb6881        	l32r	a8, 40374534 <_iram_text_start+0x130> (600c0044 <SYSTEM+0x44>)
40375797:	0020c0        	memw
4037579a:	0898      	l32i.n	a9, a8, 0
4037579c:	2a0c      	movi.n	a10, 2
4037579e:	2099a0        	or	a9, a9, a10
403757a1:	0020c0        	memw
403757a4:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
403757a6:	0020c0        	memw
403757a9:	0898      	l32i.n	a9, a8, 0
403757ab:	da7c      	movi.n	a10, -3
403757ad:	1099a0        	and	a9, a9, a10
403757b0:	0020c0        	memw
403757b3:	0899      	s32i.n	a9, a8, 0
}
403757b5:	f01d      	retw.n
	...

403757b8 <esp_restart_noos>:
/* "inner" restart function for after RTOS, interrupts & anything else on this
 * core are already stopped. Stalls other core, resets hardware,
 * triggers restart.
*/
void IRAM_ATTR esp_restart_noos(void)
{
403757b8:	008136        	entry	a1, 64
 * @param intr_mask Bit mask of the interrupts to disable
 */
FORCE_INLINE_ATTR void esp_cpu_intr_disable(uint32_t intr_mask)
{
#ifdef __XTENSA__
    xt_ints_off(intr_mask);
403757bb:	fa7c      	movi.n	a10, -1
403757bd:	0cb365        	call8	403822f4 <xt_ints_off>
    // Disable interrupts
    esp_cpu_intr_disable(0xFFFFFFFF);

    // Enable RTC watchdog for 1 second
    wdt_hal_context_t rtc_wdt_ctx;
    wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
403757c0:	0d0c      	movi.n	a13, 0
403757c2:	0dcd      	mov.n	a12, a13
403757c4:	0dbd      	mov.n	a11, a13
403757c6:	01ad      	mov.n	a10, a1
403757c8:	fb6581        	l32r	a8, 4037455c <_iram_text_start+0x158> (40000dbc <wdt_hal_init>)
403757cb:	0008e0        	callx8	a8
    uint32_t stage_timeout_ticks = (uint32_t)(1000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
403757ce:	030ee5        	call8	403788bc <rtc_clk_slow_freq_get_hz>
403757d1:	060c      	movi.n	a6, 0
403757d3:	e8a3c2        	movi	a12, 0x3e8
403757d6:	a2bca0        	muluh	a11, a12, a10
403757d9:	06dd      	mov.n	a13, a6
403757db:	82aca0        	mull	a10, a12, a10
403757de:	fb4581        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
403757e1:	0008e0        	callx8	a8
403757e4:	0a7d      	mov.n	a7, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
403757e6:	01ad      	mov.n	a10, a1
403757e8:	fb5e81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40000de0 <wdt_hal_write_protect_disable>)
403757eb:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
403757ee:	3d0c      	movi.n	a13, 3
403757f0:	07cd      	mov.n	a12, a7
403757f2:	06bd      	mov.n	a11, a6
403757f4:	01ad      	mov.n	a10, a1
403757f6:	fb5b81        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000dd4 <wdt_hal_config_stage>)
403757f9:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE1, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
403757fc:	4d0c      	movi.n	a13, 4
403757fe:	07cd      	mov.n	a12, a7
40375800:	1b0c      	movi.n	a11, 1
40375802:	01ad      	mov.n	a10, a1
40375804:	fb5881        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000dd4 <wdt_hal_config_stage>)
40375807:	0008e0        	callx8	a8
    //Enable flash boot mode so that flash booting after restart is protected by the RTC WDT.
    wdt_hal_set_flashboot_en(&rtc_wdt_ctx, true);
4037580a:	1b0c      	movi.n	a11, 1
4037580c:	01ad      	mov.n	a10, a1
4037580e:	fb5681        	l32r	a8, 40374568 <_iram_text_start+0x164> (40000e28 <wdt_hal_set_flashboot_en>)
40375811:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
40375814:	01ad      	mov.n	a10, a1
40375816:	fb5581        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000dec <wdt_hal_write_protect_enable>)
40375819:	0008e0        	callx8	a8

    // Disable TG0/TG1 watchdogs
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
4037581c:	fb4781        	l32r	a8, 40374538 <_iram_text_start+0x134> (3c026430 <__func__$0+0x10>)
4037581f:	718b      	addi.n	a7, a1, 8
40375821:	0898      	l32i.n	a9, a8, 0
40375823:	1888      	l32i.n	a8, a8, 4
40375825:	2199      	s32i.n	a9, a1, 8
40375827:	3189      	s32i.n	a8, a1, 12
    wdt_hal_write_protect_disable(&wdt0_context);
40375829:	07ad      	mov.n	a10, a7
4037582b:	fb4d81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40000de0 <wdt_hal_write_protect_disable>)
4037582e:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
40375831:	07ad      	mov.n	a10, a7
40375833:	fb4f81        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000e04 <wdt_hal_disable>)
40375836:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
40375839:	07ad      	mov.n	a10, a7
4037583b:	fb4c81        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000dec <wdt_hal_write_protect_enable>)
4037583e:	0008e0        	callx8	a8

    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
40375841:	fb3e81        	l32r	a8, 4037453c <_iram_text_start+0x138> (3c026438 <__func__$0+0x18>)
40375844:	10c172        	addi	a7, a1, 16
40375847:	0898      	l32i.n	a9, a8, 0
40375849:	1888      	l32i.n	a8, a8, 4
4037584b:	4199      	s32i.n	a9, a1, 16
4037584d:	5189      	s32i.n	a8, a1, 20
    wdt_hal_write_protect_disable(&wdt1_context);
4037584f:	07ad      	mov.n	a10, a7
40375851:	fb4381        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40000de0 <wdt_hal_write_protect_disable>)
40375854:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
40375857:	07ad      	mov.n	a10, a7
40375859:	fb4581        	l32r	a8, 40374570 <_iram_text_start+0x16c> (40000e04 <wdt_hal_disable>)
4037585c:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
4037585f:	07ad      	mov.n	a10, a7
40375861:	fb4281        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000dec <wdt_hal_write_protect_enable>)
40375864:	0008e0        	callx8	a8
40375867:	03eb50        	rsr.prid	a5
4037586a:	045d50        	extui	a5, a5, 13, 1
    // CPU must be reset before stalling, in case it was running a s32c1i
    // instruction. This would cause memory pool to be locked by arbiter
    // to the stalled CPU, preventing current CPU from accessing this pool.
    const uint32_t core_id = esp_cpu_get_core_id();
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
4037586d:	40f570        	nsau	a7, a5
40375870:	417570        	srli	a7, a7, 5
    esp_rom_software_reset_cpu(other_core_id);
40375873:	07ad      	mov.n	a10, a7
40375875:	fb3f81        	l32r	a8, 40374574 <_iram_text_start+0x170> (400006e4 <esp_rom_software_reset_cpu>)
40375878:	0008e0        	callx8	a8
    esp_cpu_stall(other_core_id);
4037587b:	07ad      	mov.n	a10, a7
4037587d:	024ae5        	call8	40377d2c <esp_cpu_stall>
#endif

    // Disable cache
    Cache_Disable_ICache();
40375880:	fb3e81        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
40375883:	0008e0        	callx8	a8
    Cache_Disable_DCache();
40375886:	fb3d81        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
40375889:	0008e0        	callx8	a8

    // 2nd stage bootloader reconfigures SPI flash signals.
    // Reset them to the defaults expected by ROM.
    WRITE_PERI_REG(GPIO_FUNC0_IN_SEL_CFG_REG, 0x30);
4037588c:	083c      	movi.n	a8, 48
4037588e:	fb2c91        	l32r	a9, 40374540 <_iram_text_start+0x13c> (60004154 <GPIO+0x154>)
40375891:	0020c0        	memw
40375894:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC1_IN_SEL_CFG_REG, 0x30);
40375896:	fb2b91        	l32r	a9, 40374544 <_iram_text_start+0x140> (60004158 <GPIO+0x158>)
40375899:	0020c0        	memw
4037589c:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC2_IN_SEL_CFG_REG, 0x30);
4037589e:	fb2a91        	l32r	a9, 40374548 <_iram_text_start+0x144> (6000415c <GPIO+0x15c>)
403758a1:	0020c0        	memw
403758a4:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC3_IN_SEL_CFG_REG, 0x30);
403758a6:	fb2991        	l32r	a9, 4037454c <_iram_text_start+0x148> (60004160 <GPIO+0x160>)
403758a9:	0020c0        	memw
403758ac:	0989      	s32i.n	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC4_IN_SEL_CFG_REG, 0x30);
403758ae:	fb2891        	l32r	a9, 40374550 <_iram_text_start+0x14c> (60004164 <GPIO+0x164>)
403758b1:	0020c0        	memw
403758b4:	006982        	s32i	a8, a9, 0
    WRITE_PERI_REG(GPIO_FUNC5_IN_SEL_CFG_REG, 0x30);
403758b7:	fb2791        	l32r	a9, 40374554 <_iram_text_start+0x150> (60004168 <GPIO+0x168>)
403758ba:	0020c0        	memw
403758bd:	006982        	s32i	a8, a9, 0

    // reset necessary peripheral modules
    esp_system_reset_modules_on_exit();
403758c0:	ffe2e5        	call8	403756f0 <esp_system_reset_modules_on_exit>

    // Set CPU back to XTAL source, same as hard reset, but keep BBPLL on so that USB Serial JTAG can log at 1st stage bootloader.
#if !CONFIG_IDF_ENV_FPGA
    rtc_clk_cpu_set_to_default_config();
403758c3:	034ce5        	call8	40378d90 <rtc_clk_cpu_set_to_default_config>
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // Clear entry point for APP CPU
    REG_WRITE(SYSTEM_CORE_1_CONTROL_1_REG, 0);
403758c6:	fb2481        	l32r	a8, 40374558 <_iram_text_start+0x154> (600c0004 <SYSTEM+0x4>)
403758c9:	0020c0        	memw
403758cc:	0869      	s32i.n	a6, a8, 0
#endif

    // Reset CPUs
    if (core_id == 0) {
403758ce:	25dc      	bnez.n	a5, 403758e4 <esp_restart_noos+0x12c>
        // Running on PRO CPU: APP CPU is stalled. Can reset both CPUs.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
        esp_rom_software_reset_cpu(1);
403758d0:	1a0c      	movi.n	a10, 1
403758d2:	fb2881        	l32r	a8, 40374574 <_iram_text_start+0x170> (400006e4 <esp_rom_software_reset_cpu>)
403758d5:	0008e0        	callx8	a8
#endif
        esp_rom_software_reset_cpu(0);
403758d8:	0a0c      	movi.n	a10, 0
403758da:	fb2681        	l32r	a8, 40374574 <_iram_text_start+0x170> (400006e4 <esp_rom_software_reset_cpu>)
403758dd:	0008e0        	callx8	a8
403758e0:	000606        	j	403758fc <esp_restart_noos+0x144>
403758e3:	a0a200        	addx4	a10, a2, a0
    }
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    else {
        // Running on APP CPU: need to reset PRO CPU and unstall it,
        // then reset APP CPU
        esp_rom_software_reset_cpu(0);
403758e6:	238100        	sext	a8, a1, 7
403758e9:	e0fb      	addi.n	a14, a0, 15
403758eb:	0008      	l32i.n	a0, a0, 0
        esp_cpu_unstall(0);
403758ed:	00a0a2        	movi	a10, 0
403758f0:	024be5        	call8	40377db0 <esp_cpu_unstall>
        esp_rom_software_reset_cpu(1);
403758f3:	01a0a2        	movi	a10, 1
403758f6:	fb1f81        	l32r	a8, 40374574 <_iram_text_start+0x170> (400006e4 <esp_rom_software_reset_cpu>)
403758f9:	0008e0        	callx8	a8
    }
#endif

    ESP_INFINITE_LOOP();
403758fc:	ffff06        	j	403758fc <esp_restart_noos+0x144>
	...

40375900 <apb_backup_dma_unlock>:
        portENTER_CRITICAL(&s_apb_backup_dma_mutex);
    }
}

static void IRAM_ATTR apb_backup_dma_unlock(void)
{
40375900:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40375903:	046ee5        	call8	40379ff0 <xPortInIsrContext>
40375906:	aa8c      	beqz.n	a10, 40375914 <apb_backup_dma_unlock+0x14>
        portEXIT_CRITICAL_ISR(&s_apb_backup_dma_mutex);
40375908:	fb1ea1        	l32r	a10, 40374580 <_iram_text_start+0x17c> (3fc92400 <s_apb_backup_dma_mutex>)
4037590b:	0485a5        	call8	4037a164 <vPortExitCritical>
4037590e:	000206        	j	4037591a <apb_backup_dma_unlock+0x1a>
40375911:	000000        	ill
    } else {
        portEXIT_CRITICAL(&s_apb_backup_dma_mutex);
40375914:	fb1ba1        	l32r	a10, 40374580 <_iram_text_start+0x17c> (3fc92400 <s_apb_backup_dma_mutex>)
40375917:	0484e5        	call8	4037a164 <vPortExitCritical>
    }
}
4037591a:	f01d      	retw.n

4037591c <apb_backup_dma_lock>:
{
4037591c:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
4037591f:	046d25        	call8	40379ff0 <xPortInIsrContext>
40375922:	00ba16        	beqz	a10, 40375931 <apb_backup_dma_lock+0x15>

// ------------------ Critical Sections --------------------

static inline void __attribute__((always_inline)) vPortEnterCritical(portMUX_TYPE *mux)
{
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40375925:	fb7c      	movi.n	a11, -1
40375927:	fb16a1        	l32r	a10, 40374580 <_iram_text_start+0x17c> (3fc92400 <s_apb_backup_dma_mutex>)
4037592a:	046ea5        	call8	4037a014 <xPortEnterCriticalTimeout>
}
4037592d:	000206        	j	40375939 <apb_backup_dma_lock+0x1d>
40375930:	00          	.byte	00
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40375931:	fb7c      	movi.n	a11, -1
40375933:	fb13a1        	l32r	a10, 40374580 <_iram_text_start+0x17c> (3fc92400 <s_apb_backup_dma_mutex>)
40375936:	046de5        	call8	4037a014 <xPortEnterCriticalTimeout>
}
40375939:	f01d      	retw.n
	...

4037593c <tick_hook>:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
volatile bool int_wdt_cpu1_ticked = false;
#endif

static void IRAM_ATTR tick_hook(void)
{
4037593c:	004136        	entry	a1, 32
4037593f:	03eb80        	rsr.prid	a8
40375942:	048d80        	extui	a8, a8, 13, 1
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    if (esp_cpu_get_core_id() != 0) {
40375945:	c88c      	beqz.n	a8, 40375955 <tick_hook+0x19>
        int_wdt_cpu1_ticked = true;
40375947:	faf281        	l32r	a8, 40374510 <_iram_text_start+0x10c> (3fc94d28 <int_wdt_cpu1_ticked>)
4037594a:	190c      	movi.n	a9, 1
4037594c:	0020c0        	memw
4037594f:	004892        	s8i	a9, a8, 0
40375952:	001586        	j	403759ac <tick_hook+0x70>
    } else {
        // Only feed wdt if app cpu also ticked.
        if (int_wdt_cpu1_ticked) {
40375955:	faee81        	l32r	a8, 40374510 <_iram_text_start+0x10c> (3fc94d28 <int_wdt_cpu1_ticked>)
40375958:	0020c0        	memw
4037595b:	000882        	l8ui	a8, a8, 0
4037595e:	748080        	extui	a8, a8, 0, 8
40375961:	047816        	beqz	a8, 403759ac <tick_hook+0x70>
            // Todo: Check if there's a way to avoid reconfiguring the stages on each feed.
            wdt_hal_write_protect_disable(&iwdt_context);
40375964:	fb0871        	l32r	a7, 40374584 <_iram_text_start+0x180> (3fc94d2c <iwdt_context>)
40375967:	20a770        	or	a10, a7, a7
4037596a:	fafd81        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40000de0 <wdt_hal_write_protect_disable>)
4037596d:	0008e0        	callx8	a8
#if CONFIG_ESP32_ECO3_CACHE_LOCK_FIX
            _lx_intr_livelock_counter = 0;
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0,
                                 CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US / (_lx_intr_livelock_max + 1), WDT_STAGE_ACTION_INT);                    // Set timeout before interrupt
#else
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);          // Set timeout before interrupt
40375970:	01a0d2        	movi	a13, 1
40375973:	58a2c2        	movi	a12, 0x258
40375976:	00a0b2        	movi	a11, 0
40375979:	20a770        	or	a10, a7, a7
4037597c:	fafa81        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000dd4 <wdt_hal_config_stage>)
4037597f:	0008e0        	callx8	a8
#endif
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
40375982:	3d0c      	movi.n	a13, 3
40375984:	b0a4c2        	movi	a12, 0x4b0
40375987:	1b0c      	movi.n	a11, 1
40375989:	07ad      	mov.n	a10, a7
4037598b:	faf681        	l32r	a8, 40374564 <_iram_text_start+0x160> (40000dd4 <wdt_hal_config_stage>)
4037598e:	0008e0        	callx8	a8
            wdt_hal_feed(&iwdt_context);
40375991:	07ad      	mov.n	a10, a7
40375993:	fafd81        	l32r	a8, 40374588 <_iram_text_start+0x184> (40000e1c <wdt_hal_feed>)
40375996:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&iwdt_context);
40375999:	07ad      	mov.n	a10, a7
4037599b:	faf481        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000dec <wdt_hal_write_protect_enable>)
4037599e:	0008e0        	callx8	a8
            int_wdt_cpu1_ticked = false;
403759a1:	fadb81        	l32r	a8, 40374510 <_iram_text_start+0x10c> (3fc94d28 <int_wdt_cpu1_ticked>)
403759a4:	090c      	movi.n	a9, 0
403759a6:	0020c0        	memw
403759a9:	004892        	s8i	a9, a8, 0
        wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
        wdt_hal_feed(&iwdt_context);
        wdt_hal_write_protect_enable(&iwdt_context);
    }
#endif // CONFIG_ESP_INT_WDT_CHECK_CPU1
}
403759ac:	f01d      	retw.n
	...

403759b0 <panic_abort>:
#endif /* CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT || CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT */
#endif /* CONFIG_ESP_SYSTEM_PANIC_GDBSTUB */
}

void IRAM_ATTR __attribute__((noreturn, no_sanitize_undefined)) panic_abort(const char *details)
{
403759b0:	004136        	entry	a1, 32
    g_panic_abort = true;
403759b3:	faf681        	l32r	a8, 4037458c <_iram_text_start+0x188> (3fc94d3c <g_panic_abort>)
403759b6:	190c      	movi.n	a9, 1
403759b8:	004892        	s8i	a9, a8, 0
    g_panic_abort_details = (char *) details;
403759bb:	faf581        	l32r	a8, 40374590 <_iram_text_start+0x18c> (3fc94d38 <g_panic_abort_details>)
403759be:	0829      	s32i.n	a2, a8, 0
                              APPTRACE_ONPANIC_HOST_FLUSH_TMO);
#endif
#endif

#ifdef __XTENSA__
    asm("ill");     // should be an invalid operation on xtensa targets
403759c0:	000000        	ill
#elif __riscv
    asm("unimp");   // should be an invalid operation on RISC-V targets
#endif

    ESP_INFINITE_LOOP();
403759c3:	ffff06        	j	403759c3 <panic_abort+0x13>
	...

403759c8 <panic_enable_cache>:
 * This function must always be in IRAM as it is required to
 * re-enable the flash cache.
 */
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
static void IRAM_ATTR panic_enable_cache(void)
{
403759c8:	004136        	entry	a1, 32
403759cb:	03eb70        	rsr.prid	a7
403759ce:	047d70        	extui	a7, a7, 13, 1
    int core_id = esp_cpu_get_core_id();
    if (!spi_flash_cache_enabled()) {
403759d1:	01fe25        	call8	403779b4 <spi_flash_cache_enabled>
403759d4:	008a56        	bnez	a10, 403759e0 <panic_enable_cache+0x18>
        esp_ipc_isr_stall_abort();
403759d7:	0003a5        	call8	40375a10 <esp_ipc_isr_stall_abort>
        spi_flash_enable_cache(core_id);
403759da:	20a770        	or	a10, a7, a7
403759dd:	01fc65        	call8	403779a4 <spi_flash_enable_cache>
    }

#if SOC_CACHE_ACS_INVALID_STATE_ON_PANIC
    // Some errors need to be cleared here to allow cache to operate normally again
    // for certain circumstances.
    esp_cache_err_acs_save_and_clr();
403759e0:	faed81        	l32r	a8, 40374594 <_iram_text_start+0x190> (42001c68 <esp_cache_err_acs_save_and_clr>)
403759e3:	0008e0        	callx8	a8
#endif //SOC_CACHE_ACS_INVALID_STATE_ON_PANIC
}
403759e6:	f01d      	retw.n

403759e8 <panicHandler>:
#endif

void IRAM_ATTR panicHandler(void *frame)
{
403759e8:	004136        	entry	a1, 32
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    panic_enable_cache();
403759eb:	fffde5        	call8	403759c8 <panic_enable_cache>
#endif
    // This panic handler gets called for when the double exception vector,
    // kernel exception vector gets used; as well as handling interrupt-based
    // faults cache error, wdt expiry. EXCAUSE register gets written with
    // one of PANIC_RSN_* values.
    panic_handler(frame, true);
403759ee:	1b0c      	movi.n	a11, 1
403759f0:	02ad      	mov.n	a10, a2
403759f2:	fae981        	l32r	a8, 40374598 <_iram_text_start+0x194> (42002390 <panic_handler>)
403759f5:	0008e0        	callx8	a8
}
403759f8:	f01d      	retw.n
	...

403759fc <xt_unhandled_exception>:

void IRAM_ATTR xt_unhandled_exception(void *frame)
{
403759fc:	004136        	entry	a1, 32
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    panic_enable_cache();
403759ff:	fffca5        	call8	403759c8 <panic_enable_cache>
#endif
    panic_handler(frame, false);
40375a02:	0b0c      	movi.n	a11, 0
40375a04:	02ad      	mov.n	a10, a2
40375a06:	fae481        	l32r	a8, 40374598 <_iram_text_start+0x194> (42002390 <panic_handler>)
40375a09:	0008e0        	callx8	a8
}
40375a0c:	f01d      	retw.n
	...

40375a10 <esp_ipc_isr_stall_abort>:
    s_stall_state = STALL_STATE_IDLE;
    IPC_ISR_EXIT_CRITICAL();
}

void IRAM_ATTR esp_ipc_isr_stall_abort(void)
{
40375a10:	004136        	entry	a1, 32
    //Note: We don't enter a critical section here as we are calling this from a panic.
    s_stall_state = STALL_STATE_IDLE;
40375a13:	fae281        	l32r	a8, 4037459c <_iram_text_start+0x198> (3fc94d48 <s_stall_state>)
40375a16:	090c      	movi.n	a9, 0
40375a18:	0020c0        	memw
40375a1b:	0899      	s32i.n	a9, a8, 0
}
40375a1d:	f01d      	retw.n
	...

40375a20 <esp_ipc_isr_handler>:
       allows one cpu to enter in the IPC_ISR section of the LX
       interrupt at one time, there's no need to have two
       _lx_intr_stack for each cpu */

    /* Save A0, A2, A3, A4 so we can use those registers further*/
    movi    a0, _lx_intr_stack
40375a20:	fae001        	l32r	a0, 403745a0 <_iram_text_start+0x19c> (3fc92418 <_lx_intr_stack>)
    s32i    a2, a0, LX_INTR_A2_OFFSET
40375a23:	1029      	s32i.n	a2, a0, 4
    s32i    a3, a0, LX_INTR_A3_OFFSET
40375a25:	2039      	s32i.n	a3, a0, 8
    s32i    a4, a0, LX_INTR_A4_OFFSET
40375a27:	3049      	s32i.n	a4, a0, 12
    rsr     a2, EXCSAVE_X
40375a29:	03d420        	rsr.excsave4	a2
    s32i    a2, a0, LX_INTR_A0_OFFSET
40375a2c:	0029      	s32i.n	a2, a0, 0

    /* disable nested iterrupts */
    /* PS.EXCM is changed from 1 to 0 . It allows using usually exception handler instead of the Double exception handler. */
    /* PS_UM = 1 */
    movi    a0, PS_INTLEVEL(5) | PS_UM
40375a2e:	502c      	movi.n	a0, 37
    wsr     a0, PS
40375a30:	13e600        	wsr.ps	a0
    rsync
40375a33:	002010        	rsync
#if CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5
    /* This int is level-triggered and doesn't need clearing.
       Do nothing here and clear int status by peripheral register later.*/
#elif CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4
    /* This int is edge-triggered and needs clearing. */
    movi    a3, (1 << ETS_IPC_ISR_INUM)
40375a36:	fadb31        	l32r	a3, 403745a4 <_iram_text_start+0x1a0> (10000000 <UserFrameTotalSize+0xfffff00>)
    wsr     a3, INTCLEAR
40375a39:	13e330        	wsr.intclear	a3
#endif /* CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5 */

    /* get CORE_ID */
    getcoreid   a3
40375a3c:	03eb30        	rsr.prid	a3
40375a3f:	043d30        	extui	a3, a3, 13, 1
    beqz    a3, 1f
40375a42:	a38c      	beqz.n	a3, 40375a50 <esp_ipc_isr_handler+0x30>

    /* current cpu is 1 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_3_REG
40375a44:	fad931        	l32r	a3, 403745a8 <_iram_text_start+0x1a4> (600c003c <SYSTEM+0x3c>)
    movi    a4, 0
40375a47:	040c      	movi.n	a4, 0
    s32i    a4, a3, 0   /* clear intr */
40375a49:	0349      	s32i.n	a4, a3, 0
    j       2f
40375a4b:	000206        	j	40375a57 <esp_ipc_isr_handler+0x37>
40375a4e:	310000        	srai	a0, a0, 16
1:
    /* current cpu is 0 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_2_REG
40375a51:	0cfad7        	bbsi	a10, 29, 40375a61 <esp_ipc_isr_handler+0x41>
    movi    a4, 0
40375a54:	04          	.byte	0x4
    s32i    a4, a3, 0   /* clear intr */
40375a55:	0349      	s32i.n	a4, a3, 0
2:

    /* set the start flag */
    movi    a0, esp_ipc_isr_start_fl
40375a57:	fad601        	l32r	a0, 403745b0 <_iram_text_start+0x1ac> (3fc94d54 <esp_ipc_isr_start_fl>)
    memw
40375a5a:	0020c0        	memw
    s32i    a0, a0, 0
40375a5d:	0009      	s32i.n	a0, a0, 0

    /* Call the esp_ipc_function(void* arg) */
    movi    a0, esp_ipc_func
40375a5f:	fad501        	l32r	a0, 403745b4 <_iram_text_start+0x1b0> (3fc94d50 <esp_ipc_func>)
    l32i    a0, a0, 0
40375a62:	0008      	l32i.n	a0, a0, 0
    movi    a2, esp_ipc_func_arg
40375a64:	fad521        	l32r	a2, 403745b8 <_iram_text_start+0x1b4> (3fc94d4c <esp_ipc_func_arg>)
    l32i    a2, a2, 0
40375a67:	0228      	l32i.n	a2, a2, 0
    callx0  a0
40375a69:	0000c0        	callx0	a0

    /* Done. Restore registers and return. */
    movi    a0, _lx_intr_stack
40375a6c:	facd01        	l32r	a0, 403745a0 <_iram_text_start+0x19c> (3fc92418 <_lx_intr_stack>)
    l32i    a2, a0, LX_INTR_A2_OFFSET
40375a6f:	1028      	l32i.n	a2, a0, 4
    l32i    a3, a0, LX_INTR_A3_OFFSET
40375a71:	2038      	l32i.n	a3, a0, 8
    l32i    a4, a0, LX_INTR_A4_OFFSET
40375a73:	3048      	l32i.n	a4, a0, 12

    /* set the end flag */
    movi    a0, esp_ipc_isr_end_fl
40375a75:	fad101        	l32r	a0, 403745bc <_iram_text_start+0x1b8> (3fc92414 <esp_ipc_isr_end_fl>)
    memw
40375a78:	0020c0        	memw
    s32i    a0, a0, 0
40375a7b:	0009      	s32i.n	a0, a0, 0

    /* restore a0 */
    rsr     a0, EXCSAVE_X
40375a7d:	03d400        	rsr.excsave4	a0
    /* restores PS from EPS[X] and jumps to the address in EPC[X] */
    rfi     RFI_X
40375a80:	003410        	rfi	4
	...

40375a84 <print_entry>:
    //Return true if both sp and pc of frame(i-1) are sane, false otherwise
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
}

static void IRAM_ATTR print_entry(uint32_t pc, uint32_t sp, bool panic)
{
40375a84:	004136        	entry	a1, 32
    if (panic) {
40375a87:	54ac      	beqz.n	a4, 40375ab0 <print_entry+0x2c>
        panic_print_str(" 0x");
40375a89:	facda1        	l32r	a10, 403745c0 <_iram_text_start+0x1bc> (3c0209fc <_flash_rodata_start+0x8dc>)
40375a8c:	fad081        	l32r	a8, 403745cc <_iram_text_start+0x1c8> (42001fe8 <panic_print_str>)
40375a8f:	0008e0        	callx8	a8
        panic_print_hex(pc);
40375a92:	02ad      	mov.n	a10, a2
40375a94:	facf81        	l32r	a8, 403745d0 <_iram_text_start+0x1cc> (42002014 <panic_print_hex>)
40375a97:	0008e0        	callx8	a8
        panic_print_str(":0x");
40375a9a:	facaa1        	l32r	a10, 403745c4 <_iram_text_start+0x1c0> (3c020e98 <_flash_rodata_start+0xd78>)
40375a9d:	facb81        	l32r	a8, 403745cc <_iram_text_start+0x1c8> (42001fe8 <panic_print_str>)
40375aa0:	0008e0        	callx8	a8
        panic_print_hex(sp);
40375aa3:	20a330        	or	a10, a3, a3
40375aa6:	faca81        	l32r	a8, 403745d0 <_iram_text_start+0x1cc> (42002014 <panic_print_hex>)
40375aa9:	0008e0        	callx8	a8
40375aac:	000346        	j	40375abd <print_entry+0x39>
40375aaf:	00          	.byte	00
    } else {
        esp_rom_printf(" 0x%08" PRIX32 ":0x%08" PRIX32, pc, sp);
40375ab0:	03cd      	mov.n	a12, a3
40375ab2:	02bd      	mov.n	a11, a2
40375ab4:	fac5a1        	l32r	a10, 403745c8 <_iram_text_start+0x1c4> (3c020e9c <_flash_rodata_start+0xd7c>)
40375ab7:	fa8981        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40375aba:	0008e0        	callx8	a8
    }
}
40375abd:	f01d      	retw.n
	...

40375ac0 <print_str>:

static void IRAM_ATTR print_str(const char* str, bool panic)
{
40375ac0:	004136        	entry	a1, 32
40375ac3:	02ad      	mov.n	a10, a2
    if (panic) {
40375ac5:	738c      	beqz.n	a3, 40375ad0 <print_str+0x10>
        panic_print_str(str);
40375ac7:	fac181        	l32r	a8, 403745cc <_iram_text_start+0x1c8> (42001fe8 <panic_print_str>)
40375aca:	0008e0        	callx8	a8
40375acd:	000146        	j	40375ad6 <print_str+0x16>
    } else {
        esp_rom_printf(str);
40375ad0:	fa8381        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40375ad3:	0008e0        	callx8	a8
    }
}
40375ad6:	f01d      	retw.n

40375ad8 <esp_backtrace_get_next_frame>:
{
40375ad8:	004136        	entry	a1, 32
    void *base_save = (void *)frame->sp;     //Base save area consists of 4 words under SP
40375adb:	1288      	l32i.n	a8, a2, 4
    frame->pc = frame->next_pc;
40375add:	22a8      	l32i.n	a10, a2, 8
40375adf:	02a9      	s32i.n	a10, a2, 0
    frame->next_pc = *((uint32_t *)(base_save - 16));     //If next_pc = 0, indicates frame(i-1) is the last frame on the stack
40375ae1:	f0c892        	addi	a9, a8, -16
40375ae4:	0998      	l32i.n	a9, a9, 0
40375ae6:	2299      	s32i.n	a9, a2, 8
    frame->sp =  *((uint32_t *)(base_save - 12));
40375ae8:	f4c882        	addi	a8, a8, -12
40375aeb:	0888      	l32i.n	a8, a8, 0
40375aed:	1289      	s32i.n	a8, a2, 4
 */
__attribute__((always_inline))
inline static bool esp_stack_ptr_in_dram(uint32_t sp)
{
    //Check if stack ptr is in between SOC_DRAM_LOW and SOC_DRAM_HIGH, and 16 byte aligned.
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375aef:	fab991        	l32r	a9, 403745d4 <_iram_text_start+0x1d0> (c0377ff0 <_rtc_reserved_end+0x60277ff0>)
40375af2:	989a      	add.n	a9, a8, a9
40375af4:	fab9b1        	l32r	a11, 403745d8 <_iram_text_start+0x1d4> (77fe0 <UserFrameTotalSize+0x77ee0>)
40375af7:	053b97        	bltu	a11, a9, 40375b00 <esp_backtrace_get_next_frame+0x28>
40375afa:	349080        	extui	a9, a8, 0, 4
40375afd:	00b916        	beqz	a9, 40375b0c <esp_backtrace_get_next_frame+0x34>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40375b00:	fab791        	l32r	a9, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40375b03:	808890        	add	a8, a8, a9
    return esp_stack_ptr_in_dram(sp)
#if CONFIG_FREERTOS_TASK_CREATE_ALLOW_EXT_MEM
        || esp_stack_ptr_in_extram(sp)
#endif
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375b06:	fab691        	l32r	a9, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40375b09:	1b3987        	bltu	a9, a8, 40375b28 <esp_backtrace_get_next_frame+0x50>
 * @param pc PC value of the current backtrace frame
 *
 */
static inline uint32_t esp_cpu_process_stack_pc(uint32_t pc)
{
    if (pc & 0x80000000) {
40375b0c:	00bad6        	bgez	a10, 40375b1b <esp_backtrace_get_next_frame+0x43>
        //Top two bits of a0 (return address) specify window increment. Overwrite to map to address space.
        pc = (pc & 0x3fffffff) | 0x40000000;
40375b0f:	11aae0        	slli	a10, a10, 2
40375b12:	41a2a0        	srli	a10, a10, 2
40375b15:	fab381        	l32r	a8, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
40375b18:	20aa80        	or	a10, a10, a8
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
40375b1b:	fdcaa2        	addi	a10, a10, -3
40375b1e:	023da5        	call8	40377ef8 <esp_ptr_executable>
40375b21:	8a8c      	beqz.n	a10, 40375b2d <esp_backtrace_get_next_frame+0x55>
40375b23:	120c      	movi.n	a2, 1
40375b25:	000186        	j	40375b2f <esp_backtrace_get_next_frame+0x57>
40375b28:	020c      	movi.n	a2, 0
40375b2a:	000046        	j	40375b2f <esp_backtrace_get_next_frame+0x57>
40375b2d:	020c      	movi.n	a2, 0
}
40375b2f:	f01d      	retw.n
40375b31:	000000        	ill

40375b34 <esp_backtrace_print_from_frame>:

esp_err_t IRAM_ATTR esp_backtrace_print_from_frame(int depth, const esp_backtrace_frame_t* frame, bool panic)
{
40375b34:	006136        	entry	a1, 48
40375b37:	20b330        	or	a11, a3, a3
40375b3a:	744040        	extui	a4, a4, 0, 8
    //Check arguments
    if (depth <= 0) {
40375b3d:	0212e6        	bgei	a2, 1, 40375b43 <esp_backtrace_print_from_frame+0xf>
40375b40:	003d46        	j	40375c39 <esp_backtrace_print_from_frame+0x105>
        return ESP_ERR_INVALID_ARG;
    }

    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t stk_frame;
    memcpy(&stk_frame, frame, sizeof(esp_backtrace_frame_t));
40375b43:	0c1c      	movi.n	a12, 16
40375b45:	20a110        	or	a10, a1, a1
40375b48:	fa6e81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40375b4b:	0008e0        	callx8	a8

    print_str("\r\n\r\nBacktrace:", panic);
40375b4e:	04bd      	mov.n	a11, a4
40375b50:	faa6a1        	l32r	a10, 403745e8 <_iram_text_start+0x1e4> (3c020eb0 <_flash_rodata_start+0xd90>)
40375b53:	fff6e5        	call8	40375ac0 <print_str>
    print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375b56:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375b58:	00bad6        	bgez	a10, 40375b67 <esp_backtrace_print_from_frame+0x33>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375b5b:	11aae0        	slli	a10, a10, 2
40375b5e:	41a2a0        	srli	a10, a10, 2
40375b61:	faa081        	l32r	a8, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
40375b64:	20aa80        	or	a10, a10, a8
40375b67:	04cd      	mov.n	a12, a4
40375b69:	11b8      	l32i.n	a11, a1, 4
40375b6b:	fdcaa2        	addi	a10, a10, -3
40375b6e:	fff165        	call8	40375a84 <print_entry>

    //Check if first frame is valid
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375b71:	1188      	l32i.n	a8, a1, 4
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375b73:	fa9891        	l32r	a9, 403745d4 <_iram_text_start+0x1d0> (c0377ff0 <_rtc_reserved_end+0x60277ff0>)
40375b76:	989a      	add.n	a9, a8, a9
40375b78:	fa98a1        	l32r	a10, 403745d8 <_iram_text_start+0x1d4> (77fe0 <UserFrameTotalSize+0x77ee0>)
40375b7b:	053a97        	bltu	a10, a9, 40375b84 <esp_backtrace_print_from_frame+0x50>
40375b7e:	349080        	extui	a9, a8, 0, 4
40375b81:	00a916        	beqz	a9, 40375b8f <esp_backtrace_print_from_frame+0x5b>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40375b84:	fa9691        	l32r	a9, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40375b87:	889a      	add.n	a8, a8, a9
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375b89:	fa9591        	l32r	a9, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40375b8c:	293987        	bltu	a9, a8, 40375bb9 <esp_backtrace_print_from_frame+0x85>
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375b8f:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375b91:	00bad6        	bgez	a10, 40375ba0 <esp_backtrace_print_from_frame+0x6c>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375b94:	11aae0        	slli	a10, a10, 2
40375b97:	41a2a0        	srli	a10, a10, 2
40375b9a:	fa9281        	l32r	a8, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
40375b9d:	20aa80        	or	a10, a10, a8
40375ba0:	fdcaa2        	addi	a10, a10, -3
40375ba3:	023565        	call8	40377ef8 <esp_ptr_executable>
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375ba6:	4adc      	bnez.n	a10, 40375bbe <esp_backtrace_print_from_frame+0x8a>
                        /* Ignore the first corrupted PC in case of InstrFetchProhibited */
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375ba8:	3188      	l32i.n	a8, a1, 12
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375baa:	589c      	beqz.n	a8, 40375bc3 <esp_backtrace_print_from_frame+0x8f>
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375bac:	142892        	l32i	a9, a8, 80
40375baf:	481c      	movi.n	a8, 20
40375bb1:	139987        	bne	a9, a8, 40375bc8 <esp_backtrace_print_from_frame+0x94>
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375bb4:	070c      	movi.n	a7, 0
40375bb6:	000fc6        	j	40375bf9 <esp_backtrace_print_from_frame+0xc5>
40375bb9:	170c      	movi.n	a7, 1
40375bbb:	000e86        	j	40375bf9 <esp_backtrace_print_from_frame+0xc5>
40375bbe:	070c      	movi.n	a7, 0
40375bc0:	000d46        	j	40375bf9 <esp_backtrace_print_from_frame+0xc5>
40375bc3:	170c      	movi.n	a7, 1
40375bc5:	000c06        	j	40375bf9 <esp_backtrace_print_from_frame+0xc5>
40375bc8:	170c      	movi.n	a7, 1

    uint32_t i = (depth <= 0) ? INT32_MAX : depth;
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375bca:	000ac6        	j	40375bf9 <esp_backtrace_print_from_frame+0xc5>
        if (!esp_backtrace_get_next_frame(&stk_frame)) {    //Get previous stack frame
40375bcd:	20a110        	or	a10, a1, a1
40375bd0:	fff065        	call8	40375ad8 <esp_backtrace_get_next_frame>
40375bd3:	002a56        	bnez	a10, 40375bd9 <esp_backtrace_print_from_frame+0xa5>
            corrupted = true;
40375bd6:	01a072        	movi	a7, 1
        }
        print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375bd9:	0021a2        	l32i	a10, a1, 0
    if (pc & 0x80000000) {
40375bdc:	00bad6        	bgez	a10, 40375beb <esp_backtrace_print_from_frame+0xb7>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375bdf:	11aae0        	slli	a10, a10, 2
40375be2:	41a2a0        	srli	a10, a10, 2
40375be5:	fa7f81        	l32r	a8, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
40375be8:	20aa80        	or	a10, a10, a8
40375beb:	20c440        	or	a12, a4, a4
40375bee:	0121b2        	l32i	a11, a1, 4
40375bf1:	fdcaa2        	addi	a10, a10, -3
40375bf4:	ffe8e5        	call8	40375a84 <print_entry>
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375bf7:	062d      	mov.n	a2, a6
40375bf9:	620b      	addi.n	a6, a2, -1
40375bfb:	528c      	beqz.n	a2, 40375c04 <esp_backtrace_print_from_frame+0xd0>
40375bfd:	2188      	l32i.n	a8, a1, 8
40375bff:	188c      	beqz.n	a8, 40375c04 <esp_backtrace_print_from_frame+0xd0>
40375c01:	fc8716        	beqz	a7, 40375bcd <esp_backtrace_print_from_frame+0x99>
    }

    //Print backtrace termination marker
    esp_err_t ret = ESP_OK;
    if (corrupted) {
40375c04:	d78c      	beqz.n	a7, 40375c15 <esp_backtrace_print_from_frame+0xe1>
        print_str(" |<-CORRUPTED", panic);
40375c06:	04bd      	mov.n	a11, a4
40375c08:	fa79a1        	l32r	a10, 403745ec <_iram_text_start+0x1e8> (3c020ec0 <_flash_rodata_start+0xda0>)
40375c0b:	ffeb65        	call8	40375ac0 <print_str>
        ret =  ESP_FAIL;
40375c0e:	f27c      	movi.n	a2, -1
40375c10:	0005c6        	j	40375c2b <esp_backtrace_print_from_frame+0xf7>
40375c13:	820000        	mull	a0, a0, a0
    } else if (stk_frame.next_pc != 0) {    //Backtrace continues
40375c16:	160221        	l32r	a2, 4033b420 <rom_rx_gain_force+0x334ff4>
40375c19:	00d8      	l32i.n	a13, a0, 0
        print_str(" |<-CONTINUES", panic);
40375c1b:	20b440        	or	a11, a4, a4
40375c1e:	fa74a1        	l32r	a10, 403745f0 <_iram_text_start+0x1ec> (3c020ed0 <_flash_rodata_start+0xdb0>)
40375c21:	ffe9e5        	call8	40375ac0 <print_str>
    esp_err_t ret = ESP_OK;
40375c24:	020c      	movi.n	a2, 0
40375c26:	000046        	j	40375c2b <esp_backtrace_print_from_frame+0xf7>
40375c29:	020c      	movi.n	a2, 0
    }
    print_str("\r\n\r\n", panic);
40375c2b:	04bd      	mov.n	a11, a4
40375c2d:	fa71a1        	l32r	a10, 403745f4 <_iram_text_start+0x1f0> (3c020ee0 <_flash_rodata_start+0xdc0>)
40375c30:	ffe8e5        	call8	40375ac0 <print_str>
    return ret;
40375c33:	000146        	j	40375c3c <esp_backtrace_print_from_frame+0x108>
40375c36:	000000        	ill
        return ESP_ERR_INVALID_ARG;
40375c39:	02a122        	movi	a2, 0x102
}
40375c3c:	f01d      	retw.n
	...

40375c40 <esp_backtrace_print>:

esp_err_t IRAM_ATTR esp_backtrace_print(int depth)
{
40375c40:	006136        	entry	a1, 48
    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t start = { 0 };
40375c43:	10a0c2        	movi	a12, 16
40375c46:	00a0b2        	movi	a11, 0
40375c49:	20a110        	or	a10, a1, a1
40375c4c:	fa1b81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40375c4f:	0008e0        	callx8	a8
    esp_backtrace_get_start(&(start.pc), &(start.sp), &(start.next_pc));
40375c52:	c18b      	addi.n	a12, a1, 8
40375c54:	b14b      	addi.n	a11, a1, 4
40375c56:	01ad      	mov.n	a10, a1
40375c58:	0000e5        	call8	40375c68 <esp_backtrace_get_start>
    return esp_backtrace_print_from_frame(depth, &start, false);
40375c5b:	0c0c      	movi.n	a12, 0
40375c5d:	01bd      	mov.n	a11, a1
40375c5f:	02ad      	mov.n	a10, a2
40375c61:	ffed25        	call8	40375b34 <esp_backtrace_print_from_frame>
}
40375c64:	0a2d      	mov.n	a2, a10
40375c66:	f01d      	retw.n

40375c68 <esp_backtrace_get_start>:
    .section    .iram1, "ax"
    .align      4
    .global     esp_backtrace_get_start
    .type       esp_backtrace_get_start, @function
esp_backtrace_get_start:
    entry   a1, 32
40375c68:	004136        	entry	a1, 32
    call8   xthal_window_spill  //Spill registers onto stack (excluding this function)
40375c6b:	0c45a5        	call8	403820c4 <xthal_window_spill>
    //a2, a3, a4 should be out arguments for i SP, i PC, i-1 PC respectively. Use a5 and a6 as scratch
    l32e    a5, sp, -16         //Get i PC, which is ret addres of i+1
40375c6e:	09c150        	l32e	a5, a1, -16
    s32i    a5, a2, 0           //Store i PC to arg *pc
40375c71:	006252        	s32i	a5, a2, 0
    l32e    a6, sp, -12         //Get i+1 SP. Used to access i BS
40375c74:	09d160        	l32e	a6, a1, -12
    l32e    a5, a6, -12         //Get i SP
40375c77:	09d650        	l32e	a5, a6, -12
    s32i    a5, a3, 0           //Store i SP to arg *sp
40375c7a:	006352        	s32i	a5, a3, 0
    l32e    a5, a6, -16         //Get i-1 PC, which is ret address of i
40375c7d:	09c650        	l32e	a5, a6, -16
    s32i    a5, a4, 0           //Store i-1 PC to arg *next_pc
40375c80:	006452        	s32i	a5, a4, 0
    retw
40375c83:	f01d      	retw.n
40375c85:	000000        	ill

40375c88 <ipc_task>:
static volatile esp_ipc_func_t s_no_block_func[portNUM_PROCESSORS] = { 0 };
static volatile bool s_no_block_func_and_arg_are_ready[portNUM_PROCESSORS] = { 0 };
static void * volatile s_no_block_func_arg[portNUM_PROCESSORS];

static void IRAM_ATTR ipc_task(void* arg)
{
40375c88:	004136        	entry	a1, 32
40375c8b:	027d      	mov.n	a7, a2
40375c8d:	03eb80        	rsr.prid	a8
40375c90:	048d80        	extui	a8, a8, 13, 1
    const int cpuid = (int) arg;

    assert(cpuid == xPortGetCoreID());
40375c93:	0d1287        	beq	a2, a8, 40375ca4 <ipc_task+0x1c>
40375c96:	fa58d1        	l32r	a13, 403745f8 <_iram_text_start+0x1f4> (3c020f54 <_flash_rodata_start+0xe34>)
40375c99:	fa58c1        	l32r	a12, 403745fc <_iram_text_start+0x1f8> (3c0265e0 <__func__$0>)
40375c9c:	8b3c      	movi.n	a11, 56
40375c9e:	fa58a1        	l32r	a10, 40374600 <_iram_text_start+0x1fc> (3c020f8c <_flash_rodata_start+0xe6c>)
40375ca1:	0a0865        	call8	4037fd28 <__assert_func>
#ifdef CONFIG_ESP_IPC_ISR_ENABLE
    esp_ipc_isr_init();
40375ca4:	fa5f81        	l32r	a8, 40374620 <_iram_text_start+0x21c> (420024f0 <esp_ipc_isr_init>)
40375ca7:	0008e0        	callx8	a8
#endif

    while (true) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
40375caa:	fc7c      	movi.n	a12, -1
40375cac:	1b0c      	movi.n	a11, 1
40375cae:	00a0a2        	movi	a10, 0
40375cb1:	063125        	call8	4037bfc4 <ulTaskGenericNotifyTake>

        if (s_no_block_func_and_arg_are_ready[cpuid] && s_no_block_func[cpuid]) {
40375cb4:	fa5481        	l32r	a8, 40374604 <_iram_text_start+0x200> (3fc94d60 <s_no_block_func_and_arg_are_ready>)
40375cb7:	887a      	add.n	a8, a8, a7
40375cb9:	0020c0        	memw
40375cbc:	000882        	l8ui	a8, a8, 0
40375cbf:	748080        	extui	a8, a8, 0, 8
40375cc2:	b8bc      	beqz.n	a8, 40375d01 <ipc_task+0x79>
40375cc4:	fa5181        	l32r	a8, 40374608 <_iram_text_start+0x204> (3fc94d64 <s_no_block_func>)
40375cc7:	a08780        	addx4	a8, a7, a8
40375cca:	0020c0        	memw
40375ccd:	0888      	l32i.n	a8, a8, 0
40375ccf:	02e816        	beqz	a8, 40375d01 <ipc_task+0x79>
            (*s_no_block_func[cpuid])(s_no_block_func_arg[cpuid]);
40375cd2:	fa4d61        	l32r	a6, 40374608 <_iram_text_start+0x204> (3fc94d64 <s_no_block_func>)
40375cd5:	a06760        	addx4	a6, a7, a6
40375cd8:	0020c0        	memw
40375cdb:	0698      	l32i.n	a9, a6, 0
40375cdd:	fa4b81        	l32r	a8, 4037460c <_iram_text_start+0x208> (3fc94d58 <s_no_block_func_arg>)
40375ce0:	a08780        	addx4	a8, a7, a8
40375ce3:	0020c0        	memw
40375ce6:	0028a2        	l32i	a10, a8, 0
40375ce9:	0009e0        	callx8	a9
            s_no_block_func_and_arg_are_ready[cpuid] = false;
40375cec:	fa4681        	l32r	a8, 40374604 <_iram_text_start+0x200> (3fc94d60 <s_no_block_func_and_arg_are_ready>)
40375cef:	887a      	add.n	a8, a8, a7
40375cf1:	090c      	movi.n	a9, 0
40375cf3:	0020c0        	memw
40375cf6:	004892        	s8i	a9, a8, 0
            s_no_block_func[cpuid] = NULL;
40375cf9:	080c      	movi.n	a8, 0
40375cfb:	0020c0        	memw
40375cfe:	006682        	s32i	a8, a6, 0
        }

#ifndef CONFIG_FREERTOS_UNICORE
        if (s_func[cpuid]) {
40375d01:	fa4381        	l32r	a8, 40374610 <_iram_text_start+0x20c> (3fc94d7c <s_func>)
40375d04:	a08780        	addx4	a8, a7, a8
40375d07:	0020c0        	memw
40375d0a:	0888      	l32i.n	a8, a8, 0
40375d0c:	f9a816        	beqz	a8, 40375caa <ipc_task+0x22>
            // we need to cache s_func, s_func_arg and ipc_ack variables locally
            // because they can be changed by a subsequent IPC call (after xTaskNotify(caller_task_handle)).
            esp_ipc_func_t func = s_func[cpuid];
40375d0f:	fa4081        	l32r	a8, 40374610 <_iram_text_start+0x20c> (3fc94d7c <s_func>)
40375d12:	a08780        	addx4	a8, a7, a8
40375d15:	0020c0        	memw
40375d18:	0868      	l32i.n	a6, a8, 0
            void* func_arg = s_func_arg[cpuid];
40375d1a:	fa3e91        	l32r	a9, 40374614 <_iram_text_start+0x210> (3fc94d74 <s_func_arg>)
40375d1d:	a09790        	addx4	a9, a7, a9
40375d20:	0020c0        	memw
40375d23:	0958      	l32i.n	a5, a9, 0
            esp_ipc_wait_t ipc_wait = s_wait_for[cpuid];
40375d25:	fa3c91        	l32r	a9, 40374618 <_iram_text_start+0x214> (3fc94d6c <s_wait_for>)
40375d28:	a09790        	addx4	a9, a7, a9
40375d2b:	0020c0        	memw
40375d2e:	09a8      	l32i.n	a10, a9, 0
            SemaphoreHandle_t ipc_ack = s_ipc_ack[cpuid];
40375d30:	fa3b91        	l32r	a9, 4037461c <_iram_text_start+0x218> (3fc94d84 <s_ipc_ack>)
40375d33:	a09790        	addx4	a9, a7, a9
40375d36:	0948      	l32i.n	a4, a9, 0
            s_func[cpuid] = NULL;
40375d38:	090c      	movi.n	a9, 0
40375d3a:	0020c0        	memw
40375d3d:	0899      	s32i.n	a9, a8, 0

            if (ipc_wait == IPC_WAIT_FOR_START) {
40375d3f:	121a66        	bnei	a10, 1, 40375d55 <ipc_task+0xcd>
                xSemaphoreGive(ipc_ack);
40375d42:	09dd      	mov.n	a13, a9
40375d44:	09cd      	mov.n	a12, a9
40375d46:	09bd      	mov.n	a11, a9
40375d48:	04ad      	mov.n	a10, a4
40375d4a:	03caa5        	call8	403799f4 <xQueueGenericSend>
                (*func)(func_arg);
40375d4d:	05ad      	mov.n	a10, a5
40375d4f:	0006e0        	callx8	a6
40375d52:	ffd506        	j	40375caa <ipc_task+0x22>
            } else if (ipc_wait == IPC_WAIT_FOR_END) {
40375d55:	132a66        	bnei	a10, 2, 40375d6c <ipc_task+0xe4>
                (*func)(func_arg);
40375d58:	05ad      	mov.n	a10, a5
40375d5a:	0006e0        	callx8	a6
                xSemaphoreGive(ipc_ack);
40375d5d:	0d0c      	movi.n	a13, 0
40375d5f:	0dcd      	mov.n	a12, a13
40375d61:	0dbd      	mov.n	a11, a13
40375d63:	04ad      	mov.n	a10, a4
40375d65:	03c8e5        	call8	403799f4 <xQueueGenericSend>
40375d68:	ffcf86        	j	40375caa <ipc_task+0x22>
40375d6b:	00          	.byte	00
            } else {
                abort();
40375d6c:	09efe5        	call8	4037fc6c <abort>
	...

40375d70 <esp_vApplicationTickHook>:
static portMUX_TYPE hooks_spinlock = portMUX_INITIALIZER_UNLOCKED;
static esp_freertos_idle_cb_t idle_cb[CONFIG_FREERTOS_NUMBER_OF_CORES][MAX_HOOKS] = {0};
static esp_freertos_tick_cb_t tick_cb[CONFIG_FREERTOS_NUMBER_OF_CORES][MAX_HOOKS] = {0};

void IRAM_ATTR esp_vApplicationTickHook(void)
{
40375d70:	004136        	entry	a1, 32
40375d73:	03eb60        	rsr.prid	a6
40375d76:	046d60        	extui	a6, a6, 13, 1
    int n;
    int core = xPortGetCoreID();
    for (n = 0; n < MAX_HOOKS; n++) {
40375d79:	070c      	movi.n	a7, 0
40375d7b:	0004c6        	j	40375d92 <esp_vApplicationTickHook+0x22>
40375d7e:	00          	.byte	00
40375d7f:	867000        	ee.ldf.64.xp	f7, f8, a0, a0
        if (tick_cb[core][n] != NULL) {
40375d82:	b0          	.byte	0xb0
40375d83:	fa2891        	l32r	a9, 40374624 <_iram_text_start+0x220> (3fc94d9c <tick_cb>)
40375d86:	a08890        	addx4	a8, a8, a9
40375d89:	0888      	l32i.n	a8, a8, 0
40375d8b:	188c      	beqz.n	a8, 40375d90 <esp_vApplicationTickHook+0x20>
            tick_cb[core][n]();
40375d8d:	0008e0        	callx8	a8
    for (n = 0; n < MAX_HOOKS; n++) {
40375d90:	771b      	addi.n	a7, a7, 1
40375d92:	ea87a6        	blti	a7, 8, 40375d80 <esp_vApplicationTickHook+0x10>
        }
    }
}
40375d95:	f01d      	retw.n
	...

40375d98 <efuse_hal_chip_revision>:
    *((uint32_t*)&mac[0]) = efuse_ll_get_mac0();
    *((uint16_t*)&mac[4]) = (uint16_t) efuse_ll_get_mac1();
}

IRAM_ATTR uint32_t efuse_hal_chip_revision(void)
{
40375d98:	004136        	entry	a1, 32
    return efuse_hal_get_major_chip_version() * 100 + efuse_hal_get_minor_chip_version();
40375d9b:	000525        	call8	40375dec <efuse_hal_get_major_chip_version>
40375d9e:	a0aaa0        	addx4	a10, a10, a10
40375da1:	a0aaa0        	addx4	a10, a10, a10
40375da4:	112ae0        	slli	a2, a10, 2
40375da7:	0008e5        	call8	40375e34 <efuse_hal_get_minor_chip_version>
}
40375daa:	8022a0        	add	a2, a2, a10
40375dad:	000090        	retw

40375db0 <efuse_hal_get_disable_wafer_version_major>:
{
    return efuse_ll_get_blk_version_major() * 100 + efuse_ll_get_blk_version_minor();
}

IRAM_ATTR bool efuse_hal_get_disable_wafer_version_major(void)
{
40375db0:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
}

__attribute__((always_inline)) static inline bool efuse_ll_get_disable_wafer_version_major(void)
{
    return EFUSE.rd_repeat_data4.disable_wafer_version_major;
40375db3:	fa1d81        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375db6:	0020c0        	memw
40375db9:	102822        	l32i	a2, a8, 64
    return efuse_ll_get_disable_wafer_version_major();
}
40375dbc:	042020        	extui	a2, a2, 0, 1
40375dbf:	f01d      	retw.n
40375dc1:	000000        	ill

40375dc4 <efuse_hal_flash_encryption_enabled>:
{
    return efuse_ll_get_disable_blk_version_major();
}

IRAM_ATTR bool efuse_hal_flash_encryption_enabled(void)
{
40375dc4:	004136        	entry	a1, 32
    return EFUSE.rd_repeat_data1.spi_boot_crypt_cnt;
40375dc7:	fa1881        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375dca:	0020c0        	memw
40375dcd:	d888      	l32i.n	a8, a8, 52
40375dcf:	258280        	extui	a8, a8, 18, 3
    uint32_t flash_crypt_cnt = efuse_ll_get_flash_crypt_cnt();
    bool enabled = false;
40375dd2:	020c      	movi.n	a2, 0
    while (flash_crypt_cnt) {
40375dd4:	0003c6        	j	40375de7 <efuse_hal_flash_encryption_enabled+0x23>
40375dd7:	070000        	ee.stf.64.xp	f0, f0, a0, a0
        if (flash_crypt_cnt & 1) {
40375dda:	0768      	l32i.n	a6, a7, 0
            enabled = !enabled;
40375ddc:	190c      	movi.n	a9, 1
40375dde:	302290        	xor	a2, a2, a9
40375de1:	742020        	extui	a2, a2, 0, 8
        }
        flash_crypt_cnt >>= 1;
40375de4:	418180        	srli	a8, a8, 1
    while (flash_crypt_cnt) {
40375de7:	fee856        	bnez	a8, 40375dd9 <efuse_hal_flash_encryption_enabled+0x15>
    }
    return enabled;
}
40375dea:	f01d      	retw.n

40375dec <efuse_hal_get_major_chip_version>:
    return ((minor_raw & 0x7) == 0 &&
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
}

IRAM_ATTR uint32_t efuse_hal_get_major_chip_version(void)
{
40375dec:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
40375def:	fa0e81        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375df2:	0020c0        	memw
40375df5:	162892        	l32i	a9, a8, 88
40375df8:	0020c0        	memw
40375dfb:	142882        	l32i	a8, a8, 80
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375dfe:	258280        	extui	a8, a8, 18, 3
40375e01:	c8dc      	bnez.n	a8, 40375e21 <efuse_hal_get_major_chip_version+0x35>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_major(void)
{
    return EFUSE.rd_sys_part1_data4.blk_version_major;
40375e03:	fa0981        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375e06:	0020c0        	memw
40375e09:	1b2882        	l32i	a8, a8, 108
40375e0c:	148080        	extui	a8, a8, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40375e0f:	0e1866        	bnei	a8, 1, 40375e21 <efuse_hal_get_major_chip_version+0x35>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_minor(void)
{
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40375e12:	fa0581        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375e15:	0020c0        	memw
40375e18:	142882        	l32i	a8, a8, 80
40375e1b:	258880        	extui	a8, a8, 24, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e1e:	0e1826        	beqi	a8, 1, 40375e30 <efuse_hal_get_major_chip_version+0x44>
    return EFUSE.rd_mac_spi_sys_5.wafer_version_major;
40375e21:	fa0181        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375e24:	0020c0        	memw
40375e27:	162822        	l32i	a2, a8, 88
40375e2a:	152820        	extui	a2, a2, 24, 2
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
    }
    return efuse_ll_get_chip_wafer_version_major();
40375e2d:	000046        	j	40375e32 <efuse_hal_get_major_chip_version+0x46>
        return 0;
40375e30:	020c      	movi.n	a2, 0
}
40375e32:	f01d      	retw.n

40375e34 <efuse_hal_get_minor_chip_version>:

IRAM_ATTR uint32_t efuse_hal_get_minor_chip_version(void)
{
40375e34:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_hi << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_lo;
40375e37:	f9fc81        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375e3a:	0020c0        	memw
40375e3d:	162822        	l32i	a2, a8, 88
40375e40:	0020c0        	memw
40375e43:	142882        	l32i	a8, a8, 80
40375e46:	258280        	extui	a8, a8, 18, 3
40375e49:	052720        	extui	a2, a2, 23, 1
40375e4c:	b02280        	addx8	a2, a2, a8
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e4f:	e8dc      	bnez.n	a8, 40375e71 <efuse_hal_get_minor_chip_version+0x3d>
    return EFUSE.rd_sys_part1_data4.blk_version_major;
40375e51:	f9f581        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375e54:	0020c0        	memw
40375e57:	1b2882        	l32i	a8, a8, 108
40375e5a:	148080        	extui	a8, a8, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40375e5d:	101866        	bnei	a8, 1, 40375e71 <efuse_hal_get_minor_chip_version+0x3d>
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40375e60:	f9f281        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
40375e63:	0020c0        	memw
40375e66:	142882        	l32i	a8, a8, 80
40375e69:	258880        	extui	a8, a8, 24, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40375e6c:	011866        	bnei	a8, 1, 40375e71 <efuse_hal_get_minor_chip_version+0x3d>
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
40375e6f:	020c      	movi.n	a2, 0
    }
    return minor_raw;
}
40375e71:	f01d      	retw.n
	...

40375e74 <heap_caps_alloc_failed>:
    memcpy(dest + 39, sCaps, 8);
}
#endif

HEAP_IRAM_ATTR NOINLINE_ATTR static void heap_caps_alloc_failed(size_t requested_size, uint32_t caps, const char *function_name)
{
40375e74:	004136        	entry	a1, 32
40375e77:	02ad      	mov.n	a10, a2
40375e79:	03bd      	mov.n	a11, a3
40375e7b:	04cd      	mov.n	a12, a4
    if (alloc_failed_callback) {
40375e7d:	f9eb81        	l32r	a8, 4037462c <_iram_text_start+0x228> (3fc94f34 <alloc_failed_callback>)
40375e80:	0888      	l32i.n	a8, a8, 0
40375e82:	002816        	beqz	a8, 40375e88 <heap_caps_alloc_failed+0x14>
        alloc_failed_callback(requested_size, caps, function_name);
40375e85:	0008e0        	callx8	a8
#ifdef CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS
    char buf[48];
    fmt_abort_str(buf, requested_size, caps);
    esp_system_abort(buf);
#endif
}
40375e88:	f01d      	retw.n
	...

40375e8c <heap_caps_aligned_check_args>:
    void *block_ptr = multi_heap_find_containing_block(heap->heap, ptr);
    return multi_heap_get_allocated_size(heap->heap, block_ptr);
}

static HEAP_IRAM_ATTR esp_err_t heap_caps_aligned_check_args(size_t alignment, size_t size, uint32_t caps, const char *funcname)
{
40375e8c:	004136        	entry	a1, 32
    if (!alignment) {
40375e8f:	01d216        	beqz	a2, 40375eb0 <heap_caps_aligned_check_args+0x24>
        return ESP_FAIL;
    }

    // Alignment must be a power of two:
    if ((alignment & (alignment - 1)) != 0) {
40375e92:	ffc282        	addi	a8, a2, -1
40375e95:	1c8827        	bany	a8, a2, 40375eb5 <heap_caps_aligned_check_args+0x29>
        return ESP_FAIL;
    }

    if (size == 0) {
40375e98:	01e316        	beqz	a3, 40375eba <heap_caps_aligned_check_args+0x2e>
        return ESP_FAIL;
    }

    if (MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size) > HEAP_SIZE_MAX) {
40375e9b:	f9e581        	l32r	a8, 40374630 <_iram_text_start+0x22c> (2000000 <UserFrameTotalSize+0x1ffff00>)
40375e9e:	1eb837        	bgeu	a8, a3, 40375ec0 <heap_caps_aligned_check_args+0x34>
        // Avoids int overflow when adding small numbers to size, or
        // calculating 'end' from start+size, by limiting 'size' to the possible range
        heap_caps_alloc_failed(size, caps, funcname);
40375ea1:	05cd      	mov.n	a12, a5
40375ea3:	04bd      	mov.n	a11, a4
40375ea5:	03ad      	mov.n	a10, a3
40375ea7:	fffce5        	call8	40375e74 <heap_caps_alloc_failed>
        return ESP_FAIL;
40375eaa:	f27c      	movi.n	a2, -1
40375eac:	000486        	j	40375ec2 <heap_caps_aligned_check_args+0x36>
40375eaf:	f27c00        	rems	a7, a12, a0
        return ESP_FAIL;
40375eb2:	000306        	j	40375ec2 <heap_caps_aligned_check_args+0x36>
        return ESP_FAIL;
40375eb5:	f27c      	movi.n	a2, -1
40375eb7:	0001c6        	j	40375ec2 <heap_caps_aligned_check_args+0x36>
        return ESP_FAIL;
40375eba:	f27c      	movi.n	a2, -1
40375ebc:	000086        	j	40375ec2 <heap_caps_aligned_check_args+0x36>
40375ebf:	020c00        	andb	b0, b12, b0
    }

    return ESP_OK;
}
40375ec2:	f01d      	retw.n

40375ec4 <heap_caps_malloc>:
{
40375ec4:	004136        	entry	a1, 32
40375ec7:	207220        	or	a7, a2, a2
    void* ptr = heap_caps_malloc_base(size, caps);
40375eca:	20b330        	or	a11, a3, a3
40375ecd:	20a220        	or	a10, a2, a2
40375ed0:	003825        	call8	40376254 <heap_caps_malloc_base>
40375ed3:	0a2d      	mov.n	a2, a10
    if (!ptr && size > 0){
40375ed5:	40fa80        	nsau	a8, a10
40375ed8:	418580        	srli	a8, a8, 5
40375edb:	190c      	movi.n	a9, 1
40375edd:	839770        	moveqz	a9, a7, a7
40375ee0:	090897        	bnone	a8, a9, 40375eed <heap_caps_malloc+0x29>
        heap_caps_alloc_failed(size, caps, __func__);
40375ee3:	f9d4c1        	l32r	a12, 40374634 <_iram_text_start+0x230> (3c02684c <__func__$13>)
40375ee6:	03bd      	mov.n	a11, a3
40375ee8:	07ad      	mov.n	a10, a7
40375eea:	fff8a5        	call8	40375e74 <heap_caps_alloc_failed>
}
40375eed:	f01d      	retw.n
	...

40375ef0 <heap_caps_malloc_default>:
{
40375ef0:	004136        	entry	a1, 32
40375ef3:	207220        	or	a7, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375ef6:	f9d081        	l32r	a8, 40374638 <_iram_text_start+0x234> (3fc9243c <malloc_alwaysinternal_limit>)
40375ef9:	002882        	l32i	a8, a8, 0
40375efc:	0d0866        	bnei	a8, -1, 40375f0d <heap_caps_malloc_default+0x1d>
        return heap_caps_malloc( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
40375eff:	f9cfb1        	l32r	a11, 4037463c <_iram_text_start+0x238> (1800 <UserFrameTotalSize+0x1700>)
40375f02:	20a220        	or	a10, a2, a2
40375f05:	fffbe5        	call8	40375ec4 <heap_caps_malloc>
40375f08:	0a2d      	mov.n	a2, a10
40375f0a:	0011c6        	j	40375f55 <heap_caps_malloc_default+0x65>
        if (size <= (size_t)malloc_alwaysinternal_limit) {
40375f0d:	0c3827        	bltu	a8, a2, 40375f1d <heap_caps_malloc_default+0x2d>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40375f10:	f9cbb1        	l32r	a11, 4037463c <_iram_text_start+0x238> (1800 <UserFrameTotalSize+0x1700>)
40375f13:	02ad      	mov.n	a10, a2
40375f15:	0033e5        	call8	40376254 <heap_caps_malloc_base>
40375f18:	0a2d      	mov.n	a2, a10
40375f1a:	000246        	j	40375f27 <heap_caps_malloc_default+0x37>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM );
40375f1d:	f9c8b1        	l32r	a11, 40374640 <_iram_text_start+0x23c> (1400 <UserFrameTotalSize+0x1300>)
40375f20:	02ad      	mov.n	a10, a2
40375f22:	003325        	call8	40376254 <heap_caps_malloc_base>
40375f25:	0a2d      	mov.n	a2, a10
        if (r==NULL && size > 0) {
40375f27:	40f280        	nsau	a8, a2
40375f2a:	418580        	srli	a8, a8, 5
40375f2d:	160c      	movi.n	a6, 1
40375f2f:	836770        	moveqz	a6, a7, a7
40375f32:	0b0867        	bnone	a8, a6, 40375f41 <heap_caps_malloc_default+0x51>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT );
40375f35:	f9c3b1        	l32r	a11, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
40375f38:	20a770        	or	a10, a7, a7
40375f3b:	0031a5        	call8	40376254 <heap_caps_malloc_base>
40375f3e:	202aa0        	or	a2, a10, a10
        if (r==NULL && size > 0){
40375f41:	40f280        	nsau	a8, a2
40375f44:	418580        	srli	a8, a8, 5
40375f47:	0a0687        	bnone	a6, a8, 40375f55 <heap_caps_malloc_default+0x65>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
40375f4a:	f9bfc1        	l32r	a12, 40374648 <_iram_text_start+0x244> (3c026830 <__func__$12>)
40375f4d:	f9bdb1        	l32r	a11, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
40375f50:	07ad      	mov.n	a10, a7
40375f52:	fff225        	call8	40375e74 <heap_caps_alloc_failed>
}
40375f55:	f01d      	retw.n
	...

40375f58 <heap_caps_realloc>:
{
40375f58:	004136        	entry	a1, 32
40375f5b:	20a220        	or	a10, a2, a2
    ptr = heap_caps_realloc_base(ptr, size, caps);
40375f5e:	20c440        	or	a12, a4, a4
40375f61:	20b330        	or	a11, a3, a3
40375f64:	002fe5        	call8	40376264 <heap_caps_realloc_base>
40375f67:	0a2d      	mov.n	a2, a10
    if (ptr == NULL && size > 0){
40375f69:	40fa80        	nsau	a8, a10
40375f6c:	418580        	srli	a8, a8, 5
40375f6f:	190c      	movi.n	a9, 1
40375f71:	839330        	moveqz	a9, a3, a3
40375f74:	090897        	bnone	a8, a9, 40375f81 <heap_caps_realloc+0x29>
        heap_caps_alloc_failed(size, caps, __func__);
40375f77:	f9b5c1        	l32r	a12, 4037464c <_iram_text_start+0x248> (3c026800 <__func__$7>)
40375f7a:	04bd      	mov.n	a11, a4
40375f7c:	03ad      	mov.n	a10, a3
40375f7e:	ffef65        	call8	40375e74 <heap_caps_alloc_failed>
}
40375f81:	f01d      	retw.n
	...

40375f84 <heap_caps_realloc_default>:
{
40375f84:	004136        	entry	a1, 32
40375f87:	207220        	or	a7, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375f8a:	f9ab81        	l32r	a8, 40374638 <_iram_text_start+0x234> (3fc9243c <malloc_alwaysinternal_limit>)
40375f8d:	002882        	l32i	a8, a8, 0
40375f90:	100866        	bnei	a8, -1, 40375fa4 <heap_caps_realloc_default+0x20>
        return heap_caps_realloc( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40375f93:	f9aac1        	l32r	a12, 4037463c <_iram_text_start+0x238> (1800 <UserFrameTotalSize+0x1700>)
40375f96:	20b330        	or	a11, a3, a3
40375f99:	02ad      	mov.n	a10, a2
40375f9b:	fffbe5        	call8	40375f58 <heap_caps_realloc>
40375f9e:	0a2d      	mov.n	a2, a10
40375fa0:	001446        	j	40375ff5 <heap_caps_realloc_default+0x71>
40375fa3:	00          	.byte	00
        if (size <= (size_t)malloc_alwaysinternal_limit) {
40375fa4:	113837        	bltu	a8, a3, 40375fb9 <heap_caps_realloc_default+0x35>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
40375fa7:	f9a5c1        	l32r	a12, 4037463c <_iram_text_start+0x238> (1800 <UserFrameTotalSize+0x1700>)
40375faa:	20b330        	or	a11, a3, a3
40375fad:	20a220        	or	a10, a2, a2
40375fb0:	002b25        	call8	40376264 <heap_caps_realloc_base>
40375fb3:	202aa0        	or	a2, a10, a10
40375fb6:	0002c6        	j	40375fc5 <heap_caps_realloc_default+0x41>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM);
40375fb9:	f9a1c1        	l32r	a12, 40374640 <_iram_text_start+0x23c> (1400 <UserFrameTotalSize+0x1300>)
40375fbc:	03bd      	mov.n	a11, a3
40375fbe:	02ad      	mov.n	a10, a2
40375fc0:	002a25        	call8	40376264 <heap_caps_realloc_base>
40375fc3:	0a2d      	mov.n	a2, a10
        if (r==NULL && size>0) {
40375fc5:	40f280        	nsau	a8, a2
40375fc8:	418580        	srli	a8, a8, 5
40375fcb:	160c      	movi.n	a6, 1
40375fcd:	836330        	moveqz	a6, a3, a3
40375fd0:	0d0867        	bnone	a8, a6, 40375fe1 <heap_caps_realloc_default+0x5d>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT);
40375fd3:	f99cc1        	l32r	a12, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
40375fd6:	03bd      	mov.n	a11, a3
40375fd8:	20a770        	or	a10, a7, a7
40375fdb:	0028a5        	call8	40376264 <heap_caps_realloc_base>
40375fde:	202aa0        	or	a2, a10, a10
        if (r==NULL && size>0){
40375fe1:	40f280        	nsau	a8, a2
40375fe4:	418580        	srli	a8, a8, 5
40375fe7:	0a0687        	bnone	a6, a8, 40375ff5 <heap_caps_realloc_default+0x71>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
40375fea:	f999c1        	l32r	a12, 40374650 <_iram_text_start+0x24c> (3c026814 <__func__$11>)
40375fed:	f995b1        	l32r	a11, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
40375ff0:	03ad      	mov.n	a10, a3
40375ff2:	ffe825        	call8	40375e74 <heap_caps_alloc_failed>
}
40375ff5:	f01d      	retw.n
	...

40375ff8 <heap_caps_calloc>:
{
40375ff8:	004136        	entry	a1, 32
40375ffb:	207220        	or	a7, a2, a2
    void* ptr = heap_caps_calloc_base(n, size, caps);
40375ffe:	20c440        	or	a12, a4, a4
40376001:	03bd      	mov.n	a11, a3
40376003:	20a220        	or	a10, a2, a2
40376006:	003ba5        	call8	403763c0 <heap_caps_calloc_base>
40376009:	0a2d      	mov.n	a2, a10
    if (!ptr && size > 0){
4037600b:	40fa80        	nsau	a8, a10
4037600e:	418580        	srli	a8, a8, 5
40376011:	190c      	movi.n	a9, 1
40376013:	839330        	moveqz	a9, a3, a3
40376016:	0a0897        	bnone	a8, a9, 40376024 <heap_caps_calloc+0x2c>
        heap_caps_alloc_failed(n * size, caps, __func__);
40376019:	f98ec1        	l32r	a12, 40374654 <_iram_text_start+0x250> (3c0267ec <__func__$6>)
4037601c:	04bd      	mov.n	a11, a4
4037601e:	82a730        	mull	a10, a7, a3
40376021:	ffe525        	call8	40375e74 <heap_caps_alloc_failed>
}
40376024:	f01d      	retw.n
	...

40376028 <heap_caps_aligned_alloc>:

    return ret;
}

HEAP_IRAM_ATTR void *heap_caps_aligned_alloc(size_t alignment, size_t size, uint32_t caps)
{
40376028:	004136        	entry	a1, 32
    void *ret = NULL;

    if (heap_caps_aligned_check_args(alignment, size, caps, __func__) != ESP_OK) {
4037602b:	f98bd1        	l32r	a13, 40374658 <_iram_text_start+0x254> (3c0267d4 <__func__$1>)
4037602e:	20c440        	or	a12, a4, a4
40376031:	03bd      	mov.n	a11, a3
40376033:	02ad      	mov.n	a10, a2
40376035:	ffe565        	call8	40375e8c <heap_caps_aligned_check_args>
40376038:	8adc      	bnez.n	a10, 40376054 <heap_caps_aligned_alloc+0x2c>
        return NULL;
    }

    ret = heap_caps_aligned_alloc_base(alignment, size, caps);
4037603a:	04cd      	mov.n	a12, a4
4037603c:	03bd      	mov.n	a11, a3
4037603e:	02ad      	mov.n	a10, a2
40376040:	001425        	call8	40376184 <heap_caps_aligned_alloc_base>
40376043:	0a2d      	mov.n	a2, a10

    if (ret == NULL) {
40376045:	dacc      	bnez.n	a10, 40376056 <heap_caps_aligned_alloc+0x2e>
        heap_caps_alloc_failed(size, caps, __func__);
40376047:	f984c1        	l32r	a12, 40374658 <_iram_text_start+0x254> (3c0267d4 <__func__$1>)
4037604a:	04bd      	mov.n	a11, a4
4037604c:	03ad      	mov.n	a10, a3
4037604e:	ffe265        	call8	40375e74 <heap_caps_alloc_failed>
40376051:	000046        	j	40376056 <heap_caps_aligned_alloc+0x2e>
        return NULL;
40376054:	020c      	movi.n	a2, 0
    }

    return ret;
}
40376056:	f01d      	retw.n

40376058 <dram_alloc_to_iram_addr>:
  This takes a memory chunk in a region that can be addressed as both DRAM as well as IRAM. It will convert it to
  IRAM in such a way that it can be later freed. It assumes both the address as well as the length to be word-aligned.
  It returns a region that's 1 word smaller than the region given because it stores the original Dram address there.
*/
HEAP_IRAM_ATTR static void *dram_alloc_to_iram_addr(void *addr, size_t len)
{
40376058:	004136        	entry	a1, 32
    uintptr_t dstart = (uintptr_t)addr; //First word
4037605b:	20a220        	or	a10, a2, a2
    uintptr_t dend __attribute__((unused)) = dstart + len - 4; //Last word
4037605e:	803230        	add	a3, a2, a3
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
40376061:	f97e91        	l32r	a9, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
40376064:	929a      	add.n	a9, a2, a9
40376066:	f97e81        	l32r	a8, 40374660 <_iram_text_start+0x25c> (67fff <UserFrameTotalSize+0x67eff>)
40376069:	628890        	saltu	a8, a8, a9
4037606c:	880b      	addi.n	a8, a8, -1
4037606e:	608080        	neg	a8, a8
40376071:	748080        	extui	a8, a8, 0, 8
    assert(esp_ptr_in_diram_dram((void *)dstart) || esp_ptr_in_rtc_dram_fast((void *)dstart));
40376074:	38ec      	bnez.n	a8, 4037609b <dram_alloc_to_iram_addr+0x43>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40376076:	f95991        	l32r	a9, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40376079:	929a      	add.n	a9, a2, a9
4037607b:	f95981        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
4037607e:	628890        	saltu	a8, a8, a9
40376081:	880b      	addi.n	a8, a8, -1
40376083:	608080        	neg	a8, a8
40376086:	748080        	extui	a8, a8, 0, 8
40376089:	00e856        	bnez	a8, 4037609b <dram_alloc_to_iram_addr+0x43>
4037608c:	f976d1        	l32r	a13, 40374664 <_iram_text_start+0x260> (3c022048 <_flash_rodata_start+0x1f28>)
4037608f:	f976c1        	l32r	a12, 40374668 <_iram_text_start+0x264> (3c026b4c <__func__$1>)
40376092:	2ea0b2        	movi	a11, 46
40376095:	f975a1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
40376098:	09c8e5        	call8	4037fd28 <__assert_func>
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
4037609b:	f97591        	l32r	a9, 40374670 <_iram_text_start+0x26c> (c0377ffc <_rtc_reserved_end+0x60277ffc>)
4037609e:	939a      	add.n	a9, a3, a9
403760a0:	f97081        	l32r	a8, 40374660 <_iram_text_start+0x25c> (67fff <UserFrameTotalSize+0x67eff>)
403760a3:	628890        	saltu	a8, a8, a9
403760a6:	880b      	addi.n	a8, a8, -1
403760a8:	608080        	neg	a8, a8
403760ab:	748080        	extui	a8, a8, 0, 8
    assert(esp_ptr_in_diram_dram((void *)dend) || esp_ptr_in_rtc_dram_fast((void *)dend));
403760ae:	28ec      	bnez.n	a8, 403760d4 <dram_alloc_to_iram_addr+0x7c>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403760b0:	f97191        	l32r	a9, 40374674 <_iram_text_start+0x270> (9ff01ffc <_rtc_reserved_end+0x3fe01ffc>)
403760b3:	939a      	add.n	a9, a3, a9
403760b5:	f94a81        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
403760b8:	628890        	saltu	a8, a8, a9
403760bb:	880b      	addi.n	a8, a8, -1
403760bd:	608080        	neg	a8, a8
403760c0:	748080        	extui	a8, a8, 0, 8
403760c3:	00d856        	bnez	a8, 403760d4 <dram_alloc_to_iram_addr+0x7c>
403760c6:	f96cd1        	l32r	a13, 40374678 <_iram_text_start+0x274> (3c0220c4 <_flash_rodata_start+0x1fa4>)
403760c9:	f967c1        	l32r	a12, 40374668 <_iram_text_start+0x264> (3c026b4c <__func__$1>)
403760cc:	fb2c      	movi.n	a11, 47
403760ce:	f967a1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
403760d1:	09c565        	call8	4037fd28 <__assert_func>
    assert((dstart & 3) == 0);
403760d4:	1480a0        	extui	a8, a10, 0, 2
403760d7:	00d816        	beqz	a8, 403760e8 <dram_alloc_to_iram_addr+0x90>
403760da:	f968d1        	l32r	a13, 4037467c <_iram_text_start+0x278> (3c022114 <_flash_rodata_start+0x1ff4>)
403760dd:	f962c1        	l32r	a12, 40374668 <_iram_text_start+0x264> (3c026b4c <__func__$1>)
403760e0:	0b3c      	movi.n	a11, 48
403760e2:	f962a1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
403760e5:	09c425        	call8	4037fd28 <__assert_func>
    assert((dend & 3) == 0);
403760e8:	143030        	extui	a3, a3, 0, 2
403760eb:	00d316        	beqz	a3, 403760fc <dram_alloc_to_iram_addr+0xa4>
403760ee:	f964d1        	l32r	a13, 40374680 <_iram_text_start+0x27c> (3c022128 <_flash_rodata_start+0x2008>)
403760f1:	f95dc1        	l32r	a12, 40374668 <_iram_text_start+0x264> (3c026b4c <__func__$1>)
403760f4:	1b3c      	movi.n	a11, 49
403760f6:	f95da1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
403760f9:	09c2e5        	call8	4037fd28 <__assert_func>
403760fc:	f93881        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403760ff:	8a8a      	add.n	a8, a10, a8
#if SOC_DIRAM_INVERTED // We want the word before the result to hold the DRAM address
    uint32_t *iptr = esp_ptr_diram_dram_to_iram((void *)dend);
#else
    uint32_t *iptr = NULL;
    if (esp_ptr_in_rtc_dram_fast((void *)dstart)) {
40376101:	f93791        	l32r	a9, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40376104:	04b987        	bgeu	a9, a8, 4037610c <dram_alloc_to_iram_addr+0xb4>
    return (void *) ( SOC_DIRAM_IRAM_LOW + ((intptr_t)p - SOC_DIRAM_DRAM_LOW) );
40376107:	f95f81        	l32r	a8, 40374684 <_iram_text_start+0x280> (6f0000 <UserFrameTotalSize+0x6eff00>)
4037610a:	228a      	add.n	a2, a2, a8
        iptr = esp_ptr_rtc_dram_to_iram((void *)dstart);
    } else {
        iptr = esp_ptr_diram_dram_to_iram((void *)dstart);
    }
#endif
    *iptr = dstart;
4037610c:	02a9      	s32i.n	a10, a2, 0
    return iptr + 1;
}
4037610e:	224b      	addi.n	a2, a2, 4
40376110:	f01d      	retw.n
	...

40376114 <aligned_or_unaligned_alloc>:
    multi_heap_free(heap->heap, block_owner_ptr);

    CALL_HOOK(esp_heap_trace_free_hook, ptr);
}

HEAP_IRAM_ATTR static inline void *aligned_or_unaligned_alloc(multi_heap_handle_t heap, size_t size, size_t alignment, size_t offset) {
40376114:	004136        	entry	a1, 32
40376117:	20a220        	or	a10, a2, a2
4037611a:	20b330        	or	a11, a3, a3
4037611d:	20c440        	or	a12, a4, a4
40376120:	05dd      	mov.n	a13, a5
    if (alignment<=UNALIGNED_MEM_ALIGNMENT_BYTES) { //alloc and friends align to 32-bit by default
40376122:	0754f6        	bgeui	a4, 5, 4037612d <aligned_or_unaligned_alloc+0x19>
        return multi_heap_malloc(heap, size);
40376125:	085be5        	call8	4037e6e4 <multi_heap_malloc>
40376128:	0a2d      	mov.n	a2, a10
4037612a:	000106        	j	40376132 <aligned_or_unaligned_alloc+0x1e>
    } else {
        return multi_heap_aligned_alloc_offs(heap, size, alignment, offset);
4037612d:	085065        	call8	4037e634 <multi_heap_aligned_alloc_offs>
40376130:	0a2d      	mov.n	a2, a10
    }
}
40376132:	f01d      	retw.n

40376134 <heap_caps_free>:
{
40376134:	004136        	entry	a1, 32
40376137:	02bd      	mov.n	a11, a2
    if (ptr == NULL) {
40376139:	044216        	beqz	a2, 40376181 <heap_caps_free+0x4d>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
4037613c:	f95381        	l32r	a8, 40374688 <_iram_text_start+0x284> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
4037613f:	828a      	add.n	a8, a2, a8
    if ((!esp_dram_match_iram() && esp_ptr_in_diram_iram(ptr)) ||
40376141:	f94791        	l32r	a9, 40374660 <_iram_text_start+0x25c> (67fff <UserFrameTotalSize+0x67eff>)
40376144:	043987        	bltu	a9, a8, 4037614c <heap_caps_free+0x18>
        ptr = (void *)dramAddrPtr[-1];
40376147:	fcc2b2        	addi	a11, a2, -4
4037614a:	0bb8      	l32i.n	a11, a11, 0
   (This confirms if ptr is inside the heap's region, doesn't confirm if 'ptr'
   is an allocated block or is some other random address inside the heap.)
*/
FORCE_INLINE_ATTR heap_t *find_containing_heap(void *ptr )
{
    intptr_t p = (intptr_t)ptr;
4037614c:	0bad      	mov.n	a10, a11
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
4037614e:	f94f81        	l32r	a8, 4037468c <_iram_text_start+0x288> (3fc94f38 <registered_heaps>)
40376151:	0888      	l32i.n	a8, a8, 0
40376153:	000406        	j	40376167 <heap_caps_free+0x33>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
40376156:	7898      	l32i.n	a9, a8, 28
40376158:	898c      	beqz.n	a9, 40376164 <heap_caps_free+0x30>
4037615a:	3898      	l32i.n	a9, a8, 12
4037615c:	042a97        	blt	a10, a9, 40376164 <heap_caps_free+0x30>
4037615f:	4898      	l32i.n	a9, a8, 16
40376161:	052a97        	blt	a10, a9, 4037616a <heap_caps_free+0x36>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376164:	082882        	l32i	a8, a8, 32
40376167:	feb856        	bnez	a8, 40376156 <heap_caps_free+0x22>
    assert(heap != NULL && "free() target pointer is outside heap areas");
4037616a:	00e856        	bnez	a8, 4037617c <heap_caps_free+0x48>
4037616d:	f948d1        	l32r	a13, 40374690 <_iram_text_start+0x28c> (3c022138 <_flash_rodata_start+0x2018>)
40376170:	f949c1        	l32r	a12, 40374694 <_iram_text_start+0x290> (3c026b64 <__func__$2>)
40376173:	50a0b2        	movi	a11, 80
40376176:	f93da1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
40376179:	09bae5        	call8	4037fd28 <__assert_func>
    multi_heap_free(heap->heap, block_owner_ptr);
4037617c:	78a8      	l32i.n	a10, a8, 28
4037617e:	084ce5        	call8	4037e64c <multi_heap_aligned_free>
}
40376181:	f01d      	retw.n
	...

40376184 <heap_caps_aligned_alloc_base>:
This function should not be called directly as it does not check for failure / call heap_caps_alloc_failed()
Note that this function does 'unaligned' alloc calls if alignment <= UNALIGNED_MEM_ALIGNMENT_BYTES (=4) as the
allocator will align to that value by default.
*/
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_aligned_alloc_base(size_t alignment, size_t size, uint32_t caps)
{
40376184:	006136        	entry	a1, 48
40376187:	006122        	s32i	a2, a1, 0
4037618a:	016132        	s32i	a3, a1, 4
4037618d:	026142        	s32i	a4, a1, 8
    void *ret = NULL;

    // Alignment, size and caps may need to be modified because of hardware requirements.
    esp_heap_adjust_alignment_to_hw(&alignment, &size, &caps);
40376190:	c18b      	addi.n	a12, a1, 8
40376192:	b14b      	addi.n	a11, a1, 4
40376194:	01ad      	mov.n	a10, a1
40376196:	015f25        	call8	40377788 <esp_heap_adjust_alignment_to_hw>

    // remove block owner size to HEAP_SIZE_MAX rather than adding the block owner size
    // to size to prevent overflows.
    if (size == 0 || size > MULTI_HEAP_REMOVE_BLOCK_OWNER_SIZE(HEAP_SIZE_MAX) ) {
40376199:	1188      	l32i.n	a8, a1, 4
4037619b:	980b      	addi.n	a9, a8, -1
4037619d:	f93ea1        	l32r	a10, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
403761a0:	02ba97        	bgeu	a10, a9, 403761a6 <heap_caps_aligned_alloc_base+0x22>
403761a3:	0027c6        	j	40376246 <heap_caps_aligned_alloc_base+0xc2>
        // Avoids int overflow when adding small numbers to size, or
        // calculating 'end' from start+size, by limiting 'size' to the possible range
        return NULL;
    }

    if (caps & MALLOC_CAP_EXEC) {
403761a6:	2198      	l32i.n	a9, a1, 8
403761a8:	0c6907        	bbci	a9, 0, 403761b8 <heap_caps_aligned_alloc_base+0x34>
        //MALLOC_CAP_EXEC forces an alloc from IRAM. There is a region which has both this as well as the following
        //caps, but the following caps are not possible for IRAM.  Thus, the combination is impossible and we return
        //NULL directly, even although our heap capabilities (based on soc_memory_tags & soc_memory_regions) would
        //indicate there is a tag for this.
        if ((caps & MALLOC_CAP_8BIT) || (caps & MALLOC_CAP_DMA)) {
403761ab:	14a290        	extui	a10, a9, 2, 2
403761ae:	09aa56        	bnez	a10, 4037624c <heap_caps_aligned_alloc_base+0xc8>
            return NULL;
        }
        caps |= MALLOC_CAP_32BIT; // IRAM is 32-bit accessible RAM
403761b1:	2a0c      	movi.n	a10, 2
403761b3:	2099a0        	or	a9, a9, a10
403761b6:	2199      	s32i.n	a9, a1, 8
    }

    if (caps & MALLOC_CAP_32BIT) {
403761b8:	2198      	l32i.n	a9, a1, 8
403761ba:	02e917        	bbsi	a9, 1, 403761c0 <heap_caps_aligned_alloc_base+0x3c>
403761bd:	001ec6        	j	4037623c <heap_caps_aligned_alloc_base+0xb8>
        /* 32-bit accessible RAM should allocated in 4 byte aligned sizes
         * (Future versions of ESP-IDF should possibly fail if an invalid size is requested)
         */
        size = (size + 3) & (~3); // int overflow checked above
403761c0:	883b      	addi.n	a8, a8, 3
403761c2:	c97c      	movi.n	a9, -4
403761c4:	108890        	and	a8, a8, a9
403761c7:	1189      	s32i.n	a8, a1, 4
403761c9:	001bc6        	j	4037623c <heap_caps_aligned_alloc_base+0xb8>
    }

    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
        //Iterate over heaps and check capabilities at this priority
        heap_t *heap;
        SLIST_FOREACH(heap, &registered_heaps, next) {
403761cc:	f93081        	l32r	a8, 4037468c <_iram_text_start+0x288> (3fc94f38 <registered_heaps>)
403761cf:	0878      	l32i.n	a7, a8, 0
403761d1:	0017c6        	j	40376234 <heap_caps_aligned_alloc_base+0xb0>
            if (heap->heap == NULL) {
403761d4:	77a8      	l32i.n	a10, a7, 28
403761d6:	058a16        	beqz	a10, 40376232 <heap_caps_aligned_alloc_base+0xae>
                continue;
            }
            if ((heap->caps[prio] & caps) != 0) {
403761d9:	a08670        	addx4	a8, a6, a7
403761dc:	0888      	l32i.n	a8, a8, 0
403761de:	2198      	l32i.n	a9, a1, 8
403761e0:	4e0897        	bnone	a8, a9, 40376232 <heap_caps_aligned_alloc_base+0xae>
    return get_ored_caps(heap->caps);
403761e3:	07dd      	mov.n	a13, a7
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
403761e5:	080c      	movi.n	a8, 0
    uint32_t all_caps = 0;
403761e7:	08bd      	mov.n	a11, a8
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
403761e9:	000246        	j	403761f6 <heap_caps_aligned_alloc_base+0x72>
        all_caps |= caps[prio];
403761ec:	a0c8d0        	addx4	a12, a8, a13
403761ef:	0cc8      	l32i.n	a12, a12, 0
403761f1:	20bbc0        	or	a11, a11, a12
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
403761f4:	881b      	addi.n	a8, a8, 1
403761f6:	f238a6        	blti	a8, 3, 403761ec <heap_caps_aligned_alloc_base+0x68>
                //Heap has at least one of the caps requested. If caps has other bits set that this prio
                //doesn't cover, see if they're available in other prios.
                if ((get_all_caps(heap) & caps) == caps) {
403761f9:	35cb97        	bnall	a11, a9, 40376232 <heap_caps_aligned_alloc_base+0xae>
                    //This heap can satisfy all the requested capabilities. See if we can grab some memory using it.
                    // If MALLOC_CAP_EXEC is requested but the DRAM and IRAM are on the same addresses (like on esp32c6)
                    // proceed as for a default allocation.
                    if ((caps & MALLOC_CAP_EXEC) &&
403761fc:	246907        	bbci	a9, 0, 40376224 <heap_caps_aligned_alloc_base+0xa0>
                        ((!esp_dram_match_iram() && esp_ptr_in_diram_dram((void *)heap->start)) ||
403761ff:	3788      	l32i.n	a8, a7, 12
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
40376201:	f91691        	l32r	a9, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
40376204:	889a      	add.n	a8, a8, a9
40376206:	f91691        	l32r	a9, 40374660 <_iram_text_start+0x25c> (67fff <UserFrameTotalSize+0x67eff>)
40376209:	173987        	bltu	a9, a8, 40376224 <heap_caps_aligned_alloc_base+0xa0>
                         (!esp_rtc_dram_match_rtc_iram() && esp_ptr_in_rtc_dram_fast((void *)heap->start)))) {
                        //This is special, insofar that what we're going to get back is a DRAM address. If so,
                        //we need to 'invert' it (lowest address in DRAM == highest address in IRAM and vice-versa) and
                        //add a pointer to the DRAM equivalent before the address we're going to return.
                        ret = aligned_or_unaligned_alloc(heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size) + 4,
4037620c:	0d0c      	movi.n	a13, 0
4037620e:	01c8      	l32i.n	a12, a1, 0
40376210:	11b8      	l32i.n	a11, a1, 4
40376212:	bb4b      	addi.n	a11, a11, 4
40376214:	ffefe5        	call8	40376114 <aligned_or_unaligned_alloc>
                                                        alignment, MULTI_HEAP_BLOCK_OWNER_SIZE());  // int overflow checked above
                        if (ret != NULL) {
40376217:	7a9c      	beqz.n	a10, 40376232 <heap_caps_aligned_alloc_base+0xae>
                                                                 get_all_caps(heap));
#endif

                            MULTI_HEAP_SET_BLOCK_OWNER(ret);
                            ret = MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ret);
                            uint32_t *iptr = dram_alloc_to_iram_addr(ret, size + 4);  // int overflow checked above
40376219:	11b8      	l32i.n	a11, a1, 4
4037621b:	bb4b      	addi.n	a11, a11, 4
4037621d:	ffe3a5        	call8	40376058 <dram_alloc_to_iram_addr>
                            CALL_HOOK(esp_heap_trace_alloc_hook, iptr, size, caps);
                            return iptr;
40376220:	000a86        	j	4037624e <heap_caps_aligned_alloc_base+0xca>
40376223:	a0d200        	addx4	a13, a2, a0
                        }
                    } else {
                        //Just try to alloc, nothing special.
                        ret = aligned_or_unaligned_alloc(heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size),
40376226:	21c200        	srai	a12, a0, 2
40376229:	21b200        	srai	a11, a0, 2
4037622c:	ee6501        	l32r	a0, 40371bc0 <rom_rx_gain_force+0x36b794>
4037622f:	78aadcff 	ee.vmulas.u8.qacc.ld.ip.qup	q1, a15, 0xfffffec0, q7, q3, q2, q2
        SLIST_FOREACH(heap, &registered_heaps, next) {
40376233:	c75687        	bbc	a6, a8, 403761fe <heap_caps_aligned_alloc_base+0x7a>
40376236:	1bf9      	s32i.n	a15, a11, 4
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
40376238:	004666        	bnei	a6, 4, 4037623c <heap_caps_aligned_alloc_base+0xb8>
4037623b:	060c00        	ee.ldf.64.xp	f0, f0, a0, a12
4037623e:	8a36a6        	blti	a6, 3, 403761cc <heap_caps_aligned_alloc_base+0x48>
            }
        }
    }

    //Nothing usable found.
    return NULL;
40376241:	0a0c      	movi.n	a10, 0
40376243:	0001c6        	j	4037624e <heap_caps_aligned_alloc_base+0xca>
        return NULL;
40376246:	0a0c      	movi.n	a10, 0
40376248:	000086        	j	4037624e <heap_caps_aligned_alloc_base+0xca>
4037624b:	0a0c00        	add.s	f0, f12, f0
}
4037624e:	0a2d      	mov.n	a2, a10
40376250:	f01d      	retw.n
	...

40376254 <heap_caps_malloc_base>:

//Wrapper for heap_caps_aligned_alloc_base as that can also do unaligned allocs.
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_malloc_base( size_t size, uint32_t caps) {
40376254:	004136        	entry	a1, 32
40376257:	02bd      	mov.n	a11, a2
40376259:	03cd      	mov.n	a12, a3
    return heap_caps_aligned_alloc_base(UNALIGNED_MEM_ALIGNMENT_BYTES, size, caps);
4037625b:	4a0c      	movi.n	a10, 4
4037625d:	fff265        	call8	40376184 <heap_caps_aligned_alloc_base>
}
40376260:	0a2d      	mov.n	a2, a10
40376262:	f01d      	retw.n

40376264 <heap_caps_realloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
HEAP_IRAM_ATTR NOINLINE_ATTR void *heap_caps_realloc_base( void *ptr, size_t size, uint32_t caps)
{
40376264:	008136        	entry	a1, 64
40376267:	206220        	or	a6, a2, a2
4037626a:	046132        	s32i	a3, a1, 16
4037626d:	5149      	s32i.n	a4, a1, 20
    bool ptr_in_diram_case = false;
    heap_t *heap = NULL;
    void *dram_ptr = NULL;

    //See if memory needs alignment because of hardware reasons.
    size_t alignment = UNALIGNED_MEM_ALIGNMENT_BYTES;
4037626f:	480c      	movi.n	a8, 4
40376271:	006182        	s32i	a8, a1, 0
    esp_heap_adjust_alignment_to_hw(&alignment, &size, &caps);
40376274:	14c1c2        	addi	a12, a1, 20
40376277:	10c1b2        	addi	a11, a1, 16
4037627a:	01ad      	mov.n	a10, a1
4037627c:	0150a5        	call8	40377788 <esp_heap_adjust_alignment_to_hw>

    if (ptr == NULL) {
4037627f:	d2cc      	bnez.n	a2, 40376290 <heap_caps_realloc_base+0x2c>
        return heap_caps_aligned_alloc_base(alignment, size, caps);
40376281:	51c8      	l32i.n	a12, a1, 20
40376283:	41b8      	l32i.n	a11, a1, 16
40376285:	01a8      	l32i.n	a10, a1, 0
40376287:	ffefe5        	call8	40376184 <heap_caps_aligned_alloc_base>
4037628a:	0a2d      	mov.n	a2, a10
4037628c:	004b86        	j	403763be <heap_caps_realloc_base+0x15a>
4037628f:	21c200        	srai	a12, a0, 2
    }

    if (size == 0) {
40376292:	ac5604        	ee.vprelu.s16	q4, q6, q6, a0
40376295:	a22000        	muluh	a2, a0, a0
        heap_caps_free(ptr);
40376298:	20          	.byte	0x20
40376299:	ffe9a5        	call8	40376134 <heap_caps_free>
        return NULL;
4037629c:	020c      	movi.n	a2, 0
4037629e:	004706        	j	403763be <heap_caps_realloc_base+0x15a>
    }

    // remove block owner size to HEAP_SIZE_MAX rather than adding the block owner size
    // to size to prevent overflows.
    if (size > MULTI_HEAP_REMOVE_BLOCK_OWNER_SIZE(HEAP_SIZE_MAX)) {
403762a1:	f8e381        	l32r	a8, 40374630 <_iram_text_start+0x22c> (2000000 <UserFrameTotalSize+0x1ffff00>)
403762a4:	02b8c7        	bgeu	a8, a12, 403762aa <heap_caps_realloc_base+0x46>
403762a7:	004446        	j	403763bc <heap_caps_realloc_base+0x158>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
403762aa:	f8f781        	l32r	a8, 40374688 <_iram_text_start+0x284> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
403762ad:	828a      	add.n	a8, a2, a8
        return NULL;
    }

    //The pointer to memory may be aliased, we need to
    //recover the corresponding address before to manage a new allocation:
    if(esp_ptr_in_diram_iram((void *)ptr)) {
403762af:	f8ec91        	l32r	a9, 40374660 <_iram_text_start+0x25c> (67fff <UserFrameTotalSize+0x67eff>)
403762b2:	343987        	bltu	a9, a8, 403762ea <heap_caps_realloc_base+0x86>
        uint32_t *dram_addr = (uint32_t *)ptr;
        dram_ptr  = (void *)dram_addr[-1];
403762b5:	fcc282        	addi	a8, a2, -4
403762b8:	0848      	l32i.n	a4, a8, 0
    intptr_t p = (intptr_t)ptr;
403762ba:	049d      	mov.n	a9, a4
    SLIST_FOREACH(heap, &registered_heaps, next) {
403762bc:	f8f481        	l32r	a8, 4037468c <_iram_text_start+0x288> (3fc94f38 <registered_heaps>)
403762bf:	0878      	l32i.n	a7, a8, 0
403762c1:	000406        	j	403762d5 <heap_caps_realloc_base+0x71>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
403762c4:	7788      	l32i.n	a8, a7, 28
403762c6:	888c      	beqz.n	a8, 403762d2 <heap_caps_realloc_base+0x6e>
403762c8:	3788      	l32i.n	a8, a7, 12
403762ca:	042987        	blt	a9, a8, 403762d2 <heap_caps_realloc_base+0x6e>
403762cd:	4788      	l32i.n	a8, a7, 16
403762cf:	052987        	blt	a9, a8, 403762d8 <heap_caps_realloc_base+0x74>
    SLIST_FOREACH(heap, &registered_heaps, next) {
403762d2:	082772        	l32i	a7, a7, 32
403762d5:	feb756        	bnez	a7, 403762c4 <heap_caps_realloc_base+0x60>
        dram_ptr = MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(dram_ptr);

        heap = find_containing_heap(dram_ptr);
        assert(heap != NULL && "realloc() pointer is outside heap areas");
403762d8:	040756        	bnez	a7, 4037631c <heap_caps_realloc_base+0xb8>
403762db:	f8f0d1        	l32r	a13, 4037469c <_iram_text_start+0x298> (3c022178 <_flash_rodata_start+0x2058>)
403762de:	f8f0c1        	l32r	a12, 403746a0 <_iram_text_start+0x29c> (3c026b34 <__func__$0>)
403762e1:	f2a0b2        	movi	a11, 242
403762e4:	f8e2a1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
403762e7:	09a425        	call8	4037fd28 <__assert_func>
    intptr_t p = (intptr_t)ptr;
403762ea:	209220        	or	a9, a2, a2
    SLIST_FOREACH(heap, &registered_heaps, next) {
403762ed:	f8e781        	l32r	a8, 4037468c <_iram_text_start+0x288> (3fc94f38 <registered_heaps>)
403762f0:	002872        	l32i	a7, a8, 0
403762f3:	000406        	j	40376307 <heap_caps_realloc_base+0xa3>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
403762f6:	7788      	l32i.n	a8, a7, 28
403762f8:	888c      	beqz.n	a8, 40376304 <heap_caps_realloc_base+0xa0>
403762fa:	3788      	l32i.n	a8, a7, 12
403762fc:	042987        	blt	a9, a8, 40376304 <heap_caps_realloc_base+0xa0>
403762ff:	4788      	l32i.n	a8, a7, 16
40376301:	052987        	blt	a9, a8, 4037630a <heap_caps_realloc_base+0xa6>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40376304:	082772        	l32i	a7, a7, 32
40376307:	feb756        	bnez	a7, 403762f6 <heap_caps_realloc_base+0x92>
        //instead force a malloc/copy/free
        ptr_in_diram_case = true;

    } else {
        heap = find_containing_heap(ptr);
        assert(heap != NULL && "realloc() pointer is outside heap areas");
4037630a:	014756        	bnez	a7, 40376322 <heap_caps_realloc_base+0xbe>
4037630d:	f8e3d1        	l32r	a13, 4037469c <_iram_text_start+0x298> (3c022178 <_flash_rodata_start+0x2058>)
40376310:	f8e4c1        	l32r	a12, 403746a0 <_iram_text_start+0x29c> (3c026b34 <__func__$0>)
40376313:	fba0b2        	movi	a11, 251
40376316:	f8d5a1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
40376319:	09a0e5        	call8	4037fd28 <__assert_func>
        ptr_in_diram_case = true;
4037631c:	01a052        	movi	a5, 1
4037631f:	0000c6        	j	40376326 <heap_caps_realloc_base+0xc2>
    void *dram_ptr = NULL;
40376322:	040c      	movi.n	a4, 0
    bool ptr_in_diram_case = false;
40376324:	045d      	mov.n	a5, a4
    if (heap->heap == NULL) {
40376326:	77a8      	l32i.n	a10, a7, 28
40376328:	8a9c      	beqz.n	a10, 40376344 <heap_caps_realloc_base+0xe0>
    return get_ored_caps(heap->caps);
4037632a:	07dd      	mov.n	a13, a7
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037632c:	090c      	movi.n	a9, 0
    uint32_t all_caps = 0;
4037632e:	098d      	mov.n	a8, a9
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
40376330:	000286        	j	4037633e <heap_caps_realloc_base+0xda>
40376333:	00          	.byte	00
        all_caps |= caps[prio];
40376334:	a0b9d0        	addx4	a11, a9, a13
40376337:	0bb8      	l32i.n	a11, a11, 0
40376339:	2088b0        	or	a8, a8, a11
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
4037633c:	991b      	addi.n	a9, a9, 1
4037633e:	f239a6        	blti	a9, 3, 40376334 <heap_caps_realloc_base+0xd0>
40376341:	000086        	j	40376347 <heap_caps_realloc_base+0xe3>
        return 0;
40376344:	00a082        	movi	a8, 0
    // processing the realloc.
    ptr = MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(ptr);

    // are the existing heap's capabilities compatible with the
    // requested ones?
    bool compatible_caps = (caps & get_all_caps(heap)) == caps;
40376347:	5198      	l32i.n	a9, a1, 20
40376349:	108890        	and	a8, a8, a9
4037634c:	308890        	xor	a8, a8, a9
4037634f:	40f880        	nsau	a8, a8
40376352:	418580        	srli	a8, a8, 5

    //Note we don't try realloc() on memory that needs to be aligned, that is handled
    //by the fallthrough code.
    if (compatible_caps && !ptr_in_diram_case && alignment<=UNALIGNED_MEM_ALIGNMENT_BYTES) {
40376355:	190c      	movi.n	a9, 1
40376357:	309590        	xor	a9, a5, a9
4037635a:	0e0987        	bnone	a9, a8, 4037636c <heap_caps_realloc_base+0x108>
4037635d:	0188      	l32i.n	a8, a1, 0
4037635f:	0958f6        	bgeui	a8, 5, 4037636c <heap_caps_realloc_base+0x108>
#if CONFIG_HEAP_TASK_TRACKING
        size_t old_size = multi_heap_get_full_block_size(heap->heap, ptr);
        TaskHandle_t old_task = MULTI_HEAP_GET_BLOCK_OWNER(ptr);
#endif

        void *r = multi_heap_realloc(heap->heap, ptr, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(size));
40376362:	06bd      	mov.n	a11, a6
40376364:	083ce5        	call8	4037e734 <multi_heap_realloc>
40376367:	0a2d      	mov.n	a2, a10
        if (r != NULL) {
40376369:	051a56        	bnez	a10, 403763be <heap_caps_realloc_base+0x15a>
        }
    }

    // if we couldn't do that, try to see if we can reallocate
    // in a different heap with requested capabilities.
    void *new_p = heap_caps_aligned_alloc_base(alignment, size, caps);
4037636c:	51c8      	l32i.n	a12, a1, 20
4037636e:	41b8      	l32i.n	a11, a1, 16
40376370:	01a8      	l32i.n	a10, a1, 0
40376372:	ffe125        	call8	40376184 <heap_caps_aligned_alloc_base>
40376375:	0a2d      	mov.n	a2, a10
    if (new_p != NULL) {
40376377:	043a16        	beqz	a10, 403763be <heap_caps_realloc_base+0x15a>
        size_t old_size = 0;

        //If we're dealing with aliased ptr, information regarding its containing
        //heap can only be obtained with translated address.
        if(ptr_in_diram_case) {
4037637a:	958c      	beqz.n	a5, 40376387 <heap_caps_realloc_base+0x123>
            old_size = multi_heap_get_allocated_size(heap->heap, dram_ptr);
4037637c:	04bd      	mov.n	a11, a4
4037637e:	0727a2        	l32i	a10, a7, 28
40376381:	083125        	call8	4037e694 <multi_heap_get_allocated_size>
40376384:	000206        	j	40376390 <heap_caps_realloc_base+0x12c>
        } else {
            old_size = multi_heap_get_allocated_size(heap->heap, ptr);
40376387:	20b660        	or	a11, a6, a6
4037638a:	0727a2        	l32i	a10, a7, 28
4037638d:	083065        	call8	4037e694 <multi_heap_get_allocated_size>
        }

        assert(old_size > 0);
40376390:	dacc      	bnez.n	a10, 403763a1 <heap_caps_realloc_base+0x13d>
40376392:	f8c4d1        	l32r	a13, 403746a4 <_iram_text_start+0x2a0> (3c0221b4 <_flash_rodata_start+0x2094>)
40376395:	f8c2c1        	l32r	a12, 403746a0 <_iram_text_start+0x29c> (3c026b34 <__func__$0>)
40376398:	34a1b2        	movi	a11, 0x134
4037639b:	f8b4a1        	l32r	a10, 4037466c <_iram_text_start+0x268> (3c0220b2 <_flash_rodata_start+0x1f92>)
4037639e:	0998a5        	call8	4037fd28 <__assert_func>
        // do not copy the block owner bytes
        memcpy(new_p, MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ptr), MIN(size, old_size));
403763a1:	0421c2        	l32i	a12, a1, 16
403763a4:	63cac0        	minu	a12, a10, a12
403763a7:	20b660        	or	a11, a6, a6
403763aa:	20a220        	or	a10, a2, a2
403763ad:	f85481        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403763b0:	0008e0        	callx8	a8
        // add the block owner bytes to ptr since they are removed in heap_caps_free
        heap_caps_free(MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(ptr));
403763b3:	06ad      	mov.n	a10, a6
403763b5:	ffd7e5        	call8	40376134 <heap_caps_free>
        return new_p;
403763b8:	000086        	j	403763be <heap_caps_realloc_base+0x15a>
403763bb:	020c00        	andb	b0, b12, b0
    }

    return NULL;
}
403763be:	f01d      	retw.n

403763c0 <heap_caps_calloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
HEAP_IRAM_ATTR void *heap_caps_calloc_base( size_t n, size_t size, uint32_t caps)
{
403763c0:	004136        	entry	a1, 32
403763c3:	04bd      	mov.n	a11, a4
    void *result;
    size_t size_bytes;

    if (__builtin_mul_overflow(n, size, &size_bytes)) {
403763c5:	080c      	movi.n	a8, 0
403763c7:	827230        	mull	a7, a2, a3
403763ca:	a22230        	muluh	a2, a2, a3
403763cd:	028c      	beqz.n	a2, 403763d1 <heap_caps_calloc_base+0x11>
403763cf:	180c      	movi.n	a8, 1
403763d1:	017856        	bnez	a8, 403763ec <heap_caps_calloc_base+0x2c>
        return NULL;
    }

    result = heap_caps_malloc_base(size_bytes, caps);
403763d4:	20a770        	or	a10, a7, a7
403763d7:	ffe7e5        	call8	40376254 <heap_caps_malloc_base>
403763da:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
403763dc:	ea8c      	beqz.n	a10, 403763ee <heap_caps_calloc_base+0x2e>
        memset(result, 0, size_bytes);
403763de:	07cd      	mov.n	a12, a7
403763e0:	0b0c      	movi.n	a11, 0
403763e2:	f83581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403763e5:	0008e0        	callx8	a8
403763e8:	000086        	j	403763ee <heap_caps_calloc_base+0x2e>
403763eb:	020c00        	andb	b0, b12, b0
    }
    return result;
}
403763ee:	f01d      	retw.n

403763f0 <calc_checksum>:

#if !NON_OS_BUILD
static __attribute__((section(".rtc_timer_data_in_rtc_mem"))) retain_mem_t s_rtc_timer_retain_mem;

static ESP_CLK_FN_ATTR uint32_t calc_checksum(void)
{
403763f0:	004136        	entry	a1, 32
    uint32_t checksum = 0;
    uint32_t *data = (uint32_t*) &s_rtc_timer_retain_mem;

    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
403763f3:	080c      	movi.n	a8, 0
    uint32_t checksum = 0;
403763f5:	082d      	mov.n	a2, a8
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
403763f7:	000506        	j	4037640f <calc_checksum+0x1f>
403763fa:	b00000        	addx8	a0, a0, a0
        checksum = ((checksum << 5) - checksum) ^ data[i];
403763fd:	201192        	l16ui	a9, a1, 64
40376400:	c029      	s32i.n	a2, a0, 48
40376402:	f8a991        	l32r	a9, 403746a8 <_iram_text_start+0x2a4> (600fffe8 <s_rtc_timer_retain_mem>)
40376405:	a09890        	addx4	a9, a8, a9
40376408:	0998      	l32i.n	a9, a9, 0
4037640a:	302290        	xor	a2, a2, a9
    for (uint32_t i = 0; i < (sizeof(retain_mem_t) - sizeof(s_rtc_timer_retain_mem.checksum)) / 4; i++) {
4037640d:	881b      	addi.n	a8, a8, 1
4037640f:	e958b6        	bltui	a8, 5, 403763fc <calc_checksum+0xc>
    }
    return checksum;
}
40376412:	f01d      	retw.n

40376414 <esp_clk_cpu_freq>:
    return g_ticks_per_us_pro;
#endif
}

int IRAM_ATTR esp_clk_cpu_freq(void)
{
40376414:	004136        	entry	a1, 32
    return esp_rom_get_cpu_ticks_per_us();
40376417:	f8a681        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
4037641a:	0008e0        	callx8	a8
    return s_get_cpu_freq_mhz() * MHZ;
}
4037641d:	f8a381        	l32r	a8, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
40376420:	822a80        	mull	a2, a10, a8
40376423:	f01d      	retw.n
40376425:	000000        	ill

40376428 <esp_clk_apb_freq>:

int IRAM_ATTR esp_clk_apb_freq(void)
{
40376428:	004136        	entry	a1, 32
    return esp_rom_get_cpu_ticks_per_us();
4037642b:	f8a181        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
4037642e:	0008e0        	callx8	a8
    // TODO: IDF-5173 Require cleanup, implementation should be unified
#if CONFIG_IDF_TARGET_ESP32C6 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32P4 || CONFIG_IDF_TARGET_ESP32C5 || CONFIG_IDF_TARGET_ESP32C61
    return rtc_clk_apb_freq_get();
#else
    return MIN(s_get_cpu_freq_mhz() * MHZ, APB_CLK_FREQ);
40376431:	f89e81        	l32r	a8, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
40376434:	82aa80        	mull	a10, a10, a8
40376437:	f8a081        	l32r	a8, 403746b8 <_iram_text_start+0x2b4> (4c4b3ff <UserFrameTotalSize+0x4c4b2ff>)
4037643a:	0e28a7        	blt	a8, a10, 4037644c <esp_clk_apb_freq+0x24>
    return esp_rom_get_cpu_ticks_per_us();
4037643d:	f89c81        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
40376440:	0008e0        	callx8	a8
    return MIN(s_get_cpu_freq_mhz() * MHZ, APB_CLK_FREQ);
40376443:	f89a81        	l32r	a8, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
40376446:	822a80        	mull	a2, a10, a8
40376449:	000086        	j	4037644f <esp_clk_apb_freq+0x27>
4037644c:	f89a21        	l32r	a2, 403746b4 <_iram_text_start+0x2b0> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
#endif
}
4037644f:	f01d      	retw.n
40376451:	000000        	ill

40376454 <esp_clk_xtal_freq>:

int IRAM_ATTR esp_clk_xtal_freq(void)
{
40376454:	004136        	entry	a1, 32
    return rtc_clk_xtal_freq_get() * MHZ;
40376457:	024d65        	call8	4037892c <rtc_clk_xtal_freq_get>
}
4037645a:	f89481        	l32r	a8, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
4037645d:	822a80        	mull	a2, a10, a8
40376460:	f01d      	retw.n
	...

40376464 <shared_intr_isr>:
    return best;
}

//Common shared isr handler. Chain-call all ISRs.
static void ESP_INTR_IRAM_ATTR shared_intr_isr(void *arg)
{
40376464:	004136        	entry	a1, 32
    vector_desc_t *vd = (vector_desc_t*)arg;
    shared_vector_desc_t *sh_vec = vd->shared_vec_info;
40376467:	1278      	l32i.n	a7, a2, 4
40376469:	fb7c      	movi.n	a11, -1
4037646b:	f894a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037646e:	03ba65        	call8	4037a014 <xPortEnterCriticalTimeout>
}
40376471:	000746        	j	40376492 <shared_intr_isr+0x2e>
    portENTER_CRITICAL_ISR(&spinlock);
    while(sh_vec) {
        if (!sh_vec->disabled) {
40376474:	001782        	l16ui	a8, a7, 0
40376477:	15e807        	bbsi	a8, 0, 40376490 <shared_intr_isr+0x2c>
            if ((sh_vec->statusreg == NULL) || (*sh_vec->statusreg & sh_vec->statusmask)) {
4037647a:	1788      	l32i.n	a8, a7, 4
4037647c:	988c      	beqz.n	a8, 40376489 <shared_intr_isr+0x25>
4037647e:	0020c0        	memw
40376481:	0898      	l32i.n	a9, a8, 0
40376483:	022782        	l32i	a8, a7, 8
40376486:	060987        	bnone	a9, a8, 40376490 <shared_intr_isr+0x2c>
                traceISR_ENTER(sh_vec->source + ETS_INTERNAL_INTR_SOURCE_OFF);
                sh_vec->isr(sh_vec->arg);
40376489:	3788      	l32i.n	a8, a7, 12
4037648b:	47a8      	l32i.n	a10, a7, 16
4037648d:	0008e0        	callx8	a8
                if (!os_task_switch_is_pended(esp_cpu_get_core_id())) {
                    traceISR_EXIT();
                }
            }
        }
        sh_vec = sh_vec->next;
40376490:	5778      	l32i.n	a7, a7, 20
    while(sh_vec) {
40376492:	fde756        	bnez	a7, 40376474 <shared_intr_isr+0x10>
    }
    portEXIT_CRITICAL_ISR(&spinlock);
40376495:	f889a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376498:	03cca5        	call8	4037a164 <vPortExitCritical>
}
4037649b:	f01d      	retw.n
4037649d:	000000        	ill

403764a0 <esp_intr_noniram_disable>:
    portEXIT_CRITICAL_SAFE(&spinlock);
    return ESP_OK;
}

void ESP_INTR_IRAM_ATTR esp_intr_noniram_disable(void)
{
403764a0:	004136        	entry	a1, 32
}

static inline BaseType_t __attribute__((always_inline)) xPortEnterCriticalTimeoutSafe(portMUX_TYPE *mux, BaseType_t timeout)
{
    BaseType_t ret;
    if (xPortInIsrContext()) {
403764a3:	03b4e5        	call8	40379ff0 <xPortInIsrContext>
403764a6:	00ca16        	beqz	a10, 403764b6 <esp_intr_noniram_disable+0x16>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403764a9:	fb7c      	movi.n	a11, -1
403764ab:	f884a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
403764ae:	03b665        	call8	4037a014 <xPortEnterCriticalTimeout>
403764b1:	000286        	j	403764bf <esp_intr_noniram_disable+0x1f>
403764b4:	b20000        	mulsh	a0, a0, a0
    } else {
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403764b7:	80a1ffaf 	ee.ldf.128.ip	f0, f3, f15, f10, a10, -16
403764bb:	65f8      	l32i.n	a15, a5, 24
403764bd:	7003b5        	call12	403e64f8 <_iram_bss_end+0x640f8>
403764c0:	03eb      	addi.n	a0, a3, 14
403764c2:	047d70        	extui	a7, a7, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t oldint;
    uint32_t cpu = esp_cpu_get_core_id();
    uint32_t non_iram_ints = non_iram_int_mask[cpu];
403764c5:	f87e81        	l32r	a8, 403746c0 <_iram_text_start+0x2bc> (3fc94f48 <non_iram_int_mask>)
403764c8:	a08780        	addx4	a8, a7, a8
403764cb:	002862        	l32i	a6, a8, 0
    if (non_iram_int_disabled_flag[cpu]) {
403764ce:	f87d81        	l32r	a8, 403746c4 <_iram_text_start+0x2c0> (3fc94f3c <non_iram_int_disabled_flag>)
403764d1:	887a      	add.n	a8, a8, a7
403764d3:	000882        	l8ui	a8, a8, 0
403764d6:	002816        	beqz	a8, 403764dc <esp_intr_noniram_disable+0x3c>
        abort();
403764d9:	097925        	call8	4037fc6c <abort>
    }
    non_iram_int_disabled_flag[cpu] = true;
403764dc:	f87a81        	l32r	a8, 403746c4 <_iram_text_start+0x2c0> (3fc94f3c <non_iram_int_disabled_flag>)
403764df:	887a      	add.n	a8, a8, a7
403764e1:	190c      	movi.n	a9, 1
403764e3:	004892        	s8i	a9, a8, 0
// ------------------ Interrupt Control --------------------

FORCE_INLINE_ATTR uint32_t xt_utils_intr_get_enabled_mask(void)
{
    uint32_t intr_mask;
    RSR(INTENABLE, intr_mask);
403764e6:	03e450        	rsr.intenable	a5
403764e9:	06ad      	mov.n	a10, a6
403764eb:	0be0a5        	call8	403822f4 <xt_ints_off>
    oldint = esp_cpu_intr_get_enabled_mask();
    esp_cpu_intr_disable(non_iram_ints);
    // Disable the RTC bit which don't want to be put in IRAM.
    rtc_isr_noniram_disable(cpu);
403764ee:	07ad      	mov.n	a10, a7
403764f0:	002a65        	call8	40376798 <rtc_isr_noniram_disable>
    // Save disabled ints
    non_iram_int_disabled[cpu] = oldint & non_iram_ints;
403764f3:	106650        	and	a6, a6, a5
403764f6:	f87481        	l32r	a8, 403746c8 <_iram_text_start+0x2c4> (3fc94f40 <non_iram_int_disabled>)
403764f9:	a07780        	addx4	a7, a7, a8
403764fc:	0769      	s32i.n	a6, a7, 0
    xPortEnterCriticalTimeoutSafe(mux, portMUX_NO_TIMEOUT);
}

static inline void __attribute__((always_inline)) vPortExitCriticalSafe(portMUX_TYPE *mux)
{
    if (xPortInIsrContext()) {
403764fe:	03af25        	call8	40379ff0 <xPortInIsrContext>
40376501:	7a8c      	beqz.n	a10, 4037650c <esp_intr_noniram_disable+0x6c>
        portEXIT_CRITICAL_ISR(mux);
40376503:	f86ea1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376506:	03c5e5        	call8	4037a164 <vPortExitCritical>
40376509:	000146        	j	40376512 <esp_intr_noniram_disable+0x72>
    } else {
        portEXIT_CRITICAL(mux);
4037650c:	f86ca1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037650f:	03c565        	call8	4037a164 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
40376512:	f01d      	retw.n

40376514 <esp_intr_noniram_enable>:

void ESP_INTR_IRAM_ATTR esp_intr_noniram_enable(void)
{
40376514:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40376517:	03ada5        	call8	40379ff0 <xPortInIsrContext>
4037651a:	00ba16        	beqz	a10, 40376529 <esp_intr_noniram_enable+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037651d:	fb7c      	movi.n	a11, -1
4037651f:	f867a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376522:	03af25        	call8	4037a014 <xPortEnterCriticalTimeout>
40376525:	000246        	j	40376532 <esp_intr_noniram_enable+0x1e>
40376528:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
40376529:	ffafb2        	movi	a11, -1
4037652c:	f864a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037652f:	03ae65        	call8	4037a014 <xPortEnterCriticalTimeout>
    asm volatile (
40376532:	03eb70        	rsr.prid	a7
40376535:	047d70        	extui	a7, a7, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t cpu = esp_cpu_get_core_id();
    int non_iram_ints = non_iram_int_disabled[cpu];
40376538:	f86481        	l32r	a8, 403746c8 <_iram_text_start+0x2c4> (3fc94f40 <non_iram_int_disabled>)
4037653b:	a08780        	addx4	a8, a7, a8
4037653e:	0028a2        	l32i	a10, a8, 0
    if (!non_iram_int_disabled_flag[cpu]) {
40376541:	f86081        	l32r	a8, 403746c4 <_iram_text_start+0x2c0> (3fc94f3c <non_iram_int_disabled_flag>)
40376544:	808870        	add	a8, a8, a7
40376547:	000882        	l8ui	a8, a8, 0
4037654a:	002856        	bnez	a8, 40376550 <esp_intr_noniram_enable+0x3c>
        abort();
4037654d:	0971e5        	call8	4037fc6c <abort>
    }
    non_iram_int_disabled_flag[cpu] = false;
40376550:	f85d81        	l32r	a8, 403746c4 <_iram_text_start+0x2c0> (3fc94f3c <non_iram_int_disabled_flag>)
40376553:	887a      	add.n	a8, a8, a7
40376555:	090c      	movi.n	a9, 0
40376557:	004892        	s8i	a9, a8, 0
    xt_ints_on(intr_mask);
4037655a:	0bd825        	call8	403822dc <xt_ints_on>
    esp_cpu_intr_enable(non_iram_ints);
    rtc_isr_noniram_enable(cpu);
4037655d:	07ad      	mov.n	a10, a7
4037655f:	0026e5        	call8	403767cc <rtc_isr_noniram_enable>
    if (xPortInIsrContext()) {
40376562:	03a8e5        	call8	40379ff0 <xPortInIsrContext>
40376565:	7a8c      	beqz.n	a10, 40376570 <esp_intr_noniram_enable+0x5c>
        portEXIT_CRITICAL_ISR(mux);
40376567:	f855a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037656a:	03bfa5        	call8	4037a164 <vPortExitCritical>
4037656d:	000146        	j	40376576 <esp_intr_noniram_enable+0x62>
        portEXIT_CRITICAL(mux);
40376570:	f853a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376573:	03bf25        	call8	4037a164 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
40376576:	f01d      	retw.n

40376578 <esp_intr_enable_source>:
void ESP_INTR_IRAM_ATTR ets_isr_mask(uint32_t mask) {
    esp_cpu_intr_disable(mask);
}

void ESP_INTR_IRAM_ATTR esp_intr_enable_source(int inum)
{
40376578:	004136        	entry	a1, 32
4037657b:	1a0c      	movi.n	a10, 1
4037657d:	401200        	ssl	a2
40376580:	a1aa00        	sll	a10, a10
40376583:	0bd5a5        	call8	403822dc <xt_ints_on>
    esp_cpu_intr_enable(1 << inum);
}
40376586:	f01d      	retw.n

40376588 <esp_intr_enable>:
{
40376588:	004136        	entry	a1, 32
    if (!handle) {
4037658b:	0ae216        	beqz	a2, 4037663d <esp_intr_enable+0xb5>
    if (xPortInIsrContext()) {
4037658e:	03a625        	call8	40379ff0 <xPortInIsrContext>
40376591:	00ca16        	beqz	a10, 403765a1 <esp_intr_enable+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376594:	ffafb2        	movi	a11, -1
40376597:	f849a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037659a:	03a7a5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037659d:	000246        	j	403765aa <esp_intr_enable+0x22>
403765a0:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403765a1:	ffafb2        	movi	a11, -1
403765a4:	f846a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
403765a7:	03a6e5        	call8	4037a014 <xPortEnterCriticalTimeout>
    if (handle->shared_vector_desc) {
403765aa:	012282        	l32i	a8, a2, 4
403765ad:	017816        	beqz	a8, 403765c8 <esp_intr_enable+0x40>
        handle->shared_vector_desc->disabled = 0;
403765b0:	001892        	l16ui	a9, a8, 0
403765b3:	ea7c      	movi.n	a10, -2
403765b5:	1099a0        	and	a9, a9, a10
403765b8:	005892        	s16i	a9, a8, 0
        source=handle->shared_vector_desc->source;
403765bb:	1288      	l32i.n	a8, a2, 4
403765bd:	08b8      	l32i.n	a11, a8, 0
403765bf:	74b1b0        	extui	a11, a11, 1, 8
403765c2:	23bb00        	sext	a11, a11, 7
403765c5:	000246        	j	403765d2 <esp_intr_enable+0x4a>
        source=handle->vector_desc->source;
403765c8:	0288      	l32i.n	a8, a2, 0
403765ca:	08b8      	l32i.n	a11, a8, 0
403765cc:	75b6b0        	extui	a11, a11, 22, 8
403765cf:	23bb00        	sext	a11, a11, 7
    if (source >= 0) {
403765d2:	012b96        	bltz	a11, 403765e8 <esp_intr_enable+0x60>
        esp_rom_route_intr_matrix(handle->vector_desc->cpu, source, handle->vector_desc->intno);
403765d5:	0288      	l32i.n	a8, a2, 0
403765d7:	08a8      	l32i.n	a10, a8, 0
403765d9:	45c1a0        	extui	a12, a10, 17, 5
403765dc:	05a0a0        	extui	a10, a10, 16, 1
403765df:	f83b81        	l32r	a8, 403746cc <_iram_text_start+0x2c8> (40001b54 <esp_rom_route_intr_matrix>)
403765e2:	0008e0        	callx8	a8
403765e5:	000d46        	j	4037661e <esp_intr_enable+0x96>
        if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
403765e8:	002292        	l32i	a9, a2, 0
403765eb:	002982        	l32i	a8, a9, 0
403765ee:	058080        	extui	a8, a8, 16, 1
403765f1:	03eba0        	rsr.prid	a10
403765f4:	04ada0        	extui	a10, a10, 13, 1
403765f7:	1a18a7        	beq	a8, a10, 40376615 <esp_intr_enable+0x8d>
    if (xPortInIsrContext()) {
403765fa:	039f65        	call8	40379ff0 <xPortInIsrContext>
403765fd:	7a8c      	beqz.n	a10, 40376608 <esp_intr_enable+0x80>
        portEXIT_CRITICAL_ISR(mux);
403765ff:	f82fa1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376602:	03b625        	call8	4037a164 <vPortExitCritical>
40376605:	000146        	j	4037660e <esp_intr_enable+0x86>
        portEXIT_CRITICAL(mux);
40376608:	f82da1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037660b:	03b5a5        	call8	4037a164 <vPortExitCritical>
            return ESP_ERR_INVALID_ARG; //Can only enable these ints on this cpu
4037660e:	02a122        	movi	a2, 0x102
40376611:	000ac6        	j	40376640 <esp_intr_enable+0xb8>
40376614:	00          	.byte	00
        ESP_INTR_ENABLE(handle->vector_desc->intno);
40376615:	0029a2        	l32i	a10, a9, 0
40376618:	45a1a0        	extui	a10, a10, 17, 5
4037661b:	fff5e5        	call8	40376578 <esp_intr_enable_source>
    if (xPortInIsrContext()) {
4037661e:	039d25        	call8	40379ff0 <xPortInIsrContext>
40376621:	0a2d      	mov.n	a2, a10
40376623:	00aa16        	beqz	a10, 40376631 <esp_intr_enable+0xa9>
        portEXIT_CRITICAL_ISR(mux);
40376626:	f825a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376629:	03b3a5        	call8	4037a164 <vPortExitCritical>
    return ESP_OK;
4037662c:	020c      	movi.n	a2, 0
4037662e:	000386        	j	40376640 <esp_intr_enable+0xb8>
        portEXIT_CRITICAL(mux);
40376631:	f822a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376634:	03b2e5        	call8	4037a164 <vPortExitCritical>
40376637:	000146        	j	40376640 <esp_intr_enable+0xb8>
4037663a:	000000        	ill
        return ESP_ERR_INVALID_ARG;
4037663d:	02a122        	movi	a2, 0x102
}
40376640:	f01d      	retw.n
	...

40376644 <esp_intr_disable_source>:

void ESP_INTR_IRAM_ATTR esp_intr_disable_source(int inum)
{
40376644:	004136        	entry	a1, 32
    xt_ints_off(intr_mask);
40376647:	1a0c      	movi.n	a10, 1
40376649:	401200        	ssl	a2
4037664c:	a1aa00        	sll	a10, a10
4037664f:	0bca65        	call8	403822f4 <xt_ints_off>
    esp_cpu_intr_disable(1 << inum);
}
40376652:	f01d      	retw.n

40376654 <esp_intr_disable>:
{
40376654:	004136        	entry	a1, 32
    if (handle == NULL) {
40376657:	0ea216        	beqz	a2, 40376745 <esp_intr_disable+0xf1>
    if (xPortInIsrContext()) {
4037665a:	039965        	call8	40379ff0 <xPortInIsrContext>
4037665d:	00ca16        	beqz	a10, 4037666d <esp_intr_disable+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376660:	ffafb2        	movi	a11, -1
40376663:	f816a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376666:	039ae5        	call8	4037a014 <xPortEnterCriticalTimeout>
40376669:	000246        	j	40376676 <esp_intr_disable+0x22>
4037666c:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037666d:	ffafb2        	movi	a11, -1
40376670:	f813a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376673:	039a25        	call8	4037a014 <xPortEnterCriticalTimeout>
    if (handle->shared_vector_desc) {
40376676:	012282        	l32i	a8, a2, 4
40376679:	047816        	beqz	a8, 403766c4 <esp_intr_disable+0x70>
        handle->shared_vector_desc->disabled = 1;
4037667c:	001892        	l16ui	a9, a8, 0
4037667f:	1a0c      	movi.n	a10, 1
40376681:	2099a0        	or	a9, a9, a10
40376684:	005892        	s16i	a9, a8, 0
        source=handle->shared_vector_desc->source;
40376687:	1288      	l32i.n	a8, a2, 4
40376689:	08c8      	l32i.n	a12, a8, 0
4037668b:	74c1c0        	extui	a12, a12, 1, 8
4037668e:	23bc00        	sext	a11, a12, 7
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
40376691:	0288      	l32i.n	a8, a2, 0
40376693:	1898      	l32i.n	a9, a8, 4
        assert(svd != NULL);
40376695:	39ec      	bnez.n	a9, 403766bc <esp_intr_disable+0x68>
40376697:	f80ed1        	l32r	a13, 403746d0 <_iram_text_start+0x2cc> (3c022218 <_flash_rodata_start+0x20f8>)
4037669a:	f80ec1        	l32r	a12, 403746d4 <_iram_text_start+0x2d0> (3c026b94 <__func__$0>)
4037669d:	a2a3b2        	movi	a11, 0x3a2
403766a0:	f80ea1        	l32r	a10, 403746d8 <_iram_text_start+0x2d4> (3c022244 <_flash_rodata_start+0x2124>)
403766a3:	096865        	call8	4037fd28 <__assert_func>
            if (svd->source == source && !svd->disabled) {
403766a6:	0988      	l32i.n	a8, a9, 0
403766a8:	748180        	extui	a8, a8, 1, 8
403766ab:	23ac00        	sext	a10, a12, 7
403766ae:	238800        	sext	a8, a8, 7
403766b1:	059a87        	bne	a10, a8, 403766ba <esp_intr_disable+0x66>
403766b4:	001982        	l16ui	a8, a9, 0
403766b7:	1a6807        	bbci	a8, 0, 403766d5 <esp_intr_disable+0x81>
            svd = svd->next;
403766ba:	5998      	l32i.n	a9, a9, 20
        while(svd) {
403766bc:	fe6956        	bnez	a9, 403766a6 <esp_intr_disable+0x52>
    bool disabled = true;
403766bf:	180c      	movi.n	a8, 1
403766c1:	000486        	j	403766d7 <esp_intr_disable+0x83>
        source=handle->vector_desc->source;
403766c4:	0288      	l32i.n	a8, a2, 0
403766c6:	08b8      	l32i.n	a11, a8, 0
403766c8:	75b6b0        	extui	a11, a11, 22, 8
403766cb:	23bb00        	sext	a11, a11, 7
    bool disabled = true;
403766ce:	180c      	movi.n	a8, 1
403766d0:	0000c6        	j	403766d7 <esp_intr_disable+0x83>
403766d3:	00          	.byte	00
403766d4:	080c00        	lsx	f0, a12, a0
    if (source >= 0) {
403766d7:	015b96        	bltz	a11, 403766f0 <esp_intr_disable+0x9c>
        if (disabled) {
403766da:	048816        	beqz	a8, 40376726 <esp_intr_disable+0xd2>
            esp_rom_route_intr_matrix(handle->vector_desc->cpu, source, INT_MUX_DISABLED_INTNO);
403766dd:	0288      	l32i.n	a8, a2, 0
403766df:	08a8      	l32i.n	a10, a8, 0
403766e1:	6c0c      	movi.n	a12, 6
403766e3:	05a0a0        	extui	a10, a10, 16, 1
403766e6:	f7f981        	l32r	a8, 403746cc <_iram_text_start+0x2c8> (40001b54 <esp_rom_route_intr_matrix>)
403766e9:	0008e0        	callx8	a8
403766ec:	000d86        	j	40376726 <esp_intr_disable+0xd2>
403766ef:	229200        	orb	b9, b2, b0
        if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
403766f2:	00          	.byte	00
403766f3:	002982        	l32i	a8, a9, 0
403766f6:	058080        	extui	a8, a8, 16, 1
403766f9:	03eba0        	rsr.prid	a10
403766fc:	04ada0        	extui	a10, a10, 13, 1
403766ff:	1a18a7        	beq	a8, a10, 4037671d <esp_intr_disable+0xc9>
    if (xPortInIsrContext()) {
40376702:	038ee5        	call8	40379ff0 <xPortInIsrContext>
40376705:	7a8c      	beqz.n	a10, 40376710 <esp_intr_disable+0xbc>
        portEXIT_CRITICAL_ISR(mux);
40376707:	f7eda1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037670a:	03a5a5        	call8	4037a164 <vPortExitCritical>
4037670d:	000146        	j	40376716 <esp_intr_disable+0xc2>
        portEXIT_CRITICAL(mux);
40376710:	f7eba1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376713:	03a525        	call8	4037a164 <vPortExitCritical>
            return ESP_ERR_INVALID_ARG; //Can only enable these ints on this cpu
40376716:	02a122        	movi	a2, 0x102
40376719:	000ac6        	j	40376748 <esp_intr_disable+0xf4>
4037671c:	00          	.byte	00
        ESP_INTR_DISABLE(handle->vector_desc->intno);
4037671d:	0029a2        	l32i	a10, a9, 0
40376720:	45a1a0        	extui	a10, a10, 17, 5
40376723:	fff225        	call8	40376644 <esp_intr_disable_source>
    if (xPortInIsrContext()) {
40376726:	038ca5        	call8	40379ff0 <xPortInIsrContext>
40376729:	0a2d      	mov.n	a2, a10
4037672b:	00aa16        	beqz	a10, 40376739 <esp_intr_disable+0xe5>
        portEXIT_CRITICAL_ISR(mux);
4037672e:	f7e3a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
40376731:	03a325        	call8	4037a164 <vPortExitCritical>
    return ESP_OK;
40376734:	020c      	movi.n	a2, 0
40376736:	000386        	j	40376748 <esp_intr_disable+0xf4>
        portEXIT_CRITICAL(mux);
40376739:	f7e0a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8> (3fc9244c <spinlock>)
4037673c:	03a265        	call8	4037a164 <vPortExitCritical>
4037673f:	000146        	j	40376748 <esp_intr_disable+0xf4>
40376742:	000000        	ill
        return ESP_ERR_INVALID_ARG;
40376745:	02a122        	movi	a2, 0x102
}
40376748:	f01d      	retw.n
	...

4037674c <rtc_isr>:
        SLIST_HEAD_INITIALIZER(s_rtc_isr_handler_list);
static DRAM_ATTR portMUX_TYPE s_rtc_isr_handler_list_lock = portMUX_INITIALIZER_UNLOCKED;
static intr_handle_t s_rtc_isr_handle;

IRAM_ATTR static void rtc_isr(void* arg)
{
4037674c:	004136        	entry	a1, 32
    uint32_t status = REG_READ(RTC_CNTL_INT_ST_REG);
4037674f:	f7e381        	l32r	a8, 403746dc <_iram_text_start+0x2d8> (60008048 <RTCCNTL+0x48>)
40376752:	0020c0        	memw
40376755:	0868      	l32i.n	a6, a8, 0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40376757:	ffafb2        	movi	a11, -1
4037675a:	f7e1a1        	l32r	a10, 403746e0 <_iram_text_start+0x2dc> (3fc92d00 <s_rtc_isr_handler_list_lock>)
4037675d:	038b65        	call8	4037a014 <xPortEnterCriticalTimeout>
    rtc_isr_handler_t* it;
    portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
40376760:	f7e181        	l32r	a8, 403746e4 <_iram_text_start+0x2e0> (3fc92d08 <s_rtc_isr_handler_list>)
40376763:	0878      	l32i.n	a7, a8, 0
40376765:	000706        	j	40376785 <rtc_isr+0x39>
        if (it->mask & status) {
40376768:	002782        	l32i	a8, a7, 0
4037676b:	140867        	bnone	a8, a6, 40376783 <rtc_isr+0x37>
            portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
4037676e:	f7dca1        	l32r	a10, 403746e0 <_iram_text_start+0x2dc> (3fc92d00 <s_rtc_isr_handler_list_lock>)
40376771:	039f25        	call8	4037a164 <vPortExitCritical>
            (*it->handler)(it->handler_arg);
40376774:	1788      	l32i.n	a8, a7, 4
40376776:	27a8      	l32i.n	a10, a7, 8
40376778:	0008e0        	callx8	a8
4037677b:	fb7c      	movi.n	a11, -1
4037677d:	f7d8a1        	l32r	a10, 403746e0 <_iram_text_start+0x2dc> (3fc92d00 <s_rtc_isr_handler_list_lock>)
40376780:	038925        	call8	4037a014 <xPortEnterCriticalTimeout>
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
40376783:	4778      	l32i.n	a7, a7, 16
40376785:	fdf756        	bnez	a7, 40376768 <rtc_isr+0x1c>
            portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
        }
    }
    portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
40376788:	f7d6a1        	l32r	a10, 403746e0 <_iram_text_start+0x2dc> (3fc92d00 <s_rtc_isr_handler_list_lock>)
4037678b:	039da5        	call8	4037a164 <vPortExitCritical>
    REG_WRITE(RTC_CNTL_INT_CLR_REG, status);
4037678e:	f7d681        	l32r	a8, 403746e8 <_iram_text_start+0x2e4> (6000804c <RTCCNTL+0x4c>)
40376791:	0020c0        	memw
40376794:	0869      	s32i.n	a6, a8, 0
}
40376796:	f01d      	retw.n

40376798 <rtc_isr_noniram_disable>:
}
#endif


IRAM_ATTR void rtc_isr_noniram_disable(uint32_t cpu)
{
40376798:	004136        	entry	a1, 32
#if SOC_LP_PERIPH_SHARE_INTERRUPT // TODO: IDF-8008
    if (rtc_isr_cpu == cpu) {
4037679b:	f7d481        	l32r	a8, 403746ec <_iram_text_start+0x2e8> (3fc92d0c <rtc_isr_cpu>)
4037679e:	0888      	l32i.n	a8, a8, 0
403767a0:	269827        	bne	a8, a2, 403767ca <rtc_isr_noniram_disable+0x32>
        rtc_intr_enabled |= RTCCNTL.int_ena.val;
403767a3:	f7d381        	l32r	a8, 403746f0 <_iram_text_start+0x2ec> (60008000 <RTCCNTL>)
403767a6:	0020c0        	memw
403767a9:	1028b2        	l32i	a11, a8, 64
403767ac:	f7d2a1        	l32r	a10, 403746f4 <_iram_text_start+0x2f0> (3fc92d10 <rtc_intr_enabled>)
403767af:	0a98      	l32i.n	a9, a10, 0
403767b1:	2099b0        	or	a9, a9, a11
403767b4:	0a99      	s32i.n	a9, a10, 0
        RTCCNTL.int_ena.val &= rtc_intr_cache;
403767b6:	0020c0        	memw
403767b9:	102892        	l32i	a9, a8, 64
403767bc:	f7cfa1        	l32r	a10, 403746f8 <_iram_text_start+0x2f4> (3fc92d14 <rtc_intr_cache>)
403767bf:	0aa8      	l32i.n	a10, a10, 0
403767c1:	1099a0        	and	a9, a9, a10
403767c4:	0020c0        	memw
403767c7:	106892        	s32i	a9, a8, 64
    }
#endif
}
403767ca:	f01d      	retw.n

403767cc <rtc_isr_noniram_enable>:

IRAM_ATTR void rtc_isr_noniram_enable(uint32_t cpu)
{
403767cc:	004136        	entry	a1, 32
#if SOC_LP_PERIPH_SHARE_INTERRUPT // TODO: IDF-8008
    if (rtc_isr_cpu == cpu) {
403767cf:	f7c781        	l32r	a8, 403746ec <_iram_text_start+0x2e8> (3fc92d0c <rtc_isr_cpu>)
403767d2:	0888      	l32i.n	a8, a8, 0
403767d4:	119827        	bne	a8, a2, 403767e9 <rtc_isr_noniram_enable+0x1d>
        RTCCNTL.int_ena.val = rtc_intr_enabled;
403767d7:	f7c781        	l32r	a8, 403746f4 <_iram_text_start+0x2f0> (3fc92d10 <rtc_intr_enabled>)
403767da:	08a8      	l32i.n	a10, a8, 0
403767dc:	f7c591        	l32r	a9, 403746f0 <_iram_text_start+0x2ec> (60008000 <RTCCNTL>)
403767df:	0020c0        	memw
403767e2:	1069a2        	s32i	a10, a9, 64
        rtc_intr_enabled = 0;
403767e5:	090c      	movi.n	a9, 0
403767e7:	0899      	s32i.n	a9, a8, 0
    }
#endif
}
403767e9:	f01d      	retw.n
	...

403767ec <rtc_brownout_isr_handler>:

static brownout_callback_t s_brownout_callback = NULL;

#if CONFIG_ESP_BROWNOUT_USE_INTR
IRAM_ATTR static void rtc_brownout_isr_handler(void *arg)
{
403767ec:	004136        	entry	a1, 32
 * @brief Clear interrupt bits.
 */
__attribute__((always_inline))
static inline void brownout_ll_intr_clear(void)
{
    RTCCNTL.int_clr.rtc_brown_out = 1;
403767ef:	f7c091        	l32r	a9, 403746f0 <_iram_text_start+0x2ec> (60008000 <RTCCNTL>)
403767f2:	0020c0        	memw
403767f5:	132982        	l32i	a8, a9, 76
403767f8:	00a2a2        	movi	a10, 0x200
403767fb:	2088a0        	or	a8, a8, a10
403767fe:	0020c0        	memw
40376801:	136982        	s32i	a8, a9, 76
     * handler returns. Since restart is called here, the flag needs to be
     * cleared manually.
     */
    brownout_ll_intr_clear();

    if (s_brownout_callback) {
40376804:	f7be81        	l32r	a8, 403746fc <_iram_text_start+0x2f8> (3fc94f84 <s_brownout_callback>)
40376807:	002882        	l32i	a8, a8, 0
4037680a:	002816        	beqz	a8, 40376810 <rtc_brownout_isr_handler+0x24>
        s_brownout_callback();
4037680d:	0008e0        	callx8	a8
40376810:	03eba0        	rsr.prid	a10
40376813:	04ada0        	extui	a10, a10, 13, 1

    // Stop the other core.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t core_id = esp_cpu_get_core_id();
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
    esp_cpu_stall(other_core_id);
40376816:	40faa0        	nsau	a10, a10
40376819:	41a5a0        	srli	a10, a10, 5
4037681c:	0150e5        	call8	40377d2c <esp_cpu_stall>
#endif

    esp_reset_reason_set_hint(ESP_RST_BROWNOUT);
4037681f:	9a0c      	movi.n	a10, 9
40376821:	014ce5        	call8	40377cf0 <esp_reset_reason_set_hint>
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    if (spi_flash_brownout_need_reset()) {
40376824:	09a8e5        	call8	403802b4 <spi_flash_brownout_need_reset>
40376827:	5a8c      	beqz.n	a10, 40376830 <rtc_brownout_isr_handler+0x44>
        bootloader_flash_reset_chip();
40376829:	00cfe5        	call8	40377528 <bootloader_flash_reset_chip>
4037682c:	001a86        	j	4037689a <rtc_brownout_isr_handler+0xae>
4037682f:	148100        	extui	a8, a0, 1, 2
40376832:	0888f7        	bany	a8, a15, 4037683e <rtc_brownout_isr_handler+0x52>
    } else
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    {
        ESP_DRAM_LOGI(TAG, "Brownout detector was triggered\r\n\r\n");
40376835:	6138b6        	bltui	a8, 3, 4037689a <rtc_brownout_isr_handler+0xae>
40376838:	f7b2b1        	l32r	a11, 40374700 <_iram_text_start+0x2fc> (3fc92d44 <TAG>)
4037683b:	f7b2a1        	l32r	a10, 40374704 <_iram_text_start+0x300> (3fc92d18 <__c$1>)
4037683e:	f72781        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40376841:	0008e0        	callx8	a8
40376844:	001486        	j	4037689a <rtc_brownout_isr_handler+0xae>
40376847:	079d00        	ee.stf.64.xp	f9, f0, a0, a13
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
4037684a:	679c      	beqz.n	a7, 40376864 <rtc_brownout_isr_handler+0x78>
                            (uart_num == 1) ? SYSTEM_UART1_RST :
4037684c:	1c1726        	beqi	a7, 1, 4037686c <rtc_brownout_isr_handler+0x80>
                            (uart_num == 2) ? SYSTEM_UART2_RST : 0);
4037684f:	052766        	bnei	a7, 2, 40376858 <rtc_brownout_isr_handler+0x6c>
    uint32_t uart_rst_bit = ((uart_num == 0) ? SYSTEM_UART_RST :
40376852:	00a282        	movi	a8, 0x200
40376855:	000046        	j	4037685a <rtc_brownout_isr_handler+0x6e>
40376858:	080c      	movi.n	a8, 0
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
4037685a:	162966        	bnei	a9, 2, 40376874 <rtc_brownout_isr_handler+0x88>
4037685d:	00a2a2        	movi	a10, 0x200
40376860:	000486        	j	40376876 <rtc_brownout_isr_handler+0x8a>
40376863:	480c00        	ssx	f0, a12, a0
    uint32_t uart_en_bit  = ((uart_num == 0) ? SYSTEM_UART_CLK_EN :
40376866:	08ad      	mov.n	a10, a8
40376868:	000286        	j	40376876 <rtc_brownout_isr_handler+0x8a>
4037686b:	082c00        	lsx	f2, a12, a0
                            (uart_num == 1) ? SYSTEM_UART1_CLK_EN :
4037686e:	0a2c      	movi.n	a10, 32
40376870:	000086        	j	40376876 <rtc_brownout_isr_handler+0x8a>
40376873:	0a0c00        	add.s	f0, f12, f0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
40376876:	f72991        	l32r	a9, 4037451c <_iram_text_start+0x118> (600c0020 <SYSTEM+0x20>)
40376879:	0020c0        	memw
4037687c:	0998      	l32i.n	a9, a9, 0
4037687e:	138987        	bany	a9, a8, 40376895 <rtc_brownout_isr_handler+0xa9>
        DPORT_REG_GET_BIT(SYSTEM_PERIP_CLK_EN0_REG, uart_en_bit) != 0;
40376881:	f72781        	l32r	a8, 40374520 <_iram_text_start+0x11c> (600c0018 <SYSTEM+0x18>)
40376884:	0020c0        	memw
40376887:	0888      	l32i.n	a8, a8, 0
    return DPORT_REG_GET_BIT(SYSTEM_PERIP_RST_EN0_REG, uart_rst_bit) == 0 &&
40376889:	0808a7        	bnone	a8, a10, 40376895 <rtc_brownout_isr_handler+0xa9>
    }

    // Flush any data left in UART FIFOs
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
        if (uart_ll_is_enabled(i)) {
            esp_rom_output_tx_wait_idle(i);
4037688c:	74a070        	extui	a10, a7, 0, 8
4037688f:	f71881        	l32r	a8, 403744f0 <_iram_text_start+0xec> (4000069c <esp_rom_output_tx_wait_idle>)
40376892:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_UART_HP_NUM; ++i) {
40376895:	771b      	addi.n	a7, a7, 1
40376897:	000046        	j	4037689c <rtc_brownout_isr_handler+0xb0>
                            (uart_num == 2) ? SYSTEM_UART2_CLK_EN : 0);
4037689a:	070c      	movi.n	a7, 0
4037689c:	a837a6        	blti	a7, 3, 40376848 <rtc_brownout_isr_handler+0x5c>
        }
    }

    esp_rom_software_reset_system();
4037689f:	f79a81        	l32r	a8, 40374708 <_iram_text_start+0x304> (400006d8 <esp_rom_software_reset_system>)
403768a2:	0008e0        	callx8	a8

    ESP_INFINITE_LOOP();
403768a5:	ffff06        	j	403768a5 <rtc_brownout_isr_handler+0xb9>

403768a8 <xPortInterruptedFromISRContext>:
    /* Assert if the interrupt nesting count is > 0 */
    configASSERT(xPortInIsrContext() == 0);
}

BaseType_t IRAM_ATTR xPortInterruptedFromISRContext(void)
{
403768a8:	004136        	entry	a1, 32
403768ab:	03eb80        	rsr.prid	a8
403768ae:	048d80        	extui	a8, a8, 13, 1
    return (port_interruptNesting[xPortGetCoreID()] != 0);
403768b1:	f79691        	l32r	a9, 4037470c <_iram_text_start+0x308> (3fc95270 <port_interruptNesting>)
403768b4:	a08890        	addx4	a8, a8, a9
403768b7:	0828      	l32i.n	a2, a8, 0
}
403768b9:	180c      	movi.n	a8, 1
403768bb:	932820        	movnez	a2, a8, a2
403768be:	f01d      	retw.n

403768c0 <lock_init_generic>:

   Called by _lock_init*, also called by _lock_acquire* to lazily initialize locks that might have
   been initialised (to zero only) before the RTOS scheduler started.
*/
static void NEWLIB_LOCKS_IRAM_ATTR lock_init_generic(_lock_t *lock, uint8_t mutex_type)
{
403768c0:	004136        	entry	a1, 32
403768c3:	ffafb2        	movi	a11, -1
403768c6:	f792a1        	l32r	a10, 40374710 <_iram_text_start+0x30c> (3fc92508 <lock_init_spinlock>)
403768c9:	0374a5        	call8	4037a014 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL(&lock_init_spinlock);
    if (*lock) {
403768cc:	0288      	l32i.n	a8, a2, 0
403768ce:	a8cc      	bnez.n	a8, 403768dc <lock_init_generic+0x1c>
           implements these as macros instead of inline functions
           (*party like it's 1998!*) it's not possible to do this
           without writing wrappers. Doing it this way seems much less
           spaghetti-like.
        */
        SemaphoreHandle_t new_sem = xQueueCreateMutex(mutex_type);
403768d0:	03ad      	mov.n	a10, a3
403768d2:	0329a5        	call8	40379b6c <xQueueCreateMutex>
        if (!new_sem) {
403768d5:	1acc      	bnez.n	a10, 403768da <lock_init_generic+0x1a>
            abort(); /* No more semaphores available or OOM */
403768d7:	093965        	call8	4037fc6c <abort>
        }
        *lock = (_lock_t)new_sem;
403768da:	02a9      	s32i.n	a10, a2, 0
    }
    portEXIT_CRITICAL(&lock_init_spinlock);
403768dc:	f78da1        	l32r	a10, 40374710 <_iram_text_start+0x30c> (3fc92508 <lock_init_spinlock>)
403768df:	038865        	call8	4037a164 <vPortExitCritical>
}
403768e2:	f01d      	retw.n

403768e4 <check_lock_nonzero>:
    _lock_close_recursive(&lock);
}

/* Separate function, to prevent generating multiple assert strings */
static void NEWLIB_LOCKS_IRAM_ATTR check_lock_nonzero(_LOCK_T lock)
{
403768e4:	004136        	entry	a1, 32
    assert(lock != NULL && "Uninitialized lock used");
403768e7:	00e256        	bnez	a2, 403768f9 <check_lock_nonzero+0x15>
403768ea:	f78ad1        	l32r	a13, 40374714 <_iram_text_start+0x310> (3c023c6c <_flash_rodata_start+0x3b4c>)
403768ed:	f78ac1        	l32r	a12, 40374718 <_iram_text_start+0x314> (3c0273bc <__func__$3>)
403768f0:	3fa1b2        	movi	a11, 0x13f
403768f3:	f78aa1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3c023cb4 <_flash_rodata_start+0x3b94>)
403768f6:	094325        	call8	4037fd28 <__assert_func>
}
403768f9:	f01d      	retw.n
	...

403768fc <lock_acquire_generic>:
{
403768fc:	006136        	entry	a1, 48
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
403768ff:	002272        	l32i	a7, a2, 0
    if (!h) {
40376902:	27ec      	bnez.n	a7, 40376928 <lock_acquire_generic+0x2c>
        if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376904:	0502e5        	call8	4037b934 <xTaskGetSchedulerState>
40376907:	021a66        	bnei	a10, 1, 4037690d <lock_acquire_generic+0x11>
4037690a:	002106        	j	40376992 <lock_acquire_generic+0x96>
        lock_init_generic(lock, mutex_type);
4037690d:	04bd      	mov.n	a11, a4
4037690f:	20a220        	or	a10, a2, a2
40376912:	fffae5        	call8	403768c0 <lock_init_generic>
        h = (SemaphoreHandle_t)(*lock);
40376915:	0278      	l32i.n	a7, a2, 0
        configASSERT(h != NULL);
40376917:	d7cc      	bnez.n	a7, 40376928 <lock_acquire_generic+0x2c>
40376919:	f781d1        	l32r	a13, 40374720 <_iram_text_start+0x31c> (3c023cbc <_flash_rodata_start+0x3b9c>)
4037691c:	f782c1        	l32r	a12, 40374724 <_iram_text_start+0x320> (3c0273e8 <__func__$1>)
4037691f:	87a0b2        	movi	a11, 135
40376922:	f77ea1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3c023cb4 <_flash_rodata_start+0x3b94>)
40376925:	094025        	call8	4037fd28 <__assert_func>
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376928:	201110        	or	a1, a1, a1
4037692b:	0500a5        	call8	4037b934 <xTaskGetSchedulerState>
4037692e:	661a26        	beqi	a10, 1, 40376998 <lock_acquire_generic+0x9c>
FORCE_INLINE_ATTR bool xPortCanYield(void)
{
    uint32_t ps_reg = 0;

    //Get the current value of PS (processor status) register
    RSR(PS, ps_reg);
40376931:	03e680        	rsr.ps	a8
     * excm  = (ps_reg >> 4) & 0x1;
     * CINTLEVEL is max(excm * EXCMLEVEL, INTLEVEL), where EXCMLEVEL is 3.
     * However, just return true, only intlevel is zero.
     */

    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
40376934:	348080        	extui	a8, a8, 0, 4
    if (!xPortCanYield()) {
40376937:	18bc      	beqz.n	a8, 4037696c <lock_acquire_generic+0x70>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376939:	054466        	bnei	a4, 4, 40376942 <lock_acquire_generic+0x46>
            abort(); /* recursive mutexes make no sense in ISR context */
4037693c:	201110        	or	a1, a1, a1
4037693f:	0932e5        	call8	4037fc6c <abort>
        BaseType_t higher_task_woken = false;
40376942:	00a0b2        	movi	a11, 0
40376945:	0061b2        	s32i	a11, a1, 0
        success = xSemaphoreTakeFromISR(h, &higher_task_woken);
40376948:	01cd      	mov.n	a12, a1
4037694a:	07ad      	mov.n	a10, a7
4037694c:	0349a5        	call8	40379de8 <xQueueReceiveFromISR>
4037694f:	0a2d      	mov.n	a2, a10
        if (!success && delay > 0) {
40376951:	40fa80        	nsau	a8, a10
40376954:	418580        	srli	a8, a8, 5
40376957:	190c      	movi.n	a9, 1
40376959:	839330        	moveqz	a9, a3, a3
4037695c:	020897        	bnone	a8, a9, 40376962 <lock_acquire_generic+0x66>
            abort(); /* Tried to block on mutex from ISR, couldn't... rewrite your program to avoid libc interactions in ISRs! */
4037695f:	0930e5        	call8	4037fc6c <abort>
        if (higher_task_woken) {
40376962:	0188      	l32i.n	a8, a1, 0
40376964:	28ac      	beqz.n	a8, 4037698a <lock_acquire_generic+0x8e>
            portYIELD_FROM_ISR();
40376966:	038fa5        	call8	4037a260 <_frxt_setup_switch>
40376969:	000746        	j	4037698a <lock_acquire_generic+0x8e>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
4037696c:	0e4466        	bnei	a4, 4, 4037697e <lock_acquire_generic+0x82>
            success = xSemaphoreTakeRecursive(h, delay);
4037696f:	20b330        	or	a11, a3, a3
40376972:	20a770        	or	a10, a7, a7
40376975:	0342e5        	call8	40379da4 <xQueueTakeMutexRecursive>
40376978:	202aa0        	or	a2, a10, a10
4037697b:	0002c6        	j	4037698a <lock_acquire_generic+0x8e>
            success = xSemaphoreTake(h, delay);
4037697e:	20b330        	or	a11, a3, a3
40376981:	20a770        	or	a10, a7, a7
40376984:	033165        	call8	40379c9c <xQueueSemaphoreTake>
40376987:	202aa0        	or	a2, a10, a10
    return (success == pdTRUE) ? 0 : -1;
4037698a:	0f1266        	bnei	a2, 1, 4037699d <lock_acquire_generic+0xa1>
4037698d:	020c      	movi.n	a2, 0
4037698f:	000306        	j	4037699f <lock_acquire_generic+0xa3>
            return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
40376992:	020c      	movi.n	a2, 0
40376994:	0001c6        	j	4037699f <lock_acquire_generic+0xa3>
40376997:	020c00        	andb	b0, b12, b0
        return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
4037699a:	000046        	j	4037699f <lock_acquire_generic+0xa3>
    return (success == pdTRUE) ? 0 : -1;
4037699d:	f27c      	movi.n	a2, -1
}
4037699f:	f01d      	retw.n
403769a1:	000000        	ill

403769a4 <lock_release_generic>:
{
403769a4:	006136        	entry	a1, 48
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
403769a7:	04f8e5        	call8	4037b934 <xTaskGetSchedulerState>
403769aa:	521a26        	beqi	a10, 1, 40376a00 <lock_release_generic+0x5c>
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
403769ad:	0022a2        	l32i	a10, a2, 0
    assert(h);
403769b0:	00ea56        	bnez	a10, 403769c2 <lock_release_generic+0x1e>
403769b3:	f75dd1        	l32r	a13, 40374728 <_iram_text_start+0x324> (3c025cb8 <_flash_rodata_start+0x5b98>)
403769b6:	f75dc1        	l32r	a12, 4037472c <_iram_text_start+0x328> (3c0273d0 <__func__$2>)
403769b9:	c4a0b2        	movi	a11, 196
403769bc:	f758a1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3c023cb4 <_flash_rodata_start+0x3b94>)
403769bf:	0936a5        	call8	4037fd28 <__assert_func>
    RSR(PS, ps_reg);
403769c2:	03e680        	rsr.ps	a8
    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
403769c5:	348080        	extui	a8, a8, 0, 4
    if (!xPortCanYield()) {
403769c8:	01c816        	beqz	a8, 403769e8 <lock_release_generic+0x44>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
403769cb:	024366        	bnei	a3, 4, 403769d1 <lock_release_generic+0x2d>
            abort(); /* indicates logic bug, it shouldn't be possible to lock recursively in ISR */
403769ce:	0929e5        	call8	4037fc6c <abort>
        BaseType_t higher_task_woken = false;
403769d1:	00a082        	movi	a8, 0
403769d4:	006182        	s32i	a8, a1, 0
        xSemaphoreGiveFromISR(h, &higher_task_woken);
403769d7:	20b110        	or	a11, a1, a1
403769da:	032065        	call8	40379be0 <xQueueGiveFromISR>
        if (higher_task_woken) {
403769dd:	0188      	l32i.n	a8, a1, 0
403769df:	d89c      	beqz.n	a8, 40376a00 <lock_release_generic+0x5c>
            portYIELD_FROM_ISR();
403769e1:	0387e5        	call8	4037a260 <_frxt_setup_switch>
403769e4:	000606        	j	40376a00 <lock_release_generic+0x5c>
403769e7:	436600        	min	a6, a6, a0
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
403769ea:	6508      	l32i.n	a0, a5, 24
            xSemaphoreGiveRecursive(h);
403769ec:	031b      	addi.n	a0, a3, 1
403769ee:	000386        	j	40376a00 <lock_release_generic+0x5c>
403769f1:	000000        	ill
            xSemaphoreGive(h);
403769f4:	00a0d2        	movi	a13, 0
403769f7:	20cdd0        	or	a12, a13, a13
403769fa:	20bdd0        	or	a11, a13, a13
403769fd:	02ff65        	call8	403799f4 <xQueueGenericSend>
}
40376a00:	f01d      	retw.n
	...

40376a04 <_lock_close>:
{
40376a04:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40376a07:	ffafb2        	movi	a11, -1
40376a0a:	f741a1        	l32r	a10, 40374710 <_iram_text_start+0x30c> (3fc92508 <lock_init_spinlock>)
40376a0d:	036065        	call8	4037a014 <xPortEnterCriticalTimeout>
    if (*lock) {
40376a10:	0278      	l32i.n	a7, a2, 0
40376a12:	d79c      	beqz.n	a7, 40376a33 <_lock_close+0x2f>
        configASSERT(xSemaphoreGetMutexHolder(h) == NULL); /* mutex should not be held */
40376a14:	07ad      	mov.n	a10, a7
40376a16:	02fa65        	call8	403799bc <xQueueGetMutexHolder>
40376a19:	da8c      	beqz.n	a10, 40376a2a <_lock_close+0x26>
40376a1b:	f745d1        	l32r	a13, 40374730 <_iram_text_start+0x32c> (3c023cd0 <_flash_rodata_start+0x3bb0>)
40376a1e:	f745c1        	l32r	a12, 40374734 <_iram_text_start+0x330> (3c027400 <__func__$0>)
40376a21:	70a0b2        	movi	a11, 112
40376a24:	f73ea1        	l32r	a10, 4037471c <_iram_text_start+0x318> (3c023cb4 <_flash_rodata_start+0x3b94>)
40376a27:	093025        	call8	4037fd28 <__assert_func>
        vSemaphoreDelete(h);
40376a2a:	07ad      	mov.n	a10, a7
40376a2c:	034425        	call8	40379e70 <vQueueDelete>
        *lock = 0;
40376a2f:	080c      	movi.n	a8, 0
40376a31:	0289      	s32i.n	a8, a2, 0
    portEXIT_CRITICAL(&lock_init_spinlock);
40376a33:	f737a1        	l32r	a10, 40374710 <_iram_text_start+0x30c> (3fc92508 <lock_init_spinlock>)
40376a36:	0372e5        	call8	4037a164 <vPortExitCritical>
}
40376a39:	f01d      	retw.n
	...

40376a3c <_lock_acquire>:
{
40376a3c:	004136        	entry	a1, 32
40376a3f:	02ad      	mov.n	a10, a2
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_MUTEX);
40376a41:	1c0c      	movi.n	a12, 1
40376a43:	fb7c      	movi.n	a11, -1
40376a45:	ffeb65        	call8	403768fc <lock_acquire_generic>
}
40376a48:	f01d      	retw.n
	...

40376a4c <_lock_acquire_recursive>:
{
40376a4c:	004136        	entry	a1, 32
40376a4f:	02ad      	mov.n	a10, a2
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a51:	4c0c      	movi.n	a12, 4
40376a53:	fb7c      	movi.n	a11, -1
40376a55:	ffea65        	call8	403768fc <lock_acquire_generic>
}
40376a58:	f01d      	retw.n
	...

40376a5c <_lock_try_acquire>:
{
40376a5c:	004136        	entry	a1, 32
40376a5f:	02ad      	mov.n	a10, a2
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_MUTEX);
40376a61:	1c0c      	movi.n	a12, 1
40376a63:	0b0c      	movi.n	a11, 0
40376a65:	ffe965        	call8	403768fc <lock_acquire_generic>
}
40376a68:	0a2d      	mov.n	a2, a10
40376a6a:	f01d      	retw.n

40376a6c <_lock_try_acquire_recursive>:
{
40376a6c:	004136        	entry	a1, 32
40376a6f:	02ad      	mov.n	a10, a2
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a71:	4c0c      	movi.n	a12, 4
40376a73:	0b0c      	movi.n	a11, 0
40376a75:	ffe865        	call8	403768fc <lock_acquire_generic>
}
40376a78:	0a2d      	mov.n	a2, a10
40376a7a:	f01d      	retw.n

40376a7c <_lock_release>:
{
40376a7c:	004136        	entry	a1, 32
40376a7f:	20a220        	or	a10, a2, a2
    lock_release_generic(lock, queueQUEUE_TYPE_MUTEX);
40376a82:	01a0b2        	movi	a11, 1
40376a85:	fff1e5        	call8	403769a4 <lock_release_generic>
}
40376a88:	000090        	retw
	...

40376a8c <_lock_release_recursive>:
{
40376a8c:	004136        	entry	a1, 32
40376a8f:	20a220        	or	a10, a2, a2
    lock_release_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376a92:	04a0b2        	movi	a11, 4
40376a95:	fff0e5        	call8	403769a4 <lock_release_generic>
}
40376a98:	000090        	retw
	...

40376a9c <__retarget_lock_init>:
{
40376a9c:	004136        	entry	a1, 32
40376a9f:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376aa2:	00a082        	movi	a8, 0
40376aa5:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_MUTEX);
40376aa8:	1b0c      	movi.n	a11, 1
40376aaa:	ffe165        	call8	403768c0 <lock_init_generic>
}
40376aad:	f01d      	retw.n
	...

40376ab0 <__retarget_lock_init_recursive>:
{
40376ab0:	004136        	entry	a1, 32
40376ab3:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376ab6:	00a082        	movi	a8, 0
40376ab9:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376abc:	4b0c      	movi.n	a11, 4
40376abe:	ffe025        	call8	403768c0 <lock_init_generic>
}
40376ac1:	f01d      	retw.n
	...

40376ac4 <__retarget_lock_close>:
{
40376ac4:	006136        	entry	a1, 48
40376ac7:	006122        	s32i	a2, a1, 0
    _lock_close(&lock);
40376aca:	20a110        	or	a10, a1, a1
40376acd:	fff365        	call8	40376a04 <_lock_close>
}
40376ad0:	000090        	retw
	...

40376ad4 <__retarget_lock_close_recursive>:
{
40376ad4:	006136        	entry	a1, 48
40376ad7:	006122        	s32i	a2, a1, 0
    _lock_close_recursive(&lock);
40376ada:	20a110        	or	a10, a1, a1
40376add:	fff265        	call8	40376a04 <_lock_close>
}
40376ae0:	000090        	retw
	...

40376ae4 <__retarget_lock_acquire>:

void NEWLIB_LOCKS_IRAM_ATTR __retarget_lock_acquire(_LOCK_T lock)
{
40376ae4:	006136        	entry	a1, 48
40376ae7:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376ae9:	027d      	mov.n	a7, a2
40376aeb:	02ad      	mov.n	a10, a2
40376aed:	ffdf65        	call8	403768e4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376af0:	0298      	l32i.n	a9, a2, 0
40376af2:	f71181        	l32r	a8, 40374738 <_iram_text_start+0x334> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376af5:	049987        	bne	a9, a8, 40376afd <__retarget_lock_acquire+0x19>
40376af8:	f71181        	l32r	a8, 4037473c <_iram_text_start+0x338> (3fc952e8 <__lock___arc4random_mutex>)
40376afb:	0189      	s32i.n	a8, a1, 0
    _lock_acquire(&lock);
40376afd:	01ad      	mov.n	a10, a1
40376aff:	fff3e5        	call8	40376a3c <_lock_acquire>
}
40376b02:	f01d      	retw.n

40376b04 <__retarget_lock_acquire_recursive>:

void NEWLIB_LOCKS_IRAM_ATTR __retarget_lock_acquire_recursive(_LOCK_T lock)
{
40376b04:	006136        	entry	a1, 48
40376b07:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b09:	027d      	mov.n	a7, a2
40376b0b:	02ad      	mov.n	a10, a2
40376b0d:	ffdd65        	call8	403768e4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376b10:	0298      	l32i.n	a9, a2, 0
40376b12:	f70981        	l32r	a8, 40374738 <_iram_text_start+0x334> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b15:	049987        	bne	a9, a8, 40376b1d <__retarget_lock_acquire_recursive+0x19>
40376b18:	f70a81        	l32r	a8, 40374740 <_iram_text_start+0x33c> (3fc95294 <__lock___atexit_recursive_mutex>)
40376b1b:	0189      	s32i.n	a8, a1, 0
    _lock_acquire_recursive(&lock);
40376b1d:	01ad      	mov.n	a10, a1
40376b1f:	fff2e5        	call8	40376a4c <_lock_acquire_recursive>
}
40376b22:	f01d      	retw.n

40376b24 <__retarget_lock_try_acquire>:

int NEWLIB_LOCKS_IRAM_ATTR __retarget_lock_try_acquire(_LOCK_T lock)
{
40376b24:	006136        	entry	a1, 48
40376b27:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b29:	027d      	mov.n	a7, a2
40376b2b:	02ad      	mov.n	a10, a2
40376b2d:	ffdb65        	call8	403768e4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376b30:	0298      	l32i.n	a9, a2, 0
40376b32:	f70181        	l32r	a8, 40374738 <_iram_text_start+0x334> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b35:	049987        	bne	a9, a8, 40376b3d <__retarget_lock_try_acquire+0x19>
40376b38:	f70181        	l32r	a8, 4037473c <_iram_text_start+0x338> (3fc952e8 <__lock___arc4random_mutex>)
40376b3b:	0189      	s32i.n	a8, a1, 0
    return _lock_try_acquire(&lock);
40376b3d:	20a110        	or	a10, a1, a1
40376b40:	fff1a5        	call8	40376a5c <_lock_try_acquire>
}
40376b43:	202aa0        	or	a2, a10, a10
40376b46:	000090        	retw
40376b49:	000000        	ill

40376b4c <__retarget_lock_try_acquire_recursive>:

int NEWLIB_LOCKS_IRAM_ATTR __retarget_lock_try_acquire_recursive(_LOCK_T lock)
{
40376b4c:	006136        	entry	a1, 48
40376b4f:	0129      	s32i.n	a2, a1, 0
    check_lock_nonzero(lock);
40376b51:	027d      	mov.n	a7, a2
40376b53:	02ad      	mov.n	a10, a2
40376b55:	ffd8e5        	call8	403768e4 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376b58:	0298      	l32i.n	a9, a2, 0
40376b5a:	f6f781        	l32r	a8, 40374738 <_iram_text_start+0x334> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
40376b5d:	049987        	bne	a9, a8, 40376b65 <__retarget_lock_try_acquire_recursive+0x19>
40376b60:	f6f881        	l32r	a8, 40374740 <_iram_text_start+0x33c> (3fc95294 <__lock___atexit_recursive_mutex>)
40376b63:	0189      	s32i.n	a8, a1, 0
    return _lock_try_acquire_recursive(&lock);
40376b65:	20a110        	or	a10, a1, a1
40376b68:	fff025        	call8	40376a6c <_lock_try_acquire_recursive>
}
40376b6b:	202aa0        	or	a2, a10, a10
40376b6e:	000090        	retw
40376b71:	000000        	ill

40376b74 <__retarget_lock_release>:

void NEWLIB_LOCKS_IRAM_ATTR __retarget_lock_release(_LOCK_T lock)
{
40376b74:	006136        	entry	a1, 48
40376b77:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376b7a:	20a220        	or	a10, a2, a2
40376b7d:	ffd665        	call8	403768e4 <check_lock_nonzero>
    _lock_release(&lock);
40376b80:	01ad      	mov.n	a10, a1
40376b82:	ffefa5        	call8	40376a7c <_lock_release>
}
40376b85:	f01d      	retw.n
	...

40376b88 <__retarget_lock_release_recursive>:

void NEWLIB_LOCKS_IRAM_ATTR __retarget_lock_release_recursive(_LOCK_T lock)
{
40376b88:	006136        	entry	a1, 48
40376b8b:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376b8e:	20a220        	or	a10, a2, a2
40376b91:	ffd525        	call8	403768e4 <check_lock_nonzero>
    _lock_release_recursive(&lock);
40376b94:	01ad      	mov.n	a10, a1
40376b96:	ffef65        	call8	40376a8c <_lock_release_recursive>
}
40376b99:	f01d      	retw.n
	...

40376b9c <usb_serial_jtag_sof_tick_hook>:
{
    return s_usb_serial_jtag_conn_status;
}

static void IRAM_ATTR usb_serial_jtag_sof_tick_hook(void)
{
40376b9c:	004136        	entry	a1, 32
 *
 * @return The USB_SERIAL_JTAG raw interrupt status.
 */
static inline __attribute__((always_inline)) uint32_t usb_serial_jtag_ll_get_intraw_mask(void)
{
    return USB_SERIAL_JTAG.int_raw.val;
40376b9f:	f6e991        	l32r	a9, 40374744 <_iram_text_start+0x340> (60038000 <USB_SERIAL_JTAG>)
40376ba2:	0020c0        	memw
40376ba5:	2988      	l32i.n	a8, a9, 8
    // SOF packet is sent by the HOST every 1ms on a full speed bus
    // Between two consecutive tick hooks, there will be at least 1ms (selectable tick rate range is 1 - 1000Hz)
    // Therefore, SOF intr bit must have be raised at every tick hook if it is connected to a HOST
    // Here, the strategy is: Always assume USB Serial/JTAG is connected until we are sure it is not connected
    // Consider it is disconnected only if SOF intr bit is not raised within (ALLOWED_NO_SOF_TICKS + 1) tick periods
    bool sof_received = (usb_serial_jtag_ll_get_intraw_mask() & USB_SERIAL_JTAG_INTR_SOF);
40376ba7:	2a0c      	movi.n	a10, 2
40376ba9:	1088a0        	and	a8, a8, a10
40376bac:	1b0c      	movi.n	a11, 1
40376bae:	83b880        	moveqz	a11, a8, a8
 *
 * @return None
 */
static inline __attribute__((always_inline)) void usb_serial_jtag_ll_clr_intsts_mask(uint32_t mask)
{
    USB_SERIAL_JTAG.int_clr.val = mask;
40376bb1:	0020c0        	memw
40376bb4:	59a9      	s32i.n	a10, a9, 20
    usb_serial_jtag_ll_clr_intsts_mask(USB_SERIAL_JTAG_INTR_SOF);
    if (s_usb_serial_jtag_conn_status != sof_received) {
40376bb6:	f6e491        	l32r	a9, 40374748 <_iram_text_start+0x344> (3fc95364 <s_usb_serial_jtag_conn_status>)
40376bb9:	0020c0        	memw
40376bbc:	000992        	l8ui	a9, a9, 0
40376bbf:	749090        	extui	a9, a9, 0, 8
40376bc2:	3e19b7        	beq	a9, a11, 40376c04 <usb_serial_jtag_sof_tick_hook+0x68>
        if (!sof_received) {
40376bc5:	38ec      	bnez.n	a8, 40376bec <usb_serial_jtag_sof_tick_hook+0x50>
            if (remaining_allowed_no_sof_ticks > 0) {
40376bc7:	f6e181        	l32r	a8, 4037474c <_iram_text_start+0x348> (3fc95360 <remaining_allowed_no_sof_ticks>)
40376bca:	0888      	l32i.n	a8, a8, 0
40376bcc:	888c      	beqz.n	a8, 40376bd8 <usb_serial_jtag_sof_tick_hook+0x3c>
                remaining_allowed_no_sof_ticks--;
40376bce:	880b      	addi.n	a8, a8, -1
40376bd0:	f6df91        	l32r	a9, 4037474c <_iram_text_start+0x348> (3fc95360 <remaining_allowed_no_sof_ticks>)
40376bd3:	0989      	s32i.n	a8, a9, 0
40376bd5:	000ac6        	j	40376c04 <usb_serial_jtag_sof_tick_hook+0x68>
                // Tolerance credit used up, considered as USJ disconnected
#if CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION
                esp_pm_lock_release(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
                rtc_clk_bbpll_remove_consumer();
40376bd8:	0195a5        	call8	40378534 <rtc_clk_bbpll_remove_consumer>
#endif
                s_usb_serial_jtag_conn_status = false;
40376bdb:	f6db81        	l32r	a8, 40374748 <_iram_text_start+0x344> (3fc95364 <s_usb_serial_jtag_conn_status>)
40376bde:	090c      	movi.n	a9, 0
40376be0:	0020c0        	memw
40376be3:	004892        	s8i	a9, a8, 0
40376be6:	000686        	j	40376c04 <usb_serial_jtag_sof_tick_hook+0x68>
40376be9:	000000        	ill
            // USJ re-connected
#if CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION
            esp_pm_lock_acquire(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
            rtc_clk_bbpll_add_consumer();
40376bec:	019365        	call8	40378524 <rtc_clk_bbpll_add_consumer>
#endif
            s_usb_serial_jtag_conn_status = true;
40376bef:	f6d681        	l32r	a8, 40374748 <_iram_text_start+0x344> (3fc95364 <s_usb_serial_jtag_conn_status>)
40376bf2:	01a092        	movi	a9, 1
40376bf5:	0020c0        	memw
40376bf8:	004892        	s8i	a9, a8, 0
            remaining_allowed_no_sof_ticks = ALLOWED_NO_SOF_TICKS;
40376bfb:	f6d481        	l32r	a8, 4037474c <_iram_text_start+0x348> (3fc95360 <remaining_allowed_no_sof_ticks>)
40376bfe:	00a092        	movi	a9, 0
40376c01:	006892        	s32i	a9, a8, 0
        }
    }
}
40376c04:	f01d      	retw.n
	...

40376c08 <xt_unhandled_interrupt>:

/*
  Default handler for unhandled interrupts.
*/
void IRAM_ATTR xt_unhandled_interrupt(void * arg)
{
40376c08:	004136        	entry	a1, 32
40376c0b:	02bd      	mov.n	a11, a2
40376c0d:	03ebc0        	rsr.prid	a12
40376c10:	04cdc0        	extui	a12, a12, 13, 1
    esp_rom_printf("Unhandled interrupt %d on cpu %d!\n", (int)arg, xPortGetCoreID());
40376c13:	f6cfa1        	l32r	a10, 40374750 <_iram_text_start+0x34c> (3c024c14 <_flash_rodata_start+0x4af4>)
40376c16:	f63181        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40376c19:	0008e0        	callx8	a8
}
40376c1c:	f01d      	retw.n
	...

40376c20 <xt_debugexception>:
    movi    a0,PANIC_RSN_DEBUGEXCEPTION
40376c20:	100c      	movi.n	a0, 1
    wsr     a0,EXCCAUSE
40376c22:	13e800        	wsr.exccause	a0
    rsr     a0,(EPC + XCHAL_DEBUGLEVEL)
40376c25:	03b600        	rsr.epc6	a0
    wsr     a0,EPC_1
40376c28:	13b100        	wsr.epc1	a0
    rsr     a0,(EXCSAVE + XCHAL_DEBUGLEVEL)
40376c2b:	03d600        	rsr.excsave6	a0
    wsr     a0,EXCSAVE_1
40376c2e:	13d100        	wsr.excsave1	a0
    call0   _xt_panic                       /* does not return */
40376c31:	0107c5        	call0	40377cb0 <_xt_panic>
    rfi     XCHAL_DEBUGLEVEL
40376c34:	003610        	rfi	6
	...

40376c38 <_xt_kernel_exc>:
    break   1, 0                            /* unhandled kernel exception */
40376c38:	004100        	break	1, 0
    movi    a0,PANIC_RSN_KERNELEXCEPTION
40376c3b:	300c      	movi.n	a0, 3
    wsr     a0,EXCCAUSE
40376c3d:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
40376c40:	0106c5        	call0	40377cb0 <_xt_panic>
    rfe                                     /* make a0 point here not there */
40376c43:	003000        	rfe
	...

40376c48 <_xt_to_alloca_exc>:
    call0   _xt_alloca_exc                  /* in window vectors section */
40376c48:	201110        	or	a1, a1, a1
40376c4b:	fd4045        	call0	40374050 <_xt_alloca_exc>
	...

40376c50 <_xt_to_syscall_exc>:
    call0   _xt_syscall_exc
40376c50:	000b45        	call0	40376d08 <_xt_syscall_exc>
	...

40376c54 <_xt_to_coproc_exc>:
    call0   _xt_coproc_exc
40376c54:	000f85        	call0	40376d50 <_xt_coproc_exc>
	...

40376c58 <_xt_user_exc>:
    rsr     a0, EXCCAUSE
40376c58:	03e800        	rsr.exccause	a0
    bnei    a0, EXCCAUSE_LEVEL1INTERRUPT, _xt_handle_exc
40376c5b:	024066        	bnei	a0, 4, 40376c61 <_xt_handle_exc>
    j       _xt_lowint1
40376c5e:	00e386        	j	40376ff0 <_xt_lowint1>

40376c61 <_xt_handle_exc>:
    bgeui   a0, EXCCAUSE_CP0_DISABLED, _xt_to_coproc_exc
40376c61:	efc0f6        	bgeui	a0, 32, 40376c54 <_xt_to_coproc_exc>
    beqi    a0, EXCCAUSE_ALLOCA,  _xt_to_alloca_exc
40376c64:	e05026        	beqi	a0, 5, 40376c48 <_xt_to_alloca_exc>
    beqi    a0, EXCCAUSE_SYSCALL, _xt_to_syscall_exc
40376c67:	e51026        	beqi	a0, 1, 40376c50 <_xt_to_syscall_exc>
    mov     a0, sp
40376c6a:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ
40376c6d:	ffd112        	addmi	a1, a1, 0xffffff00
40376c70:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40376c73:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
40376c76:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376c79:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376c7c:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376c7e:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376c81:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376c83:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376c86:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376c88:	49c100        	s32e	a0, a1, -16
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40376c8b:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376c8e:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376c91:	0b4b45        	call0	40382148 <_xt_context_save>
    rsr     a0, EXCCAUSE
40376c94:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40376c97:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40376c9a:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40376c9d:	156102        	s32i	a0, a1, 84
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
40376ca0:	f6ad01        	l32r	a0, 40374754 <_iram_text_start+0x350> (40024 <UserFrameTotalSize+0x3ff24>)
    wsr     a0, PS
40376ca3:	13e600        	wsr.ps	a0
    l32i    a3, sp, XT_STK_A0               /* Copy pre-exception a0 (return address) */
40376ca6:	3138      	l32i.n	a3, a1, 12
    s32e    a3, sp, -16
40376ca8:	49c130        	s32e	a3, a1, -16
    l32i    a3, sp, XT_STK_A1               /* Copy pre-exception a1 (stack pointer) */
40376cab:	4138      	l32i.n	a3, a1, 16
    s32e    a3, sp, -12
40376cad:	49d130        	s32e	a3, a1, -12
    rsr     a0, EPC_1                       /* return address for debug backtrace */
40376cb0:	03b100        	rsr.epc1	a0
    movi    a5, 0xC0000000                  /* constant with top 2 bits set (call size) */
40376cb3:	f6a951        	l32r	a5, 40374758 <_iram_text_start+0x354> (c0000000 <_rtc_reserved_end+0x5ff00000>)
    rsync                                   /* wait for WSR.PS to complete */
40376cb6:	002010        	rsync
    or      a0, a0, a5                      /* set top 2 bits */
40376cb9:	200050        	or	a0, a0, a5
    addx2   a0, a5, a0                      /* clear top bit -- thus simulating call4 size */
40376cbc:	900500        	addx2	a0, a5, a0
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376cbf:	03e820        	rsr.exccause	a2
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376cc2:	03e820        	rsr.exccause	a2
    movi    a3, _xt_exception_table
40376cc5:	f6a531        	l32r	a3, 4037475c <_iram_text_start+0x358> (3fc927c0 <_xt_exception_table>)
    get_percpu_entry_for a2, a4
40376cc8:	03eb40        	rsr.prid	a4
40376ccb:	044d40        	extui	a4, a4, 13, 1
40376cce:	902240        	addx2	a2, a2, a4
    addx4   a4, a2, a3                      /* a4 = address of exception table entry */
40376cd1:	a04230        	addx4	a4, a2, a3
    l32i    a4, a4, 0                       /* a4 = handler address */
40376cd4:	0448      	l32i.n	a4, a4, 0
    mov     a6, sp                          /* a6 = pointer to exc frame */
40376cd6:	016d      	mov.n	a6, a1
    callx4  a4                              /* call handler */
40376cd8:	0004d0        	callx4	a4
    call0   _xt_context_restore
40376cdb:	0b5105        	call0	403821ec <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376cde:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376ce0:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376ce3:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376ce5:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376ce8:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
40376cea:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40376cec:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
40376cef:	003000        	rfe
	...

40376cf4 <_xt_user_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376cf4:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376cf6:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376cf9:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376cfb:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376cfe:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40376d00:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40376d02:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
40376d05:	003000        	rfe

40376d08 <_xt_syscall_exc>:
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376d08:	ffd112        	addmi	a1, a1, 0xffffff00
40376d0b:	40c112        	addi	a1, a1, 64
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40376d0e:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376d11:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376d14:	0b4305        	call0	40382148 <_xt_context_save>
    rsr     a2, EPC_1                       /* a2 = PC of 'syscall' */
40376d17:	03b120        	rsr.epc1	a2
    addi    a3, a2, 3                       /* ++PC                 */
40376d1a:	03c232        	addi	a3, a2, 3
    rsr     a0, LEND                        /* if (PC == LEND       */
40376d1d:	030100        	rsr.lend	a0
    bne     a3, a0, 1f
40376d20:	0d9307        	bne	a3, a0, 40376d31 <_xt_syscall_exc+0x29>
    rsr     a0, LCOUNT                      /*     && LCOUNT != 0)  */
40376d23:	030200        	rsr.lcount	a0
    beqz    a0, 1f                          /* {                    */
40376d26:	007016        	beqz	a0, 40376d31 <_xt_syscall_exc+0x29>
    addi    a0, a0, -1                      /*   --LCOUNT           */
40376d29:	000b      	addi.n	a0, a0, -1
    rsr     a3, LBEG                        /*   PC = LBEG          */
40376d2b:	030030        	rsr.lbeg	a3
    wsr     a0, LCOUNT                      /* }                    */
40376d2e:	130200        	wsr.lcount	a0
1:  wsr     a3, EPC_1                       /* update PC            */
40376d31:	13b130        	wsr.epc1	a3
    call0   _xt_context_restore
40376d34:	0b4b45        	call0	403821ec <_xt_context_restore>
    addi    sp, sp, XT_STK_FRMSZ
40376d37:	01d112        	addmi	a1, a1, 0x100
40376d3a:	c0c112        	addi	a1, a1, -64
    movi    a0, -1
40376d3d:	f07c      	movi.n	a0, -1
    movnez  a2, a0, a2                      /* return -1 if not syscall 0 */
40376d3f:	932020        	movnez	a2, a0, a2
    rsr     a0, EXCSAVE_1
40376d42:	03d100        	rsr.excsave1	a0
    rfe
40376d45:	003000        	rfe
    j   .L_xt_coproc_invalid    /* not in a thread (invalid) */
40376d48:	00a646        	j	40376fe5 <_xt_coproc_exc+0x295>
40376d4b:	00          	.byte	00
    j   .L_xt_coproc_done
40376d4c:	009806        	j	40376fb0 <_xt_coproc_exc+0x260>
	...

40376d50 <_xt_coproc_exc>:
    mov     a0, sp                          /* sp == a1 */
40376d50:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376d53:	ffd112        	addmi	a1, a1, 0xffffff00
40376d56:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376d59:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
40376d5c:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376d5f:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376d62:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376d64:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376d67:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376d69:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376d6c:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376d6e:	49c100        	s32e	a0, a1, -16
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
40376d71:	f67b01        	l32r	a0, 40374760 <_iram_text_start+0x35c> (40376cf4 <_xt_user_exit>)
    s32i    a0, sp, XT_STK_EXIT
40376d74:	0109      	s32i.n	a0, a1, 0
    rsr     a0, EXCCAUSE
40376d76:	03e800        	rsr.exccause	a0
    s32i    a5, sp, XT_STK_A5               /* save a5 */
40376d79:	8159      	s32i.n	a5, a1, 32
    addi    a5, a0, -EXCCAUSE_CP0_DISABLED  /* a5 = CP index */
40376d7b:	e0c052        	addi	a5, a0, -32
    s32i    a2,  sp, XT_STK_A2
40376d7e:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
40376d80:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
40376d82:	7149      	s32i.n	a4, a1, 28
    s32i    a6,  sp, XT_STK_A6
40376d84:	096162        	s32i	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40376d87:	a179      	s32i.n	a7, a1, 40
    s32i    a15, sp, XT_STK_A15
40376d89:	1261f2        	s32i	a15, a1, 72
    call0   XT_RTOS_CP_EXC_HOOK
40376d8c:	036b85        	call0	4037a448 <_frxt_coproc_exc_hook>
    call0   XT_RTOS_CP_STATE                /* a15 = new owner's save area */
40376d8f:	036785        	call0	4037a408 <_frxt_task_coproc_state>
    beqz    a15, .L_goto_invalid            /* not in a thread (invalid) */
40376d92:	fb2f16        	beqz	a15, 40376d48 <_xt_syscall_exc+0x40>
    movi    a0, _xt_coproc_mask
40376d95:	f67301        	l32r	a0, 40374764 <_iram_text_start+0x360> (3c027700 <_xt_coproc_mask>)
    rsr     a4, CPENABLE                    /* a4 = CPENABLE */
40376d98:	03e040        	rsr.cpenable	a4
    addx4   a0, a5, a0                      /* a0 = &_xt_coproc_mask[n] */
40376d9b:	a00500        	addx4	a0, a5, a0
    l32i    a0, a0, 0                       /* a0 = (n << 16) | (1 << n) */
40376d9e:	0008      	l32i.n	a0, a0, 0
    extui   a2, a0, 0, 16                   /* coprocessor bitmask portion */
40376da0:	f42000        	extui	a2, a0, 0, 16
    or      a4, a4, a2                      /* a4 = CPENABLE | (1 << n) */
40376da3:	204420        	or	a4, a4, a2
    wsr     a4, CPENABLE
40376da6:	13e040        	wsr.cpenable	a4
    getcoreid a3                            /* a3 = current core ID */
40376da9:	03eb30        	rsr.prid	a3
40376dac:	043d30        	extui	a3, a3, 13, 1
    movi    a2, XCHAL_CP_MAX << 2           /* a2 = size of an owner array */
40376daf:	021c      	movi.n	a2, 16
    mull    a2, a2, a3                      /* a2 = offset to the owner array of the current core*/
40376db1:	822230        	mull	a2, a2, a3
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of all owner arrays */
40376db4:	f66d31        	l32r	a3, 40374768 <_iram_text_start+0x364> (3fc929c0 <_xt_coproc_owner_sa>)
    add     a3, a3, a2                      /* a3 = base of owner array of the current core */
40376db7:	332a      	add.n	a3, a3, a2
    spinlock_take a6 a7 _xt_coproc_owner_sa_lock
40376db9:	f66c61        	l32r	a6, 4037476c <_iram_text_start+0x368> (3fc929e0 <_xt_coproc_owner_sa_lock>)
40376dbc:	070c      	movi.n	a7, 0
40376dbe:	130c70        	wsr.scompare1	a7
40376dc1:	002010        	rsync
40376dc4:	03eb70        	rsr.prid	a7
40376dc7:	00e672        	s32c1i	a7, a6, 0
40376dca:	fee756        	bnez	a7, 40376dbc <_xt_coproc_exc+0x6c>
    addx4   a3,  a5, a3                      /* a3 = &_xt_coproc_owner_sa[n] */
40376dcd:	a03530        	addx4	a3, a5, a3
    l32i    a2,  a3, 0                       /* a2 = old owner's save area */
40376dd0:	0328      	l32i.n	a2, a3, 0
    s32i    a15, a3, 0                       /* _xt_coproc_owner_sa[n] = new */
40376dd2:	03f9      	s32i.n	a15, a3, 0
    rsync                                    /* ensure wsr.CPENABLE is complete */
40376dd4:	002010        	rsync
    spinlock_release a6 a7 _xt_coproc_owner_sa_lock
40376dd7:	f66561        	l32r	a6, 4037476c <_iram_text_start+0x368> (3fc929e0 <_xt_coproc_owner_sa_lock>)
40376dda:	070c      	movi.n	a7, 0
40376ddc:	0679      	s32i.n	a7, a6, 0
    bne     a15, a2, .L_switch_context
40376dde:	029f27        	bne	a15, a2, 40376de4 <_xt_coproc_exc+0x94>
    j    .L_goto_done                       /* new owner == old, we're done */
40376de1:	ffd9c6        	j	40376d4c <_xt_syscall_exc+0x44>
    beqz    a2, .L_check_new
40376de4:	0e8216        	beqz	a2, 40376ed0 <_xt_coproc_exc+0x180>
    l16ui   a4,  a2,  XT_CPENABLE           /* a4 = old owner's CPENABLE */
40376de7:	001242        	l16ui	a4, a2, 0
    bnone   a4,  a0,  .L_check_new          /* old owner not using CP    */
40376dea:	028407        	bany	a4, a0, 40376df0 <_xt_coproc_exc+0xa0>
40376ded:	0037c6        	j	40376ed0 <_xt_coproc_exc+0x180>
    movi    a5, _xt_coproc_sa_offset
40376df0:	f66051        	l32r	a5, 40374770 <_iram_text_start+0x36c> (3c0276e0 <_xt_coproc_sa_offset>)
    xor     a4,  a4,  a0                    /* clear CP bit in CPENABLE    */
40376df3:	304400        	xor	a4, a4, a0
    s16i    a4,  a2,  XT_CPENABLE           /* update old owner's CPENABLE */
40376df6:	005242        	s16i	a4, a2, 0
    extui   a4,  a0,  16,  5                /* a4 = CP index = n */
40376df9:	454000        	extui	a4, a0, 16, 5
    addx4   a5,  a4,  a5                    /* a5 = &_xt_coproc_sa_offset[n] */
40376dfc:	a05450        	addx4	a5, a4, a5
    l16ui   a4,  a2,  XT_CPSTORED           /* a4 = old owner's CPSTORED */
40376dff:	011242        	l16ui	a4, a2, 2
    l32i    a5,  a5,  0                     /* a5 = XT_CP[n]_SA offset */
40376e02:	0558      	l32i.n	a5, a5, 0
    or      a4,  a4,  a0                    /* set CP in old owner's CPSTORED */
40376e04:	204400        	or	a4, a4, a0
    s16i    a4,  a2,  XT_CPSTORED           /* update old owner's CPSTORED */
40376e07:	015242        	s16i	a4, a2, 2
    l32i    a2, a2, XT_CP_ASA               /* ptr to actual (aligned) save area */
40376e0a:	2228      	l32i.n	a2, a2, 8
    extui   a3, a0, 16, 5                   /* a3 = CP index = n */
40376e0c:	453000        	extui	a3, a0, 16, 5
    add     a2, a2, a5                      /* a2 = old owner's area for CP n */
40376e0f:	225a      	add.n	a2, a2, a5
    xchal_cpi_store_funcbody
40376e11:	b3fc      	bnez.n	a3, 40376e50 <_xt_coproc_exc+0x100>
40376e13:	e33e80        	rur.fcr	a3
40376e16:	0239      	s32i.n	a3, a2, 0
40376e18:	e33e90        	rur.fsr	a3
40376e1b:	1239      	s32i.n	a3, a2, 4
40376e1d:	024203        	ssi	f0, a2, 8
40376e20:	034213        	ssi	f1, a2, 12
40376e23:	044223        	ssi	f2, a2, 16
40376e26:	054233        	ssi	f3, a2, 20
40376e29:	064243        	ssi	f4, a2, 24
40376e2c:	074253        	ssi	f5, a2, 28
40376e2f:	084263        	ssi	f6, a2, 32
40376e32:	094273        	ssi	f7, a2, 36
40376e35:	0a4283        	ssi	f8, a2, 40
40376e38:	0b4293        	ssi	f9, a2, 44
40376e3b:	0c42a3        	ssi	f10, a2, 48
40376e3e:	0d42b3        	ssi	f11, a2, 52
40376e41:	0e42c3        	ssi	f12, a2, 56
40376e44:	0f42d3        	ssi	f13, a2, 60
40376e47:	1042e3        	ssi	f14, a2, 64
40376e4a:	1142f3        	ssi	f15, a2, 68
40376e4d:	001fc6        	j	40376ed0 <_xt_coproc_exc+0x180>
40376e50:	7c3366        	bnei	a3, 3, 40376ed0 <_xt_coproc_exc+0x180>
40376e53:	e33000        	rur.accx_0	a3
40376e56:	0239      	s32i.n	a3, a2, 0
40376e58:	e33010        	rur.accx_1	a3
40376e5b:	1239      	s32i.n	a3, a2, 4
40376e5d:	e33020        	rur.qacc_h_0	a3
40376e60:	2239      	s32i.n	a3, a2, 8
40376e62:	e33030        	rur.qacc_h_1	a3
40376e65:	3239      	s32i.n	a3, a2, 12
40376e67:	e33040        	rur.qacc_h_2	a3
40376e6a:	4239      	s32i.n	a3, a2, 16
40376e6c:	e33050        	rur.qacc_h_3	a3
40376e6f:	5239      	s32i.n	a3, a2, 20
40376e71:	e33060        	rur.qacc_h_4	a3
40376e74:	6239      	s32i.n	a3, a2, 24
40376e76:	e33070        	rur.qacc_l_0	a3
40376e79:	7239      	s32i.n	a3, a2, 28
40376e7b:	e33080        	rur.qacc_l_1	a3
40376e7e:	8239      	s32i.n	a3, a2, 32
40376e80:	e33090        	rur.qacc_l_2	a3
40376e83:	9239      	s32i.n	a3, a2, 36
40376e85:	e330a0        	rur.qacc_l_3	a3
40376e88:	a239      	s32i.n	a3, a2, 40
40376e8a:	e330b0        	rur.qacc_l_4	a3
40376e8d:	b239      	s32i.n	a3, a2, 44
40376e8f:	e330d0        	rur.sar_byte	a3
40376e92:	c239      	s32i.n	a3, a2, 48
40376e94:	e330e0        	rur.fft_bit_width	a3
40376e97:	d239      	s32i.n	a3, a2, 52
40376e99:	e330f0        	rur.ua_state_0	a3
40376e9c:	e239      	s32i.n	a3, a2, 56
40376e9e:	e33100        	rur.ua_state_1	a3
40376ea1:	f239      	s32i.n	a3, a2, 60
40376ea3:	e33110        	rur.ua_state_2	a3
40376ea6:	106232        	s32i	a3, a2, 64
40376ea9:	e33120        	rur.ua_state_3	a3
40376eac:	116232        	s32i	a3, a2, 68
40376eaf:	cd6524        	st.qr	q0, a2, 80
40376eb2:	cde624        	st.qr	q1, a2, 96
40376eb5:	dd6724        	st.qr	q2, a2, 112
40376eb8:	01d222        	addmi	a2, a2, 0x100
40376ebb:	80c222        	addi	a2, a2, -128
40376ebe:	dde024        	st.qr	q3, a2, 0
40376ec1:	ed6124        	st.qr	q4, a2, 16
40376ec4:	ede224        	st.qr	q5, a2, 32
40376ec7:	fd6324        	st.qr	q6, a2, 48
40376eca:	fde424        	st.qr	q7, a2, 64
40376ecd:	ffffc6        	j	40376ed0 <_xt_coproc_exc+0x180>
    beqz    a15, .L_xt_coproc_done
40376ed0:	0dcf16        	beqz	a15, 40376fb0 <_xt_coproc_exc+0x260>
    l16ui   a3,  a15, XT_CPSTORED           /* a3 = new owner's CPSTORED */
40376ed3:	011f32        	l16ui	a3, a15, 2
    movi    a4, _xt_coproc_sa_offset
40376ed6:	f62641        	l32r	a4, 40374770 <_iram_text_start+0x36c> (3c0276e0 <_xt_coproc_sa_offset>)
    bnone   a3,  a0,  .L_check_cs           /* full CP not saved, check callee-saved */
40376ed9:	028307        	bany	a3, a0, 40376edf <_xt_coproc_exc+0x18f>
40376edc:	003906        	j	40376fc4 <_xt_coproc_exc+0x274>
    xor     a3,  a3,  a0                    /* CPSTORED bit is set, clear it */
40376edf:	303300        	xor	a3, a3, a0
    s16i    a3,  a15, XT_CPSTORED           /* update new owner's CPSTORED */
40376ee2:	015f32        	s16i	a3, a15, 2
    extui   a3,  a0, 16, 5                  /* a3 = CP index = n */
40376ee5:	453000        	extui	a3, a0, 16, 5
    addx4   a4,  a3, a4                     /* a4 = &_xt_coproc_sa_offset[n] */
40376ee8:	a04340        	addx4	a4, a3, a4
    l32i    a4,  a4, 0                      /* a4 = XT_CP[n]_SA */
40376eeb:	0448      	l32i.n	a4, a4, 0
    l32i    a5, a15, XT_CP_ASA              /* ptr to actual (aligned) save area */
40376eed:	2f58      	l32i.n	a5, a15, 8
    add     a2,  a4, a5                     /* a2 = new owner's area for CP */
40376eef:	245a      	add.n	a2, a4, a5
    xchal_cpi_load_funcbody
40376ef1:	b3fc      	bnez.n	a3, 40376f30 <_xt_coproc_exc+0x1e0>
40376ef3:	0238      	l32i.n	a3, a2, 0
40376ef5:	f3e830        	wur.fcr	a3
40376ef8:	1238      	l32i.n	a3, a2, 4
40376efa:	f3e930        	wur.fsr	a3
40376efd:	020203        	lsi	f0, a2, 8
40376f00:	030213        	lsi	f1, a2, 12
40376f03:	040223        	lsi	f2, a2, 16
40376f06:	050233        	lsi	f3, a2, 20
40376f09:	060243        	lsi	f4, a2, 24
40376f0c:	070253        	lsi	f5, a2, 28
40376f0f:	080263        	lsi	f6, a2, 32
40376f12:	090273        	lsi	f7, a2, 36
40376f15:	0a0283        	lsi	f8, a2, 40
40376f18:	0b0293        	lsi	f9, a2, 44
40376f1b:	0c02a3        	lsi	f10, a2, 48
40376f1e:	0d02b3        	lsi	f11, a2, 52
40376f21:	0e02c3        	lsi	f12, a2, 56
40376f24:	0f02d3        	lsi	f13, a2, 60
40376f27:	1002e3        	lsi	f14, a2, 64
40376f2a:	1102f3        	lsi	f15, a2, 68
40376f2d:	001fc6        	j	40376fb0 <_xt_coproc_exc+0x260>
40376f30:	7c3366        	bnei	a3, 3, 40376fb0 <_xt_coproc_exc+0x260>
40376f33:	0238      	l32i.n	a3, a2, 0
40376f35:	f30030        	wur.accx_0	a3
40376f38:	1238      	l32i.n	a3, a2, 4
40376f3a:	f30130        	wur.accx_1	a3
40376f3d:	2238      	l32i.n	a3, a2, 8
40376f3f:	f30230        	wur.qacc_h_0	a3
40376f42:	3238      	l32i.n	a3, a2, 12
40376f44:	f30330        	wur.qacc_h_1	a3
40376f47:	4238      	l32i.n	a3, a2, 16
40376f49:	f30430        	wur.qacc_h_2	a3
40376f4c:	5238      	l32i.n	a3, a2, 20
40376f4e:	f30530        	wur.qacc_h_3	a3
40376f51:	6238      	l32i.n	a3, a2, 24
40376f53:	f30630        	wur.qacc_h_4	a3
40376f56:	7238      	l32i.n	a3, a2, 28
40376f58:	f30730        	wur.qacc_l_0	a3
40376f5b:	8238      	l32i.n	a3, a2, 32
40376f5d:	f30830        	wur.qacc_l_1	a3
40376f60:	9238      	l32i.n	a3, a2, 36
40376f62:	f30930        	wur.qacc_l_2	a3
40376f65:	a238      	l32i.n	a3, a2, 40
40376f67:	f30a30        	wur.qacc_l_3	a3
40376f6a:	b238      	l32i.n	a3, a2, 44
40376f6c:	f30b30        	wur.qacc_l_4	a3
40376f6f:	c238      	l32i.n	a3, a2, 48
40376f71:	f30d30        	wur.sar_byte	a3
40376f74:	d238      	l32i.n	a3, a2, 52
40376f76:	f30e30        	wur.fft_bit_width	a3
40376f79:	e238      	l32i.n	a3, a2, 56
40376f7b:	f30f30        	wur.ua_state_0	a3
40376f7e:	f238      	l32i.n	a3, a2, 60
40376f80:	f31030        	wur.ua_state_1	a3
40376f83:	102232        	l32i	a3, a2, 64
40376f86:	f31130        	wur.ua_state_2	a3
40376f89:	112232        	l32i	a3, a2, 68
40376f8c:	f31230        	wur.ua_state_3	a3
40376f8f:	cd2524        	ld.qr	q0, a2, 80
40376f92:	cda624        	ld.qr	q1, a2, 96
40376f95:	dd2724        	ld.qr	q2, a2, 112
40376f98:	01d222        	addmi	a2, a2, 0x100
40376f9b:	80c222        	addi	a2, a2, -128
40376f9e:	dda024        	ld.qr	q3, a2, 0
40376fa1:	ed2124        	ld.qr	q4, a2, 16
40376fa4:	eda224        	ld.qr	q5, a2, 32
40376fa7:	fd2324        	ld.qr	q6, a2, 48
40376faa:	fda424        	ld.qr	q7, a2, 64
40376fad:	ffffc6        	j	40376fb0 <_xt_coproc_exc+0x260>
    l32i    a15, sp, XT_STK_A15
40376fb0:	1221f2        	l32i	a15, a1, 72
    l32i    a6,  sp, XT_STK_A6
40376fb3:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40376fb5:	a178      	l32i.n	a7, a1, 40
    l32i    a5,  sp, XT_STK_A5
40376fb7:	8158      	l32i.n	a5, a1, 32
    l32i    a4,  sp, XT_STK_A4
40376fb9:	7148      	l32i.n	a4, a1, 28
    l32i    a3,  sp, XT_STK_A3
40376fbb:	062132        	l32i	a3, a1, 24
    l32i    a2,  sp, XT_STK_A2
40376fbe:	052122        	l32i	a2, a1, 20
    call0   _xt_user_exit                   /* return via exit dispatcher */
40376fc1:	ffd305        	call0	40376cf4 <_xt_user_exit>
    l16ui   a2, a15, XT_CP_CS_ST            /* a2 = mask of CPs saved    */
40376fc4:	021f22        	l16ui	a2, a15, 4
    bnone   a2,  a0, .L_xt_coproc_done      /* if no match then done     */
40376fc7:	e50207        	bnone	a2, a0, 40376fb0 <_xt_coproc_exc+0x260>
    and     a2,  a2, a0                     /* a2 = which CPs to restore */
40376fca:	102200        	and	a2, a2, a0
    extui   a2,  a2, 0, 8                   /* extract low 8 bits        */
40376fcd:	742020        	extui	a2, a2, 0, 8
    s32i    a13, sp, XT_STK_A13
40376fd0:	1061d2        	s32i	a13, a1, 64
    s32i    a14, sp, XT_STK_A14
40376fd3:	1161e2        	s32i	a14, a1, 68
    call0   _xt_coproc_restorecs            /* restore CP registers      */
40376fd6:	0b2dc5        	call0	403822b4 <_xt_coproc_restorecs>
    l32i    a13, sp, XT_STK_A13
40376fd9:	1021d2        	l32i	a13, a1, 64
    l32i    a14, sp, XT_STK_A14
40376fdc:	1121e2        	l32i	a14, a1, 68
    j       .L_xt_coproc_done
40376fdf:	fff346        	j	40376fb0 <_xt_coproc_exc+0x260>
40376fe2:	000000        	ill
    movi    a0,PANIC_RSN_COPROCEXCEPTION
40376fe5:	400c      	movi.n	a0, 4
    wsr     a0,EXCCAUSE
40376fe7:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* not in a thread (invalid) */
40376fea:	201110        	or	a1, a1, a1
40376fed:	00cc05        	call0	40377cb0 <_xt_panic>

40376ff0 <_xt_lowint1>:
    mov     a0, sp                          /* sp == a1 */
40376ff0:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376ff3:	ffd112        	addmi	a1, a1, 0xffffff00
40376ff6:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376ff9:	046102        	s32i	a0, a1, 16
    rsr     a0, PS                          /* save interruptee's PS */
40376ffc:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376fff:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40377002:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40377005:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40377007:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
4037700a:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
4037700c:	f5d501        	l32r	a0, 40374760 <_iram_text_start+0x35c> (40376cf4 <_xt_user_exit>)
    s32i    a0, sp, XT_STK_EXIT
4037700f:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40377011:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_1
40377013:	13d100        	wsr.excsave1	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40377016:	032605        	call0	4037a278 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(1) | PS_UM | PS_WOE
40377019:	f5d601        	l32r	a0, 40374774 <_iram_text_start+0x370> (40021 <UserFrameTotalSize+0x3ff21>)
    wsr     a0, PS
4037701c:	13e600        	wsr.ps	a0
    rsync
4037701f:	002010        	rsync
    dispatch_c_isr 1 XCHAL_INTLEVEL1_MASK
40377022:	03e420        	rsr.intenable	a2
40377025:	03e230        	rsr.interrupt	a3
40377028:	f5d441        	l32r	a4, 40374778 <_iram_text_start+0x374> (637ff <UserFrameTotalSize+0x636ff>)
4037702b:	102230        	and	a2, a2, a3
4037702e:	102240        	and	a2, a2, a4
40377031:	04f216        	beqz	a2, 40377084 <_xt_lowint1+0x94>
40377034:	03d100        	rsr.excsave1	a0
40377037:	3038      	l32i.n	a3, a0, 12
40377039:	49c130        	s32e	a3, a1, -16
4037703c:	4038      	l32i.n	a3, a0, 16
4037703e:	49d130        	s32e	a3, a1, -12
40377041:	03b100        	rsr.epc1	a0
40377044:	f5c541        	l32r	a4, 40374758 <_iram_text_start+0x354> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377047:	200040        	or	a0, a0, a4
4037704a:	900400        	addx2	a0, a4, a0
4037704d:	420b      	addi.n	a4, a2, -1
4037704f:	102240        	and	a2, a2, a4
40377052:	ff7256        	bnez	a2, 4037704d <_xt_lowint1+0x5d>
40377055:	441b      	addi.n	a4, a4, 1
40377057:	13e340        	wsr.intclear	a4
4037705a:	f31c      	movi.n	a3, 31
4037705c:	40f440        	nsau	a4, a4
4037705f:	c03340        	sub	a3, a3, a4
40377062:	03ebc0        	rsr.prid	a12
40377065:	04cdc0        	extui	a12, a12, 13, 1
40377068:	9033c0        	addx2	a3, a3, a12
4037706b:	f5c441        	l32r	a4, 4037477c <_iram_text_start+0x378> (3fc925c0 <_xt_interrupt_table>)
4037706e:	b03340        	addx8	a3, a3, a4
40377071:	0348      	l32i.n	a4, a3, 0
40377073:	202660        	or	a2, a6, a6
40377076:	012362        	l32i	a6, a3, 4
40377079:	0004d0        	callx4	a4
4037707c:	ffe886        	j	40377022 <_xt_lowint1+0x32>
4037707f:	460000        	ee.ldf.64.xp	f0, f4, a0, a0
40377082:	10ffe7        	bbsi	a15, 30, 40377096 <_xt_medint2+0xa>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40377085:	452011        	l32r	a1, 40348508 <rom_rx_gain_force+0x3420dc>
40377088:	000323        	lsi	f2, a3, 0
	...

4037708c <_xt_medint2>:
    mov     a0, sp                          /* sp == a1 */
4037708c:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
4037708f:	ffd112        	addmi	a1, a1, 0xffffff00
40377092:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40377095:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_2                       /* save interruptee's PS */
40377098:	03c200        	rsr.eps2	a0
    s32i    a0, sp, XT_STK_PS
4037709b:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_2                       /* save interruptee's PC */
4037709e:	03b200        	rsr.epc2	a0
    s32i    a0, sp, XT_STK_PC
403770a1:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_2                   /* save interruptee's a0 */
403770a3:	03d200        	rsr.excsave2	a0
    s32i    a0, sp, XT_STK_A0
403770a6:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint2_exit            /* save exit point for dispatch */
403770a8:	f5b601        	l32r	a0, 40374780 <_iram_text_start+0x37c> (40377128 <_xt_medint2_exit>)
    s32i    a0, sp, XT_STK_EXIT
403770ab:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
403770ad:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_2
403770af:	13d200        	wsr.excsave2	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
403770b2:	031c45        	call0	4037a278 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(2) | PS_UM | PS_WOE
403770b5:	f5b301        	l32r	a0, 40374784 <_iram_text_start+0x380> (40022 <UserFrameTotalSize+0x3ff22>)
    wsr     a0, PS
403770b8:	13e600        	wsr.ps	a0
    rsync
403770bb:	002010        	rsync
    dispatch_c_isr 2 XCHAL_INTLEVEL2_MASK
403770be:	03e420        	rsr.intenable	a2
403770c1:	03e230        	rsr.interrupt	a3
403770c4:	f5b141        	l32r	a4, 40374788 <_iram_text_start+0x384> (380000 <UserFrameTotalSize+0x37ff00>)
403770c7:	102230        	and	a2, a2, a3
403770ca:	102240        	and	a2, a2, a4
403770cd:	04f216        	beqz	a2, 40377120 <_xt_medint2+0x94>
403770d0:	03d200        	rsr.excsave2	a0
403770d3:	3038      	l32i.n	a3, a0, 12
403770d5:	49c130        	s32e	a3, a1, -16
403770d8:	4038      	l32i.n	a3, a0, 16
403770da:	49d130        	s32e	a3, a1, -12
403770dd:	03b200        	rsr.epc2	a0
403770e0:	f59e41        	l32r	a4, 40374758 <_iram_text_start+0x354> (c0000000 <_rtc_reserved_end+0x5ff00000>)
403770e3:	200040        	or	a0, a0, a4
403770e6:	900400        	addx2	a0, a4, a0
403770e9:	420b      	addi.n	a4, a2, -1
403770eb:	102240        	and	a2, a2, a4
403770ee:	ff7256        	bnez	a2, 403770e9 <_xt_medint2+0x5d>
403770f1:	441b      	addi.n	a4, a4, 1
403770f3:	13e340        	wsr.intclear	a4
403770f6:	f31c      	movi.n	a3, 31
403770f8:	40f440        	nsau	a4, a4
403770fb:	c03340        	sub	a3, a3, a4
403770fe:	03ebc0        	rsr.prid	a12
40377101:	04cdc0        	extui	a12, a12, 13, 1
40377104:	9033c0        	addx2	a3, a3, a12
40377107:	f59d41        	l32r	a4, 4037477c <_iram_text_start+0x378> (3fc925c0 <_xt_interrupt_table>)
4037710a:	b03340        	addx8	a3, a3, a4
4037710d:	0348      	l32i.n	a4, a3, 0
4037710f:	202660        	or	a2, a6, a6
40377112:	012362        	l32i	a6, a3, 4
40377115:	0004d0        	callx4	a4
40377118:	ffe886        	j	403770be <_xt_medint2+0x32>
4037711b:	460000        	ee.ldf.64.xp	f0, f4, a0, a0
4037711e:	10ffe7        	bbsi	a15, 30, 40377132 <_xt_medint2_exit+0xa>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40377121:	852011        	l32r	a1, 403585a4 <rom_rx_gain_force+0x352178>
40377124:	0319      	s32i.n	a1, a3, 0
	...

40377128 <_xt_medint2_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40377128:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_2
4037712a:	13c200        	wsr.eps2	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
4037712d:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_2
4037712f:	13b200        	wsr.epc2	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40377132:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40377134:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
40377136:	002010        	rsync
    rfi     2
40377139:	003210        	rfi	2

4037713c <_xt_medint3>:
    mov     a0, sp                          /* sp == a1 */
4037713c:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
4037713f:	ffd112        	addmi	a1, a1, 0xffffff00
40377142:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40377145:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_3                       /* save interruptee's PS */
40377148:	03c300        	rsr.eps3	a0
    s32i    a0, sp, XT_STK_PS
4037714b:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_3                       /* save interruptee's PC */
4037714e:	03b300        	rsr.epc3	a0
    s32i    a0, sp, XT_STK_PC
40377151:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_3                   /* save interruptee's a0 */
40377153:	03d300        	rsr.excsave3	a0
    s32i    a0, sp, XT_STK_A0
40377156:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint3_exit            /* save exit point for dispatch */
40377158:	f58d01        	l32r	a0, 4037478c <_iram_text_start+0x388> (403771d8 <_xt_medint3_exit>)
    s32i    a0, sp, XT_STK_EXIT
4037715b:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
4037715d:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_3
4037715f:	13d300        	wsr.excsave3	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40377162:	031145        	call0	4037a278 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(3) | PS_UM | PS_WOE
40377165:	f58a01        	l32r	a0, 40374790 <_iram_text_start+0x38c> (40023 <UserFrameTotalSize+0x3ff23>)
    wsr     a0, PS
40377168:	13e600        	wsr.ps	a0
    rsync
4037716b:	002010        	rsync
    dispatch_c_isr 3 XCHAL_INTLEVEL3_MASK
4037716e:	03e420        	rsr.intenable	a2
40377171:	03e230        	rsr.interrupt	a3
40377174:	f58841        	l32r	a4, 40374794 <_iram_text_start+0x390> (28c08800 <UserFrameTotalSize+0x28c08700>)
40377177:	102230        	and	a2, a2, a3
4037717a:	102240        	and	a2, a2, a4
4037717d:	04f216        	beqz	a2, 403771d0 <_xt_medint3+0x94>
40377180:	03d300        	rsr.excsave3	a0
40377183:	3038      	l32i.n	a3, a0, 12
40377185:	49c130        	s32e	a3, a1, -16
40377188:	4038      	l32i.n	a3, a0, 16
4037718a:	49d130        	s32e	a3, a1, -12
4037718d:	03b300        	rsr.epc3	a0
40377190:	f57241        	l32r	a4, 40374758 <_iram_text_start+0x354> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377193:	200040        	or	a0, a0, a4
40377196:	900400        	addx2	a0, a4, a0
40377199:	420b      	addi.n	a4, a2, -1
4037719b:	102240        	and	a2, a2, a4
4037719e:	ff7256        	bnez	a2, 40377199 <_xt_medint3+0x5d>
403771a1:	441b      	addi.n	a4, a4, 1
403771a3:	13e340        	wsr.intclear	a4
403771a6:	f31c      	movi.n	a3, 31
403771a8:	40f440        	nsau	a4, a4
403771ab:	c03340        	sub	a3, a3, a4
403771ae:	03ebc0        	rsr.prid	a12
403771b1:	04cdc0        	extui	a12, a12, 13, 1
403771b4:	9033c0        	addx2	a3, a3, a12
403771b7:	f57141        	l32r	a4, 4037477c <_iram_text_start+0x378> (3fc925c0 <_xt_interrupt_table>)
403771ba:	b03340        	addx8	a3, a3, a4
403771bd:	0348      	l32i.n	a4, a3, 0
403771bf:	202660        	or	a2, a6, a6
403771c2:	012362        	l32i	a6, a3, 4
403771c5:	0004d0        	callx4	a4
403771c8:	ffe886        	j	4037716e <_xt_medint3+0x32>
403771cb:	ffe7c6        	j	4037716e <_xt_medint3+0x32>
403771ce:	100000        	and	a0, a0, a0
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
403771d1:	852011        	l32r	a1, 40358654 <rom_rx_gain_force+0x352228>
403771d4:	0000030e 	ee.vmulas.s16.accx.ld.ip.qup	q0, a0, 48, q0, q0, q0, q0

403771d8 <_xt_medint3_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
403771d8:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_3
403771da:	13c300        	wsr.eps3	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
403771dd:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_3
403771df:	13b300        	wsr.epc3	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
403771e2:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
403771e4:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
403771e6:	002010        	rsync
    rfi     3
403771e9:	003310        	rfi	3

403771ec <_xt_highint4>:
    rsr     a0, EXCSAVE_4                   /* restore a0 */
403771ec:	03d400        	rsr.excsave4	a0
    rfi     4
403771ef:	003410        	rfi	4
	...

403771f4 <xt_highint5>:
    rsr     a0, EXCSAVE_5                   /* restore a0 */
403771f4:	03d500        	rsr.excsave5	a0
    rfi     5
403771f7:	003510        	rfi	5
	...

403771fc <xt_nmi>:
    rsr     a0, EXCSAVE + XCHAL_NMILEVEL    /* restore a0 */
403771fc:	03d700        	rsr.excsave7	a0
    rfi     XCHAL_NMILEVEL
403771ff:	003710        	rfi	7
	...

40377204 <bootloader_flash_execute_command_common>:
    uint8_t command,
    uint32_t addr_len, uint32_t address,
    uint8_t dummy_len,
    uint8_t mosi_len, uint32_t mosi_data,
    uint8_t miso_len)
{
40377204:	00a136        	entry	a1, 80
40377207:	4179      	s32i.n	a7, a1, 16
40377209:	749020        	extui	a9, a2, 0, 8
4037720c:	745050        	extui	a5, a5, 0, 8
4037720f:	746060        	extui	a6, a6, 0, 8
40377212:	500122        	l8ui	a2, a1, 80
    assert(mosi_len <= 32);
40377215:	082c      	movi.n	a8, 32
40377217:	0eb867        	bgeu	a8, a6, 40377229 <bootloader_flash_execute_command_common+0x25>
4037721a:	f55fd1        	l32r	a13, 40374798 <_iram_text_start+0x394> (3c024c38 <_flash_rodata_start+0x4b18>)
4037721d:	f55fc1        	l32r	a12, 4037479c <_iram_text_start+0x398> (3c027710 <__func__$8>)
40377220:	03a3b2        	movi	a11, 0x303
40377223:	f55fa1        	l32r	a10, 403747a0 <_iram_text_start+0x39c> (3c024c81 <_flash_rodata_start+0x4b61>)
40377226:	08b025        	call8	4037fd28 <__assert_func>
    assert(miso_len <= 32);
40377229:	082c      	movi.n	a8, 32
4037722b:	0eb827        	bgeu	a8, a2, 4037723d <bootloader_flash_execute_command_common+0x39>
4037722e:	f55dd1        	l32r	a13, 403747a4 <_iram_text_start+0x3a0> (3c024c94 <_flash_rodata_start+0x4b74>)
40377231:	f55ac1        	l32r	a12, 4037479c <_iram_text_start+0x398> (3c027710 <__func__$8>)
40377234:	04a3b2        	movi	a11, 0x304
40377237:	f55aa1        	l32r	a10, 403747a0 <_iram_text_start+0x39c> (3c024c81 <_flash_rodata_start+0x4b61>)
4037723a:	08aee5        	call8	4037fd28 <__assert_func>
 * @param user1_reg user1_reg
 * @param user2_reg user2_reg
 */
static inline void spimem_flash_ll_get_common_command_register_info(spi_mem_dev_t *dev, uint32_t *ctrl_reg, uint32_t *user_reg, uint32_t *user1_reg, uint32_t *user2_reg)
{
    *ctrl_reg = dev->ctrl.val;
4037723d:	f55a81        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
40377240:	0020c0        	memw
40377243:	28a8      	l32i.n	a10, a8, 8
40377245:	51a9      	s32i.n	a10, a1, 20
    *user_reg = dev->user.val;
40377247:	0020c0        	memw
4037724a:	68a8      	l32i.n	a10, a8, 24
4037724c:	61a9      	s32i.n	a10, a1, 24
    *user1_reg = dev->user1.val;
4037724e:	0020c0        	memw
40377251:	78a8      	l32i.n	a10, a8, 28
40377253:	71a9      	s32i.n	a10, a1, 28
    *user2_reg = dev->user2.val;
40377255:	0020c0        	memw
40377258:	88a8      	l32i.n	a10, a8, 32
4037725a:	81a9      	s32i.n	a10, a1, 32
    uint32_t old_ctrl_reg = 0;
    uint32_t old_user_reg = 0;
    uint32_t old_user1_reg = 0;
    uint32_t old_user2_reg = 0;
    spi_flash_ll_get_common_command_register_info(&SPIMEM_LL_APB, &old_ctrl_reg, &old_user_reg, &old_user1_reg, &old_user2_reg);
    SPIMEM_LL_APB.ctrl.val = 0;
4037725c:	0a0c      	movi.n	a10, 0
4037725e:	0020c0        	memw
40377261:	28a9      	s32i.n	a10, a8, 8
    dev->ctrl.wp = level;
40377263:	0020c0        	memw
40377266:	28a8      	l32i.n	a10, a8, 8
40377268:	f551b1        	l32r	a11, 403747ac <_iram_text_start+0x3a8> (200000 <UserFrameTotalSize+0x1fff00>)
4037726b:	20aab0        	or	a10, a10, a11
4037726e:	0020c0        	memw
40377271:	28a9      	s32i.n	a10, a8, 8
    dev->user.usr_command = 1;
40377273:	0020c0        	memw
40377276:	68a8      	l32i.n	a10, a8, 24
40377278:	f54eb1        	l32r	a11, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037727b:	20aab0        	or	a10, a10, a11
4037727e:	0020c0        	memw
40377281:	68a9      	s32i.n	a10, a8, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
40377283:	0020c0        	memw
40377286:	88a8      	l32i.n	a10, a8, 32
40377288:	0020c0        	memw
4037728b:	21a9      	s32i.n	a10, a1, 8
4037728d:	0020c0        	memw
40377290:	21a8      	l32i.n	a10, a1, 8
40377292:	f5a0a0        	extui	a10, a10, 16, 16
40377295:	11aa00        	slli	a10, a10, 16
40377298:	2099a0        	or	a9, a9, a10
4037729b:	0020c0        	memw
4037729e:	2199      	s32i.n	a9, a1, 8
403772a0:	0020c0        	memw
403772a3:	2198      	l32i.n	a9, a1, 8
403772a5:	0020c0        	memw
403772a8:	8899      	s32i.n	a9, a8, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
403772aa:	0020c0        	memw
403772ad:	8898      	l32i.n	a9, a8, 32
403772af:	0020c0        	memw
403772b2:	1199      	s32i.n	a9, a1, 4
403772b4:	0020c0        	memw
403772b7:	1198      	l32i.n	a9, a1, 4
403772b9:	1199c0        	slli	a9, a9, 4
403772bc:	419490        	srli	a9, a9, 4
403772bf:	f53da1        	l32r	a10, 403747b4 <_iram_text_start+0x3b0> (70000000 <_rtc_reserved_end+0xff00000>)
403772c2:	2099a0        	or	a9, a9, a10
403772c5:	0020c0        	memw
403772c8:	1199      	s32i.n	a9, a1, 4
403772ca:	0020c0        	memw
403772cd:	1198      	l32i.n	a9, a1, 4
403772cf:	0020c0        	memw
403772d2:	8899      	s32i.n	a9, a8, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
403772d4:	e0c392        	addi	a9, a3, -32
403772d7:	0020c0        	memw
403772da:	f8a8      	l32i.n	a10, a8, 60
403772dc:	40f990        	nsau	a9, a9
403772df:	419590        	srli	a9, a9, 5
403772e2:	999a      	add.n	a9, a9, a9
403772e4:	db7c      	movi.n	a11, -3
403772e6:	10aab0        	and	a10, a10, a11
403772e9:	209a90        	or	a9, a10, a9
403772ec:	0020c0        	memw
403772ef:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
403772f1:	a30b      	addi.n	a10, a3, -1
403772f3:	0020c0        	memw
403772f6:	7898      	l32i.n	a9, a8, 28
403772f8:	01aa60        	slli	a10, a10, 26
403772fb:	1199a0        	slli	a9, a9, 6
403772fe:	419690        	srli	a9, a9, 6
40377301:	2099a0        	or	a9, a9, a10
40377304:	0020c0        	memw
40377307:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
40377309:	0020c0        	memw
4037730c:	6898      	l32i.n	a9, a8, 24
4037730e:	1a0c      	movi.n	a10, 1
40377310:	83a330        	moveqz	a10, a3, a3
40377313:	01aa20        	slli	a10, a10, 30
40377316:	f528b1        	l32r	a11, 403747b8 <_iram_text_start+0x3b4> (bfffffff <_rtc_reserved_end+0x5fefffff>)
40377319:	1099b0        	and	a9, a9, a11
4037731c:	2099a0        	or	a9, a9, a10
4037731f:	0020c0        	memw
40377322:	6899      	s32i.n	a9, a8, 24
    dev->addr = addr;
40377324:	0020c0        	memw
40377327:	1849      	s32i.n	a4, a8, 4
    spi_flash_ll_set_command(&SPIMEM_LL_APB, command, 8);
    //addr phase
    spi_flash_ll_set_addr_bitlen(&SPIMEM_LL_APB, addr_len);
    spi_flash_ll_set_usr_address(&SPIMEM_LL_APB, address, addr_len);
    //dummy phase
    uint32_t total_dummy = dummy_len;
40377329:	058d      	mov.n	a8, a5
    if (miso_len > 0) {
4037732b:	928c      	beqz.n	a2, 40377338 <bootloader_flash_execute_command_common+0x134>
        total_dummy += g_rom_spiflash_dummy_len_plus[1];
4037732d:	f52381        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40377330:	0888      	l32i.n	a8, a8, 0
40377332:	190882        	l8ui	a8, a8, 25
40377335:	808580        	add	a8, a5, a8
    dev->user.usr_dummy = dummy_n ? 1 : 0;
40377338:	f51cb1        	l32r	a11, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037733b:	0020c0        	memw
4037733e:	6b98      	l32i.n	a9, a11, 24
40377340:	1a0c      	movi.n	a10, 1
40377342:	83a880        	moveqz	a10, a8, a8
40377345:	01aa30        	slli	a10, a10, 29
40377348:	f51ec1        	l32r	a12, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037734b:	1099c0        	and	a9, a9, a12
4037734e:	2099a0        	or	a9, a9, a10
40377351:	0020c0        	memw
40377354:	6b99      	s32i.n	a9, a11, 24
    if (dummy_n > 0) {
40377356:	a89c      	beqz.n	a8, 40377374 <bootloader_flash_execute_command_common+0x170>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
40377358:	880b      	addi.n	a8, a8, -1
4037735a:	0bad      	mov.n	a10, a11
4037735c:	0020c0        	memw
4037735f:	072b92        	l32i	a9, a11, 28
40377362:	548080        	extui	a8, a8, 0, 6
40377365:	c0afb2        	movi	a11, -64
40377368:	1099b0        	and	a9, a9, a11
4037736b:	208980        	or	a8, a9, a8
4037736e:	0020c0        	memw
40377371:	076a82        	s32i	a8, a10, 28
    dev->user.usr_mosi = bitlen > 0;
40377374:	f50da1        	l32r	a10, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
40377377:	0020c0        	memw
4037737a:	6a88      	l32i.n	a8, a10, 24
4037737c:	190c      	movi.n	a9, 1
4037737e:	839660        	moveqz	a9, a6, a6
40377381:	019950        	slli	a9, a9, 27
40377384:	f510b1        	l32r	a11, 403747c4 <_iram_text_start+0x3c0> (f7ffffff <_rtc_reserved_end+0x97efffff>)
40377387:	1088b0        	and	a8, a8, a11
4037738a:	208890        	or	a8, a8, a9
4037738d:	0020c0        	memw
40377390:	6a89      	s32i.n	a8, a10, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
40377392:	668c      	beqz.n	a6, 4037739c <bootloader_flash_execute_command_common+0x198>
40377394:	860b      	addi.n	a8, a6, -1
40377396:	948080        	extui	a8, a8, 0, 10
40377399:	000046        	j	4037739e <bootloader_flash_execute_command_common+0x19a>
4037739c:	080c      	movi.n	a8, 0
4037739e:	f502a1        	l32r	a10, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
403773a1:	0020c0        	memw
403773a4:	9a98      	l32i.n	a9, a10, 36
403773a6:	00acb2        	movi	a11, 0xfffffc00
403773a9:	1099b0        	and	a9, a9, a11
403773ac:	208890        	or	a8, a8, a9
403773af:	0020c0        	memw
403773b2:	9a89      	s32i.n	a8, a10, 36
    }
    spi_flash_ll_set_dummy(&SPIMEM_LL_APB, total_dummy);
    //output data

    spi_flash_ll_set_mosi_bitlen(&SPIMEM_LL_APB, mosi_len);
    spi_flash_ll_set_buffer_data(&SPIMEM_LL_APB, &mosi_data, mosi_len / 8);
403773b4:	416360        	srli	a6, a6, 3
    int num_words = (length + 3) / 4;
403773b7:	363b      	addi.n	a3, a6, 3
403773b9:	413230        	srli	a3, a3, 2
    for (int i = 0; i < num_words; i++) {
403773bc:	050c      	movi.n	a5, 0
403773be:	10c142        	addi	a4, a1, 16
403773c1:	000ac6        	j	403773f0 <bootloader_flash_execute_command_common+0x1ec>
        uint32_t word = 0;
403773c4:	080c      	movi.n	a8, 0
403773c6:	3189      	s32i.n	a8, a1, 12
        uint32_t word_len = MIN(length, sizeof(word));
403773c8:	470c      	movi.n	a7, 4
403773ca:	637670        	minu	a7, a6, a7
        memcpy(&word, buffer, word_len);
403773cd:	07cd      	mov.n	a12, a7
403773cf:	04bd      	mov.n	a11, a4
403773d1:	a1cb      	addi.n	a10, a1, 12
403773d3:	f44b81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403773d6:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
403773d9:	14c582        	addi	a8, a5, 20
403773dc:	f4f391        	l32r	a9, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
403773df:	a08890        	addx4	a8, a8, a9
403773e2:	3198      	l32i.n	a9, a1, 12
403773e4:	0020c0        	memw
403773e7:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
403773e9:	c06670        	sub	a6, a6, a7
        buffer = (void *)((intptr_t)buffer + word_len);
403773ec:	474a      	add.n	a4, a7, a4
    for (int i = 0; i < num_words; i++) {
403773ee:	551b      	addi.n	a5, a5, 1
403773f0:	d02537        	blt	a5, a3, 403773c4 <bootloader_flash_execute_command_common+0x1c0>
    dev->user.usr_miso = bitlen > 0;
403773f3:	f4eda1        	l32r	a10, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
403773f6:	0020c0        	memw
403773f9:	6a88      	l32i.n	a8, a10, 24
403773fb:	190c      	movi.n	a9, 1
403773fd:	839220        	moveqz	a9, a2, a2
40377400:	019940        	slli	a9, a9, 28
40377403:	f4f1b1        	l32r	a11, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
40377406:	1088b0        	and	a8, a8, a11
40377409:	208890        	or	a8, a8, a9
4037740c:	0020c0        	memw
4037740f:	6a89      	s32i.n	a8, a10, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
40377411:	628c      	beqz.n	a2, 4037741b <bootloader_flash_execute_command_common+0x217>
40377413:	920b      	addi.n	a9, a2, -1
40377415:	949090        	extui	a9, a9, 0, 10
40377418:	000046        	j	4037741d <bootloader_flash_execute_command_common+0x219>
4037741b:	090c      	movi.n	a9, 0
4037741d:	f4e281        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
40377420:	0020c0        	memw
40377423:	a8a8      	l32i.n	a10, a8, 40
40377425:	00acb2        	movi	a11, 0xfffffc00
40377428:	10aab0        	and	a10, a10, a11
4037742b:	2099a0        	or	a9, a9, a10
4037742e:	0020c0        	memw
40377431:	a899      	s32i.n	a9, a8, 40
    dev->cmd.val |= usr_pe;
40377433:	0020c0        	memw
40377436:	0898      	l32i.n	a9, a8, 0
40377438:	f4e5a1        	l32r	a10, 403747cc <_iram_text_start+0x3c8> (40000 <UserFrameTotalSize+0x3ff00>)
4037743b:	2099a0        	or	a9, a9, a10
4037743e:	0020c0        	memw
40377441:	006892        	s32i	a9, a8, 0
    return (dev->cmd.val == 0);
40377444:	f4d981        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
40377447:	0020c0        	memw
4037744a:	0878      	l32i.n	a7, a8, 0
    //input data
    spi_flash_ll_set_miso_bitlen(&SPIMEM_LL_APB, miso_len);

    spi_flash_ll_user_start(&SPIMEM_LL_APB, false);
    while(!spi_flash_ll_cmd_is_done(&SPIMEM_LL_APB)) {
4037744c:	ff4756        	bnez	a7, 40377444 <bootloader_flash_execute_command_common+0x240>
 * @param user1_reg user1_reg
 * @param user2_reg user2_reg
 */
static inline void spimem_flash_ll_set_common_command_register_info(spi_mem_dev_t *dev, uint32_t ctrl_reg, uint32_t user_reg, uint32_t user1_reg, uint32_t user2_reg)
{
    dev->ctrl.val = ctrl_reg;
4037744f:	5198      	l32i.n	a9, a1, 20
40377451:	0020c0        	memw
40377454:	2899      	s32i.n	a9, a8, 8
    dev->user.val = user_reg;
40377456:	6198      	l32i.n	a9, a1, 24
40377458:	0020c0        	memw
4037745b:	6899      	s32i.n	a9, a8, 24
    dev->user1.val = user1_reg;
4037745d:	7198      	l32i.n	a9, a1, 28
4037745f:	0020c0        	memw
40377462:	7899      	s32i.n	a9, a8, 28
    dev->user2.val = user2_reg;
40377464:	8198      	l32i.n	a9, a1, 32
40377466:	0020c0        	memw
40377469:	8899      	s32i.n	a9, a8, 32
    }
    spi_flash_ll_set_common_command_register_info(&SPIMEM_LL_APB, old_ctrl_reg, old_user_reg, old_user1_reg, old_user2_reg);

    uint32_t output_data = 0;
4037746b:	080c      	movi.n	a8, 0
4037746d:	0189      	s32i.n	a8, a1, 0
    spi_flash_ll_get_buffer_data(&SPIMEM_LL_APB, &output_data, miso_len / 8);
4037746f:	413320        	srli	a3, a2, 3
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
40377472:	148320        	extui	a8, a2, 3, 2
40377475:	f8cc      	bnez.n	a8, 40377488 <bootloader_flash_execute_command_common+0x284>
        memcpy(buffer, (void *)dev->data_buf, read_len);
40377477:	03cd      	mov.n	a12, a3
40377479:	f4d5b1        	l32r	a11, 403747d0 <_iram_text_start+0x3cc> (60002058 <SPIMEM1+0x58>)
4037747c:	01ad      	mov.n	a10, a1
4037747e:	f42081        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40377481:	0008e0        	callx8	a8
40377484:	000e06        	j	403774c0 <bootloader_flash_execute_command_common+0x2bc>
40377487:	00          	.byte	00
        int copy_len = read_len;
40377488:	034d      	mov.n	a4, a3
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037748a:	015d      	mov.n	a5, a1
4037748c:	000a06        	j	403774b8 <bootloader_flash_execute_command_common+0x2b4>
4037748f:	460c00        	ee.ldf.64.xp	f0, f4, a0, a12
            int word_len = MIN(sizeof(uint32_t), copy_len);
40377492:	636460        	minu	a6, a4, a6
            uint32_t word = dev->data_buf[i];
40377495:	14c782        	addi	a8, a7, 20
40377498:	f4c491        	l32r	a9, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037749b:	a08890        	addx4	a8, a8, a9
4037749e:	0020c0        	memw
403774a1:	2888      	l32i.n	a8, a8, 8
403774a3:	3189      	s32i.n	a8, a1, 12
            memcpy(buffer, &word, word_len);
403774a5:	06cd      	mov.n	a12, a6
403774a7:	b1cb      	addi.n	a11, a1, 12
403774a9:	05ad      	mov.n	a10, a5
403774ab:	f41581        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403774ae:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
403774b1:	565a      	add.n	a5, a6, a5
            copy_len -= word_len;
403774b3:	c04460        	sub	a4, a4, a6
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
403774b6:	771b      	addi.n	a7, a7, 1
403774b8:	833b      	addi.n	a8, a3, 3
403774ba:	418280        	srli	a8, a8, 2
403774bd:	cf3787        	bltu	a7, a8, 40377490 <bootloader_flash_execute_command_common+0x28c>
    uint32_t ret = output_data;
403774c0:	0188      	l32i.n	a8, a1, 0
    if (miso_len < 32) {
403774c2:	f91c      	movi.n	a9, 31
403774c4:	0d3927        	bltu	a9, a2, 403774d5 <bootloader_flash_execute_command_common+0x2d1>
        //set unused bits to 0
        ret &= ~(UINT32_MAX << miso_len);
403774c7:	f97c      	movi.n	a9, -1
403774c9:	401200        	ssl	a2
403774cc:	a19900        	sll	a9, a9
403774cf:	109980        	and	a9, a9, a8
403774d2:	308980        	xor	a8, a9, a8
    }
    return ret;
}
403774d5:	082d      	mov.n	a2, a8
403774d7:	f01d      	retw.n
403774d9:	000000        	ill

403774dc <bootloader_execute_flash_command>:
#endif

uint32_t IRAM_ATTR bootloader_execute_flash_command(uint8_t command, uint32_t mosi_data, uint8_t mosi_len, uint8_t miso_len)
{
403774dc:	006136        	entry	a1, 48
403774df:	20f330        	or	a15, a3, a3
403774e2:	745050        	extui	a5, a5, 0, 8
    const uint8_t addr_len = 0;
    const uint8_t address = 0;
    const uint8_t dummy_len = 0;

    return bootloader_flash_execute_command_common(command, addr_len, address,
403774e5:	006152        	s32i	a5, a1, 0
403774e8:	74e040        	extui	a14, a4, 0, 8
403774eb:	00a0d2        	movi	a13, 0
403774ee:	0dcd      	mov.n	a12, a13
403774f0:	0dbd      	mov.n	a11, a13
403774f2:	74a020        	extui	a10, a2, 0, 8
403774f5:	ffd0e5        	call8	40377204 <bootloader_flash_execute_command_common>
            dummy_len, mosi_len, mosi_data, miso_len);
}
403774f8:	0a2d      	mov.n	a2, a10
403774fa:	f01d      	retw.n

403774fc <bootloader_read_flash_id>:
{
    bootloader_execute_flash_command(CMD_WRDI, 0, 0, 0);   /* Exit OTP mode */
}

uint32_t IRAM_ATTR bootloader_read_flash_id(void)
{
403774fc:	004136        	entry	a1, 32
    uint32_t id = bootloader_execute_flash_command(CMD_RDID, 0, 0, 24);
403774ff:	8d1c      	movi.n	a13, 24
40377501:	0c0c      	movi.n	a12, 0
40377503:	20bcc0        	or	a11, a12, a12
40377506:	9fa0a2        	movi	a10, 159
40377509:	fffd25        	call8	403774dc <bootloader_execute_flash_command>
    id = ((id & 0xff) << 16) | ((id >> 16) & 0xff) | (id & 0xff00);
4037750c:	112a00        	slli	a2, a10, 16
4037750f:	752020        	extui	a2, a2, 16, 8
40377512:	112200        	slli	a2, a2, 16
40377515:	7580a0        	extui	a8, a10, 16, 8
40377518:	202280        	or	a2, a2, a8
4037751b:	74a8a0        	extui	a10, a10, 8, 8
4037751e:	11aa80        	slli	a10, a10, 8
    return id;
}
40377521:	2022a0        	or	a2, a2, a10
40377524:	f01d      	retw.n
	...

40377528 <bootloader_flash_reset_chip>:
}

#endif //XMC_SUPPORT

esp_err_t IRAM_ATTR bootloader_flash_reset_chip(void)
{
40377528:	004136        	entry	a1, 32
    SPIMEM1.ctrl2.sync_reset = 0;
4037752b:	f49f71        	l32r	a7, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037752e:	0020c0        	memw
40377531:	0427a2        	l32i	a10, a7, 16
40377534:	f4a881        	l32r	a8, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
40377537:	109a80        	and	a9, a10, a8
4037753a:	0020c0        	memw
4037753d:	4799      	s32i.n	a9, a7, 16
    SPIMEM0.ctrl2.sync_reset = 0;
4037753f:	f4a691        	l32r	a9, 403747d8 <_iram_text_start+0x3d4> (60003000 <SPIMEM0>)
40377542:	0020c0        	memw
40377545:	49b8      	l32i.n	a11, a9, 16
40377547:	10ab80        	and	a10, a11, a8
4037754a:	0020c0        	memw
4037754d:	49a9      	s32i.n	a10, a9, 16
    SPIMEM1.ctrl2.sync_reset = 1;
4037754f:	0020c0        	memw
40377552:	47c8      	l32i.n	a12, a7, 16
40377554:	f497a1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
40377557:	20bca0        	or	a11, a12, a10
4037755a:	0020c0        	memw
4037755d:	47b9      	s32i.n	a11, a7, 16
    SPIMEM0.ctrl2.sync_reset = 1;
4037755f:	0020c0        	memw
40377562:	49b8      	l32i.n	a11, a9, 16
40377564:	20aba0        	or	a10, a11, a10
40377567:	0020c0        	memw
4037756a:	49a9      	s32i.n	a10, a9, 16
    SPIMEM1.ctrl2.sync_reset = 0;
4037756c:	0020c0        	memw
4037756f:	47b8      	l32i.n	a11, a7, 16
40377571:	10ab80        	and	a10, a11, a8
40377574:	0020c0        	memw
40377577:	47a9      	s32i.n	a10, a7, 16
    SPIMEM0.ctrl2.sync_reset = 0;
40377579:	0020c0        	memw
4037757c:	49a8      	l32i.n	a10, a9, 16
4037757e:	108a80        	and	a8, a10, a8
40377581:	0020c0        	memw
40377584:	4989      	s32i.n	a8, a9, 16
    spi_flash_ll_sync_reset();
    // Seems that sync_reset cannot make host totally idle.'
    // Sending an extra(useless) command to make the host idle in order to send reset command.
    bootloader_execute_flash_command(0x05, 0, 0, 0);
40377586:	0d0c      	movi.n	a13, 0
40377588:	0dcd      	mov.n	a12, a13
4037758a:	20bdd0        	or	a11, a13, a13
4037758d:	5a0c      	movi.n	a10, 5
4037758f:	fff4e5        	call8	403774dc <bootloader_execute_flash_command>
    return dev->cmd.val == 0;
40377592:	0020c0        	memw
40377595:	0788      	l32i.n	a8, a7, 0
#if CONFIG_IDF_TARGET_ESP32
    if (SPI1.ext2.st != 0)
#else
    if (!spimem_flash_ll_host_idle(&SPIMEM1))
40377597:	b8dc      	bnez.n	a8, 403775b6 <bootloader_flash_reset_chip+0x8e>
#endif
    {
        return ESP_FAIL;
    }
    bootloader_execute_flash_command(0x66, 0, 0, 0);
40377599:	0d0c      	movi.n	a13, 0
4037759b:	0dcd      	mov.n	a12, a13
4037759d:	0dbd      	mov.n	a11, a13
4037759f:	66a0a2        	movi	a10, 102
403775a2:	fff3a5        	call8	403774dc <bootloader_execute_flash_command>
    bootloader_execute_flash_command(0x99, 0, 0, 0);
403775a5:	0d0c      	movi.n	a13, 0
403775a7:	0dcd      	mov.n	a12, a13
403775a9:	0dbd      	mov.n	a11, a13
403775ab:	99a0a2        	movi	a10, 153
403775ae:	fff2e5        	call8	403774dc <bootloader_execute_flash_command>

    return ESP_OK;
403775b1:	020c      	movi.n	a2, 0
403775b3:	000046        	j	403775b8 <bootloader_flash_reset_chip+0x90>
        return ESP_FAIL;
403775b6:	f27c      	movi.n	a2, -1
}
403775b8:	f01d      	retw.n
	...

403775bc <bootloader_flash_is_octal_mode_enabled>:

bool IRAM_ATTR bootloader_flash_is_octal_mode_enabled(void)
{
403775bc:	004136        	entry	a1, 32
    return EFUSE.rd_repeat_data3.flash_type;
403775bf:	f41a81        	l32r	a8, 40374628 <_iram_text_start+0x224> (60007000 <EFUSE>)
403775c2:	0020c0        	memw
403775c5:	f828      	l32i.n	a2, a8, 60
#if SOC_SPI_MEM_SUPPORT_FLASH_OPI_MODE
    return efuse_ll_get_flash_type();
#else
    return false;
#endif
}
403775c7:	042920        	extui	a2, a2, 9, 1
403775ca:	f01d      	retw.n

403775cc <esp_flash_encryption_enabled>:
 * would require the caller component to include `efuse` as part of its `REQUIRES` or
 * `PRIV_REQUIRES` entries.
 * Attribute IRAM_ATTR must be specified for the app build.
 */
bool IRAM_ATTR esp_flash_encryption_enabled(void)
{
403775cc:	004136        	entry	a1, 32
#ifndef CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
    return efuse_hal_flash_encryption_enabled();
403775cf:	fe7f65        	call8	40375dc4 <efuse_hal_flash_encryption_enabled>
        }
        flash_crypt_cnt >>= 1;
    }
    return enabled;
#endif // CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
}
403775d2:	0a2d      	mov.n	a2, a10
403775d4:	f01d      	retw.n
	...

403775d8 <s_stop_cache>:
    *out_caps = found_block->caps;
    return ESP_OK;
}

static void IRAM_ATTR NOINLINE_ATTR s_stop_cache(void)
{
403775d8:	004136        	entry	a1, 32
#if SOC_CACHE_FREEZE_SUPPORTED && !CONFIG_IDF_TARGET_ESP32P4
    // On P4, due to limitations on stalling another core, we temporarily use cache disable/enable
    esp_cache_freeze_caches_disable_interrupts();
403775db:	01e565        	call8	40379430 <esp_cache_freeze_caches_disable_interrupts>
#else
    spi_flash_disable_interrupts_caches_and_other_cpu();
#endif
}
403775de:	f01d      	retw.n

403775e0 <s_do_cache_invalidate>:
    spi_flash_enable_interrupts_caches_and_other_cpu();
#endif
}

static void IRAM_ATTR NOINLINE_ATTR s_do_cache_invalidate(uint32_t vaddr_start, uint32_t size)
{
403775e0:	004136        	entry	a1, 32
403775e3:	20a220        	or	a10, a2, a2
403775e6:	20b330        	or	a11, a3, a3
     * easy way to sync between cache and external memory wrt
     * certain range. So we do a full sync here
     */
    cache_sync();
#else   //Other chips
    cache_hal_invalidate_addr(vaddr_start, size);
403775e9:	054ea5        	call8	4037cad4 <cache_hal_invalidate_addr>
#endif // CONFIG_IDF_TARGET_ESP32
}
403775ec:	000090        	retw
	...

403775f0 <s_start_cache>:
{
403775f0:	004136        	entry	a1, 32
    esp_cache_unfreeze_caches_enable_interrupts();
403775f3:	01e8e5        	call8	40379480 <esp_cache_unfreeze_caches_enable_interrupts>
}
403775f6:	f01d      	retw.n

403775f8 <s_do_mapping>:
    return actual_mapped_len;
}
#endif

static void IRAM_ATTR NOINLINE_ATTR s_do_mapping(mmu_target_t target, uint32_t vaddr_start, esp_paddr_t paddr_start, uint32_t size)
{
403775f8:	006136        	entry	a1, 48
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     */
    s_stop_cache();
403775fb:	fffde5        	call8	403775d8 <s_stop_cache>
    uint32_t actual_mapped_len = 0;
403775fe:	00a0a2        	movi	a10, 0
40377601:	01a9      	s32i.n	a10, a1, 0
    mmu_hal_map_region(0, target, vaddr_start, paddr_start, size, &actual_mapped_len);
40377603:	01fd      	mov.n	a15, a1
40377605:	05ed      	mov.n	a14, a5
40377607:	04dd      	mov.n	a13, a4
40377609:	03cd      	mov.n	a12, a3
4037760b:	02bd      	mov.n	a11, a2
4037760d:	0573a5        	call8	4037cd48 <mmu_hal_map_region>
    uint32_t vaddr_end = vaddr_start + len - 1;
40377610:	a35a      	add.n	a10, a3, a5
40377612:	aa0b      	addi.n	a10, a10, -1
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
40377614:	f47291        	l32r	a9, 403747dc <_iram_text_start+0x3d8> (41ffffff <_iram_bss_end+0x1c7dbff>)
40377617:	629930        	saltu	a9, a9, a3
4037761a:	f47181        	l32r	a8, 403747e0 <_iram_text_start+0x3dc> (43ffffff <_etext+0x1fe68c9>)
4037761d:	6288a0        	saltu	a8, a8, a10
40377620:	880b      	addi.n	a8, a8, -1
40377622:	608080        	neg	a8, a8
40377625:	10b890        	and	a11, a8, a9
40377628:	228897        	bany	a8, a9, 4037764e <s_do_mapping+0x56>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
4037762b:	f46e91        	l32r	a9, 403747e4 <_iram_text_start+0x3e0> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037762e:	629930        	saltu	a9, a9, a3
40377631:	f46d81        	l32r	a8, 403747e8 <_iram_text_start+0x3e4> (3dffffff <_esp_system_init_fn_array_end+0x1fd6d5b>)
40377634:	6288a0        	saltu	a8, a8, a10
40377637:	880b      	addi.n	a8, a8, -1
40377639:	608080        	neg	a8, a8
4037763c:	148897        	bany	a8, a9, 40377654 <s_do_mapping+0x5c>
        HAL_ASSERT(0);      //Out of region
4037763f:	f46bd1        	l32r	a13, 403747ec <_iram_text_start+0x3e8> (3c0233b0 <_flash_rodata_start+0x3290>)
40377642:	f46bc1        	l32r	a12, 403747f0 <_iram_text_start+0x3ec> (3c027790 <__func__$9>)
40377645:	3aa2b2        	movi	a11, 0x23a
40377648:	f46ba1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (3c020504 <_flash_rodata_start+0x3e4>)
4037764b:	086de5        	call8	4037fd28 <__assert_func>
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_IBUS0);    //Both cores have their own IBUS0
4037764e:	180c      	movi.n	a8, 1
40377650:	0000c6        	j	40377657 <s_do_mapping+0x5f>
40377653:	a08200        	addx4	a8, a2, a0
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_DBUS0);    //Both cores have their own DBUS0
40377656:	8008      	l32i.n	a0, a0, 32
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE0_BUS : 0);
40377658:	c10490        	mul16u	a0, a4, a9
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037765b:	f37c      	movi.n	a3, -1
4037765d:	0020c0        	memw
40377660:	0cd8      	l32i.n	a13, a12, 0
40377662:	1099d0        	and	a9, a9, a13
40377665:	3099d0        	xor	a9, a9, a13
40377668:	0020c0        	memw
4037766b:	0c99      	s32i.n	a9, a12, 0
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE1_BUS : 0);
4037766d:	419280        	srli	a9, a8, 2
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
40377670:	f378c1        	l32r	a12, 40374450 <_iram_text_start+0x4c> (600c4004 <SYSTEM+0x4004>)
40377673:	0020c0        	memw
40377676:	0cd8      	l32i.n	a13, a12, 0
40377678:	1099d0        	and	a9, a9, a13
4037767b:	3099d0        	xor	a9, a9, a13
4037767e:	0020c0        	memw
40377681:	0c99      	s32i.n	a9, a12, 0
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
40377683:	1bec      	bnez.n	a11, 403776a8 <s_do_mapping+0xb0>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
40377685:	f457b1        	l32r	a11, 403747e4 <_iram_text_start+0x3e0> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
40377688:	62bb30        	saltu	a11, a11, a3
4037768b:	f45791        	l32r	a9, 403747e8 <_iram_text_start+0x3e4> (3dffffff <_esp_system_init_fn_array_end+0x1fd6d5b>)
4037768e:	6299a0        	saltu	a9, a9, a10
40377691:	990b      	addi.n	a9, a9, -1
40377693:	609090        	neg	a9, a9
40377696:	0e89b7        	bany	a9, a11, 403776a8 <s_do_mapping+0xb0>
        HAL_ASSERT(0);      //Out of region
40377699:	f454d1        	l32r	a13, 403747ec <_iram_text_start+0x3e8> (3c0233b0 <_flash_rodata_start+0x3290>)
4037769c:	f455c1        	l32r	a12, 403747f0 <_iram_text_start+0x3ec> (3c027790 <__func__$9>)
4037769f:	3aa2b2        	movi	a11, 0x23a
403776a2:	f454a1        	l32r	a10, 403747f4 <_iram_text_start+0x3f0> (3c020504 <_flash_rodata_start+0x3e4>)
403776a5:	086825        	call8	4037fd28 <__assert_func>
        ibus_mask = ibus_mask | ((mask & CACHE_BUS_IBUS0) ? EXTMEM_ICACHE_SHUT_CORE1_BUS : 0);
403776a8:	988a      	add.n	a9, a8, a8
403776aa:	2a0c      	movi.n	a10, 2
403776ac:	1099a0        	and	a9, a9, a10
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
403776af:	f367a1        	l32r	a10, 4037444c <_iram_text_start+0x48> (600c4064 <SYSTEM+0x4064>)
403776b2:	0020c0        	memw
403776b5:	0ab8      	l32i.n	a11, a10, 0
403776b7:	1099b0        	and	a9, a9, a11
403776ba:	3099b0        	xor	a9, a9, a11
403776bd:	0020c0        	memw
403776c0:	0a99      	s32i.n	a9, a10, 0
        dbus_mask = dbus_mask | ((mask & CACHE_BUS_DBUS0) ? EXTMEM_DCACHE_SHUT_CORE0_BUS : 0);
403776c2:	418380        	srli	a8, a8, 3
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
403776c5:	f36291        	l32r	a9, 40374450 <_iram_text_start+0x4c> (600c4004 <SYSTEM+0x4004>)
403776c8:	0020c0        	memw
403776cb:	09a8      	l32i.n	a10, a9, 0
403776cd:	1088a0        	and	a8, a8, a10
403776d0:	3088a0        	xor	a8, a8, a10
403776d3:	0020c0        	memw
403776d6:	0989      	s32i.n	a8, a9, 0
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    bus_mask = cache_ll_l1_get_bus(0, vaddr_start, size);
    cache_ll_l1_enable_bus(1, bus_mask);
#endif

    s_do_cache_invalidate(vaddr_start, size);
403776d8:	05bd      	mov.n	a11, a5
403776da:	03ad      	mov.n	a10, a3
403776dc:	fff025        	call8	403775e0 <s_do_cache_invalidate>

    //enable Cache, after this function, internal RAM access is no longer mandatory
    s_start_cache();
403776df:	fff125        	call8	403775f0 <s_start_cache>

    ESP_EARLY_LOGV(TAG, "actual_mapped_len is 0x%"PRIx32, actual_mapped_len);
}
403776e2:	f01d      	retw.n

403776e4 <s_do_unmapping>:
#endif //  #if (SOC_MMU_PERIPH_NUM == 2)
}
#endif

static void IRAM_ATTR NOINLINE_ATTR s_do_unmapping(uint32_t vaddr_start, uint32_t size)
{
403776e4:	004136        	entry	a1, 32
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     */
    s_stop_cache();
403776e7:	ffef25        	call8	403775d8 <s_stop_cache>
    mmu_hal_unmap_region(0, vaddr_start, size);
403776ea:	20c330        	or	a12, a3, a3
403776ed:	02bd      	mov.n	a11, a2
403776ef:	0a0c      	movi.n	a10, 0
403776f1:	057125        	call8	4037ce04 <mmu_hal_unmap_region>

    s_unmapping_operation(vaddr_start, size);

    //enable Cache, after this function, internal RAM access is no longer mandatory
    s_start_cache();
403776f4:	ffefa5        	call8	403775f0 <s_start_cache>
}
403776f7:	f01d      	retw.n
403776f9:	000000        	ill

403776fc <s_vaddr_to_paddr>:

/*---------------------------------------------------------------
    Helper APIs for conversion between vaddr and paddr
---------------------------------------------------------------*/
static bool NOINLINE_ATTR IRAM_ATTR s_vaddr_to_paddr(uint32_t vaddr, esp_paddr_t *out_paddr, mmu_target_t *out_target)
{
403776fc:	004136        	entry	a1, 32
    uint32_t mmu_id = 0;
    /**
     * Disable Cache, after this function, involved code and data should be placed in internal RAM.
     */
    s_stop_cache();
403776ff:	ffeda5        	call8	403775d8 <s_stop_cache>

#if SOC_MMU_PER_EXT_MEM_TARGET
    mmu_id = mmu_hal_get_id_from_vaddr(vaddr);
#endif
    bool is_mapped = mmu_hal_vaddr_to_paddr(mmu_id, vaddr, out_paddr, out_target);
40377702:	20d440        	or	a13, a4, a4
40377705:	03cd      	mov.n	a12, a3
40377707:	02bd      	mov.n	a11, a2
40377709:	00a0a2        	movi	a10, 0
4037770c:	0575e5        	call8	4037ce6c <mmu_hal_vaddr_to_paddr>
4037770f:	0a2d      	mov.n	a2, a10
        is_mapped = mmu_hal_vaddr_to_paddr(1, vaddr, out_paddr, out_target);
    }
#endif

    //enable Cache, after this function, internal RAM access is no longer mandatory
    s_start_cache();
40377711:	ffede5        	call8	403775f0 <s_start_cache>

    return is_mapped;
}
40377714:	f01d      	retw.n
	...

40377718 <esp_mmu_paddr_find_caps>:
{
40377718:	004136        	entry	a1, 32
    if (out_caps == NULL) {
4037771b:	05a316        	beqz	a3, 40377779 <esp_mmu_paddr_find_caps+0x61>
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
4037771e:	0a0c      	movi.n	a10, 0
    mem_block_t *found_block = NULL;
40377720:	0aed      	mov.n	a14, a10
    bool found = false;
40377722:	0add      	mov.n	a13, a10
40377724:	000f86        	j	40377766 <esp_mmu_paddr_find_caps+0x4e>
40377727:	8aa000        	round.s	a10, f0, 0
        TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
4037772a:	3391a0        	clamps	a9, a1, 17
4037772d:	8890f4        	ee.vld.h.64.ip	q1, a15, 128
40377730:	b0          	.byte	0xb0
40377731:	98c8      	l32i.n	a12, a8, 36
40377733:	0c8d      	mov.n	a8, a12
40377735:	000846        	j	4037775a <esp_mmu_paddr_find_caps+0x42>
40377738:	18c700        	lsxp	f12, a7, a0
            if (mem_block == TAILQ_FIRST(&region->mem_block_head) || mem_block == TAILQ_LAST(&region->mem_block_head, mem_block_head_)) {
4037773b:	a01b      	addi.n	a10, a0, 1
4037773d:	a09a      	add.n	a10, a0, a9
4037773f:	f42eb1        	l32r	a11, 403747f8 <_iram_text_start+0x3f4> (3fc95380 <s_mmu_ctx>)
40377742:	b099b0        	addx8	a9, a9, a11
40377745:	a998      	l32i.n	a9, a9, 40
40377747:	1998      	l32i.n	a9, a9, 4
40377749:	0998      	l32i.n	a9, a9, 0
4037774b:	091987        	beq	a9, a8, 40377758 <esp_mmu_paddr_find_caps+0x40>
            if (paddr >= mem_block->paddr_start && paddr < mem_block->paddr_end) {
4037774e:	6898      	l32i.n	a9, a8, 24
40377750:	043297        	bltu	a2, a9, 40377758 <esp_mmu_paddr_find_caps+0x40>
40377753:	7898      	l32i.n	a9, a8, 28
40377755:	073297        	bltu	a2, a9, 40377760 <esp_mmu_paddr_find_caps+0x48>
        TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
40377758:	9888      	l32i.n	a8, a8, 36
4037775a:	fdb856        	bnez	a8, 40377739 <esp_mmu_paddr_find_caps+0x21>
4037775d:	0000c6        	j	40377764 <esp_mmu_paddr_find_caps+0x4c>
                found_block = mem_block;
40377760:	08ed      	mov.n	a14, a8
                found = true;
40377762:	1d0c      	movi.n	a13, 1
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
40377764:	aa1b      	addi.n	a10, a10, 1
40377766:	f42481        	l32r	a8, 403747f8 <_iram_text_start+0x3f4> (3fc95380 <s_mmu_ctx>)
40377769:	0888      	l32i.n	a8, a8, 0
4037776b:	b93a87        	bltu	a10, a8, 40377728 <esp_mmu_paddr_find_caps+0x10>
    if (!found) {
4037776e:	ed8c      	beqz.n	a13, 40377780 <esp_mmu_paddr_find_caps+0x68>
    *out_caps = found_block->caps;
40377770:	5e88      	l32i.n	a8, a14, 20
40377772:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40377774:	020c      	movi.n	a2, 0
40377776:	000246        	j	40377783 <esp_mmu_paddr_find_caps+0x6b>
        return ESP_ERR_INVALID_ARG;
40377779:	02a122        	movi	a2, 0x102
4037777c:	0000c6        	j	40377783 <esp_mmu_paddr_find_caps+0x6b>
4037777f:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40377782:	f01d05        	call0	40367954 <rom_rx_gain_force+0x361528>
40377785:	000000        	ill

40377788 <esp_heap_adjust_alignment_to_hw>:
#endif

#define CAPS_NEEDING_ALIGNMENT (MALLOC_CAP_DMA|MALLOC_CAP_DMA_DESC_AHB|MALLOC_CAP_DMA_DESC_AXI|MALLOC_CAP_CACHE_ALIGNED|MALLOC_CAP_SIMD)

HEAP_IRAM_ATTR void esp_heap_adjust_alignment_to_hw(size_t *p_alignment, size_t *p_size, uint32_t *p_caps)
{
40377788:	006136        	entry	a1, 48
    size_t size = *p_size;
4037778b:	002362        	l32i	a6, a3, 0
    size_t alignment = *p_alignment;
4037778e:	002252        	l32i	a5, a2, 0
    uint32_t caps = *p_caps;
40377791:	002472        	l32i	a7, a4, 0

    //Bail out early if we don't need alignment
    if (!(caps & CAPS_NEEDING_ALIGNMENT)) {
40377794:	f41a81        	l32r	a8, 403747fc <_iram_text_start+0x3f8> (1e0008 <UserFrameTotalSize+0x1dff08>)
40377797:	590787        	bnone	a7, a8, 403777f4 <esp_heap_adjust_alignment_to_hw+0x6c>
#endif
    return;
#endif

    //Ask cache driver what alignment is applicable here.
    size_t cache_alignment_bytes = 0;
4037779a:	080c      	movi.n	a8, 0
4037779c:	0189      	s32i.n	a8, a1, 0
    esp_err_t ret = esp_cache_get_alignment(caps, &cache_alignment_bytes);
4037779e:	01bd      	mov.n	a11, a1
403777a0:	07ad      	mov.n	a10, a7
403777a2:	01c0a5        	call8	403793ac <esp_cache_get_alignment>
    if (ret != ESP_OK) {
403777a5:	ca8c      	beqz.n	a10, 403777b5 <esp_heap_adjust_alignment_to_hw+0x2d>
        //This is not supposed to happen.
        *p_caps |= MALLOC_CAP_INVALID;
403777a7:	0488      	l32i.n	a8, a4, 0
403777a9:	f40191        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
403777ac:	208890        	or	a8, a8, a9
403777af:	0489      	s32i.n	a8, a4, 0
        return;
403777b1:	000fc6        	j	403777f4 <esp_heap_adjust_alignment_to_hw+0x6c>
403777b4:	018800        	slli	a8, a8, 32
    // do this because:
    // - DMA alignment in current chips always is a power of two, and is unlikely to ever
    //   be something else,
    // - Requested alignment is checked by heap_caps_aligned_check_args to be a power
    //   of two.
    if (cache_alignment_bytes > alignment) {
403777b7:	013587        	bltu	a5, a8, 403777bc <esp_heap_adjust_alignment_to_hw+0x34>
    size_t alignment = *p_alignment;
403777ba:	058d      	mov.n	a8, a5
        alignment = cache_alignment_bytes;
    }

#if SOC_SIMD_INSTRUCTION_SUPPORTED
    // SIMD instructions preferred data alignment, SOC_SIMD_PREFERRED_DATA_ALIGNMENT, which is also definitely a power of two
    if (caps & MALLOC_CAP_SIMD) {
403777bc:	047747        	bbci	a7, 20, 403777c4 <esp_heap_adjust_alignment_to_hw+0x3c>
        alignment = (alignment > SOC_SIMD_PREFERRED_DATA_ALIGNMENT) ? alignment : SOC_SIMD_PREFERRED_DATA_ALIGNMENT;
403777bf:	091c      	movi.n	a9, 16
403777c1:	738890        	maxu	a8, a8, a9
    }
#endif

    // Align up `size` to resulting alignment as well.
    size = (size + alignment - 1) & (~(alignment - 1));
403777c4:	686a      	add.n	a6, a8, a6
403777c6:	660b      	addi.n	a6, a6, -1
403777c8:	609080        	neg	a9, a8
403777cb:	106690        	and	a6, a6, a9

    // For the heap allocator itself, there's no difference between data and descriptor DMA; the regions
    // are only marked as DMA-capable.
    if (caps & (MALLOC_CAP_DMA_DESC_AHB | MALLOC_CAP_DMA_DESC_AXI)) {
403777ce:	159170        	extui	a9, a7, 17, 2
403777d1:	00b916        	beqz	a9, 403777e0 <esp_heap_adjust_alignment_to_hw+0x58>
        caps &= ~(MALLOC_CAP_DMA_DESC_AHB | MALLOC_CAP_DMA_DESC_AXI);
403777d4:	f40b91        	l32r	a9, 40374800 <_iram_text_start+0x3fc> (fff9ffff <_rtc_reserved_end+0x9fe9ffff>)
403777d7:	109790        	and	a9, a7, a9
        caps |= MALLOC_CAP_DMA;
403777da:	08a072        	movi	a7, 8
403777dd:	207970        	or	a7, a9, a7
    }

    // Workaround: the heap allocator doesn't have regions marked `MALLOC_CAP_DMA | MALLOC_CAP_SPIRAM`
    // so we need to request those without the DMA flag.
    if (caps & MALLOC_CAP_SPIRAM) {
403777e0:	0467a7        	bbci	a7, 10, 403777e8 <esp_heap_adjust_alignment_to_hw+0x60>
        caps &= ~MALLOC_CAP_DMA;
403777e3:	797c      	movi.n	a9, -9
403777e5:	107790        	and	a7, a7, a9
        //memory, so the MALLOC_CAP_SPIRAM|MALLOC_CAP_DMA_DESC_* simply will not return any
        //usable memory.
    }
    // MALLOC_CAP_CACHE_ALIGNED is not a real flag the heap_base component will understand; it
    // only sets alignment (which we handled here)
    caps &= ~ MALLOC_CAP_CACHE_ALIGNED;
403777e8:	f40791        	l32r	a9, 40374804 <_iram_text_start+0x400> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
403777eb:	107790        	and	a7, a7, a9

    *p_size = size;
403777ee:	0369      	s32i.n	a6, a3, 0
    *p_alignment = alignment;
403777f0:	0289      	s32i.n	a8, a2, 0
    *p_caps = caps;
403777f2:	0479      	s32i.n	a7, a4, 0
}
403777f4:	f01d      	retw.n
	...

403777f8 <spi_flash_disable_cache>:
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
#endif
}

void IRAM_ATTR spi_flash_disable_cache(uint32_t cpuid, uint32_t *saved_state)
{
403777f8:	004136        	entry	a1, 32
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    //branch predictor will start cache request as well
    esp_cpu_branch_prediction_disable();
#endif
    esp_cache_suspend_ext_mem_cache();
403777fb:	01bf65        	call8	403793f0 <esp_cache_suspend_ext_mem_cache>
}
403777fe:	f01d      	retw.n

40377800 <spi_flash_disable_interrupts_caches_and_other_cpu>:
{
40377800:	004136        	entry	a1, 32
    asm volatile ("mov %0, sp;" : "=r" (sp));
40377803:	209110        	or	a9, a1, a1
    return ((intptr_t)p >= SOC_DRAM_LOW && (intptr_t)p < SOC_DRAM_HIGH);
40377806:	f39581        	l32r	a8, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
40377809:	808980        	add	a8, a9, a8
           || esp_ptr_in_rtc_dram_fast(sp)
4037780c:	f3ffa1        	l32r	a10, 40374808 <_iram_text_start+0x404> (77fff <UserFrameTotalSize+0x77eff>)
4037780f:	1aba87        	bgeu	a10, a8, 4037782d <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40377812:	f37281        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40377815:	809980        	add	a9, a9, a8
40377818:	f37281        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
4037781b:	0eb897        	bgeu	a8, a9, 4037782d <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    assert(esp_task_stack_is_sane_cache_disabled());
4037781e:	f3fbd1        	l32r	a13, 4037480c <_iram_text_start+0x408> (3c0251e4 <_flash_rodata_start+0x50c4>)
40377821:	f3fbc1        	l32r	a12, 40374810 <_iram_text_start+0x40c> (3c027948 <__func__$1>)
40377824:	7fa0b2        	movi	a11, 127
40377827:	f3fba1        	l32r	a10, 40374814 <_iram_text_start+0x410> (3c0251d3 <_flash_rodata_start+0x50b3>)
4037782a:	084fe5        	call8	4037fd28 <__assert_func>
    spi_flash_op_lock();
4037782d:	f40081        	l32r	a8, 40374830 <_iram_text_start+0x42c> (4200aeb4 <spi_flash_op_lock>)
40377830:	0008e0        	callx8	a8
    asm volatile (
40377833:	03eb70        	rsr.prid	a7
40377836:	047d70        	extui	a7, a7, 13, 1
    return (int)xt_utils_get_core_id();
40377839:	076d      	mov.n	a6, a7
    assert(s_flash_op_cpu == -1);
4037783b:	f3f781        	l32r	a8, 40374818 <_iram_text_start+0x414> (3fc92a14 <s_flash_op_cpu>)
4037783e:	0020c0        	memw
40377841:	0888      	l32i.n	a8, a8, 0
40377843:	0e0826        	beqi	a8, -1, 40377855 <spi_flash_disable_interrupts_caches_and_other_cpu+0x55>
40377846:	f3f5d1        	l32r	a13, 4037481c <_iram_text_start+0x418> (3c02520c <_flash_rodata_start+0x50ec>)
40377849:	f3f1c1        	l32r	a12, 40374810 <_iram_text_start+0x40c> (3c027948 <__func__$1>)
4037784c:	87a0b2        	movi	a11, 135
4037784f:	f3f1a1        	l32r	a10, 40374814 <_iram_text_start+0x410> (3c0251d3 <_flash_rodata_start+0x50b3>)
40377852:	084d65        	call8	4037fd28 <__assert_func>
    s_flash_op_cpu = cpuid;
40377855:	f3f081        	l32r	a8, 40374818 <_iram_text_start+0x414> (3fc92a14 <s_flash_op_cpu>)
40377858:	0020c0        	memw
4037785b:	0879      	s32i.n	a7, a8, 0
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
4037785d:	040d65        	call8	4037b934 <xTaskGetSchedulerState>
40377860:	111a66        	bnei	a10, 1, 40377875 <spi_flash_disable_interrupts_caches_and_other_cpu+0x75>
        assert(other_cpuid == 1);
40377863:	058716        	beqz	a7, 403778bf <spi_flash_disable_interrupts_caches_and_other_cpu+0xbf>
40377866:	f3eed1        	l32r	a13, 40374820 <_iram_text_start+0x41c> (3c025224 <_flash_rodata_start+0x5104>)
40377869:	f3e9c1        	l32r	a12, 40374810 <_iram_text_start+0x40c> (3c027948 <__func__$1>)
4037786c:	91a0b2        	movi	a11, 145
4037786f:	f3e9a1        	l32r	a10, 40374814 <_iram_text_start+0x410> (3c0251d3 <_flash_rodata_start+0x50b3>)
40377872:	084b65        	call8	4037fd28 <__assert_func>
            vTaskSuspendAll();
40377875:	0381a5        	call8	4037b090 <vTaskSuspendAll>
40377878:	03eb80        	rsr.prid	a8
4037787b:	048d80        	extui	a8, a8, 13, 1
4037787e:	086d      	mov.n	a6, a8
            other_cpuid = (cpuid == 0) ? 1 : 0;
40377880:	40f8a0        	nsau	a10, a8
40377883:	41a5a0        	srli	a10, a10, 5
            s_flash_op_cpu = cpuid;
40377886:	f3e491        	l32r	a9, 40374818 <_iram_text_start+0x414> (3fc92a14 <s_flash_op_cpu>)
40377889:	0020c0        	memw
4037788c:	006982        	s32i	a8, a9, 0
            s_flash_op_can_start = false;
4037788f:	090c      	movi.n	a9, 0
40377891:	f3e481        	l32r	a8, 40374824 <_iram_text_start+0x420> (3fc953b3 <s_flash_op_can_start>)
40377894:	0020c0        	memw
40377897:	004892        	s8i	a9, a8, 0
            ipc_call_was_send_to_other_cpu = esp_ipc_call_nonblocking(other_cpuid, &spi_flash_op_block_func, (void *) other_cpuid) == ESP_OK;
4037789a:	0acd      	mov.n	a12, a10
4037789c:	f3e3b1        	l32r	a11, 40374828 <_iram_text_start+0x424> (403778d8 <spi_flash_op_block_func>)
4037789f:	f3e581        	l32r	a8, 40374834 <_iram_text_start+0x430> (42002948 <esp_ipc_call_nonblocking>)
403778a2:	0008e0        	callx8	a8
403778a5:	0a7d      	mov.n	a7, a10
            if (!ipc_call_was_send_to_other_cpu) {
403778a7:	002a16        	beqz	a10, 403778ad <spi_flash_disable_interrupts_caches_and_other_cpu+0xad>
                xTaskResumeAll();
403778aa:	041f25        	call8	4037ba9c <xTaskResumeAll>
        } while (!ipc_call_was_send_to_other_cpu);
403778ad:	fc4756        	bnez	a7, 40377875 <spi_flash_disable_interrupts_caches_and_other_cpu+0x75>
        while (!s_flash_op_can_start) {
403778b0:	f3dd81        	l32r	a8, 40374824 <_iram_text_start+0x420> (3fc953b3 <s_flash_op_can_start>)
403778b3:	0020c0        	memw
403778b6:	000882        	l8ui	a8, a8, 0
403778b9:	748080        	extui	a8, a8, 0, 8
403778bc:	ff0816        	beqz	a8, 403778b0 <spi_flash_disable_interrupts_caches_and_other_cpu+0xb0>
    esp_intr_noniram_disable();
403778bf:	febe25        	call8	403764a0 <esp_intr_noniram_disable>
    spi_flash_disable_cache(cpuid, &s_flash_op_cache_state[cpuid]);
403778c2:	f3dab1        	l32r	a11, 4037482c <_iram_text_start+0x428> (3fc953b8 <s_flash_op_cache_state>)
403778c5:	a0b6b0        	addx4	a11, a6, a11
403778c8:	06ad      	mov.n	a10, a6
403778ca:	fff2e5        	call8	403777f8 <spi_flash_disable_cache>
}
403778cd:	f01d      	retw.n
	...

403778d0 <spi_flash_restore_cache>:

void IRAM_ATTR spi_flash_restore_cache(uint32_t cpuid, uint32_t saved_state)
{
403778d0:	004136        	entry	a1, 32
    esp_cache_resume_ext_mem_cache();
403778d3:	01b2e5        	call8	40379400 <esp_cache_resume_ext_mem_cache>
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    esp_cpu_branch_prediction_enable();
#endif
}
403778d6:	f01d      	retw.n

403778d8 <spi_flash_op_block_func>:
{
403778d8:	004136        	entry	a1, 32
    vTaskSuspendAll();
403778db:	037b65        	call8	4037b090 <vTaskSuspendAll>
    esp_intr_noniram_disable();
403778de:	febc25        	call8	403764a0 <esp_intr_noniram_disable>
    s_flash_op_complete = false;
403778e1:	f3d581        	l32r	a8, 40374838 <_iram_text_start+0x434> (3fc953b2 <s_flash_op_complete>)
403778e4:	00a092        	movi	a9, 0
403778e7:	0020c0        	memw
403778ea:	004892        	s8i	a9, a8, 0
    s_flash_op_can_start = true;
403778ed:	f3cd81        	l32r	a8, 40374824 <_iram_text_start+0x420> (3fc953b3 <s_flash_op_can_start>)
403778f0:	01a092        	movi	a9, 1
403778f3:	0020c0        	memw
403778f6:	004892        	s8i	a9, a8, 0
    while (!s_flash_op_complete) {
403778f9:	f3cf81        	l32r	a8, 40374838 <_iram_text_start+0x434> (3fc953b2 <s_flash_op_complete>)
403778fc:	0020c0        	memw
403778ff:	000882        	l8ui	a8, a8, 0
40377902:	748080        	extui	a8, a8, 0, 8
40377905:	ff0816        	beqz	a8, 403778f9 <spi_flash_op_block_func+0x21>
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
40377908:	f3c981        	l32r	a8, 4037482c <_iram_text_start+0x428> (3fc953b8 <s_flash_op_cache_state>)
4037790b:	a08280        	addx4	a8, a2, a8
4037790e:	0028b2        	l32i	a11, a8, 0
40377911:	02ad      	mov.n	a10, a2
40377913:	fffbe5        	call8	403778d0 <spi_flash_restore_cache>
    esp_intr_noniram_enable();
40377916:	febfe5        	call8	40376514 <esp_intr_noniram_enable>
    xTaskResumeAll();
40377919:	041825        	call8	4037ba9c <xTaskResumeAll>
}
4037791c:	f01d      	retw.n
	...

40377920 <spi_flash_enable_interrupts_caches_and_other_cpu>:
{
40377920:	004136        	entry	a1, 32
40377923:	03eb70        	rsr.prid	a7
40377926:	047d70        	extui	a7, a7, 13, 1
    assert(cpuid == s_flash_op_cpu);
40377929:	f3bb81        	l32r	a8, 40374818 <_iram_text_start+0x414> (3fc92a14 <s_flash_op_cpu>)
4037792c:	0020c0        	memw
4037792f:	002882        	l32i	a8, a8, 0
40377932:	0e1877        	beq	a8, a7, 40377944 <spi_flash_enable_interrupts_caches_and_other_cpu+0x24>
40377935:	f3c1d1        	l32r	a13, 4037483c <_iram_text_start+0x438> (3c025238 <_flash_rodata_start+0x5118>)
40377938:	f3c2c1        	l32r	a12, 40374840 <_iram_text_start+0x43c> (3c027914 <__func__$0>)
4037793b:	c9a0b2        	movi	a11, 201
4037793e:	f3b5a1        	l32r	a10, 40374814 <_iram_text_start+0x410> (3c0251d3 <_flash_rodata_start+0x50b3>)
40377941:	083e65        	call8	4037fd28 <__assert_func>
    assert(!(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED && cpuid != 0));
40377944:	03fee5        	call8	4037b934 <xTaskGetSchedulerState>
40377947:	111a66        	bnei	a10, 1, 4037795c <spi_flash_enable_interrupts_caches_and_other_cpu+0x3c>
4037794a:	00e716        	beqz	a7, 4037795c <spi_flash_enable_interrupts_caches_and_other_cpu+0x3c>
4037794d:	f3bdd1        	l32r	a13, 40374844 <_iram_text_start+0x440> (3c025250 <_flash_rodata_start+0x5130>)
40377950:	f3bcc1        	l32r	a12, 40374840 <_iram_text_start+0x43c> (3c027914 <__func__$0>)
40377953:	cba0b2        	movi	a11, 203
40377956:	f3afa1        	l32r	a10, 40374814 <_iram_text_start+0x410> (3c0251d3 <_flash_rodata_start+0x50b3>)
40377959:	083ce5        	call8	4037fd28 <__assert_func>
    s_flash_op_cpu = -1;
4037795c:	f3af81        	l32r	a8, 40374818 <_iram_text_start+0x414> (3fc92a14 <s_flash_op_cpu>)
4037795f:	f97c      	movi.n	a9, -1
40377961:	0020c0        	memw
40377964:	0899      	s32i.n	a9, a8, 0
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
40377966:	f3b181        	l32r	a8, 4037482c <_iram_text_start+0x428> (3fc953b8 <s_flash_op_cache_state>)
40377969:	a08780        	addx4	a8, a7, a8
4037796c:	08b8      	l32i.n	a11, a8, 0
4037796e:	07ad      	mov.n	a10, a7
40377970:	fff5e5        	call8	403778d0 <spi_flash_restore_cache>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
40377973:	03fc25        	call8	4037b934 <xTaskGetSchedulerState>
40377976:	0a1a26        	beqi	a10, 1, 40377984 <spi_flash_enable_interrupts_caches_and_other_cpu+0x64>
        s_flash_op_complete = true;
40377979:	f3af81        	l32r	a8, 40374838 <_iram_text_start+0x434> (3fc953b2 <s_flash_op_complete>)
4037797c:	190c      	movi.n	a9, 1
4037797e:	0020c0        	memw
40377981:	004892        	s8i	a9, a8, 0
    esp_intr_noniram_enable();
40377984:	201110        	or	a1, a1, a1
40377987:	feb8e5        	call8	40376514 <esp_intr_noniram_enable>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
4037798a:	201110        	or	a1, a1, a1
4037798d:	03fa65        	call8	4037b934 <xTaskGetSchedulerState>
40377990:	051a26        	beqi	a10, 1, 40377999 <spi_flash_enable_interrupts_caches_and_other_cpu+0x79>
        xTaskResumeAll();
40377993:	201110        	or	a1, a1, a1
40377996:	041065        	call8	4037ba9c <xTaskResumeAll>
    spi_flash_op_unlock();
40377999:	f3ab81        	l32r	a8, 40374848 <_iram_text_start+0x444> (4200aec8 <spi_flash_op_unlock>)
4037799c:	0008e0        	callx8	a8
}
4037799f:	f01d      	retw.n
403779a1:	000000        	ill

403779a4 <spi_flash_enable_cache>:
{
403779a4:	004136        	entry	a1, 32
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
403779a7:	00a0b2        	movi	a11, 0
403779aa:	20abb0        	or	a10, a11, a11
403779ad:	fff225        	call8	403778d0 <spi_flash_restore_cache>
}
403779b0:	000090        	retw
	...

403779b4 <spi_flash_cache_enabled>:

bool IRAM_ATTR spi_flash_cache_enabled(void)
{
403779b4:	004136        	entry	a1, 32
    return cache_hal_is_cache_enabled(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403779b7:	02a0b2        	movi	a11, 2
403779ba:	01a0a2        	movi	a10, 1
403779bd:	050565        	call8	4037ca14 <cache_hal_is_cache_enabled>
}
403779c0:	202aa0        	or	a2, a10, a10
403779c3:	f01d      	retw.n
403779c5:	000000        	ill

403779c8 <is_page_mapped_in_cache>:
    esp_mmu_map_get_max_consecutive_free_block_size(caps, MMU_TARGET_FLASH0, &len);
    return len / CONFIG_MMU_PAGE_SIZE;
}

static bool IRAM_ATTR is_page_mapped_in_cache(uint32_t phys_addr, const void **out_ptr)
{
403779c8:	006136        	entry	a1, 48
    *out_ptr = NULL;
403779cb:	080c      	movi.n	a8, 0
403779cd:	0389      	s32i.n	a8, a3, 0
    mmu_mem_caps_t caps = 0;
403779cf:	0189      	s32i.n	a8, a1, 0

    esp_err_t err = esp_mmu_paddr_find_caps(phys_addr, &caps);
403779d1:	01bd      	mov.n	a11, a1
403779d3:	02ad      	mov.n	a10, a2
403779d5:	ffd425        	call8	40377718 <esp_mmu_paddr_find_caps>
    if (err == ESP_OK) {
403779d8:	1afc      	bnez.n	a10, 40377a0d <is_page_mapped_in_cache+0x45>
    // On ESP32, we will always flush all, so always return true, and don't care the vaddr
#if !CONFIG_IDF_TARGET_ESP32
        uint32_t vaddr = 0;
403779da:	080c      	movi.n	a8, 0
403779dc:	1189      	s32i.n	a8, a1, 4
        if (caps & MMU_MEM_CAP_EXEC) {
403779de:	0188      	l32i.n	a8, a1, 0
403779e0:	106807        	bbci	a8, 0, 403779f4 <is_page_mapped_in_cache+0x2c>
            mmu_hal_paddr_to_vaddr(0, phys_addr, MMU_TARGET_FLASH0, MMU_VADDR_INSTRUCTION, &vaddr);
403779e3:	e14b      	addi.n	a14, a1, 4
403779e5:	2d0c      	movi.n	a13, 2
403779e7:	01a0c2        	movi	a12, 1
403779ea:	20b220        	or	a11, a2, a2
403779ed:	052aa5        	call8	4037cc98 <mmu_hal_paddr_to_vaddr>
403779f0:	000406        	j	40377a04 <is_page_mapped_in_cache+0x3c>
403779f3:	c1e200        	mul16u	a14, a2, a0
        } else {
            mmu_hal_paddr_to_vaddr(0, phys_addr, MMU_TARGET_FLASH0, MMU_VADDR_DATA, &vaddr);
403779f6:	04          	.byte	0x4
403779f7:	01a0d2        	movi	a13, 1
403779fa:	20cdd0        	or	a12, a13, a13
403779fd:	02bd      	mov.n	a11, a2
403779ff:	0a0c      	movi.n	a10, 0
40377a01:	052965        	call8	4037cc98 <mmu_hal_paddr_to_vaddr>
        }
        *out_ptr = (void *)vaddr;
40377a04:	1188      	l32i.n	a8, a1, 4
40377a06:	0389      	s32i.n	a8, a3, 0
#endif
        return true;
40377a08:	120c      	movi.n	a2, 1
40377a0a:	000046        	j	40377a0f <is_page_mapped_in_cache+0x47>
    }
    return false;
40377a0d:	020c      	movi.n	a2, 0
}
40377a0f:	f01d      	retw.n
40377a11:	000000        	ill

40377a14 <spi_flash_check_and_flush_cache>:

/* Validates if given flash address has corresponding cache mapping, if yes, flushes cache memories */
IRAM_ATTR bool spi_flash_check_and_flush_cache(size_t start_addr, size_t length)
{
40377a14:	006136        	entry	a1, 48
    bool ret = false;
    /* align start_addr & length to full MMU pages */
    uint32_t page_start_addr = start_addr & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377a17:	f38d81        	l32r	a8, 4037484c <_iram_text_start+0x448> (ffff0000 <_rtc_reserved_end+0x9fef0000>)
40377a1a:	104280        	and	a4, a2, a8
    length += (start_addr - page_start_addr);
40377a1d:	c02240        	sub	a2, a2, a4
40377a20:	223a      	add.n	a2, a2, a3
    length = (length + SPI_FLASH_MMU_PAGE_SIZE - 1) & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377a22:	f29491        	l32r	a9, 40374474 <_iram_text_start+0x70> (ffff <UserFrameTotalSize+0xfeff>)
40377a25:	529a      	add.n	a5, a2, a9
40377a27:	105580        	and	a5, a5, a8
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377a2a:	047d      	mov.n	a7, a4
    bool ret = false;
40377a2c:	020c      	movi.n	a2, 0
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377a2e:	000cc6        	j	40377a65 <spi_flash_check_and_flush_cache+0x51>
        if (addr >= g_rom_flashchip.chip_size) {
40377a31:	f36281        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40377a34:	0888      	l32i.n	a8, a8, 0
40377a36:	1888      	l32i.n	a8, a8, 4
40377a38:	043787        	bltu	a7, a8, 40377a40 <spi_flash_check_and_flush_cache+0x2c>
            return false; /* invalid address */
40377a3b:	020c      	movi.n	a2, 0
40377a3d:	000a46        	j	40377a6a <spi_flash_check_and_flush_cache+0x56>
        }

        const void *vaddr = NULL;
40377a40:	00a082        	movi	a8, 0
40377a43:	006182        	s32i	a8, a1, 0
        if (is_page_mapped_in_cache(addr, &vaddr)) {
40377a46:	01bd      	mov.n	a11, a1
40377a48:	07ad      	mov.n	a10, a7
40377a4a:	fff7e5        	call8	403779c8 <is_page_mapped_in_cache>
40377a4d:	0a6d      	mov.n	a6, a10
40377a4f:	00da16        	beqz	a10, 40377a60 <spi_flash_check_and_flush_cache+0x4c>
#if CONFIG_IDF_TARGET_ESP32
            cache_sync();
            return true;
#else // CONFIG_IDF_TARGET_ESP32
            if (vaddr != NULL) {
40377a52:	0021a2        	l32i	a10, a1, 0
40377a55:	007a16        	beqz	a10, 40377a60 <spi_flash_check_and_flush_cache+0x4c>
                cache_hal_invalidate_addr((uint32_t)vaddr, SPI_FLASH_MMU_PAGE_SIZE);
40377a58:	f37eb1        	l32r	a11, 40374850 <_iram_text_start+0x44c> (10000 <UserFrameTotalSize+0xff00>)
40377a5b:	0507a5        	call8	4037cad4 <cache_hal_invalidate_addr>
                ret = true;
40377a5e:	062d      	mov.n	a2, a6
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377a60:	f37c81        	l32r	a8, 40374850 <_iram_text_start+0x44c> (10000 <UserFrameTotalSize+0xff00>)
40377a63:	778a      	add.n	a7, a7, a8
40377a65:	845a      	add.n	a8, a4, a5
40377a67:	c63787        	bltu	a7, a8, 40377a31 <spi_flash_check_and_flush_cache+0x1d>
#endif // CONFIG_IDF_TARGET_ESP32

        }
    }
    return ret;
}
40377a6a:	f01d      	retw.n

40377a6c <spi_flash_guard_set>:
};

static const spi_flash_guard_funcs_t *s_flash_guard_ops;

void IRAM_ATTR spi_flash_guard_set(const spi_flash_guard_funcs_t *funcs)
{
40377a6c:	004136        	entry	a1, 32
    s_flash_guard_ops = funcs;
40377a6f:	f37981        	l32r	a8, 40374854 <_iram_text_start+0x450> (3fc953c0 <s_flash_guard_ops>)
40377a72:	0829      	s32i.n	a2, a8, 0
}
40377a74:	f01d      	retw.n
	...

40377a78 <esp_mspi_pin_init>:
#endif // ESP_ROM_HAS_SPI_FLASH_MMAP
}
#endif

void IRAM_ATTR esp_mspi_pin_init(void)
{
40377a78:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_FLASH_OPI_MODE
    bool octal_mspi_required = bootloader_flash_is_octal_mode_enabled();
40377a7b:	ffb425        	call8	403775bc <bootloader_flash_is_octal_mode_enabled>
#if CONFIG_SPIRAM_MODE_OCT
    octal_mspi_required |= true;
#endif

    if (octal_mspi_required) {
40377a7e:	008a16        	beqz	a10, 40377a8a <esp_mspi_pin_init+0x12>
        esp_rom_opiflash_pin_config();
40377a81:	f37581        	l32r	a8, 40374858 <_iram_text_start+0x454> (40000894 <esp_rom_opiflash_pin_config>)
40377a84:	0008e0        	callx8	a8
        mspi_timing_set_pin_drive_strength();
40377a87:	006f65        	call8	4037817c <mspi_timing_set_pin_drive_strength>
    }
    //Set F4R4 board pin drive strength. TODO: IDF-3663
#endif
}
40377a8a:	000090        	retw
40377a8d:	000000        	ill

40377a90 <spi_flash_init_chip_state>:
    }
    esp_gpio_reserve(reserve_pin_mask);
}

esp_err_t IRAM_ATTR spi_flash_init_chip_state(void)
{
40377a90:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_FLASH_OPI_MODE
    if (bootloader_flash_is_octal_mode_enabled()) {
40377a93:	ffb2a5        	call8	403775bc <bootloader_flash_is_octal_mode_enabled>
40377a96:	00fa16        	beqz	a10, 40377aa9 <spi_flash_init_chip_state+0x19>
        return esp_opiflash_init(rom_spiflash_legacy_data->chip.device_id);
40377a99:	f34881        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40377a9c:	002882        	l32i	a8, a8, 0
40377a9f:	08a8      	l32i.n	a10, a8, 0
40377aa1:	0a3aa5        	call8	40381e4c <esp_opiflash_init>
40377aa4:	0a2d      	mov.n	a2, a10
40377aa6:	000106        	j	40377aae <spi_flash_init_chip_state+0x1e>
    }
#endif
#if CONFIG_SPI_FLASH_HPM_ON
        return spi_flash_enable_high_performance_mode();
40377aa9:	0a1ae5        	call8	40381c58 <spi_flash_enable_high_performance_mode>
40377aac:	0a2d      	mov.n	a2, a10
#endif // CONFIG_SPI_FLASH_HPM_ON
    return ESP_OK;
}
40377aae:	f01d      	retw.n

40377ab0 <read_id_core>:
    // Done: all fields on 'chip' are initialised
    return rom_spiflash_api_funcs->end(chip, err);
}

static esp_err_t IRAM_ATTR read_id_core(esp_flash_t* chip, uint32_t* out_id, bool sanity_check)
{
40377ab0:	006136        	entry	a1, 48
40377ab3:	027d      	mov.n	a7, a2
    bool installed = esp_flash_chip_driver_initialized(chip);
40377ab5:	02ad      	mov.n	a10, a2
40377ab7:	085625        	call8	40380018 <esp_flash_chip_driver_initialized>
40377aba:	0a6d      	mov.n	a6, a10
    esp_err_t err = rom_spiflash_api_funcs->start(chip);
40377abc:	f36981        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
40377abf:	0888      	l32i.n	a8, a8, 0
40377ac1:	0888      	l32i.n	a8, a8, 0
40377ac3:	02ad      	mov.n	a10, a2
40377ac5:	0008e0        	callx8	a8
40377ac8:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377aca:	04ca56        	bnez	a10, 40377b1a <read_id_core+0x6a>
        return err;
    }

    esp_err_t (*read_id_func)(void*, uint32_t*);
    void* read_id_arg;
    if (installed && chip->chip_drv->read_id) {
40377acd:	568c      	beqz.n	a6, 40377ad6 <read_id_core+0x26>
40377acf:	1788      	l32i.n	a8, a7, 4
40377ad1:	182822        	l32i	a2, a8, 96
40377ad4:	92cc      	bnez.n	a2, 40377ae1 <read_id_core+0x31>
        read_id_func = (void*)chip->chip_drv->read_id;
        read_id_arg = (void*)chip;
    } else {
        //default option if the chip is not detected/chosen yet.
        read_id_func = (void*)chip->host->driver->read_id;
40377ad6:	0768      	l32i.n	a6, a7, 0
40377ad8:	0688      	l32i.n	a8, a6, 0
40377ada:	2828      	l32i.n	a2, a8, 8
        read_id_arg = (void*)chip->host;
40377adc:	0000c6        	j	40377ae3 <read_id_core+0x33>
40377adf:	00          	.byte	00
40377ae0:	076d00        	ee.stf.64.xp	f6, f0, a0, a13
    }

    // Inner function fails if it sees all-ones or all-zeroes.
    err = read_id_func(read_id_arg, out_id);
40377ae3:	03bd      	mov.n	a11, a3
40377ae5:	06ad      	mov.n	a10, a6
40377ae7:	0002e0        	callx8	a2
40377aea:	0abd      	mov.n	a11, a10

    if (sanity_check && err == ESP_OK) {
40377aec:	40fa80        	nsau	a8, a10
40377aef:	418580        	srli	a8, a8, 5
40377af2:	160847        	bnone	a8, a4, 40377b0c <read_id_core+0x5c>
        // Send RDID command twice, check for a matching result and retry in case we just powered on
        uint32_t new_id;
        err = read_id_func(read_id_arg, &new_id);
40377af5:	20b110        	or	a11, a1, a1
40377af8:	20a660        	or	a10, a6, a6
40377afb:	0002e0        	callx8	a2
40377afe:	0abd      	mov.n	a11, a10
        if (err == ESP_OK && (new_id != *out_id)) {
40377b00:	8acc      	bnez.n	a10, 40377b0c <read_id_core+0x5c>
40377b02:	0398      	l32i.n	a9, a3, 0
40377b04:	0188      	l32i.n	a8, a1, 0
40377b06:	021987        	beq	a9, a8, 40377b0c <read_id_core+0x5c>
            err = ESP_ERR_FLASH_NOT_INITIALISED;
40377b09:	f354b1        	l32r	a11, 4037485c <_iram_text_start+0x458> (6003 <UserFrameTotalSize+0x5f03>)
        }
    }

    return rom_spiflash_api_funcs->end(chip, err);
40377b0c:	f35581        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
40377b0f:	0888      	l32i.n	a8, a8, 0
40377b11:	1888      	l32i.n	a8, a8, 4
40377b13:	07ad      	mov.n	a10, a7
40377b15:	0008e0        	callx8	a8
40377b18:	0a2d      	mov.n	a2, a10
}
40377b1a:	f01d      	retw.n

40377b1c <on_spi_check_yield>:
//
// Valid task execution interval: continuous time with the cache enabled, which is longer than
// CONFIG_SPI_FLASH_ERASE_YIELD_TICKS. Yield time shorter than CONFIG_SPI_FLASH_ERASE_YIELD_TICKS is
// not treated as valid interval.
static inline IRAM_ATTR bool on_spi_check_yield(app_func_arg_t* ctx)
{
40377b1c:	004136        	entry	a1, 32
#ifdef CONFIG_SPI_FLASH_YIELD_DURING_ERASE
    uint32_t time = esp_system_get_time();
40377b1f:	fd6ae5        	call8	403751cc <esp_system_get_time>
    // We handle the reset here instead of in `on_spi_acquired()`, when acquire() and release() is
    // larger than CONFIG_SPI_FLASH_ERASE_YIELD_TICKS, to save one `esp_system_get_time()` call
    if ((time - ctx->released_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_TICKS * portTICK_PERIOD_MS * 1000) {
40377b22:	032282        	l32i	a8, a2, 12
40377b25:	c08a80        	sub	a8, a10, a8
40377b28:	f34f91        	l32r	a9, 40374864 <_iram_text_start+0x460> (270f <UserFrameTotalSize+0x260f>)
40377b2b:	09b987        	bgeu	a9, a8, 40377b38 <on_spi_check_yield+0x1c>
        // Reset the acquired time as if the yield has just happened.
        ctx->acquired_since_us = time;
40377b2e:	0262a2        	s32i	a10, a2, 8
    } else if ((time - ctx->acquired_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS * 1000) {
        return true;
    }
#endif
    return false;
40377b31:	00a022        	movi	a2, 0
40377b34:	000486        	j	40377b4a <on_spi_check_yield+0x2e>
40377b37:	228800        	orb	b8, b8, b0
    } else if ((time - ctx->acquired_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS * 1000) {
40377b3a:	c0aa80        	sub	a10, a10, a8
40377b3d:	f34a81        	l32r	a8, 40374868 <_iram_text_start+0x464> (4e1f <UserFrameTotalSize+0x4d1f>)
40377b40:	0438a7        	bltu	a8, a10, 40377b48 <on_spi_check_yield+0x2c>
    return false;
40377b43:	020c      	movi.n	a2, 0
40377b45:	000046        	j	40377b4a <on_spi_check_yield+0x2e>
        return true;
40377b48:	120c      	movi.n	a2, 1
}
40377b4a:	f01d      	retw.n

40377b4c <cache_enable>:
{
40377b4c:	004136        	entry	a1, 32
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377b4f:	ffdd25        	call8	40377920 <spi_flash_enable_interrupts_caches_and_other_cpu>
}
40377b52:	f01d      	retw.n

40377b54 <spi1_end>:
{
40377b54:	004136        	entry	a1, 32
    cache_enable(NULL);
40377b57:	00a0a2        	movi	a10, 0
40377b5a:	ffff25        	call8	40377b4c <cache_enable>
static inline IRAM_ATTR void on_spi_released(app_func_arg_t* ctx)
{
#ifdef CONFIG_SPI_FLASH_YIELD_DURING_ERASE
    ctx->released_since_us = esp_system_get_time();
40377b5d:	fd66e5        	call8	403751cc <esp_system_get_time>
40377b60:	0362a2        	s32i	a10, a2, 12
}
40377b63:	00a022        	movi	a2, 0
40377b66:	f01d      	retw.n

40377b68 <cache_disable>:
{
40377b68:	004136        	entry	a1, 32
    spi_flash_disable_interrupts_caches_and_other_cpu();
40377b6b:	ffc965        	call8	40377800 <spi_flash_disable_interrupts_caches_and_other_cpu>
}
40377b6e:	f01d      	retw.n

40377b70 <spi1_start>:
{
40377b70:	004136        	entry	a1, 32
    cache_disable(NULL);
40377b73:	0a0c      	movi.n	a10, 0
40377b75:	ffff25        	call8	40377b68 <cache_disable>
}
40377b78:	020c      	movi.n	a2, 0
40377b7a:	f01d      	retw.n

40377b7c <end>:

    return ESP_OK;
}

static IRAM_ATTR esp_err_t end(void *arg)
{
40377b7c:	004136        	entry	a1, 32
#if CONFIG_IDF_TARGET_ESP32
    Cache_Read_Enable(0);
    Cache_Read_Enable(1);
#else
    cache_hal_resume(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377b7f:	02a0b2        	movi	a11, 2
40377b82:	01a0a2        	movi	a10, 1
40377b85:	04e225        	call8	4037c9a8 <cache_hal_resume>
#if SOC_BRANCH_PREDICTOR_SUPPORTED
    esp_cpu_branch_prediction_enable();
#endif

    return ESP_OK;
}
40377b88:	00a022        	movi	a2, 0
40377b8b:	f01d      	retw.n
40377b8d:	000000        	ill

40377b90 <start>:
{
40377b90:	004136        	entry	a1, 32
    cache_hal_suspend(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40377b93:	02a0b2        	movi	a11, 2
40377b96:	01a0a2        	movi	a10, 1
40377b99:	04dd65        	call8	4037c970 <cache_hal_suspend>
}
40377b9c:	00a022        	movi	a2, 0
40377b9f:	f01d      	retw.n
40377ba1:	000000        	ill

40377ba4 <esp_crosscore_isr>:
{
    portYIELD_FROM_ISR();
}

static void IRAM_ATTR esp_crosscore_isr(void *arg)
{
40377ba4:	004136        	entry	a1, 32
40377ba7:	03eb80        	rsr.prid	a8
40377baa:	048d80        	extui	a8, a8, 13, 1
/**
 * @brief Clear the crosscore interrupt that just occurred on the current core
 */
FORCE_INLINE_ATTR void crosscore_int_ll_clear_interrupt(int core_id)
{
    if (core_id == 0) {
40377bad:	b8cc      	bnez.n	a8, 40377bbc <esp_crosscore_isr+0x18>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, 0);
40377baf:	f32f81        	l32r	a8, 4037486c <_iram_text_start+0x468> (600c0030 <SYSTEM+0x30>)
40377bb2:	090c      	movi.n	a9, 0
40377bb4:	0020c0        	memw
40377bb7:	0899      	s32i.n	a9, a8, 0
40377bb9:	000246        	j	40377bc6 <esp_crosscore_isr+0x22>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, 0);
40377bbc:	f32d81        	l32r	a8, 40374870 <_iram_text_start+0x46c> (600c0034 <SYSTEM+0x34>)
40377bbf:	090c      	movi.n	a9, 0
40377bc1:	0020c0        	memw
40377bc4:	0899      	s32i.n	a9, a8, 0
40377bc6:	fb7c      	movi.n	a11, -1
40377bc8:	f32ba1        	l32r	a10, 40374874 <_iram_text_start+0x470> (3fc92a7c <reason_spinlock>)
40377bcb:	0244a5        	call8	4037a014 <xPortEnterCriticalTimeout>
    //Clear the interrupt first.
    crosscore_int_ll_clear_interrupt(esp_cpu_get_core_id());

    //Grab the reason and clear it.
    portENTER_CRITICAL_ISR(&reason_spinlock);
    my_reason_val = *my_reason;
40377bce:	0020c0        	memw
40377bd1:	002272        	l32i	a7, a2, 0
    *my_reason = 0;
40377bd4:	080c      	movi.n	a8, 0
40377bd6:	0020c0        	memw
40377bd9:	006282        	s32i	a8, a2, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40377bdc:	f326a1        	l32r	a10, 40374874 <_iram_text_start+0x470> (3fc92a7c <reason_spinlock>)
40377bdf:	025865        	call8	4037a164 <vPortExitCritical>

    //Check what we need to do.
    if (my_reason_val & REASON_YIELD) {
40377be2:	026707        	bbci	a7, 0, 40377be8 <esp_crosscore_isr+0x44>
    portYIELD_FROM_ISR();
40377be5:	0267a5        	call8	4037a260 <_frxt_setup_switch>
    if (my_reason_val & REASON_GDB_CALL) {
        update_breakpoints();
    }
#endif // !CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME

    if (my_reason_val & REASON_PRINT_BACKTRACE) {
40377be8:	056727        	bbci	a7, 2, 40377bf1 <esp_crosscore_isr+0x4d>
        esp_backtrace_print(100);
40377beb:	64a0a2        	movi	a10, 100
40377bee:	fe0525        	call8	40375c40 <esp_backtrace_print>
    }

#if CONFIG_ESP_TASK_WDT_EN
    if (my_reason_val & REASON_TWDT_ABORT) {
40377bf1:	076747        	bbci	a7, 4, 40377bfc <esp_crosscore_isr+0x58>
        extern void task_wdt_timeout_abort(bool);
        /* Called from a crosscore interrupt, thus, we are not the core that received
         * the TWDT interrupt, call the function with `false` as a parameter. */
        task_wdt_timeout_abort(false);
40377bf4:	0a0c      	movi.n	a10, 0
40377bf6:	f32081        	l32r	a8, 40374878 <_iram_text_start+0x474> (4200b5dc <task_wdt_timeout_abort>)
40377bf9:	0008e0        	callx8	a8
    }
#endif // CONFIG_ESP_TASK_WDT_EN

}
40377bfc:	f01d      	retw.n
	...

40377c00 <esp_crosscore_int_send>:
#endif
    ESP_ERROR_CHECK(err);
}

static void IRAM_ATTR esp_crosscore_int_send(int core_id, uint32_t reason_mask)
{
40377c00:	004136        	entry	a1, 32
    assert(core_id < CONFIG_FREERTOS_NUMBER_OF_CORES);
40377c03:	01a082        	movi	a8, 1
40377c06:	0ea827        	bge	a8, a2, 40377c18 <esp_crosscore_int_send+0x18>
40377c09:	f31cd1        	l32r	a13, 4037487c <_iram_text_start+0x478> (3c0256cc <_flash_rodata_start+0x55ac>)
40377c0c:	f31dc1        	l32r	a12, 40374880 <_iram_text_start+0x47c> (3c027ab8 <__func__$0>)
40377c0f:	6ea0b2        	movi	a11, 110
40377c12:	f31ca1        	l32r	a10, 40374884 <_iram_text_start+0x480> (3c025714 <_flash_rodata_start+0x55f4>)
40377c15:	081125        	call8	4037fd28 <__assert_func>
40377c18:	fb7c      	movi.n	a11, -1
40377c1a:	f316a1        	l32r	a10, 40374874 <_iram_text_start+0x470> (3fc92a7c <reason_spinlock>)
40377c1d:	023f65        	call8	4037a014 <xPortEnterCriticalTimeout>
    //Mark the reason we interrupt the other CPU
    portENTER_CRITICAL_ISR(&reason_spinlock);
    reason[core_id] |= reason_mask;
40377c20:	f31a81        	l32r	a8, 40374888 <_iram_text_start+0x484> (3fc953d0 <reason>)
40377c23:	a08280        	addx4	a8, a2, a8
40377c26:	0020c0        	memw
40377c29:	0898      	l32i.n	a9, a8, 0
40377c2b:	209930        	or	a9, a9, a3
40377c2e:	0020c0        	memw
40377c31:	0899      	s32i.n	a9, a8, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40377c33:	f310a1        	l32r	a10, 40374874 <_iram_text_start+0x470> (3fc92a7c <reason_spinlock>)
40377c36:	0252e5        	call8	4037a164 <vPortExitCritical>
 *
 * @param core_id Core to trigger an interrupt on.
 */
FORCE_INLINE_ATTR void crosscore_int_ll_trigger_interrupt(int core_id)
{
    if (core_id == 0) {
40377c39:	b2cc      	bnez.n	a2, 40377c48 <esp_crosscore_int_send+0x48>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, SYSTEM_CPU_INTR_FROM_CPU_0);
40377c3b:	f30c81        	l32r	a8, 4037486c <_iram_text_start+0x468> (600c0030 <SYSTEM+0x30>)
40377c3e:	190c      	movi.n	a9, 1
40377c40:	0020c0        	memw
40377c43:	0899      	s32i.n	a9, a8, 0
40377c45:	000246        	j	40377c52 <esp_crosscore_int_send+0x52>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, SYSTEM_CPU_INTR_FROM_CPU_1);
40377c48:	f30a81        	l32r	a8, 40374870 <_iram_text_start+0x46c> (600c0034 <SYSTEM+0x34>)
40377c4b:	190c      	movi.n	a9, 1
40377c4d:	0020c0        	memw
40377c50:	0899      	s32i.n	a9, a8, 0
    //Poke the other CPU.
    crosscore_int_ll_trigger_interrupt(core_id);
}
40377c52:	f01d      	retw.n

40377c54 <esp_crosscore_int_send_yield>:

void IRAM_ATTR esp_crosscore_int_send_yield(int core_id)
{
40377c54:	004136        	entry	a1, 32
40377c57:	20a220        	or	a10, a2, a2
    esp_crosscore_int_send(core_id, REASON_YIELD);
40377c5a:	01a0b2        	movi	a11, 1
40377c5d:	fffa25        	call8	40377c00 <esp_crosscore_int_send>
}
40377c60:	000090        	retw
	...

40377c64 <esp_crosscore_int_send_print_backtrace>:
{
    esp_crosscore_int_send(core_id, REASON_GDB_CALL);
}

void IRAM_ATTR esp_crosscore_int_send_print_backtrace(int core_id)
{
40377c64:	004136        	entry	a1, 32
40377c67:	20a220        	or	a10, a2, a2
    esp_crosscore_int_send(core_id, REASON_PRINT_BACKTRACE);
40377c6a:	04a0b2        	movi	a11, 4
40377c6d:	fff925        	call8	40377c00 <esp_crosscore_int_send>
}
40377c70:	000090        	retw
	...

40377c74 <esp_crosscore_int_send_twdt_abort>:

#if CONFIG_ESP_TASK_WDT_EN
void IRAM_ATTR esp_crosscore_int_send_twdt_abort(int core_id)
{
40377c74:	004136        	entry	a1, 32
40377c77:	20a220        	or	a10, a2, a2
    esp_crosscore_int_send(core_id, REASON_TWDT_ABORT);
40377c7a:	10a0b2        	movi	a11, 16
40377c7d:	fff825        	call8	40377c00 <esp_crosscore_int_send>
}
40377c80:	000090        	retw
	...

40377c84 <esp_task_wdt_impl_timer_feed>:
#endif
    }
}

esp_err_t TASK_WDT_FN_ATTR esp_task_wdt_impl_timer_feed(twdt_ctx_t obj)
{
40377c84:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx == NULL) {
40377c87:	d29c      	beqz.n	a2, 40377ca8 <esp_task_wdt_impl_timer_feed+0x24>
        ret = ESP_ERR_INVALID_STATE;
    }

    if (ret == ESP_OK) {
        wdt_hal_write_protect_disable(&ctx->hal);
40377c89:	02ad      	mov.n	a10, a2
40377c8b:	f23581        	l32r	a8, 40374560 <_iram_text_start+0x15c> (40000de0 <wdt_hal_write_protect_disable>)
40377c8e:	0008e0        	callx8	a8
        wdt_hal_feed(&ctx->hal);
40377c91:	02ad      	mov.n	a10, a2
40377c93:	f23d81        	l32r	a8, 40374588 <_iram_text_start+0x184> (40000e1c <wdt_hal_feed>)
40377c96:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
40377c99:	02ad      	mov.n	a10, a2
40377c9b:	f23481        	l32r	a8, 4037456c <_iram_text_start+0x168> (40000dec <wdt_hal_write_protect_enable>)
40377c9e:	0008e0        	callx8	a8
    esp_err_t ret = ESP_OK;
40377ca1:	020c      	movi.n	a2, 0
40377ca3:	000106        	j	40377cab <esp_task_wdt_impl_timer_feed+0x27>
40377ca6:	220000        	orb	b0, b0, b0
        ret = ESP_ERR_INVALID_STATE;
40377ca9:	1d03a1        	l32r	a10, 4033f0b8 <rom_rx_gain_force+0x338c8c>
    }

    return ret;
}
40377cac:	0000f0        	callx12	a0
	...

40377cb0 <_xt_panic>:
    .literal_position
    .align      4

_xt_panic:
    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
40377cb0:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
40377cb2:	ffd112        	addmi	a1, a1, 0xffffff00
40377cb5:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40377cb8:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
40377cba:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
40377cbd:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40377cc0:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40377cc2:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40377cc5:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40377cc7:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40377cca:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
40377ccc:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40377ccf:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40377cd1:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40377cd4:	0a4705        	call0	40382148 <_xt_context_save>

    /* Save exc cause and vaddr into exception frame */
    rsr     a0, EXCCAUSE
40377cd7:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40377cda:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40377cdd:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40377ce0:	156102        	s32i	a0, a1, 84

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
40377ce3:	f29c01        	l32r	a0, 40374754 <_iram_text_start+0x350> (40024 <UserFrameTotalSize+0x3ff24>)
    wsr     a0, PS
40377ce6:	13e600        	wsr.ps	a0

    //Call panic handler
    mov     a6,sp
40377ce9:	016d      	mov.n	a6, a1
    call4 panicHandler
40377ceb:	fdcfd5        	call4	403759e8 <panicHandler>

    ret
40377cee:	f00d      	ret.n

40377cf0 <esp_reset_reason_set_hint>:
/* Weak versions of reset reason hint functions.
 * If these weren't provided, reset reason code would be linked into the app
 * even if the app never called esp_reset_reason().
 */
void IRAM_ATTR __attribute__((weak)) esp_reset_reason_set_hint(esp_reset_reason_t hint)
{
40377cf0:	004136        	entry	a1, 32
}
40377cf3:	f01d      	retw.n
40377cf5:	000000        	ill

40377cf8 <esp_reset_reason_get_hint>:

esp_reset_reason_t IRAM_ATTR  __attribute__((weak)) esp_reset_reason_get_hint(void)
{
40377cf8:	004136        	entry	a1, 32
    return ESP_RST_UNKNOWN;
}
40377cfb:	020c      	movi.n	a2, 0
40377cfd:	f01d      	retw.n
	...

40377d00 <esp_mspi_32bit_address_flash_feature_check>:
#endif // SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE
}

#if !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM  // IDF-10019
esp_err_t IRAM_ATTR esp_mspi_32bit_address_flash_feature_check(void)
{
40377d00:	004136        	entry	a1, 32
        return ESP_ERR_NOT_SUPPORTED;
    }
#endif

    return ESP_OK;
}
40377d03:	020c      	movi.n	a2, 0
40377d05:	f01d      	retw.n
	...

40377d08 <esp_pm_lock_acquire>:
    free(handle);
    return ESP_OK;
}

esp_err_t IRAM_ATTR esp_pm_lock_acquire(esp_pm_lock_handle_t handle)
{
40377d08:	004136        	entry	a1, 32
        handle->times_taken++;
#endif
    }
    portEXIT_CRITICAL_SAFE(&handle->spinlock);
    return ESP_OK;
}
40377d0b:	06a122        	movi	a2, 0x106
40377d0e:	f01d      	retw.n

40377d10 <esp_pm_lock_release>:

esp_err_t IRAM_ATTR esp_pm_lock_release(esp_pm_lock_handle_t handle)
{
40377d10:	004136        	entry	a1, 32
        esp_pm_impl_switch_mode(handle->mode, MODE_UNLOCK, now);
    }
out:
    portEXIT_CRITICAL_SAFE(&handle->spinlock);
    return ret;
}
40377d13:	06a122        	movi	a2, 0x106
40377d16:	f01d      	retw.n

40377d18 <esp_cpu_compare_and_set>:
#if __XTENSA__ && XCHAL_HAVE_S32C1I && CONFIG_SPIRAM
static DRAM_ATTR uint32_t external_ram_cas_lock = 0;
#endif

bool esp_cpu_compare_and_set(volatile uint32_t *addr, uint32_t compare_value, uint32_t new_value)
{
40377d18:	004136        	entry	a1, 32
    temp = *addr;
    *addr = temp;
#endif
    // Atomic compare and set using S32C1I instruction
    uint32_t old_value = new_value;
    __asm__ __volatile__ (
40377d1b:	130c30        	wsr.scompare1	a3
40377d1e:	00e242        	s32c1i	a4, a2, 0
        "S32C1I %0, %1, 0 \n"
        :"=r"(old_value)
        :"r"(addr), "r"(compare_value), "0"(old_value)
    );

    return (old_value == compare_value);
40377d21:	c03340        	sub	a3, a3, a4
    return ret;

#else // __riscv
    return rv_utils_compare_and_set(addr, compare_value, new_value);
#endif
}
40377d24:	40f320        	nsau	a2, a3
40377d27:	412520        	srli	a2, a2, 5
40377d2a:	f01d      	retw.n

40377d2c <esp_cpu_stall>:
{
40377d2c:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
40377d2f:	01a082        	movi	a8, 1
40377d32:	0eb827        	bgeu	a8, a2, 40377d44 <esp_cpu_stall+0x18>
40377d35:	f2d7d1        	l32r	a13, 40374894 <_iram_text_start+0x490> (3c0221c4 <_flash_rodata_start+0x20a4>)
40377d38:	f2d8c1        	l32r	a12, 40374898 <_iram_text_start+0x494> (3c026b84 <__func__$2>)
40377d3b:	21a0b2        	movi	a11, 33
40377d3e:	f2d7a1        	l32r	a10, 4037489c <_iram_text_start+0x498> (3c022210 <_flash_rodata_start+0x20f0>)
40377d41:	07fe65        	call8	4037fd28 <__assert_func>
    uint32_t rtc_cntl_c0_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40377d44:	00c256        	bnez	a2, 40377d54 <esp_cpu_stall+0x28>
    uint32_t rtc_cntl_c1_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40377d47:	f2d181        	l32r	a8, 4037488c <_iram_text_start+0x488> (fc000000 <_rtc_reserved_end+0x9bf00000>)
    uint32_t rtc_cntl_c0_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40377d4a:	2d0c      	movi.n	a13, 2
40377d4c:	c90c      	movi.n	a9, 12
    uint32_t rtc_cntl_c1_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
40377d4e:	ac1c      	movi.n	a12, 26
40377d50:	000246        	j	40377d5d <esp_cpu_stall+0x31>
40377d53:	00          	.byte	00
    uint32_t rtc_cntl_c1_m = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40377d54:	f2cf81        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3f00000 <UserFrameTotalSize+0x3efff00>)
40377d57:	0d0c      	movi.n	a13, 0
40377d59:	390c      	movi.n	a9, 3
    uint32_t rtc_cntl_c1_s = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
40377d5b:	4c1c      	movi.n	a12, 20
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0_m);
40377d5d:	f2d0a1        	l32r	a10, 403748a0 <_iram_text_start+0x49c> (60008000 <RTCCNTL>)
40377d60:	0020c0        	memw
40377d63:	0ab8      	l32i.n	a11, a10, 0
40377d65:	1099b0        	and	a9, a9, a11
40377d68:	3099b0        	xor	a9, a9, a11
40377d6b:	0020c0        	memw
40377d6e:	0a99      	s32i.n	a9, a10, 0
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, 2 << rtc_cntl_c0_s);
40377d70:	0020c0        	memw
40377d73:	0a98      	l32i.n	a9, a10, 0
40377d75:	2b0c      	movi.n	a11, 2
40377d77:	401d00        	ssl	a13
40377d7a:	a1bb00        	sll	a11, a11
40377d7d:	2099b0        	or	a9, a9, a11
40377d80:	0020c0        	memw
40377d83:	0a99      	s32i.n	a9, a10, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1_m);
40377d85:	f2c791        	l32r	a9, 403748a4 <_iram_text_start+0x4a0> (600080bc <RTCCNTL+0xbc>)
40377d88:	0020c0        	memw
40377d8b:	09a8      	l32i.n	a10, a9, 0
40377d8d:	1088a0        	and	a8, a8, a10
40377d90:	3088a0        	xor	a8, a8, a10
40377d93:	0020c0        	memw
40377d96:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, 0x21 << rtc_cntl_c1_s);
40377d98:	0020c0        	memw
40377d9b:	0988      	l32i.n	a8, a9, 0
40377d9d:	1a2c      	movi.n	a10, 33
40377d9f:	401c00        	ssl	a12
40377da2:	a1aa00        	sll	a10, a10
40377da5:	2088a0        	or	a8, a8, a10
40377da8:	0020c0        	memw
40377dab:	0989      	s32i.n	a8, a9, 0
}
40377dad:	f01d      	retw.n
	...

40377db0 <esp_cpu_unstall>:
{
40377db0:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
40377db3:	01a082        	movi	a8, 1
40377db6:	0eb827        	bgeu	a8, a2, 40377dc8 <esp_cpu_unstall+0x18>
40377db9:	f2b6d1        	l32r	a13, 40374894 <_iram_text_start+0x490> (3c0221c4 <_flash_rodata_start+0x20a4>)
40377dbc:	f2bbc1        	l32r	a12, 403748a8 <_iram_text_start+0x4a4> (3c026b74 <__func__$1>)
40377dbf:	29a0b2        	movi	a11, 41
40377dc2:	f2b6a1        	l32r	a10, 4037489c <_iram_text_start+0x498> (3c022210 <_flash_rodata_start+0x20f0>)
40377dc5:	07f625        	call8	4037fd28 <__assert_func>
    uint32_t rtc_cntl_c0 = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40377dc8:	004256        	bnez	a2, 40377dd0 <esp_cpu_unstall+0x20>
40377dcb:	c80c      	movi.n	a8, 12
40377dcd:	000046        	j	40377dd2 <esp_cpu_unstall+0x22>
40377dd0:	380c      	movi.n	a8, 3
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0);
40377dd2:	f2b391        	l32r	a9, 403748a0 <_iram_text_start+0x49c> (60008000 <RTCCNTL>)
40377dd5:	0020c0        	memw
40377dd8:	09a8      	l32i.n	a10, a9, 0
40377dda:	1088a0        	and	a8, a8, a10
40377ddd:	3088a0        	xor	a8, a8, a10
40377de0:	0020c0        	memw
40377de3:	0989      	s32i.n	a8, a9, 0
    int rtc_cntl_c1 = (cpu_no == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40377de5:	42cc      	bnez.n	a2, 40377ded <esp_cpu_unstall+0x3d>
40377de7:	f2a981        	l32r	a8, 4037488c <_iram_text_start+0x488> (fc000000 <_rtc_reserved_end+0x9bf00000>)
40377dea:	000086        	j	40377df0 <esp_cpu_unstall+0x40>
40377ded:	f2a881        	l32r	a8, 40374890 <_iram_text_start+0x48c> (3f00000 <UserFrameTotalSize+0x3efff00>)
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1);
40377df0:	f2ad91        	l32r	a9, 403748a4 <_iram_text_start+0x4a0> (600080bc <RTCCNTL+0xbc>)
40377df3:	0020c0        	memw
40377df6:	09a8      	l32i.n	a10, a9, 0
40377df8:	1088a0        	and	a8, a8, a10
40377dfb:	3088a0        	xor	a8, a8, a10
40377dfe:	0020c0        	memw
40377e01:	0989      	s32i.n	a8, a9, 0
}
40377e03:	f01d      	retw.n
40377e05:	000000        	ill

40377e08 <esp_cpu_wait_for_intr>:
{
40377e08:	004136        	entry	a1, 32
    asm volatile ("waiti 0\n");
40377e0b:	007000        	waiti	0
}
40377e0e:	f01d      	retw.n

40377e10 <esp_clk_slowclk_cal_get>:
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    clk_ll_rtc_slow_store_cal(new_cal);
}

uint32_t esp_clk_slowclk_cal_get(void)
{
40377e10:	004136        	entry	a1, 32
 *
 * @return The calibration value of slow clock period in microseconds, in Q13.19 fixed point format
 */
static inline __attribute__((always_inline)) uint32_t clk_ll_rtc_slow_load_cal(void)
{
    return REG_READ(RTC_SLOW_CLK_CAL_REG);
40377e13:	f2a681        	l32r	a8, 403748ac <_iram_text_start+0x4a8> (60008054 <RTCCNTL+0x54>)
40377e16:	0020c0        	memw
40377e19:	0828      	l32i.n	a2, a8, 0
    return clk_ll_rtc_slow_load_cal();
}
40377e1b:	f01d      	retw.n
40377e1d:	000000        	ill

40377e20 <esp_clk_slowclk_cal_set>:
{
40377e20:	004136        	entry	a1, 32
    esp_rtc_get_time_us();
40377e23:	0000e5        	call8	40377e30 <esp_rtc_get_time_us>
    REG_WRITE(RTC_SLOW_CLK_CAL_REG, cal_value);
40377e26:	f2a181        	l32r	a8, 403748ac <_iram_text_start+0x4a8> (60008054 <RTCCNTL+0x54>)
40377e29:	0020c0        	memw
40377e2c:	0829      	s32i.n	a2, a8, 0
}
40377e2e:	f01d      	retw.n

40377e30 <esp_rtc_get_time_us>:
{
40377e30:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40377e33:	021be5        	call8	40379ff0 <xPortInIsrContext>
40377e36:	00ba16        	beqz	a10, 40377e45 <esp_rtc_get_time_us+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40377e39:	fb7c      	movi.n	a11, -1
40377e3b:	f29da1        	l32r	a10, 403748b0 <_iram_text_start+0x4ac> (3fc92444 <s_esp_rtc_time_lock>)
40377e3e:	021d65        	call8	4037a014 <xPortEnterCriticalTimeout>
40377e41:	000246        	j	40377e4e <esp_rtc_get_time_us+0x1e>
40377e44:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
40377e45:	ffafb2        	movi	a11, -1
40377e48:	f29aa1        	l32r	a10, 403748b0 <_iram_text_start+0x4ac> (3fc92444 <s_esp_rtc_time_lock>)
40377e4b:	021ca5        	call8	4037a014 <xPortEnterCriticalTimeout>
    const uint32_t cal = esp_clk_slowclk_cal_get();
40377e4e:	fffc25        	call8	40377e10 <esp_clk_slowclk_cal_get>
40377e51:	0a7d      	mov.n	a7, a10
    if (cal == 0 || (first_call && !IS_RETAIN_MEM_VALID())) {
40377e53:	1a9c      	beqz.n	a10, 40377e68 <esp_rtc_get_time_us+0x38>
40377e55:	f29781        	l32r	a8, 403748b4 <_iram_text_start+0x4b0> (3fc92440 <first_call$0>)
40377e58:	000882        	l8ui	a8, a8, 0
40377e5b:	689c      	beqz.n	a8, 40377e75 <esp_rtc_get_time_us+0x45>
40377e5d:	f21281        	l32r	a8, 403746a8 <_iram_text_start+0x2a4> (600fffe8 <s_rtc_timer_retain_mem>)
40377e60:	5838      	l32i.n	a3, a8, 20
40377e62:	fe58e5        	call8	403763f0 <calc_checksum>
40377e65:	0c13a7        	beq	a3, a10, 40377e75 <esp_rtc_get_time_us+0x45>
        memset(&s_rtc_timer_retain_mem, 0, sizeof(retain_mem_t));
40377e68:	8c1c      	movi.n	a12, 24
40377e6a:	0b0c      	movi.n	a11, 0
40377e6c:	f20fa1        	l32r	a10, 403746a8 <_iram_text_start+0x2a4> (600fffe8 <s_rtc_timer_retain_mem>)
40377e6f:	f19281        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40377e72:	0008e0        	callx8	a8
    first_call = false;
40377e75:	f28f81        	l32r	a8, 403748b4 <_iram_text_start+0x4b0> (3fc92440 <first_call$0>)
40377e78:	090c      	movi.n	a9, 0
40377e7a:	004892        	s8i	a9, a8, 0
    const uint64_t rtc_this_ticks = rtc_time_get();
40377e7d:	014565        	call8	403792d4 <rtc_time_get>
    const uint64_t ticks = rtc_this_ticks - s_rtc_timer_retain_mem.rtc_last_ticks;
40377e80:	f20a91        	l32r	a9, 403746a8 <_iram_text_start+0x2a4> (600fffe8 <s_rtc_timer_retain_mem>)
40377e83:	2988      	l32i.n	a8, a9, 8
40377e85:	39d8      	l32i.n	a13, a9, 12
40377e87:	c0dbd0        	sub	a13, a11, a13
40377e8a:	02ba87        	bgeu	a10, a8, 40377e90 <esp_rtc_get_time_us+0x60>
40377e8d:	ffcdd2        	addi	a13, a13, -1
40377e90:	c08a80        	sub	a8, a10, a8
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
40377e93:	829780        	mull	a9, a7, a8
40377e96:	a28780        	muluh	a8, a7, a8
40377e99:	11c830        	slli	a12, a8, 13
40377e9c:	c59390        	extui	a9, a9, 19, 13
40377e9f:	209c90        	or	a9, a12, a9
40377ea2:	c58380        	extui	a8, a8, 19, 13
                                   ((ticks_high * cal) << (32 - RTC_CLK_CAL_FRACT));
40377ea5:	82c7d0        	mull	a12, a7, a13
40377ea8:	a277d0        	muluh	a7, a7, a13
40377eab:	c5d3c0        	extui	a13, a12, 19, 13
40377eae:	117730        	slli	a7, a7, 13
40377eb1:	207d70        	or	a7, a13, a7
40377eb4:	11cc30        	slli	a12, a12, 13
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
40377eb7:	887a      	add.n	a8, a8, a7
40377eb9:	99ca      	add.n	a9, a9, a12
40377ebb:	01b9c7        	bgeu	a9, a12, 40377ec0 <esp_rtc_get_time_us+0x90>
40377ebe:	881b      	addi.n	a8, a8, 1
    s_rtc_timer_retain_mem.rtc_time_us += delta_time_us;
40377ec0:	f1fac1        	l32r	a12, 403746a8 <_iram_text_start+0x2a4> (600fffe8 <s_rtc_timer_retain_mem>)
40377ec3:	0c28      	l32i.n	a2, a12, 0
40377ec5:	1c38      	l32i.n	a3, a12, 4
40377ec7:	338a      	add.n	a3, a3, a8
40377ec9:	229a      	add.n	a2, a2, a9
40377ecb:	01b297        	bgeu	a2, a9, 40377ed0 <esp_rtc_get_time_us+0xa0>
40377ece:	331b      	addi.n	a3, a3, 1
40377ed0:	f1f671        	l32r	a7, 403746a8 <_iram_text_start+0x2a4> (600fffe8 <s_rtc_timer_retain_mem>)
40377ed3:	006722        	s32i	a2, a7, 0
40377ed6:	1739      	s32i.n	a3, a7, 4
    s_rtc_timer_retain_mem.rtc_last_ticks = rtc_this_ticks;
40377ed8:	27a9      	s32i.n	a10, a7, 8
40377eda:	37b9      	s32i.n	a11, a7, 12
    s_rtc_timer_retain_mem.checksum = calc_checksum();
40377edc:	fe5125        	call8	403763f0 <calc_checksum>
40377edf:	57a9      	s32i.n	a10, a7, 20
    if (xPortInIsrContext()) {
40377ee1:	0210e5        	call8	40379ff0 <xPortInIsrContext>
40377ee4:	8a8c      	beqz.n	a10, 40377ef0 <esp_rtc_get_time_us+0xc0>
        portEXIT_CRITICAL_ISR(mux);
40377ee6:	f272a1        	l32r	a10, 403748b0 <_iram_text_start+0x4ac> (3fc92444 <s_esp_rtc_time_lock>)
40377ee9:	0227a5        	call8	4037a164 <vPortExitCritical>
40377eec:	000186        	j	40377ef6 <esp_rtc_get_time_us+0xc6>
40377eef:	00          	.byte	00
        portEXIT_CRITICAL(mux);
40377ef0:	f270a1        	l32r	a10, 403748b0 <_iram_text_start+0x4ac> (3fc92444 <s_esp_rtc_time_lock>)
40377ef3:	022725        	call8	4037a164 <vPortExitCritical>
}
40377ef6:	f01d      	retw.n

40377ef8 <esp_ptr_executable>:
    return false;
#endif  //CONFIG_SPIRAM
}

bool esp_ptr_executable(const void *p)
{
40377ef8:	004136        	entry	a1, 32
    intptr_t ip = (intptr_t) p;
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40377efb:	f26f91        	l32r	a9, 403748b8 <_iram_text_start+0x4b4> (be000000 <_rtc_reserved_end+0x5df00000>)
40377efe:	929a      	add.n	a9, a2, a9
40377f00:	f1e681        	l32r	a8, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
40377f03:	628890        	saltu	a8, a8, a9
40377f06:	880b      	addi.n	a8, a8, -1
40377f08:	608080        	neg	a8, a8
40377f0b:	748080        	extui	a8, a8, 0, 8
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40377f0e:	f26ba1        	l32r	a10, 403748bc <_iram_text_start+0x4b8> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
40377f11:	a2aa      	add.n	a10, a2, a10
40377f13:	f26b91        	l32r	a9, 403748c0 <_iram_text_start+0x4bc> (6ffff <UserFrameTotalSize+0x6feff>)
40377f16:	6299a0        	saltu	a9, a9, a10
40377f19:	990b      	addi.n	a9, a9, -1
40377f1b:	609090        	neg	a9, a9
40377f1e:	749090        	extui	a9, a9, 0, 8
40377f21:	208890        	or	a8, a8, a9
#endif
#if defined(SOC_CACHE_APP_LOW) && defined(CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE)
        || (ip >= SOC_CACHE_APP_LOW && ip < SOC_CACHE_APP_HIGH)
#endif
#if SOC_RTC_FAST_MEM_SUPPORTED
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40377f24:	98dc      	bnez.n	a8, 40377f41 <esp_ptr_executable+0x49>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40377f26:	f20c81        	l32r	a8, 40374758 <_iram_text_start+0x354> (c0000000 <_rtc_reserved_end+0x5ff00000>)
40377f29:	828a      	add.n	a8, a2, a8
40377f2b:	f26691        	l32r	a9, 403748c4 <_iram_text_start+0x4c0> (5ffff <UserFrameTotalSize+0x5feff>)
40377f2e:	14b987        	bgeu	a9, a8, 40377f46 <esp_ptr_executable+0x4e>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40377f31:	f1aa81        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40377f34:	228a      	add.n	a2, a2, a8
40377f36:	f1aa81        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40377f39:	0f3827        	bltu	a8, a2, 40377f4c <esp_ptr_executable+0x54>
40377f3c:	120c      	movi.n	a2, 1
40377f3e:	000306        	j	40377f4e <esp_ptr_executable+0x56>
40377f41:	120c      	movi.n	a2, 1
40377f43:	0001c6        	j	40377f4e <esp_ptr_executable+0x56>
40377f46:	120c      	movi.n	a2, 1
40377f48:	000086        	j	40377f4e <esp_ptr_executable+0x56>
40377f4b:	020c00        	andb	b0, b12, b0
#endif
    ;
}
40377f4e:	f01d      	retw.n

40377f50 <esp_ptr_byte_accessible>:

bool esp_ptr_byte_accessible(const void *p)
{
40377f50:	004136        	entry	a1, 32
    intptr_t ip = (intptr_t) p;
    bool r;
    r = (ip >= SOC_BYTE_ACCESSIBLE_LOW && ip < SOC_BYTE_ACCESSIBLE_HIGH);
40377f53:	f1c291        	l32r	a9, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
40377f56:	929a      	add.n	a9, a2, a9
40377f58:	f22c81        	l32r	a8, 40374808 <_iram_text_start+0x404> (77fff <UserFrameTotalSize+0x77eff>)
40377f5b:	628890        	saltu	a8, a8, a9
40377f5e:	880b      	addi.n	a8, a8, -1
40377f60:	608080        	neg	a8, a8
40377f63:	748080        	extui	a8, a8, 0, 8
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
    /* For ESP32 case, RTC fast memory is accessible to PRO cpu only and hence
     * for single core configuration (where it gets added to system heap) following
     * additional check is required */
    r |= (ip >= SOC_RTC_DRAM_LOW && ip < SOC_RTC_DRAM_HIGH);
40377f66:	f19d91        	l32r	a9, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40377f69:	929a      	add.n	a9, a2, a9
40377f6b:	f19d21        	l32r	a2, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40377f6e:	622290        	saltu	a2, a2, a9
40377f71:	220b      	addi.n	a2, a2, -1
40377f73:	602020        	neg	a2, a2
40377f76:	742020        	extui	a2, a2, 0, 8
     * from the internal RAM in terms of hardware attributes. It is a part of
     * the internal RAM when added to the heap and is byte-accessible .*/
    r |= (ip >= SOC_DROM_LOW && ip < (SOC_DROM_LOW + 0x4000));
#endif
    return r;
}
40377f79:	202280        	or	a2, a2, a8
40377f7c:	f01d      	retw.n
	...

40377f80 <s_mspi_flash_set_core_clock>:
/**
 * Currently we only need these on chips with timing tuning
 */
//-------------------------------------MSPI Clock Setting-------------------------------------//
static void s_mspi_flash_set_core_clock(uint8_t spi_num, uint32_t core_clock_mhz)
{
40377f80:	004136        	entry	a1, 32
__attribute__((always_inline))
static inline void mspi_timing_ll_set_core_clock(uint8_t spi_num, uint32_t core_clk_mhz)
{
    uint32_t reg_val = 0;

    switch (core_clk_mhz) {
40377f83:	a0a082        	movi	a8, 160
40377f86:	271387        	beq	a3, a8, 40377fb1 <s_mspi_flash_set_core_clock+0x31>
40377f89:	0f3837        	bltu	a8, a3, 40377f9c <s_mspi_flash_set_core_clock+0x1c>
40377f8c:	085c      	movi.n	a8, 80
40377f8e:	271387        	beq	a3, a8, 40377fb9 <s_mspi_flash_set_core_clock+0x39>
40377f91:	78a082        	movi	a8, 120
40377f94:	261387        	beq	a3, a8, 40377fbe <s_mspi_flash_set_core_clock+0x3e>
40377f97:	0001c6        	j	40377fa2 <s_mspi_flash_set_core_clock+0x22>
40377f9a:	820000        	mull	a0, a0, a0
40377f9d:	87f0a0        	ee.stf.64.xp	f15, f8, a10, a0
40377fa0:	13          	.byte	0x13
40377fa1:	49d121        	l32r	a2, 4034a6e8 <rom_rx_gain_force+0x3442bc>
            break;
        case 240:
            reg_val = 3;
            break;
        default:
            HAL_ASSERT(false);
40377fa4:	49c1f2        	addi	a15, a1, 73
40377fa7:	a0b2f2        	l32ai	a15, a2, 0x280
40377faa:	49a1b0        	s32e	a11, a1, -24
40377fad:	d7a5f2        	movi	a15, 0x5d7
40377fb0:	2b0c07        	bnone	a12, a0, 40377fdf <s_mspi_flash_set_core_clock+0x5f>
            reg_val = 2;
40377fb3:	0003c6        	j	40377fc6 <s_mspi_flash_set_core_clock+0x46>
40377fb6:	000000        	ill
    switch (core_clk_mhz) {
40377fb9:	0b0c      	movi.n	a11, 0
40377fbb:	0001c6        	j	40377fc6 <s_mspi_flash_set_core_clock+0x46>
            reg_val = 1;
40377fbe:	1b0c      	movi.n	a11, 1
40377fc0:	000086        	j	40377fc6 <s_mspi_flash_set_core_clock+0x46>
40377fc3:	3b0c00        	ueq.s	b0, f12, f0
    }

    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
40377fc6:	f24381        	l32r	a8, 403748d4 <_iram_text_start+0x4d0> (60003 <UserFrameTotalSize+0x5ff03>)
40377fc9:	c08820        	sub	a8, a8, a2
40377fcc:	118840        	slli	a8, a8, 12
40377fcf:	eca092        	movi	a9, 236
40377fd2:	889a      	add.n	a8, a8, a9
40377fd4:	0020c0        	memw
40377fd7:	0898      	l32i.n	a9, a8, 0
40377fd9:	ca7c      	movi.n	a10, -4
40377fdb:	1099a0        	and	a9, a9, a10
40377fde:	2099b0        	or	a9, a9, a11
40377fe1:	0020c0        	memw
40377fe4:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_core_clock(spi_num, core_clock_mhz);
}
40377fe6:	f01d      	retw.n

40377fe8 <s_mspi_psram_set_core_clock>:

static void s_mspi_psram_set_core_clock(uint8_t spi_num, uint32_t core_clock_mhz)
{
40377fe8:	004136        	entry	a1, 32
    switch (core_clk_mhz) {
40377feb:	a0a082        	movi	a8, 160
40377fee:	271387        	beq	a3, a8, 40378019 <_diram_i_start+0x19>
40377ff1:	0f3837        	bltu	a8, a3, 40378004 <_diram_i_start+0x4>
40377ff4:	085c      	movi.n	a8, 80
40377ff6:	271387        	beq	a3, a8, 40378021 <_diram_i_start+0x21>
40377ff9:	78a082        	movi	a8, 120
40377ffc:	261387        	beq	a3, a8, 40378026 <_diram_i_start+0x26>
40377fff:	0001c6        	j	4037800a <_diram_i_start+0xa>
40378002:	820000        	mull	a0, a0, a0
40378005:	87f0a0        	ee.stf.64.xp	f15, f8, a10, a0
40378008:	13          	.byte	0x13
40378009:	2fd121        	l32r	a2, 40343f50 <rom_rx_gain_force+0x33db24>
            HAL_ASSERT(false);
4037800c:	2fc1f2        	addi	a15, a1, 47
4037800f:	a0b2f2        	l32ai	a15, a2, 0x280
40378012:	b0          	.byte	0xb0
40378013:	f22fa1        	l32r	a10, 403748d0 <_iram_text_start+0x4cc> (3fc93e34 <__func__$0+0x248>)
40378016:	07d125        	call8	4037fd28 <__assert_func>
            reg_val = 2;
40378019:	2b0c      	movi.n	a11, 2
4037801b:	0003c6        	j	4037802e <_diram_i_start+0x2e>
4037801e:	000000        	ill
    switch (core_clk_mhz) {
40378021:	0b0c      	movi.n	a11, 0
40378023:	0001c6        	j	4037802e <_diram_i_start+0x2e>
            reg_val = 1;
40378026:	1b0c      	movi.n	a11, 1
40378028:	000086        	j	4037802e <_diram_i_start+0x2e>
4037802b:	3b0c00        	ueq.s	b0, f12, f0
    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
4037802e:	f22981        	l32r	a8, 403748d4 <_iram_text_start+0x4d0> (60003 <UserFrameTotalSize+0x5ff03>)
40378031:	c08820        	sub	a8, a8, a2
40378034:	118840        	slli	a8, a8, 12
40378037:	eca092        	movi	a9, 236
4037803a:	889a      	add.n	a8, a8, a9
4037803c:	0020c0        	memw
4037803f:	0898      	l32i.n	a9, a8, 0
40378041:	ca7c      	movi.n	a10, -4
40378043:	1099a0        	and	a9, a9, a10
40378046:	2099b0        	or	a9, a9, a11
40378049:	0020c0        	memw
4037804c:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_core_clock(spi_num, core_clock_mhz);
}
4037804e:	f01d      	retw.n

40378050 <mspi_timing_config_set_flash_clock>:

void mspi_timing_config_set_flash_clock(uint32_t flash_freq_mhz, mspi_timing_speed_mode_t speed_mode, bool control_both_mspi)
{
40378050:	004136        	entry	a1, 32
40378053:	744040        	extui	a4, a4, 0, 8
        core_clock_mhz = FLASH_LOW_SPEED_CORE_CLOCK_MHZ;
    } else {
        core_clock_mhz = FLASH_HIGH_SPEED_CORE_CLOCK_MHZ;
    }
    //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
    s_mspi_flash_set_core_clock(0, core_clock_mhz);
40378056:	50a0b2        	movi	a11, 80
40378059:	00a0a2        	movi	a10, 0
4037805c:	fff225        	call8	40377f80 <s_mspi_flash_set_core_clock>

    uint32_t freqdiv = core_clock_mhz / flash_freq_mhz;
4037805f:	095c      	movi.n	a9, 80
40378061:	c28920        	quou	a8, a9, a2
    assert(freqdiv > 0);
40378064:	0db927        	bgeu	a9, a2, 40378075 <mspi_timing_config_set_flash_clock+0x25>
40378067:	f21cd1        	l32r	a13, 403748d8 <_iram_text_start+0x4d4> (3fc93e68 <__func__$0+0x27c>)
4037806a:	f21cc1        	l32r	a12, 403748dc <_iram_text_start+0x4d8> (3fc93b44 <__func__$2>)
4037806d:	1b3c      	movi.n	a11, 49
4037806f:	f21ca1        	l32r	a10, 403748e0 <_iram_text_start+0x4dc> (3fc93eb4 <__func__$0+0x2c8>)
40378072:	07cb65        	call8	4037fd28 <__assert_func>
 * @param freqdiv  Divider value
 */
__attribute__((always_inline))
static inline void mspi_timing_ll_set_flash_clock(uint8_t spi_num, uint32_t freqdiv)
{
    if (freqdiv == 1) {
40378075:	0d1866        	bnei	a8, 1, 40378086 <mspi_timing_config_set_flash_clock+0x36>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
40378078:	f21b91        	l32r	a9, 403748e4 <_iram_text_start+0x4e0> (60003014 <SPIMEM0+0x14>)
4037807b:	f1cda1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037807e:	0020c0        	memw
40378081:	09a9      	s32i.n	a10, a9, 0
40378083:	000686        	j	403780a1 <mspi_timing_config_set_flash_clock+0x51>
    } else {
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
40378086:	a80b      	addi.n	a10, a8, -1
40378088:	11ba00        	slli	a11, a10, 16
4037808b:	419180        	srli	a9, a8, 1
4037808e:	990b      	addi.n	a9, a9, -1
40378090:	119980        	slli	a9, a9, 8
40378093:	209b90        	or	a9, a11, a9
40378096:	20aa90        	or	a10, a10, a9
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
40378099:	f21291        	l32r	a9, 403748e4 <_iram_text_start+0x4e0> (60003014 <SPIMEM0+0x14>)
4037809c:	0020c0        	memw
4037809f:	09a9      	s32i.n	a10, a9, 0
    mspi_timing_ll_set_flash_clock(0, freqdiv);
    if (control_both_mspi) {
403780a1:	b4ac      	beqz.n	a4, 403780d0 <mspi_timing_config_set_flash_clock+0x80>
    if (freqdiv == 1) {
403780a3:	0e1866        	bnei	a8, 1, 403780b5 <mspi_timing_config_set_flash_clock+0x65>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
403780a6:	f21081        	l32r	a8, 403748e8 <_iram_text_start+0x4e4> (60002014 <SPIMEM1+0x14>)
403780a9:	f1c191        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
403780ac:	0020c0        	memw
403780af:	0899      	s32i.n	a9, a8, 0
403780b1:	0006c6        	j	403780d0 <mspi_timing_config_set_flash_clock+0x80>
403780b4:	00          	.byte	00
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
403780b5:	980b      	addi.n	a9, a8, -1
403780b7:	11a900        	slli	a10, a9, 16
403780ba:	418180        	srli	a8, a8, 1
403780bd:	880b      	addi.n	a8, a8, -1
403780bf:	118880        	slli	a8, a8, 8
403780c2:	208a80        	or	a8, a10, a8
403780c5:	209980        	or	a9, a9, a8
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
403780c8:	f20881        	l32r	a8, 403748e8 <_iram_text_start+0x4e4> (60002014 <SPIMEM1+0x14>)
403780cb:	0020c0        	memw
403780ce:	0899      	s32i.n	a9, a8, 0
        mspi_timing_ll_set_flash_clock(1, freqdiv);
    }
}
403780d0:	f01d      	retw.n
	...

403780d4 <mspi_timing_config_set_psram_clock>:

void mspi_timing_config_set_psram_clock(uint32_t psram_freq_mhz, mspi_timing_speed_mode_t speed_mode, bool control_both_mspi)
{
403780d4:	004136        	entry	a1, 32
        core_clock_mhz = PSRAM_LOW_SPEED_CORE_CLOCK_MHZ;
    } else {
        core_clock_mhz = PSRAM_HIGH_SPEED_CORE_CLOCK_MHZ;
    }
    //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
    s_mspi_psram_set_core_clock(0, core_clock_mhz);
403780d7:	0b5c      	movi.n	a11, 80
403780d9:	0a0c      	movi.n	a10, 0
403780db:	fff0e5        	call8	40377fe8 <s_mspi_psram_set_core_clock>

    uint32_t freqdiv = core_clock_mhz / psram_freq_mhz;
403780de:	095c      	movi.n	a9, 80
403780e0:	c28920        	quou	a8, a9, a2
    assert(freqdiv > 0);
403780e3:	0db927        	bgeu	a9, a2, 403780f4 <mspi_timing_config_set_psram_clock+0x20>
403780e6:	f1fcd1        	l32r	a13, 403748d8 <_iram_text_start+0x4d4> (3fc93e68 <__func__$0+0x27c>)
403780e9:	f200c1        	l32r	a12, 403748ec <_iram_text_start+0x4e8> (3fc93b00 <__func__$0>)
403780ec:	5b4c      	movi.n	a11, 69
403780ee:	f1fca1        	l32r	a10, 403748e0 <_iram_text_start+0x4dc> (3fc93eb4 <__func__$0+0x2c8>)
403780f1:	07c365        	call8	4037fd28 <__assert_func>
 * @param freqdiv  Divider value
 */
__attribute__((always_inline))
static inline void mspi_timing_ll_set_psram_clock(uint8_t spi_num, uint32_t freqdiv)
{
    if (freqdiv == 1) {
403780f4:	0d1866        	bnei	a8, 1, 40378105 <mspi_timing_config_set_psram_clock+0x31>
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), SPI_MEM_SCLK_EQU_SYSCLK);
403780f7:	f1fe81        	l32r	a8, 403748f0 <_iram_text_start+0x4ec> (60003050 <SPIMEM0+0x50>)
403780fa:	f1ad91        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
403780fd:	0020c0        	memw
40378100:	0899      	s32i.n	a9, a8, 0
40378102:	000686        	j	40378120 <mspi_timing_config_set_psram_clock+0x4c>
    } else {
        uint32_t freqbits = (((freqdiv-1)<<SPI_MEM_SCLKCNT_N_S)) | (((freqdiv/2-1)<<SPI_MEM_SCLKCNT_H_S)) | ((freqdiv-1)<<SPI_MEM_SCLKCNT_L_S);
40378105:	980b      	addi.n	a9, a8, -1
40378107:	11a900        	slli	a10, a9, 16
4037810a:	418180        	srli	a8, a8, 1
4037810d:	880b      	addi.n	a8, a8, -1
4037810f:	118880        	slli	a8, a8, 8
40378112:	208a80        	or	a8, a10, a8
40378115:	209980        	or	a9, a9, a8
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), freqbits);
40378118:	f1f681        	l32r	a8, 403748f0 <_iram_text_start+0x4ec> (60003050 <SPIMEM0+0x50>)
4037811b:	0020c0        	memw
4037811e:	0899      	s32i.n	a9, a8, 0
    mspi_timing_ll_set_psram_clock(0, freqdiv);
}
40378120:	f01d      	retw.n
	...

40378124 <mspi_timing_enter_low_speed_mode>:

/*------------------------------------------------------------------------------
 * APIs to make SPI0 (and SPI1) FLASH work for high/low freq
 *----------------------------------------------------------------------------*/
void mspi_timing_enter_low_speed_mode(bool control_spi1)
{
40378124:	004136        	entry	a1, 32
40378127:	742020        	extui	a2, a2, 0, 8
     *
     * Currently we only need to change these clocks on chips with timing tuning
     * Should be extended to other no-timing-tuning chips if needed. e.g.:
     * we still need to turn down Flash / PSRAM clock speed at a certain period of time
     */
    mspi_timing_config_set_flash_clock(20, MSPI_TIMING_SPEED_MODE_LOW_PERF, control_spi1);
4037812a:	20c220        	or	a12, a2, a2
4037812d:	00a0b2        	movi	a11, 0
40378130:	4a1c      	movi.n	a10, 20
40378132:	fff1e5        	call8	40378050 <mspi_timing_config_set_flash_clock>
    mspi_timing_config_set_psram_clock(20, MSPI_TIMING_SPEED_MODE_LOW_PERF, control_spi1);
40378135:	02cd      	mov.n	a12, a2
40378137:	0b0c      	movi.n	a11, 0
40378139:	4a1c      	movi.n	a10, 20
4037813b:	fff9a5        	call8	403780d4 <mspi_timing_config_set_psram_clock>

#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
    mspi_timing_flash_config_clear_tuning_regs(control_spi1);
    mspi_timing_psram_config_clear_tuning_regs(control_spi1);
#endif  //#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
}
4037813e:	f01d      	retw.n

40378140 <mspi_timing_enter_high_speed_mode>:
 * iF control_spi1 == 1, will also update SPI1 timing registers. Should only be set to 1 when do tuning.
 *
 * This function should always be called after `mspi_timing_flash_tuning` or `calculate_best_flash_tuning_config`
 */
void mspi_timing_enter_high_speed_mode(bool control_spi1)
{
40378140:	004136        	entry	a1, 32
    /**
     * Currently we only need to change these clocks on chips with timing tuning
     * Should be extended to other no-timing-tuning chips if needed. e.g.:
     * we still need to turn down Flash / PSRAM clock speed at a certain period of time
     */
    mspi_timing_config_set_flash_clock(FLASH_FREQUENCY_MHZ, MSPI_TIMING_SPEED_MODE_NORMAL_PERF, control_spi1);
40378143:	74c020        	extui	a12, a2, 0, 8
40378146:	01a0b2        	movi	a11, 1
40378149:	50a0a2        	movi	a10, 80
4037814c:	fff025        	call8	40378050 <mspi_timing_config_set_flash_clock>

#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
    mspi_timing_flash_config_set_tuning_regs(control_spi1);
    mspi_timing_psram_config_set_tuning_regs(control_spi1);
#endif  //#if MSPI_TIMING_FLASH_NEEDS_TUNING || MSPI_TIMING_PSRAM_NEEDS_TUNING
}
4037814f:	000090        	retw
	...

40378154 <mspi_timing_change_speed_mode_cache_safe>:

void mspi_timing_change_speed_mode_cache_safe(bool switch_down)
{
40378154:	004136        	entry	a1, 32
40378157:	742020        	extui	a2, a2, 0, 8
     * - or other way
     *
     * for preventing concurrent from MSPI to external memory
     */
#if SOC_CACHE_FREEZE_SUPPORTED
    esp_cache_freeze_ext_mem_cache();
4037815a:	012b65        	call8	40379410 <esp_cache_freeze_ext_mem_cache>
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

    if (switch_down) {
4037815d:	007216        	beqz	a2, 40378168 <mspi_timing_change_speed_mode_cache_safe+0x14>
        //enter MSPI low speed mode, extra delays should be removed
        mspi_timing_enter_low_speed_mode(false);
40378160:	0a0c      	movi.n	a10, 0
40378162:	fffc25        	call8	40378124 <mspi_timing_enter_low_speed_mode>
40378165:	000146        	j	4037816e <mspi_timing_change_speed_mode_cache_safe+0x1a>
    } else {
        //enter MSPI high speed mode, extra delays should be considered
        mspi_timing_enter_high_speed_mode(false);
40378168:	00a0a2        	movi	a10, 0
4037816b:	fffd65        	call8	40378140 <mspi_timing_enter_high_speed_mode>
    }

#if SOC_CACHE_FREEZE_SUPPORTED
    esp_cache_unfreeze_ext_mem_cache();
4037816e:	012b25        	call8	40379420 <esp_cache_unfreeze_ext_mem_cache>
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE && !CONFIG_FREERTOS_UNICORE
    esp_ipc_isr_release_other_cpu();
#endif
}
40378171:	000090        	retw

40378174 <spi_timing_get_flash_timing_param>:
    // Get CS setup/hold value here.
    mspi_timing_config_get_cs_timing(&out_timing_config->cs_setup, &out_timing_config->cs_hold);
}
#else
void spi_timing_get_flash_timing_param(spi_flash_hal_timing_config_t *out_timing_config)
{
40378174:	004136        	entry	a1, 32
    // This function shouldn't be called if timing tuning is not used.
    abort();
40378177:	07af65        	call8	4037fc6c <abort>
	...

4037817c <mspi_timing_set_pin_drive_strength>:

/*------------------------------------------------------------------------------
 * Common settings
 *----------------------------------------------------------------------------*/
void mspi_timing_set_pin_drive_strength(void)
{
4037817c:	00a136        	entry	a1, 80
    SET_PERI_REG_MASK(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPICLK_PAD_DRV_CTL_EN);
4037817f:	f1dd81        	l32r	a8, 403748f4 <_iram_text_start+0x4f0> (600033fc <SPIMEM0+0x3fc>)
40378182:	0020c0        	memw
40378185:	0898      	l32i.n	a9, a8, 0
40378187:	0a1c      	movi.n	a10, 16
40378189:	2099a0        	or	a9, a9, a10
4037818c:	0020c0        	memw
4037818f:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPI_SMEM_SPICLK_FUN_DRV, val);
40378191:	0020c0        	memw
40378194:	0898      	l32i.n	a9, a8, 0
40378196:	3a0c      	movi.n	a10, 3
40378198:	2099a0        	or	a9, a9, a10
4037819b:	0020c0        	memw
4037819e:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SPI_MEM_DATE_REG(spi_num), SPI_MEM_SPI_FMEM_SPICLK_FUN_DRV, val);
403781a0:	0020c0        	memw
403781a3:	0898      	l32i.n	a9, a8, 0
403781a5:	ca0c      	movi.n	a10, 12
403781a7:	2099a0        	or	a9, a9, a10
403781aa:	0020c0        	memw
403781ad:	0899      	s32i.n	a9, a8, 0
    uint32_t regs[] = {IO_MUX_GPIO27_REG, IO_MUX_GPIO28_REG,
403781af:	4c2c      	movi.n	a12, 36
403781b1:	f1d1b1        	l32r	a11, 403748f8 <_iram_text_start+0x4f4> (3fc93b68 <__func__$2+0x24>)
403781b4:	01ad      	mov.n	a10, a1
403781b6:	f0d281        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403781b9:	0008e0        	callx8	a8
    for (int i = 0; i < ARRAY_SIZE(regs); i++) {
403781bc:	080c      	movi.n	a8, 0
403781be:	000586        	j	403781d8 <mspi_timing_set_pin_drive_strength+0x5c>
        PIN_SET_DRV(regs[i], val);
403781c1:	a09810        	addx4	a9, a8, a1
403781c4:	09a8      	l32i.n	a10, a9, 0
403781c6:	0020c0        	memw
403781c9:	0a98      	l32i.n	a9, a10, 0
403781cb:	f1ccb1        	l32r	a11, 403748fc <_iram_text_start+0x4f8> (c00 <UserFrameTotalSize+0xb00>)
403781ce:	2099b0        	or	a9, a9, a11
403781d1:	0020c0        	memw
403781d4:	0a99      	s32i.n	a9, a10, 0
    for (int i = 0; i < ARRAY_SIZE(regs); i++) {
403781d6:	881b      	addi.n	a8, a8, 1
403781d8:	890c      	movi.n	a9, 8
403781da:	e3b987        	bgeu	a9, a8, 403781c1 <mspi_timing_set_pin_drive_strength+0x45>
#if CONFIG_IDF_TARGET_ESP32S3
    //Set default pin drive
    mspi_timing_ll_set_all_pin_drive(0, 3);
#endif
}
403781dd:	f01d      	retw.n
	...

403781e0 <mspi_timing_flash_tuning>:
{
403781e0:	004136        	entry	a1, 32
}
403781e3:	f01d      	retw.n
403781e5:	000000        	ill

403781e8 <spi_flash_timing_is_tuned>:
{
403781e8:	004136        	entry	a1, 32
}
403781eb:	020c      	movi.n	a2, 0
403781ed:	f01d      	retw.n
	...

403781f0 <periph_rcc_acquire_enter>:
{
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
}

uint8_t periph_rcc_acquire_enter(periph_module_t periph)
{
403781f0:	004136        	entry	a1, 32
    periph_rcc_enter();
403781f3:	000265        	call8	40378218 <periph_rcc_enter>
    return ref_counts[periph];
403781f6:	f1c281        	l32r	a8, 40374900 <_iram_text_start+0x4fc> (3fc94f54 <ref_counts>)
403781f9:	282a      	add.n	a2, a8, a2
}
403781fb:	000222        	l8ui	a2, a2, 0
403781fe:	f01d      	retw.n

40378200 <periph_rcc_acquire_exit>:

void periph_rcc_acquire_exit(periph_module_t periph, uint8_t ref_count)
{
40378200:	004136        	entry	a1, 32
40378203:	743030        	extui	a3, a3, 0, 8
    ref_counts[periph] = ++ref_count;
40378206:	f1be81        	l32r	a8, 40374900 <_iram_text_start+0x4fc> (3fc94f54 <ref_counts>)
40378209:	808820        	add	a8, a8, a2
4037820c:	01c332        	addi	a3, a3, 1
4037820f:	004832        	s8i	a3, a8, 0
    periph_rcc_exit();
40378212:	000265        	call8	40378238 <periph_rcc_exit>
}
40378215:	000090        	retw

40378218 <periph_rcc_enter>:
{
40378218:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
4037821b:	01dd65        	call8	40379ff0 <xPortInIsrContext>
4037821e:	00ba16        	beqz	a10, 4037822d <periph_rcc_enter+0x15>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40378221:	ffafb2        	movi	a11, -1
40378224:	f1b8a1        	l32r	a10, 40374904 <_iram_text_start+0x500> (3fc92454 <periph_spinlock>)
40378227:	01dee5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037822a:	0001c6        	j	40378235 <periph_rcc_enter+0x1d>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037822d:	fb7c      	movi.n	a11, -1
4037822f:	f1b5a1        	l32r	a10, 40374904 <_iram_text_start+0x500> (3fc92454 <periph_spinlock>)
40378232:	01de25        	call8	4037a014 <xPortEnterCriticalTimeout>
}
40378235:	f01d      	retw.n
	...

40378238 <periph_rcc_exit>:
{
40378238:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
4037823b:	01db65        	call8	40379ff0 <xPortInIsrContext>
4037823e:	aa8c      	beqz.n	a10, 4037824c <periph_rcc_exit+0x14>
        portEXIT_CRITICAL_ISR(mux);
40378240:	f1b1a1        	l32r	a10, 40374904 <_iram_text_start+0x500> (3fc92454 <periph_spinlock>)
40378243:	01f225        	call8	4037a164 <vPortExitCritical>
40378246:	000206        	j	40378252 <periph_rcc_exit+0x1a>
40378249:	000000        	ill
        portEXIT_CRITICAL(mux);
4037824c:	f1aea1        	l32r	a10, 40374904 <_iram_text_start+0x500> (3fc92454 <periph_spinlock>)
4037824f:	01f165        	call8	4037a164 <vPortExitCritical>
}
40378252:	f01d      	retw.n

40378254 <periph_rcc_release_enter>:

uint8_t periph_rcc_release_enter(periph_module_t periph)
{
40378254:	004136        	entry	a1, 32
    periph_rcc_enter();
40378257:	fffc25        	call8	40378218 <periph_rcc_enter>
    return ref_counts[periph] - 1;
4037825a:	f1a981        	l32r	a8, 40374900 <_iram_text_start+0x4fc> (3fc94f54 <ref_counts>)
4037825d:	802820        	add	a2, a8, a2
40378260:	000222        	l8ui	a2, a2, 0
40378263:	ffc222        	addi	a2, a2, -1
}
40378266:	742020        	extui	a2, a2, 0, 8
40378269:	000090        	retw

4037826c <periph_rcc_release_exit>:

void periph_rcc_release_exit(periph_module_t periph, uint8_t ref_count)
{
4037826c:	004136        	entry	a1, 32
    ref_counts[periph] = ref_count;
4037826f:	f1a481        	l32r	a8, 40374900 <_iram_text_start+0x4fc> (3fc94f54 <ref_counts>)
40378272:	882a      	add.n	a8, a8, a2
40378274:	004832        	s8i	a3, a8, 0
    periph_rcc_exit();
40378277:	fffc25        	call8	40378238 <periph_rcc_exit>
}
4037827a:	f01d      	retw.n

4037827c <regi2c_ctrl_read_reg_mask>:
    REGI2C_CLOCK_DISABLE();
    return value;
}

uint8_t regi2c_ctrl_read_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb)
{
4037827c:	004136        	entry	a1, 32
4037827f:	742020        	extui	a2, a2, 0, 8
40378282:	743030        	extui	a3, a3, 0, 8
40378285:	744040        	extui	a4, a4, 0, 8
40378288:	745050        	extui	a5, a5, 0, 8
4037828b:	746060        	extui	a6, a6, 0, 8
    if (xPortInIsrContext()) {
4037828e:	01d625        	call8	40379ff0 <xPortInIsrContext>
40378291:	00ca16        	beqz	a10, 403782a1 <regi2c_ctrl_read_reg_mask+0x25>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40378294:	ffafb2        	movi	a11, -1
40378297:	f19ca1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
4037829a:	01d7a5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037829d:	000246        	j	403782aa <regi2c_ctrl_read_reg_mask+0x2e>
403782a0:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403782a1:	ffafb2        	movi	a11, -1
403782a4:	f199a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
403782a7:	01d6e5        	call8	4037a014 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    uint8_t value = regi2c_read_reg_mask_raw(block, host_id, reg_add, msb, lsb);
403782aa:	06ed      	mov.n	a14, a6
403782ac:	05dd      	mov.n	a13, a5
403782ae:	04cd      	mov.n	a12, a4
403782b0:	03bd      	mov.n	a11, a3
403782b2:	20a220        	or	a10, a2, a2
403782b5:	f19581        	l32r	a8, 4037490c <_iram_text_start+0x508> (40005d54 <esp_rom_regi2c_read_mask>)
403782b8:	0008e0        	callx8	a8
403782bb:	0a2d      	mov.n	a2, a10
    if (xPortInIsrContext()) {
403782bd:	01d325        	call8	40379ff0 <xPortInIsrContext>
403782c0:	8a8c      	beqz.n	a10, 403782cc <regi2c_ctrl_read_reg_mask+0x50>
        portEXIT_CRITICAL_ISR(mux);
403782c2:	f191a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
403782c5:	01e9e5        	call8	4037a164 <vPortExitCritical>
403782c8:	000186        	j	403782d2 <regi2c_ctrl_read_reg_mask+0x56>
403782cb:	00          	.byte	00
        portEXIT_CRITICAL(mux);
403782cc:	f18fa1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
403782cf:	01e965        	call8	4037a164 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
    return value;
}
403782d2:	f01d      	retw.n

403782d4 <regi2c_ctrl_write_reg>:

void regi2c_ctrl_write_reg(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t data)
{
403782d4:	004136        	entry	a1, 32
403782d7:	742020        	extui	a2, a2, 0, 8
403782da:	743030        	extui	a3, a3, 0, 8
403782dd:	744040        	extui	a4, a4, 0, 8
403782e0:	745050        	extui	a5, a5, 0, 8
    if (xPortInIsrContext()) {
403782e3:	01d0e5        	call8	40379ff0 <xPortInIsrContext>
403782e6:	00ba16        	beqz	a10, 403782f5 <regi2c_ctrl_write_reg+0x21>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403782e9:	fb7c      	movi.n	a11, -1
403782eb:	f187a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
403782ee:	01d265        	call8	4037a014 <xPortEnterCriticalTimeout>
403782f1:	000246        	j	403782fe <regi2c_ctrl_write_reg+0x2a>
403782f4:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403782f5:	ffafb2        	movi	a11, -1
403782f8:	f184a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
403782fb:	01d1a5        	call8	4037a014 <xPortEnterCriticalTimeout>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_raw(block, host_id, reg_add, data);
403782fe:	05dd      	mov.n	a13, a5
40378300:	20c440        	or	a12, a4, a4
40378303:	20b330        	or	a11, a3, a3
40378306:	02ad      	mov.n	a10, a2
40378308:	f18281        	l32r	a8, 40374910 <_iram_text_start+0x50c> (40005d60 <esp_rom_regi2c_write>)
4037830b:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
4037830e:	01ce25        	call8	40379ff0 <xPortInIsrContext>
40378311:	7a8c      	beqz.n	a10, 4037831c <regi2c_ctrl_write_reg+0x48>
        portEXIT_CRITICAL_ISR(mux);
40378313:	f17da1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
40378316:	01e4e5        	call8	4037a164 <vPortExitCritical>
40378319:	000146        	j	40378322 <regi2c_ctrl_write_reg+0x4e>
        portEXIT_CRITICAL(mux);
4037831c:	f17ba1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
4037831f:	01e465        	call8	4037a164 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
}
40378322:	f01d      	retw.n

40378324 <regi2c_ctrl_write_reg_mask>:

void regi2c_ctrl_write_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb, uint8_t data)
{
40378324:	004136        	entry	a1, 32
40378327:	742020        	extui	a2, a2, 0, 8
4037832a:	743030        	extui	a3, a3, 0, 8
4037832d:	744040        	extui	a4, a4, 0, 8
40378330:	745050        	extui	a5, a5, 0, 8
40378333:	746060        	extui	a6, a6, 0, 8
40378336:	747070        	extui	a7, a7, 0, 8
    if (xPortInIsrContext()) {
40378339:	01cb65        	call8	40379ff0 <xPortInIsrContext>
4037833c:	00da16        	beqz	a10, 4037834d <regi2c_ctrl_write_reg_mask+0x29>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037833f:	ffafb2        	movi	a11, -1
40378342:	f171a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
40378345:	01cce5        	call8	4037a014 <xPortEnterCriticalTimeout>
40378348:	000286        	j	40378356 <regi2c_ctrl_write_reg_mask+0x32>
4037834b:	b20000        	mulsh	a0, a0, a0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037834e:	6ea1ffaf 	ee.vmulas.u8.accx.ld.ip.qup	q4, a10, -16, q7, q7, q2, q1
40378352:	cc25f1        	l32r	a15, 4036b3e8 <rom_rx_gain_force+0x364fbc>
40378355:	07fd01        	l32r	a0, 4033a34c <rom_rx_gain_force+0x333f20>
    REGI2C_CLOCK_ENABLE();
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_mask_raw(block, host_id, reg_add, msb, lsb, data);
40378358:	06ed      	mov.n	a14, a6
4037835a:	05dd      	mov.n	a13, a5
4037835c:	20c440        	or	a12, a4, a4
4037835f:	20b330        	or	a11, a3, a3
40378362:	02ad      	mov.n	a10, a2
40378364:	f16c81        	l32r	a8, 40374914 <_iram_text_start+0x510> (40005d6c <esp_rom_regi2c_write_mask>)
40378367:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
4037836a:	01c865        	call8	40379ff0 <xPortInIsrContext>
4037836d:	7a8c      	beqz.n	a10, 40378378 <regi2c_ctrl_write_reg_mask+0x54>
        portEXIT_CRITICAL_ISR(mux);
4037836f:	f166a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
40378372:	01df25        	call8	4037a164 <vPortExitCritical>
40378375:	000146        	j	4037837e <regi2c_ctrl_write_reg_mask+0x5a>
        portEXIT_CRITICAL(mux);
40378378:	f164a1        	l32r	a10, 40374908 <_iram_text_start+0x504> (3fc92484 <mux>)
4037837b:	01dea5        	call8	4037a164 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    REGI2C_CLOCK_DISABLE();
}
4037837e:	f01d      	retw.n

40378380 <rtc_clk_bbpll_disable>:
{
    return clk_ll_rtc_fast_get_src();
}

static void rtc_clk_bbpll_disable(void)
{
40378380:	004136        	entry	a1, 32
    REG_SET_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
40378383:	f14791        	l32r	a9, 403748a0 <_iram_text_start+0x49c> (60008000 <RTCCNTL>)
40378386:	0020c0        	memw
40378389:	0988      	l32i.n	a8, a9, 0
4037838b:	40a5a2        	movi	a10, 0x540
4037838e:	2088a0        	or	a8, a8, a10
40378391:	0020c0        	memw
40378394:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_disable();
    s_cur_pll_freq = 0;
40378396:	f16081        	l32r	a8, 40374918 <_iram_text_start+0x514> (3fc94f90 <s_cur_pll_freq>)
40378399:	090c      	movi.n	a9, 0
4037839b:	0899      	s32i.n	a9, a8, 0
}
4037839d:	f01d      	retw.n
	...

403783a0 <rtc_clk_bbpll_enable>:

static void rtc_clk_bbpll_enable(void)
{
403783a0:	004136        	entry	a1, 32
    REG_CLR_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
403783a3:	f13f91        	l32r	a9, 403748a0 <_iram_text_start+0x49c> (60008000 <RTCCNTL>)
403783a6:	0020c0        	memw
403783a9:	0988      	l32i.n	a8, a9, 0
403783ab:	bfaaa2        	movi	a10, 0xfffffabf
403783ae:	1088a0        	and	a8, a8, a10
403783b1:	0020c0        	memw
403783b4:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_enable();
}
403783b6:	f01d      	retw.n

403783b8 <rtc_clk_cpu_freq_to_8m>:

    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
}

static void rtc_clk_cpu_freq_to_8m(void)
{
403783b8:	004136        	entry	a1, 32
    assert(0 && "LDO dbias need to modified");
403783bb:	f158d1        	l32r	a13, 4037491c <_iram_text_start+0x518> (3fc93d1c <__func__$0+0x130>)
403783be:	f158c1        	l32r	a12, 40374920 <_iram_text_start+0x51c> (3fc93b8c <__func__$2>)
403783c1:	aaa1b2        	movi	a11, 0x1aa
403783c4:	f158a1        	l32r	a10, 40374924 <_iram_text_start+0x520> (3fc93d6d <__func__$0+0x181>)
403783c7:	079625        	call8	4037fd28 <__assert_func>
	...

403783cc <rtc_clk_bbpll_configure>:
{
403783cc:	004136        	entry	a1, 32
    switch (pll_freq_mhz) {
403783cf:	40a182        	movi	a8, 0x140
403783d2:	0a1387        	beq	a3, a8, 403783e0 <rtc_clk_bbpll_configure+0x14>
403783d5:	e0a182        	movi	a8, 0x1e0
403783d8:	191387        	beq	a3, a8, 403783f5 <rtc_clk_bbpll_configure+0x29>
403783db:	000ac6        	j	4037840a <rtc_clk_bbpll_configure+0x3e>
403783de:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 0);
403783e1:	c0f152        	s32ri	a5, a1, 0x300
403783e4:	20          	.byte	0x20
403783e5:	098800        	l32e	a0, a8, -32
403783e8:	ba7c      	movi.n	a10, -5
403783ea:	1088a0        	and	a8, a8, a10
403783ed:	0020c0        	memw
403783f0:	0989      	s32i.n	a8, a9, 0
        break;
403783f2:	0005c6        	j	4037840d <rtc_clk_bbpll_configure+0x41>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 1);
403783f5:	f14c91        	l32r	a9, 40374928 <_iram_text_start+0x524> (600c0010 <SYSTEM+0x10>)
403783f8:	0020c0        	memw
403783fb:	0988      	l32i.n	a8, a9, 0
403783fd:	4a0c      	movi.n	a10, 4
403783ff:	2088a0        	or	a8, a8, a10
40378402:	0020c0        	memw
40378405:	0989      	s32i.n	a8, a9, 0
        break;
40378407:	000086        	j	4037840d <rtc_clk_bbpll_configure+0x41>
        abort();
4037840a:	078625        	call8	4037fc6c <abort>
/**
 * @brief Start BBPLL self-calibration
 */
static inline __attribute__((always_inline)) void regi2c_ctrl_ll_bbpll_calibration_start(void)
{
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
4037840d:	f14781        	l32r	a8, 4037492c <_iram_text_start+0x528> (6000e040 <SENS+0x5840>)
40378410:	0020c0        	memw
40378413:	002892        	l32i	a9, a8, 0
40378416:	fbafa2        	movi	a10, -5
40378419:	1099a0        	and	a9, a9, a10
4037841c:	0020c0        	memw
4037841f:	006892        	s32i	a9, a8, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
40378422:	0020c0        	memw
40378425:	0898      	l32i.n	a9, a8, 0
40378427:	8a0c      	movi.n	a10, 8
40378429:	2099a0        	or	a9, a9, a10
4037842c:	0020c0        	memw
4037842f:	0899      	s32i.n	a9, a8, 0
    if (pll_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
40378431:	e0a182        	movi	a8, 0x1e0
40378434:	2c9387        	bne	a3, a8, 40378464 <rtc_clk_bbpll_configure+0x98>
        switch (xtal_freq_mhz) {
40378437:	0ac226        	beqi	a2, 32, 40378445 <rtc_clk_bbpll_configure+0x79>
            dcur = 3;
4037843a:	370c      	movi.n	a7, 3
            dchgp = 5;
4037843c:	520c      	movi.n	a2, 5
            div7_0 = 8;
4037843e:	0a4d      	mov.n	a4, a10
            div_ref = 0;
40378440:	050c      	movi.n	a5, 0
40378442:	000286        	j	40378450 <rtc_clk_bbpll_configure+0x84>
            dcur = 0;
40378445:	00a072        	movi	a7, 0
            dchgp = 4;
40378448:	04a022        	movi	a2, 4
            div7_0 = 26;
4037844b:	1aa042        	movi	a4, 26
            div_ref = 1;
4037844e:	150c      	movi.n	a5, 1
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x6B);
40378450:	6ba0d2        	movi	a13, 107
40378453:	4c0c      	movi.n	a12, 4
40378455:	1b0c      	movi.n	a11, 1
40378457:	66a0a2        	movi	a10, 102
4037845a:	ffe7a5        	call8	403782d4 <regi2c_ctrl_write_reg>
4037845d:	056d      	mov.n	a6, a5
4037845f:	000886        	j	40378485 <rtc_clk_bbpll_configure+0xb9>
40378462:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
        switch (xtal_freq_mhz) {
40378465:	0c06c2        	l8ui	a12, a6, 12
            div7_0 = 4;
40378468:	050c44        	ee.ldqa.u16.128.ip	a4, 192
            div_ref = 0;
4037846b:	0000c6        	j	40378472 <rtc_clk_bbpll_configure+0xa6>
            div7_0 = 6;
4037846e:	640c      	movi.n	a4, 6
            div_ref = 1;
40378470:	150c      	movi.n	a5, 1
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x69);
40378472:	69a0d2        	movi	a13, 105
40378475:	4c0c      	movi.n	a12, 4
40378477:	1b0c      	movi.n	a11, 1
40378479:	66a0a2        	movi	a10, 102
4037847c:	ffe565        	call8	403782d4 <regi2c_ctrl_write_reg>
4037847f:	370c      	movi.n	a7, 3
40378481:	520c      	movi.n	a2, 5
40378483:	060c      	movi.n	a6, 0
    uint8_t i2c_bbpll_lref  = (dchgp << I2C_BBPLL_OC_DCHGP_LSB) | (div_ref);
40378485:	11d2c0        	slli	a13, a2, 4
    uint8_t i2c_bbpll_dcur = (1 << I2C_BBPLL_OC_DLREF_SEL_LSB ) | (3 << I2C_BBPLL_OC_DHREF_SEL_LSB) | dcur;
40378488:	70a082        	movi	a8, 112
4037848b:	207780        	or	a7, a7, a8
4037848e:	747070        	extui	a7, a7, 0, 8
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_REF_DIV, i2c_bbpll_lref);
40378491:	20d5d0        	or	a13, a5, a13
40378494:	2c0c      	movi.n	a12, 2
40378496:	1b0c      	movi.n	a11, 1
40378498:	66a0a2        	movi	a10, 102
4037849b:	ffe3a5        	call8	403782d4 <regi2c_ctrl_write_reg>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DIV_7_0, i2c_bbpll_div_7_0);
4037849e:	04dd      	mov.n	a13, a4
403784a0:	3c0c      	movi.n	a12, 3
403784a2:	1b0c      	movi.n	a11, 1
403784a4:	66a0a2        	movi	a10, 102
403784a7:	ffe2e5        	call8	403782d4 <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR1, dr1);
403784aa:	06fd      	mov.n	a15, a6
403784ac:	0e0c      	movi.n	a14, 0
403784ae:	2d0c      	movi.n	a13, 2
403784b0:	5c0c      	movi.n	a12, 5
403784b2:	1b0c      	movi.n	a11, 1
403784b4:	66a0a2        	movi	a10, 102
403784b7:	ffe6e5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR3, dr3);
403784ba:	06fd      	mov.n	a15, a6
403784bc:	4e0c      	movi.n	a14, 4
403784be:	6d0c      	movi.n	a13, 6
403784c0:	5c0c      	movi.n	a12, 5
403784c2:	01a0b2        	movi	a11, 1
403784c5:	66a0a2        	movi	a10, 102
403784c8:	ffe5a5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DCUR, i2c_bbpll_dcur);
403784cb:	07dd      	mov.n	a13, a7
403784cd:	6c0c      	movi.n	a12, 6
403784cf:	01a0b2        	movi	a11, 1
403784d2:	66a0a2        	movi	a10, 102
403784d5:	ffdfe5        	call8	403782d4 <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_VCO_DBIAS, dbias);
403784d8:	3f0c      	movi.n	a15, 3
403784da:	0e0c      	movi.n	a14, 0
403784dc:	1d0c      	movi.n	a13, 1
403784de:	9c0c      	movi.n	a12, 9
403784e0:	20bdd0        	or	a11, a13, a13
403784e3:	66a0a2        	movi	a10, 102
403784e6:	ffe3e5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
 *
 * @return True if calibration is done; otherwise false
 */
static inline __attribute__((always_inline)) bool regi2c_ctrl_ll_bbpll_calibration_is_done(void)
{
    return REG_GET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_CAL_DONE);
403784e9:	f11081        	l32r	a8, 4037492c <_iram_text_start+0x528> (6000e040 <SENS+0x5840>)
403784ec:	0020c0        	memw
403784ef:	0888      	l32i.n	a8, a8, 0
    while(!regi2c_ctrl_ll_bbpll_calibration_is_done());
403784f1:	f47887        	bbci	a8, 24, 403784e9 <rtc_clk_bbpll_configure+0x11d>
    esp_rom_delay_us(10);
403784f4:	aa0c      	movi.n	a10, 10
403784f6:	efc781        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
403784f9:	0008e0        	callx8	a8
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
403784fc:	f10c81        	l32r	a8, 4037492c <_iram_text_start+0x528> (6000e040 <SENS+0x5840>)
403784ff:	0020c0        	memw
40378502:	0898      	l32i.n	a9, a8, 0
40378504:	7a7c      	movi.n	a10, -9
40378506:	1099a0        	and	a9, a9, a10
40378509:	0020c0        	memw
4037850c:	0899      	s32i.n	a9, a8, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
4037850e:	0020c0        	memw
40378511:	0898      	l32i.n	a9, a8, 0
40378513:	4a0c      	movi.n	a10, 4
40378515:	2099a0        	or	a9, a9, a10
40378518:	0020c0        	memw
4037851b:	0899      	s32i.n	a9, a8, 0
    s_cur_pll_freq = pll_freq;
4037851d:	f0fe81        	l32r	a8, 40374918 <_iram_text_start+0x514> (3fc94f90 <s_cur_pll_freq>)
40378520:	0839      	s32i.n	a3, a8, 0
}
40378522:	f01d      	retw.n

40378524 <rtc_clk_bbpll_add_consumer>:
{
40378524:	004136        	entry	a1, 32
    s_bbpll_digi_consumers_ref_count += 1;
40378527:	f10291        	l32r	a9, 40374930 <_iram_text_start+0x52c> (3fc94f88 <s_bbpll_digi_consumers_ref_count>)
4037852a:	0988      	l32i.n	a8, a9, 0
4037852c:	881b      	addi.n	a8, a8, 1
4037852e:	0989      	s32i.n	a8, a9, 0
}
40378530:	f01d      	retw.n
	...

40378534 <rtc_clk_bbpll_remove_consumer>:
{
40378534:	004136        	entry	a1, 32
    s_bbpll_digi_consumers_ref_count -= 1;
40378537:	f0fe91        	l32r	a9, 40374930 <_iram_text_start+0x52c> (3fc94f88 <s_bbpll_digi_consumers_ref_count>)
4037853a:	0988      	l32i.n	a8, a9, 0
4037853c:	880b      	addi.n	a8, a8, -1
4037853e:	0989      	s32i.n	a8, a9, 0
}
40378540:	f01d      	retw.n
	...

40378544 <rtc_clk_32k_enable>:
{
40378544:	004136        	entry	a1, 32
40378547:	742020        	extui	a2, a2, 0, 8
    if (enable) {
4037854a:	0be216        	beqz	a2, 4037860c <rtc_clk_32k_enable+0xc8>
        SET_PERI_REG_MASK(RTC_IO_XTAL_32P_PAD_REG, RTC_IO_X32P_MUX_SEL);
4037854d:	f0f991        	l32r	a9, 40374934 <_iram_text_start+0x530> (600084c0 <RTCIO+0xc0>)
40378550:	0020c0        	memw
40378553:	0988      	l32i.n	a8, a9, 0
40378555:	f0f8a1        	l32r	a10, 40374938 <_iram_text_start+0x534> (80000 <UserFrameTotalSize+0x7ff00>)
40378558:	2088a0        	or	a8, a8, a10
4037855b:	0020c0        	memw
4037855e:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_IO_XTAL_32N_PAD_REG, RTC_IO_X32N_MUX_SEL);
40378560:	f0f791        	l32r	a9, 4037493c <_iram_text_start+0x538> (600084c4 <RTCIO+0xc4>)
40378563:	0020c0        	memw
40378566:	0988      	l32i.n	a8, a9, 0
40378568:	2088a0        	or	a8, a8, a10
4037856b:	0020c0        	memw
4037856e:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_GPIO_SEL);
40378570:	f0f491        	l32r	a9, 40374940 <_iram_text_start+0x53c> (60008060 <RTCCNTL+0x60>)
40378573:	0020c0        	memw
40378576:	0988      	l32i.n	a8, a9, 0
40378578:	f0f3a1        	l32r	a10, 40374944 <_iram_text_start+0x540> (ff7fffff <_rtc_reserved_end+0x9f6fffff>)
4037857b:	1088a0        	and	a8, a8, a10
4037857e:	0020c0        	memw
40378581:	0989      	s32i.n	a8, a9, 0
        clk_ll_xtal32k_config_t cfg = CLK_LL_XTAL32K_CONFIG_DEFAULT();
40378583:	380c      	movi.n	a8, 3
40378585:	c0a0a2        	movi	a10, 192
40378588:	2088a0        	or	a8, a8, a10
4037858b:	00a6a2        	movi	a10, 0x600
4037858e:	2088a0        	or	a8, a8, a10
40378591:	f02ca1        	l32r	a10, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
40378594:	2088a0        	or	a8, a8, a10
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DAC_XTAL_32K, cfg.dac);
40378597:	0020c0        	memw
4037859a:	09a8      	l32i.n	a10, a9, 0
4037859c:	f0ebb1        	l32r	a11, 40374948 <_iram_text_start+0x544> (fff1ffff <_rtc_reserved_end+0x9fe1ffff>)
4037859f:	10aab0        	and	a10, a10, a11
403785a2:	f0eab1        	l32r	a11, 4037494c <_iram_text_start+0x548> (60000 <UserFrameTotalSize+0x5ff00>)
403785a5:	20aab0        	or	a10, a10, a11
403785a8:	0020c0        	memw
403785ab:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DRES_XTAL_32K, cfg.dres);
403785ad:	0020c0        	memw
403785b0:	09a8      	l32i.n	a10, a9, 0
403785b2:	f0e7b1        	l32r	a11, 40374950 <_iram_text_start+0x54c> (ffff1fff <_rtc_reserved_end+0x9fef1fff>)
403785b5:	10aab0        	and	a10, a10, a11
403785b8:	24b680        	extui	a11, a8, 6, 3
403785bb:	11bb30        	slli	a11, a11, 13
403785be:	20aab0        	or	a10, a10, a11
403785c1:	0020c0        	memw
403785c4:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DGM_XTAL_32K, cfg.dgm);
403785c6:	0020c0        	memw
403785c9:	09a8      	l32i.n	a10, a9, 0
403785cb:	f0e2b1        	l32r	a11, 40374954 <_iram_text_start+0x550> (ffffe3ff <_rtc_reserved_end+0x9fefe3ff>)
403785ce:	10aab0        	and	a10, a10, a11
403785d1:	24b980        	extui	a11, a8, 9, 3
403785d4:	11bb60        	slli	a11, a11, 10
403785d7:	20aab0        	or	a10, a10, a11
403785da:	0020c0        	memw
403785dd:	09a9      	s32i.n	a10, a9, 0
        REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DBUF_XTAL_32K, cfg.dbuf);
403785df:	0020c0        	memw
403785e2:	09a8      	l32i.n	a10, a9, 0
403785e4:	ffadb2        	movi	a11, 0xfffffdff
403785e7:	10aab0        	and	a10, a10, a11
403785ea:	048c80        	extui	a8, a8, 12, 1
403785ed:	118870        	slli	a8, a8, 9
403785f0:	208a80        	or	a8, a10, a8
403785f3:	0020c0        	memw
403785f6:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
403785f8:	0020c0        	memw
403785fb:	0988      	l32i.n	a8, a9, 0
403785fd:	f094a1        	l32r	a10, 40374850 <_iram_text_start+0x44c> (10000 <UserFrameTotalSize+0xff00>)
40378600:	2088a0        	or	a8, a8, a10
40378603:	0020c0        	memw
40378606:	0989      	s32i.n	a8, a9, 0
40378608:	0008c6        	j	4037862f <rtc_clk_32k_enable+0xeb>
4037860b:	00          	.byte	00
    SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_XPD_FORCE);
4037860c:	f0cd81        	l32r	a8, 40374940 <_iram_text_start+0x53c> (60008060 <RTCCNTL+0x60>)
4037860f:	0020c0        	memw
40378612:	0898      	l32i.n	a9, a8, 0
40378614:	80a0a2        	movi	a10, 128
40378617:	2099a0        	or	a9, a9, a10
4037861a:	0020c0        	memw
4037861d:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
4037861f:	0020c0        	memw
40378622:	0898      	l32i.n	a9, a8, 0
40378624:	f0cda1        	l32r	a10, 40374958 <_iram_text_start+0x554> (fffeffff <_rtc_reserved_end+0x9feeffff>)
40378627:	1099a0        	and	a9, a9, a10
4037862a:	0020c0        	memw
4037862d:	0899      	s32i.n	a9, a8, 0
}
4037862f:	f01d      	retw.n
40378631:	000000        	ill

40378634 <rtc_clk_32k_enable_external>:
{
40378634:	004136        	entry	a1, 32
    PIN_INPUT_ENABLE(IO_MUX_GPIO15_REG);
40378637:	f0c991        	l32r	a9, 4037495c <_iram_text_start+0x558> (60009040 <SENS+0x840>)
4037863a:	0020c0        	memw
4037863d:	0988      	l32i.n	a8, a9, 0
4037863f:	00a2a2        	movi	a10, 0x200
40378642:	2088a0        	or	a8, a8, a10
40378645:	0020c0        	memw
40378648:	0989      	s32i.n	a8, a9, 0
 *
 * @param enable true to enable the clock / false to disable the clock
 */
static inline void rtcio_ll_enable_io_clock(bool enable)
{
    SENS.sar_peri_clk_gate_conf.iomux_clk_en = enable;
4037864a:	f0c591        	l32r	a9, 40374960 <_iram_text_start+0x55c> (60008800 <SENS>)
4037864d:	0020c0        	memw
40378650:	4129a2        	l32i	a10, a9, 0x104
40378653:	f05781        	l32r	a8, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
40378656:	208a80        	or	a8, a10, a8
40378659:	0020c0        	memw
4037865c:	416982        	s32i	a8, a9, 0x104
    SET_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, RTC_CNTL_X32P_HOLD);
4037865f:	f0c191        	l32r	a9, 40374964 <_iram_text_start+0x560> (600080d8 <RTCCNTL+0xd8>)
40378662:	0020c0        	memw
40378665:	0988      	l32i.n	a8, a9, 0
40378667:	ef80a1        	l32r	a10, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
4037866a:	2088a0        	or	a8, a8, a10
4037866d:	0020c0        	memw
40378670:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_GPIO_SEL);
40378672:	f0b391        	l32r	a9, 40374940 <_iram_text_start+0x53c> (60008060 <RTCCNTL+0x60>)
40378675:	0020c0        	memw
40378678:	0988      	l32i.n	a8, a9, 0
4037867a:	f0bba1        	l32r	a10, 40374968 <_iram_text_start+0x564> (800000 <UserFrameTotalSize+0x7fff00>)
4037867d:	2088a0        	or	a8, a8, a10
40378680:	0020c0        	memw
40378683:	0989      	s32i.n	a8, a9, 0
}
40378685:	f01d      	retw.n
	...

40378688 <rtc_clk_32k_disable_external>:
{
40378688:	004136        	entry	a1, 32
    PIN_INPUT_DISABLE(IO_MUX_GPIO15_REG);
4037868b:	f0b491        	l32r	a9, 4037495c <_iram_text_start+0x558> (60009040 <SENS+0x840>)
4037868e:	0020c0        	memw
40378691:	0988      	l32i.n	a8, a9, 0
40378693:	ffada2        	movi	a10, 0xfffffdff
40378696:	1088a0        	and	a8, a8, a10
40378699:	0020c0        	memw
4037869c:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, RTC_CNTL_X32P_HOLD);
4037869e:	f0b191        	l32r	a9, 40374964 <_iram_text_start+0x560> (600080d8 <RTCCNTL+0xd8>)
403786a1:	0020c0        	memw
403786a4:	0988      	l32i.n	a8, a9, 0
403786a6:	f0b1a1        	l32r	a10, 4037496c <_iram_text_start+0x568> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
403786a9:	1088a0        	and	a8, a8, a10
403786ac:	0020c0        	memw
403786af:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_XPD_FORCE);
403786b1:	f0a381        	l32r	a8, 40374940 <_iram_text_start+0x53c> (60008060 <RTCCNTL+0x60>)
403786b4:	0020c0        	memw
403786b7:	0898      	l32i.n	a9, a8, 0
403786b9:	80a0a2        	movi	a10, 128
403786bc:	2099a0        	or	a9, a9, a10
403786bf:	0020c0        	memw
403786c2:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
403786c4:	0020c0        	memw
403786c7:	0898      	l32i.n	a9, a8, 0
403786c9:	f0a3a1        	l32r	a10, 40374958 <_iram_text_start+0x554> (fffeffff <_rtc_reserved_end+0x9feeffff>)
403786cc:	1099a0        	and	a9, a9, a10
403786cf:	0020c0        	memw
403786d2:	0899      	s32i.n	a9, a8, 0
}
403786d4:	f01d      	retw.n
	...

403786d8 <rtc_clk_8m_enable>:
{
403786d8:	004136        	entry	a1, 32
403786db:	742020        	extui	a2, a2, 0, 8
403786de:	743030        	extui	a3, a3, 0, 8
    if (clk_8m_en) {
403786e1:	72bc      	beqz.n	a2, 4037871c <rtc_clk_8m_enable+0x44>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
403786e3:	f0a391        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
403786e6:	0020c0        	memw
403786e9:	0988      	l32i.n	a8, a9, 0
403786eb:	bfafa2        	movi	a10, -65
403786ee:	1088a0        	and	a8, a8, a10
403786f1:	0020c0        	memw
403786f4:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, CLK_LL_RC_FAST_ENABLE_WAIT_DEFAULT);
403786f6:	f09f91        	l32r	a9, 40374974 <_iram_text_start+0x570> (6000801c <RTCCNTL+0x1c>)
403786f9:	0020c0        	memw
403786fc:	0988      	l32i.n	a8, a9, 0
403786fe:	f09ea1        	l32r	a10, 40374978 <_iram_text_start+0x574> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
40378701:	1088a0        	and	a8, a8, a10
40378704:	40a1a2        	movi	a10, 0x140
40378707:	2088a0        	or	a8, a8, a10
4037870a:	0020c0        	memw
4037870d:	0989      	s32i.n	a8, a9, 0
        esp_rom_delay_us(SOC_DELAY_RC_FAST_ENABLE);
4037870f:	32a0a2        	movi	a10, 50
40378712:	ef4081        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40378715:	0008e0        	callx8	a8
40378718:	000ac6        	j	40378747 <rtc_clk_8m_enable+0x6f>
4037871b:	959100        	extui	a9, a0, 17, 10
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
4037871e:	20c0f0        	or	a12, a0, a15
40378721:	098800        	l32e	a0, a8, -32
40378724:	0a4c      	movi.n	a10, 64
40378726:	2088a0        	or	a8, a8, a10
40378729:	0020c0        	memw
4037872c:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, CLK_LL_RC_FAST_WAIT_DEFAULT);
4037872e:	f09191        	l32r	a9, 40374974 <_iram_text_start+0x570> (6000801c <RTCCNTL+0x1c>)
40378731:	0020c0        	memw
40378734:	0988      	l32i.n	a8, a9, 0
40378736:	f090a1        	l32r	a10, 40374978 <_iram_text_start+0x574> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
40378739:	1088a0        	and	a8, a8, a10
4037873c:	00a5a2        	movi	a10, 0x500
4037873f:	2088a0        	or	a8, a8, a10
40378742:	0020c0        	memw
40378745:	0989      	s32i.n	a8, a9, 0
    if (d256_en) {
40378747:	539c      	beqz.n	a3, 40378760 <rtc_clk_8m_enable+0x88>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
40378749:	f08991        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
4037874c:	0020c0        	memw
4037874f:	0988      	l32i.n	a8, a9, 0
40378751:	7fafa2        	movi	a10, -129
40378754:	1088a0        	and	a8, a8, a10
40378757:	0020c0        	memw
4037875a:	0989      	s32i.n	a8, a9, 0
}
4037875c:	0004c6        	j	40378773 <rtc_clk_8m_enable+0x9b>
4037875f:	849100        	extui	a9, a0, 1, 9
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
40378762:	20c0f0        	or	a12, a0, a15
40378765:	098800        	l32e	a0, a8, -32
40378768:	80a0a2        	movi	a10, 128
4037876b:	2088a0        	or	a8, a8, a10
4037876e:	0020c0        	memw
40378771:	0989      	s32i.n	a8, a9, 0
}
40378773:	f01d      	retw.n
40378775:	000000        	ill

40378778 <rtc_clk_8md256_enabled>:
{
40378778:	004136        	entry	a1, 32
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
4037877b:	f07d81        	l32r	a8, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
4037877e:	0020c0        	memw
40378781:	0828      	l32i.n	a2, a8, 0
40378783:	80a082        	movi	a8, 128
40378786:	102280        	and	a2, a2, a8
}
40378789:	40f220        	nsau	a2, a2
4037878c:	412520        	srli	a2, a2, 5
4037878f:	f01d      	retw.n
40378791:	000000        	ill

40378794 <rtc_clk_slow_src_set>:
{
40378794:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
40378797:	f07681        	l32r	a8, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
4037879a:	0020c0        	memw
4037879d:	0888      	l32i.n	a8, a8, 0
4037879f:	158e80        	extui	a8, a8, 30, 2
    switch (clk_sel) {
403787a2:	131826        	beqi	a8, 1, 403787b9 <rtc_clk_slow_src_set+0x25>
403787a5:	102826        	beqi	a8, 2, 403787b9 <rtc_clk_slow_src_set+0x25>
403787a8:	d88c      	beqz.n	a8, 403787b9 <rtc_clk_slow_src_set+0x25>
        HAL_ASSERT(false);
403787aa:	f074d1        	l32r	a13, 4037497c <_iram_text_start+0x578> (3fc93c94 <__func__$0+0xa8>)
403787ad:	f074c1        	l32r	a12, 40374980 <_iram_text_start+0x57c> (3fc93bbc <__func__$0>)
403787b0:	1aa2b2        	movi	a11, 0x21a
403787b3:	f074a1        	l32r	a10, 40374984 <_iram_text_start+0x580> (3fc93d78 <__func__$0+0x18c>)
403787b6:	075725        	call8	4037fd28 <__assert_func>
    if (clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256 && clk_src_before_switch != SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {       // Switch to RC_FAST_D256
403787b9:	fec292        	addi	a9, a2, -2
403787bc:	40f990        	nsau	a9, a9
403787bf:	419590        	srli	a9, a9, 5
403787c2:	fec8b2        	addi	a11, a8, -2
403787c5:	1a0c      	movi.n	a10, 1
403787c7:	83abb0        	moveqz	a10, a11, a11
403787ca:	0e09a7        	bnone	a9, a10, 403787dc <rtc_clk_slow_src_set+0x48>
        esp_sleep_sub_mode_config(ESP_SLEEP_RTC_USE_RC_FAST_MODE, true);
403787cd:	1b0c      	movi.n	a11, 1
403787cf:	00a0a2        	movi	a10, 0
403787d2:	f06d81        	l32r	a8, 40374988 <_iram_text_start+0x584> (42018cb0 <esp_sleep_sub_mode_config>)
403787d5:	0008e0        	callx8	a8
403787d8:	000806        	j	403787fc <rtc_clk_slow_src_set+0x68>
403787db:	c2a200        	quou	a10, a2, a0
    } else if (clk_src != SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256 && clk_src_before_switch == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) { // Switch away from RC_FAST_D256
403787de:	a0190cfe 	ee.fft.ams.s16.st.incp	q1, q1, a15, a12, q1, q0, q0, 0
403787e2:	839a      	add.n	a8, a3, a9
403787e4:	fec882        	addi	a8, a8, -2
403787e7:	40f880        	nsau	a8, a8
403787ea:	418580        	srli	a8, a8, 5
403787ed:	0b0987        	bnone	a9, a8, 403787fc <rtc_clk_slow_src_set+0x68>
        esp_sleep_sub_mode_config(ESP_SLEEP_RTC_USE_RC_FAST_MODE, false);
403787f0:	00a0b2        	movi	a11, 0
403787f3:	20abb0        	or	a10, a11, a11
403787f6:	f06481        	l32r	a8, 40374988 <_iram_text_start+0x584> (42018cb0 <esp_sleep_sub_mode_config>)
403787f9:	0008e0        	callx8	a8
    switch (in_sel) {
403787fc:	1c1226        	beqi	a2, 1, 4037881c <rtc_clk_slow_src_set+0x88>
403787ff:	352226        	beqi	a2, 2, 40378838 <rtc_clk_slow_src_set+0xa4>
40378802:	04e256        	bnez	a2, 40378854 <rtc_clk_slow_src_set+0xc0>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 0);
40378805:	f05a91        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378808:	0020c0        	memw
4037880b:	0988      	l32i.n	a8, a9, 0
4037880d:	1188e0        	slli	a8, a8, 2
40378810:	418280        	srli	a8, a8, 2
40378813:	0020c0        	memw
40378816:	0989      	s32i.n	a8, a9, 0
        break;
40378818:	000ec6        	j	40378857 <rtc_clk_slow_src_set+0xc3>
4037881b:	559100        	extui	a9, a0, 17, 6
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 1);
4037881e:	20c0f0        	or	a12, a0, a15
40378821:	098800        	l32e	a0, a8, -32
40378824:	1188e0        	slli	a8, a8, 2
40378827:	418280        	srli	a8, a8, 2
4037882a:	ef6ea1        	l32r	a10, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037882d:	2088a0        	or	a8, a8, a10
40378830:	0020c0        	memw
40378833:	0989      	s32i.n	a8, a9, 0
        break;
40378835:	000786        	j	40378857 <rtc_clk_slow_src_set+0xc3>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 2);
40378838:	f04e91        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
4037883b:	0020c0        	memw
4037883e:	0988      	l32i.n	a8, a9, 0
40378840:	1188e0        	slli	a8, a8, 2
40378843:	418280        	srli	a8, a8, 2
40378846:	efdaa1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
40378849:	2088a0        	or	a8, a8, a10
4037884c:	0020c0        	memw
4037884f:	0989      	s32i.n	a8, a9, 0
        break;
40378851:	000086        	j	40378857 <rtc_clk_slow_src_set+0xc3>
        abort();
40378854:	074165        	call8	4037fc6c <abort>
    if (clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
40378857:	151266        	bnei	a2, 1, 40378870 <rtc_clk_slow_src_set+0xdc>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
4037885a:	f04591        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
4037885d:	0020c0        	memw
40378860:	0988      	l32i.n	a8, a9, 0
40378862:	00a1a2        	movi	a10, 0x100
40378865:	2088a0        	or	a8, a8, a10
40378868:	0020c0        	memw
4037886b:	0989      	s32i.n	a8, a9, 0
}
4037886d:	000486        	j	40378883 <rtc_clk_slow_src_set+0xef>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378870:	f04091        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378873:	0020c0        	memw
40378876:	0988      	l32i.n	a8, a9, 0
40378878:	ffaea2        	movi	a10, 0xfffffeff
4037887b:	1088a0        	and	a8, a8, a10
4037887e:	0020c0        	memw
40378881:	0989      	s32i.n	a8, a9, 0
    esp_rom_delay_us(SOC_DELAY_RTC_SLOW_CLK_SWITCH);
40378883:	2ca1a2        	movi	a10, 0x12c
40378886:	eee381        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40378889:	0008e0        	callx8	a8
}
4037888c:	f01d      	retw.n
	...

40378890 <rtc_clk_slow_src_get>:
{
40378890:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
40378893:	f03781        	l32r	a8, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378896:	0020c0        	memw
40378899:	002822        	l32i	a2, a8, 0
4037889c:	152e20        	extui	a2, a2, 30, 2
    switch (clk_sel) {
4037889f:	141226        	beqi	a2, 1, 403788b7 <rtc_clk_slow_src_get+0x27>
403788a2:	112226        	beqi	a2, 2, 403788b7 <rtc_clk_slow_src_get+0x27>
403788a5:	00e216        	beqz	a2, 403788b7 <rtc_clk_slow_src_get+0x27>
        HAL_ASSERT(false);
403788a8:	f035d1        	l32r	a13, 4037497c <_iram_text_start+0x578> (3fc93c94 <__func__$0+0xa8>)
403788ab:	f035c1        	l32r	a12, 40374980 <_iram_text_start+0x57c> (3fc93bbc <__func__$0>)
403788ae:	1aa2b2        	movi	a11, 0x21a
403788b1:	f034a1        	l32r	a10, 40374984 <_iram_text_start+0x580> (3fc93d78 <__func__$0+0x18c>)
403788b4:	074725        	call8	4037fd28 <__assert_func>
}
403788b7:	000090        	retw
	...

403788bc <rtc_clk_slow_freq_get_hz>:
{
403788bc:	004136        	entry	a1, 32
    switch (rtc_clk_slow_src_get()) {
403788bf:	fffd25        	call8	40378890 <rtc_clk_slow_src_get>
403788c2:	0a1a26        	beqi	a10, 1, 403788d0 <rtc_clk_slow_freq_get_hz+0x14>
403788c5:	0f2a26        	beqi	a10, 2, 403788d8 <rtc_clk_slow_freq_get_hz+0x1c>
403788c8:	2adc      	bnez.n	a10, 403788de <rtc_clk_slow_freq_get_hz+0x22>
403788ca:	f03021        	l32r	a2, 4037498c <_iram_text_start+0x588> (21340 <UserFrameTotalSize+0x21240>)
403788cd:	0003c6        	j	403788e0 <rtc_clk_slow_freq_get_hz+0x24>
    case SOC_RTC_SLOW_CLK_SRC_XTAL32K: return SOC_CLK_XTAL32K_FREQ_APPROX;
403788d0:	eee621        	l32r	a2, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
403788d3:	000246        	j	403788e0 <rtc_clk_slow_freq_get_hz+0x24>
403788d6:	210000        	srai	a0, a0, 0
    case SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256: return SOC_CLK_RC_FAST_D256_FREQ_APPROX;
403788d9:	0046f02e 	ee.vmulas.s16.accx.ld.ip.qup	q0, a2, 0, q3, q6, q4, q6
403788dd:	020c00        	andb	b0, b12, b0
}
403788e0:	f01d      	retw.n
	...

403788e4 <rtc_clk_fast_src_set>:
{
403788e4:	004136        	entry	a1, 32
    switch (in_sel) {
403788e7:	528c      	beqz.n	a2, 403788f0 <rtc_clk_fast_src_set+0xc>
403788e9:	1b1226        	beqi	a2, 1, 40378908 <rtc_clk_fast_src_set+0x24>
403788ec:	000b86        	j	4037891e <rtc_clk_fast_src_set+0x3a>
403788ef:	209100        	or	a9, a1, a0
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 0);
403788f2:	20c0f0        	or	a12, a0, a15
403788f5:	098800        	l32e	a0, a8, -32
403788f8:	efb2a1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
403788fb:	1088a0        	and	a8, a8, a10
403788fe:	0020c0        	memw
40378901:	0989      	s32i.n	a8, a9, 0
        break;
40378903:	000686        	j	40378921 <rtc_clk_fast_src_set+0x3d>
40378906:	910000        	srl	a0, a0
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 1);
40378909:	f01a      	add.n	a15, a0, a1
4037890b:	0020c0        	memw
4037890e:	0988      	l32i.n	a8, a9, 0
40378910:	f021a1        	l32r	a10, 40374994 <_iram_text_start+0x590> (20000000 <UserFrameTotalSize+0x1fffff00>)
40378913:	2088a0        	or	a8, a8, a10
40378916:	0020c0        	memw
40378919:	0989      	s32i.n	a8, a9, 0
        break;
4037891b:	000086        	j	40378921 <rtc_clk_fast_src_set+0x3d>
        abort();
4037891e:	0734e5        	call8	4037fc6c <abort>
    esp_rom_delay_us(SOC_DELAY_RTC_FAST_CLK_SWITCH);
40378921:	3a0c      	movi.n	a10, 3
40378923:	eebc81        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40378926:	0008e0        	callx8	a8
}
40378929:	f01d      	retw.n
	...

4037892c <rtc_clk_xtal_freq_get>:
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
}

soc_xtal_freq_t rtc_clk_xtal_freq_get(void)
{
4037892c:	004136        	entry	a1, 32
    uint32_t xtal_freq_reg = READ_PERI_REG(RTC_XTAL_FREQ_REG);
4037892f:	f01a81        	l32r	a8, 40374998 <_iram_text_start+0x594> (600080c0 <RTCCNTL+0xc0>)
40378932:	0020c0        	memw
40378935:	0828      	l32i.n	a2, a8, 0
    if ((xtal_freq_reg & 0xFFFF) == ((xtal_freq_reg >> 16) & 0xFFFF) &&
40378937:	f49020        	extui	a9, a2, 0, 16
4037893a:	f58020        	extui	a8, a2, 16, 16
4037893d:	0e9987        	bne	a9, a8, 4037894f <rtc_clk_xtal_freq_get+0x23>
        xtal_freq_reg != 0 && xtal_freq_reg != UINT32_MAX) {
40378940:	820b      	addi.n	a8, a2, -1
40378942:	d97c      	movi.n	a9, -3
40378944:	073987        	bltu	a9, a8, 4037894f <rtc_clk_xtal_freq_get+0x23>
        return xtal_freq_reg & ~RTC_DISABLE_ROM_LOG & UINT16_MAX;
40378947:	e42120        	extui	a2, a2, 1, 15
4037894a:	222a      	add.n	a2, a2, a2
    uint32_t xtal_freq_mhz = clk_ll_xtal_load_freq_mhz();
    if (xtal_freq_mhz == 0) {
4037894c:	01a256        	bnez	a2, 4037896a <rtc_clk_xtal_freq_get+0x3e>
4037894f:	eecc81        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40378952:	0888      	l32i.n	a8, a8, 0
        ESP_HW_LOGW(TAG, "invalid RTC_XTAL_FREQ_REG value, assume 40MHz");
40378954:	1028b6        	bltui	a8, 2, 40378968 <rtc_clk_xtal_freq_get+0x3c>
40378957:	072ae5        	call8	4037fc04 <esp_log_timestamp>
4037895a:	f010c1        	l32r	a12, 4037499c <_iram_text_start+0x598> (3fc93db0 <__func__$0+0x1c4>)
4037895d:	0abd      	mov.n	a11, a10
4037895f:	f010a1        	l32r	a10, 403749a0 <_iram_text_start+0x59c> (3fc93db8 <__func__$0+0x1cc>)
40378962:	eede81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40378965:	0008e0        	callx8	a8
        return SOC_XTAL_FREQ_40M;
40378968:	822c      	movi.n	a2, 40
    }
    return (soc_xtal_freq_t)xtal_freq_mhz;
}
4037896a:	f01d      	retw.n

4037896c <rtc_clk_cpu_freq_mhz_to_config>:
{
4037896c:	004136        	entry	a1, 32
    uint32_t xtal_freq = (uint32_t)rtc_clk_xtal_freq_get();
4037896f:	fffbe5        	call8	4037892c <rtc_clk_xtal_freq_get>
    if (freq_mhz <= xtal_freq && freq_mhz != 0) {
40378972:	ffc282        	addi	a8, a2, -1
40378975:	17b8a7        	bgeu	a8, a10, 40378990 <rtc_clk_cpu_freq_mhz_to_config+0x24>
        divider = xtal_freq / freq_mhz;
40378978:	c29a20        	quou	a9, a10, a2
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
4037897b:	418190        	srli	a8, a9, 1
4037897e:	8088a0        	add	a8, a8, a10
40378981:	c28890        	quou	a8, a8, a9
        if (real_freq_mhz != freq_mhz) {
40378984:	429287        	bne	a2, a8, 403789ca <rtc_clk_cpu_freq_mhz_to_config+0x5e>
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
40378987:	202880        	or	a2, a8, a8
        source = SOC_CPU_CLK_SRC_XTAL;
4037898a:	080c      	movi.n	a8, 0
4037898c:	000b46        	j	403789bd <rtc_clk_cpu_freq_mhz_to_config+0x51>
4037898f:	085c00        	lsx	f5, a12, a0
    } else if (freq_mhz == 80) {
40378992:	161287        	beq	a2, a8, 403789ac <rtc_clk_cpu_freq_mhz_to_config+0x40>
    } else if (freq_mhz == 160) {
40378995:	a0a082        	movi	a8, 160
40378998:	1a1287        	beq	a2, a8, 403789b6 <rtc_clk_cpu_freq_mhz_to_config+0x4a>
    } else if (freq_mhz == 240) {
4037899b:	f0a082        	movi	a8, 240
4037899e:	2d9287        	bne	a2, a8, 403789cf <rtc_clk_cpu_freq_mhz_to_config+0x63>
        divider = 2;
403789a1:	290c      	movi.n	a9, 2
        source = SOC_CPU_CLK_SRC_PLL;
403789a3:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
403789a5:	e0a1a2        	movi	a10, 0x1e0
403789a8:	000446        	j	403789bd <rtc_clk_cpu_freq_mhz_to_config+0x51>
403789ab:	00          	.byte	00
        divider = 6;
403789ac:	690c      	movi.n	a9, 6
        source = SOC_CPU_CLK_SRC_PLL;
403789ae:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
403789b0:	e0a1a2        	movi	a10, 0x1e0
403789b3:	000186        	j	403789bd <rtc_clk_cpu_freq_mhz_to_config+0x51>
        divider = 3;
403789b6:	390c      	movi.n	a9, 3
        source = SOC_CPU_CLK_SRC_PLL;
403789b8:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
403789ba:	e0a1a2        	movi	a10, 0x1e0
    *out_config = (rtc_cpu_freq_config_t) {
403789bd:	0389      	s32i.n	a8, a3, 0
403789bf:	13a9      	s32i.n	a10, a3, 4
403789c1:	2399      	s32i.n	a9, a3, 8
403789c3:	3329      	s32i.n	a2, a3, 12
    return true;
403789c5:	120c      	movi.n	a2, 1
403789c7:	000186        	j	403789d1 <rtc_clk_cpu_freq_mhz_to_config+0x65>
            return false;
403789ca:	020c      	movi.n	a2, 0
403789cc:	000046        	j	403789d1 <rtc_clk_cpu_freq_mhz_to_config+0x65>
        return false;
403789cf:	020c      	movi.n	a2, 0
}
403789d1:	f01d      	retw.n
	...

403789d4 <rtc_clk_cpu_freq_get_config>:
{
403789d4:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
403789d7:	eff381        	l32r	a8, 403749a4 <_iram_text_start+0x5a0> (600c0060 <SYSTEM+0x60>)
403789da:	0020c0        	memw
403789dd:	002872        	l32i	a7, a8, 0
403789e0:	147a70        	extui	a7, a7, 10, 2
    switch (clk_sel) {
403789e3:	291726        	beqi	a7, 1, 40378a10 <rtc_clk_cpu_freq_get_config+0x3c>
403789e6:	022766        	bnei	a7, 2, 403789ec <rtc_clk_cpu_freq_get_config+0x18>
403789e9:	0035c6        	j	40378ac4 <rtc_clk_cpu_freq_get_config+0xf0>
403789ec:	014756        	bnez	a7, 40378a04 <rtc_clk_cpu_freq_get_config+0x30>
    return REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT) + 1;
403789ef:	0020c0        	memw
403789f2:	002862        	l32i	a6, a8, 0
403789f5:	946060        	extui	a6, a6, 0, 10
403789f8:	661b      	addi.n	a6, a6, 1
        source_freq_mhz = (uint32_t)rtc_clk_xtal_freq_get();
403789fa:	fff325        	call8	4037892c <rtc_clk_xtal_freq_get>
        freq_mhz = source_freq_mhz / div;
403789fd:	c2ba60        	quou	a11, a10, a6
    break;
40378a00:	003586        	j	40378ada <rtc_clk_cpu_freq_get_config+0x106>
40378a03:	00          	.byte	00
40378a04:	ee9f81        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40378a07:	0888      	l32i.n	a8, a8, 0
        ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378a09:	0d5816        	beqz	a8, 40378ae2 <rtc_clk_cpu_freq_get_config+0x10e>
40378a0c:	0027c6        	j	40378aaf <rtc_clk_cpu_freq_get_config+0xdb>
40378a0f:	c68100        	ee.ldf.64.xp	f8, f12, a0, a1
    uint32_t cpu_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL);
40378a12:	0020c0ef 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 0, q7, q0, q2, q0
40378a16:	0888      	l32i.n	a8, a8, 0
40378a18:	148080        	extui	a8, a8, 0, 2
    switch (cpu_freq_sel) {
40378a1b:	091826        	beqi	a8, 1, 40378a28 <rtc_clk_cpu_freq_get_config+0x54>
40378a1e:	0e2826        	beqi	a8, 2, 40378a30 <rtc_clk_cpu_freq_get_config+0x5c>
40378a21:	18dc      	bnez.n	a8, 40378a36 <rtc_clk_cpu_freq_get_config+0x62>
40378a23:	0b5c      	movi.n	a11, 80
40378a25:	0003c6        	j	40378a38 <rtc_clk_cpu_freq_get_config+0x64>
        return CLK_LL_PLL_160M_FREQ_MHZ;
40378a28:	a0a0b2        	movi	a11, 160
40378a2b:	000246        	j	40378a38 <rtc_clk_cpu_freq_get_config+0x64>
40378a2e:	b20000        	mulsh	a0, a0, a0
        return CLK_LL_PLL_240M_FREQ_MHZ;
40378a31:	46f0a0        	ee.ldf.64.xp	f15, f4, a10, a0
40378a34:	00          	.byte	00
40378a35:	00          	.byte	00
        return 0;
40378a36:	0b0c      	movi.n	a11, 0
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
40378a38:	efbc81        	l32r	a8, 40374928 <_iram_text_start+0x524> (600c0010 <SYSTEM+0x10>)
40378a3b:	0020c0        	memw
40378a3e:	0888      	l32i.n	a8, a8, 0
40378a40:	049280        	extui	a9, a8, 2, 1
    switch (pll_freq_sel) {
40378a43:	096827        	bbci	a8, 2, 40378a50 <rtc_clk_cpu_freq_get_config+0x7c>
40378a46:	0c1966        	bnei	a9, 1, 40378a56 <rtc_clk_cpu_freq_get_config+0x82>
        return CLK_LL_PLL_480M_FREQ_MHZ;
40378a49:	e0a1a2        	movi	a10, 0x1e0
40378a4c:	000206        	j	40378a58 <rtc_clk_cpu_freq_get_config+0x84>
40378a4f:	a1a200        	sll	a10, a2
    switch (pll_freq_sel) {
40378a52:	004640        	break	6, 4
40378a55:	0a0c00        	add.s	f0, f12, f0
        if (freq_mhz == CLK_LL_PLL_80M_FREQ_MHZ) {
40378a58:	085c      	movi.n	a8, 80
40378a5a:	0a9b87        	bne	a11, a8, 40378a68 <rtc_clk_cpu_freq_get_config+0x94>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378a5d:	e0a182        	movi	a8, 0x1e0
40378a60:	699a87        	bne	a10, a8, 40378acd <rtc_clk_cpu_freq_get_config+0xf9>
40378a63:	660c      	movi.n	a6, 6
40378a65:	001c46        	j	40378ada <rtc_clk_cpu_freq_get_config+0x106>
        } else if (freq_mhz == CLK_LL_PLL_160M_FREQ_MHZ) {
40378a68:	a0a082        	movi	a8, 160
40378a6b:	0a9b87        	bne	a11, a8, 40378a79 <rtc_clk_cpu_freq_get_config+0xa5>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378a6e:	e0a182        	movi	a8, 0x1e0
40378a71:	5d9a87        	bne	a10, a8, 40378ad2 <rtc_clk_cpu_freq_get_config+0xfe>
40378a74:	360c      	movi.n	a6, 3
40378a76:	001806        	j	40378ada <rtc_clk_cpu_freq_get_config+0x106>
        } else if (freq_mhz == CLK_LL_PLL_240M_FREQ_MHZ  && source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
40378a79:	10af92        	movi	a9, -240
40378a7c:	9b9a      	add.n	a9, a11, a9
40378a7e:	40f990        	nsau	a9, a9
40378a81:	419590        	srli	a9, a9, 5
40378a84:	20ae82        	movi	a8, 0xfffffe20
40378a87:	8a8a      	add.n	a8, a10, a8
40378a89:	40f880        	nsau	a8, a8
40378a8c:	418580        	srli	a8, a8, 5
40378a8f:	458987        	bany	a9, a8, 40378ad8 <rtc_clk_cpu_freq_get_config+0x104>
40378a92:	ee7b81        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40378a95:	0888      	l32i.n	a8, a8, 0
            ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378a97:	047816        	beqz	a8, 40378ae2 <rtc_clk_cpu_freq_get_config+0x10e>
40378a9a:	0716a5        	call8	4037fc04 <esp_log_timestamp>
40378a9d:	efbfc1        	l32r	a12, 4037499c <_iram_text_start+0x598> (3fc93db0 <__func__$0+0x1c4>)
40378aa0:	20baa0        	or	a11, a10, a10
40378aa3:	efc1a1        	l32r	a10, 403749a8 <_iram_text_start+0x5a4> (3fc93df4 <__func__$0+0x208>)
40378aa6:	ee8d81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40378aa9:	0008e0        	callx8	a8
            return;
40378aac:	000c86        	j	40378ae2 <rtc_clk_cpu_freq_get_config+0x10e>
        ESP_HW_LOGE(TAG, "unsupported frequency configuration");
40378aaf:	071565        	call8	4037fc04 <esp_log_timestamp>
40378ab2:	efbac1        	l32r	a12, 4037499c <_iram_text_start+0x598> (3fc93db0 <__func__$0+0x1c4>)
40378ab5:	0abd      	mov.n	a11, a10
40378ab7:	efbca1        	l32r	a10, 403749a8 <_iram_text_start+0x5a4> (3fc93df4 <__func__$0+0x208>)
40378aba:	ee8881        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40378abd:	0008e0        	callx8	a8
40378ac0:	000786        	j	40378ae2 <rtc_clk_cpu_freq_get_config+0x10e>
40378ac3:	4b1c00        	olt.s	b1, f12, f0
    switch (clk_sel) {
40378ac6:	160c      	movi.n	a6, 1
40378ac8:	0bad      	mov.n	a10, a11
40378aca:	000306        	j	40378ada <rtc_clk_cpu_freq_get_config+0x106>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378acd:	460c      	movi.n	a6, 4
40378acf:	0001c6        	j	40378ada <rtc_clk_cpu_freq_get_config+0x106>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378ad2:	260c      	movi.n	a6, 2
40378ad4:	000086        	j	40378ada <rtc_clk_cpu_freq_get_config+0x106>
40378ad7:	260c00        	ee.ldf.64.xp	f0, f2, a0, a12
    *out_config = (rtc_cpu_freq_config_t) {
40378ada:	0279      	s32i.n	a7, a2, 0
40378adc:	12a9      	s32i.n	a10, a2, 4
40378ade:	2269      	s32i.n	a6, a2, 8
40378ae0:	32b9      	s32i.n	a11, a2, 12
}
40378ae2:	f01d      	retw.n

40378ae4 <rtc_clk_apb_freq_update>:
{
    clk_ll_xtal_store_freq_mhz(xtal_freq);
}

void rtc_clk_apb_freq_update(uint32_t apb_freq)
{
40378ae4:	004136        	entry	a1, 32
    s_apb_freq = apb_freq;
40378ae7:	efb181        	l32r	a8, 403749ac <_iram_text_start+0x5a8> (3fc94f8c <s_apb_freq>)
40378aea:	0829      	s32i.n	a2, a8, 0
}
40378aec:	f01d      	retw.n
	...

40378af0 <rtc_clk_cpu_freq_to_pll_mhz>:
{
40378af0:	006136        	entry	a1, 48
    int pd_slave = cpu_freq_mhz / 80;
40378af3:	efaf71        	l32r	a7, 403749b0 <_iram_text_start+0x5ac> (66666667 <_rtc_reserved_end+0x6566667>)
40378af6:	b27270        	mulsh	a7, a2, a7
40378af9:	217570        	srai	a7, a7, 5
40378afc:	318f20        	srai	a8, a2, 31
40378aff:	c07780        	sub	a7, a7, a8
    rtc_clk_cpu_freq_get_config(&cur_config);
40378b02:	01ad      	mov.n	a10, a1
40378b04:	ffece5        	call8	403789d4 <rtc_clk_cpu_freq_get_config>
    if (cpu_freq_mhz > cur_config.freq_mhz) {
40378b07:	3188      	l32i.n	a8, a1, 12
40378b09:	026d      	mov.n	a6, a2
40378b0b:	5db827        	bgeu	a8, a2, 40378b6c <rtc_clk_cpu_freq_to_pll_mhz+0x7c>
        if (cpu_freq_mhz == 240) {
40378b0e:	f0a082        	movi	a8, 240
40378b11:	309287        	bne	a2, a8, 40378b45 <rtc_clk_cpu_freq_to_pll_mhz+0x55>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_240m);
40378b14:	efa881        	l32r	a8, 403749b4 <_iram_text_start+0x5b0> (3fc92464 <g_rtc_dbias_pvt_240m>)
40378b17:	0008f2        	l8ui	a15, a8, 0
40378b1a:	0e0c      	movi.n	a14, 0
40378b1c:	4d0c      	movi.n	a13, 4
40378b1e:	0dcd      	mov.n	a12, a13
40378b20:	1b0c      	movi.n	a11, 1
40378b22:	6da0a2        	movi	a10, 109
40378b25:	ff7fe5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_240m);
40378b28:	efa481        	l32r	a8, 403749b8 <_iram_text_start+0x5b4> (3fc92468 <g_dig_dbias_pvt_240m>)
40378b2b:	0008f2        	l8ui	a15, a8, 0
40378b2e:	0e0c      	movi.n	a14, 0
40378b30:	4d0c      	movi.n	a13, 4
40378b32:	6c0c      	movi.n	a12, 6
40378b34:	01a0b2        	movi	a11, 1
40378b37:	6da0a2        	movi	a10, 109
40378b3a:	ff7ea5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
            esp_rom_delay_us(40);
40378b3d:	8a2c      	movi.n	a10, 40
40378b3f:	ee3581        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40378b42:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378b45:	ef9da1        	l32r	a10, 403749bc <_iram_text_start+0x5b8> (600081fc <RTCCNTL+0x1fc>)
40378b48:	0020c0        	memw
40378b4b:	0a88      	l32i.n	a8, a10, 0
40378b4d:	ef9c91        	l32r	a9, 403749c0 <_iram_text_start+0x5bc> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378b50:	109890        	and	a9, a8, a9
40378b53:	780c      	movi.n	a8, 7
40378b55:	400700        	ssr	a7
40378b58:	b18080        	sra	a8, a8
40378b5b:	118830        	slli	a8, a8, 13
40378b5e:	548d80        	extui	a8, a8, 13, 6
40378b61:	118830        	slli	a8, a8, 13
40378b64:	208980        	or	a8, a9, a8
40378b67:	0020c0        	memw
40378b6a:	0a89      	s32i.n	a8, a10, 0
    switch (cpu_mhz) {
40378b6c:	a0a082        	movi	a8, 160
40378b6f:	211287        	beq	a2, a8, 40378b94 <rtc_clk_cpu_freq_to_pll_mhz+0xa4>
40378b72:	f0a082        	movi	a8, 240
40378b75:	371287        	beq	a2, a8, 40378bb0 <rtc_clk_cpu_freq_to_pll_mhz+0xc0>
40378b78:	085c      	movi.n	a8, 80
40378b7a:	4f9287        	bne	a2, a8, 40378bcd <rtc_clk_cpu_freq_to_pll_mhz+0xdd>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 0);
40378b7d:	ef6a91        	l32r	a9, 40374928 <_iram_text_start+0x524> (600c0010 <SYSTEM+0x10>)
40378b80:	0020c0        	memw
40378b83:	0988      	l32i.n	a8, a9, 0
40378b85:	ca7c      	movi.n	a10, -4
40378b87:	1088a0        	and	a8, a8, a10
40378b8a:	0020c0        	memw
40378b8d:	0989      	s32i.n	a8, a9, 0
        break;
40378b8f:	000f46        	j	40378bd0 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378b92:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 1);
40378b95:	c0ef65        	call8	40339a8c <rom_rx_gain_force+0x333660>
40378b98:	20          	.byte	0x20
40378b99:	098800        	l32e	a0, a8, -32
40378b9c:	ca7c      	movi.n	a10, -4
40378b9e:	1088a0        	and	a8, a8, a10
40378ba1:	1a0c      	movi.n	a10, 1
40378ba3:	2088a0        	or	a8, a8, a10
40378ba6:	0020c0        	memw
40378ba9:	0989      	s32i.n	a8, a9, 0
        break;
40378bab:	000846        	j	40378bd0 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378bae:	910000        	srl	a0, a0
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
40378bb1:	20c0ef5e 	ee.vmulas.s8.accx.ld.ip.qup	q0, a5, 240, q3, q5, q4, q0
40378bb5:	098800        	l32e	a0, a8, -32
40378bb8:	ca7c      	movi.n	a10, -4
40378bba:	1088a0        	and	a8, a8, a10
40378bbd:	2a0c      	movi.n	a10, 2
40378bbf:	2088a0        	or	a8, a8, a10
40378bc2:	0020c0        	memw
40378bc5:	0989      	s32i.n	a8, a9, 0
        break;
40378bc7:	000146        	j	40378bd0 <rtc_clk_cpu_freq_to_pll_mhz+0xe0>
40378bca:	000000        	ill
        abort();
40378bcd:	0709e5        	call8	4037fc6c <abort>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378bd0:	ef7591        	l32r	a9, 403749a4 <_iram_text_start+0x5a0> (600c0060 <SYSTEM+0x60>)
40378bd3:	0020c0        	memw
40378bd6:	0988      	l32i.n	a8, a9, 0
40378bd8:	00aca2        	movi	a10, 0xfffffc00
40378bdb:	1088a0        	and	a8, a8, a10
40378bde:	0020c0        	memw
40378be1:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 1);
40378be3:	0020c0        	memw
40378be6:	0988      	l32i.n	a8, a9, 0
40378be8:	ef77a1        	l32r	a10, 403749c4 <_iram_text_start+0x5c0> (fffff3ff <_rtc_reserved_end+0x9feff3ff>)
40378beb:	1088a0        	and	a8, a8, a10
40378bee:	00a4a2        	movi	a10, 0x400
40378bf1:	2088a0        	or	a8, a8, a10
40378bf4:	0020c0        	memw
40378bf7:	006982        	s32i	a8, a9, 0
    rtc_clk_apb_freq_update(80 * MHZ);
40378bfa:	eeaea1        	l32r	a10, 403746b4 <_iram_text_start+0x2b0> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
40378bfd:	ffee65        	call8	40378ae4 <rtc_clk_apb_freq_update>
    esp_rom_set_cpu_ticks_per_us(cpu_freq_mhz);
40378c00:	02ad      	mov.n	a10, a2
40378c02:	ef7381        	l32r	a8, 403749d0 <_iram_text_start+0x5cc> (40001a4c <esp_rom_set_cpu_ticks_per_us>)
40378c05:	0008e0        	callx8	a8
    if (cpu_freq_mhz < cur_config.freq_mhz) {
40378c08:	3188      	l32i.n	a8, a1, 12
40378c0a:	5eb687        	bgeu	a6, a8, 40378c6c <rtc_clk_cpu_freq_to_pll_mhz+0x17c>
        if (cur_config.freq_mhz == 240) {
40378c0d:	f0a092        	movi	a9, 240
40378c10:	319897        	bne	a8, a9, 40378c45 <rtc_clk_cpu_freq_to_pll_mhz+0x155>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378c13:	ef6d81        	l32r	a8, 403749c8 <_iram_text_start+0x5c4> (3fc9245c <g_rtc_dbias_pvt_non_240m>)
40378c16:	0008f2        	l8ui	a15, a8, 0
40378c19:	0e0c      	movi.n	a14, 0
40378c1b:	4d0c      	movi.n	a13, 4
40378c1d:	0dcd      	mov.n	a12, a13
40378c1f:	01a0b2        	movi	a11, 1
40378c22:	6da0a2        	movi	a10, 109
40378c25:	ff6fe5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
            REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378c28:	ef6981        	l32r	a8, 403749cc <_iram_text_start+0x5c8> (3fc92460 <g_dig_dbias_pvt_non_240m>)
40378c2b:	0008f2        	l8ui	a15, a8, 0
40378c2e:	0e0c      	movi.n	a14, 0
40378c30:	4d0c      	movi.n	a13, 4
40378c32:	6c0c      	movi.n	a12, 6
40378c34:	01a0b2        	movi	a11, 1
40378c37:	6da0a2        	movi	a10, 109
40378c3a:	ff6ea5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
            esp_rom_delay_us(40);
40378c3d:	8a2c      	movi.n	a10, 40
40378c3f:	edf581        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40378c42:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378c45:	ef5da1        	l32r	a10, 403749bc <_iram_text_start+0x5b8> (600081fc <RTCCNTL+0x1fc>)
40378c48:	0020c0        	memw
40378c4b:	0a88      	l32i.n	a8, a10, 0
40378c4d:	ef5c91        	l32r	a9, 403749c0 <_iram_text_start+0x5bc> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378c50:	109890        	and	a9, a8, a9
40378c53:	780c      	movi.n	a8, 7
40378c55:	400700        	ssr	a7
40378c58:	b18080        	sra	a8, a8
40378c5b:	118830        	slli	a8, a8, 13
40378c5e:	548d80        	extui	a8, a8, 13, 6
40378c61:	118830        	slli	a8, a8, 13
40378c64:	208980        	or	a8, a9, a8
40378c67:	0020c0        	memw
40378c6a:	0a89      	s32i.n	a8, a10, 0
}
40378c6c:	f01d      	retw.n
	...

40378c70 <rtc_clk_cpu_freq_to_xtal>:
{
40378c70:	006136        	entry	a1, 48
    rtc_clk_cpu_freq_get_config(&cur_config);
40378c73:	01ad      	mov.n	a10, a1
40378c75:	ffd5e5        	call8	403789d4 <rtc_clk_cpu_freq_get_config>
    esp_rom_set_cpu_ticks_per_us(cpu_freq);
40378c78:	02ad      	mov.n	a10, a2
40378c7a:	ef5581        	l32r	a8, 403749d0 <_iram_text_start+0x5cc> (40001a4c <esp_rom_set_cpu_ticks_per_us>)
40378c7d:	0008e0        	callx8	a8
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378c80:	ef4991        	l32r	a9, 403749a4 <_iram_text_start+0x5a0> (600c0060 <SYSTEM+0x60>)
40378c83:	0020c0        	memw
40378c86:	0988      	l32i.n	a8, a9, 0
40378c88:	00aca2        	movi	a10, 0xfffffc00
40378c8b:	1088a0        	and	a8, a8, a10
40378c8e:	0020c0        	memw
40378c91:	0989      	s32i.n	a8, a9, 0
    HAL_ASSERT(divider > 0);
40378c93:	00e356        	bnez	a3, 40378ca5 <rtc_clk_cpu_freq_to_xtal+0x35>
40378c96:	ef4fd1        	l32r	a13, 403749d4 <_iram_text_start+0x5d0> (3fc93e28 <__func__$0+0x23c>)
40378c99:	ef4fc1        	l32r	a12, 403749d8 <_iram_text_start+0x5d4> (3fc93ba4 <__func__$1>)
40378c9c:	e4a1b2        	movi	a11, 0x1e4
40378c9f:	ef39a1        	l32r	a10, 40374984 <_iram_text_start+0x580> (3fc93d78 <__func__$0+0x18c>)
40378ca2:	070865        	call8	4037fd28 <__assert_func>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378ca5:	ef3f91        	l32r	a9, 403749a4 <_iram_text_start+0x5a0> (600c0060 <SYSTEM+0x60>)
40378ca8:	0020c0        	memw
40378cab:	002982        	l32i	a8, a9, 0
40378cae:	00aca2        	movi	a10, 0xfffffc00
40378cb1:	1088a0        	and	a8, a8, a10
40378cb4:	330b      	addi.n	a3, a3, -1
40378cb6:	943030        	extui	a3, a3, 0, 10
40378cb9:	208830        	or	a8, a8, a3
40378cbc:	0020c0        	memw
40378cbf:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 0);
40378cc1:	0020c0        	memw
40378cc4:	0988      	l32i.n	a8, a9, 0
40378cc6:	ef3fa1        	l32r	a10, 403749c4 <_iram_text_start+0x5c0> (fffff3ff <_rtc_reserved_end+0x9feff3ff>)
40378cc9:	1088a0        	and	a8, a8, a10
40378ccc:	0020c0        	memw
40378ccf:	006982        	s32i	a8, a9, 0
    rtc_clk_apb_freq_update(cpu_freq * MHZ);
40378cd2:	ee76a1        	l32r	a10, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
40378cd5:	82a2a0        	mull	a10, a2, a10
40378cd8:	ffe0a5        	call8	40378ae4 <rtc_clk_apb_freq_update>
    if (cur_config.freq_mhz == 240) {
40378cdb:	3198      	l32i.n	a9, a1, 12
40378cdd:	f0a082        	movi	a8, 240
40378ce0:	309987        	bne	a9, a8, 40378d14 <rtc_clk_cpu_freq_to_xtal+0xa4>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378ce3:	ef3981        	l32r	a8, 403749c8 <_iram_text_start+0x5c4> (3fc9245c <g_rtc_dbias_pvt_non_240m>)
40378ce6:	0008f2        	l8ui	a15, a8, 0
40378ce9:	0e0c      	movi.n	a14, 0
40378ceb:	4d0c      	movi.n	a13, 4
40378ced:	0dcd      	mov.n	a12, a13
40378cef:	01a0b2        	movi	a11, 1
40378cf2:	6da0a2        	movi	a10, 109
40378cf5:	ff62e5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378cf8:	ef3581        	l32r	a8, 403749cc <_iram_text_start+0x5c8> (3fc92460 <g_dig_dbias_pvt_non_240m>)
40378cfb:	0008f2        	l8ui	a15, a8, 0
40378cfe:	0e0c      	movi.n	a14, 0
40378d00:	4d0c      	movi.n	a13, 4
40378d02:	6c0c      	movi.n	a12, 6
40378d04:	1b0c      	movi.n	a11, 1
40378d06:	6da0a2        	movi	a10, 109
40378d09:	ff61a5        	call8	40378324 <regi2c_ctrl_write_reg_mask>
        esp_rom_delay_us(40);
40378d0c:	8a2c      	movi.n	a10, 40
40378d0e:	edc181        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40378d11:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
40378d14:	ef2a91        	l32r	a9, 403749bc <_iram_text_start+0x5b8> (600081fc <RTCCNTL+0x1fc>)
40378d17:	0020c0        	memw
40378d1a:	0988      	l32i.n	a8, a9, 0
40378d1c:	ef29a1        	l32r	a10, 403749c0 <_iram_text_start+0x5bc> (fff81fff <_rtc_reserved_end+0x9fe81fff>)
40378d1f:	1088a0        	and	a8, a8, a10
40378d22:	ef2ea1        	l32r	a10, 403749dc <_iram_text_start+0x5d8> (e000 <UserFrameTotalSize+0xdf00>)
40378d25:	2088a0        	or	a8, a8, a10
40378d28:	0020c0        	memw
40378d2b:	0989      	s32i.n	a8, a9, 0
}
40378d2d:	f01d      	retw.n
	...

40378d30 <rtc_clk_cpu_freq_set_config>:
{
40378d30:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
40378d33:	ef1c81        	l32r	a8, 403749a4 <_iram_text_start+0x5a0> (600c0060 <SYSTEM+0x60>)
40378d36:	0020c0        	memw
40378d39:	002872        	l32i	a7, a8, 0
40378d3c:	147a70        	extui	a7, a7, 10, 2
    switch (clk_sel) {
40378d3f:	081726        	beqi	a7, 1, 40378d4b <rtc_clk_cpu_freq_set_config+0x1b>
40378d42:	052726        	beqi	a7, 2, 40378d4b <rtc_clk_cpu_freq_set_config+0x1b>
40378d45:	002716        	beqz	a7, 40378d4b <rtc_clk_cpu_freq_set_config+0x1b>
        return SOC_CPU_CLK_SRC_INVALID;
40378d48:	03a072        	movi	a7, 3
    if (config->source == SOC_CPU_CLK_SRC_XTAL) {
40378d4b:	002282        	l32i	a8, a2, 0
40378d4e:	68dc      	bnez.n	a8, 40378d68 <rtc_clk_cpu_freq_set_config+0x38>
        rtc_clk_cpu_freq_to_xtal(config->freq_mhz, config->div);
40378d50:	22b8      	l32i.n	a11, a2, 8
40378d52:	32a8      	l32i.n	a10, a2, 12
40378d54:	fff1a5        	call8	40378c70 <rtc_clk_cpu_freq_to_xtal>
        if ((old_cpu_clk_src == SOC_CPU_CLK_SRC_PLL) && !s_bbpll_digi_consumers_ref_count) {
40378d57:	331766        	bnei	a7, 1, 40378d8e <rtc_clk_cpu_freq_set_config+0x5e>
40378d5a:	eef581        	l32r	a8, 40374930 <_iram_text_start+0x52c> (3fc94f88 <s_bbpll_digi_consumers_ref_count>)
40378d5d:	0888      	l32i.n	a8, a8, 0
40378d5f:	b8ec      	bnez.n	a8, 40378d8e <rtc_clk_cpu_freq_set_config+0x5e>
            rtc_clk_bbpll_disable();
40378d61:	ff61e5        	call8	40378380 <rtc_clk_bbpll_disable>
40378d64:	000986        	j	40378d8e <rtc_clk_cpu_freq_set_config+0x5e>
40378d67:	186600        	lsxp	f6, a6, a0
    } else if (config->source == SOC_CPU_CLK_SRC_PLL) {
40378d6a:	2619      	s32i.n	a1, a6, 8
        if (old_cpu_clk_src != SOC_CPU_CLK_SRC_PLL) {
40378d6c:	250b17        	bnone	a11, a1, 40378d95 <rtc_clk_cpu_set_to_default_config+0x5>
            rtc_clk_bbpll_enable();
40378d6f:	63          	.byte	0x63
40378d70:	ff          	.byte	0xff
            rtc_clk_bbpll_configure(rtc_clk_xtal_freq_get(), config->source_freq_mhz);
40378d71:	ffbba5        	call8	4037892c <rtc_clk_xtal_freq_get>
40378d74:	0122b2        	l32i	a11, a2, 4
40378d77:	ff6565        	call8	403783cc <rtc_clk_bbpll_configure>
        rtc_clk_cpu_freq_to_pll_mhz(config->freq_mhz);
40378d7a:	32a8      	l32i.n	a10, a2, 12
40378d7c:	ffd725        	call8	40378af0 <rtc_clk_cpu_freq_to_pll_mhz>
40378d7f:	0002c6        	j	40378d8e <rtc_clk_cpu_freq_set_config+0x5e>
40378d82:	000000        	ill
    } else if (config->source == SOC_CPU_CLK_SRC_RC_FAST) {
40378d85:	052866        	bnei	a8, 2, 40378d8e <rtc_clk_cpu_freq_set_config+0x5e>
        rtc_clk_cpu_freq_to_8m();
40378d88:	201110        	or	a1, a1, a1
40378d8b:	ff62e5        	call8	403783b8 <rtc_clk_cpu_freq_to_8m>
}
40378d8e:	f01d      	retw.n

40378d90 <rtc_clk_cpu_set_to_default_config>:
{
40378d90:	004136        	entry	a1, 32
    int freq_mhz = (int)rtc_clk_xtal_freq_get();
40378d93:	ffb9a5        	call8	4037892c <rtc_clk_xtal_freq_get>
    rtc_clk_cpu_freq_to_xtal(freq_mhz, 1);
40378d96:	01a0b2        	movi	a11, 1
40378d99:	ffed65        	call8	40378c70 <rtc_clk_cpu_freq_to_xtal>
}
40378d9c:	000090        	retw
	...

40378da0 <rtc_clk_cpu_freq_set_xtal>:
{
40378da0:	004136        	entry	a1, 32
    rtc_clk_cpu_set_to_default_config();
40378da3:	fffee5        	call8	40378d90 <rtc_clk_cpu_set_to_default_config>
    rtc_clk_bbpll_disable();
40378da6:	ff5da5        	call8	40378380 <rtc_clk_bbpll_disable>
}
40378da9:	f01d      	retw.n
	...

40378dac <rtc_sleep_pu>:
/**
 * Configure whether certain peripherals are powered up in sleep
 * @param cfg power down flags as rtc_sleep_pu_config_t structure
 */
void rtc_sleep_pu(rtc_sleep_pu_config_t cfg)
{
40378dac:	004136        	entry	a1, 32
    REG_SET_FIELD(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_LSLP_MEM_FORCE_PU, cfg.dig_fpu);
40378daf:	ef0cb1        	l32r	a11, 403749e0 <_iram_text_start+0x5dc> (60008090 <RTCCNTL+0x90>)
40378db2:	0020c0        	memw
40378db5:	0b88      	l32i.n	a8, a11, 0
40378db7:	fa6c      	movi.n	a10, -17
40378db9:	1088a0        	and	a8, a8, a10
40378dbc:	049020        	extui	a9, a2, 0, 1
40378dbf:	1199c0        	slli	a9, a9, 4
40378dc2:	208890        	or	a8, a8, a9
40378dc5:	0020c0        	memw
40378dc8:	0b89      	s32i.n	a8, a11, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_LPU, cfg.rtc_fpu);
40378dca:	ef0691        	l32r	a9, 403749e4 <_iram_text_start+0x5e0> (60008088 <RTCCNTL+0x88>)
40378dcd:	0020c0        	memw
40378dd0:	0988      	l32i.n	a8, a9, 0
40378dd2:	ffaeb2        	movi	a11, 0xfffffeff
40378dd5:	1088b0        	and	a8, a8, a11
40378dd8:	04b120        	extui	a11, a2, 1, 1
40378ddb:	11bb80        	slli	a11, a11, 8
40378dde:	2088b0        	or	a8, a8, a11
40378de1:	0020c0        	memw
40378de4:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_LPU, cfg.rtc_fpu);
40378de6:	0020c0        	memw
40378de9:	0988      	l32i.n	a8, a9, 0
40378deb:	eeffb1        	l32r	a11, 403749e8 <_iram_text_start+0x5e4> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
40378dee:	1088b0        	and	a8, a8, a11
40378df1:	04b120        	extui	a11, a2, 1, 1
40378df4:	11bb50        	slli	a11, a11, 11
40378df7:	2088b0        	or	a8, a8, a11
40378dfa:	0020c0        	memw
40378dfd:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_DC_MEM_FORCE_PU, cfg.fe_fpu);
40378dff:	eefb81        	l32r	a8, 403749ec <_iram_text_start+0x5e8> (6002609c <SYSCON+0x9c>)
40378e02:	0020c0        	memw
40378e05:	0898      	l32i.n	a9, a8, 0
40378e07:	1099a0        	and	a9, a9, a10
40378e0a:	04a620        	extui	a10, a2, 6, 1
40378e0d:	11aac0        	slli	a10, a10, 4
40378e10:	2099a0        	or	a9, a9, a10
40378e13:	0020c0        	memw
40378e16:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_PBUS_MEM_FORCE_PU, cfg.fe_fpu);
40378e18:	0020c0        	memw
40378e1b:	0898      	l32i.n	a9, a8, 0
40378e1d:	ba7c      	movi.n	a10, -5
40378e1f:	1099a0        	and	a9, a9, a10
40378e22:	04a620        	extui	a10, a2, 6, 1
40378e25:	11aae0        	slli	a10, a10, 2
40378e28:	2099a0        	or	a9, a9, a10
40378e2b:	0020c0        	memw
40378e2e:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_AGC_MEM_FORCE_PU, cfg.fe_fpu);
40378e30:	0020c0        	memw
40378e33:	0898      	l32i.n	a9, a8, 0
40378e35:	ea7c      	movi.n	a10, -2
40378e37:	1099a0        	and	a9, a9, a10
40378e3a:	04a620        	extui	a10, a2, 6, 1
40378e3d:	2099a0        	or	a9, a9, a10
40378e40:	0020c0        	memw
40378e43:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(BBPD_CTRL, BB_FFT_FORCE_PU, cfg.bb_fpu);
40378e45:	eeea91        	l32r	a9, 403749f0 <_iram_text_start+0x5ec> (6001d054 <SENS+0x14854>)
40378e48:	0020c0        	memw
40378e4b:	0988      	l32i.n	a8, a9, 0
40378e4d:	7c7c      	movi.n	a12, -9
40378e4f:	1088c0        	and	a8, a8, a12
40378e52:	04a420        	extui	a10, a2, 4, 1
40378e55:	11aad0        	slli	a10, a10, 3
40378e58:	2088a0        	or	a8, a8, a10
40378e5b:	0020c0        	memw
40378e5e:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(BBPD_CTRL, BB_DC_EST_FORCE_PU, cfg.bb_fpu);
40378e60:	0020c0        	memw
40378e63:	0988      	l32i.n	a8, a9, 0
40378e65:	db7c      	movi.n	a11, -3
40378e67:	1088b0        	and	a8, a8, a11
40378e6a:	04a420        	extui	a10, a2, 4, 1
40378e6d:	aaaa      	add.n	a10, a10, a10
40378e6f:	2088a0        	or	a8, a8, a10
40378e72:	0020c0        	memw
40378e75:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_RX_ROT_FORCE_PU, cfg.nrx_fpu);
40378e77:	eedf81        	l32r	a8, 403749f4 <_iram_text_start+0x5f0> (6001ccd4 <SENS+0x144d4>)
40378e7a:	0020c0        	memw
40378e7d:	0898      	l32i.n	a9, a8, 0
40378e7f:	dfafa2        	movi	a10, -33
40378e82:	1099a0        	and	a9, a9, a10
40378e85:	04d520        	extui	a13, a2, 5, 1
40378e88:	11ddb0        	slli	a13, a13, 5
40378e8b:	2099d0        	or	a9, a9, a13
40378e8e:	0020c0        	memw
40378e91:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_VIT_FORCE_PU, cfg.nrx_fpu);
40378e93:	0020c0        	memw
40378e96:	0898      	l32i.n	a9, a8, 0
40378e98:	1099c0        	and	a9, a9, a12
40378e9b:	04c520        	extui	a12, a2, 5, 1
40378e9e:	11ccd0        	slli	a12, a12, 3
40378ea1:	2099c0        	or	a9, a9, a12
40378ea4:	0020c0        	memw
40378ea7:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_DEMAP_FORCE_PU, cfg.nrx_fpu);
40378ea9:	0020c0        	memw
40378eac:	0898      	l32i.n	a9, a8, 0
40378eae:	1099b0        	and	a9, a9, a11
40378eb1:	04b520        	extui	a11, a2, 5, 1
40378eb4:	bbba      	add.n	a11, a11, a11
40378eb6:	2099b0        	or	a9, a9, a11
40378eb9:	0020c0        	memw
40378ebc:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(FE_GEN_CTRL, FE_IQ_EST_FORCE_PU, cfg.fe_fpu);
40378ebe:	eeceb1        	l32r	a11, 403749f8 <_iram_text_start+0x5f4> (60006090 <GPIO+0x2090>)
40378ec1:	0020c0        	memw
40378ec4:	0b88      	l32i.n	a8, a11, 0
40378ec6:	1088a0        	and	a8, a8, a10
40378ec9:	049620        	extui	a9, a2, 6, 1
40378ecc:	1199b0        	slli	a9, a9, 5
40378ecf:	208890        	or	a8, a8, a9
40378ed2:	0020c0        	memw
40378ed5:	0b89      	s32i.n	a8, a11, 0
    REG_SET_FIELD(FE2_TX_INTERP_CTRL, FE2_TX_INF_FORCE_PU, cfg.fe_fpu);
40378ed7:	eec9a1        	l32r	a10, 403749fc <_iram_text_start+0x5f8> (600050f0 <GPIO+0x10f0>)
40378eda:	0020c0        	memw
40378edd:	0a88      	l32i.n	a8, a10, 0
40378edf:	ffab92        	movi	a9, 0xfffffbff
40378ee2:	108890        	and	a8, a8, a9
40378ee5:	049620        	extui	a9, a2, 6, 1
40378ee8:	119960        	slli	a9, a9, 10
40378eeb:	208890        	or	a8, a8, a9
40378eee:	0020c0        	memw
40378ef1:	0a89      	s32i.n	a8, a10, 0
    if (cfg.sram_fpu) {
40378ef3:	80a082        	movi	a8, 128
40378ef6:	108280        	and	a8, a2, a8
40378ef9:	f48080        	extui	a8, a8, 0, 16
40378efc:	489c      	beqz.n	a8, 40378f14 <rtc_sleep_pu+0x168>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, SYSCON_SRAM_POWER_UP);
40378efe:	eec091        	l32r	a9, 40374a00 <_iram_text_start+0x5fc> (600260b0 <SYSCON+0xb0>)
40378f01:	0020c0        	memw
40378f04:	0988      	l32i.n	a8, a9, 0
40378f06:	eebfa1        	l32r	a10, 40374a04 <_iram_text_start+0x600> (3ff8 <UserFrameTotalSize+0x3ef8>)
40378f09:	2088a0        	or	a8, a8, a10
40378f0c:	0020c0        	memw
40378f0f:	0989      	s32i.n	a8, a9, 0
40378f11:	000486        	j	40378f27 <rtc_sleep_pu+0x17b>
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, 0);
40378f14:	eebb91        	l32r	a9, 40374a00 <_iram_text_start+0x5fc> (600260b0 <SYSCON+0xb0>)
40378f17:	0020c0        	memw
40378f1a:	0988      	l32i.n	a8, a9, 0
40378f1c:	eebba1        	l32r	a10, 40374a08 <_iram_text_start+0x604> (ffffc007 <_rtc_reserved_end+0x9fefc007>)
40378f1f:	1088a0        	and	a8, a8, a10
40378f22:	0020c0        	memw
40378f25:	0989      	s32i.n	a8, a9, 0
    }
    if (cfg.rom_ram_fpu) {
40378f27:	00a182        	movi	a8, 0x100
40378f2a:	102280        	and	a2, a2, a8
40378f2d:	f42020        	extui	a2, a2, 0, 16
40378f30:	429c      	beqz.n	a2, 40378f48 <rtc_sleep_pu+0x19c>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, SYSCON_ROM_POWER_UP);
40378f32:	eeb391        	l32r	a9, 40374a00 <_iram_text_start+0x5fc> (600260b0 <SYSCON+0xb0>)
40378f35:	0020c0        	memw
40378f38:	0988      	l32i.n	a8, a9, 0
40378f3a:	7a0c      	movi.n	a10, 7
40378f3c:	2088a0        	or	a8, a8, a10
40378f3f:	0020c0        	memw
40378f42:	0989      	s32i.n	a8, a9, 0
40378f44:	000486        	j	40378f5a <rtc_sleep_pu+0x1ae>
40378f47:	00          	.byte	00
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, 0);
40378f48:	eeae91        	l32r	a9, 40374a00 <_iram_text_start+0x5fc> (600260b0 <SYSCON+0xb0>)
40378f4b:	0020c0        	memw
40378f4e:	0988      	l32i.n	a8, a9, 0
40378f50:	8a7c      	movi.n	a10, -8
40378f52:	1088a0        	and	a8, a8, a10
40378f55:	0020c0        	memw
40378f58:	0989      	s32i.n	a8, a9, 0
    }
}
40378f5a:	f01d      	retw.n

40378f5c <rtc_clk_cal_internal>:
 * @param cal_clk which clock to calibrate
 * @param slowclk_cycles number of slow clock cycles to count
 * @return number of XTAL clock cycles within the given number of slow clock cycles
 */
uint32_t rtc_clk_cal_internal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
40378f5c:	004136        	entry	a1, 32
40378f5f:	027d      	mov.n	a7, a2
    /* On ESP32S3, choosing RTC_CAL_RTC_MUX results in calibration of
     * the 150k RTC clock regardless of the currently selected SLOW_CLK.
     * On the ESP32, it used the currently selected SLOW_CLK.
     * The following code emulates ESP32 behavior:
     */
    if (cal_clk == RTC_CAL_RTC_MUX) {
40378f61:	b2cc      	bnez.n	a2, 40378f70 <rtc_clk_cal_internal+0x14>
        soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
40378f63:	ff92e5        	call8	40378890 <rtc_clk_slow_src_get>
        if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
40378f66:	0c1a26        	beqi	a10, 1, 40378f76 <rtc_clk_cal_internal+0x1a>
            cal_clk = RTC_CAL_32K_XTAL;
        } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
40378f69:	172a66        	bnei	a10, 2, 40378f84 <rtc_clk_cal_internal+0x28>
40378f6c:	000346        	j	40378f7d <rtc_clk_cal_internal+0x21>
40378f6f:	326600        	orbc	b6, b6, b0
            cal_clk = RTC_CAL_8MD256;
        }
    } else if (cal_clk == RTC_CAL_INTERNAL_OSC) {
40378f72:	02c610        	andb	b12, b6, b1
40378f75:	270c00        	ee.stf.64.xp	f0, f2, a0, a12
            cal_clk = RTC_CAL_32K_XTAL;
40378f78:	000206        	j	40378f84 <rtc_clk_cal_internal+0x28>
40378f7b:	00          	.byte	00
40378f7c:	170c00        	ee.stf.64.xp	f0, f1, a0, a12
            cal_clk = RTC_CAL_8MD256;
40378f7f:	000046        	j	40378f84 <rtc_clk_cal_internal+0x28>
        cal_clk = RTC_CAL_RTC_MUX;
40378f82:	070c      	movi.n	a7, 0
    return REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN);
40378f84:	ee7b81        	l32r	a8, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378f87:	0020c0        	memw
40378f8a:	08a8      	l32i.n	a10, a8, 0
    }

    /* Enable requested clock (150k clock is always on) */
    bool dig_32k_xtal_enabled = clk_ll_xtal32k_digi_is_enabled();
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
40378f8c:	fec782        	addi	a8, a7, -2
40378f8f:	40f880        	nsau	a8, a8
40378f92:	418580        	srli	a8, a8, 5
40378f95:	04a8a0        	extui	a10, a10, 8, 1
40378f98:	190c      	movi.n	a9, 1
40378f9a:	3099a0        	xor	a9, a9, a10
40378f9d:	104980        	and	a4, a9, a8
40378fa0:	130987        	bnone	a9, a8, 40378fb7 <rtc_clk_cal_internal+0x5b>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378fa3:	ee7391        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378fa6:	0020c0        	memw
40378fa9:	0988      	l32i.n	a8, a9, 0
40378fab:	00a1a2        	movi	a10, 0x100
40378fae:	2088a0        	or	a8, a8, a10
40378fb1:	0020c0        	memw
40378fb4:	006982        	s32i	a8, a9, 0
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M) == 0;
40378fb7:	ee6e81        	l32r	a8, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378fba:	0020c0        	memw
40378fbd:	0868      	l32i.n	a6, a8, 0
40378fbf:	094c      	movi.n	a9, 64
40378fc1:	106690        	and	a6, a6, a9
40378fc4:	40f660        	nsau	a6, a6
40378fc7:	416560        	srli	a6, a6, 5
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
40378fca:	0020c0        	memw
40378fcd:	0858      	l32i.n	a5, a8, 0
40378fcf:	80a082        	movi	a8, 128
40378fd2:	105580        	and	a5, a5, a8
40378fd5:	40f550        	nsau	a5, a5
40378fd8:	415550        	srli	a5, a5, 5
        clk_ll_xtal32k_digi_enable();
    }

    bool rc_fast_enabled = clk_ll_rc_fast_is_enabled();
    bool rc_fast_d256_enabled = clk_ll_rc_fast_d256_is_enabled();
    if (cal_clk == RTC_CAL_8MD256) {
40378fdb:	191766        	bnei	a7, 1, 40378ff8 <rtc_clk_cal_internal+0x9c>
        rtc_clk_8m_enable(true, true);
40378fde:	1b0c      	movi.n	a11, 1
40378fe0:	0bad      	mov.n	a10, a11
40378fe2:	ff6f65        	call8	403786d8 <rtc_clk_8m_enable>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40378fe5:	ee6291        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40378fe8:	0020c0        	memw
40378feb:	0988      	l32i.n	a8, a9, 0
40378fed:	00a2a2        	movi	a10, 0x200
40378ff0:	2088a0        	or	a8, a8, a10
40378ff3:	0020c0        	memw
40378ff6:	0989      	s32i.n	a8, a9, 0
        clk_ll_rc_fast_d256_digi_enable();
    }
    /* There may be another calibration process already running during we call this function,
     * so we should wait the last process is done.
     */
    if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING)) {
40378ff8:	ee8581        	l32r	a8, 40374a0c <_iram_text_start+0x608> (6001f068 <TIMERG0+0x68>)
40378ffb:	0020c0        	memw
40378ffe:	0888      	l32i.n	a8, a8, 0
40379000:	2c68c7        	bbci	a8, 12, 40379030 <rtc_clk_cal_internal+0xd4>
        /**
         * Set a small timeout threshold to accelerate the generation of timeout.
         * The internal circuit will be reset when the timeout occurs and will not affect the next calibration.
         */
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, 1);
40379003:	ee8391        	l32r	a9, 40374a10 <_iram_text_start+0x60c> (6001f080 <TIMERG0+0x80>)
40379006:	0020c0        	memw
40379009:	0988      	l32i.n	a8, a9, 0
4037900b:	748080        	extui	a8, a8, 0, 8
4037900e:	80a0a2        	movi	a10, 128
40379011:	2088a0        	or	a8, a8, a10
40379014:	0020c0        	memw
40379017:	0989      	s32i.n	a8, a9, 0
        while (!GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)
40379019:	ee7c81        	l32r	a8, 40374a0c <_iram_text_start+0x608> (6001f068 <TIMERG0+0x68>)
4037901c:	0020c0        	memw
4037901f:	0888      	l32i.n	a8, a8, 0
                && !GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT));
40379021:	0be8f7        	bbsi	a8, 15, 40379030 <rtc_clk_cal_internal+0xd4>
40379024:	ee7b81        	l32r	a8, 40374a10 <_iram_text_start+0x60c> (6001f080 <TIMERG0+0x80>)
40379027:	0020c0        	memw
4037902a:	002882        	l32i	a8, a8, 0
4037902d:	e86807        	bbci	a8, 0, 40379019 <rtc_clk_cal_internal+0xbd>
    }

    /* Prepare calibration */
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_CLK_SEL, cal_clk);
40379030:	ee7781        	l32r	a8, 40374a0c <_iram_text_start+0x608> (6001f068 <TIMERG0+0x68>)
40379033:	0020c0        	memw
40379036:	0898      	l32i.n	a9, a8, 0
40379038:	ee77a1        	l32r	a10, 40374a14 <_iram_text_start+0x610> (ffff9fff <_rtc_reserved_end+0x9fef9fff>)
4037903b:	1099a0        	and	a9, a9, a10
4037903e:	11a730        	slli	a10, a7, 13
40379041:	14ada0        	extui	a10, a10, 13, 2
40379044:	11aa30        	slli	a10, a10, 13
40379047:	2099a0        	or	a9, a9, a10
4037904a:	0020c0        	memw
4037904d:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING);
4037904f:	0020c0        	memw
40379052:	0898      	l32i.n	a9, a8, 0
40379054:	ee71a1        	l32r	a10, 40374a18 <_iram_text_start+0x614> (ffffefff <_rtc_reserved_end+0x9fefefff>)
40379057:	1099a0        	and	a9, a9, a10
4037905a:	0020c0        	memw
4037905d:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_MAX, slowclk_cycles);
4037905f:	0020c0        	memw
40379062:	0898      	l32i.n	a9, a8, 0
40379064:	ee6ea1        	l32r	a10, 40374a1c <_iram_text_start+0x618> (8000ffff <_rtc_reserved_end+0x1ff0ffff>)
40379067:	1099a0        	and	a9, a9, a10
4037906a:	11a300        	slli	a10, a3, 16
4037906d:	e5a0a0        	extui	a10, a10, 16, 15
40379070:	11aa00        	slli	a10, a10, 16
40379073:	2099a0        	or	a9, a9, a10
40379076:	0020c0        	memw
40379079:	0899      	s32i.n	a9, a8, 0
    /* Figure out how long to wait for calibration to finish */

    /* Set timeout reg and expect time delay*/
    uint32_t expected_freq;
    if (cal_clk == RTC_CAL_32K_XTAL) {
4037907b:	1d2766        	bnei	a7, 2, 4037909c <rtc_clk_cal_internal+0x140>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_X32K_CAL_TIMEOUT_THRES(slowclk_cycles));
4037907e:	ee6491        	l32r	a9, 40374a10 <_iram_text_start+0x60c> (6001f080 <TIMERG0+0x80>)
40379081:	0020c0        	memw
40379084:	0988      	l32i.n	a8, a9, 0
40379086:	648080        	extui	a8, a8, 0, 7
40379089:	01a3d0        	slli	a10, a3, 19
4037908c:	2088a0        	or	a8, a8, a10
4037908f:	0020c0        	memw
40379092:	0989      	s32i.n	a8, a9, 0
        expected_freq = SOC_CLK_XTAL32K_FREQ_APPROX;
40379094:	ecf5c1        	l32r	a12, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
40379097:	000ec6        	j	403790d6 <rtc_clk_cal_internal+0x17a>
4037909a:	660000        	ee.ldf.64.xp	f0, f6, a0, a0
    } else if (cal_clk == RTC_CAL_8MD256) {
4037909d:	911c17        	beq	a12, a1, 40379032 <rtc_clk_cal_internal+0xd6>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_8MD256_CAL_TIMEOUT_THRES(slowclk_cycles));
403790a0:	ee5c      	movi.n	a14, 94
403790a2:	0020c0        	memw
403790a5:	0988      	l32i.n	a8, a9, 0
403790a7:	648080        	extui	a8, a8, 0, 7
403790aa:	01a3d0        	slli	a10, a3, 19
403790ad:	2088a0        	or	a8, a8, a10
403790b0:	0020c0        	memw
403790b3:	0989      	s32i.n	a8, a9, 0
        expected_freq = SOC_CLK_RC_FAST_D256_FREQ_APPROX;
403790b5:	ee36c1        	l32r	a12, 40374990 <_iram_text_start+0x58c> (10b07 <UserFrameTotalSize+0x10a07>)
403790b8:	000686        	j	403790d6 <rtc_clk_cal_internal+0x17a>
403790bb:	559100        	extui	a9, a0, 17, 6
    } else {
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_150K_CAL_TIMEOUT_THRES(slowclk_cycles));
403790be:	0020c0ee 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 0, q3, q0, q2, q0
403790c2:	0988      	l32i.n	a8, a9, 0
403790c4:	648080        	extui	a8, a8, 0, 7
403790c7:	01a3f0        	slli	a10, a3, 17
403790ca:	2088a0        	or	a8, a8, a10
403790cd:	0020c0        	memw
403790d0:	006982        	s32i	a8, a9, 0
        expected_freq = SOC_CLK_RC_SLOW_FREQ_APPROX;
403790d3:	ee2ec1        	l32r	a12, 4037498c <_iram_text_start+0x588> (21340 <UserFrameTotalSize+0x21240>)
    }
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
403790d6:	ed75a1        	l32r	a10, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
403790d9:	a2b3a0        	muluh	a11, a3, a10
403790dc:	00a0d2        	movi	a13, 0
403790df:	82a3a0        	mull	a10, a3, a10
403790e2:	ed0481        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
403790e5:	0008e0        	callx8	a8
    /* Start calibration */
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
403790e8:	ee4991        	l32r	a9, 40374a0c <_iram_text_start+0x608> (6001f068 <TIMERG0+0x68>)
403790eb:	0020c0        	memw
403790ee:	0988      	l32i.n	a8, a9, 0
403790f0:	888a      	add.n	a8, a8, a8
403790f2:	418180        	srli	a8, a8, 1
403790f5:	0020c0        	memw
403790f8:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
403790fa:	0020c0        	memw
403790fd:	0988      	l32i.n	a8, a9, 0
403790ff:	edacb1        	l32r	a11, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
40379102:	2088b0        	or	a8, a8, a11
40379105:	0020c0        	memw
40379108:	0989      	s32i.n	a8, a9, 0

    /* Wait for calibration to finish up to another us_time_estimate */
    esp_rom_delay_us(us_time_estimate);
4037910a:	ecc281        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
4037910d:	0008e0        	callx8	a8
    uint32_t cal_val;
    while (true) {
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)) {
40379110:	ee3f81        	l32r	a8, 40374a0c <_iram_text_start+0x608> (6001f068 <TIMERG0+0x68>)
40379113:	0020c0        	memw
40379116:	0888      	l32i.n	a8, a8, 0
40379118:	042f80        	extui	a2, a8, 15, 1
4037911b:	112210        	slli	a2, a2, 15
4037911e:	0e68f7        	bbci	a8, 15, 40379130 <rtc_clk_cal_internal+0x1d4>
            cal_val = REG_GET_FIELD(TIMG_RTCCALICFG1_REG(0), TIMG_RTC_CALI_VALUE);
40379121:	ee3f81        	l32r	a8, 40374a20 <_iram_text_start+0x61c> (6001f06c <TIMERG0+0x6c>)
40379124:	0020c0        	memw
40379127:	0828      	l32i.n	a2, a8, 0
40379129:	412720        	srli	a2, a2, 7
            break;
4037912c:	0002c6        	j	4037913b <rtc_clk_cal_internal+0x1df>
4037912f:	00          	.byte	00
        }
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT)) {
40379130:	ee3881        	l32r	a8, 40374a10 <_iram_text_start+0x60c> (6001f080 <TIMERG0+0x80>)
40379133:	0020c0        	memw
40379136:	0888      	l32i.n	a8, a8, 0
40379138:	d46807        	bbci	a8, 0, 40379110 <rtc_clk_cal_internal+0x1b4>
            cal_val = 0;
            break;
        }
    }
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
4037913b:	ee3491        	l32r	a9, 40374a0c <_iram_text_start+0x608> (6001f068 <TIMERG0+0x68>)
4037913e:	0020c0        	memw
40379141:	0988      	l32i.n	a8, a9, 0
40379143:	888a      	add.n	a8, a8, a8
40379145:	418180        	srli	a8, a8, 1
40379148:	0020c0        	memw
4037914b:	0989      	s32i.n	a8, a9, 0

    /* if dig_32k_xtal was originally off and enabled due to calibration, then set back to off state */
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
4037914d:	249c      	beqz.n	a4, 40379163 <rtc_clk_cal_internal+0x207>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
4037914f:	ee0891        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40379152:	0020c0        	memw
40379155:	0988      	l32i.n	a8, a9, 0
40379157:	ffaea2        	movi	a10, 0xfffffeff
4037915a:	1088a0        	and	a8, a8, a10
4037915d:	0020c0        	memw
40379160:	006982        	s32i	a8, a9, 0
        clk_ll_xtal32k_digi_disable();
    }

    if (cal_clk == RTC_CAL_8MD256) {
40379163:	191766        	bnei	a7, 1, 40379180 <rtc_clk_cal_internal+0x224>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40379166:	ee0291        	l32r	a9, 40374970 <_iram_text_start+0x56c> (60008074 <RTCCNTL+0x74>)
40379169:	0020c0        	memw
4037916c:	0988      	l32i.n	a8, a9, 0
4037916e:	ffada2        	movi	a10, 0xfffffdff
40379171:	1088a0        	and	a8, a8, a10
40379174:	0020c0        	memw
40379177:	0989      	s32i.n	a8, a9, 0
        clk_ll_rc_fast_d256_digi_disable();
        rtc_clk_8m_enable(rc_fast_enabled, rc_fast_d256_enabled);
40379179:	05bd      	mov.n	a11, a5
4037917b:	06ad      	mov.n	a10, a6
4037917d:	ff55a5        	call8	403786d8 <rtc_clk_8m_enable>
    }

    return cal_val;
}
40379180:	f01d      	retw.n
	...

40379184 <rtc_clk_cal>:
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
}

uint32_t rtc_clk_cal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
40379184:	004136        	entry	a1, 32
    assert(slowclk_cycles);
40379187:	011356        	bnez	a3, 4037919c <rtc_clk_cal+0x18>
4037918a:	ee26d1        	l32r	a13, 40374a24 <_iram_text_start+0x620> (3c0224d0 <_flash_rodata_start+0x23b0>)
4037918d:	ee26c1        	l32r	a12, 40374a28 <_iram_text_start+0x624> (3c026ccc <__func__$1>)
40379190:	93a0b2        	movi	a11, 147
40379193:	ee26a1        	l32r	a10, 40374a2c <_iram_text_start+0x628> (3c02250d <_flash_rodata_start+0x23ed>)
40379196:	201110        	or	a1, a1, a1
40379199:	06b8e5        	call8	4037fd28 <__assert_func>
    soc_xtal_freq_t xtal_freq = rtc_clk_xtal_freq_get();
4037919c:	ff78e5        	call8	4037892c <rtc_clk_xtal_freq_get>
4037919f:	0a6d      	mov.n	a6, a10
    uint64_t xtal_cycles = rtc_clk_cal_internal(cal_clk, slowclk_cycles);
403791a1:	03bd      	mov.n	a11, a3
403791a3:	02ad      	mov.n	a10, a2
403791a5:	ffdb65        	call8	40378f5c <rtc_clk_cal_internal>
403791a8:	0a7d      	mov.n	a7, a10
403791aa:	050c      	movi.n	a5, 0

    if ((cal_clk == RTC_CAL_32K_XTAL) && !rtc_clk_cal_32k_valid((uint32_t)xtal_freq, slowclk_cycles, xtal_cycles)) {
403791ac:	562266        	bnei	a2, 2, 40379206 <rtc_clk_cal+0x82>
    uint64_t expected_xtal_cycles = (xtal_freq * 1000000ULL * slowclk_cycles) >> 15; // xtal_freq(hz) * slowclk_cycles / 32768
403791af:	828630        	mull	a8, a6, a3
403791b2:	a22630        	muluh	a2, a6, a3
403791b5:	ed3d91        	l32r	a9, 403746ac <_iram_text_start+0x2a8> (f4240 <UserFrameTotalSize+0xf4140>)
403791b8:	822290        	mull	a2, a2, a9
403791bb:	824890        	mull	a4, a8, a9
403791be:	a28890        	muluh	a8, a8, a9
403791c1:	228a      	add.n	a2, a2, a8
403791c3:	0182f0        	slli	a8, a2, 17
403791c6:	414f40        	srli	a4, a4, 15
403791c9:	204840        	or	a4, a8, a4
403791cc:	412f20        	srli	a2, a2, 15
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
403791cf:	d0a7c2        	movi	a12, 0x7d0
403791d2:	05dd      	mov.n	a13, a5
403791d4:	04ad      	mov.n	a10, a4
403791d6:	02bd      	mov.n	a11, a2
403791d8:	ecc781        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
403791db:	0008e0        	callx8	a8
403791de:	0a9d      	mov.n	a9, a10
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
403791e0:	c082b0        	sub	a8, a2, a11
403791e3:	01b4a7        	bgeu	a4, a10, 403791e8 <rtc_clk_cal+0x64>
403791e6:	880b      	addi.n	a8, a8, -1
403791e8:	c0c4a0        	sub	a12, a4, a10
403791eb:	513587        	bltu	a5, a8, 40379240 <rtc_clk_cal+0xbc>
403791ee:	029857        	bne	a8, a5, 403791f4 <rtc_clk_cal+0x70>
403791f1:	4b37c7        	bltu	a7, a12, 40379240 <rtc_clk_cal+0xbc>
403791f4:	22ba      	add.n	a2, a2, a11
403791f6:	44aa      	add.n	a4, a4, a10
403791f8:	01b497        	bgeu	a4, a9, 403791fd <rtc_clk_cal+0x79>
403791fb:	221b      	addi.n	a2, a2, 1
403791fd:	443257        	bltu	a2, a5, 40379245 <rtc_clk_cal+0xc1>
40379200:	029527        	bne	a5, a2, 40379206 <rtc_clk_cal+0x82>
40379203:	3e3477        	bltu	a4, a7, 40379245 <rtc_clk_cal+0xc1>
        return 0;
    }

    uint64_t divider = ((uint64_t)xtal_freq) * slowclk_cycles;
40379206:	82c630        	mull	a12, a6, a3
40379209:	a2d630        	muluh	a13, a6, a3
    uint64_t period_64 = ((xtal_cycles << RTC_CLK_CAL_FRACT) + divider / 2 - 1) / divider;
4037920c:	418d70        	srli	a8, a7, 13
4037920f:	01a7d0        	slli	a10, a7, 19
40379212:	01bd10        	slli	a11, a13, 31
40379215:	4191c0        	srli	a9, a12, 1
40379218:	209b90        	or	a9, a11, a9
4037921b:	41b1d0        	srli	a11, a13, 1
4037921e:	88ba      	add.n	a8, a8, a11
40379220:	80aa90        	add	a10, a10, a9
40379223:	02ba97        	bgeu	a10, a9, 40379229 <rtc_clk_cal+0xa5>
40379226:	01c882        	addi	a8, a8, 1
40379229:	f97c      	movi.n	a9, -1
4037922b:	b89a      	add.n	a11, a8, a9
4037922d:	aa9a      	add.n	a10, a10, a9
4037922f:	01ba97        	bgeu	a10, a9, 40379234 <rtc_clk_cal+0xb0>
40379232:	08bd      	mov.n	a11, a8
40379234:	ecb081        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
40379237:	0008e0        	callx8	a8
    uint32_t period = (uint32_t)(period_64 & UINT32_MAX);
4037923a:	0a2d      	mov.n	a2, a10
    return period;
4037923c:	0001c6        	j	40379247 <rtc_clk_cal+0xc3>
4037923f:	020c00        	andb	b0, b12, b0
        return 0;
40379242:	000046        	j	40379247 <rtc_clk_cal+0xc3>
40379245:	020c      	movi.n	a2, 0
}
40379247:	f01d      	retw.n
40379249:	000000        	ill

4037924c <rtc_time_us_to_slowclk>:

uint64_t rtc_time_us_to_slowclk(uint64_t time_in_us, uint32_t period)
{
4037924c:	004136        	entry	a1, 32
    assert(period);
4037924f:	00e456        	bnez	a4, 40379261 <rtc_time_us_to_slowclk+0x15>
40379252:	edf7d1        	l32r	a13, 40374a30 <_iram_text_start+0x62c> (3c022518 <_flash_rodata_start+0x23f8>)
40379255:	edf7c1        	l32r	a12, 40374a34 <_iram_text_start+0x630> (3c026cb4 <__func__$2>)
40379258:	a3a0b2        	movi	a11, 163
4037925b:	edf4a1        	l32r	a10, 40374a2c <_iram_text_start+0x628> (3c02250d <_flash_rodata_start+0x23ed>)
4037925e:	06aca5        	call8	4037fd28 <__assert_func>
    if (time_in_us > (UINT64_MAX >> RTC_CLK_CAL_FRACT)) {
40379261:	ecdf81        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40379264:	1c3837        	bltu	a8, a3, 40379284 <rtc_time_us_to_slowclk+0x38>
        return ((time_in_us / period) << RTC_CLK_CAL_FRACT) + ((time_in_us % period) << RTC_CLK_CAL_FRACT) / period;
    }
    return (time_in_us << RTC_CLK_CAL_FRACT) / period;
40379267:	41bd20        	srli	a11, a2, 13
4037926a:	0133d0        	slli	a3, a3, 19
4037926d:	04cd      	mov.n	a12, a4
4037926f:	0d0c      	movi.n	a13, 0
40379271:	01a2d0        	slli	a10, a2, 19
40379274:	20bb30        	or	a11, a11, a3
40379277:	ec9f81        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
4037927a:	0008e0        	callx8	a8
4037927d:	0a2d      	mov.n	a2, a10
4037927f:	0b3d      	mov.n	a3, a11
40379281:	0012c6        	j	403792d0 <rtc_time_us_to_slowclk+0x84>
        return ((time_in_us / period) << RTC_CLK_CAL_FRACT) + ((time_in_us % period) << RTC_CLK_CAL_FRACT) / period;
40379284:	050c      	movi.n	a5, 0
40379286:	04cd      	mov.n	a12, a4
40379288:	05dd      	mov.n	a13, a5
4037928a:	02ad      	mov.n	a10, a2
4037928c:	03bd      	mov.n	a11, a3
4037928e:	ec9981        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
40379291:	0008e0        	callx8	a8
40379294:	418da0        	srli	a8, a10, 13
40379297:	016bd0        	slli	a6, a11, 19
4037929a:	206860        	or	a6, a8, a6
4037929d:	017ad0        	slli	a7, a10, 19
403792a0:	04cd      	mov.n	a12, a4
403792a2:	05dd      	mov.n	a13, a5
403792a4:	20a220        	or	a10, a2, a2
403792a7:	20b330        	or	a11, a3, a3
403792aa:	ede381        	l32r	a8, 40374a38 <_iram_text_start+0x634> (40002574 <__umoddi3>)
403792ad:	0008e0        	callx8	a8
403792b0:	418da0        	srli	a8, a10, 13
403792b3:	01bbd0        	slli	a11, a11, 19
403792b6:	04cd      	mov.n	a12, a4
403792b8:	05dd      	mov.n	a13, a5
403792ba:	01aad0        	slli	a10, a10, 19
403792bd:	20b8b0        	or	a11, a8, a11
403792c0:	ec8d81        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
403792c3:	0008e0        	callx8	a8
403792c6:	36ba      	add.n	a3, a6, a11
403792c8:	27aa      	add.n	a2, a7, a10
403792ca:	02b2a7        	bgeu	a2, a10, 403792d0 <rtc_time_us_to_slowclk+0x84>
403792cd:	01c332        	addi	a3, a3, 1
}
403792d0:	f01d      	retw.n
	...

403792d4 <rtc_time_get>:
{
    return (rtc_cycles * period) >> RTC_CLK_CAL_FRACT;
}

uint64_t rtc_time_get(void)
{
403792d4:	004136        	entry	a1, 32
    SET_PERI_REG_MASK(RTC_CNTL_STATE0_REG, RTC_CNTL_SLEEP_EN);
}

FORCE_INLINE_ATTR uint64_t rtc_cntl_ll_get_rtc_time(void)
{
    SET_PERI_REG_MASK(RTC_CNTL_TIME_UPDATE_REG, RTC_CNTL_TIME_UPDATE);
403792d7:	edd991        	l32r	a9, 40374a3c <_iram_text_start+0x638> (6000800c <RTCCNTL+0xc>)
403792da:	0020c0        	memw
403792dd:	0988      	l32i.n	a8, a9, 0
403792df:	ed34a1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
403792e2:	2088a0        	or	a8, a8, a10
403792e5:	0020c0        	memw
403792e8:	0989      	s32i.n	a8, a9, 0
    uint64_t t = READ_PERI_REG(RTC_CNTL_TIME0_REG);
403792ea:	edd581        	l32r	a8, 40374a40 <_iram_text_start+0x63c> (60008010 <RTCCNTL+0x10>)
403792ed:	0020c0        	memw
403792f0:	0828      	l32i.n	a2, a8, 0
    t |= ((uint64_t) READ_PERI_REG(RTC_CNTL_TIME1_REG)) << 32;
403792f2:	edd481        	l32r	a8, 40374a44 <_iram_text_start+0x640> (60008014 <RTCCNTL+0x14>)
403792f5:	0020c0        	memw
403792f8:	0838      	l32i.n	a3, a8, 0
    return rtc_cntl_ll_get_rtc_time();
}
403792fa:	f01d      	retw.n

403792fc <rtc_clk_freq_cal>:
        esp_rom_delay_us(1);
    }
}

uint32_t rtc_clk_freq_cal(uint32_t cal_val)
{
403792fc:	004136        	entry	a1, 32
    if (cal_val == 0) {
403792ff:	129c      	beqz.n	a2, 40379314 <rtc_clk_freq_cal+0x18>
        return 0;   // cal_val will be denominator, return 0 as the symbol of failure.
    }
    return 1000000ULL * (1 << RTC_CLK_CAL_FRACT) / cal_val;
40379301:	02cd      	mov.n	a12, a2
40379303:	00a0d2        	movi	a13, 0
40379306:	edd0a1        	l32r	a10, 40374a48 <_iram_text_start+0x644> (12000000 <UserFrameTotalSize+0x11ffff00>)
40379309:	7aa0b2        	movi	a11, 122
4037930c:	ec7a81        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
4037930f:	0008e0        	callx8	a8
40379312:	0a2d      	mov.n	a2, a10
}
40379314:	f01d      	retw.n
	...

40379318 <enable_timer_group0_for_calibration>:
uint32_t rtc_clk_freq_to_period(uint32_t) __attribute__((alias("rtc_clk_freq_cal")));

/// @brief if the calibration is used, we need to enable the timer group0 first
__attribute__((constructor))
static void enable_timer_group0_for_calibration(void)
{
40379318:	004136        	entry	a1, 32
#ifndef BOOTLOADER_BUILD
    PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_TIMG0_MODULE, ref_count) {
4037931b:	170c      	movi.n	a7, 1
4037931d:	001406        	j	40379371 <enable_timer_group0_for_calibration+0x59>
 * @param enable true to enable, false to disable
 */
static inline void _timer_ll_enable_bus_clock(int group_id, bool enable)
{
    if (group_id == 0) {
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
40379320:	edcb81        	l32r	a8, 40374a4c <_iram_text_start+0x648> (600c0000 <SYSTEM>)
40379323:	0020c0        	memw
40379326:	062892        	l32i	a9, a8, 24
40379329:	edc9a1        	l32r	a10, 40374a50 <_iram_text_start+0x64c> (2000 <UserFrameTotalSize+0x1f00>)
4037932c:	2099a0        	or	a9, a9, a10
4037932f:	0020c0        	memw
40379332:	066892        	s32i	a9, a8, 24
 * @param group_id Group ID
 */
static inline void _timer_ll_reset_register(int group_id)
{
    if (group_id == 0) {
        SYSTEM.perip_rst_en0.timergroup_rst = 1;
40379335:	0020c0        	memw
40379338:	8898      	l32i.n	a9, a8, 32
4037933a:	2099a0        	or	a9, a9, a10
4037933d:	0020c0        	memw
40379340:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup_rst = 0;
40379342:	0020c0        	memw
40379345:	8898      	l32i.n	a9, a8, 32
40379347:	edc3a1        	l32r	a10, 40374a54 <_iram_text_start+0x650> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4037934a:	1099a0        	and	a9, a9, a10
4037934d:	0020c0        	memw
40379350:	8899      	s32i.n	a9, a8, 32
        TIMERG0.wdtconfig0.wdt_flashboot_mod_en = 0;
40379352:	edc191        	l32r	a9, 40374a58 <_iram_text_start+0x654> (6001f000 <TIMERG0>)
40379355:	0020c0        	memw
40379358:	122982        	l32i	a8, a9, 72
4037935b:	edc0a1        	l32r	a10, 40374a5c <_iram_text_start+0x658> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
4037935e:	1088a0        	and	a8, a8, a10
40379361:	0020c0        	memw
40379364:	126982        	s32i	a8, a9, 72
40379367:	aa0c      	movi.n	a10, 10
40379369:	fee965        	call8	40378200 <periph_rcc_acquire_exit>
4037936c:	770b      	addi.n	a7, a7, -1
4037936e:	747070        	extui	a7, a7, 0, 8
40379371:	b78c      	beqz.n	a7, 40379380 <enable_timer_group0_for_calibration+0x68>
40379373:	aa0c      	movi.n	a10, 10
40379375:	fee7a5        	call8	403781f0 <periph_rcc_acquire_enter>
40379378:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
4037937a:	fa2a16        	beqz	a10, 40379320 <enable_timer_group0_for_calibration+0x8>
4037937d:	fff986        	j	40379367 <enable_timer_group0_for_calibration+0x4f>
    }
#else
    _timer_ll_enable_bus_clock(0, true);
    _timer_ll_reset_register(0);
#endif
}
40379380:	f01d      	retw.n
	...

40379384 <systimer_ticks_to_us>:
 * @brief systimer's clock source is fixed to XTAL (40MHz), and has a fixed fractional divider (2.5).
 *        So the resolution of the systimer is 40MHz/2.5 = 16MHz.
 */

uint64_t systimer_ticks_to_us(uint64_t ticks)
{
40379384:	004136        	entry	a1, 32
    return ticks / 16;
40379387:	018340        	slli	a8, a3, 28
4037938a:	412420        	srli	a2, a2, 4
}
4037938d:	202820        	or	a2, a8, a2
40379390:	413430        	srli	a3, a3, 4
40379393:	f01d      	retw.n
40379395:	000000        	ill

40379398 <systimer_us_to_ticks>:

uint64_t systimer_us_to_ticks(uint64_t us)
{
40379398:	004136        	entry	a1, 32
    return us * 16;
4037939b:	358c20        	extui	a8, a2, 28, 4
4037939e:	1133c0        	slli	a3, a3, 4
}
403793a1:	1122c0        	slli	a2, a2, 4
403793a4:	203830        	or	a3, a8, a3
403793a7:	f01d      	retw.n
403793a9:	000000        	ill

403793ac <esp_cache_get_alignment>:

    return ret;
}

esp_err_t esp_cache_get_alignment(uint32_t heap_caps, size_t *out_alignment)
{
403793ac:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(out_alignment, ESP_ERR_INVALID_ARG, TAG, "null pointer");
403793af:	022356        	bnez	a3, 403793d5 <esp_cache_get_alignment+0x29>
403793b2:	068525        	call8	4037fc04 <esp_log_timestamp>
403793b5:	edabb1        	l32r	a11, 40374a64 <_iram_text_start+0x660> (3fc93f84 <__func__$0+0x398>)
403793b8:	0fa182        	movi	a8, 0x10f
403793bb:	0189      	s32i.n	a8, a1, 0
403793bd:	eda8f1        	l32r	a15, 40374a60 <_iram_text_start+0x65c> (3fc93bd4 <__FUNCTION__$0>)
403793c0:	0bed      	mov.n	a14, a11
403793c2:	0add      	mov.n	a13, a10
403793c4:	eda9c1        	l32r	a12, 40374a68 <_iram_text_start+0x664> (3fc93f8c <__func__$0+0x3a0>)
403793c7:	1a0c      	movi.n	a10, 1
403793c9:	0675e5        	call8	4037fb28 <esp_log>
403793cc:	02a122        	movi	a2, 0x102
403793cf:	000646        	j	403793ec <esp_cache_get_alignment+0x40>
403793d2:	000000        	ill

    uint32_t cache_level = CACHE_LL_LEVEL_INT_MEM;
    uint32_t data_cache_line_size = 0;

    if (heap_caps & MALLOC_CAP_SPIRAM) {
403793d5:	00a482        	movi	a8, 0x400
403793d8:	10a280        	and	a10, a2, a8
403793db:	020287        	bnone	a2, a8, 403793e1 <esp_cache_get_alignment+0x35>
        cache_level = CACHE_LL_LEVEL_EXT_MEM;
403793de:	01a0a2        	movi	a10, 1
    }

    data_cache_line_size = cache_hal_get_cache_line_size(cache_level, CACHE_TYPE_DATA);
403793e1:	00a0b2        	movi	a11, 0
403793e4:	037925        	call8	4037cb78 <cache_hal_get_cache_line_size>

    *out_alignment = data_cache_line_size;
403793e7:	0063a2        	s32i	a10, a3, 0

    return ESP_OK;
403793ea:	020c      	movi.n	a2, 0
}
403793ec:	f01d      	retw.n
	...

403793f0 <esp_cache_suspend_ext_mem_cache>:
#endif

#define ALIGN_UP_BY(num, align) (((num) + ((align) - 1)) & ~((align) - 1))

void esp_cache_suspend_ext_mem_cache(void)
{
403793f0:	004136        	entry	a1, 32
     * before suspending the external mem cache, writeback internal mem cache content back to external mem cache
     * to avoid stuck issue caused by internal mem cache auto-writeback
     */
    cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
#endif
    cache_hal_suspend(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
403793f3:	02a0b2        	movi	a11, 2
403793f6:	01a0a2        	movi	a10, 1
403793f9:	035765        	call8	4037c970 <cache_hal_suspend>
}
403793fc:	000090        	retw
	...

40379400 <esp_cache_resume_ext_mem_cache>:

void esp_cache_resume_ext_mem_cache(void)
{
40379400:	004136        	entry	a1, 32
    cache_hal_resume(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40379403:	02a0b2        	movi	a11, 2
40379406:	01a0a2        	movi	a10, 1
40379409:	0359e5        	call8	4037c9a8 <cache_hal_resume>
}
4037940c:	000090        	retw
	...

40379410 <esp_cache_freeze_ext_mem_cache>:
 *----------------------------------------------------------------------------*/
#if SOC_CACHE_FREEZE_SUPPORTED
DEFINE_CRIT_SECTION_LOCK_STATIC(s_spinlock);

void esp_cache_freeze_ext_mem_cache(void)
{
40379410:	004136        	entry	a1, 32
     * to avoid stuck issue caused by internal mem cache auto-writeback
     */
    cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
#endif

    cache_hal_freeze(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40379413:	02a0b2        	movi	a11, 2
40379416:	01a0a2        	movi	a10, 1
40379419:	036e25        	call8	4037cafc <cache_hal_freeze>
    esp_cpu_unstall(other_cpuid);
#else
    //single core mode, don't need to unstall other core
#endif
#endif
}
4037941c:	000090        	retw
	...

40379420 <esp_cache_unfreeze_ext_mem_cache>:

void esp_cache_unfreeze_ext_mem_cache(void)
{
40379420:	004136        	entry	a1, 32
    cache_hal_unfreeze(CACHE_LL_LEVEL_EXT_MEM, CACHE_TYPE_ALL);
40379423:	02a0b2        	movi	a11, 2
40379426:	01a0a2        	movi	a10, 1
40379429:	0370e5        	call8	4037cb38 <cache_hal_unfreeze>
}
4037942c:	000090        	retw
	...

40379430 <esp_cache_freeze_caches_disable_interrupts>:
#endif
           ;
}

void esp_cache_freeze_caches_disable_interrupts(void)
{
40379430:	004136        	entry	a1, 32
    asm volatile ("mov %0, sp;" : "=r" (sp));
40379433:	209110        	or	a9, a1, a1
    return ((intptr_t)p >= SOC_DRAM_LOW && (intptr_t)p < SOC_DRAM_HIGH);
40379436:	ec8981        	l32r	a8, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
40379439:	898a      	add.n	a8, a9, a8
           || esp_ptr_in_rtc_dram_fast(sp)
4037943b:	ecf3a1        	l32r	a10, 40374808 <_iram_text_start+0x404> (77fff <UserFrameTotalSize+0x77eff>)
4037943e:	19ba87        	bgeu	a10, a8, 4037945b <esp_cache_freeze_caches_disable_interrupts+0x2b>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
40379441:	ec6681        	l32r	a8, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
40379444:	998a      	add.n	a9, a9, a8
40379446:	ec6681        	l32r	a8, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
40379449:	0eb897        	bgeu	a8, a9, 4037945b <esp_cache_freeze_caches_disable_interrupts+0x2b>
    assert(s_task_stack_is_sane_when_cache_frozen());
4037944c:	ed88d1        	l32r	a13, 40374a6c <_iram_text_start+0x668> (3fc93f2c <__func__$0+0x340>)
4037944f:	ed88c1        	l32r	a12, 40374a70 <_iram_text_start+0x66c> (3fc93bec <__func__$0>)
40379452:	60a0b2        	movi	a11, 96
40379455:	ed87a1        	l32r	a10, 40374a74 <_iram_text_start+0x670> (3fc93f70 <__func__$0+0x384>)
40379458:	068ce5        	call8	4037fd28 <__assert_func>
    if (xPortInIsrContext()) {
4037945b:	00b965        	call8	40379ff0 <xPortInIsrContext>
4037945e:	ba8c      	beqz.n	a10, 4037946d <esp_cache_freeze_caches_disable_interrupts+0x3d>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40379460:	fb7c      	movi.n	a11, -1
40379462:	ed85a1        	l32r	a10, 40374a78 <_iram_text_start+0x674> (3fc929e4 <s_spinlock>)
40379465:	00bae5        	call8	4037a014 <xPortEnterCriticalTimeout>
40379468:	000286        	j	40379476 <esp_cache_freeze_caches_disable_interrupts+0x46>
4037946b:	b20000        	mulsh	a0, a0, a0
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037946e:	82a1ffaf 	ee.ldf.128.ip	f4, f3, f15, f10, a10, -16
40379472:	ed          	.byte	0xed
40379473:	00ba25        	call8	4037a014 <xPortEnterCriticalTimeout>
    /**
     * - disable non-iram interrupt on current core
     * - current core call cache freeze
     * - external access from other cores will hang on cache
     */
    esp_intr_noniram_disable();
40379476:	fd02a5        	call8	403764a0 <esp_intr_noniram_disable>
    esp_cache_freeze_ext_mem_cache();
40379479:	fff965        	call8	40379410 <esp_cache_freeze_ext_mem_cache>
}
4037947c:	f01d      	retw.n
	...

40379480 <esp_cache_unfreeze_caches_enable_interrupts>:

void esp_cache_unfreeze_caches_enable_interrupts(void)
{
40379480:	004136        	entry	a1, 32
    esp_cache_unfreeze_ext_mem_cache();
40379483:	fff9e5        	call8	40379420 <esp_cache_unfreeze_ext_mem_cache>
    esp_intr_noniram_enable();
40379486:	fd08e5        	call8	40376514 <esp_intr_noniram_enable>
    if (xPortInIsrContext()) {
40379489:	00b665        	call8	40379ff0 <xPortInIsrContext>
4037948c:	8a8c      	beqz.n	a10, 40379498 <esp_cache_unfreeze_caches_enable_interrupts+0x18>
        portEXIT_CRITICAL_ISR(mux);
4037948e:	ed7aa1        	l32r	a10, 40374a78 <_iram_text_start+0x674> (3fc929e4 <s_spinlock>)
40379491:	00cd25        	call8	4037a164 <vPortExitCritical>
40379494:	000186        	j	4037949e <esp_cache_unfreeze_caches_enable_interrupts+0x1e>
40379497:	00          	.byte	00
        portEXIT_CRITICAL(mux);
40379498:	ed78a1        	l32r	a10, 40374a78 <_iram_text_start+0x674> (3fc929e4 <s_spinlock>)
4037949b:	00cca5        	call8	4037a164 <vPortExitCritical>
    esp_os_exit_critical_safe(&s_spinlock);
}
4037949e:	f01d      	retw.n

403794a0 <Cache_Suspend_ICache>:
    }
}
// renamed for patch
extern uint32_t rom_Cache_Suspend_ICache(void);
uint32_t Cache_Suspend_ICache(void)
{
403794a0:	004136        	entry	a1, 32
    uint32_t ret = rom_Cache_Suspend_ICache();
403794a3:	ed7781        	l32r	a8, 40374a80 <_iram_text_start+0x67c> (4000189c <rom_Cache_Suspend_ICache>)
403794a6:	0008e0        	callx8	a8
403794a9:	202aa0        	or	a2, a10, a10
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_ICACHE_STATE) != 1) {
403794ac:	ed7481        	l32r	a8, 40374a7c <_iram_text_start+0x678> (600c4130 <SYSTEM+0x4130>)
403794af:	0020c0        	memw
403794b2:	0888      	l32i.n	a8, a8, 0
403794b4:	b48080        	extui	a8, a8, 0, 12
403794b7:	f11866        	bnei	a8, 1, 403794ac <Cache_Suspend_ICache+0xc>
    Cache_Wait_Idle(1);
    return ret;
}
403794ba:	f01d      	retw.n

403794bc <Cache_Suspend_DCache>:
extern uint32_t Cache_Suspend_ICache(void);

// renamed for patch
extern uint32_t rom_Cache_Suspend_DCache(void);
uint32_t Cache_Suspend_DCache(void)
{
403794bc:	004136        	entry	a1, 32
    uint32_t ret = rom_Cache_Suspend_DCache();
403794bf:	ed7181        	l32r	a8, 40374a84 <_iram_text_start+0x680> (400018b4 <rom_Cache_Suspend_DCache>)
403794c2:	0008e0        	callx8	a8
403794c5:	202aa0        	or	a2, a10, a10
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_DCACHE_STATE) != 1) {
403794c8:	ed6d81        	l32r	a8, 40374a7c <_iram_text_start+0x678> (600c4130 <SYSTEM+0x4130>)
403794cb:	0020c0        	memw
403794ce:	0888      	l32i.n	a8, a8, 0
403794d0:	b48c80        	extui	a8, a8, 12, 12
403794d3:	118840        	slli	a8, a8, 12
403794d6:	ec5b91        	l32r	a9, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
403794d9:	eb9897        	bne	a8, a9, 403794c8 <Cache_Suspend_DCache+0xc>
    Cache_Wait_Idle(0);
    return ret;
}
403794dc:	f01d      	retw.n
	...

403794e0 <Cache_Freeze_ICache_Enable>:

#if SOC_CACHE_FREEZE_SUPPORTED
// renamed for patch
extern void rom_Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode);
void Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode)
{
403794e0:	004136        	entry	a1, 32
403794e3:	20a220        	or	a10, a2, a2
    rom_Cache_Freeze_ICache_Enable(mode);
403794e6:	ed6881        	l32r	a8, 40374a88 <_iram_text_start+0x684> (400018e4 <rom_Cache_Freeze_ICache_Enable>)
403794e9:	0008e0        	callx8	a8
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_ICACHE_STATE) != 1) {
403794ec:	ed6481        	l32r	a8, 40374a7c <_iram_text_start+0x678> (600c4130 <SYSTEM+0x4130>)
403794ef:	0020c0        	memw
403794f2:	0888      	l32i.n	a8, a8, 0
403794f4:	b48080        	extui	a8, a8, 0, 12
403794f7:	f11866        	bnei	a8, 1, 403794ec <Cache_Freeze_ICache_Enable+0xc>
    Cache_Wait_Idle(1);
}
403794fa:	f01d      	retw.n

403794fc <Cache_Freeze_DCache_Enable>:
extern void Cache_Freeze_ICache_Enable(cache_freeze_mode_t mode);

// renamed for patch
extern void rom_Cache_Freeze_DCache_Enable(cache_freeze_mode_t mode);
void Cache_Freeze_DCache_Enable(cache_freeze_mode_t mode)
{
403794fc:	004136        	entry	a1, 32
403794ff:	20a220        	or	a10, a2, a2
    rom_Cache_Freeze_DCache_Enable(mode);
40379502:	ed6281        	l32r	a8, 40374a8c <_iram_text_start+0x688> (400018fc <rom_Cache_Freeze_DCache_Enable>)
40379505:	0008e0        	callx8	a8
        while (REG_GET_FIELD(EXTMEM_CACHE_STATE_REG, EXTMEM_DCACHE_STATE) != 1) {
40379508:	ed5d81        	l32r	a8, 40374a7c <_iram_text_start+0x678> (600c4130 <SYSTEM+0x4130>)
4037950b:	0020c0        	memw
4037950e:	0888      	l32i.n	a8, a8, 0
40379510:	b48c80        	extui	a8, a8, 12, 12
40379513:	118840        	slli	a8, a8, 12
40379516:	ec4b91        	l32r	a9, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
40379519:	eb9897        	bne	a8, a9, 40379508 <Cache_Freeze_DCache_Enable+0xc>
    Cache_Wait_Idle(0);
}
4037951c:	f01d      	retw.n
	...

40379520 <esp_rom_opiflash_cache_mode_config>:
}

#elif CONFIG_IDF_TARGET_ESP32S3
extern void esp_rom_spi_set_address_bit_len(int spi, int addr_bits);
void esp_rom_opiflash_cache_mode_config(esp_rom_spiflash_read_mode_t mode, const esp_rom_opiflash_spi0rd_t *cache)
{
40379520:	004136        	entry	a1, 32
40379523:	02bd      	mov.n	a11, a2
    esp_rom_spi_set_op_mode(0, mode);
40379525:	0a0c      	movi.n	a10, 0
40379527:	ed5f81        	l32r	a8, 40374aa4 <_iram_text_start+0x6a0> (400008a0 <esp_rom_spi_set_op_mode>)
4037952a:	0008e0        	callx8	a8
    REG_CLR_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_MOSI);
4037952d:	ed5881        	l32r	a8, 40374a90 <_iram_text_start+0x68c> (60003018 <SPIMEM0+0x18>)
40379530:	0020c0        	memw
40379533:	0898      	l32i.n	a9, a8, 0
40379535:	eca3a1        	l32r	a10, 403747c4 <_iram_text_start+0x3c0> (f7ffffff <_rtc_reserved_end+0x97efffff>)
40379538:	1099a0        	and	a9, a9, a10
4037953b:	0020c0        	memw
4037953e:	0899      	s32i.n	a9, a8, 0
    REG_SET_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_MISO | SPI_MEM_USR_ADDR);
40379540:	0020c0        	memw
40379543:	0898      	l32i.n	a9, a8, 0
40379545:	ed53a1        	l32r	a10, 40374a94 <_iram_text_start+0x690> (50000000 <_rtc_bss_end>)
40379548:	2099a0        	or	a9, a9, a10
4037954b:	0020c0        	memw
4037954e:	006892        	s32i	a9, a8, 0

    if (cache) {
40379551:	0b5316        	beqz	a3, 4037960a <esp_rom_opiflash_cache_mode_config+0xea>
        esp_rom_spi_set_address_bit_len(0, cache->addr_bit_len);
40379554:	0003b2        	l8ui	a11, a3, 0
40379557:	00a0a2        	movi	a10, 0
4037955a:	ed5381        	l32r	a8, 40374aa8 <_iram_text_start+0x6a4> (40000c60 <esp_rom_spi_set_address_bit_len>)
4037955d:	0008e0        	callx8	a8
        // Patch for ROM function `esp_rom_opiflash_cache_mode_config`, because when dummy is 0,
        // `SPI_MEM_USR_DUMMY` should be 0. `esp_rom_opiflash_cache_mode_config` doesn't handle this
        // properly.
        if (cache->dummy_bit_len == 0) {
40379560:	010382        	l8ui	a8, a3, 1
40379563:	58dc      	bnez.n	a8, 4037957c <esp_rom_opiflash_cache_mode_config+0x5c>
            REG_CLR_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_DUMMY);
40379565:	ed4a91        	l32r	a9, 40374a90 <_iram_text_start+0x68c> (60003018 <SPIMEM0+0x18>)
40379568:	0020c0        	memw
4037956b:	0988      	l32i.n	a8, a9, 0
4037956d:	ec94a1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
40379570:	1088a0        	and	a8, a8, a10
40379573:	0020c0        	memw
40379576:	0989      	s32i.n	a8, a9, 0
40379578:	000ec6        	j	403795b7 <esp_rom_opiflash_cache_mode_config+0x97>
4037957b:	459100        	extui	a9, a0, 17, 5
        } else {
            REG_SET_BIT(SPI_MEM_USER_REG(0), SPI_MEM_USR_DUMMY);
4037957e:	ed          	.byte	0xed
4037957f:	0020c0        	memw
40379582:	0988      	l32i.n	a8, a9, 0
40379584:	ed04a1        	l32r	a10, 40374994 <_iram_text_start+0x590> (20000000 <UserFrameTotalSize+0x1fffff00>)
40379587:	2088a0        	or	a8, a8, a10
4037958a:	0020c0        	memw
4037958d:	0989      	s32i.n	a8, a9, 0
            REG_SET_FIELD(SPI_MEM_USER1_REG(0), SPI_MEM_USR_DUMMY_CYCLELEN, cache->dummy_bit_len - 1 + rom_spiflash_legacy_data->dummy_len_plus[0]);
4037958f:	ed42a1        	l32r	a10, 40374a98 <_iram_text_start+0x694> (6000301c <SPIMEM0+0x1c>)
40379592:	0020c0        	memw
40379595:	0a88      	l32i.n	a8, a10, 0
40379597:	c0af92        	movi	a9, -64
4037959a:	109890        	and	a9, a8, a9
4037959d:	010382        	l8ui	a8, a3, 1
403795a0:	880b      	addi.n	a8, a8, -1
403795a2:	ec86b1        	l32r	a11, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
403795a5:	0bb8      	l32i.n	a11, a11, 0
403795a7:	180bb2        	l8ui	a11, a11, 24
403795aa:	88ba      	add.n	a8, a8, a11
403795ac:	548080        	extui	a8, a8, 0, 6
403795af:	208980        	or	a8, a9, a8
403795b2:	0020c0        	memw
403795b5:	0a89      	s32i.n	a8, a10, 0
        }
        REG_SET_FIELD(SPI_MEM_USER2_REG(0), SPI_MEM_USR_COMMAND_VALUE, cache->cmd);
403795b7:	ed39a1        	l32r	a10, 40374a9c <_iram_text_start+0x698> (60003020 <SPIMEM0+0x20>)
403795ba:	0020c0        	memw
403795bd:	0a88      	l32i.n	a8, a10, 0
403795bf:	f58080        	extui	a8, a8, 16, 16
403795c2:	118800        	slli	a8, a8, 16
403795c5:	011392        	l16ui	a9, a3, 2
403795c8:	208890        	or	a8, a8, a9
403795cb:	0020c0        	memw
403795ce:	0a89      	s32i.n	a8, a10, 0
        REG_SET_FIELD(SPI_MEM_USER2_REG(0), SPI_MEM_USR_COMMAND_BITLEN, cache->cmd_bit_len - 1);
403795d0:	0020c0        	memw
403795d3:	0a88      	l32i.n	a8, a10, 0
403795d5:	1188c0        	slli	a8, a8, 4
403795d8:	418480        	srli	a8, a8, 4
403795db:	040392        	l8ui	a9, a3, 4
403795de:	990b      	addi.n	a9, a9, -1
403795e0:	019940        	slli	a9, a9, 28
403795e3:	208890        	or	a8, a8, a9
403795e6:	0020c0        	memw
403795e9:	0a89      	s32i.n	a8, a10, 0
        REG_SET_FIELD(SPI_MEM_DDR_REG(0), SPI_MEM_SPI_FMEM_VAR_DUMMY, cache->var_dummy_en);
403795eb:	ed2da1        	l32r	a10, 40374aa0 <_iram_text_start+0x69c> (600030e0 <SPIMEM0+0xe0>)
403795ee:	0020c0        	memw
403795f1:	0a88      	l32i.n	a8, a10, 0
403795f3:	d97c      	movi.n	a9, -3
403795f5:	109890        	and	a9, a8, a9
403795f8:	050382        	l8ui	a8, a3, 5
403795fb:	888a      	add.n	a8, a8, a8
403795fd:	2b0c      	movi.n	a11, 2
403795ff:	1088b0        	and	a8, a8, a11
40379602:	208980        	or	a8, a9, a8
40379605:	0020c0        	memw
40379608:	0a89      	s32i.n	a8, a10, 0
    }
}
4037960a:	f01d      	retw.n

4037960c <esp_rom_install_uart_printf>:
    }
}

#if ESP_ROM_HAS_ETS_PRINTF_BUG
void esp_rom_install_uart_printf(void)
{
4037960c:	004136        	entry	a1, 32
#if !ESP_ROM_HAS_OUTPUT_TO_CHANNELS_FUNC
    _putc1 = esp_rom_output_putc;
4037960f:	ed2781        	l32r	a8, 40374aac <_iram_text_start+0x6a8> (3fc92430 <_putc1>)
40379612:	ed2791        	l32r	a9, 40374ab0 <_iram_text_start+0x6ac> (400006b4 <esp_rom_output_putc>)
40379615:	0899      	s32i.n	a9, a8, 0
    extern void ets_install_uart_printf(void);
    extern bool g_uart_print;
    extern bool g_usb_print;
    // If ROM log is disabled permanently via eFuse or temporarily via RTC storage register,
    // this ROM symbol will be set to false, and cause ``esp_rom_printf`` can't work on esp-idf side.
    g_uart_print = true;
40379617:	01a082        	movi	a8, 1
4037961a:	ed2691        	l32r	a9, 40374ab4 <_iram_text_start+0x6b0> (3fceffb9 <g_uart_print>)
4037961d:	004982        	s8i	a8, a9, 0
    g_usb_print = true;
40379620:	ed2691        	l32r	a9, 40374ab8 <_iram_text_start+0x6b4> (3fceffb8 <g_usb_print>)
40379623:	004982        	s8i	a8, a9, 0
    ets_install_uart_printf();
40379626:	ed2581        	l32r	a8, 40374abc <_iram_text_start+0x6b8> (400005e8 <ets_install_uart_printf>)
40379629:	0008e0        	callx8	a8
#endif // !CONFIG_IDF_TARGET_LINUX
}
4037962c:	f01d      	retw.n
	...

40379630 <esp_error_check_failed_print>:
    return return_address;
}
#endif

static void esp_error_check_failed_print(const char *msg, esp_err_t rc, const char *file, int line, const char *function, const char *expression, intptr_t addr)
{
40379630:	004136        	entry	a1, 32
40379633:	02bd      	mov.n	a11, a2
    esp_rom_printf("%s failed: esp_err_t 0x%x", msg, rc);
40379635:	03cd      	mov.n	a12, a3
40379637:	ed22a1        	l32r	a10, 40374ac0 <_iram_text_start+0x6bc> (3fc94280 <__func__$0+0x694>)
4037963a:	eba881        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
4037963d:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" (%s)", esp_err_to_name(rc));
40379640:	20a330        	or	a10, a3, a3
40379643:	ebb181        	l32r	a8, 40374508 <_iram_text_start+0x104> (42002b38 <esp_err_to_name>)
40379646:	0008e0        	callx8	a8
40379649:	20baa0        	or	a11, a10, a10
4037964c:	ed1ea1        	l32r	a10, 40374ac4 <_iram_text_start+0x6c0> (3fc9429c <__func__$0+0x6b0>)
4037964f:	eba381        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40379652:	0008e0        	callx8	a8
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" at 0x%08x\n", esp_cpu_get_call_addr(addr));
40379655:	81b8      	l32i.n	a11, a1, 32
40379657:	fdcbb2        	addi	a11, a11, -3
4037965a:	ed1ba1        	l32r	a10, 40374ac8 <_iram_text_start+0x6c4> (3fc942a4 <__func__$0+0x6b8>)
4037965d:	eb9f81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40379660:	0008e0        	callx8	a8
#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    if (spi_flash_cache_enabled())  // strings may be in flash cache
40379663:	fe3525        	call8	403779b4 <spi_flash_cache_enabled>
40379666:	fa8c      	beqz.n	a10, 40379679 <esp_error_check_failed_print+0x49>
#endif
    {
        esp_rom_printf("file: \"%s\" line %d\nfunc: %s\nexpression: %s\n", file, line, function, expression);
40379668:	07ed      	mov.n	a14, a7
4037966a:	06dd      	mov.n	a13, a6
4037966c:	05cd      	mov.n	a12, a5
4037966e:	04bd      	mov.n	a11, a4
40379670:	ed17a1        	l32r	a10, 40374acc <_iram_text_start+0x6c8> (3fc942b0 <__func__$0+0x6c4>)
40379673:	eb9a81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40379676:	0008e0        	callx8	a8
    }
}
40379679:	f01d      	retw.n
	...

4037967c <_esp_error_check_failed>:
{
    esp_error_check_failed_print("ESP_ERROR_CHECK_WITHOUT_ABORT", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
}

void _esp_error_check_failed(esp_err_t rc, const char *file, int line, const char *function, const char *expression)
{
4037967c:	006136        	entry	a1, 48
4037967f:	02bd      	mov.n	a11, a2
40379681:	03cd      	mov.n	a12, a3
40379683:	04dd      	mov.n	a13, a4
40379685:	05ed      	mov.n	a14, a5
40379687:	06fd      	mov.n	a15, a6
    esp_error_check_failed_print("ESP_ERROR_CHECK", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
40379689:	ed1191        	l32r	a9, 40374ad0 <_iram_text_start+0x6cc> (40379689 <_esp_error_check_failed+0xd>)
4037968c:	159e90        	extui	a9, a9, 30, 2
4037968f:	019920        	slli	a9, a9, 30
40379692:	1180e0        	slli	a8, a0, 2
40379695:	418280        	srli	a8, a8, 2
40379698:	208890        	or	a8, a8, a9
4037969b:	0189      	s32i.n	a8, a1, 0
4037969d:	ed0da1        	l32r	a10, 40374ad4 <_iram_text_start+0x6d0> (3fc942dc <__func__$0+0x6f0>)
403796a0:	fff8e5        	call8	40379630 <esp_error_check_failed_print>
    abort();
403796a3:	065ca5        	call8	4037fc6c <abort>
	...

403796a8 <esp_system_abort>:
{
    return IDF_VER;
}

void __attribute__((noreturn)) esp_system_abort(const char *details)
{
403796a8:	004136        	entry	a1, 32
403796ab:	02ad      	mov.n	a10, a2
    panic_abort(details);
403796ad:	fc3025        	call8	403759b0 <panic_abort>

403796b0 <__ubsan_include>:
    __ubsan_default_handler(&data->loc, __func__);
}

/* Hook for the linker to include this object file */
void __ubsan_include(void)
{
403796b0:	004136        	entry	a1, 32
}
403796b3:	f01d      	retw.n
403796b5:	000000        	ill

403796b8 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
403796b8:	004136        	entry	a1, 32
403796bb:	207220        	or	a7, a2, a2
403796be:	20b330        	or	a11, a3, a3
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
403796c1:	0020c0        	memw
403796c4:	0e2262        	l32i	a6, a2, 56

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
403796c7:	1022c2        	l32i	a12, a2, 64
403796ca:	2cdc      	bnez.n	a12, 403796e0 <prvCopyDataToQueue+0x28>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
403796cc:	0288      	l32i.n	a8, a2, 0
403796ce:	05b856        	bnez	a8, 4037972d <prvCopyDataToQueue+0x75>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
403796d1:	22a8      	l32i.n	a10, a2, 8
403796d3:	026ca5        	call8	4037bd9c <xTaskPriorityDisinherit>
403796d6:	0a2d      	mov.n	a2, a10
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
403796d8:	080c      	movi.n	a8, 0
403796da:	2789      	s32i.n	a8, a7, 8
403796dc:	0017c6        	j	4037973f <prvCopyDataToQueue+0x87>
403796df:	d4dc00        	extui	a13, a0, 12, 14
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
403796e2:	12a8      	l32i.n	a10, a2, 4
403796e4:	eb8781        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403796e7:	0008e0        	callx8	a8
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
403796ea:	1288      	l32i.n	a8, a2, 4
403796ec:	102292        	l32i	a9, a2, 64
403796ef:	889a      	add.n	a8, a8, a9
403796f1:	1289      	s32i.n	a8, a2, 4

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
403796f3:	2298      	l32i.n	a9, a2, 8
403796f5:	393897        	bltu	a8, a9, 40379732 <prvCopyDataToQueue+0x7a>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
403796f8:	0288      	l32i.n	a8, a2, 0
403796fa:	1289      	s32i.n	a8, a2, 4
    BaseType_t xReturn = pdFALSE;
403796fc:	042d      	mov.n	a2, a4
403796fe:	000f46        	j	4037973f <prvCopyDataToQueue+0x87>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
40379701:	32a8      	l32i.n	a10, a2, 12
40379703:	eb7f81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40379706:	0008e0        	callx8	a8
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
40379709:	3288      	l32i.n	a8, a2, 12
4037970b:	102292        	l32i	a9, a2, 64
4037970e:	60a090        	neg	a10, a9
40379711:	c08890        	sub	a8, a8, a9
40379714:	3289      	s32i.n	a8, a2, 12

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
40379716:	0298      	l32i.n	a9, a2, 0
40379718:	05b897        	bgeu	a8, a9, 40379721 <prvCopyDataToQueue+0x69>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
4037971b:	2288      	l32i.n	a8, a2, 8
4037971d:	88aa      	add.n	a8, a8, a10
4037971f:	3289      	s32i.n	a8, a2, 12
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
40379721:	132466        	bnei	a4, 2, 40379738 <prvCopyDataToQueue+0x80>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
40379724:	569c      	beqz.n	a6, 4037973d <prvCopyDataToQueue+0x85>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
40379726:	660b      	addi.n	a6, a6, -1
    BaseType_t xReturn = pdFALSE;
40379728:	020c      	movi.n	a2, 0
4037972a:	000446        	j	4037973f <prvCopyDataToQueue+0x87>
4037972d:	020c      	movi.n	a2, 0
4037972f:	000306        	j	4037973f <prvCopyDataToQueue+0x87>
40379732:	042d      	mov.n	a2, a4
40379734:	0001c6        	j	4037973f <prvCopyDataToQueue+0x87>
40379737:	020c00        	andb	b0, b12, b0
4037973a:	000046        	j	4037973f <prvCopyDataToQueue+0x87>
4037973d:	020c      	movi.n	a2, 0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
4037973f:	661b      	addi.n	a6, a6, 1
40379741:	0020c0        	memw
40379744:	e769      	s32i.n	a6, a7, 56

    return xReturn;
}
40379746:	f01d      	retw.n

40379748 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
40379748:	004136        	entry	a1, 32
4037974b:	03ad      	mov.n	a10, a3
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
4037974d:	1022c2        	l32i	a12, a2, 64
40379750:	5c9c      	beqz.n	a12, 40379769 <prvCopyDataFromQueue+0x21>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
40379752:	3288      	l32i.n	a8, a2, 12
40379754:	88ca      	add.n	a8, a8, a12
40379756:	3289      	s32i.n	a8, a2, 12

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
40379758:	2298      	l32i.n	a9, a2, 8
4037975a:	033897        	bltu	a8, a9, 40379761 <prvCopyDataFromQueue+0x19>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
4037975d:	0288      	l32i.n	a8, a2, 0
4037975f:	3289      	s32i.n	a8, a2, 12
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
40379761:	32b8      	l32i.n	a11, a2, 12
40379763:	eb6781        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40379766:	0008e0        	callx8	a8
    }
}
40379769:	f01d      	retw.n
	...

4037976c <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
4037976c:	006136        	entry	a1, 48
4037976f:	0129      	s32i.n	a2, a1, 0
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
40379771:	122272        	l32i	a7, a2, 72
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
40379774:	d7cc      	bnez.n	a7, 40379785 <prvNotifyQueueSetContainer+0x19>
40379776:	ecd8d1        	l32r	a13, 40374ad8 <_iram_text_start+0x6d4> (3c022f98 <_flash_rodata_start+0x2e78>)
40379779:	ecd8c1        	l32r	a12, 40374adc <_iram_text_start+0x6d8> (3c026ffc <__func__$13>)
4037977c:	ecd9b1        	l32r	a11, 40374ae0 <_iram_text_start+0x6dc> (d21 <UserFrameTotalSize+0xc21>)
4037977f:	ecd9a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379782:	065a65        	call8	4037fd28 <__assert_func>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
40379785:	0020c0        	memw
40379788:	e798      	l32i.n	a9, a7, 56
4037978a:	f788      	l32i.n	a8, a7, 60
4037978c:	113987        	bltu	a9, a8, 403797a1 <prvNotifyQueueSetContainer+0x35>
4037978f:	ecd6d1        	l32r	a13, 40374ae8 <_iram_text_start+0x6e4> (3c022fe0 <_flash_rodata_start+0x2ec0>)
40379792:	ecd2c1        	l32r	a12, 40374adc <_iram_text_start+0x6d8> (3c026ffc <__func__$13>)
40379795:	ecd5b1        	l32r	a11, 40374aec <_iram_text_start+0x6e8> (d22 <UserFrameTotalSize+0xc22>)
40379798:	ecd3a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
4037979b:	201110        	or	a1, a1, a1
4037979e:	0658a5        	call8	4037fd28 <__assert_func>

        /* In SMP, queue sets have their own xQueueLock. Thus we need to also
         * acquire the queue set's xQueueLock before accessing it. */
        prvENTER_CRITICAL_SAFE_SMP_ONLY( &( pxQueueSetContainer->xQueueLock ) );
403797a1:	4cc762        	addi	a6, a7, 76
    #define prvEXIT_CRITICAL_SAFE_SMP_ONLY( pxLock )     prvTaskExitCriticalSafeSMPOnly( pxLock )

    static inline __attribute__( ( always_inline ) )
    void prvTaskEnterCriticalSafeSMPOnly( portMUX_TYPE * pxLock )
    {
        if( portCHECK_IF_IN_ISR() == pdFALSE )
403797a4:	0084a5        	call8	40379ff0 <xPortInIsrContext>
403797a7:	bacc      	bnez.n	a10, 403797b6 <prvNotifyQueueSetContainer+0x4a>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403797a9:	ffafb2        	movi	a11, -1
403797ac:	06ad      	mov.n	a10, a6
403797ae:	008665        	call8	4037a014 <xPortEnterCriticalTimeout>
}
403797b1:	000246        	j	403797be <prvNotifyQueueSetContainer+0x52>
403797b4:	b20000        	mulsh	a0, a0, a0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403797b7:	06adffaf 	ee.vmulas.s16.accx.ld.ip.qup	q5, a10, 0x1f0, q7, q7, q2, q5
403797bb:	0085a5        	call8	4037a014 <xPortEnterCriticalTimeout>
        {
            if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
403797be:	0020c0        	memw
403797c1:	e798      	l32i.n	a9, a7, 56
403797c3:	f788      	l32i.n	a8, a7, 60
403797c5:	1cb987        	bgeu	a9, a8, 403797e5 <prvNotifyQueueSetContainer+0x79>
                #endif /* queueUSE_LOCKS == 1 */

                traceQUEUE_SET_SEND( pxQueueSetContainer );

                /* The data copied is the handle of the queue that contains data. */
                xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
403797c8:	0c0c      	movi.n	a12, 0
403797ca:	01bd      	mov.n	a11, a1
403797cc:	07ad      	mov.n	a10, a7
403797ce:	ffeea5        	call8	403796b8 <prvCopyDataToQueue>
403797d1:	0a2d      	mov.n	a2, a10

                if( cTxLock == queueUNLOCKED )
                {
                    if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
403797d3:	0020c0        	memw
403797d6:	9788      	l32i.n	a8, a7, 36
403797d8:	189c      	beqz.n	a8, 403797ed <prvNotifyQueueSetContainer+0x81>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
403797da:	24c7a2        	addi	a10, a7, 36
403797dd:	01cca5        	call8	4037b4a8 <xTaskRemoveFromEventList>
403797e0:	6acc      	bnez.n	a10, 403797ea <prvNotifyQueueSetContainer+0x7e>
403797e2:	0001c6        	j	403797ed <prvNotifyQueueSetContainer+0x81>
        BaseType_t xReturn = pdFALSE;
403797e5:	020c      	movi.n	a2, 0
403797e7:	000086        	j	403797ed <prvNotifyQueueSetContainer+0x81>
                        {
                            /* The task waiting has a higher priority. */
                            xReturn = pdTRUE;
403797ea:	01a022        	movi	a2, 1
    }

    static inline __attribute__( ( always_inline ) )
    void prvTaskExitCriticalSafeSMPOnly( portMUX_TYPE * pxLock )
    {
        if( portCHECK_IF_IN_ISR() == pdFALSE )
403797ed:	008025        	call8	40379ff0 <xPortInIsrContext>
403797f0:	008a56        	bnez	a10, 403797fc <prvNotifyQueueSetContainer+0x90>
        {
            taskEXIT_CRITICAL( pxLock );
403797f3:	06ad      	mov.n	a10, a6
403797f5:	0096e5        	call8	4037a164 <vPortExitCritical>
403797f8:	000146        	j	40379801 <prvNotifyQueueSetContainer+0x95>
403797fb:	06ad00        	ee.ldf.64.xp	f10, f0, a0, a13
        {
            #ifdef __clang_analyzer__
                /* Teach clang-tidy that ISR version macro can be different */
                configASSERT( 1 );
            #endif
            taskEXIT_CRITICAL_ISR( pxLock );
403797fe:	009665        	call8	4037a164 <vPortExitCritical>
        }
        /* Release the previously acquired queue set's xQueueLock. */
        prvEXIT_CRITICAL_SAFE_SMP_ONLY( &( pxQueueSetContainer->xQueueLock ) );

        return xReturn;
    }
40379801:	f01d      	retw.n
	...

40379804 <xQueueGenericReset>:
{
40379804:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379807:	00e256        	bnez	a2, 40379819 <xQueueGenericReset+0x15>
4037980a:	ecb9d1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec> (3c023028 <_flash_rodata_start+0x2f08>)
4037980d:	ecb9c1        	l32r	a12, 40374af4 <_iram_text_start+0x6f0> (3c0270c0 <__func__$25>)
40379810:	4da1b2        	movi	a11, 0x14d
40379813:	ecb4a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379816:	065125        	call8	4037fd28 <__assert_func>
    if( xNewQueue == pdTRUE )
40379819:	101366        	bnei	a3, 1, 4037982d <xQueueGenericReset+0x29>
 */
static inline void __attribute__((always_inline)) spinlock_initialize(spinlock_t *lock)
{
    assert(lock);
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    lock->owner = SPINLOCK_FREE;
4037981c:	ecb781        	l32r	a8, 40374af8 <_iram_text_start+0x6f4> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037981f:	136282        	s32i	a8, a2, 76
    lock->count = 0;
40379822:	080c      	movi.n	a8, 0
40379824:	146282        	s32i	a8, a2, 80
    if( ( pxQueue != NULL ) &&
40379827:	000146        	j	40379830 <xQueueGenericReset+0x2c>
4037982a:	000000        	ill
4037982d:	06c216        	beqz	a2, 4037989d <xQueueGenericReset+0x99>
        ( pxQueue->uxLength >= 1U ) &&
40379830:	f288      	l32i.n	a8, a2, 60
    if( ( pxQueue != NULL ) &&
40379832:	067816        	beqz	a8, 4037989d <xQueueGenericReset+0x99>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
40379835:	1022a2        	l32i	a10, a2, 64
40379838:	090c      	movi.n	a9, 0
4037983a:	a288a0        	muluh	a8, a8, a10
4037983d:	088c      	beqz.n	a8, 40379841 <xQueueGenericReset+0x3d>
4037983f:	190c      	movi.n	a9, 1
        ( pxQueue->uxLength >= 1U ) &&
40379841:	058956        	bnez	a9, 4037989d <xQueueGenericReset+0x99>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379844:	4cc272        	addi	a7, a2, 76
40379847:	fb7c      	movi.n	a11, -1
40379849:	07ad      	mov.n	a10, a7
4037984b:	007ca5        	call8	4037a014 <xPortEnterCriticalTimeout>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037984e:	0288      	l32i.n	a8, a2, 0
40379850:	f2a8      	l32i.n	a10, a2, 60
40379852:	102292        	l32i	a9, a2, 64
40379855:	82ba90        	mull	a11, a10, a9
40379858:	b8ba      	add.n	a11, a8, a11
4037985a:	22b9      	s32i.n	a11, a2, 8
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
4037985c:	0b0c      	movi.n	a11, 0
4037985e:	0020c0        	memw
40379861:	e2b9      	s32i.n	a11, a2, 56
            pxQueue->pcWriteTo = pxQueue->pcHead;
40379863:	1289      	s32i.n	a8, a2, 4
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
40379865:	aa0b      	addi.n	a10, a10, -1
40379867:	8299a0        	mull	a9, a9, a10
4037986a:	889a      	add.n	a8, a8, a9
4037986c:	3289      	s32i.n	a8, a2, 12
            if( xNewQueue == pdFALSE )
4037986e:	a3dc      	bnez.n	a3, 4037988c <xQueueGenericReset+0x88>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379870:	0020c0        	memw
40379873:	4288      	l32i.n	a8, a2, 16
40379875:	033816        	beqz	a8, 403798ac <xQueueGenericReset+0xa8>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379878:	10c2a2        	addi	a10, a2, 16
4037987b:	01c2e5        	call8	4037b4a8 <xTaskRemoveFromEventList>
4037987e:	aaac      	beqz.n	a10, 403798ac <xQueueGenericReset+0xa8>
    asm volatile (
40379880:	03eba0        	rsr.prid	a10
40379883:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
40379886:	fe3ce5        	call8	40377c54 <esp_crosscore_int_send_yield>
40379889:	0007c6        	j	403798ac <xQueueGenericReset+0xa8>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
4037988c:	10c2a2        	addi	a10, a2, 16
4037988f:	00f225        	call8	4037a7b0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
40379892:	24c2a2        	addi	a10, a2, 36
40379895:	00f1a5        	call8	4037a7b0 <vListInitialise>
40379898:	000406        	j	403798ac <xQueueGenericReset+0xa8>
4037989b:	d10000        	mul16s	a0, a0, a0
    configASSERT( xReturn != pdFAIL );
4037989e:	c1ec97        	bbsi	a12, 9, 40379863 <xQueueGenericReset+0x5f>
403798a1:	b2ec95        	call4	4032c76c <rom_rx_gain_force+0x326340>
403798a4:	a18ba1        	l32r	a10, 40361ed0 <rom_rx_gain_force+0x35baa4>
403798a7:	47e5ec8f 	ee.vmulas.u16.accx.ld.ip.qup	q6, a8, 0x1c0, q7, q5, q6, q5
403798ab:	a77006        	j	4036366f <rom_rx_gain_force+0x35d243>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
403798ae:	8b6520        	moveqz.s	f6, f5, a2
403798b1:	a02200        	addx4	a2, a2, a0
}
403798b4:	f01d01        	l32r	a0, 40375928 <apb_backup_dma_lock+0xc> (6ea5fb16 <_rtc_reserved_end+0xe95fb16>)
	...

403798b8 <prvInitialiseNewQueue>:
{
403798b8:	004136        	entry	a1, 32
    if( uxItemSize == ( UBaseType_t ) 0 )
403798bb:	33cc      	bnez.n	a3, 403798c2 <prvInitialiseNewQueue+0xa>
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
403798bd:	0669      	s32i.n	a6, a6, 0
403798bf:	000046        	j	403798c4 <prvInitialiseNewQueue+0xc>
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
403798c2:	0649      	s32i.n	a4, a6, 0
    pxNewQueue->uxLength = uxQueueLength;
403798c4:	f629      	s32i.n	a2, a6, 60
    pxNewQueue->uxItemSize = uxItemSize;
403798c6:	106632        	s32i	a3, a6, 64
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
403798c9:	1b0c      	movi.n	a11, 1
403798cb:	06ad      	mov.n	a10, a6
403798cd:	fff365        	call8	40379804 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
403798d0:	080c      	movi.n	a8, 0
403798d2:	126682        	s32i	a8, a6, 72
}
403798d5:	f01d      	retw.n
	...

403798d8 <xQueueGenericCreateStatic>:
    {
403798d8:	006136        	entry	a1, 48
403798db:	02ad      	mov.n	a10, a2
403798dd:	03bd      	mov.n	a11, a3
403798df:	04cd      	mov.n	a12, a4
403798e1:	052d      	mov.n	a2, a5
403798e3:	74d060        	extui	a13, a6, 0, 8
        configASSERT( pxStaticQueue );
403798e6:	180c      	movi.n	a8, 1
403798e8:	838550        	moveqz	a8, a5, a5
403798eb:	d5cc      	bnez.n	a5, 403798fc <xQueueGenericCreateStatic+0x24>
403798ed:	ec84d1        	l32r	a13, 40374b00 <_iram_text_start+0x6fc> (3c023054 <_flash_rodata_start+0x2f34>)
403798f0:	ec85c1        	l32r	a12, 40374b04 <_iram_text_start+0x700> (3c027090 <__func__$23>)
403798f3:	9fa1b2        	movi	a11, 0x19f
403798f6:	ec7ba1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
403798f9:	0642e5        	call8	4037fd28 <__assert_func>
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
403798fc:	01a092        	movi	a9, 1
403798ff:	839aa0        	moveqz	a9, a10, a10
40379902:	400897        	bnone	a8, a9, 40379946 <xQueueGenericCreateStatic+0x6e>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
40379905:	40f480        	nsau	a8, a4
40379908:	418580        	srli	a8, a8, 5
4037990b:	190c      	movi.n	a9, 1
4037990d:	839330        	moveqz	a9, a3, a3
40379910:	208890        	or	a8, a8, a9
            ( pxStaticQueue != NULL ) &&
40379913:	f8ac      	beqz.n	a8, 40379946 <xQueueGenericCreateStatic+0x6e>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
40379915:	180c      	movi.n	a8, 1
40379917:	838440        	moveqz	a8, a4, a4
4037991a:	40f390        	nsau	a9, a3
4037991d:	419590        	srli	a9, a9, 5
40379920:	208890        	or	a8, a8, a9
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
40379923:	f89c      	beqz.n	a8, 40379946 <xQueueGenericCreateStatic+0x6e>
                volatile size_t xSize = sizeof( StaticQueue_t );
40379925:	485c      	movi.n	a8, 84
40379927:	0020c0        	memw
4037992a:	0189      	s32i.n	a8, a1, 0
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
4037992c:	0020c0        	memw
4037992f:	002182        	l32i	a8, a1, 0
40379932:	acc882        	addi	a8, a8, -84
40379935:	c89c      	beqz.n	a8, 40379955 <xQueueGenericCreateStatic+0x7d>
40379937:	ec74d1        	l32r	a13, 40374b08 <_iram_text_start+0x704> (3c023064 <_flash_rodata_start+0x2f44>)
4037993a:	ec72c1        	l32r	a12, 40374b04 <_iram_text_start+0x700> (3c027090 <__func__$23>)
4037993d:	b1a1b2        	movi	a11, 0x1b1
40379940:	ec69a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379943:	063e65        	call8	4037fd28 <__assert_func>
            configASSERT( pxNewQueue );
40379946:	ec71d1        	l32r	a13, 40374b0c <_iram_text_start+0x708> (3c023080 <_flash_rodata_start+0x2f60>)
40379949:	ec6ec1        	l32r	a12, 40374b04 <_iram_text_start+0x700> (3c027090 <__func__$23>)
4037994c:	c8a1b2        	movi	a11, 0x1c8
4037994f:	ec65a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379952:	063d65        	call8	4037fd28 <__assert_func>
                ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
40379955:	0020c0        	memw
40379958:	0188      	l32i.n	a8, a1, 0
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
4037995a:	180c      	movi.n	a8, 1
4037995c:	444582        	s8i	a8, a5, 68
            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
4037995f:	05ed      	mov.n	a14, a5
40379961:	fff565        	call8	403798b8 <prvInitialiseNewQueue>
    }
40379964:	f01d      	retw.n
	...

40379968 <xQueueGenericCreate>:
    {
40379968:	004136        	entry	a1, 32
4037996b:	027d      	mov.n	a7, a2
4037996d:	744040        	extui	a4, a4, 0, 8
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
40379970:	42bc      	beqz.n	a2, 403799a8 <xQueueGenericCreate+0x40>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
40379972:	080c      	movi.n	a8, 0
40379974:	a29230        	muluh	a9, a2, a3
40379977:	001916        	beqz	a9, 4037997c <xQueueGenericCreate+0x14>
4037997a:	180c      	movi.n	a8, 1
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
4037997c:	88ec      	bnez.n	a8, 403799a8 <xQueueGenericCreate+0x40>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
4037997e:	82a730        	mull	a10, a7, a3
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
40379981:	abaf82        	movi	a8, -85
40379984:	2038a7        	bltu	a8, a10, 403799a8 <xQueueGenericCreate+0x40>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
40379987:	54caa2        	addi	a10, a10, 84
4037998a:	00aee5        	call8	4037a478 <pvPortMalloc>
4037998d:	0a2d      	mov.n	a2, a10
            if( pxNewQueue != NULL )
4037998f:	7aac      	beqz.n	a10, 403799ba <xQueueGenericCreate+0x52>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
40379991:	080c      	movi.n	a8, 0
40379993:	444a82        	s8i	a8, a10, 68
                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
40379996:	0aed      	mov.n	a14, a10
40379998:	04dd      	mov.n	a13, a4
4037999a:	54cac2        	addi	a12, a10, 84
4037999d:	03bd      	mov.n	a11, a3
4037999f:	07ad      	mov.n	a10, a7
403799a1:	fff165        	call8	403798b8 <prvInitialiseNewQueue>
403799a4:	000486        	j	403799ba <xQueueGenericCreate+0x52>
403799a7:	59d100        	s32nb	a0, a1, 52
            configASSERT( pxNewQueue );
403799aa:	c1ec      	bnez.n	a1, 403799da <xQueueGetMutexHolder+0x1e>
403799ac:	ec59      	s32i.n	a5, a12, 56
403799ae:	3da2b2        	movi	a11, 0x23d
403799b1:	ec4ca1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
403799b4:	201110        	or	a1, a1, a1
403799b7:	063725        	call8	4037fd28 <__assert_func>
    }
403799ba:	f01d      	retw.n

403799bc <xQueueGetMutexHolder>:
    {
403799bc:	004136        	entry	a1, 32
        configASSERT( xSemaphore );
403799bf:	00e256        	bnez	a2, 403799d1 <xQueueGetMutexHolder+0x15>
403799c2:	ec54d1        	l32r	a13, 40374b14 <_iram_text_start+0x710> (3c02308c <_flash_rodata_start+0x2f6c>)
403799c5:	ec54c1        	l32r	a12, 40374b18 <_iram_text_start+0x714> (3c027064 <__func__$20>)
403799c8:	c2a2b2        	movi	a11, 0x2c2
403799cb:	ec46a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
403799ce:	0635a5        	call8	4037fd28 <__assert_func>
        taskENTER_CRITICAL( &( pxSemaphore->xQueueLock ) );
403799d1:	4cc272        	addi	a7, a2, 76
403799d4:	fb7c      	movi.n	a11, -1
403799d6:	20a770        	or	a10, a7, a7
403799d9:	0063a5        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
403799dc:	002282        	l32i	a8, a2, 0
403799df:	38cc      	bnez.n	a8, 403799e6 <xQueueGetMutexHolder+0x2a>
                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
403799e1:	2228      	l32i.n	a2, a2, 8
403799e3:	000086        	j	403799e9 <xQueueGetMutexHolder+0x2d>
                pxReturn = NULL;
403799e6:	00a022        	movi	a2, 0
        taskEXIT_CRITICAL( &( pxSemaphore->xQueueLock ) );
403799e9:	20a770        	or	a10, a7, a7
403799ec:	007765        	call8	4037a164 <vPortExitCritical>
    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
403799ef:	000090        	retw
	...

403799f4 <xQueueGenericSend>:
{
403799f4:	008136        	entry	a1, 64
403799f7:	4149      	s32i.n	a4, a1, 16
    configASSERT( pxQueue );
403799f9:	02dc      	bnez.n	a2, 40379a0d <xQueueGenericSend+0x19>
403799fb:	ec3dd1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec> (3c023028 <_flash_rodata_start+0x2f08>)
403799fe:	ec47c1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c027018 <__func__$14>)
40379a01:	a8a3b2        	movi	a11, 0x3a8
40379a04:	ec38a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379a07:	201110        	or	a1, a1, a1
40379a0a:	0631e5        	call8	4037fd28 <__assert_func>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
40379a0d:	014356        	bnez	a3, 40379a25 <xQueueGenericSend+0x31>
40379a10:	102282        	l32i	a8, a2, 64
40379a13:	00e816        	beqz	a8, 40379a25 <xQueueGenericSend+0x31>
40379a16:	ec42d1        	l32r	a13, 40374b20 <_iram_text_start+0x71c> (3c023098 <_flash_rodata_start+0x2f78>)
40379a19:	ec40c1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c027018 <__func__$14>)
40379a1c:	a9a3b2        	movi	a11, 0x3a9
40379a1f:	ec31a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379a22:	063065        	call8	4037fd28 <__assert_func>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
40379a25:	132566        	bnei	a5, 2, 40379a3c <xQueueGenericSend+0x48>
40379a28:	f288      	l32i.n	a8, a2, 60
40379a2a:	0e1826        	beqi	a8, 1, 40379a3c <xQueueGenericSend+0x48>
40379a2d:	ec3dd1        	l32r	a13, 40374b24 <_iram_text_start+0x720> (3c0230f0 <_flash_rodata_start+0x2fd0>)
40379a30:	ec3bc1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c027018 <__func__$14>)
40379a33:	aaa3b2        	movi	a11, 0x3aa
40379a36:	ec2ba1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379a39:	062ee5        	call8	4037fd28 <__assert_func>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
40379a3c:	01ef65        	call8	4037b934 <xTaskGetSchedulerState>
40379a3f:	160c      	movi.n	a6, 1
40379a41:	836aa0        	moveqz	a6, a10, a10
40379a44:	2adc      	bnez.n	a10, 40379a5a <xQueueGenericSend+0x66>
40379a46:	4188      	l32i.n	a8, a1, 16
40379a48:	010816        	beqz	a8, 40379a5c <xQueueGenericSend+0x68>
40379a4b:	ec37d1        	l32r	a13, 40374b28 <_iram_text_start+0x724> (3c023140 <_flash_rodata_start+0x3020>)
40379a4e:	ec33c1        	l32r	a12, 40374b1c <_iram_text_start+0x718> (3c027018 <__func__$14>)
40379a51:	ada3b2        	movi	a11, 0x3ad
40379a54:	ec24a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379a57:	062d25        	call8	4037fd28 <__assert_func>
40379a5a:	060c      	movi.n	a6, 0
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379a5c:	4cc272        	addi	a7, a2, 76
40379a5f:	fb7c      	movi.n	a11, -1
40379a61:	07ad      	mov.n	a10, a7
40379a63:	005b25        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
40379a66:	0020c0        	memw
40379a69:	0e2292        	l32i	a9, a2, 56
40379a6c:	0f2282        	l32i	a8, a2, 60
40379a6f:	023987        	bltu	a9, a8, 40379a75 <xQueueGenericSend+0x81>
40379a72:	6e2566        	bnei	a5, 2, 40379ae4 <xQueueGenericSend+0xf0>
                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
40379a75:	0020c0        	memw
40379a78:	e268      	l32i.n	a6, a2, 56
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
40379a7a:	05cd      	mov.n	a12, a5
40379a7c:	03bd      	mov.n	a11, a3
40379a7e:	02ad      	mov.n	a10, a2
40379a80:	ffc365        	call8	403796b8 <prvCopyDataToQueue>
                    if( pxQueue->pxQueueSetContainer != NULL )
40379a83:	122282        	l32i	a8, a2, 72
40379a86:	38ac      	beqz.n	a8, 40379aad <xQueueGenericSend+0xb9>
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
40379a88:	fec552        	addi	a5, a5, -2
40379a8b:	40f550        	nsau	a5, a5
40379a8e:	415550        	srli	a5, a5, 5
40379a91:	01a082        	movi	a8, 1
40379a94:	838660        	moveqz	a8, a6, a6
40379a97:	3d8587        	bany	a5, a8, 40379ad8 <xQueueGenericSend+0xe4>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
40379a9a:	02ad      	mov.n	a10, a2
40379a9c:	ffcce5        	call8	4037976c <prvNotifyQueueSetContainer>
40379a9f:	5abc      	beqz.n	a10, 40379ad8 <xQueueGenericSend+0xe4>
40379aa1:	03eba0        	rsr.prid	a10
40379aa4:	04ada0        	extui	a10, a10, 13, 1
                            queueYIELD_IF_USING_PREEMPTION();
40379aa7:	fe1ae5        	call8	40377c54 <esp_crosscore_int_send_yield>
40379aaa:	000a86        	j	40379ad8 <xQueueGenericSend+0xe4>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
40379aad:	0020c0        	memw
40379ab0:	092282        	l32i	a8, a2, 36
40379ab3:	015816        	beqz	a8, 40379acc <xQueueGenericSend+0xd8>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
40379ab6:	24c2a2        	addi	a10, a2, 36
40379ab9:	019ee5        	call8	4037b4a8 <xTaskRemoveFromEventList>
40379abc:	018a16        	beqz	a10, 40379ad8 <xQueueGenericSend+0xe4>
40379abf:	03eba0        	rsr.prid	a10
40379ac2:	04ada0        	extui	a10, a10, 13, 1
                                queueYIELD_IF_USING_PREEMPTION();
40379ac5:	fe18e5        	call8	40377c54 <esp_crosscore_int_send_yield>
40379ac8:	000306        	j	40379ad8 <xQueueGenericSend+0xe4>
40379acb:	8a1600        	round.s	a1, f6, 0
                        else if( xYieldRequired != pdFALSE )
40379ace:	00          	.byte	00
40379acf:	03eba0        	rsr.prid	a10
40379ad2:	04ada0        	extui	a10, a10, 13, 1
                            queueYIELD_IF_USING_PREEMPTION();
40379ad5:	fe17e5        	call8	40377c54 <esp_crosscore_int_send_yield>
                taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379ad8:	20a770        	or	a10, a7, a7
40379adb:	0068a5        	call8	4037a164 <vPortExitCritical>
                return pdPASS;
40379ade:	120c      	movi.n	a2, 1
40379ae0:	001246        	j	40379b2d <xQueueGenericSend+0x139>
40379ae3:	218200        	srai	a8, a0, 2
                if( xTicksToWait == ( TickType_t ) 0 )
40379ae6:	b85604        	ee.vld.h.64.ip	q6, a0, 0x2b0
40379ae9:	a77000        	ee.stf.64.xp	f7, f10, a0, a0
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379aec:	676520        	ee.stf.64.xp	f6, f6, a2, a5
40379aef:	020c00        	andb	b0, b12, b0
                    return errQUEUE_FULL;
40379af2:	000dc6        	j	40379b2d <xQueueGenericSend+0x139>
40379af5:	765600        	ee.ldf.64.xp	f5, f7, a0, a6
                else if( xEntryTimeSet == pdFALSE )
40379af8:	01ad00        	slli	a10, a13, 32
                    vTaskInternalSetTimeOutState( &xTimeOut );
40379afb:	01baa5        	call8	4037b6a4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
40379afe:	01a062        	movi	a6, 1
                if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
40379b01:	10c1b2        	addi	a11, a1, 16
40379b04:	01ad      	mov.n	a10, a1
40379b06:	01bba5        	call8	4037b6c0 <xTaskCheckForTimeOut>
40379b09:	7adc      	bnez.n	a10, 40379b24 <xQueueGenericSend+0x130>
                    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
40379b0b:	41b8      	l32i.n	a11, a1, 16
40379b0d:	10c2a2        	addi	a10, a2, 16
40379b10:	0194e5        	call8	4037b460 <vTaskPlaceOnEventList>
40379b13:	03eba0        	rsr.prid	a10
40379b16:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
40379b19:	fe13a5        	call8	40377c54 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379b1c:	07ad      	mov.n	a10, a7
40379b1e:	006465        	call8	4037a164 <vPortExitCritical>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379b21:	ffcdc6        	j	40379a5c <xQueueGenericSend+0x68>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379b24:	20a770        	or	a10, a7, a7
40379b27:	0063e5        	call8	4037a164 <vPortExitCritical>
                    return errQUEUE_FULL;
40379b2a:	00a022        	movi	a2, 0
}
40379b2d:	000090        	retw

40379b30 <prvInitialiseMutex>:
    {
40379b30:	004136        	entry	a1, 32
40379b33:	20a220        	or	a10, a2, a2
        if( pxNewQueue != NULL )
40379b36:	030216        	beqz	a2, 40379b6a <prvInitialiseMutex+0x3a>
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
40379b39:	00a082        	movi	a8, 0
40379b3c:	2289      	s32i.n	a8, a2, 8
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
40379b3e:	0289      	s32i.n	a8, a2, 0
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
40379b40:	3289      	s32i.n	a8, a2, 12
            portMUX_INITIALIZE( &( pxNewQueue->xQueueLock ) );
40379b42:	4cc282        	addi	a8, a2, 76
    assert(lock);
40379b45:	c8cc      	bnez.n	a8, 40379b55 <prvInitialiseMutex+0x25>
40379b47:	ebf9d1        	l32r	a13, 40374b2c <_iram_text_start+0x728> (3c0216a8 <_flash_rodata_start+0x1588>)
40379b4a:	ebf9c1        	l32r	a12, 40374b30 <_iram_text_start+0x72c> (3c0270ac <__func__$24>)
40379b4d:	5b3c      	movi.n	a11, 53
40379b4f:	ebf9a1        	l32r	a10, 40374b34 <_iram_text_start+0x730> (3c0216d8 <_flash_rodata_start+0x15b8>)
40379b52:	061d65        	call8	4037fd28 <__assert_func>
    lock->owner = SPINLOCK_FREE;
40379b55:	ebe881        	l32r	a8, 40374af8 <_iram_text_start+0x6f4> (b33fffff <_rtc_reserved_end+0x532fffff>)
40379b58:	136282        	s32i	a8, a2, 76
    lock->count = 0;
40379b5b:	00a0b2        	movi	a11, 0
40379b5e:	1462b2        	s32i	a11, a2, 80
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
40379b61:	20dbb0        	or	a13, a11, a11
40379b64:	20cbb0        	or	a12, a11, a11
40379b67:	ffe8e5        	call8	403799f4 <xQueueGenericSend>
    }
40379b6a:	f01d      	retw.n

40379b6c <xQueueCreateMutex>:
    {
40379b6c:	004136        	entry	a1, 32
        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
40379b6f:	74c020        	extui	a12, a2, 0, 8
40379b72:	00a0b2        	movi	a11, 0
40379b75:	01a0a2        	movi	a10, 1
40379b78:	ffdee5        	call8	40379968 <xQueueGenericCreate>
40379b7b:	0a2d      	mov.n	a2, a10
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
40379b7d:	fffb25        	call8	40379b30 <prvInitialiseMutex>
    }
40379b80:	f01d      	retw.n
	...

40379b84 <xQueueCreateMutexStatic>:
    {
40379b84:	004136        	entry	a1, 32
40379b87:	20d330        	or	a13, a3, a3
        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
40379b8a:	74e020        	extui	a14, a2, 0, 8
40379b8d:	00a0c2        	movi	a12, 0
40379b90:	0cbd      	mov.n	a11, a12
40379b92:	1a0c      	movi.n	a10, 1
40379b94:	ffd425        	call8	403798d8 <xQueueGenericCreateStatic>
40379b97:	0a2d      	mov.n	a2, a10
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
40379b99:	fff965        	call8	40379b30 <prvInitialiseMutex>
    }
40379b9c:	f01d      	retw.n
	...

40379ba0 <xQueueGiveMutexRecursive>:
    {
40379ba0:	004136        	entry	a1, 32
        configASSERT( pxMutex );
40379ba3:	00e256        	bnez	a2, 40379bb5 <xQueueGiveMutexRecursive+0x15>
40379ba6:	ebe4d1        	l32r	a13, 40374b38 <_iram_text_start+0x734> (3c023194 <_flash_rodata_start+0x3074>)
40379ba9:	ebe4c1        	l32r	a12, 40374b3c <_iram_text_start+0x738> (3c027048 <__func__$18>)
40379bac:	fda2b2        	movi	a11, 0x2fd
40379baf:	ebcda1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379bb2:	061765        	call8	4037fd28 <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
40379bb5:	2278      	l32i.n	a7, a2, 8
40379bb7:	01bc25        	call8	4037b778 <xTaskGetCurrentTaskHandle>
40379bba:	1897a7        	bne	a7, a10, 40379bd6 <xQueueGiveMutexRecursive+0x36>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
40379bbd:	032282        	l32i	a8, a2, 12
40379bc0:	880b      	addi.n	a8, a8, -1
40379bc2:	3289      	s32i.n	a8, a2, 12
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
40379bc4:	38dc      	bnez.n	a8, 40379bdb <xQueueGiveMutexRecursive+0x3b>
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
40379bc6:	0d0c      	movi.n	a13, 0
40379bc8:	0dcd      	mov.n	a12, a13
40379bca:	0dbd      	mov.n	a11, a13
40379bcc:	02ad      	mov.n	a10, a2
40379bce:	ffe265        	call8	403799f4 <xQueueGenericSend>
            xReturn = pdPASS;
40379bd1:	120c      	movi.n	a2, 1
40379bd3:	000186        	j	40379bdd <xQueueGiveMutexRecursive+0x3d>
            xReturn = pdFAIL;
40379bd6:	020c      	movi.n	a2, 0
40379bd8:	000046        	j	40379bdd <xQueueGiveMutexRecursive+0x3d>
            xReturn = pdPASS;
40379bdb:	120c      	movi.n	a2, 1
    }
40379bdd:	f01d      	retw.n
	...

40379be0 <xQueueGiveFromISR>:
{
40379be0:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379be3:	00e256        	bnez	a2, 40379bf5 <xQueueGiveFromISR+0x15>
40379be6:	ebc2d1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec> (3c023028 <_flash_rodata_start+0x2f08>)
40379be9:	ebd5c1        	l32r	a12, 40374b40 <_iram_text_start+0x73c> (3c026fe8 <__func__$11>)
40379bec:	4ea5b2        	movi	a11, 0x54e
40379bef:	ebbda1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379bf2:	061365        	call8	4037fd28 <__assert_func>
    configASSERT( pxQueue->uxItemSize == 0 );
40379bf5:	102282        	l32i	a8, a2, 64
40379bf8:	011816        	beqz	a8, 40379c0d <xQueueGiveFromISR+0x2d>
40379bfb:	ebd2d1        	l32r	a13, 40374b44 <_iram_text_start+0x740> (3c02319c <_flash_rodata_start+0x307c>)
40379bfe:	ebd0c1        	l32r	a12, 40374b40 <_iram_text_start+0x73c> (3c026fe8 <__func__$11>)
40379c01:	52a5b2        	movi	a11, 0x552
40379c04:	ebb8a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379c07:	201110        	or	a1, a1, a1
40379c0a:	0611e5        	call8	4037fd28 <__assert_func>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
40379c0d:	0288      	l32i.n	a8, a2, 0
40379c0f:	016856        	bnez	a8, 40379c29 <xQueueGiveFromISR+0x49>
40379c12:	2288      	l32i.n	a8, a2, 8
40379c14:	011816        	beqz	a8, 40379c29 <xQueueGiveFromISR+0x49>
40379c17:	ebccd1        	l32r	a13, 40374b48 <_iram_text_start+0x744> (3c0231b8 <_flash_rodata_start+0x3098>)
40379c1a:	ebc9c1        	l32r	a12, 40374b40 <_iram_text_start+0x73c> (3c026fe8 <__func__$11>)
40379c1d:	57a5b2        	movi	a11, 0x557
40379c20:	ebb1a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379c23:	201110        	or	a1, a1, a1
40379c26:	061025        	call8	4037fd28 <__assert_func>
    prvENTER_CRITICAL_OR_MASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379c29:	4cc272        	addi	a7, a2, 76
40379c2c:	fb7c      	movi.n	a11, -1
40379c2e:	20a770        	or	a10, a7, a7
40379c31:	003e25        	call8	4037a014 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
40379c34:	0020c0        	memw
40379c37:	e288      	l32i.n	a8, a2, 56
        if( uxMessagesWaiting < pxQueue->uxLength )
40379c39:	f298      	l32i.n	a9, a2, 60
40379c3b:	35b897        	bgeu	a8, a9, 40379c74 <xQueueGiveFromISR+0x94>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
40379c3e:	881b      	addi.n	a8, a8, 1
40379c40:	0020c0        	memw
40379c43:	e289      	s32i.n	a8, a2, 56
                    if( pxQueue->pxQueueSetContainer != NULL )
40379c45:	122282        	l32i	a8, a2, 72
40379c48:	f88c      	beqz.n	a8, 40379c5b <xQueueGiveFromISR+0x7b>
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
40379c4a:	20a220        	or	a10, a2, a2
40379c4d:	ffb1e5        	call8	4037976c <prvNotifyQueueSetContainer>
40379c50:	5aac      	beqz.n	a10, 40379c79 <xQueueGiveFromISR+0x99>
                            if( pxHigherPriorityTaskWoken != NULL )
40379c52:	83ac      	beqz.n	a3, 40379c7e <xQueueGiveFromISR+0x9e>
                                *pxHigherPriorityTaskWoken = pdTRUE;
40379c54:	120c      	movi.n	a2, 1
40379c56:	0329      	s32i.n	a2, a3, 0
40379c58:	000d46        	j	40379c91 <xQueueGiveFromISR+0xb1>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
40379c5b:	0020c0        	memw
40379c5e:	9288      	l32i.n	a8, a2, 36
40379c60:	08ac      	beqz.n	a8, 40379c84 <xQueueGiveFromISR+0xa4>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
40379c62:	24c2a2        	addi	a10, a2, 36
40379c65:	018425        	call8	4037b4a8 <xTaskRemoveFromEventList>
40379c68:	da9c      	beqz.n	a10, 40379c89 <xQueueGiveFromISR+0xa9>
                                if( pxHigherPriorityTaskWoken != NULL )
40379c6a:	03ac      	beqz.n	a3, 40379c8e <xQueueGiveFromISR+0xae>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
40379c6c:	120c      	movi.n	a2, 1
40379c6e:	0329      	s32i.n	a2, a3, 0
40379c70:	000746        	j	40379c91 <xQueueGiveFromISR+0xb1>
40379c73:	020c00        	andb	b0, b12, b0
            xReturn = errQUEUE_FULL;
40379c76:	0005c6        	j	40379c91 <xQueueGiveFromISR+0xb1>
            xReturn = pdPASS;
40379c79:	120c      	movi.n	a2, 1
40379c7b:	000486        	j	40379c91 <xQueueGiveFromISR+0xb1>
40379c7e:	120c      	movi.n	a2, 1
40379c80:	000346        	j	40379c91 <xQueueGiveFromISR+0xb1>
40379c83:	120c00        	andbc	b0, b12, b0
40379c86:	0001c6        	j	40379c91 <xQueueGiveFromISR+0xb1>
40379c89:	120c      	movi.n	a2, 1
40379c8b:	000086        	j	40379c91 <xQueueGiveFromISR+0xb1>
40379c8e:	01a022        	movi	a2, 1
    prvEXIT_CRITICAL_OR_UNMASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379c91:	20a770        	or	a10, a7, a7
40379c94:	004ce5        	call8	4037a164 <vPortExitCritical>
}
40379c97:	000090        	retw
	...

40379c9c <xQueueSemaphoreTake>:
{
40379c9c:	008136        	entry	a1, 64
40379c9f:	4139      	s32i.n	a3, a1, 16
    configASSERT( ( pxQueue ) );
40379ca1:	02dc      	bnez.n	a2, 40379cb5 <xQueueSemaphoreTake+0x19>
40379ca3:	ebaad1        	l32r	a13, 40374b4c <_iram_text_start+0x748> (3c02321c <_flash_rodata_start+0x30fc>)
40379ca6:	ebaac1        	l32r	a12, 40374b50 <_iram_text_start+0x74c> (3c026fd4 <__func__$9>)
40379ca9:	ada6b2        	movi	a11, 0x6ad
40379cac:	eb8ea1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379caf:	201110        	or	a1, a1, a1
40379cb2:	060765        	call8	4037fd28 <__assert_func>
    configASSERT( pxQueue->uxItemSize == 0 );
40379cb5:	102282        	l32i	a8, a2, 64
40379cb8:	d88c      	beqz.n	a8, 40379cc9 <xQueueSemaphoreTake+0x2d>
40379cba:	eba2d1        	l32r	a13, 40374b44 <_iram_text_start+0x740> (3c02319c <_flash_rodata_start+0x307c>)
40379cbd:	eba4c1        	l32r	a12, 40374b50 <_iram_text_start+0x74c> (3c026fd4 <__func__$9>)
40379cc0:	b1a6b2        	movi	a11, 0x6b1
40379cc3:	eb88a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379cc6:	060625        	call8	4037fd28 <__assert_func>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
40379cc9:	01c6a5        	call8	4037b934 <xTaskGetSchedulerState>
40379ccc:	160c      	movi.n	a6, 1
40379cce:	836aa0        	moveqz	a6, a10, a10
40379cd1:	013a56        	bnez	a10, 40379ce8 <xQueueSemaphoreTake+0x4c>
40379cd4:	4188      	l32i.n	a8, a1, 16
40379cd6:	017816        	beqz	a8, 40379cf1 <xQueueSemaphoreTake+0x55>
40379cd9:	eb93d1        	l32r	a13, 40374b28 <_iram_text_start+0x724> (3c023140 <_flash_rodata_start+0x3020>)
40379cdc:	eb9dc1        	l32r	a12, 40374b50 <_iram_text_start+0x74c> (3c026fd4 <__func__$9>)
40379cdf:	b6a6b2        	movi	a11, 0x6b6
40379ce2:	eb80a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379ce5:	060425        	call8	4037fd28 <__assert_func>
40379ce8:	050c      	movi.n	a5, 0
40379cea:	056d      	mov.n	a6, a5
40379cec:	000106        	j	40379cf4 <xQueueSemaphoreTake+0x58>
40379cef:	600000        	neg	a0, a0
40379cf2:	722056        	bnez	a0, 4037a418 <_frxt_task_coproc_state+0x10>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379cf5:	b24cc2        	s8i	a12, a12, 178
40379cf8:	07adffaf 	ee.vmulas.s16.accx.ld.ip.qup	q7, a10, 0x1f0, q7, q7, q2, q5
40379cfc:	003165        	call8	4037a014 <xPortEnterCriticalTimeout>
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
40379cff:	0020c0        	memw
40379d02:	e288      	l32i.n	a8, a2, 56
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
40379d04:	48bc      	beqz.n	a8, 40379d3c <xQueueSemaphoreTake+0xa0>
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
40379d06:	880b      	addi.n	a8, a8, -1
40379d08:	0020c0        	memw
40379d0b:	e289      	s32i.n	a8, a2, 56
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
40379d0d:	002282        	l32i	a8, a2, 0
40379d10:	004856        	bnez	a8, 40379d18 <xQueueSemaphoreTake+0x7c>
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
40379d13:	0226a5        	call8	4037bf7c <pvTaskIncrementMutexHeldCount>
40379d16:	22a9      	s32i.n	a10, a2, 8
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379d18:	0020c0        	memw
40379d1b:	042282        	l32i	a8, a2, 16
40379d1e:	010816        	beqz	a8, 40379d32 <xQueueSemaphoreTake+0x96>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379d21:	10c2a2        	addi	a10, a2, 16
40379d24:	017825        	call8	4037b4a8 <xTaskRemoveFromEventList>
40379d27:	7a8c      	beqz.n	a10, 40379d32 <xQueueSemaphoreTake+0x96>
40379d29:	03eba0        	rsr.prid	a10
40379d2c:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
40379d2f:	fdf265        	call8	40377c54 <esp_crosscore_int_send_yield>
                taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379d32:	07ad      	mov.n	a10, a7
40379d34:	0042e5        	call8	4037a164 <vPortExitCritical>
                return pdPASS;
40379d37:	120c      	movi.n	a2, 1
40379d39:	001946        	j	40379da2 <xQueueSemaphoreTake+0x106>
                if( xTicksToWait == ( TickType_t ) 0 )
40379d3c:	042182        	l32i	a8, a1, 16
40379d3f:	00b856        	bnez	a8, 40379d4e <xQueueSemaphoreTake+0xb2>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379d42:	20a770        	or	a10, a7, a7
40379d45:	0041e5        	call8	4037a164 <vPortExitCritical>
                    return errQUEUE_EMPTY;
40379d48:	020c      	movi.n	a2, 0
40379d4a:	001506        	j	40379da2 <xQueueSemaphoreTake+0x106>
40379d4d:	765600        	ee.ldf.64.xp	f5, f7, a0, a6
                else if( xEntryTimeSet == pdFALSE )
40379d50:	01ad00        	slli	a10, a13, 32
                    vTaskInternalSetTimeOutState( &xTimeOut );
40379d53:	019525        	call8	4037b6a4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
40379d56:	01a062        	movi	a6, 1
                if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
40379d59:	10c1b2        	addi	a11, a1, 16
40379d5c:	20a110        	or	a10, a1, a1
40379d5f:	019625        	call8	4037b6c0 <xTaskCheckForTimeOut>
40379d62:	026a56        	bnez	a10, 40379d8c <xQueueSemaphoreTake+0xf0>
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
40379d65:	0288      	l32i.n	a8, a2, 0
40379d67:	007856        	bnez	a8, 40379d72 <xQueueSemaphoreTake+0xd6>
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
40379d6a:	0222a2        	l32i	a10, a2, 8
40379d6d:	01f1e5        	call8	4037bc8c <xTaskPriorityInherit>
40379d70:	0a5d      	mov.n	a5, a10
                    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
40379d72:	0421b2        	l32i	a11, a1, 16
40379d75:	24c2a2        	addi	a10, a2, 36
40379d78:	016e65        	call8	4037b460 <vTaskPlaceOnEventList>
40379d7b:	03eba0        	rsr.prid	a10
40379d7e:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
40379d81:	fded25        	call8	40377c54 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379d84:	07ad      	mov.n	a10, a7
40379d86:	003de5        	call8	4037a164 <vPortExitCritical>
        taskENTER_CRITICAL( &( pxQueue->xQueueLock ) );
40379d89:	ffd9c6        	j	40379cf4 <xQueueSemaphoreTake+0x58>
                        if( xInheritanceOccurred != pdFALSE )
40379d8c:	00b516        	beqz	a5, 40379d9b <xQueueSemaphoreTake+0xff>
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
40379d8f:	02ad      	mov.n	a10, a2
40379d91:	009fe5        	call8	4037a790 <prvGetDisinheritPriorityAfterTimeout>
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
40379d94:	0abd      	mov.n	a11, a10
40379d96:	22a8      	l32i.n	a10, a2, 8
40379d98:	020ea5        	call8	4037be84 <vTaskPriorityDisinheritAfterTimeout>
                    taskEXIT_CRITICAL( &( pxQueue->xQueueLock ) );
40379d9b:	07ad      	mov.n	a10, a7
40379d9d:	003c65        	call8	4037a164 <vPortExitCritical>
                    return errQUEUE_EMPTY;
40379da0:	020c      	movi.n	a2, 0
}
40379da2:	f01d      	retw.n

40379da4 <xQueueTakeMutexRecursive>:
    {
40379da4:	004136        	entry	a1, 32
40379da7:	027d      	mov.n	a7, a2
        configASSERT( pxMutex );
40379da9:	d2cc      	bnez.n	a2, 40379dba <xQueueTakeMutexRecursive+0x16>
40379dab:	eb63d1        	l32r	a13, 40374b38 <_iram_text_start+0x734> (3c023194 <_flash_rodata_start+0x3074>)
40379dae:	eb69c1        	l32r	a12, 40374b54 <_iram_text_start+0x750> (3c02702c <__func__$17>)
40379db1:	35a3b2        	movi	a11, 0x335
40379db4:	eb4ca1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379db7:	05f725        	call8	4037fd28 <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
40379dba:	2228      	l32i.n	a2, a2, 8
40379dbc:	019ba5        	call8	4037b778 <xTaskGetCurrentTaskHandle>
40379dbf:	0d92a7        	bne	a2, a10, 40379dd0 <xQueueTakeMutexRecursive+0x2c>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
40379dc2:	032782        	l32i	a8, a7, 12
40379dc5:	01c882        	addi	a8, a8, 1
40379dc8:	3789      	s32i.n	a8, a7, 12
            xReturn = pdPASS;
40379dca:	120c      	movi.n	a2, 1
40379dcc:	000506        	j	40379de4 <xQueueTakeMutexRecursive+0x40>
40379dcf:	b33000        	movgez	a3, a0, a0
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
40379dd2:	a77020        	ee.stf.64.xp	f7, f10, a2, a0
40379dd5:	20          	.byte	0x20
40379dd6:	ffec65        	call8	40379c9c <xQueueSemaphoreTake>
40379dd9:	202aa0        	or	a2, a10, a10
            if( xReturn != pdFAIL )
40379ddc:	4a8c      	beqz.n	a10, 40379de4 <xQueueTakeMutexRecursive+0x40>
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
40379dde:	3788      	l32i.n	a8, a7, 12
40379de0:	881b      	addi.n	a8, a8, 1
40379de2:	3789      	s32i.n	a8, a7, 12
    }
40379de4:	f01d      	retw.n
	...

40379de8 <xQueueReceiveFromISR>:
{
40379de8:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379deb:	011256        	bnez	a2, 40379e00 <xQueueReceiveFromISR+0x18>
40379dee:	eb40d1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec> (3c023028 <_flash_rodata_start+0x2f08>)
40379df1:	eb59c1        	l32r	a12, 40374b58 <_iram_text_start+0x754> (3c026fbc <__func__$7>)
40379df4:	eb5ab1        	l32r	a11, 40374b5c <_iram_text_start+0x758> (86d <UserFrameTotalSize+0x76d>)
40379df7:	eb3ba1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379dfa:	201110        	or	a1, a1, a1
40379dfd:	05f2a5        	call8	4037fd28 <__assert_func>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
40379e00:	53dc      	bnez.n	a3, 40379e19 <xQueueReceiveFromISR+0x31>
40379e02:	102282        	l32i	a8, a2, 64
40379e05:	089c      	beqz.n	a8, 40379e19 <xQueueReceiveFromISR+0x31>
40379e07:	eb56d1        	l32r	a13, 40374b60 <_iram_text_start+0x75c> (3c023284 <_flash_rodata_start+0x3164>)
40379e0a:	eb53c1        	l32r	a12, 40374b58 <_iram_text_start+0x754> (3c026fbc <__func__$7>)
40379e0d:	eb55b1        	l32r	a11, 40374b64 <_iram_text_start+0x760> (86e <UserFrameTotalSize+0x76e>)
40379e10:	eb35a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379e13:	201110        	or	a1, a1, a1
40379e16:	05f125        	call8	4037fd28 <__assert_func>
    prvENTER_CRITICAL_OR_MASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379e19:	4cc262        	addi	a6, a2, 76
40379e1c:	ffafb2        	movi	a11, -1
40379e1f:	20a660        	or	a10, a6, a6
40379e22:	001f25        	call8	4037a014 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
40379e25:	0020c0        	memw
40379e28:	0e2272        	l32i	a7, a2, 56
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
40379e2b:	57ac      	beqz.n	a7, 40379e54 <xQueueReceiveFromISR+0x6c>
            prvCopyDataFromQueue( pxQueue, pvBuffer );
40379e2d:	03bd      	mov.n	a11, a3
40379e2f:	02ad      	mov.n	a10, a2
40379e31:	ff9165        	call8	40379748 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
40379e34:	770b      	addi.n	a7, a7, -1
40379e36:	0020c0        	memw
40379e39:	e279      	s32i.n	a7, a2, 56
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
40379e3b:	0020c0        	memw
40379e3e:	4288      	l32i.n	a8, a2, 16
40379e40:	589c      	beqz.n	a8, 40379e59 <xQueueReceiveFromISR+0x71>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
40379e42:	10c2a2        	addi	a10, a2, 16
40379e45:	016625        	call8	4037b4a8 <xTaskRemoveFromEventList>
40379e48:	2a9c      	beqz.n	a10, 40379e5e <xQueueReceiveFromISR+0x76>
                        if( pxHigherPriorityTaskWoken != NULL )
40379e4a:	649c      	beqz.n	a4, 40379e64 <xQueueReceiveFromISR+0x7c>
                            *pxHigherPriorityTaskWoken = pdTRUE;
40379e4c:	120c      	movi.n	a2, 1
40379e4e:	0429      	s32i.n	a2, a4, 0
40379e50:	0004c6        	j	40379e67 <xQueueReceiveFromISR+0x7f>
40379e53:	020c00        	andb	b0, b12, b0
            xReturn = pdFAIL;
40379e56:	000346        	j	40379e67 <xQueueReceiveFromISR+0x7f>
            xReturn = pdPASS;
40379e59:	120c      	movi.n	a2, 1
40379e5b:	000206        	j	40379e67 <xQueueReceiveFromISR+0x7f>
40379e5e:	120c      	movi.n	a2, 1
40379e60:	0000c6        	j	40379e67 <xQueueReceiveFromISR+0x7f>
40379e63:	a02200        	addx4	a2, a2, a0
40379e66:	a66001        	l32r	a0, 403637e8 <rom_rx_gain_force+0x35d3bc>
    prvEXIT_CRITICAL_OR_UNMASK_ISR( &( pxQueue->xQueueLock ), uxSavedInterruptStatus );
40379e69:	20          	.byte	0x20
40379e6a:	002fa5        	call8	4037a164 <vPortExitCritical>
}
40379e6d:	000090        	retw

40379e70 <vQueueDelete>:
{
40379e70:	004136        	entry	a1, 32
    configASSERT( pxQueue );
40379e73:	00e256        	bnez	a2, 40379e85 <vQueueDelete+0x15>
40379e76:	eb1ed1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec> (3c023028 <_flash_rodata_start+0x2f08>)
40379e79:	eb3bc1        	l32r	a12, 40374b68 <_iram_text_start+0x764> (3c026fac <__func__$2>)
40379e7c:	eb3cb1        	l32r	a11, 40374b6c <_iram_text_start+0x768> (933 <UserFrameTotalSize+0x833>)
40379e7f:	eb19a1        	l32r	a10, 40374ae4 <_iram_text_start+0x6e0> (3c022fd6 <_flash_rodata_start+0x2eb6>)
40379e82:	05ea65        	call8	4037fd28 <__assert_func>
        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
40379e85:	440282        	l8ui	a8, a2, 68
40379e88:	68cc      	bnez.n	a8, 40379e92 <vQueueDelete+0x22>
            vPortFree( pxQueue );
40379e8a:	02ad      	mov.n	a10, a2
40379e8c:	201110        	or	a1, a1, a1
40379e8f:	005fe5        	call8	4037a48c <vPortFree>
}
40379e92:	f01d      	retw.n

40379e94 <vPortTaskWrapper>:
{
40379e94:	004136        	entry	a1, 32
40379e97:	03ad      	mov.n	a10, a3
    pxCode(pvParameters);
40379e99:	0002e0        	callx8	a2
    char *pcTaskName = pcTaskGetName(NULL);
40379e9c:	0a0c      	movi.n	a10, 0
40379e9e:	01a725        	call8	4037b910 <pcTaskGetName>
40379ea1:	0a7d      	mov.n	a7, a10
    ESP_LOGE("FreeRTOS", "FreeRTOS Task \"%s\" should not return, Aborting now!", pcTaskName);
40379ea3:	05d625        	call8	4037fc04 <esp_log_timestamp>
40379ea6:	eb32b1        	l32r	a11, 40374b70 <_iram_text_start+0x76c> (3c023918 <_flash_rodata_start+0x37f8>)
40379ea9:	07fd      	mov.n	a15, a7
40379eab:	0bed      	mov.n	a14, a11
40379ead:	0add      	mov.n	a13, a10
40379eaf:	eb31c1        	l32r	a12, 40374b74 <_iram_text_start+0x770> (3c023924 <_flash_rodata_start+0x3804>)
40379eb2:	1a0c      	movi.n	a10, 1
40379eb4:	05c725        	call8	4037fb28 <esp_log>
    abort();
40379eb7:	05db65        	call8	4037fc6c <abort>
	...

40379ebc <vPortTLSPointersDelCb>:

// --------------------- TCB Cleanup -----------------------

#if ( CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS )
static void vPortTLSPointersDelCb( void *pxTCB )
{
40379ebc:	004136        	entry	a1, 32
     * pvDummy15 corresponds to pvThreadLocalStoragePointers member of the TCB.
     */
    StaticTask_t *tcb = ( StaticTask_t * )pxTCB;

    /* The TLSP deletion callbacks are stored at an offset of (configNUM_THREAD_LOCAL_STORAGE_POINTERS/2) */
    TlsDeleteCallbackFunction_t *pvThreadLocalStoragePointersDelCallback = ( TlsDeleteCallbackFunction_t * )( &( tcb->pvDummy15[ ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ) ] ) );
40379ebf:	58c252        	addi	a5, a2, 88

    /* We need to iterate over half the depth of the pvThreadLocalStoragePointers area
     * to access all TLS pointers and their respective TLS deletion callbacks.
     */
    for ( int x = 0; x < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ); x++ ) {
40379ec2:	070c      	movi.n	a7, 0
40379ec4:	0010c6        	j	40379f0b <vPortTLSPointersDelCb+0x4f>
40379ec7:	00          	.byte	00
40379ec8:	675000        	ee.stf.64.xp	f5, f6, a0, a0
        if ( pvThreadLocalStoragePointersDelCallback[ x ] != NULL ) {  //If del cb is set
40379ecb:	26a2a0        	ee.ldf.64.xp	f10, f2, a10, a2
40379ece:	6a1600        	maddn.s	f1, f6, f0
40379ed1:	03          	.byte	0x3
            /* In case the TLSP deletion callback has been overwritten by a TLS pointer, gracefully abort. */
            if ( !esp_ptr_executable( pvThreadLocalStoragePointersDelCallback[ x ] ) ) {
40379ed2:	fe0265        	call8	40377ef8 <esp_ptr_executable>
40379ed5:	1aec      	bnez.n	a10, 40379efa <vPortTLSPointersDelCb+0x3e>
40379ed7:	e96a81        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40379eda:	0888      	l32i.n	a8, a8, 0
                // We call EARLY log here as currently portCLEAN_UP_TCB() is called in a critical section
                ESP_EARLY_LOGE("FreeRTOS", "Fatal error: TLSP deletion callback at index %d overwritten with non-excutable pointer %p", x, pvThreadLocalStoragePointersDelCallback[ x ]);
40379edc:	014816        	beqz	a8, 40379ef4 <vPortTLSPointersDelCb+0x38>
40379edf:	05d265        	call8	4037fc04 <esp_log_timestamp>
40379ee2:	06e8      	l32i.n	a14, a6, 0
40379ee4:	07dd      	mov.n	a13, a7
40379ee6:	eb22c1        	l32r	a12, 40374b70 <_iram_text_start+0x76c> (3c023918 <_flash_rodata_start+0x37f8>)
40379ee9:	0abd      	mov.n	a11, a10
40379eeb:	eb23a1        	l32r	a10, 40374b78 <_iram_text_start+0x774> (3c023968 <_flash_rodata_start+0x3848>)
40379eee:	e97b81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40379ef1:	0008e0        	callx8	a8
                abort();
40379ef4:	201110        	or	a1, a1, a1
40379ef7:	05d765        	call8	4037fc6c <abort>
            }

            pvThreadLocalStoragePointersDelCallback[ x ]( x, tcb->pvDummy15[ x ] );   //Call del cb
40379efa:	0698      	l32i.n	a9, a6, 0
40379efc:	14c782        	addi	a8, a7, 20
40379eff:	a08820        	addx4	a8, a8, a2
40379f02:	18b8      	l32i.n	a11, a8, 4
40379f04:	07ad      	mov.n	a10, a7
40379f06:	0009e0        	callx8	a9
    for ( int x = 0; x < ( configNUM_THREAD_LOCAL_STORAGE_POINTERS / 2 ); x++ ) {
40379f09:	771b      	addi.n	a7, a7, 1
40379f0b:	ba17a6        	blti	a7, 1, 40379ec9 <vPortTLSPointersDelCb+0xd>
        }
    }
}
40379f0e:	f01d      	retw.n

40379f10 <vPortCleanUpCoprocArea>:
#endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */

#if ( XCHAL_CP_NUM > 0 )
static void vPortCleanUpCoprocArea(void *pvTCB)
{
40379f10:	004136        	entry	a1, 32
    UBaseType_t uxCoprocArea;
    BaseType_t xTargetCoreID;

    /* Get a pointer to the task's coprocessor save area */
    uxCoprocArea = ( UBaseType_t ) ( ( ( StaticTask_t * ) pvTCB )->pxDummy8 );  /* Get TCB_t.pxEndOfStack */
40379f13:	122282        	l32i	a8, a2, 72
    uxCoprocArea = STACKPTR_ALIGN_DOWN(16, uxCoprocArea - XT_CP_SIZE);
40379f16:	c4ae92        	movi	a9, 0xfffffec4
40379f19:	808890        	add	a8, a8, a9
        xTargetCoreID = 0;
    #endif /* configNUMBER_OF_CORES > 1 */

    /* If task has live floating point registers somewhere, release them */
    void _xt_coproc_release(volatile void *coproc_sa_base, BaseType_t xTargetCoreID);
    _xt_coproc_release( (void *)uxCoprocArea, xTargetCoreID );
40379f1c:	1122b2        	l32i	a11, a2, 68
40379f1f:	f0afa2        	movi	a10, -16
40379f22:	10a8a0        	and	a10, a8, a10
40379f25:	083225        	call8	40382248 <_xt_coproc_release>
}
40379f28:	000090        	retw
	...

40379f2c <xPortStartScheduler>:
{
40379f2c:	004136        	entry	a1, 32
    portDISABLE_INTERRUPTS();
40379f2f:	006380        	rsil	a8, 3
    _xt_coproc_init();
40379f32:	082fe5        	call8	40382230 <_xt_coproc_init>
    vPortSetupTimer();
40379f35:	007a65        	call8	4037a6dc <vPortSetupTimer>
40379f38:	03eb80        	rsr.prid	a8
40379f3b:	048d80        	extui	a8, a8, 13, 1
    port_xSchedulerRunning[xPortGetCoreID()] = 1;
40379f3e:	eb0f91        	l32r	a9, 40374b7c <_iram_text_start+0x778> (3fc95278 <port_xSchedulerRunning>)
40379f41:	a08890        	addx4	a8, a8, a9
40379f44:	01a022        	movi	a2, 1
40379f47:	0020c0        	memw
40379f4a:	0829      	s32i.n	a2, a8, 0
    xthal_window_spill();
40379f4c:	081765        	call8	403820c4 <xthal_window_spill>
    __asm__ volatile ("call0    _frxt_dispatch\n");
40379f4f:	003bc5        	call0	4037a30c <_frxt_dispatch>
}
40379f52:	f01d      	retw.n

40379f54 <pxPortInitialiseStack>:
{
40379f54:	004136        	entry	a1, 32
    configASSERT((uxStackPointer & portBYTE_ALIGNMENT_MASK) == 0);
40379f57:	348020        	extui	a8, a2, 0, 4
40379f5a:	d88c      	beqz.n	a8, 40379f6b <pxPortInitialiseStack+0x17>
40379f5c:	eb09d1        	l32r	a13, 40374b80 <_iram_text_start+0x77c> (3c0239d0 <_flash_rodata_start+0x38b0>)
40379f5f:	eb09c1        	l32r	a12, 40374b84 <_iram_text_start+0x780> (3c027358 <__func__$4>)
40379f62:	a1a1b2        	movi	a11, 0x1a1
40379f65:	eb08a1        	l32r	a10, 40374b88 <_iram_text_start+0x784> (3c023a2e <_flash_rodata_start+0x390e>)
40379f68:	05dbe5        	call8	4037fd28 <__assert_func>
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - XT_CP_SIZE);
40379f6b:	c4ae82        	movi	a8, 0xfffffec4
40379f6e:	728a      	add.n	a7, a2, a8
40379f70:	027c      	movi.n	a2, -16
40379f72:	107720        	and	a7, a7, a2
    p[0] = 0;   // Clear XT_CPENABLE and XT_CPSTORED
40379f75:	050c      	movi.n	a5, 0
40379f77:	0759      	s32i.n	a5, a7, 0
    p[1] = 0;   // Clear XT_CP_CS_ST
40379f79:	1759      	s32i.n	a5, a7, 4
    p[2] = (uint32_t)ALIGNUP(XCHAL_TOTAL_SA_ALIGN, (uint32_t)uxStackPointer + 12);
40379f7b:	1bc782        	addi	a8, a7, 27
40379f7e:	108820        	and	a8, a8, a2
40379f81:	2789      	s32i.n	a8, a7, 8
    const uint32_t tls_area_size = ALIGNUP(16, (uint32_t)&_thread_local_end - (uint32_t)&_thread_local_start);
40379f83:	eb0261        	l32r	a6, 40374b8c <_iram_text_start+0x788> (3c0292a4 <_esp_system_init_fn_array_end>)
40379f86:	eb06c1        	l32r	a12, 40374ba0 <_iram_text_start+0x79c> (3c0292b3 <_esp_system_init_fn_array_end+0xf>)
40379f89:	c0cc60        	sub	a12, a12, a6
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - (UBaseType_t)tls_area_size);
40379f8c:	10cc20        	and	a12, a12, a2
40379f8f:	c077c0        	sub	a7, a7, a12
40379f92:	107720        	and	a7, a7, a2
    memcpy((void *)uxStackPointer, &_thread_local_start, tls_area_size);
40379f95:	06bd      	mov.n	a11, a6
40379f97:	20a770        	or	a10, a7, a7
40379f9a:	e95981        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40379f9d:	0008e0        	callx8	a8
    const uint32_t base = ALIGNUP(tls_section_align, TCB_SIZE);
40379fa0:	eafc81        	l32r	a8, 40374b90 <_iram_text_start+0x78c> (10 <_flash_rodata_align>)
40379fa3:	a87b      	addi.n	a10, a8, 7
40379fa5:	609080        	neg	a9, a8
    *ret_threadptr_reg_init = (uint32_t)uxStackPointer - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
40379fa8:	c08760        	sub	a8, a7, a6
40379fab:	109a90        	and	a9, a10, a9
40379fae:	eaf961        	l32r	a6, 40374b94 <_iram_text_start+0x790> (3c020120 <_flash_rodata_start>)
40379fb1:	c06690        	sub	a6, a6, a9
40379fb4:	668a      	add.n	a6, a6, a8
    uxStackPointer = STACKPTR_ALIGN_DOWN(16, uxStackPointer - XT_STK_FRMSZ);
40379fb6:	40af82        	movi	a8, -192
40379fb9:	878a      	add.n	a8, a7, a8
40379fbb:	102820        	and	a2, a8, a2
    memset((void *)uxStackPointer, 0, (size_t)(uxStackPointerPrevious - uxStackPointer));
40379fbe:	c0c720        	sub	a12, a7, a2
40379fc1:	05bd      	mov.n	a11, a5
40379fc3:	20a220        	or	a10, a2, a2
40379fc6:	e93c81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40379fc9:	0008e0        	callx8	a8
    frame->a0 = 0;                                          // Set the return address to 0 terminate GDB backtrace
40379fcc:	3259      	s32i.n	a5, a2, 12
    frame->a1 = uxStackPointer + XT_STK_FRMSZ;              // Saved stack pointer should point to physical top of stack frame
40379fce:	c0a082        	movi	a8, 192
40379fd1:	828a      	add.n	a8, a2, a8
40379fd3:	4289      	s32i.n	a8, a2, 16
    frame->exit = (UBaseType_t) _xt_user_exit;              // User exception exit dispatcher
40379fd5:	e9e281        	l32r	a8, 40374760 <_iram_text_start+0x35c> (40376cf4 <_xt_user_exit>)
40379fd8:	0289      	s32i.n	a8, a2, 0
        frame->pc = (UBaseType_t) vPortTaskWrapper;         // Task entry point is the wrapper function
40379fda:	eaef81        	l32r	a8, 40374b98 <_iram_text_start+0x794> (40379e94 <vPortTaskWrapper>)
40379fdd:	1289      	s32i.n	a8, a2, 4
            frame->a6 = (UBaseType_t) pxCode;               // Wrapper function's argument 0 (which is the task function), passed as if we call4'd
40379fdf:	9239      	s32i.n	a3, a2, 36
            frame->a7 = (UBaseType_t) pvParameters;         // Wrapper function's argument 1 (which is the task function's argument), passed as if we call4'd
40379fe1:	a249      	s32i.n	a4, a2, 40
        frame->ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(1);
40379fe3:	eaee81        	l32r	a8, 40374b9c <_iram_text_start+0x798> (50030 <UserFrameTotalSize+0x4ff30>)
40379fe6:	2289      	s32i.n	a8, a2, 8
    *threadptr_reg = threadptr_reg_init;
40379fe8:	1c6262        	s32i	a6, a2, 112
}
40379feb:	f01d      	retw.n
40379fed:	000000        	ill

40379ff0 <xPortInIsrContext>:
{
40379ff0:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40379ff3:	0063a0        	rsil	a10, 3
40379ff6:	03eb80        	rsr.prid	a8
40379ff9:	048d80        	extui	a8, a8, 13, 1
    ret = (port_interruptNesting[xPortGetCoreID()] != 0);
40379ffc:	e9c491        	l32r	a9, 4037470c <_iram_text_start+0x308> (3fc95270 <port_interruptNesting>)
40379fff:	a08890        	addx4	a8, a8, a9
4037a002:	0888      	l32i.n	a8, a8, 0
4037a004:	01a022        	movi	a2, 1
4037a007:	832880        	moveqz	a2, a8, a8
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a00a:	eae681        	l32r	a8, 40374ba4 <_iram_text_start+0x7a0> (40001c38 <_xtos_set_intlevel>)
4037a00d:	0008e0        	callx8	a8
}
4037a010:	f01d      	retw.n
	...

4037a014 <xPortEnterCriticalTimeout>:
{
4037a014:	006136        	entry	a1, 48
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a017:	006380        	rsil	a8, 3
4037a01a:	006182        	s32i	a8, a1, 0
    // Unused if asserts are disabled
    uint32_t __attribute__((unused)) other_core_owner_id;
    bool lock_set;
    esp_cpu_cycle_count_t start_count;

    assert(lock);
4037a01d:	00e256        	bnez	a2, 4037a02f <xPortEnterCriticalTimeout+0x1b>
4037a020:	eae2d1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4> (3c0216a8 <_flash_rodata_start+0x1588>)
4037a023:	eae2c1        	l32r	a12, 40374bac <_iram_text_start+0x7a8> (3c027344 <__func__$2>)
4037a026:	eae2a1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a029:	54a0b2        	movi	a11, 84
4037a02c:	05cfa5        	call8	4037fd28 <__assert_func>
#if __XTENSA__
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a02f:	006350        	rsil	a5, 3
    asm volatile (
4037a032:	03eb70        	rsr.prid	a7
     *  - If "our" core_owner_id, we can drop through immediately.
     *  - If "other_core_owner_id", we spin here.
     */

    // The caller is already the owner of the lock. Simply increment the nesting count
    if (lock->owner == core_owner_id) {
4037a035:	002292        	l32i	a9, a2, 0
4037a038:	259797        	bne	a7, a9, 4037a061 <xPortEnterCriticalTimeout+0x4d>
        assert(lock->count > 0 && lock->count < 0xFF);    // Bad count value implies memory corruption
4037a03b:	1298      	l32i.n	a9, a2, 4
4037a03d:	fda0b2        	movi	a11, 253
4037a040:	a90b      	addi.n	a10, a9, -1
4037a042:	0ebba7        	bgeu	a11, a10, 4037a054 <xPortEnterCriticalTimeout+0x40>
4037a045:	eadbd1        	l32r	a13, 40374bb4 <_iram_text_start+0x7b0> (3c023a38 <_flash_rodata_start+0x3918>)
4037a048:	ead9c1        	l32r	a12, 40374bac <_iram_text_start+0x7a8> (3c027344 <__func__$2>)
4037a04b:	ead9a1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a04e:	6aa0b2        	movi	a11, 106
4037a051:	05cd65        	call8	4037fd28 <__assert_func>
        lock->count++;
4037a054:	991b      	addi.n	a9, a9, 1
4037a056:	1299      	s32i.n	a9, a2, 4
#if __XTENSA__
        XTOS_RESTORE_INTLEVEL(irq_status);
4037a058:	13e650        	wsr.ps	a5
4037a05b:	002010        	rsync
#else
        rv_utils_restore_intlevel_regval(irq_status);
#endif
        return true;
4037a05e:	003346        	j	4037a12f <xPortEnterCriticalTimeout+0x11b>
     * Note: We do a first attempt separately (instead of putting this into a loop) in order to avoid call to
     * esp_cpu_get_cycle_count(). This doing a first attempt separately makes acquiring a free lock quicker, which
     * is the case for the majority of spinlock_acquire() calls (as spinlocks are free most of the time since they
     * aren't meant to be held for long).
     */
    lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a061:	eaa5b1        	l32r	a11, 40374af8 <_iram_text_start+0x6f4> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a064:	20c770        	or	a12, a7, a7
4037a067:	20a220        	or	a10, a2, a2
4037a06a:	fdcae5        	call8	40377d18 <esp_cpu_compare_and_set>
    if (lock_set || timeout == SPINLOCK_NO_WAIT) {
4037a06d:	53bc      	beqz.n	a3, 4037a0a6 <xPortEnterCriticalTimeout+0x92>
4037a06f:	3afc      	bnez.n	a10, 4037a0a6 <xPortEnterCriticalTimeout+0x92>
    RSR(CCOUNT, ccount);
4037a071:	03ea40        	rsr.ccount	a4
    }

    // First attempt to take the lock has failed. Retry until the lock is taken, or until we timeout.
    start_count = esp_cpu_get_cycle_count();
    do {
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a074:	eaa161        	l32r	a6, 40374af8 <_iram_text_start+0x6f4> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a077:	190326        	beqi	a3, -1, 4037a094 <xPortEnterCriticalTimeout+0x80>
4037a07a:	07cd      	mov.n	a12, a7
4037a07c:	06bd      	mov.n	a11, a6
4037a07e:	20a220        	or	a10, a2, a2
4037a081:	fdc965        	call8	40377d18 <esp_cpu_compare_and_set>
        if (lock_set) {
4037a084:	0d5a56        	bnez	a10, 4037a15d <xPortEnterCriticalTimeout+0x149>
4037a087:	03ea90        	rsr.ccount	a9
            break;
        }
        // Keep looping if we are waiting forever, or check if we have timed out
    } while ((timeout == SPINLOCK_WAIT_FOREVER) || (esp_cpu_get_cycle_count() - start_count) <= (esp_cpu_cycle_count_t)timeout);
4037a08a:	c09940        	sub	a9, a9, a4
4037a08d:	e9b397        	bgeu	a3, a9, 4037a07a <xPortEnterCriticalTimeout+0x66>
4037a090:	003106        	j	4037a158 <xPortEnterCriticalTimeout+0x144>
4037a093:	c77000        	ee.stf.64.xp	f7, f12, a0, a0
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_owner_id);
4037a096:	b66020        	ee.ldf.64.xp	f6, f11, a2, a0
4037a099:	a22020        	muluh	a2, a0, a2
4037a09c:	c7a520        	ee.stf.64.xp	f10, f12, a2, a5
4037a09f:	fd          	.byte	0xfd
        if (lock_set) {
4037a0a0:	ff0a16        	beqz	a10, 4037a094 <xPortEnterCriticalTimeout+0x80>

exit:
4037a0a3:	002d86        	j	4037a15d <xPortEnterCriticalTimeout+0x149>
    if (lock_set) {
        assert(lock->owner == core_owner_id);
4037a0a6:	002292        	l32i	a9, a2, 0
    if (lock_set) {
4037a0a9:	034a16        	beqz	a10, 4037a0e1 <xPortEnterCriticalTimeout+0xcd>
        assert(lock->owner == core_owner_id);
4037a0ac:	0e1797        	beq	a7, a9, 4037a0be <xPortEnterCriticalTimeout+0xaa>
4037a0af:	eac2d1        	l32r	a13, 40374bb8 <_iram_text_start+0x7b4> (3c023a60 <_flash_rodata_start+0x3940>)
4037a0b2:	eabec1        	l32r	a12, 40374bac <_iram_text_start+0x7a8> (3c027344 <__func__$2>)
4037a0b5:	eabea1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a0b8:	8da0b2        	movi	a11, 141
4037a0bb:	05c6e5        	call8	4037fd28 <__assert_func>
        assert(lock->count == 0);   // This is the first time the lock is set, so count should still be 0
4037a0be:	1298      	l32i.n	a9, a2, 4
4037a0c0:	d98c      	beqz.n	a9, 4037a0d1 <xPortEnterCriticalTimeout+0xbd>
4037a0c2:	eabed1        	l32r	a13, 40374bbc <_iram_text_start+0x7b8> (3c023a80 <_flash_rodata_start+0x3960>)
4037a0c5:	eab9c1        	l32r	a12, 40374bac <_iram_text_start+0x7a8> (3c027344 <__func__$2>)
4037a0c8:	eabaa1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a0cb:	8ea0b2        	movi	a11, 142
4037a0ce:	05c5a5        	call8	4037fd28 <__assert_func>
        lock->count++;  // Finally, we increment the lock count
4037a0d1:	190c      	movi.n	a9, 1
4037a0d3:	1299      	s32i.n	a9, a2, 4
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_owner_id);
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
    }

#if __XTENSA__
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a0d5:	13e650        	wsr.ps	a5
4037a0d8:	002010        	rsync
#else
    rv_utils_restore_intlevel_regval(irq_status);
#endif
    return lock_set;
4037a0db:	001406        	j	4037a12f <xPortEnterCriticalTimeout+0x11b>
4037a0de:	000000        	ill
    other_core_owner_id = CORE_ID_REGVAL_XOR_SWAP ^ core_owner_id;
4037a0e1:	eab7a1        	l32r	a10, 40374bc0 <_iram_text_start+0x7bc> (6666 <UserFrameTotalSize+0x6566>)
4037a0e4:	30a7a0        	xor	a10, a7, a10
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_owner_id);
4037a0e7:	171a97        	beq	a10, a9, 4037a102 <xPortEnterCriticalTimeout+0xee>
4037a0ea:	ea83a1        	l32r	a10, 40374af8 <_iram_text_start+0x6f4> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a0ed:	1119a7        	beq	a9, a10, 4037a102 <xPortEnterCriticalTimeout+0xee>
4037a0f0:	eab5d1        	l32r	a13, 40374bc4 <_iram_text_start+0x7c0> (3c023a94 <_flash_rodata_start+0x3974>)
4037a0f3:	eaaec1        	l32r	a12, 40374bac <_iram_text_start+0x7a8> (3c027344 <__func__$2>)
4037a0f6:	eaaea1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a0f9:	91a0b2        	movi	a11, 145
4037a0fc:	201110        	or	a1, a1, a1
4037a0ff:	05c2a5        	call8	4037fd28 <__assert_func>
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
4037a102:	012282        	l32i	a8, a2, 4
4037a105:	fea092        	movi	a9, 254
4037a108:	0eb987        	bgeu	a9, a8, 4037a11a <xPortEnterCriticalTimeout+0x106>
4037a10b:	eaafd1        	l32r	a13, 40374bc8 <_iram_text_start+0x7c4> (3c023ad8 <_flash_rodata_start+0x39b8>)
4037a10e:	eaa7c1        	l32r	a12, 40374bac <_iram_text_start+0x7a8> (3c027344 <__func__$2>)
4037a111:	eaa7a1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a114:	92a0b2        	movi	a11, 146
4037a117:	05c125        	call8	4037fd28 <__assert_func>
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a11a:	13e650        	wsr.ps	a5
4037a11d:	002010        	rsync
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a120:	0021a2        	l32i	a10, a1, 0
        return pdFAIL;
4037a123:	00a022        	movi	a2, 0
4037a126:	ea9f81        	l32r	a8, 40374ba4 <_iram_text_start+0x7a0> (40001c38 <_xtos_set_intlevel>)
4037a129:	0008e0        	callx8	a8
4037a12c:	000c86        	j	4037a162 <xPortEnterCriticalTimeout+0x14e>
    asm volatile (
4037a12f:	03eb80        	rsr.prid	a8
4037a132:	048d80        	extui	a8, a8, 13, 1
    BaseType_t newNesting = port_uxCriticalNesting[coreID] + 1;
4037a135:	eaa591        	l32r	a9, 40374bcc <_iram_text_start+0x7c8> (3fc95268 <port_uxCriticalNesting>)
4037a138:	11a8e0        	slli	a10, a8, 2
4037a13b:	a08890        	addx4	a8, a8, a9
4037a13e:	0898      	l32i.n	a9, a8, 0
4037a140:	991b      	addi.n	a9, a9, 1
    port_uxCriticalNesting[coreID] = newNesting;
4037a142:	0899      	s32i.n	a9, a8, 0
    if ( newNesting == 1 ) {
4037a144:	041926        	beqi	a9, 1, 4037a14c <xPortEnterCriticalTimeout+0x138>
    return pdPASS;
4037a147:	120c      	movi.n	a2, 1
4037a149:	000546        	j	4037a162 <xPortEnterCriticalTimeout+0x14e>
        port_uxOldInterruptState[coreID] = xOldInterruptLevel;
4037a14c:	eaa181        	l32r	a8, 40374bd0 <_iram_text_start+0x7cc> (3fc95260 <port_uxOldInterruptState>)
4037a14f:	0198      	l32i.n	a9, a1, 0
4037a151:	88aa      	add.n	a8, a8, a10
4037a153:	0899      	s32i.n	a9, a8, 0
4037a155:	fffb86        	j	4037a147 <xPortEnterCriticalTimeout+0x133>
        assert(lock->owner == core_owner_id);
4037a158:	0298      	l32i.n	a9, a2, 0
4037a15a:	ffe0c6        	j	4037a0e1 <xPortEnterCriticalTimeout+0xcd>
4037a15d:	0298      	l32i.n	a9, a2, 0
4037a15f:	ffd246        	j	4037a0ac <xPortEnterCriticalTimeout+0x98>
}
4037a162:	f01d      	retw.n

4037a164 <vPortExitCritical>:
{
4037a164:	004136        	entry	a1, 32
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE && !BOOTLOADER_BUILD
    uint32_t irq_status;
    // Return value unused if asserts are disabled
    uint32_t __attribute__((unused)) core_owner_id;

    assert(lock);
4037a167:	00e256        	bnez	a2, 4037a179 <vPortExitCritical+0x15>
4037a16a:	ea8fd1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4> (3c0216a8 <_flash_rodata_start+0x1588>)
4037a16d:	ea99c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0> (3c02731c <__func__$0>)
4037a170:	ea90a1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a173:	b5a0b2        	movi	a11, 181
4037a176:	05bb25        	call8	4037fd28 <__assert_func>
#if __XTENSA__
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a179:	0063a0        	rsil	a10, 3
    asm volatile (
4037a17c:	03eb90        	rsr.prid	a9
    core_owner_id = xt_utils_get_raw_core_id();
#else
    irq_status = rv_utils_set_intlevel_regval(RVHAL_EXCM_LEVEL_CLIC);
    core_owner_id = rv_utils_get_core_id() == 0 ? SPINLOCK_OWNER_ID_0 : SPINLOCK_OWNER_ID_1;
#endif
    assert(core_owner_id == lock->owner); // This is a lock that we didn't acquire, or the lock is corrupt
4037a17f:	0288      	l32i.n	a8, a2, 0
4037a181:	111987        	beq	a9, a8, 4037a196 <vPortExitCritical+0x32>
4037a184:	ea95d1        	l32r	a13, 40374bd8 <_iram_text_start+0x7d4> (3c023aec <_flash_rodata_start+0x39cc>)
4037a187:	ea93c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0> (3c02731c <__func__$0>)
4037a18a:	ea89a1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a18d:	bea0b2        	movi	a11, 190
4037a190:	201110        	or	a1, a1, a1
4037a193:	05b965        	call8	4037fd28 <__assert_func>
    lock->count--;
4037a196:	1288      	l32i.n	a8, a2, 4
4037a198:	880b      	addi.n	a8, a8, -1
4037a19a:	1289      	s32i.n	a8, a2, 4

    if (!lock->count) { // If this is the last recursive release of the lock, mark the lock as free
4037a19c:	98cc      	bnez.n	a8, 4037a1a9 <vPortExitCritical+0x45>
        lock->owner = SPINLOCK_FREE;
4037a19e:	ea5681        	l32r	a8, 40374af8 <_iram_text_start+0x6f4> (b33fffff <_rtc_reserved_end+0x532fffff>)
4037a1a1:	0289      	s32i.n	a8, a2, 0
4037a1a3:	0005c6        	j	4037a1be <vPortExitCritical+0x5a>
4037a1a6:	000000        	ill
    } else {
        assert(lock->count < 0x100); // Indicates memory corruption
4037a1a9:	ffa092        	movi	a9, 255
4037a1ac:	0eb987        	bgeu	a9, a8, 4037a1be <vPortExitCritical+0x5a>
4037a1af:	ea8bd1        	l32r	a13, 40374bdc <_iram_text_start+0x7d8> (3c023b0c <_flash_rodata_start+0x39ec>)
4037a1b2:	ea88c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0> (3c02731c <__func__$0>)
4037a1b5:	ea7ea1        	l32r	a10, 40374bb0 <_iram_text_start+0x7ac> (3c0216d8 <_flash_rodata_start+0x15b8>)
4037a1b8:	c4a0b2        	movi	a11, 196
4037a1bb:	05b6e5        	call8	4037fd28 <__assert_func>
    }

#if __XTENSA__
    XTOS_RESTORE_INTLEVEL(irq_status);
4037a1be:	13e6a0        	wsr.ps	a10
4037a1c1:	002010        	rsync
    asm volatile (
4037a1c4:	03eb80        	rsr.prid	a8
4037a1c7:	048d80        	extui	a8, a8, 13, 1
    BaseType_t nesting = port_uxCriticalNesting[coreID];
4037a1ca:	ea8091        	l32r	a9, 40374bcc <_iram_text_start+0x7c8> (3fc95268 <port_uxCriticalNesting>)
4037a1cd:	11a8e0        	slli	a10, a8, 2
4037a1d0:	a08890        	addx4	a8, a8, a9
4037a1d3:	0898      	l32i.n	a9, a8, 0
    configASSERT( nesting > 0 );
4037a1d5:	1119e6        	bgei	a9, 1, 4037a1ea <vPortExitCritical+0x86>
4037a1d8:	ea82d1        	l32r	a13, 40374be0 <_iram_text_start+0x7dc> (3c023b20 <_flash_rodata_start+0x3a00>)
4037a1db:	ea82c1        	l32r	a12, 40374be4 <_iram_text_start+0x7e0> (3c027330 <__func__$1>)
4037a1de:	ea6aa1        	l32r	a10, 40374b88 <_iram_text_start+0x784> (3c023a2e <_flash_rodata_start+0x390e>)
4037a1e1:	faa1b2        	movi	a11, 0x1fa
4037a1e4:	201110        	or	a1, a1, a1
4037a1e7:	05b425        	call8	4037fd28 <__assert_func>
        nesting--;
4037a1ea:	990b      	addi.n	a9, a9, -1
        port_uxCriticalNesting[coreID] = nesting;
4037a1ec:	0899      	s32i.n	a9, a8, 0
        if ( nesting == 0 ) {
4037a1ee:	b9cc      	bnez.n	a9, 4037a1fd <vPortExitCritical+0x99>
            portCLEAR_INTERRUPT_MASK_FROM_ISR(port_uxOldInterruptState[coreID]);
4037a1f0:	ea7881        	l32r	a8, 40374bd0 <_iram_text_start+0x7cc> (3fc95260 <port_uxOldInterruptState>)
4037a1f3:	88aa      	add.n	a8, a8, a10
4037a1f5:	08a8      	l32i.n	a10, a8, 0
4037a1f7:	ea6b81        	l32r	a8, 40374ba4 <_iram_text_start+0x7a0> (40001c38 <_xtos_set_intlevel>)
4037a1fa:	0008e0        	callx8	a8
}
4037a1fd:	f01d      	retw.n
	...

4037a200 <vPortYieldOtherCore>:
{
4037a200:	004136        	entry	a1, 32
4037a203:	02ad      	mov.n	a10, a2
    esp_crosscore_int_send_yield( coreid );
4037a205:	fda4e5        	call8	40377c54 <esp_crosscore_int_send_yield>
}
4037a208:	f01d      	retw.n
	...

4037a20c <vApplicationStackOverflowHook>:
{
4037a20c:	010136        	entry	a1, 128
    const char *str[] = {ERR_STR1, pcTaskName, ERR_STR2};
4037a20f:	ea7681        	l32r	a8, 40374be8 <_iram_text_start+0x7e4> (3c023b2c <_flash_rodata_start+0x3a0c>)
4037a212:	0189      	s32i.n	a8, a1, 0
4037a214:	1139      	s32i.n	a3, a1, 4
4037a216:	ea7581        	l32r	a8, 40374bec <_iram_text_start+0x7e8> (3c023b54 <_flash_rodata_start+0x3a34>)
4037a219:	2189      	s32i.n	a8, a1, 8
    char buf[sizeof(ERR_STR1) + CONFIG_FREERTOS_MAX_TASK_NAME_LEN + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037a21b:	71cb      	addi.n	a7, a1, 12
4037a21d:	bc4c      	movi.n	a12, 75
4037a21f:	0b0c      	movi.n	a11, 0
4037a221:	07ad      	mov.n	a10, a7
4037a223:	e8a581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037a226:	0008e0        	callx8	a8
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a229:	060c      	movi.n	a6, 0
    char *dest = buf;
4037a22b:	07ad      	mov.n	a10, a7
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a22d:	0003c6        	j	4037a240 <vApplicationStackOverflowHook+0x34>
4037a230:	861000        	ee.ldf.64.xp	f1, f8, a0, a0
        dest = strcat(dest, str[i]);
4037a233:	a0          	.byte	0xa0
4037a234:	0028b2        	l32i	a11, a8, 0
4037a237:	ea6e81        	l32r	a8, 40374bf0 <_iram_text_start+0x7ec> (40001374 <strcat>)
4037a23a:	0008e0        	callx8	a8
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037a23d:	01c662        	addi	a6, a6, 1
4037a240:	ed36b6        	bltui	a6, 3, 4037a231 <vApplicationStackOverflowHook+0x25>
    esp_system_abort(buf);
4037a243:	0cc1a2        	addi	a10, a1, 12
4037a246:	ff4625        	call8	403796a8 <esp_system_abort>
4037a249:	000000        	ill

4037a24c <vPortTCBPreDeleteHook>:
#endif /* XCHAL_CP_NUM > 0 */

void vPortTCBPreDeleteHook( void *pxTCB )
{
4037a24c:	004136        	entry	a1, 32
        vPortCleanUpTCB( pxTCB );
    #endif /* CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP */

    #if ( CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS )
        /* Call TLS pointers deletion callbacks */
        vPortTLSPointersDelCb( pxTCB );
4037a24f:	20a220        	or	a10, a2, a2
4037a252:	ffc6a5        	call8	40379ebc <vPortTLSPointersDelCb>
    #endif /* CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS */

    #if ( XCHAL_CP_NUM > 0 )
        /* Cleanup coproc save area */
        vPortCleanUpCoprocArea( pxTCB );
4037a255:	20a220        	or	a10, a2, a2
4037a258:	ffcb65        	call8	40379f10 <vPortCleanUpCoprocArea>
    #endif /* XCHAL_CP_NUM > 0 */
}
4037a25b:	000090        	retw
	...

4037a260 <_frxt_setup_switch>:
    .global     _frxt_setup_switch
    .type       _frxt_setup_switch,@function
    .align      4
_frxt_setup_switch:

    ENTRY(16)
4037a260:	002136        	entry	a1, 16

    getcoreid a3
4037a263:	03eb30        	rsr.prid	a3
4037a266:	043d30        	extui	a3, a3, 13, 1
    movi    a2, port_switch_flag
4037a269:	ea6221        	l32r	a2, 40374bf4 <_iram_text_start+0x7f0> (3fc95258 <port_switch_flag>)
    addx4   a2,  a3, a2
4037a26c:	a02320        	addx4	a2, a3, a2
    movi    a3, 1
4037a26f:	130c      	movi.n	a3, 1
    s32i    a3, a2, 0
4037a271:	0239      	s32i.n	a3, a2, 0

    RET(16)
4037a273:	f01d      	retw.n
4037a275:	000000        	ill

4037a278 <_frxt_int_enter>:
    .type   _frxt_int_enter,@function
    .align  4
_frxt_int_enter:

    /* Save a12-13 in the stack frame as required by _xt_context_save. */
    s32i    a12, a1, XT_STK_A12
4037a278:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, a1, XT_STK_A13
4037a27a:	1061d2        	s32i	a13, a1, 64

    /* Save return address in a safe place (free a0). */
    mov     a12, a0
4037a27d:	00cd      	mov.n	a12, a0

    /* Save the rest of the interrupted context (preserves A12-13). */
    call0   _xt_context_save
4037a27f:	07ec85        	call0	40382148 <_xt_context_save>
    /*
    Save interrupted task's SP in TCB only if not nesting.
    Manage nesting directly rather than call the generic IntEnter()
    (in windowed ABI we can't call a C function here anyway because PS.EXCM is still set).
    */
    getcoreid a4
4037a282:	03eb40        	rsr.prid	a4
4037a285:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
4037a288:	ea3d21        	l32r	a2, 40374b7c <_iram_text_start+0x778> (3fc95278 <port_xSchedulerRunning>)
    addx4   a2,  a4, a2
4037a28b:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
4037a28e:	e91f31        	l32r	a3, 4037470c <_iram_text_start+0x308> (3fc95270 <port_interruptNesting>)
    addx4   a3,  a4, a3
4037a291:	a03430        	addx4	a3, a4, a3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
4037a294:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* scheduler not running, no tasks */
4037a296:	e29c      	beqz.n	a2, 4037a2b8 <_frxt_int_enter+0x40>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
4037a298:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, 1                  /* increment nesting count         */
4037a29a:	221b      	addi.n	a2, a2, 1
    s32i    a2,  a3, 0                  /* save nesting count              */
4037a29c:	0329      	s32i.n	a2, a3, 0
    bnei    a2,  1, .Lnested            /* !=0 before incr, so nested      */
4037a29e:	161266        	bnei	a2, 1, 4037a2b8 <_frxt_int_enter+0x40>

    movi    a2,  pxCurrentTCBs
4037a2a1:	ea5521        	l32r	a2, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    addx4   a2,  a4, a2
4037a2a4:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
4037a2a7:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f
4037a2a9:	b28c      	beqz.n	a2, 4037a2b8 <_frxt_int_enter+0x40>
    s32i    a1,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCBs->pxTopOfStack = SP */
4037a2ab:	0219      	s32i.n	a1, a2, 0
    movi    a1,  port_IntStack+configISR_STACK_SIZE   /* a1 = top of intr stack for CPU 0  */
4037a2ad:	ea5311        	l32r	a1, 40374bfc <_iram_text_start+0x7f8> (3fc93360 <port_IntStack+0x600>)
    movi    a2,  configISR_STACK_SIZE   /* add configISR_STACK_SIZE * cpu_num to arrive at top of stack for cpu_num */
4037a2b0:	00a622        	movi	a2, 0x600
    mull    a2,  a4, a2
4037a2b3:	822420        	mull	a2, a4, a2
    add     a1,  a1, a2                 /* for current proc */
4037a2b6:	112a      	add.n	a1, a1, a2
    movi    a3,  0              /* whilst ISRs pending keep CPENABLE exception active */
    wsr     a3,  CPENABLE
    rsync
    #endif

    mov     a0,  a12                    /* restore return addr and return  */
4037a2b8:	0c0d      	mov.n	a0, a12
    ret
4037a2ba:	f00d      	ret.n

4037a2bc <_frxt_int_exit>:
    .globl  _frxt_int_exit
    .type   _frxt_int_exit,@function
    .align  4
_frxt_int_exit:

    getcoreid a4
4037a2bc:	03eb40        	rsr.prid	a4
4037a2bf:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
4037a2c2:	ea2e21        	l32r	a2, 40374b7c <_iram_text_start+0x778> (3fc95278 <port_xSchedulerRunning>)
    addx4   a2,  a4, a2
4037a2c5:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
4037a2c8:	e91131        	l32r	a3, 4037470c <_iram_text_start+0x308> (3fc95270 <port_interruptNesting>)
    addx4   a3,  a4, a3
4037a2cb:	a03430        	addx4	a3, a4, a3
    rsil    a0,  XCHAL_EXCM_LEVEL       /* lock out interrupts             */
4037a2ce:	006300        	rsil	a0, 3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
4037a2d1:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  .Lnoswitch             /* scheduler not running, no tasks */
4037a2d3:	e2ac      	beqz.n	a2, 4037a305 <_frxt_int_exit+0x49>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
4037a2d5:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, -1                 /* decrement nesting count         */
4037a2d7:	220b      	addi.n	a2, a2, -1
    s32i    a2,  a3, 0                  /* save nesting count              */
4037a2d9:	0329      	s32i.n	a2, a3, 0
    bnez    a2,  .Lnesting              /* !=0 after decr so still nested  */
4037a2db:	62ec      	bnez.n	a2, 4037a305 <_frxt_int_exit+0x49>
    addi    sp,  sp, 4
    wsr     a3, CPENABLE
    rsync                               /* ensure CPENABLE was modified */
    #endif

    movi    a2,  pxCurrentTCBs
4037a2dd:	ea4621        	l32r	a2, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    addx4   a2,  a4, a2
4037a2e0:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
4037a2e3:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* no task ? go to dispatcher      */
4037a2e5:	029c      	beqz.n	a2, 4037a2f9 <_frxt_int_exit+0x3d>
    l32i    a1,  a2, TOPOFSTACK_OFFS    /* SP = pxCurrentTCBs->pxTopOfStack */
4037a2e7:	0218      	l32i.n	a1, a2, 0

    movi    a2,  port_switch_flag       /* address of switch flag          */
4037a2e9:	ea4221        	l32r	a2, 40374bf4 <_iram_text_start+0x7f0> (3fc95258 <port_switch_flag>)
    addx4   a2,  a4, a2                 /* point to flag for this cpu      */
4037a2ec:	a02420        	addx4	a2, a4, a2
    l32i    a3,  a2, 0                  /* a3 = port_switch_flag           */
4037a2ef:	0238      	l32i.n	a3, a2, 0
    beqz    a3,  .Lnoswitch             /* flag = 0 means no switch reqd   */
4037a2f1:	039c      	beqz.n	a3, 4037a305 <_frxt_int_exit+0x49>
    movi    a3,  0
4037a2f3:	00a032        	movi	a3, 0
    s32i    a3,  a2, 0                  /* zero out the flag for next time */
4037a2f6:	006232        	s32i	a3, a2, 0
    #endif

    #ifdef __XTENSA_CALL0_ABI__
    call0   vPortYieldFromInt       /* call dispatch inside the function; never returns */
    #else
    call4   vPortYieldFromInt       /* this one returns */
4037a2f9:	201110        	or	a1, a1, a1
4037a2fc:	000d55        	call4	4037a3d4 <vPortYieldFromInt>
    call0   _frxt_dispatch          /* tail-call dispatcher */
4037a2ff:	201110        	or	a1, a1, a1
4037a302:	000085        	call0	4037a30c <_frxt_dispatch>
    is a nested interrupt, or the interrupted task was not preempted.
    In either case there's no need to load the SP.
    */

    /* Restore full context from interrupt stack frame */
    call0   _xt_context_restore
4037a305:	07ee45        	call0	403821ec <_xt_context_restore>
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0,  a1, XT_STK_EXIT
4037a308:	0108      	l32i.n	a0, a1, 0
    ret
4037a30a:	f00d      	ret.n

4037a30c <_frxt_dispatch>:
    call0   vTaskSwitchContext  // Get next TCB to resume
    movi    a2, pxCurrentTCBs
    getcoreid a3
    addx4   a2,  a3, a2
    #else
    call4   vTaskSwitchContext  // Get next TCB to resume
4037a30c:	010a95        	call4	4037b3b8 <vTaskSwitchContext>
    movi    a2, pxCurrentTCBs
4037a30f:	ea3a21        	l32r	a2, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    getcoreid a3
4037a312:	03eb30        	rsr.prid	a3
4037a315:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a318:	a02320        	addx4	a2, a3, a2
    #endif
    l32i    a3,  a2, 0
4037a31b:	002232        	l32i	a3, a2, 0
    l32i    sp,  a3, TOPOFSTACK_OFFS     /* SP = next_TCB->pxTopOfStack;  */
4037a31e:	002312        	l32i	a1, a3, 0
    s32i    a3,  a2, 0
4037a321:	006232        	s32i	a3, a2, 0

    /* Determine the type of stack frame. */
    l32i    a2,  sp, XT_STK_EXIT        /* exit dispatcher or solicited flag */
4037a324:	0128      	l32i.n	a2, a1, 0
    bnez    a2,  .L_frxt_dispatch_stk
4037a326:	f2cc      	bnez.n	a2, 4037a339 <_frxt_dispatch+0x2d>

.L_frxt_dispatch_sol:

    /* Solicited stack frame. Restore minimal context and return from vPortYield(). */
    #if XCHAL_HAVE_THREADPTR
    l32i    a2,  sp, XT_SOL_THREADPTR
4037a328:	3128      	l32i.n	a2, a1, 12
    wur.threadptr a2
4037a32a:	f3e720        	wur.threadptr	a2
    #endif
    l32i    a3,  sp, XT_SOL_PS
4037a32d:	2138      	l32i.n	a3, a1, 8
    l32i    a12, sp, XT_SOL_A12
    l32i    a13, sp, XT_SOL_A13
    l32i    a14, sp, XT_SOL_A14
    l32i    a15, sp, XT_SOL_A15
    #endif
    l32i    a0,  sp, XT_SOL_PC
4037a32f:	1108      	l32i.n	a0, a1, 4
    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE is complete (should be, it was cleared on entry). */
    rsync
4037a331:	002010        	rsync
    #endif
    /* As soons as PS is restored, interrupts can happen. No need to sync PS. */
    wsr     a3,  PS
4037a334:	13e630        	wsr.ps	a3
    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, XT_SOL_FRMSZ
    ret
    #else
    retw
4037a337:	f01d      	retw.n

.L_frxt_dispatch_stk:

    #if XCHAL_CP_NUM > 0
    /* Restore CPENABLE from task's co-processor save area. */
    movi    a2, pxCurrentTCBs           /* cp_state =                       */
4037a339:	ea2f21        	l32r	a2, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    getcoreid a3
4037a33c:	03eb30        	rsr.prid	a3
4037a33f:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
4037a342:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0
4037a345:	002222        	l32i	a2, a2, 0
    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a348:	ea2e31        	l32r	a3, 40374c00 <_iram_text_start+0x7fc> (3fc93968 <offset_pxEndOfStack>)
4037a34b:	002332        	l32i	a3, a3, 0
4037a34e:	802230        	add	a2, a2, a3
4037a351:	0228      	l32i.n	a2, a2, 0
4037a353:	ea2c31        	l32r	a3, 40374c04 <_iram_text_start+0x800> (3fc93964 <offset_cpsa>)
4037a356:	0338      	l32i.n	a3, a3, 0
4037a358:	c02230        	sub	a2, a2, a3
4037a35b:	037c      	movi.n	a3, -16
4037a35d:	102230        	and	a2, a2, a3
    l16ui   a3, a2, XT_CPENABLE         /* CPENABLE = cp_state->cpenable;   */
4037a360:	001232        	l16ui	a3, a2, 0
    wsr     a3, CPENABLE
4037a363:	13e030        	wsr.cpenable	a3
    #endif

    /* Interrupt stack frame. Restore full context and return to exit dispatcher. */
    call0   _xt_context_restore
4037a366:	07e845        	call0	403821ec <_xt_context_restore>
    l32i    a15, sp, XT_STK_A15
    #endif

    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE has completed. */
    rsync
4037a369:	002010        	rsync
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0, sp, XT_STK_EXIT
4037a36c:	0108      	l32i.n	a0, a1, 0
    ret
4037a36e:	f00d      	ret.n

4037a370 <vPortYield>:
vPortYield:

    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, -XT_SOL_FRMSZ
    #else
    entry   sp,  XT_SOL_FRMSZ
4037a370:	004136        	entry	a1, 32
    #endif

    rsr     a2,  PS
4037a373:	03e620        	rsr.ps	a2
    s32i    a0,  sp, XT_SOL_PC
4037a376:	1109      	s32i.n	a0, a1, 4
    s32i    a2,  sp, XT_SOL_PS
4037a378:	2129      	s32i.n	a2, a1, 8
    #if XCHAL_HAVE_THREADPTR
    rur.threadptr a2
4037a37a:	e32e70        	rur.threadptr	a2
    s32i    a2,  sp, XT_SOL_THREADPTR
4037a37d:	3129      	s32i.n	a2, a1, 12
    s32i    a15, sp, XT_SOL_A15
    #else
    /* Spill register windows. Calling xthal_window_spill() causes extra    */
    /* spills and reloads, so we will set things up to call the _nw version */
    /* instead to save cycles.                                              */
    movi    a6,  ~(PS_WOE_MASK|PS_INTLEVEL_MASK)  /* spills a4-a7 if needed */
4037a37f:	ea2261        	l32r	a6, 40374c08 <_iram_text_start+0x804> (fffbfff0 <_rtc_reserved_end+0x9febfff0>)
    and     a2,  a2, a6                           /* clear WOE, INTLEVEL    */
4037a382:	102260        	and	a2, a2, a6
    addi    a2,  a2, XCHAL_EXCM_LEVEL             /* set INTLEVEL           */
4037a385:	03c222        	addi	a2, a2, 3
    wsr     a2,  PS
4037a388:	13e620        	wsr.ps	a2
    rsync
4037a38b:	002010        	rsync
    call0   xthal_window_spill_nw
4037a38e:	07c205        	call0	40381fb0 <xthal_window_spill_nw>
    l32i    a2,  sp, XT_SOL_PS                    /* restore PS             */
4037a391:	2128      	l32i.n	a2, a1, 8
    wsr     a2,  PS
4037a393:	13e620        	wsr.ps	a2
    #endif

    rsil    a2,  XCHAL_EXCM_LEVEL       /* disable low/med interrupts       */
4037a396:	006320        	rsil	a2, 3

    #if XCHAL_CP_NUM > 0
    /* Save coprocessor callee-saved state (if any). At this point CPENABLE */
    /* should still reflect which CPs were in use (enabled).                */
    call0   _xt_coproc_savecs
4037a399:	07ef05        	call0	4038228c <_xt_coproc_savecs>
    #endif

    movi    a2,  pxCurrentTCBs
4037a39c:	ea1721        	l32r	a2, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    getcoreid a3
4037a39f:	03eb30        	rsr.prid	a3
4037a3a2:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a3a5:	a02320        	addx4	a2, a3, a2
    l32i    a2,  a2, 0                  /* a2 = pxCurrentTCBs                */
4037a3a8:	0228      	l32i.n	a2, a2, 0
    movi    a3,  0
4037a3aa:	030c      	movi.n	a3, 0
    s32i    a3,  sp, XT_SOL_EXIT        /* 0 to flag as solicited frame     */
4037a3ac:	0139      	s32i.n	a3, a1, 0
    s32i    sp,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCBs->pxTopOfStack = SP  */
4037a3ae:	0219      	s32i.n	a1, a2, 0

    #if XCHAL_CP_NUM > 0
    /* Clear CPENABLE, also in task's co-processor state save area. */
    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a3b0:	ea1431        	l32r	a3, 40374c00 <_iram_text_start+0x7fc> (3fc93968 <offset_pxEndOfStack>)
4037a3b3:	0338      	l32i.n	a3, a3, 0
4037a3b5:	223a      	add.n	a2, a2, a3
4037a3b7:	0228      	l32i.n	a2, a2, 0
4037a3b9:	ea1231        	l32r	a3, 40374c04 <_iram_text_start+0x800> (3fc93964 <offset_cpsa>)
4037a3bc:	0338      	l32i.n	a3, a3, 0
4037a3be:	c02230        	sub	a2, a2, a3
4037a3c1:	037c      	movi.n	a3, -16
4037a3c3:	102230        	and	a2, a2, a3
    movi    a3,  0
4037a3c6:	030c      	movi.n	a3, 0
    wsr     a3,  CPENABLE
4037a3c8:	13e030        	wsr.cpenable	a3
    beqz    a2,  1f
4037a3cb:	002216        	beqz	a2, 4037a3d1 <vPortYield+0x61>
    s16i    a3,  a2, XT_CPENABLE        /* clear saved cpenable             */
4037a3ce:	005232        	s16i	a3, a2, 0
1:
    #endif

    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
4037a3d1:	fff385        	call0	4037a30c <_frxt_dispatch>

4037a3d4 <vPortYieldFromInt>:
    .globl  vPortYieldFromInt
    .type   vPortYieldFromInt,@function
    .align  4
vPortYieldFromInt:

    ENTRY(16)
4037a3d4:	002136        	entry	a1, 16

    #if XCHAL_CP_NUM > 0
    /* Save CPENABLE in task's co-processor save area, and clear CPENABLE.  */
    movi    a2, pxCurrentTCBs           /* cp_state =                       */
4037a3d7:	ea0821        	l32r	a2, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    getcoreid a3
4037a3da:	03eb30        	rsr.prid	a3
4037a3dd:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
4037a3e0:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0
4037a3e3:	0228      	l32i.n	a2, a2, 0

    get_cpsa_from_tcb a2, a3            /* After this, pointer to CP save area is in a2, a3 is destroyed */
4037a3e5:	ea0631        	l32r	a3, 40374c00 <_iram_text_start+0x7fc> (3fc93968 <offset_pxEndOfStack>)
4037a3e8:	0338      	l32i.n	a3, a3, 0
4037a3ea:	223a      	add.n	a2, a2, a3
4037a3ec:	0228      	l32i.n	a2, a2, 0
4037a3ee:	ea0531        	l32r	a3, 40374c04 <_iram_text_start+0x800> (3fc93964 <offset_cpsa>)
4037a3f1:	0338      	l32i.n	a3, a3, 0
4037a3f3:	c02230        	sub	a2, a2, a3
4037a3f6:	037c      	movi.n	a3, -16
4037a3f8:	102230        	and	a2, a2, a3

    rsr     a3, CPENABLE
4037a3fb:	03e030        	rsr.cpenable	a3
    s16i    a3, a2, XT_CPENABLE         /* cp_state->cpenable = CPENABLE;   */
4037a3fe:	005232        	s16i	a3, a2, 0
    movi    a3, 0
4037a401:	030c      	movi.n	a3, 0
    wsr     a3, CPENABLE                /* disable all co-processors        */
4037a403:	13e030        	wsr.cpenable	a3
    #ifdef __XTENSA_CALL0_ABI__
    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
    /* Never reaches here. */
    #else
    RET(16)
4037a406:	f01d      	retw.n

4037a408 <_frxt_task_coproc_state>:
    .align  4
_frxt_task_coproc_state:


    /* We can use a3 as a scratchpad, the instances of code calling XT_RTOS_CP_STATE don't seem to need it saved. */
    getcoreid a3
4037a408:	03eb30        	rsr.prid	a3
4037a40b:	043d30        	extui	a3, a3, 13, 1
    movi    a15, port_xSchedulerRunning /* if (port_xSchedulerRunning              */
4037a40e:	e9dbf1        	l32r	a15, 40374b7c <_iram_text_start+0x778> (3fc95278 <port_xSchedulerRunning>)
    addx4   a15, a3,a15
4037a411:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a414:	0ff8      	l32i.n	a15, a15, 0
    beqz    a15, 1f
4037a416:	afac      	beqz.n	a15, 4037a444 <_frxt_task_coproc_state+0x3c>
    movi    a15, port_interruptNesting  /* && port_interruptNesting == 0           */
4037a418:	e8bdf1        	l32r	a15, 4037470c <_iram_text_start+0x308> (3fc95270 <port_interruptNesting>)
    addx4   a15, a3, a15
4037a41b:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a41e:	0ff8      	l32i.n	a15, a15, 0
    bnez    a15, 1f
4037a420:	0fec      	bnez.n	a15, 4037a444 <_frxt_task_coproc_state+0x3c>

    movi    a15, pxCurrentTCBs
4037a422:	e9f5f1        	l32r	a15, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    addx4   a15, a3, a15
4037a425:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0                 /* && pxCurrentTCBs != 0) {                 */
4037a428:	0ff8      	l32i.n	a15, a15, 0

    beqz    a15, 2f
4037a42a:	8f9c      	beqz.n	a15, 4037a446 <_frxt_task_coproc_state+0x3e>
    get_cpsa_from_tcb a15, a3           /* After this, pointer to CP save area is in a15, a3 is destroyed */
4037a42c:	e9f531        	l32r	a3, 40374c00 <_iram_text_start+0x7fc> (3fc93968 <offset_pxEndOfStack>)
4037a42f:	0338      	l32i.n	a3, a3, 0
4037a431:	ff3a      	add.n	a15, a15, a3
4037a433:	0ff8      	l32i.n	a15, a15, 0
4037a435:	e9f331        	l32r	a3, 40374c04 <_iram_text_start+0x800> (3fc93964 <offset_cpsa>)
4037a438:	0338      	l32i.n	a3, a3, 0
4037a43a:	c0ff30        	sub	a15, a15, a3
4037a43d:	037c      	movi.n	a3, -16
4037a43f:	10ff30        	and	a15, a15, a3
    ret
4037a442:	f00d      	ret.n

1:  movi    a15, 0
4037a444:	0f0c      	movi.n	a15, 0
2:  ret
4037a446:	f00d      	ret.n

4037a448 <_frxt_coproc_exc_hook>:
    .type   _frxt_coproc_exc_hook,@function
    .align  4
_frxt_coproc_exc_hook:

    #if configNUM_CORES > 1
    getcoreid a2                            /* a2 = xCurCoreID */
4037a448:	03eb20        	rsr.prid	a2
4037a44b:	042d20        	extui	a2, a2, 13, 1
    /* if (port_xSchedulerRunning[xCurCoreID] == 0) */
    movi    a3, port_xSchedulerRunning
4037a44e:	e9cb31        	l32r	a3, 40374b7c <_iram_text_start+0x778> (3fc95278 <port_xSchedulerRunning>)
    addx4   a3, a2, a3
4037a451:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a454:	0338      	l32i.n	a3, a3, 0
    beqz    a3, 1f                          /* Scheduler hasn't started yet. Return. */
4037a456:	a39c      	beqz.n	a3, 4037a474 <_frxt_coproc_exc_hook+0x2c>
    /* if (port_interruptNesting[xCurCoreID] != 0) */
    movi    a3, port_interruptNesting
4037a458:	e8ad31        	l32r	a3, 4037470c <_iram_text_start+0x308> (3fc95270 <port_interruptNesting>)
    addx4   a3, a2, a3
4037a45b:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a45e:	0338      	l32i.n	a3, a3, 0
    bnez    a3, 1f                          /* We are in an interrupt. Return*/
4037a460:	03dc      	bnez.n	a3, 4037a474 <_frxt_coproc_exc_hook+0x2c>
    /* CP operations are incompatible with unpinned tasks. Thus we pin the task
    to the current running core. */
    movi    a3, pxCurrentTCBs
4037a462:	e9e531        	l32r	a3, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
    addx4   a3, a2, a3
4037a465:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0                       /* a3 = pxCurrentTCBs[xCurCoreID] */
4037a468:	0338      	l32i.n	a3, a3, 0
    movi    a4, offset_xCoreID
4037a46a:	e9e841        	l32r	a4, 40374c0c <_iram_text_start+0x808> (3fc93960 <offset_xCoreID>)
    l32i    a4, a4, 0                       /* a4 = offset_xCoreID */
4037a46d:	0448      	l32i.n	a4, a4, 0
    add     a3, a3, a4                      /* a3 = &TCB.xCoreID */
4037a46f:	334a      	add.n	a3, a3, a4
    s32i    a2, a3, 0                       /* TCB.xCoreID = xCurCoreID */
4037a471:	006322        	s32i	a2, a3, 0
1:
    #endif /* configNUM_CORES > 1 */

    ret
4037a474:	f00d      	ret.n
	...

4037a478 <pvPortMalloc>:
#define portFREERTOS_HEAP_CAPS    ( MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT )

/*-----------------------------------------------------------*/

void * pvPortMalloc(size_t xWantedSize)
{
4037a478:	004136        	entry	a1, 32
4037a47b:	20a220        	or	a10, a2, a2

    /* All dynamic allocation done by FreeRTOS goes through this function. If
     * users need to allocate FreeRTOS objects into external RAM, they should
     * use the "static" equivalents of FreeRTOS API to create FreeRTOS objects
     * (e.g., queues). */
    pvReturn = heap_caps_malloc(xWantedSize, portFREERTOS_HEAP_CAPS);
4037a47e:	e9e4b1        	l32r	a11, 40374c10 <_iram_text_start+0x80c> (804 <UserFrameTotalSize+0x704>)
4037a481:	fba425        	call8	40375ec4 <heap_caps_malloc>

    return pvReturn;
}
4037a484:	202aa0        	or	a2, a10, a10
4037a487:	000090        	retw
	...

4037a48c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree(void * pv)
{
4037a48c:	004136        	entry	a1, 32
4037a48f:	02ad      	mov.n	a10, a2
    heap_caps_free(pv);
4037a491:	fbca25        	call8	40376134 <heap_caps_free>
}
4037a494:	f01d      	retw.n
	...

4037a498 <xPortCheckValidTCBMem>:
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
#endif /* CONFIG_IDF_TARGET_LINUX */
}

bool xPortCheckValidTCBMem(const void * ptr)
{
4037a498:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037a49b:	e87091        	l32r	a9, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
4037a49e:	929a      	add.n	a9, a2, a9
4037a4a0:	e9dd81        	l32r	a8, 40374c14 <_iram_text_start+0x810> (757fff <UserFrameTotalSize+0x757eff>)
4037a4a3:	628890        	saltu	a8, a8, a9
4037a4a6:	880b      	addi.n	a8, a8, -1
4037a4a8:	608080        	neg	a8, a8
4037a4ab:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037a4ae:	e9da91        	l32r	a9, 40374c18 <_iram_text_start+0x814> (b0000000 <_rtc_reserved_end+0x4ff00000>)
4037a4b1:	929a      	add.n	a9, a2, a9
4037a4b3:	e84bb1        	l32r	a11, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
4037a4b6:	629b90        	saltu	a9, a11, a9
4037a4b9:	990b      	addi.n	a9, a9, -1
4037a4bb:	609090        	neg	a9, a9
4037a4be:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037a4c1:	e846c1        	l32r	a12, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4037a4c4:	c2ca      	add.n	a12, a2, a12
4037a4c6:	62bbc0        	saltu	a11, a11, a12
4037a4c9:	bb0b      	addi.n	a11, a11, -1
4037a4cb:	60b0b0        	neg	a11, a11
4037a4ce:	74b0b0        	extui	a11, a11, 0, 8
#if CONFIG_IDF_TARGET_LINUX
    return true;
#else /* CONFIG_IDF_TARGET_LINUX */
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037a4d1:	208890        	or	a8, a8, a9
4037a4d4:	08cc      	bnez.n	a8, 4037a4d8 <xPortCheckValidTCBMem+0x40>
4037a4d6:	eb8c      	beqz.n	a11, 4037a4e8 <xPortCheckValidTCBMem+0x50>
4037a4d8:	20a220        	or	a10, a2, a2
4037a4db:	fda765        	call8	40377f50 <esp_ptr_byte_accessible>
4037a4de:	00ba16        	beqz	a10, 4037a4ed <xPortCheckValidTCBMem+0x55>
4037a4e1:	01a022        	movi	a2, 1
4037a4e4:	0001c6        	j	4037a4ef <xPortCheckValidTCBMem+0x57>
4037a4e7:	020c00        	andb	b0, b12, b0
4037a4ea:	000046        	j	4037a4ef <xPortCheckValidTCBMem+0x57>
4037a4ed:	020c      	movi.n	a2, 0
#endif /* CONFIG_IDF_TARGET_LINUX */
}
4037a4ef:	f01d      	retw.n
4037a4f1:	000000        	ill

4037a4f4 <xPortcheckValidStackMem>:

bool xPortcheckValidStackMem(const void * ptr)
{
4037a4f4:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037a4f7:	e85991        	l32r	a9, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
4037a4fa:	929a      	add.n	a9, a2, a9
4037a4fc:	e9c681        	l32r	a8, 40374c14 <_iram_text_start+0x810> (757fff <UserFrameTotalSize+0x757eff>)
4037a4ff:	628890        	saltu	a8, a8, a9
4037a502:	880b      	addi.n	a8, a8, -1
4037a504:	608080        	neg	a8, a8
4037a507:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037a50a:	e9c391        	l32r	a9, 40374c18 <_iram_text_start+0x814> (b0000000 <_rtc_reserved_end+0x4ff00000>)
4037a50d:	929a      	add.n	a9, a2, a9
4037a50f:	e834b1        	l32r	a11, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
4037a512:	629b90        	saltu	a9, a11, a9
4037a515:	990b      	addi.n	a9, a9, -1
4037a517:	609090        	neg	a9, a9
4037a51a:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037a51d:	e82fc1        	l32r	a12, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4037a520:	c2ca      	add.n	a12, a2, a12
4037a522:	62bbc0        	saltu	a11, a11, a12
4037a525:	bb0b      	addi.n	a11, a11, -1
4037a527:	60b0b0        	neg	a11, a11
4037a52a:	74b0b0        	extui	a11, a11, 0, 8
    return true;
#else /* CONFIG_IDF_TARGET_LINUX */
#ifdef CONFIG_FREERTOS_TASK_CREATE_ALLOW_EXT_MEM
    return esp_ptr_byte_accessible(ptr);
#else
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037a52d:	208890        	or	a8, a8, a9
4037a530:	08cc      	bnez.n	a8, 4037a534 <xPortcheckValidStackMem+0x40>
4037a532:	db8c      	beqz.n	a11, 4037a543 <xPortcheckValidStackMem+0x4f>
4037a534:	20a220        	or	a10, a2, a2
4037a537:	fda1a5        	call8	40377f50 <esp_ptr_byte_accessible>
4037a53a:	00aa16        	beqz	a10, 4037a548 <xPortcheckValidStackMem+0x54>
4037a53d:	01a022        	movi	a2, 1
4037a540:	000186        	j	4037a54a <xPortcheckValidStackMem+0x56>
4037a543:	020c      	movi.n	a2, 0
4037a545:	000046        	j	4037a54a <xPortcheckValidStackMem+0x56>
4037a548:	020c      	movi.n	a2, 0
#endif
#endif /* CONFIG_IDF_TARGET_LINUX */
}
4037a54a:	f01d      	retw.n

4037a54c <vApplicationGetIdleTaskMemory>:
*/
#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                   StackType_t **ppxIdleTaskStackBuffer,
                                   uint32_t *pulIdleTaskStackSize)
{
4037a54c:	004136        	entry	a1, 32
        pxTCBBufferTemp = pvPortMalloc(sizeof(StaticTask_t));
        pxStackBufferTemp = pvPortMalloc(configMINIMAL_STACK_SIZE);
    }
#else /* portSTACK_GROWTH */
    {
        pxStackBufferTemp = pvPortMalloc(configMINIMAL_STACK_SIZE);
4037a54f:	00a6a2        	movi	a10, 0x600
4037a552:	fff265        	call8	4037a478 <pvPortMalloc>
4037a555:	0a7d      	mov.n	a7, a10
        pxTCBBufferTemp = pvPortMalloc(sizeof(StaticTask_t));
4037a557:	54a1a2        	movi	a10, 0x154
4037a55a:	fff1e5        	call8	4037a478 <pvPortMalloc>
    }
#endif /* portSTACK_GROWTH */

    assert(pxTCBBufferTemp != NULL);
4037a55d:	00da56        	bnez	a10, 4037a56e <vApplicationGetIdleTaskMemory+0x22>
4037a560:	e9afd1        	l32r	a13, 40374c1c <_iram_text_start+0x818> (3c023b68 <_flash_rodata_start+0x3a48>)
4037a563:	e9afc1        	l32r	a12, 40374c20 <_iram_text_start+0x81c> (3c027370 <__func__$1>)
4037a566:	4b3c      	movi.n	a11, 52
4037a568:	e9afa1        	l32r	a10, 40374c24 <_iram_text_start+0x820> (3c023b9a <_flash_rodata_start+0x3a7a>)
4037a56b:	057be5        	call8	4037fd28 <__assert_func>
    assert(pxStackBufferTemp != NULL);
4037a56e:	c7cc      	bnez.n	a7, 4037a57e <vApplicationGetIdleTaskMemory+0x32>
4037a570:	e9aed1        	l32r	a13, 40374c28 <_iram_text_start+0x824> (3c023ba8 <_flash_rodata_start+0x3a88>)
4037a573:	e9abc1        	l32r	a12, 40374c20 <_iram_text_start+0x81c> (3c027370 <__func__$1>)
4037a576:	5b3c      	movi.n	a11, 53
4037a578:	e9aba1        	l32r	a10, 40374c24 <_iram_text_start+0x820> (3c023b9a <_flash_rodata_start+0x3a7a>)
4037a57b:	057ae5        	call8	4037fd28 <__assert_func>
    //Write back pointers
    *ppxIdleTaskTCBBuffer = pxTCBBufferTemp;
4037a57e:	02a9      	s32i.n	a10, a2, 0
    *ppxIdleTaskStackBuffer = pxStackBufferTemp;
4037a580:	0379      	s32i.n	a7, a3, 0
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
4037a582:	00a682        	movi	a8, 0x600
4037a585:	0489      	s32i.n	a8, a4, 0
}
4037a587:	f01d      	retw.n
4037a589:	000000        	ill

4037a58c <vSystimerSetup>:
 * Both timer alarms are configured in periodic mode.
 * It is done at the same time so SysTicks for both CPUs occur at the same time or very close.
 * Shifts a time of triggering interrupts for core 0 and core 1.
 */
void vSystimerSetup(void)
{
4037a58c:	006136        	entry	a1, 48
4037a58f:	03eb70        	rsr.prid	a7
4037a592:	047d70        	extui	a7, a7, 13, 1
#endif
    /* Systimer HAL layer object */
    static systimer_hal_context_t systimer_hal;
    /* set system timer interrupt vector */

    ESP_ERROR_CHECK(esp_intr_alloc(ETS_SYSTIMER_TARGET0_INTR_SOURCE + cpuid, ESP_INTR_FLAG_IRAM | level, SysTickIsrHandler, &systimer_hal, NULL));
4037a595:	00a0e2        	movi	a14, 0
4037a598:	e9a5d1        	l32r	a13, 40374c2c <_iram_text_start+0x828> (3fc95280 <systimer_hal$1>)
4037a59b:	e9a5c1        	l32r	a12, 40374c30 <_iram_text_start+0x82c> (4037a70c <SysTickIsrHandler>)
4037a59e:	02a4b2        	movi	a11, 0x402
4037a5a1:	39c7a2        	addi	a10, a7, 57
4037a5a4:	e9aa81        	l32r	a8, 40374c4c <_iram_text_start+0x848> (42003a18 <esp_intr_alloc>)
4037a5a7:	0008e0        	callx8	a8
4037a5aa:	00ea16        	beqz	a10, 4037a5bc <vSystimerSetup+0x30>
4037a5ad:	e9a1e1        	l32r	a14, 40374c34 <_iram_text_start+0x830> (3c023bc4 <_flash_rodata_start+0x3aa4>)
4037a5b0:	e9a2d1        	l32r	a13, 40374c38 <_iram_text_start+0x834> (3c027398 <__func__$0>)
4037a5b3:	48a0c2        	movi	a12, 72
4037a5b6:	e9a1b1        	l32r	a11, 40374c3c <_iram_text_start+0x838> (3c023c44 <_flash_rodata_start+0x3b24>)
4037a5b9:	ff0c25        	call8	4037967c <_esp_error_check_failed>

    if (cpuid == 0) {
4037a5bc:	044716        	beqz	a7, 4037a604 <vSystimerSetup+0x78>
4037a5bf:	004386        	j	4037a6d1 <vSystimerSetup+0x145>
4037a5c2:	810000        	src	a0, a0, a0
 *
 * @param enable true to enable, false to disable
 */
static inline void systimer_ll_enable_bus_clock(bool enable)
{
    SYSTEM.perip_clk_en0.systimer_clk_en = enable;
4037a5c5:	c0e922        	s32c1i	a2, a9, 0x300
4037a5c8:	20          	.byte	0x20
4037a5c9:	00          	.byte	00
4037a5ca:	062892        	l32i	a9, a8, 24
4037a5cd:	e8f1a1        	l32r	a10, 40374994 <_iram_text_start+0x590> (20000000 <UserFrameTotalSize+0x1fffff00>)
4037a5d0:	2099a0        	or	a9, a9, a10
4037a5d3:	0020c0        	memw
4037a5d6:	066892        	s32i	a9, a8, 24
 *
 * @param group_id Group ID
 */
static inline void systimer_ll_reset_register(void)
{
    SYSTEM.perip_rst_en0.systimer_rst = 1;
4037a5d9:	0020c0        	memw
4037a5dc:	082892        	l32i	a9, a8, 32
4037a5df:	2099a0        	or	a9, a9, a10
4037a5e2:	0020c0        	memw
4037a5e5:	8899      	s32i.n	a9, a8, 32
    SYSTEM.perip_rst_en0.systimer_rst = 0;
4037a5e7:	0020c0        	memw
4037a5ea:	8898      	l32i.n	a9, a8, 32
4037a5ec:	e875a1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037a5ef:	1099a0        	and	a9, a9, a10
4037a5f2:	0020c0        	memw
4037a5f5:	8899      	s32i.n	a9, a8, 32
        PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_SYSTIMER_MODULE, ref_count) {
4037a5f7:	4a2c      	movi.n	a10, 36
4037a5f9:	fdc065        	call8	40378200 <periph_rcc_acquire_exit>
4037a5fc:	660b      	addi.n	a6, a6, -1
4037a5fe:	746060        	extui	a6, a6, 0, 8
4037a601:	000086        	j	4037a607 <vSystimerSetup+0x7b>
4037a604:	01a062        	movi	a6, 1
4037a607:	00e616        	beqz	a6, 4037a619 <vSystimerSetup+0x8d>
4037a60a:	24a0a2        	movi	a10, 36
4037a60d:	fdbe25        	call8	403781f0 <periph_rcc_acquire_enter>
4037a610:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
4037a612:	faea16        	beqz	a10, 4037a5c4 <vSystimerSetup+0x38>
4037a615:	fff786        	j	4037a5f7 <vSystimerSetup+0x6b>
4037a618:	846100        	extui	a6, a0, 1, 9
                systimer_ll_enable_bus_clock(true);
                systimer_ll_reset_register();
            }
        }
        systimer_hal_init(&systimer_hal);
4037a61b:	60e9      	s32i.n	a14, a0, 24
4037a61d:	a520a6        	blti	a0, 2, 4037a5c6 <vSystimerSetup+0x3a>
4037a620:	878103cf 	ee.ldf.128.ip	f14, f3, f0, f8, a12, 48
        systimer_hal_tick_rate_ops_t ops = {
4037a624:	92e9      	s32i.n	a14, a2, 36
4037a626:	0028      	l32i.n	a2, a0, 0
4037a628:	1888      	l32i.n	a8, a8, 4
4037a62a:	0199      	s32i.n	a9, a1, 0
4037a62c:	1189      	s32i.n	a8, a1, 4
            .ticks_to_us = systimer_ticks_to_us,
            .us_to_ticks = systimer_us_to_ticks,
        };
        systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
4037a62e:	01bd      	mov.n	a11, a1
4037a630:	06ad      	mov.n	a10, a6
4037a632:	03e6a5        	call8	4037e49c <systimer_hal_set_tick_rate_ops>
        systimer_ll_set_counter_value(systimer_hal.dev, SYSTIMER_COUNTER_OS_TICK, 0);
4037a635:	0698      	l32i.n	a9, a6, 0
    return dev->unit_op[counter_id].timer_unit_value_valid;
}

__attribute__((always_inline)) static inline void systimer_ll_set_counter_value(systimer_dev_t *dev, uint32_t counter_id, uint64_t value)
{
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037a637:	0020c0        	memw
4037a63a:	5988      	l32i.n	a8, a9, 20
4037a63c:	b58480        	extui	a8, a8, 20, 12
4037a63f:	0188c0        	slli	a8, a8, 20
4037a642:	0020c0        	memw
4037a645:	5989      	s32i.n	a8, a9, 20
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037a647:	080c      	movi.n	a8, 0
4037a649:	0020c0        	memw
4037a64c:	6989      	s32i.n	a8, a9, 24
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
}

__attribute__((always_inline)) static inline void systimer_ll_apply_counter_value(systimer_dev_t *dev, uint32_t counter_id)
{
    dev->unit_load[counter_id].val = 0x01;
4037a64e:	180c      	movi.n	a8, 1
4037a650:	0020c0        	memw
4037a653:	186982        	s32i	a8, a9, 96
        systimer_ll_apply_counter_value(systimer_hal.dev, SYSTIMER_COUNTER_OS_TICK);

        for (cpuid = 0; cpuid < SOC_CPU_CORES_NUM; cpuid++) {
4037a656:	076d      	mov.n	a6, a7
4037a658:	0006c6        	j	4037a677 <vSystimerSetup+0xeb>
4037a65b:	d20000        	quos	a0, a0, a0
            // Set stall option and alarm mode to default state. Below they will be set to a required state.
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, cpuid, false);
4037a65e:	6000a0        	neg	a0, a10
4037a661:	0c20c6        	j	4037d6e8 <spimem_flash_ll_set_read_mode+0x58>
4037a664:	a11b      	addi.n	a10, a1, 1
4037a666:	a5e971        	l32r	a7, 40363e0c <rom_rx_gain_force+0x35d9e0>
4037a669:	03ea      	add.n	a0, a3, a14
            uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_ONESHOT);
4037a66b:	0c0c      	movi.n	a12, 0
4037a66d:	06bd      	mov.n	a11, a6
4037a66f:	e96fa1        	l32r	a10, 40374c2c <_iram_text_start+0x828> (3fc95280 <systimer_hal$1>)
4037a672:	03dea5        	call8	4037e45c <systimer_hal_select_alarm_mode>
        for (cpuid = 0; cpuid < SOC_CPU_CORES_NUM; cpuid++) {
4037a675:	661b      	addi.n	a6, a6, 1
4037a677:	e226b6        	bltui	a6, 2, 4037a65d <vSystimerSetup+0xd1>
4037a67a:	001306        	j	4037a6ca <vSystimerSetup+0x13e>

        for (cpuid = 0; cpuid < configNUM_CORES; ++cpuid) {
            uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;

            /* configure the timer */
            systimer_hal_connect_alarm_counter(&systimer_hal, alarm_id, SYSTIMER_COUNTER_OS_TICK);
4037a67d:	e96b61        	l32r	a6, 40374c2c <_iram_text_start+0x828> (3fc95280 <systimer_hal$1>)
4037a680:	1c0c      	movi.n	a12, 1
4037a682:	07bd      	mov.n	a11, a7
4037a684:	06ad      	mov.n	a10, a6
4037a686:	03e6a5        	call8	4037e4f0 <systimer_hal_connect_alarm_counter>
            systimer_hal_set_alarm_period(&systimer_hal, alarm_id, 1000000UL / CONFIG_FREERTOS_HZ);
4037a689:	e96ec1        	l32r	a12, 40374c44 <_iram_text_start+0x840> (2710 <UserFrameTotalSize+0x2610>)
4037a68c:	07bd      	mov.n	a11, a7
4037a68e:	06ad      	mov.n	a10, a6
4037a690:	03cf25        	call8	4037e384 <systimer_hal_set_alarm_period>
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_PERIOD);
4037a693:	1c0c      	movi.n	a12, 1
4037a695:	07bd      	mov.n	a11, a7
4037a697:	06ad      	mov.n	a10, a6
4037a699:	03dc25        	call8	4037e45c <systimer_hal_select_alarm_mode>
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, cpuid, true);
4037a69c:	1d0c      	movi.n	a13, 1
4037a69e:	07cd      	mov.n	a12, a7
4037a6a0:	0dbd      	mov.n	a11, a13
4037a6a2:	06ad      	mov.n	a10, a6
4037a6a4:	03e6e5        	call8	4037e514 <systimer_hal_counter_can_stall_by_cpu>
            if (cpuid == 0) {
4037a6a7:	d7dc      	bnez.n	a7, 4037a6c8 <vSystimerSetup+0x13c>
                systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a6a9:	e96061        	l32r	a6, 40374c2c <_iram_text_start+0x828> (3fc95280 <systimer_hal$1>)
4037a6ac:	07bd      	mov.n	a11, a7
4037a6ae:	20a660        	or	a10, a6, a6
4037a6b1:	03dfa5        	call8	4037e4ac <systimer_hal_enable_alarm_int>
                systimer_hal_enable_counter(&systimer_hal, SYSTIMER_COUNTER_OS_TICK);
4037a6b4:	1b0c      	movi.n	a11, 1
4037a6b6:	20a660        	or	a10, a6, a6
4037a6b9:	03e125        	call8	4037e4cc <systimer_hal_enable_counter>
#ifndef CONFIG_FREERTOS_UNICORE
                // SysTick of core 0 and core 1 are shifted by half of period
                systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_COUNTER_OS_TICK, 1000000UL / CONFIG_FREERTOS_HZ / 2);
4037a6bc:	e963c1        	l32r	a12, 40374c48 <_iram_text_start+0x844> (1388 <UserFrameTotalSize+0x1288>)
4037a6bf:	0d0c      	movi.n	a13, 0
4037a6c1:	1b0c      	movi.n	a11, 1
4037a6c3:	06ad      	mov.n	a10, a6
4037a6c5:	03d425        	call8	4037e408 <systimer_hal_counter_value_advance>
        for (cpuid = 0; cpuid < configNUM_CORES; ++cpuid) {
4037a6c8:	771b      	addi.n	a7, a7, 1
4037a6ca:	af27b6        	bltui	a7, 2, 4037a67d <vSystimerSetup+0xf1>
4037a6cd:	000206        	j	4037a6d9 <vSystimerSetup+0x14d>
4037a6d0:	07bd00        	ee.stf.64.xp	f11, f0, a0, a13
#endif
            }
        }
    } else {
        uint32_t alarm_id = SYSTIMER_ALARM_OS_TICK_CORE0 + cpuid;
        systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a6d3:	e956a1        	l32r	a10, 40374c2c <_iram_text_start+0x828> (3fc95280 <systimer_hal$1>)
4037a6d6:	03dd65        	call8	4037e4ac <systimer_hal_enable_alarm_int>
    }
}
4037a6d9:	f01d      	retw.n
	...

4037a6dc <vPortSetupTimer>:
 *
 * - CCOUNT timer is used if CONFIG_FREERTOS_SYSTICK_USES_CCOUNT is set
 * - SYSTIMER is used if CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER is set
 */
void vPortSetupTimer(void)
{
4037a6dc:	004136        	entry	a1, 32
    extern void _xt_tick_divisor_init(void);
    /* Init the tick divisor value */
    _xt_tick_divisor_init();
    _frxt_tick_timer_init();
#else /* CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER */
    vSystimerSetup();
4037a6df:	ffeae5        	call8	4037a58c <vSystimerSetup>
#endif /* CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER */
}
4037a6e2:	f01d      	retw.n

4037a6e4 <xPortSysTickHandler>:
 *  - _frxt_timer_int for xtensa with CONFIG_FREERTOS_SYSTICK_USES_CCOUNT
 *  - SysTickIsrHandler for xtensa with CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER
 *  - SysTickIsrHandler for riscv
 */
BaseType_t xPortSysTickHandler(void)
{
4037a6e4:	004136        	entry	a1, 32
#endif //configBENCHMARK
    traceISR_ENTER(SYSTICK_INTR_ID);

    // Call IDF Tick Hook
    extern void esp_vApplicationTickHook(void);
    esp_vApplicationTickHook();
4037a6e7:	fb68a5        	call8	40375d70 <esp_vApplicationTickHook>
4037a6ea:	03eb80        	rsr.prid	a8
4037a6ed:	048d80        	extui	a8, a8, 13, 1
    /*
    Multi-core IDF FreeRTOS requires that...
        - core 0 calls xTaskIncrementTick()
        - core 1 calls xTaskIncrementTickOtherCores()
    */
    if (xPortGetCoreID() == 0) {
4037a6f0:	009856        	bnez	a8, 4037a6fd <xPortSysTickHandler+0x19>
        xSwitchRequired = xTaskIncrementTick();
4037a6f3:	009fe5        	call8	4037b0f0 <xTaskIncrementTick>
4037a6f6:	0a2d      	mov.n	a2, a10
4037a6f8:	0001c6        	j	4037a703 <xPortSysTickHandler+0x1f>
4037a6fb:	250000        	extui	a0, a0, 16, 3
    } else {
        xSwitchRequired = xTaskIncrementTickOtherCores();
4037a6fe:	a001d3        	lsi	f13, a1, 0x280
4037a701:	202a      	add.n	a2, a0, a2
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
#endif /* configNUM_CORES > 1 */
#endif /* !CONFIG_FREERTOS_SMP */

    // Check if yield is required
    if (xSwitchRequired != pdFALSE) {
4037a703:	002216        	beqz	a2, 4037a709 <xPortSysTickHandler+0x25>
        portYIELD_FROM_ISR();
4037a706:	ffb5a5        	call8	4037a260 <_frxt_setup_switch>
    } else {
        traceISR_EXIT();
    }
    return xSwitchRequired;
}
4037a709:	f01d      	retw.n
	...

4037a70c <SysTickIsrHandler>:
{
4037a70c:	004136        	entry	a1, 32
4037a70f:	03eb60        	rsr.prid	a6
4037a712:	046d60        	extui	a6, a6, 13, 1
        systimer_ll_clear_alarm_int(systimer_hal->dev, alarm_id);
4037a715:	002292        	l32i	a9, a2, 0
    return dev->int_st.val & (1 << alarm_id);
}

__attribute__((always_inline)) static inline void systimer_ll_clear_alarm_int(systimer_dev_t *dev, uint32_t alarm_id)
{
    dev->int_clr.val |= 1 << alarm_id;
4037a718:	0020c0        	memw
4037a71b:	1b2982        	l32i	a8, a9, 108
4037a71e:	01a0b2        	movi	a11, 1
4037a721:	401600        	ssl	a6
4037a724:	a15b00        	sll	a5, a11
4037a727:	208850        	or	a8, a8, a5
4037a72a:	0020c0        	memw
4037a72d:	1b6982        	s32i	a8, a9, 108
        uint32_t diff = systimer_hal_get_counter_value(systimer_hal, SYSTIMER_COUNTER_OS_TICK) / systimer_ll_get_alarm_period(systimer_hal->dev, alarm_id) - s_handled_systicks[cpuid];
4037a730:	20a220        	or	a10, a2, a2
4037a733:	03c025        	call8	4037e334 <systimer_hal_get_counter_value>
4037a736:	0298      	l32i.n	a9, a2, 0
    return dev->target_conf[alarm_id].target_period;
4037a738:	86cb      	addi.n	a8, a6, 12
4037a73a:	a08890        	addx4	a8, a8, a9
4037a73d:	0020c0        	memw
4037a740:	18c8      	l32i.n	a12, a8, 4
4037a742:	11cca0        	slli	a12, a12, 6
4037a745:	41c6c0        	srli	a12, a12, 6
4037a748:	0d0c      	movi.n	a13, 0
4037a74a:	e76a81        	l32r	a8, 403744f4 <_iram_text_start+0xf0> (40002544 <__udivdi3>)
4037a74d:	0008e0        	callx8	a8
4037a750:	e94081        	l32r	a8, 40374c50 <_iram_text_start+0x84c> (3fc9528c <s_handled_systicks>)
4037a753:	a08680        	addx4	a8, a6, a8
4037a756:	0888      	l32i.n	a8, a8, 0
4037a758:	c07a80        	sub	a7, a10, a8
        if (diff > 0) {
4037a75b:	1f1a87        	beq	a10, a8, 4037a77e <SysTickIsrHandler+0x72>
            if (s_handled_systicks[cpuid] == 0) {
4037a75e:	b8cc      	bnez.n	a8, 4037a76d <SysTickIsrHandler+0x61>
                s_handled_systicks[cpuid] = diff;
4037a760:	e93c81        	l32r	a8, 40374c50 <_iram_text_start+0x84c> (3fc9528c <s_handled_systicks>)
4037a763:	a08680        	addx4	a8, a6, a8
4037a766:	0879      	s32i.n	a7, a8, 0
                diff = 1;
4037a768:	170c      	movi.n	a7, 1
4037a76a:	0001c6        	j	4037a775 <SysTickIsrHandler+0x69>
                s_handled_systicks[cpuid] += diff;
4037a76d:	e93881        	l32r	a8, 40374c50 <_iram_text_start+0x84c> (3fc9528c <s_handled_systicks>)
4037a770:	a08680        	addx4	a8, a6, a8
4037a773:	08a9      	s32i.n	a10, a8, 0
                xPortSysTickHandler();
4037a775:	fff6e5        	call8	4037a6e4 <xPortSysTickHandler>
            } while (--diff);
4037a778:	ffc772        	addi	a7, a7, -1
4037a77b:	ff6756        	bnez	a7, 4037a775 <SysTickIsrHandler+0x69>
    } while (systimer_ll_is_alarm_int_fired(systimer_hal->dev, alarm_id));
4037a77e:	002282        	l32i	a8, a2, 0
    return dev->int_st.val & (1 << alarm_id);
4037a781:	0020c0        	memw
4037a784:	1c2882        	l32i	a8, a8, 112
4037a787:	8a8587        	bany	a5, a8, 4037a715 <SysTickIsrHandler+0x9>
}
4037a78a:	000090        	retw
4037a78d:	000000        	ill

4037a790 <prvGetDisinheritPriorityAfterTimeout>:
    {
4037a790:	004136        	entry	a1, 32
4037a793:	028d      	mov.n	a8, a2
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
4037a795:	0020c0        	memw
4037a798:	9228      	l32i.n	a2, a2, 36
4037a79a:	e28c      	beqz.n	a2, 4037a7ac <prvGetDisinheritPriorityAfterTimeout+0x1c>
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
4037a79c:	0020c0        	memw
4037a79f:	c888      	l32i.n	a8, a8, 48
4037a7a1:	0020c0        	memw
4037a7a4:	0828      	l32i.n	a2, a8, 0
4037a7a6:	e7c222        	addi	a2, a2, -25
4037a7a9:	602020        	neg	a2, a2
    }
4037a7ac:	f01d      	retw.n
	...

4037a7b0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
4037a7b0:	004136        	entry	a1, 32
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a7b3:	828b      	addi.n	a8, a2, 8
4037a7b5:	0020c0        	memw
4037a7b8:	1289      	s32i.n	a8, a2, 4

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
4037a7ba:	f97c      	movi.n	a9, -1
4037a7bc:	0020c0        	memw
4037a7bf:	2299      	s32i.n	a9, a2, 8

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a7c1:	0020c0        	memw
4037a7c4:	3289      	s32i.n	a8, a2, 12
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037a7c6:	0020c0        	memw
4037a7c9:	4289      	s32i.n	a8, a2, 16
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
4037a7cb:	080c      	movi.n	a8, 0
4037a7cd:	0020c0        	memw
4037a7d0:	0289      	s32i.n	a8, a2, 0

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
4037a7d2:	f01d      	retw.n

4037a7d4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
4037a7d4:	004136        	entry	a1, 32
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
4037a7d7:	080c      	movi.n	a8, 0
4037a7d9:	0020c0        	memw
4037a7dc:	4289      	s32i.n	a8, a2, 16

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
4037a7de:	f01d      	retw.n

4037a7e0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
4037a7e0:	004136        	entry	a1, 32
    ListItem_t * const pxIndex = pxList->pxIndex;
4037a7e3:	0020c0        	memw
4037a7e6:	1288      	l32i.n	a8, a2, 4
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
4037a7e8:	0020c0        	memw
4037a7eb:	1389      	s32i.n	a8, a3, 4
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
4037a7ed:	0020c0        	memw
4037a7f0:	2898      	l32i.n	a9, a8, 8
4037a7f2:	0020c0        	memw
4037a7f5:	2399      	s32i.n	a9, a3, 8

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
4037a7f7:	0020c0        	memw
4037a7fa:	2898      	l32i.n	a9, a8, 8
4037a7fc:	0020c0        	memw
4037a7ff:	1939      	s32i.n	a3, a9, 4
    pxIndex->pxPrevious = pxNewListItem;
4037a801:	0020c0        	memw
4037a804:	2839      	s32i.n	a3, a8, 8

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
4037a806:	0020c0        	memw
4037a809:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037a80b:	0020c0        	memw
4037a80e:	0288      	l32i.n	a8, a2, 0
4037a810:	881b      	addi.n	a8, a8, 1
4037a812:	0020c0        	memw
4037a815:	0289      	s32i.n	a8, a2, 0
}
4037a817:	f01d      	retw.n
4037a819:	000000        	ill

4037a81c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
4037a81c:	004136        	entry	a1, 32
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
4037a81f:	0020c0        	memw
4037a822:	03a8      	l32i.n	a10, a3, 0
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
4037a824:	080a66        	bnei	a10, -1, 4037a830 <vListInsert+0x14>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
4037a827:	0020c0        	memw
4037a82a:	4288      	l32i.n	a8, a2, 16
4037a82c:	0005c6        	j	4037a847 <vListInsert+0x2b>
4037a82f:	828b00        	mull	a8, a11, a0
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
4037a832:	000106        	j	4037a83a <vListInsert+0x1e>
4037a835:	0020c0        	memw
4037a838:	1888      	l32i.n	a8, a8, 4
4037a83a:	0020c0        	memw
4037a83d:	1898      	l32i.n	a9, a8, 4
4037a83f:	0020c0        	memw
4037a842:	0998      	l32i.n	a9, a9, 0
4037a844:	edba97        	bgeu	a10, a9, 4037a835 <vListInsert+0x19>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
4037a847:	0020c0        	memw
4037a84a:	1898      	l32i.n	a9, a8, 4
4037a84c:	0020c0        	memw
4037a84f:	1399      	s32i.n	a9, a3, 4
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
4037a851:	0020c0        	memw
4037a854:	1398      	l32i.n	a9, a3, 4
4037a856:	0020c0        	memw
4037a859:	2939      	s32i.n	a3, a9, 8
    pxNewListItem->pxPrevious = pxIterator;
4037a85b:	0020c0        	memw
4037a85e:	2389      	s32i.n	a8, a3, 8
    pxIterator->pxNext = pxNewListItem;
4037a860:	0020c0        	memw
4037a863:	1839      	s32i.n	a3, a8, 4

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
4037a865:	0020c0        	memw
4037a868:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037a86a:	0020c0        	memw
4037a86d:	0288      	l32i.n	a8, a2, 0
4037a86f:	881b      	addi.n	a8, a8, 1
4037a871:	0020c0        	memw
4037a874:	0289      	s32i.n	a8, a2, 0
}
4037a876:	f01d      	retw.n

4037a878 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
4037a878:	004136        	entry	a1, 32
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
4037a87b:	0020c0        	memw
4037a87e:	4288      	l32i.n	a8, a2, 16

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
4037a880:	0020c0        	memw
4037a883:	1298      	l32i.n	a9, a2, 4
4037a885:	0020c0        	memw
4037a888:	22a8      	l32i.n	a10, a2, 8
4037a88a:	0020c0        	memw
4037a88d:	29a9      	s32i.n	a10, a9, 8
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
4037a88f:	0020c0        	memw
4037a892:	2298      	l32i.n	a9, a2, 8
4037a894:	0020c0        	memw
4037a897:	12a8      	l32i.n	a10, a2, 4
4037a899:	0020c0        	memw
4037a89c:	19a9      	s32i.n	a10, a9, 4

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
4037a89e:	0020c0        	memw
4037a8a1:	1898      	l32i.n	a9, a8, 4
4037a8a3:	099927        	bne	a9, a2, 4037a8b0 <uxListRemove+0x38>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
4037a8a6:	0020c0        	memw
4037a8a9:	2298      	l32i.n	a9, a2, 8
4037a8ab:	0020c0        	memw
4037a8ae:	1899      	s32i.n	a9, a8, 4
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
4037a8b0:	090c      	movi.n	a9, 0
4037a8b2:	0020c0        	memw
4037a8b5:	4299      	s32i.n	a9, a2, 16
    ( pxList->uxNumberOfItems )--;
4037a8b7:	0020c0        	memw
4037a8ba:	0898      	l32i.n	a9, a8, 0
4037a8bc:	990b      	addi.n	a9, a9, -1
4037a8be:	0020c0        	memw
4037a8c1:	0899      	s32i.n	a9, a8, 0

    return pxList->uxNumberOfItems;
4037a8c3:	0020c0        	memw
4037a8c6:	0828      	l32i.n	a2, a8, 0
}
4037a8c8:	f01d      	retw.n
	...

4037a8cc <prvCheckTaskCanBeScheduledSMP>:
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    static BaseType_t prvCheckTaskCanBeScheduledSMP( TCB_t * pxTCB )
    {
4037a8cc:	004136        	entry	a1, 32
        /* This function must be called from a critical section (where the kernel
         * lock is taken). */

        BaseType_t xReturn;

        if( pxTCB->xCoreID == tskNO_AFFINITY )
4037a8cf:	112282        	l32i	a8, a2, 68
4037a8d2:	e7c091        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037a8d5:	189897        	bne	a8, a9, 4037a8f1 <prvCheckTaskCanBeScheduledSMP+0x25>
        {
            /* Task is unpinned. As long as one core has not suspended
             * scheduling, the task can be scheduled. */
            if( ( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) 0U ) || ( uxSchedulerSuspended[ 1 ] == ( UBaseType_t ) 0U ) )
4037a8d8:	e8df81        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037a8db:	0020c0        	memw
4037a8de:	0888      	l32i.n	a8, a8, 0
4037a8e0:	08ac      	beqz.n	a8, 4037a904 <prvCheckTaskCanBeScheduledSMP+0x38>
4037a8e2:	e8dc81        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037a8e5:	0020c0        	memw
4037a8e8:	1888      	l32i.n	a8, a8, 4
4037a8ea:	b8dc      	bnez.n	a8, 4037a909 <prvCheckTaskCanBeScheduledSMP+0x3d>
            {
                xReturn = pdTRUE;
4037a8ec:	120c      	movi.n	a2, 1
4037a8ee:	000786        	j	4037a910 <prvCheckTaskCanBeScheduledSMP+0x44>
            else
            {
                xReturn = pdFALSE;
            }
        }
        else if( uxSchedulerSuspended[ pxTCB->xCoreID ] == ( UBaseType_t ) 0U )
4037a8f1:	e8d891        	l32r	a9, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037a8f4:	a08890        	addx4	a8, a8, a9
4037a8f7:	0020c0        	memw
4037a8fa:	0888      	l32i.n	a8, a8, 0
4037a8fc:	e8cc      	bnez.n	a8, 4037a90e <prvCheckTaskCanBeScheduledSMP+0x42>
        {
            /* The task is pinned to a core. If it's pinned core has not
             * suspended scheduling, the task can be scheduled. */
            xReturn = pdTRUE;
4037a8fe:	120c      	movi.n	a2, 1
4037a900:	000306        	j	4037a910 <prvCheckTaskCanBeScheduledSMP+0x44>
4037a903:	120c00        	andbc	b0, b12, b0
                xReturn = pdTRUE;
4037a906:	000186        	j	4037a910 <prvCheckTaskCanBeScheduledSMP+0x44>
                xReturn = pdFALSE;
4037a909:	020c      	movi.n	a2, 0
4037a90b:	000046        	j	4037a910 <prvCheckTaskCanBeScheduledSMP+0x44>
        }
        else
        {
            xReturn = pdFALSE;
4037a90e:	020c      	movi.n	a2, 0
        }

        return xReturn;
    }
4037a910:	f01d      	retw.n
	...

4037a914 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
4037a914:	004136        	entry	a1, 32
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037a917:	e8d081        	l32r	a8, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037a91a:	0020c0        	memw
4037a91d:	0888      	l32i.n	a8, a8, 0
4037a91f:	0020c0        	memw
4037a922:	0888      	l32i.n	a8, a8, 0
4037a924:	c8cc      	bnez.n	a8, 4037a934 <prvResetNextTaskUnblockTime+0x20>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
4037a926:	e8cd81        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037a929:	f97c      	movi.n	a9, -1
4037a92b:	0020c0        	memw
4037a92e:	0899      	s32i.n	a9, a8, 0
4037a930:	000686        	j	4037a94e <prvResetNextTaskUnblockTime+0x3a>
4037a933:	00          	.byte	00
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
4037a934:	e8c981        	l32r	a8, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037a937:	0020c0        	memw
4037a93a:	0888      	l32i.n	a8, a8, 0
4037a93c:	0020c0        	memw
4037a93f:	3888      	l32i.n	a8, a8, 12
4037a941:	0020c0        	memw
4037a944:	0898      	l32i.n	a9, a8, 0
4037a946:	e8c581        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037a949:	0020c0        	memw
4037a94c:	0899      	s32i.n	a9, a8, 0
    }
}
4037a94e:	f01d      	retw.n

4037a950 <prvIsYieldRequiredSMP>:
    {
4037a950:	004136        	entry	a1, 32
        configASSERT( uxTaskPriority < configMAX_PRIORITIES );
4037a953:	881c      	movi.n	a8, 24
4037a955:	0eb837        	bgeu	a8, a3, 4037a967 <prvIsYieldRequiredSMP+0x17>
4037a958:	e8c2d1        	l32r	a13, 40374c60 <_iram_text_start+0x85c> (3c0232d8 <_flash_rodata_start+0x31b8>)
4037a95b:	e8c2c1        	l32r	a12, 40374c64 <_iram_text_start+0x860> (3c0272c4 <__func__$37>)
4037a95e:	36a3b2        	movi	a11, 0x336
4037a961:	e8c1a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037a964:	053c25        	call8	4037fd28 <__assert_func>
4037a967:	03eba0        	rsr.prid	a10
4037a96a:	04ada0        	extui	a10, a10, 13, 1
4037a96d:	0a9d      	mov.n	a9, a10
        if( xYieldEqualPriority == pdTRUE )
4037a96f:	011466        	bnei	a4, 1, 4037a974 <prvIsYieldRequiredSMP+0x24>
            uxTaskPriority++;
4037a972:	331b      	addi.n	a3, a3, 1
        if( ( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCB ) == pdTRUE ) &&
4037a974:	112282        	l32i	a8, a2, 68
4037a977:	051897        	beq	a8, a9, 4037a980 <prvIsYieldRequiredSMP+0x30>
4037a97a:	e79691        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037a97d:	1c9897        	bne	a8, a9, 4037a99d <prvIsYieldRequiredSMP+0x4d>
            ( uxTaskPriority > pxCurrentTCBs[ xCurCoreID ]->uxPriority ) &&
4037a980:	e89e91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037a983:	a09a90        	addx4	a9, a10, a9
4037a986:	0020c0        	memw
4037a989:	0998      	l32i.n	a9, a9, 0
4037a98b:	b998      	l32i.n	a9, a9, 44
        if( ( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCB ) == pdTRUE ) &&
4037a98d:	0cb937        	bgeu	a9, a3, 4037a99d <prvIsYieldRequiredSMP+0x4d>
            ( uxSchedulerSuspended[ xCurCoreID ] == ( UBaseType_t ) 0U ) )
4037a990:	e8b191        	l32r	a9, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037a993:	a09a90        	addx4	a9, a10, a9
4037a996:	0020c0        	memw
4037a999:	0998      	l32i.n	a9, a9, 0
            ( uxTaskPriority > pxCurrentTCBs[ xCurCoreID ]->uxPriority ) &&
4037a99b:	69bc      	beqz.n	a9, 4037a9d5 <prvIsYieldRequiredSMP+0x85>
        else if( ( taskIS_AFFINITY_COMPATIBLE( !xCurCoreID, pxTCB ) == pdTRUE ) &&
4037a99d:	40faa0        	nsau	a10, a10
4037a9a0:	41a5a0        	srli	a10, a10, 5
4037a9a3:	0518a7        	beq	a8, a10, 4037a9ac <prvIsYieldRequiredSMP+0x5c>
4037a9a6:	e78b91        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037a9a9:	2d9897        	bne	a8, a9, 4037a9da <prvIsYieldRequiredSMP+0x8a>
                 ( uxTaskPriority > pxCurrentTCBs[ !xCurCoreID ]->uxPriority ) &&
4037a9ac:	e89381        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037a9af:	a08a80        	addx4	a8, a10, a8
4037a9b2:	0020c0        	memw
4037a9b5:	002882        	l32i	a8, a8, 0
4037a9b8:	0b2882        	l32i	a8, a8, 44
        else if( ( taskIS_AFFINITY_COMPATIBLE( !xCurCoreID, pxTCB ) == pdTRUE ) &&
4037a9bb:	21b837        	bgeu	a8, a3, 4037a9e0 <prvIsYieldRequiredSMP+0x90>
                 ( uxSchedulerSuspended[ !xCurCoreID ] == ( UBaseType_t ) 0U ) )
4037a9be:	e8a581        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037a9c1:	a08a80        	addx4	a8, a10, a8
4037a9c4:	0020c0        	memw
4037a9c7:	002882        	l32i	a8, a8, 0
                 ( uxTaskPriority > pxCurrentTCBs[ !xCurCoreID ]->uxPriority ) &&
4037a9ca:	017856        	bnez	a8, 4037a9e5 <prvIsYieldRequiredSMP+0x95>
            taskYIELD_CORE( !xCurCoreID );
4037a9cd:	ff8325        	call8	4037a200 <vPortYieldOtherCore>
            xYieldRequiredCurrentCore = pdFALSE;
4037a9d0:	020c      	movi.n	a2, 0
4037a9d2:	000446        	j	4037a9e7 <prvIsYieldRequiredSMP+0x97>
            xYieldRequiredCurrentCore = pdTRUE;
4037a9d5:	120c      	movi.n	a2, 1
4037a9d7:	000306        	j	4037a9e7 <prvIsYieldRequiredSMP+0x97>
            xYieldRequiredCurrentCore = pdFALSE;
4037a9da:	020c      	movi.n	a2, 0
4037a9dc:	0001c6        	j	4037a9e7 <prvIsYieldRequiredSMP+0x97>
4037a9df:	020c00        	andb	b0, b12, b0
4037a9e2:	000046        	j	4037a9e7 <prvIsYieldRequiredSMP+0x97>
4037a9e5:	020c      	movi.n	a2, 0
    }
4037a9e7:	f01d      	retw.n
4037a9e9:	000000        	ill

4037a9ec <prvSelectHighestPriorityTaskSMP>:
    {
4037a9ec:	004136        	entry	a1, 32
4037a9ef:	03ebc0        	rsr.prid	a12
4037a9f2:	04cdc0        	extui	a12, a12, 13, 1
4037a9f5:	0cfd      	mov.n	a15, a12
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037a9f7:	e89d81        	l32r	a8, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037a9fa:	0020c0        	memw
4037a9fd:	0898      	l32i.n	a9, a8, 0
        BaseType_t xNewTopPrioritySet = pdFALSE;
4037a9ff:	060c      	movi.n	a6, 0
        BaseType_t xTaskScheduled = pdFALSE;
4037aa01:	067d      	mov.n	a7, a6
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037aa03:	006a06        	j	4037abaf <prvSelectHighestPriorityTaskSMP+0x1c3>
4037aa06:	000000        	ill
            if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxCurPriority ] ) ) )
4037aa09:	a08990        	addx4	a8, a9, a9
4037aa0c:	11a8e0        	slli	a10, a8, 2
4037aa0f:	e89881        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037aa12:	88aa      	add.n	a8, a8, a10
4037aa14:	0020c0        	memw
4037aa17:	0888      	l32i.n	a8, a8, 0
4037aa19:	190816        	beqz	a8, 4037abad <prvSelectHighestPriorityTaskSMP+0x1c1>
            if( xNewTopPrioritySet == pdFALSE )
4037aa1c:	96cc      	bnez.n	a6, 4037aa29 <prvSelectHighestPriorityTaskSMP+0x3d>
                uxTopReadyPriority = uxCurPriority;
4037aa1e:	e89381        	l32r	a8, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037aa21:	0020c0        	memw
4037aa24:	0899      	s32i.n	a9, a8, 0
                xNewTopPrioritySet = pdTRUE;
4037aa26:	01a062        	movi	a6, 1
            pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037aa29:	a0a990        	addx4	a10, a9, a9
4037aa2c:	118ae0        	slli	a8, a10, 2
4037aa2f:	e890a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037aa32:	88aa      	add.n	a8, a8, a10
4037aa34:	d88b      	addi.n	a13, a8, 8
4037aa36:	0020c0        	memw
4037aa39:	18d9      	s32i.n	a13, a8, 4
            listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037aa3b:	0020c0        	memw
4037aa3e:	18a8      	l32i.n	a10, a8, 4
4037aa40:	0020c0        	memw
4037aa43:	1aa8      	l32i.n	a10, a10, 4
4037aa45:	0020c0        	memw
4037aa48:	18a9      	s32i.n	a10, a8, 4
4037aa4a:	0020c0        	memw
4037aa4d:	1888      	l32i.n	a8, a8, 4
4037aa4f:	199d87        	bne	a13, a8, 4037aa6c <prvSelectHighestPriorityTaskSMP+0x80>
4037aa52:	a08990        	addx4	a8, a9, a9
4037aa55:	11a8e0        	slli	a10, a8, 2
4037aa58:	e88681        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037aa5b:	88aa      	add.n	a8, a8, a10
4037aa5d:	0020c0        	memw
4037aa60:	18a8      	l32i.n	a10, a8, 4
4037aa62:	0020c0        	memw
4037aa65:	1aa8      	l32i.n	a10, a10, 4
4037aa67:	0020c0        	memw
4037aa6a:	18a9      	s32i.n	a10, a8, 4
4037aa6c:	a08990        	addx4	a8, a9, a9
4037aa6f:	11a8e0        	slli	a10, a8, 2
4037aa72:	e87f81        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037aa75:	88aa      	add.n	a8, a8, a10
4037aa77:	0020c0        	memw
4037aa7a:	1888      	l32i.n	a8, a8, 4
4037aa7c:	38e8      	l32i.n	a14, a8, 12
4037aa7e:	0ebd      	mov.n	a11, a14
                for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037aa80:	080c      	movi.n	a8, 0
4037aa82:	000546        	j	4037aa9b <prvSelectHighestPriorityTaskSMP+0xaf>
                    if( x == xCurCoreID )
4037aa85:	1018c7        	beq	a8, a12, 4037aa99 <prvSelectHighestPriorityTaskSMP+0xad>
                    else if( pxCurrentTCBs[ x ] == pxTCBCur )
4037aa88:	e85ca1        	l32r	a10, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037aa8b:	a0a8a0        	addx4	a10, a8, a10
4037aa8e:	0020c0        	memw
4037aa91:	0aa8      	l32i.n	a10, a10, 0
4037aa93:	029ab7        	bne	a10, a11, 4037aa99 <prvSelectHighestPriorityTaskSMP+0xad>
4037aa96:	002f86        	j	4037ab58 <prvSelectHighestPriorityTaskSMP+0x16c>
                for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037aa99:	881b      	addi.n	a8, a8, 1
4037aa9b:	e628b6        	bltui	a8, 2, 4037aa85 <prvSelectHighestPriorityTaskSMP+0x99>
                if( taskIS_AFFINITY_COMPATIBLE( xCurCoreID, pxTCBCur ) == pdFALSE )
4037aa9e:	112b82        	l32i	a8, a11, 68
4037aaa1:	0818f7        	beq	a8, a15, 4037aaad <prvSelectHighestPriorityTaskSMP+0xc1>
4037aaa4:	e74ca1        	l32r	a10, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037aaa7:	0218a7        	beq	a8, a10, 4037aaad <prvSelectHighestPriorityTaskSMP+0xc1>
4037aaaa:	002a86        	j	4037ab58 <prvSelectHighestPriorityTaskSMP+0x16c>
                pxCurrentTCBs[ xCurCoreID ] = pxTCBCur;
4037aaad:	e85281        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037aab0:	a08c80        	addx4	a8, a12, a8
4037aab3:	0020c0        	memw
4037aab6:	08b9      	s32i.n	a11, a8, 0
                pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037aab8:	a08990        	addx4	a8, a9, a9
4037aabb:	11a8e0        	slli	a10, a8, 2
4037aabe:	e86c81        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037aac1:	88aa      	add.n	a8, a8, a10
4037aac3:	0020c0        	memw
4037aac6:	18d9      	s32i.n	a13, a8, 4
                listREMOVE_ITEM( &( pxTCBCur->xStateListItem ) );
4037aac8:	0020c0        	memw
4037aacb:	5b88      	l32i.n	a8, a11, 20
4037aacd:	0020c0        	memw
4037aad0:	2ba8      	l32i.n	a10, a11, 8
4037aad2:	0020c0        	memw
4037aad5:	3bd8      	l32i.n	a13, a11, 12
4037aad7:	0020c0        	memw
4037aada:	2ad9      	s32i.n	a13, a10, 8
4037aadc:	0020c0        	memw
4037aadf:	3ba8      	l32i.n	a10, a11, 12
4037aae1:	0020c0        	memw
4037aae4:	2bd8      	l32i.n	a13, a11, 8
4037aae6:	0020c0        	memw
4037aae9:	1ad9      	s32i.n	a13, a10, 4
4037aaeb:	0020c0        	memw
4037aaee:	18a8      	l32i.n	a10, a8, 4
4037aaf0:	db4b      	addi.n	a13, a11, 4
4037aaf2:	0a9ad7        	bne	a10, a13, 4037ab00 <prvSelectHighestPriorityTaskSMP+0x114>
4037aaf5:	0020c0        	memw
4037aaf8:	3ba8      	l32i.n	a10, a11, 12
4037aafa:	0020c0        	memw
4037aafd:	0168a2        	s32i	a10, a8, 4
4037ab00:	0a0c      	movi.n	a10, 0
4037ab02:	0020c0        	memw
4037ab05:	5ba9      	s32i.n	a10, a11, 20
4037ab07:	0020c0        	memw
4037ab0a:	08a8      	l32i.n	a10, a8, 0
4037ab0c:	aa0b      	addi.n	a10, a10, -1
4037ab0e:	0020c0        	memw
4037ab11:	08a9      	s32i.n	a10, a8, 0
                listINSERT_END( &( pxReadyTasksLists[ uxCurPriority ] ), &( pxTCBCur->xStateListItem ) );
4037ab13:	a08990        	addx4	a8, a9, a9
4037ab16:	11a8e0        	slli	a10, a8, 2
4037ab19:	e85581        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037ab1c:	88aa      	add.n	a8, a8, a10
4037ab1e:	0020c0        	memw
4037ab21:	18a8      	l32i.n	a10, a8, 4
4037ab23:	0020c0        	memw
4037ab26:	2ba9      	s32i.n	a10, a11, 8
4037ab28:	0020c0        	memw
4037ab2b:	2ae8      	l32i.n	a14, a10, 8
4037ab2d:	0020c0        	memw
4037ab30:	3be9      	s32i.n	a14, a11, 12
4037ab32:	0020c0        	memw
4037ab35:	2ae8      	l32i.n	a14, a10, 8
4037ab37:	0020c0        	memw
4037ab3a:	1ed9      	s32i.n	a13, a14, 4
4037ab3c:	0020c0        	memw
4037ab3f:	2ad9      	s32i.n	a13, a10, 8
4037ab41:	0020c0        	memw
4037ab44:	5b89      	s32i.n	a8, a11, 20
4037ab46:	0020c0        	memw
4037ab49:	08a8      	l32i.n	a10, a8, 0
4037ab4b:	aa1b      	addi.n	a10, a10, 1
4037ab4d:	0020c0        	memw
4037ab50:	08a9      	s32i.n	a10, a8, 0
                xTaskScheduled = pdTRUE;
4037ab52:	170c      	movi.n	a7, 1
                break;
4037ab54:	001546        	j	4037abad <prvSelectHighestPriorityTaskSMP+0x1c1>
4037ab57:	00          	.byte	00
                listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037ab58:	a08990        	addx4	a8, a9, a9
4037ab5b:	11a8e0        	slli	a10, a8, 2
4037ab5e:	e84481        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037ab61:	88aa      	add.n	a8, a8, a10
4037ab63:	0020c0        	memw
4037ab66:	18a8      	l32i.n	a10, a8, 4
4037ab68:	0020c0        	memw
4037ab6b:	1aa8      	l32i.n	a10, a10, 4
4037ab6d:	0020c0        	memw
4037ab70:	18a9      	s32i.n	a10, a8, 4
4037ab72:	0020c0        	memw
4037ab75:	1888      	l32i.n	a8, a8, 4
4037ab77:	1a9d87        	bne	a13, a8, 4037ab95 <prvSelectHighestPriorityTaskSMP+0x1a9>
4037ab7a:	a08990        	addx4	a8, a9, a9
4037ab7d:	11a8e0        	slli	a10, a8, 2
4037ab80:	e83c81        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037ab83:	88aa      	add.n	a8, a8, a10
4037ab85:	0020c0        	memw
4037ab88:	18a8      	l32i.n	a10, a8, 4
4037ab8a:	0020c0        	memw
4037ab8d:	1aa8      	l32i.n	a10, a10, 4
4037ab8f:	0020c0        	memw
4037ab92:	0168a2        	s32i	a10, a8, 4
4037ab95:	a08990        	addx4	a8, a9, a9
4037ab98:	11a8e0        	slli	a10, a8, 2
4037ab9b:	e83581        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037ab9e:	88aa      	add.n	a8, a8, a10
4037aba0:	0020c0        	memw
4037aba3:	1888      	l32i.n	a8, a8, 4
4037aba5:	38b8      	l32i.n	a11, a8, 12
            } while( pxTCBCur != pxTCBFirst ); /* Check to see if we've walked the entire list */
4037aba7:	021eb7        	beq	a14, a11, 4037abad <prvSelectHighestPriorityTaskSMP+0x1c1>
4037abaa:	ffb486        	j	4037aa80 <prvSelectHighestPriorityTaskSMP+0x94>
        for( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037abad:	990b      	addi.n	a9, a9, -1
4037abaf:	048070        	extui	a8, a7, 0, 1
4037abb2:	1a0c      	movi.n	a10, 1
4037abb4:	3088a0        	xor	a8, a8, a10
4037abb7:	748080        	extui	a8, a8, 0, 8
4037abba:	002996        	bltz	a9, 4037abc0 <prvSelectHighestPriorityTaskSMP+0x1d4>
4037abbd:	e48856        	bnez	a8, 4037aa09 <prvSelectHighestPriorityTaskSMP+0x1d>
        configASSERT( xTaskScheduled == pdTRUE ); /* At this point, a task MUST have been scheduled */
4037abc0:	d7cc      	bnez.n	a7, 4037abd1 <prvSelectHighestPriorityTaskSMP+0x1e5>
4037abc2:	e82cd1        	l32r	a13, 40374c74 <_iram_text_start+0x870> (3c023324 <_flash_rodata_start+0x3204>)
4037abc5:	e82cc1        	l32r	a12, 40374c78 <_iram_text_start+0x874> (3c02725c <__func__$24>)
4037abc8:	e82db1        	l32r	a11, 40374c7c <_iram_text_start+0x878> (e3a <UserFrameTotalSize+0xd3a>)
4037abcb:	e827a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037abce:	0515a5        	call8	4037fd28 <__assert_func>
    }
4037abd1:	f01d      	retw.n
	...

4037abd4 <prvDeleteTCB>:
    {
4037abd4:	004136        	entry	a1, 32
        portCLEAN_UP_TCB( pxTCB );
4037abd7:	20a220        	or	a10, a2, a2
4037abda:	ff6725        	call8	4037a24c <vPortTCBPreDeleteHook>
            configDEINIT_TLS_BLOCK( pxTCB->xTLSBlock );
4037abdd:	5cc2a2        	addi	a10, a2, 92
4037abe0:	e82b81        	l32r	a8, 40374c8c <_iram_text_start+0x888> (4200d398 <_reclaim_reent>)
4037abe3:	0008e0        	callx8	a8
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
4037abe6:	01d282        	addmi	a8, a2, 0x100
4037abe9:	510882        	l8ui	a8, a8, 81
4037abec:	00d856        	bnez	a8, 4037abfd <prvDeleteTCB+0x29>
                vPortFreeStack( pxTCB->pxStack );
4037abef:	c2a8      	l32i.n	a10, a2, 48
4037abf1:	ff89a5        	call8	4037a48c <vPortFree>
                vPortFree( pxTCB );
4037abf4:	02ad      	mov.n	a10, a2
4037abf6:	ff8965        	call8	4037a48c <vPortFree>
4037abf9:	000746        	j	4037ac1a <prvDeleteTCB+0x46>
4037abfc:	186600        	lsxp	f6, a6, a0
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
4037abff:	02ad07        	bge	a13, a0, 4037ac05 <prvDeleteTCB+0x31>
                vPortFree( pxTCB );
4037ac02:	ff88a5        	call8	4037a48c <vPortFree>
4037ac05:	000446        	j	4037ac1a <prvDeleteTCB+0x46>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
4037ac08:	0e2826        	beqi	a8, 2, 4037ac1a <prvDeleteTCB+0x46>
4037ac0b:	e81dd1        	l32r	a13, 40374c80 <_iram_text_start+0x87c> (3c02334c <_flash_rodata_start+0x322c>)
4037ac0e:	e81dc1        	l32r	a12, 40374c84 <_iram_text_start+0x880> (3c0272fc <__func__$42>)
4037ac11:	e81db1        	l32r	a11, 40374c88 <_iram_text_start+0x884> (134b <UserFrameTotalSize+0x124b>)
4037ac14:	e815a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037ac17:	051125        	call8	4037fd28 <__assert_func>
    }
4037ac1a:	f01d      	retw.n

4037ac1c <prvCheckTasksWaitingTermination>:
{
4037ac1c:	004136        	entry	a1, 32
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037ac1f:	002086        	j	4037aca5 <prvCheckTasksWaitingTermination+0x89>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037ac22:	ffafb2        	movi	a11, -1
4037ac25:	e81aa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ac28:	ff3ea5        	call8	4037a014 <xPortEnterCriticalTimeout>
                    if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
4037ac2b:	e81a81        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94ff0 <xTasksWaitingTermination>)
4037ac2e:	0020c0        	memw
4037ac31:	002882        	l32i	a8, a8, 0
4037ac34:	05e816        	beqz	a8, 4037ac96 <prvCheckTasksWaitingTermination+0x7a>
                        for( xEntry = listGET_HEAD_ENTRY( &xTasksWaitingTermination ); xEntry != listGET_END_MARKER( &xTasksWaitingTermination ); xEntry = listGET_NEXT( xEntry ) )
4037ac37:	e81781        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94ff0 <xTasksWaitingTermination>)
4037ac3a:	0020c0        	memw
4037ac3d:	032882        	l32i	a8, a8, 12
4037ac40:	001186        	j	4037ac8a <prvCheckTasksWaitingTermination+0x6e>
4037ac43:	00          	.byte	00
                            if( taskIS_CURRENTLY_RUNNING( ( ( TCB_t * ) listGET_LIST_ITEM_OWNER( xEntry ) ) ) == pdFALSE )
4037ac44:	032872        	l32i	a7, a8, 12
4037ac47:	e7ec91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037ac4a:	0020c0        	memw
4037ac4d:	002992        	l32i	a9, a9, 0
4037ac50:	311797        	beq	a7, a9, 4037ac85 <prvCheckTasksWaitingTermination+0x69>
4037ac53:	e7e991        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037ac56:	0020c0        	memw
4037ac59:	012992        	l32i	a9, a9, 4
4037ac5c:	251797        	beq	a7, a9, 4037ac85 <prvCheckTasksWaitingTermination+0x69>
                                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4037ac5f:	a74b      	addi.n	a10, a7, 4
4037ac61:	ffc165        	call8	4037a878 <uxListRemove>
                                --uxCurrentNumberOfTasks;
4037ac64:	e80d91        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94fd4 <uxCurrentNumberOfTasks>)
4037ac67:	0020c0        	memw
4037ac6a:	0988      	l32i.n	a8, a9, 0
4037ac6c:	880b      	addi.n	a8, a8, -1
4037ac6e:	0020c0        	memw
4037ac71:	0989      	s32i.n	a8, a9, 0
                                --uxDeletedTasksWaitingCleanUp;
4037ac73:	e80a91        	l32r	a9, 40374c9c <_iram_text_start+0x898> (3fc94fec <uxDeletedTasksWaitingCleanUp>)
4037ac76:	0020c0        	memw
4037ac79:	0988      	l32i.n	a8, a9, 0
4037ac7b:	880b      	addi.n	a8, a8, -1
4037ac7d:	0020c0        	memw
4037ac80:	0989      	s32i.n	a8, a9, 0
                                break;
4037ac82:	000486        	j	4037ac98 <prvCheckTasksWaitingTermination+0x7c>
                        for( xEntry = listGET_HEAD_ENTRY( &xTasksWaitingTermination ); xEntry != listGET_END_MARKER( &xTasksWaitingTermination ); xEntry = listGET_NEXT( xEntry ) )
4037ac85:	0020c0        	memw
4037ac88:	1888      	l32i.n	a8, a8, 4
4037ac8a:	e80591        	l32r	a9, 40374ca0 <_iram_text_start+0x89c> (3fc94ff8 <xTasksWaitingTermination+0x8>)
4037ac8d:	b39897        	bne	a8, a9, 4037ac44 <prvCheckTasksWaitingTermination+0x28>
                pxTCB = NULL;
4037ac90:	070c      	movi.n	a7, 0
4037ac92:	000086        	j	4037ac98 <prvCheckTasksWaitingTermination+0x7c>
4037ac95:	070c00        	ee.stf.64.xp	f0, f0, a0, a12
                taskEXIT_CRITICAL( &xKernelLock );
4037ac98:	e7fea1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ac9b:	ff4ca5        	call8	4037a164 <vPortExitCritical>
                if( pxTCB != NULL )
4037ac9e:	e78c      	beqz.n	a7, 4037acb0 <prvCheckTasksWaitingTermination+0x94>
                    prvDeleteTCB( pxTCB );
4037aca0:	07ad      	mov.n	a10, a7
4037aca2:	fff325        	call8	4037abd4 <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037aca5:	e7fd81        	l32r	a8, 40374c9c <_iram_text_start+0x898> (3fc94fec <uxDeletedTasksWaitingCleanUp>)
4037aca8:	0020c0        	memw
4037acab:	0888      	l32i.n	a8, a8, 0
4037acad:	f71856        	bnez	a8, 4037ac22 <prvCheckTasksWaitingTermination+0x6>
}
4037acb0:	f01d      	retw.n
	...

4037acb4 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
4037acb4:	004136        	entry	a1, 32
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
4037acb7:	e7fb81        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037acba:	0020c0        	memw
4037acbd:	002862        	l32i	a6, a8, 0
4037acc0:	03eb70        	rsr.prid	a7
4037acc3:	047d70        	extui	a7, a7, 13, 1
    /* Get current core ID as we can no longer be preempted. */
    const BaseType_t xCurCoreID = portGET_CORE_ID();

    #if ( configNUMBER_OF_CORES > 1 )
    {
        if( listIS_CONTAINED_WITHIN( &xTasksWaitingTermination, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) ) == pdTRUE )
4037acc6:	e7cc81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037acc9:	a08780        	addx4	a8, a7, a8
4037accc:	0020c0        	memw
4037accf:	002882        	l32i	a8, a8, 0
4037acd2:	0020c0        	memw
4037acd5:	052892        	l32i	a9, a8, 20
4037acd8:	e7ef81        	l32r	a8, 40374c94 <_iram_text_start+0x890> (3fc94ff0 <xTasksWaitingTermination>)
4037acdb:	029987        	bne	a9, a8, 4037ace1 <prvAddCurrentTaskToDelayedList+0x2d>
4037acde:	003a86        	j	4037adcc <prvAddCurrentTaskToDelayedList+0x118>
    #if ( INCLUDE_xTaskAbortDelay == 1 )
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
         * reset to pdFALSE so it can be detected as having been set to pdTRUE
         * when the task leaves the Blocked state. */
        pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted = pdFALSE;
4037ace1:	e7c581        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037ace4:	a08780        	addx4	a8, a7, a8
4037ace7:	0020c0        	memw
4037acea:	0898      	l32i.n	a9, a8, 0
4037acec:	01d992        	addmi	a9, a9, 0x100
4037acef:	0a0c      	movi.n	a10, 0
4037acf1:	5249a2        	s8i	a10, a9, 82
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037acf4:	0020c0        	memw
4037acf7:	08a8      	l32i.n	a10, a8, 0
4037acf9:	aa4b      	addi.n	a10, a10, 4
4037acfb:	ffb7e5        	call8	4037a878 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
4037acfe:	821b      	addi.n	a8, a2, 1
4037ad00:	40f880        	nsau	a8, a8
4037ad03:	418580        	srli	a8, a8, 5
4037ad06:	190c      	movi.n	a9, 1
4037ad08:	839330        	moveqz	a9, a3, a3
4037ad0b:	5d0897        	bnone	a8, a9, 4037ad6c <prvAddCurrentTaskToDelayedList+0xb8>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037ad0e:	e7e691        	l32r	a9, 40374ca8 <_iram_text_start+0x8a4> (3fc94fd8 <xSuspendedTaskList>)
4037ad11:	0020c0        	memw
4037ad14:	19a8      	l32i.n	a10, a9, 4
4037ad16:	e7b881        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037ad19:	a08780        	addx4	a8, a7, a8
4037ad1c:	0020c0        	memw
4037ad1f:	08b8      	l32i.n	a11, a8, 0
4037ad21:	0020c0        	memw
4037ad24:	2ba9      	s32i.n	a10, a11, 8
4037ad26:	0020c0        	memw
4037ad29:	08b8      	l32i.n	a11, a8, 0
4037ad2b:	0020c0        	memw
4037ad2e:	2ac8      	l32i.n	a12, a10, 8
4037ad30:	0020c0        	memw
4037ad33:	3bc9      	s32i.n	a12, a11, 12
4037ad35:	0020c0        	memw
4037ad38:	08b8      	l32i.n	a11, a8, 0
4037ad3a:	0020c0        	memw
4037ad3d:	2ac8      	l32i.n	a12, a10, 8
4037ad3f:	bb4b      	addi.n	a11, a11, 4
4037ad41:	0020c0        	memw
4037ad44:	1cb9      	s32i.n	a11, a12, 4
4037ad46:	0020c0        	memw
4037ad49:	08b8      	l32i.n	a11, a8, 0
4037ad4b:	bb4b      	addi.n	a11, a11, 4
4037ad4d:	0020c0        	memw
4037ad50:	2ab9      	s32i.n	a11, a10, 8
4037ad52:	0020c0        	memw
4037ad55:	0888      	l32i.n	a8, a8, 0
4037ad57:	0020c0        	memw
4037ad5a:	5899      	s32i.n	a9, a8, 20
4037ad5c:	0020c0        	memw
4037ad5f:	0988      	l32i.n	a8, a9, 0
4037ad61:	881b      	addi.n	a8, a8, 1
4037ad63:	0020c0        	memw
4037ad66:	0989      	s32i.n	a8, a9, 0
4037ad68:	001806        	j	4037adcc <prvAddCurrentTaskToDelayedList+0x118>
4037ad6b:	262000        	ee.ldf.64.xp	f2, f2, a0, a0
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
4037ad6e:	a28180        	muluh	a8, a1, a8

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ), xTimeToWake );
4037ad71:	8780e7        	bany	a0, a14, 4037acfc <prvAddCurrentTaskToDelayedList+0x48>
4037ad74:	20c0a0        	or	a12, a0, a10
4037ad77:	00          	.byte	00
4037ad78:	002882        	l32i	a8, a8, 0
4037ad7b:	0020c0        	memw
4037ad7e:	016822        	s32i	a2, a8, 4

            if( xTimeToWake < xConstTickCount )
4037ad81:	1cb267        	bgeu	a2, a6, 4037ada1 <prvAddCurrentTaskToDelayedList+0xed>
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037ad84:	e7ca81        	l32r	a8, 40374cac <_iram_text_start+0x8a8> (3fc9502c <pxOverflowDelayedTaskList>)
4037ad87:	0020c0        	memw
4037ad8a:	08a8      	l32i.n	a10, a8, 0
4037ad8c:	e79b81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037ad8f:	a08780        	addx4	a8, a7, a8
4037ad92:	0020c0        	memw
4037ad95:	08b8      	l32i.n	a11, a8, 0
4037ad97:	bb4b      	addi.n	a11, a11, 4
4037ad99:	ffa825        	call8	4037a81c <vListInsert>
4037ad9c:	000b06        	j	4037adcc <prvAddCurrentTaskToDelayedList+0x118>
4037ad9f:	810000        	src	a0, a0, a0
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCBs[ xCurCoreID ]->xStateListItem ) );
4037ada2:	ad          	.byte	0xad
4037ada3:	20c0e7        	bnall	a0, a14, 4037adc7 <prvAddCurrentTaskToDelayedList+0x113>
4037ada6:	08a800        	lsx	f10, a8, a0
4037ada9:	e79381        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037adac:	a07780        	addx4	a7, a7, a8
4037adaf:	0020c0        	memw
4037adb2:	07b8      	l32i.n	a11, a7, 0
4037adb4:	bb4b      	addi.n	a11, a11, 4
4037adb6:	ffa665        	call8	4037a81c <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
4037adb9:	e7a881        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037adbc:	0020c0        	memw
4037adbf:	0888      	l32i.n	a8, a8, 0
4037adc1:	07b287        	bgeu	a2, a8, 4037adcc <prvAddCurrentTaskToDelayedList+0x118>
                {
                    xNextTaskUnblockTime = xTimeToWake;
4037adc4:	e7a681        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037adc7:	0020c0        	memw
4037adca:	0829      	s32i.n	a2, a8, 0

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
4037adcc:	f01d      	retw.n
	...

4037add0 <prvIdleTask>:
{
4037add0:	004136        	entry	a1, 32
        prvCheckTasksWaitingTermination();
4037add3:	ffe4a5        	call8	4037ac1c <prvCheckTasksWaitingTermination>
        esp_vApplicationIdleHook();
4037add6:	e7b681        	l32r	a8, 40374cb0 <_iram_text_start+0x8ac> (420029f8 <esp_vApplicationIdleHook>)
4037add9:	0008e0        	callx8	a8
    for( ; ; )
4037addc:	fffcc6        	j	4037add3 <prvIdleTask+0x3>
	...

4037ade0 <prvInitialiseNewTask>:
{
4037ade0:	006136        	entry	a1, 48
4037ade3:	1179      	s32i.n	a7, a1, 4
4037ade5:	0179      	s32i.n	a7, a1, 0
4037ade7:	c178      	l32i.n	a7, a1, 48
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
4037ade9:	04cd      	mov.n	a12, a4
4037adeb:	a5a0b2        	movi	a11, 165
4037adee:	c7a8      	l32i.n	a10, a7, 48
4037adf0:	e5b281        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037adf3:	0008e0        	callx8	a8
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
4037adf6:	c788      	l32i.n	a8, a7, 48
4037adf8:	440b      	addi.n	a4, a4, -1
4037adfa:	484a      	add.n	a4, a8, a4
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
4037adfc:	087c      	movi.n	a8, -16
4037adfe:	104480        	and	a4, a4, a8
            pxNewTCB->pxEndOfStack = pxTopOfStack;
4037ae01:	126742        	s32i	a4, a7, 72
    if( pcName != NULL )
4037ae04:	23dc      	bnez.n	a3, 4037ae1a <prvInitialiseNewTask+0x3a>
4037ae06:	000746        	j	4037ae27 <prvInitialiseNewTask+0x47>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
4037ae09:	938a      	add.n	a9, a3, a8
4037ae0b:	000992        	l8ui	a9, a9, 0
4037ae0e:	a78a      	add.n	a10, a7, a8
4037ae10:	344a92        	s8i	a9, a10, 52
            if( pcName[ x ] == ( char ) 0x00 )
4037ae13:	b98c      	beqz.n	a9, 4037ae22 <prvInitialiseNewTask+0x42>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
4037ae15:	881b      	addi.n	a8, a8, 1
4037ae17:	000046        	j	4037ae1c <prvInitialiseNewTask+0x3c>
4037ae1a:	080c      	movi.n	a8, 0
4037ae1c:	0fa092        	movi	a9, 15
4037ae1f:	e6b987        	bgeu	a9, a8, 4037ae09 <prvInitialiseNewTask+0x29>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
4037ae22:	080c      	movi.n	a8, 0
4037ae24:	434782        	s8i	a8, a7, 67
    configASSERT( uxPriority < configMAX_PRIORITIES );
4037ae27:	881c      	movi.n	a8, 24
4037ae29:	11b867        	bgeu	a8, a6, 4037ae3e <prvInitialiseNewTask+0x5e>
4037ae2c:	e7a2d1        	l32r	a13, 40374cb4 <_iram_text_start+0x8b0> (3c023380 <_flash_rodata_start+0x3260>)
4037ae2f:	e7a2c1        	l32r	a12, 40374cb8 <_iram_text_start+0x8b4> (3c027138 <__func__$5>)
4037ae32:	57a4b2        	movi	a11, 0x457
4037ae35:	e78ca1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037ae38:	201110        	or	a1, a1, a1
4037ae3b:	04eee5        	call8	4037fd28 <__assert_func>
    pxNewTCB->uxPriority = uxPriority;
4037ae3e:	0b6762        	s32i	a6, a7, 44
        pxNewTCB->xCoreID = xCoreID;
4037ae41:	e188      	l32i.n	a8, a1, 56
4037ae43:	116782        	s32i	a8, a7, 68
        pxNewTCB->uxBasePriority = uxPriority;
4037ae46:	136762        	s32i	a6, a7, 76
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
4037ae49:	04c7a2        	addi	a10, a7, 4
4037ae4c:	ff9865        	call8	4037a7d4 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
4037ae4f:	18c7a2        	addi	a10, a7, 24
4037ae52:	ff9825        	call8	4037a7d4 <vListInitialiseItem>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
4037ae55:	4779      	s32i.n	a7, a7, 16
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037ae57:	e7c662        	addi	a6, a6, -25
4037ae5a:	606060        	neg	a6, a6
4037ae5d:	0020c0        	memw
4037ae60:	6769      	s32i.n	a6, a7, 24
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
4037ae62:	9779      	s32i.n	a7, a7, 36
        configINIT_TLS_BLOCK( pxNewTCB->xTLSBlock );
4037ae64:	5cc7a2        	addi	a10, a7, 92
4037ae67:	e79581        	l32r	a8, 40374cbc <_iram_text_start+0x8b8> (420061e8 <esp_reent_init>)
4037ae6a:	0008e0        	callx8	a8
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
4037ae6d:	05cd      	mov.n	a12, a5
4037ae6f:	02bd      	mov.n	a11, a2
4037ae71:	04ad      	mov.n	a10, a4
4037ae73:	ff0e25        	call8	40379f54 <pxPortInitialiseStack>
4037ae76:	07a9      	s32i.n	a10, a7, 0
    if( pxCreatedTask != NULL )
4037ae78:	0188      	l32i.n	a8, a1, 0
4037ae7a:	288c      	beqz.n	a8, 4037ae80 <prvInitialiseNewTask+0xa0>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
4037ae7c:	1188      	l32i.n	a8, a1, 4
4037ae7e:	0879      	s32i.n	a7, a8, 0
}
4037ae80:	f01d      	retw.n
	...

4037ae84 <prvInitialiseTaskLists>:
{
4037ae84:	004136        	entry	a1, 32
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037ae87:	070c      	movi.n	a7, 0
4037ae89:	000406        	j	4037ae9d <prvInitialiseTaskLists+0x19>
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
4037ae8c:	a09770        	addx4	a9, a7, a7
4037ae8f:	1189e0        	slli	a8, a9, 2
4037ae92:	e777a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037ae95:	80aa80        	add	a10, a10, a8
4037ae98:	ff9165        	call8	4037a7b0 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037ae9b:	771b      	addi.n	a7, a7, 1
4037ae9d:	881c      	movi.n	a8, 24
4037ae9f:	e9b877        	bgeu	a8, a7, 4037ae8c <prvInitialiseTaskLists+0x8>
    vListInitialise( &xDelayedTaskList1 );
4037aea2:	e787a1        	l32r	a10, 40374cc0 <_iram_text_start+0x8bc> (3fc95048 <xDelayedTaskList1>)
4037aea5:	ff90a5        	call8	4037a7b0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
4037aea8:	e787a1        	l32r	a10, 40374cc4 <_iram_text_start+0x8c0> (3fc95034 <xDelayedTaskList2>)
4037aeab:	ff9065        	call8	4037a7b0 <vListInitialise>
    for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037aeae:	070c      	movi.n	a7, 0
4037aeb0:	000406        	j	4037aec4 <prvInitialiseTaskLists+0x40>
        vListInitialise( &xPendingReadyList[ x ] );
4037aeb3:	a09770        	addx4	a9, a7, a7
4037aeb6:	1189e0        	slli	a8, a9, 2
4037aeb9:	e783a1        	l32r	a10, 40374cc8 <_iram_text_start+0x8c4> (3fc95004 <xPendingReadyList>)
4037aebc:	80aa80        	add	a10, a10, a8
4037aebf:	ff8f25        	call8	4037a7b0 <vListInitialise>
    for( x = 0; x < configNUMBER_OF_CORES; x++ )
4037aec2:	771b      	addi.n	a7, a7, 1
4037aec4:	eb27b6        	bltui	a7, 2, 4037aeb3 <prvInitialiseTaskLists+0x2f>
        vListInitialise( &xTasksWaitingTermination );
4037aec7:	e773a1        	l32r	a10, 40374c94 <_iram_text_start+0x890> (3fc94ff0 <xTasksWaitingTermination>)
4037aeca:	ff8e65        	call8	4037a7b0 <vListInitialise>
        vListInitialise( &xSuspendedTaskList );
4037aecd:	e776a1        	l32r	a10, 40374ca8 <_iram_text_start+0x8a4> (3fc94fd8 <xSuspendedTaskList>)
4037aed0:	ff8de5        	call8	4037a7b0 <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
4037aed3:	e76181        	l32r	a8, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037aed6:	e77a91        	l32r	a9, 40374cc0 <_iram_text_start+0x8bc> (3fc95048 <xDelayedTaskList1>)
4037aed9:	0020c0        	memw
4037aedc:	0899      	s32i.n	a9, a8, 0
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
4037aede:	e77381        	l32r	a8, 40374cac <_iram_text_start+0x8a8> (3fc9502c <pxOverflowDelayedTaskList>)
4037aee1:	e77891        	l32r	a9, 40374cc4 <_iram_text_start+0x8c0> (3fc95034 <xDelayedTaskList2>)
4037aee4:	0020c0        	memw
4037aee7:	0899      	s32i.n	a9, a8, 0
}
4037aee9:	f01d      	retw.n
	...

4037aeec <prvAddNewTaskToReadyList>:
{
4037aeec:	004136        	entry	a1, 32
4037aeef:	ffafb2        	movi	a11, -1
4037aef2:	e767a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037aef5:	ff11e5        	call8	4037a014 <xPortEnterCriticalTimeout>
        uxCurrentNumberOfTasks++;
4037aef8:	e76881        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94fd4 <uxCurrentNumberOfTasks>)
4037aefb:	0020c0        	memw
4037aefe:	002892        	l32i	a9, a8, 0
4037af01:	991b      	addi.n	a9, a9, 1
4037af03:	0020c0        	memw
4037af06:	0899      	s32i.n	a9, a8, 0
        if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
4037af08:	0020c0        	memw
4037af0b:	002882        	l32i	a8, a8, 0
4037af0e:	021866        	bnei	a8, 1, 4037af14 <prvAddNewTaskToReadyList+0x28>
            prvInitialiseTaskLists();
4037af11:	fff725        	call8	4037ae84 <prvInitialiseTaskLists>
        if( ( pxCurrentTCBs[ 0 ] == NULL ) && ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) )
4037af14:	e73981        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037af17:	0020c0        	memw
4037af1a:	0888      	l32i.n	a8, a8, 0
4037af1c:	48ec      	bnez.n	a8, 4037af44 <prvAddNewTaskToReadyList+0x58>
4037af1e:	112282        	l32i	a8, a2, 68
4037af21:	40f890        	nsau	a9, a8
4037af24:	419590        	srli	a9, a9, 5
4037af27:	e62ba1        	l32r	a10, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037af2a:	c088a0        	sub	a8, a8, a10
4037af2d:	40f880        	nsau	a8, a8
4037af30:	418580        	srli	a8, a8, 5
4037af33:	209980        	or	a9, a9, a8
4037af36:	a98c      	beqz.n	a9, 4037af44 <prvAddNewTaskToReadyList+0x58>
            pxCurrentTCBs[ 0 ] = pxNewTCB;
4037af38:	e73081        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037af3b:	0020c0        	memw
4037af3e:	0829      	s32i.n	a2, a8, 0
4037af40:	002e46        	j	4037affd <prvAddNewTaskToReadyList+0x111>
4037af43:	00          	.byte	00
            else if( ( pxCurrentTCBs[ 1 ] == NULL ) && ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) )
4037af44:	e72d81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037af47:	0020c0        	memw
4037af4a:	1888      	l32i.n	a8, a8, 4
4037af4c:	58ec      	bnez.n	a8, 4037af75 <prvAddNewTaskToReadyList+0x89>
4037af4e:	112282        	l32i	a8, a2, 68
4037af51:	980b      	addi.n	a9, a8, -1
4037af53:	40f990        	nsau	a9, a9
4037af56:	419590        	srli	a9, a9, 5
4037af59:	e61ea1        	l32r	a10, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037af5c:	c088a0        	sub	a8, a8, a10
4037af5f:	40f880        	nsau	a8, a8
4037af62:	418580        	srli	a8, a8, 5
4037af65:	209980        	or	a9, a9, a8
4037af68:	998c      	beqz.n	a9, 4037af75 <prvAddNewTaskToReadyList+0x89>
                pxCurrentTCBs[ 1 ] = pxNewTCB;
4037af6a:	e72381        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037af6d:	0020c0        	memw
4037af70:	1829      	s32i.n	a2, a8, 4
4037af72:	0021c6        	j	4037affd <prvAddNewTaskToReadyList+0x111>
            if( xSchedulerRunning == pdFALSE )
4037af75:	e75581        	l32r	a8, 40374ccc <_iram_text_start+0x8c8> (3fc94fc8 <xSchedulerRunning>)
4037af78:	0020c0        	memw
4037af7b:	0888      	l32i.n	a8, a8, 0
4037af7d:	07c856        	bnez	a8, 4037affd <prvAddNewTaskToReadyList+0x111>
                if( ( pxCurrentTCBs[ 0 ] != NULL ) &&
4037af80:	e71e81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037af83:	0020c0        	memw
4037af86:	0888      	l32i.n	a8, a8, 0
4037af88:	48bc      	beqz.n	a8, 4037afc0 <prvAddNewTaskToReadyList+0xd4>
                    ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) &&
4037af8a:	112282        	l32i	a8, a2, 68
4037af8d:	40f890        	nsau	a9, a8
4037af90:	419590        	srli	a9, a9, 5
4037af93:	e610a1        	l32r	a10, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037af96:	c088a0        	sub	a8, a8, a10
4037af99:	40f880        	nsau	a8, a8
4037af9c:	418580        	srli	a8, a8, 5
4037af9f:	209980        	or	a9, a9, a8
                if( ( pxCurrentTCBs[ 0 ] != NULL ) &&
4037afa2:	a99c      	beqz.n	a9, 4037afc0 <prvAddNewTaskToReadyList+0xd4>
                    ( pxCurrentTCBs[ 0 ]->uxPriority <= pxNewTCB->uxPriority ) )
4037afa4:	e71581        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037afa7:	0020c0        	memw
4037afaa:	0888      	l32i.n	a8, a8, 0
4037afac:	b888      	l32i.n	a8, a8, 44
4037afae:	b298      	l32i.n	a9, a2, 44
                    ( taskIS_AFFINITY_COMPATIBLE( 0, pxNewTCB ) == pdTRUE ) &&
4037afb0:	0c3987        	bltu	a9, a8, 4037afc0 <prvAddNewTaskToReadyList+0xd4>
                    pxCurrentTCBs[ 0 ] = pxNewTCB;
4037afb3:	e71181        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037afb6:	0020c0        	memw
4037afb9:	0829      	s32i.n	a2, a8, 0
4037afbb:	000f86        	j	4037affd <prvAddNewTaskToReadyList+0x111>
4037afbe:	810000        	src	a0, a0, a0
                    else if( ( pxCurrentTCBs[ 1 ] != NULL ) &&
4037afc1:	20c0e70e 	ee.vmulas.s8.accx.ld.ip.qup	q0, a0, 112, q3, q5, q4, q0
4037afc5:	188800        	lsxp	f8, a8, a0
4037afc8:	18bc      	beqz.n	a8, 4037affd <prvAddNewTaskToReadyList+0x111>
                             ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) &&
4037afca:	112282        	l32i	a8, a2, 68
4037afcd:	980b      	addi.n	a9, a8, -1
4037afcf:	40f990        	nsau	a9, a9
4037afd2:	419590        	srli	a9, a9, 5
4037afd5:	e5ffa1        	l32r	a10, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037afd8:	c088a0        	sub	a8, a8, a10
4037afdb:	40f880        	nsau	a8, a8
4037afde:	418580        	srli	a8, a8, 5
4037afe1:	209980        	or	a9, a9, a8
                    else if( ( pxCurrentTCBs[ 1 ] != NULL ) &&
4037afe4:	599c      	beqz.n	a9, 4037affd <prvAddNewTaskToReadyList+0x111>
                             ( pxCurrentTCBs[ 1 ]->uxPriority <= pxNewTCB->uxPriority ) )
4037afe6:	e70481        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037afe9:	0020c0        	memw
4037afec:	1888      	l32i.n	a8, a8, 4
4037afee:	b888      	l32i.n	a8, a8, 44
4037aff0:	b298      	l32i.n	a9, a2, 44
                             ( taskIS_AFFINITY_COMPATIBLE( 1, pxNewTCB ) == pdTRUE ) &&
4037aff2:	073987        	bltu	a9, a8, 4037affd <prvAddNewTaskToReadyList+0x111>
                        pxCurrentTCBs[ 1 ] = pxNewTCB;
4037aff5:	e70081        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037aff8:	0020c0        	memw
4037affb:	1829      	s32i.n	a2, a8, 4
        uxTaskNumber++;
4037affd:	e73491        	l32r	a9, 40374cd0 <_iram_text_start+0x8cc> (3fc94fb4 <uxTaskNumber>)
4037b000:	0988      	l32i.n	a8, a9, 0
4037b002:	881b      	addi.n	a8, a8, 1
4037b004:	0989      	s32i.n	a8, a9, 0
        prvAddTaskToReadyList( pxNewTCB );
4037b006:	b288      	l32i.n	a8, a2, 44
4037b008:	e71991        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b00b:	0020c0        	memw
4037b00e:	0998      	l32i.n	a9, a9, 0
4037b010:	07b987        	bgeu	a9, a8, 4037b01b <prvAddNewTaskToReadyList+0x12f>
4037b013:	e71691        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b016:	0020c0        	memw
4037b019:	0989      	s32i.n	a8, a9, 0
4037b01b:	e715a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037b01e:	a08880        	addx4	a8, a8, a8
4037b021:	a088a0        	addx4	a8, a8, a10
4037b024:	0020c0        	memw
4037b027:	1888      	l32i.n	a8, a8, 4
4037b029:	0020c0        	memw
4037b02c:	2289      	s32i.n	a8, a2, 8
4037b02e:	0020c0        	memw
4037b031:	2898      	l32i.n	a9, a8, 8
4037b033:	0020c0        	memw
4037b036:	3299      	s32i.n	a9, a2, 12
4037b038:	0020c0        	memw
4037b03b:	28b8      	l32i.n	a11, a8, 8
4037b03d:	924b      	addi.n	a9, a2, 4
4037b03f:	0020c0        	memw
4037b042:	1b99      	s32i.n	a9, a11, 4
4037b044:	0020c0        	memw
4037b047:	2899      	s32i.n	a9, a8, 8
4037b049:	b288      	l32i.n	a8, a2, 44
4037b04b:	a09880        	addx4	a9, a8, a8
4037b04e:	a099a0        	addx4	a9, a9, a10
4037b051:	0020c0        	memw
4037b054:	5299      	s32i.n	a9, a2, 20
4037b056:	0020c0        	memw
4037b059:	0998      	l32i.n	a9, a9, 0
4037b05b:	991b      	addi.n	a9, a9, 1
4037b05d:	a08880        	addx4	a8, a8, a8
4037b060:	a088a0        	addx4	a8, a8, a10
4037b063:	0020c0        	memw
4037b066:	0899      	s32i.n	a9, a8, 0
        if( xSchedulerRunning != pdFALSE )
4037b068:	e71981        	l32r	a8, 40374ccc <_iram_text_start+0x8c8> (3fc94fc8 <xSchedulerRunning>)
4037b06b:	0020c0        	memw
4037b06e:	0888      	l32i.n	a8, a8, 0
4037b070:	489c      	beqz.n	a8, 4037b088 <prvAddNewTaskToReadyList+0x19c>
            if( taskIS_YIELD_REQUIRED( pxNewTCB, pdTRUE ) == pdTRUE )
4037b072:	1c0c      	movi.n	a12, 1
4037b074:	b2b8      	l32i.n	a11, a2, 44
4037b076:	20a220        	or	a10, a2, a2
4037b079:	ff8d65        	call8	4037a950 <prvIsYieldRequiredSMP>
4037b07c:	081a66        	bnei	a10, 1, 4037b088 <prvAddNewTaskToReadyList+0x19c>
4037b07f:	03eba0        	rsr.prid	a10
4037b082:	04ada0        	extui	a10, a10, 13, 1
                taskYIELD_IF_USING_PREEMPTION();
4037b085:	fcbce5        	call8	40377c54 <esp_crosscore_int_send_yield>
    taskEXIT_CRITICAL( &xKernelLock );
4037b088:	e702a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b08b:	ff0da5        	call8	4037a164 <vPortExitCritical>
}
4037b08e:	f01d      	retw.n

4037b090 <vTaskSuspendAll>:
{
4037b090:	004136        	entry	a1, 32
4037b093:	ffafb2        	movi	a11, -1
4037b096:	e6fea1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b099:	fef7a5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037b09c:	03eb80        	rsr.prid	a8
4037b09f:	048d80        	extui	a8, a8, 13, 1
        ++uxSchedulerSuspended[ portGET_CORE_ID() ];
4037b0a2:	e6ec91        	l32r	a9, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037b0a5:	a08890        	addx4	a8, a8, a9
4037b0a8:	0020c0        	memw
4037b0ab:	002892        	l32i	a9, a8, 0
4037b0ae:	991b      	addi.n	a9, a9, 1
4037b0b0:	0020c0        	memw
4037b0b3:	006892        	s32i	a9, a8, 0
    prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037b0b6:	e6f6a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b0b9:	ff0aa5        	call8	4037a164 <vPortExitCritical>
}
4037b0bc:	f01d      	retw.n
	...

4037b0c0 <xTaskGetTickCount>:
{
4037b0c0:	004136        	entry	a1, 32
        xTicks = xTickCount;
4037b0c3:	e6f881        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037b0c6:	0020c0        	memw
4037b0c9:	0828      	l32i.n	a2, a8, 0
}
4037b0cb:	f01d      	retw.n
4037b0cd:	000000        	ill

4037b0d0 <xTaskGetTickCountFromISR>:
{
4037b0d0:	004136        	entry	a1, 32
4037b0d3:	ffafb2        	movi	a11, -1
4037b0d6:	e6eea1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b0d9:	fef3a5        	call8	4037a014 <xPortEnterCriticalTimeout>
            xReturn = xTickCount;
4037b0dc:	e6f281        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037b0df:	0020c0        	memw
4037b0e2:	002822        	l32i	a2, a8, 0
    prvEXIT_CRITICAL_ISR_SMP_ONLY( &xKernelLock );
4037b0e5:	e6eaa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b0e8:	ff07a5        	call8	4037a164 <vPortExitCritical>
}
4037b0eb:	000090        	retw
	...

4037b0f0 <xTaskIncrementTick>:
{
4037b0f0:	004136        	entry	a1, 32
4037b0f3:	03eb80        	rsr.prid	a8
4037b0f6:	048d80        	extui	a8, a8, 13, 1
        configASSERT( portGET_CORE_ID() == 0 );
4037b0f9:	00e816        	beqz	a8, 4037b10b <xTaskIncrementTick+0x1b>
4037b0fc:	e6f6d1        	l32r	a13, 40374cd4 <_iram_text_start+0x8d0> (3c02339c <_flash_rodata_start+0x327c>)
4037b0ff:	e6f6c1        	l32r	a12, 40374cd8 <_iram_text_start+0x8d4> (3c02727c <__func__$25>)
4037b102:	e6f6b1        	l32r	a11, 40374cdc <_iram_text_start+0x8d8> (c87 <UserFrameTotalSize+0xb87>)
4037b105:	e6d8a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b108:	04c1e5        	call8	4037fd28 <__assert_func>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b10b:	feee65        	call8	40379ff0 <xPortInIsrContext>
4037b10e:	9acc      	bnez.n	a10, 4037b11b <xTaskIncrementTick+0x2b>
4037b110:	fb7c      	movi.n	a11, -1
4037b112:	e6dfa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b115:	feefe5        	call8	4037a014 <xPortEnterCriticalTimeout>
}
4037b118:	000206        	j	4037b124 <xTaskIncrementTick+0x34>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b11b:	ffafb2        	movi	a11, -1
4037b11e:	e6dca1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b121:	feef25        	call8	4037a014 <xPortEnterCriticalTimeout>
        if( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) pdFALSE )
4037b124:	e6cc81        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037b127:	0020c0        	memw
4037b12a:	002882        	l32i	a8, a8, 0
4037b12d:	257856        	bnez	a8, 4037b388 <xTaskIncrementTick+0x298>
            const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
4037b130:	e6dd81        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037b133:	0020c0        	memw
4037b136:	0878      	l32i.n	a7, a8, 0
4037b138:	771b      	addi.n	a7, a7, 1
            xTickCount = xConstTickCount;
4037b13a:	0020c0        	memw
4037b13d:	0879      	s32i.n	a7, a8, 0
            if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
4037b13f:	04d756        	bnez	a7, 4037b190 <xTaskIncrementTick+0xa0>
                taskSWITCH_DELAYED_LISTS();
4037b142:	e6c581        	l32r	a8, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037b145:	0020c0        	memw
4037b148:	0888      	l32i.n	a8, a8, 0
4037b14a:	0020c0        	memw
4037b14d:	0888      	l32i.n	a8, a8, 0
4037b14f:	00e816        	beqz	a8, 4037b161 <xTaskIncrementTick+0x71>
4037b152:	e6e3d1        	l32r	a13, 40374ce0 <_iram_text_start+0x8dc> (3c0233b4 <_flash_rodata_start+0x3294>)
4037b155:	e6e0c1        	l32r	a12, 40374cd8 <_iram_text_start+0x8d4> (3c02727c <__func__$25>)
4037b158:	e6e3b1        	l32r	a11, 40374ce4 <_iram_text_start+0x8e0> (ca7 <UserFrameTotalSize+0xba7>)
4037b15b:	e6c3a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b15e:	04bca5        	call8	4037fd28 <__assert_func>
4037b161:	e6bd91        	l32r	a9, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037b164:	0020c0        	memw
4037b167:	0029a2        	l32i	a10, a9, 0
4037b16a:	e6d081        	l32r	a8, 40374cac <_iram_text_start+0x8a8> (3fc9502c <pxOverflowDelayedTaskList>)
4037b16d:	0020c0        	memw
4037b170:	0028b2        	l32i	a11, a8, 0
4037b173:	0020c0        	memw
4037b176:	0069b2        	s32i	a11, a9, 0
4037b179:	0020c0        	memw
4037b17c:	08a9      	s32i.n	a10, a8, 0
4037b17e:	e6da91        	l32r	a9, 40374ce8 <_iram_text_start+0x8e4> (3fc94fb8 <xNumOfOverflows>)
4037b181:	0020c0        	memw
4037b184:	0988      	l32i.n	a8, a9, 0
4037b186:	881b      	addi.n	a8, a8, 1
4037b188:	0020c0        	memw
4037b18b:	0989      	s32i.n	a8, a9, 0
4037b18d:	ff7865        	call8	4037a914 <prvResetNextTaskUnblockTime>
            if( xConstTickCount >= xNextTaskUnblockTime )
4037b190:	e6b381        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037b193:	0020c0        	memw
4037b196:	0888      	l32i.n	a8, a8, 0
4037b198:	0ab787        	bgeu	a7, a8, 4037b1a6 <xTaskIncrementTick+0xb6>
    BaseType_t xSwitchRequired = pdFALSE;
4037b19b:	020c      	movi.n	a2, 0
4037b19d:	006ec6        	j	4037b35c <xTaskIncrementTick+0x26c>
                                    xSwitchRequired = pdTRUE;
4037b1a0:	120c      	movi.n	a2, 1
4037b1a2:	000086        	j	4037b1a8 <xTaskIncrementTick+0xb8>
4037b1a5:	020c00        	andb	b0, b12, b0
                    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037b1a8:	e6ac81        	l32r	a8, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037b1ab:	0020c0        	memw
4037b1ae:	0888      	l32i.n	a8, a8, 0
4037b1b0:	0020c0        	memw
4037b1b3:	0888      	l32i.n	a8, a8, 0
4037b1b5:	b8cc      	bnez.n	a8, 4037b1c4 <xTaskIncrementTick+0xd4>
                        xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b1b7:	e6a981        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037b1ba:	f97c      	movi.n	a9, -1
4037b1bc:	0020c0        	memw
4037b1bf:	0899      	s32i.n	a9, a8, 0
                        break;
4037b1c1:	0065c6        	j	4037b35c <xTaskIncrementTick+0x26c>
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b1c4:	e6a581        	l32r	a8, 40374c58 <_iram_text_start+0x854> (3fc95030 <pxDelayedTaskList>)
4037b1c7:	0020c0        	memw
4037b1ca:	0888      	l32i.n	a8, a8, 0
4037b1cc:	0020c0        	memw
4037b1cf:	3888      	l32i.n	a8, a8, 12
4037b1d1:	3888      	l32i.n	a8, a8, 12
                        xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
4037b1d3:	0020c0        	memw
4037b1d6:	1898      	l32i.n	a9, a8, 4
                        if( xConstTickCount < xItemValue )
4037b1d8:	0db797        	bgeu	a7, a9, 4037b1e9 <xTaskIncrementTick+0xf9>
                            xNextTaskUnblockTime = xItemValue;
4037b1db:	e6a081        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037b1de:	0020c0        	memw
4037b1e1:	0899      	s32i.n	a9, a8, 0
                            break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
4037b1e3:	005d46        	j	4037b35c <xTaskIncrementTick+0x26c>
4037b1e6:	000000        	ill
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037b1e9:	0020c0        	memw
4037b1ec:	5898      	l32i.n	a9, a8, 20
4037b1ee:	0020c0        	memw
4037b1f1:	28a8      	l32i.n	a10, a8, 8
4037b1f3:	0020c0        	memw
4037b1f6:	38b8      	l32i.n	a11, a8, 12
4037b1f8:	0020c0        	memw
4037b1fb:	2ab9      	s32i.n	a11, a10, 8
4037b1fd:	0020c0        	memw
4037b200:	38a8      	l32i.n	a10, a8, 12
4037b202:	0020c0        	memw
4037b205:	28b8      	l32i.n	a11, a8, 8
4037b207:	0020c0        	memw
4037b20a:	1ab9      	s32i.n	a11, a10, 4
4037b20c:	0020c0        	memw
4037b20f:	19b8      	l32i.n	a11, a9, 4
4037b211:	a84b      	addi.n	a10, a8, 4
4037b213:	0a9ba7        	bne	a11, a10, 4037b221 <xTaskIncrementTick+0x131>
4037b216:	0020c0        	memw
4037b219:	0328b2        	l32i	a11, a8, 12
4037b21c:	0020c0        	memw
4037b21f:	19b9      	s32i.n	a11, a9, 4
4037b221:	0b0c      	movi.n	a11, 0
4037b223:	0020c0        	memw
4037b226:	58b9      	s32i.n	a11, a8, 20
4037b228:	0020c0        	memw
4037b22b:	09b8      	l32i.n	a11, a9, 0
4037b22d:	bb0b      	addi.n	a11, a11, -1
4037b22f:	0020c0        	memw
4037b232:	09b9      	s32i.n	a11, a9, 0
                        if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037b234:	0020c0        	memw
4037b237:	a898      	l32i.n	a9, a8, 40
4037b239:	04c916        	beqz	a9, 4037b289 <xTaskIncrementTick+0x199>
                            listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
4037b23c:	0020c0        	memw
4037b23f:	a898      	l32i.n	a9, a8, 40
4037b241:	0020c0        	memw
4037b244:	78b8      	l32i.n	a11, a8, 28
4037b246:	0020c0        	memw
4037b249:	88c8      	l32i.n	a12, a8, 32
4037b24b:	0020c0        	memw
4037b24e:	2bc9      	s32i.n	a12, a11, 8
4037b250:	0020c0        	memw
4037b253:	88b8      	l32i.n	a11, a8, 32
4037b255:	0020c0        	memw
4037b258:	78c8      	l32i.n	a12, a8, 28
4037b25a:	0020c0        	memw
4037b25d:	1bc9      	s32i.n	a12, a11, 4
4037b25f:	0020c0        	memw
4037b262:	19c8      	l32i.n	a12, a9, 4
4037b264:	18c8b2        	addi	a11, a8, 24
4037b267:	0a9cb7        	bne	a12, a11, 4037b275 <xTaskIncrementTick+0x185>
4037b26a:	0020c0        	memw
4037b26d:	0828b2        	l32i	a11, a8, 32
4037b270:	0020c0        	memw
4037b273:	19b9      	s32i.n	a11, a9, 4
4037b275:	0b0c      	movi.n	a11, 0
4037b277:	0020c0        	memw
4037b27a:	a8b9      	s32i.n	a11, a8, 40
4037b27c:	0020c0        	memw
4037b27f:	09b8      	l32i.n	a11, a9, 0
4037b281:	ffcbb2        	addi	a11, a11, -1
4037b284:	0020c0        	memw
4037b287:	09b9      	s32i.n	a11, a9, 0
                        prvAddTaskToReadyList( pxTCB );
4037b289:	b898      	l32i.n	a9, a8, 44
4037b28b:	e678b1        	l32r	a11, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b28e:	0020c0        	memw
4037b291:	002bb2        	l32i	a11, a11, 0
4037b294:	08bb97        	bgeu	a11, a9, 4037b2a0 <xTaskIncrementTick+0x1b0>
4037b297:	e675b1        	l32r	a11, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b29a:	0020c0        	memw
4037b29d:	006b92        	s32i	a9, a11, 0
4037b2a0:	e674b1        	l32r	a11, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037b2a3:	a09990        	addx4	a9, a9, a9
4037b2a6:	a099b0        	addx4	a9, a9, a11
4037b2a9:	0020c0        	memw
4037b2ac:	1998      	l32i.n	a9, a9, 4
4037b2ae:	0020c0        	memw
4037b2b1:	2899      	s32i.n	a9, a8, 8
4037b2b3:	0020c0        	memw
4037b2b6:	29c8      	l32i.n	a12, a9, 8
4037b2b8:	0020c0        	memw
4037b2bb:	38c9      	s32i.n	a12, a8, 12
4037b2bd:	0020c0        	memw
4037b2c0:	29c8      	l32i.n	a12, a9, 8
4037b2c2:	0020c0        	memw
4037b2c5:	1ca9      	s32i.n	a10, a12, 4
4037b2c7:	0020c0        	memw
4037b2ca:	29a9      	s32i.n	a10, a9, 8
4037b2cc:	b898      	l32i.n	a9, a8, 44
4037b2ce:	a0a990        	addx4	a10, a9, a9
4037b2d1:	a0aab0        	addx4	a10, a10, a11
4037b2d4:	0020c0        	memw
4037b2d7:	58a9      	s32i.n	a10, a8, 20
4037b2d9:	0020c0        	memw
4037b2dc:	0aa8      	l32i.n	a10, a10, 0
4037b2de:	aa1b      	addi.n	a10, a10, 1
4037b2e0:	a09990        	addx4	a9, a9, a9
4037b2e3:	a099b0        	addx4	a9, a9, a11
4037b2e6:	0020c0        	memw
4037b2e9:	09a9      	s32i.n	a10, a9, 0
                            if( taskIS_AFFINITY_COMPATIBLE( 0, pxTCB ) == pdTRUE )
4037b2eb:	1128b2        	l32i	a11, a8, 68
4037b2ee:	40fba0        	nsau	a10, a11
4037b2f1:	41a5a0        	srli	a10, a10, 5
4037b2f4:	e53891        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b2f7:	c09b90        	sub	a9, a11, a9
4037b2fa:	40f990        	nsau	a9, a9
4037b2fd:	419590        	srli	a9, a9, 5
4037b300:	20aa90        	or	a10, a10, a9
4037b303:	6abc      	beqz.n	a10, 4037b33d <xTaskIncrementTick+0x24d>
                                if( pxTCB->uxPriority > pxCurrentTCBs[ 0 ]->uxPriority )
4037b305:	b888      	l32i.n	a8, a8, 44
4037b307:	e63c91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b30a:	0020c0        	memw
4037b30d:	0998      	l32i.n	a9, a9, 0
4037b30f:	b998      	l32i.n	a9, a9, 44
4037b311:	02b987        	bgeu	a9, a8, 4037b317 <xTaskIncrementTick+0x227>
4037b314:	ffa206        	j	4037b1a0 <xTaskIncrementTick+0xb0>
                                    else if( pxTCB->xCoreID == tskNO_AFFINITY )
4037b317:	e52f91        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037b31a:	021b97        	beq	a11, a9, 4037b320 <xTaskIncrementTick+0x230>
4037b31d:	ffa1c6        	j	4037b1a8 <xTaskIncrementTick+0xb8>
                                        if( pxTCB->uxPriority > pxCurrentTCBs[ 1 ]->uxPriority )
4037b320:	e63691        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b323:	0020c0        	memw
4037b326:	1998      	l32i.n	a9, a9, 4
4037b328:	b998      	l32i.n	a9, a9, 44
4037b32a:	023987        	bltu	a9, a8, 4037b330 <xTaskIncrementTick+0x240>
4037b32d:	ff9dc6        	j	4037b1a8 <xTaskIncrementTick+0xb8>
                                            xYieldPending[ 1 ] = pdTRUE;
4037b330:	e66f81        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037b333:	190c      	movi.n	a9, 1
4037b335:	0020c0        	memw
4037b338:	1899      	s32i.n	a9, a8, 4
4037b33a:	ff9a86        	j	4037b1a8 <xTaskIncrementTick+0xb8>
                                    if( pxTCB->uxPriority > pxCurrentTCBs[ 1 ]->uxPriority )
4037b33d:	b888      	l32i.n	a8, a8, 44
4037b33f:	e62e91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b342:	0020c0        	memw
4037b345:	1998      	l32i.n	a9, a9, 4
4037b347:	b998      	l32i.n	a9, a9, 44
4037b349:	023987        	bltu	a9, a8, 4037b34f <xTaskIncrementTick+0x25f>
4037b34c:	ff9606        	j	4037b1a8 <xTaskIncrementTick+0xb8>
                                        xYieldPending[ 1 ] = pdTRUE;
4037b34f:	e66781        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037b352:	190c      	movi.n	a9, 1
4037b354:	0020c0        	memw
4037b357:	1899      	s32i.n	a9, a8, 4
4037b359:	ff92c6        	j	4037b1a8 <xTaskIncrementTick+0xb8>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ 0 ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b35c:	e62781        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b35f:	0020c0        	memw
4037b362:	0888      	l32i.n	a8, a8, 0
4037b364:	b888      	l32i.n	a8, a8, 44
4037b366:	a08880        	addx4	a8, a8, a8
4037b369:	e64191        	l32r	a9, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037b36c:	a08890        	addx4	a8, a8, a9
4037b36f:	0020c0        	memw
4037b372:	0888      	l32i.n	a8, a8, 0
4037b374:	0128b6        	bltui	a8, 2, 4037b379 <xTaskIncrementTick+0x289>
                    xSwitchRequired = pdTRUE;
4037b377:	120c      	movi.n	a2, 1
                if( xYieldPending[ 0 ] != pdFALSE )
4037b379:	e65c81        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037b37c:	0020c0        	memw
4037b37f:	0888      	l32i.n	a8, a8, 0
4037b381:	88dc      	bnez.n	a8, 4037b39d <xTaskIncrementTick+0x2ad>
4037b383:	000646        	j	4037b3a0 <xTaskIncrementTick+0x2b0>
4037b386:	910000        	srl	a0, a0
            ++xPendedTicks;
4037b389:	e65a      	add.n	a14, a6, a5
4037b38b:	0020c0        	memw
4037b38e:	0988      	l32i.n	a8, a9, 0
4037b390:	881b      	addi.n	a8, a8, 1
4037b392:	0020c0        	memw
4037b395:	0989      	s32i.n	a8, a9, 0
    BaseType_t xSwitchRequired = pdFALSE;
4037b397:	020c      	movi.n	a2, 0
4037b399:	0000c6        	j	4037b3a0 <xTaskIncrementTick+0x2b0>
4037b39c:	a02200        	addx4	a2, a2, a0
                    xSwitchRequired = pdTRUE;
4037b39f:	c4e501        	l32r	a0, 4036c734 <rom_rx_gain_force+0x366308>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b3a2:	009a56fe 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 96, q1, q3, q1, q2
            taskEXIT_CRITICAL( pxLock );
4037b3a6:	e63aa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b3a9:	fedba5        	call8	4037a164 <vPortExitCritical>
4037b3ac:	000186        	j	4037b3b6 <xTaskIncrementTick+0x2c6>
4037b3af:	00          	.byte	00
            taskEXIT_CRITICAL_ISR( pxLock );
4037b3b0:	e638a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b3b3:	fedb25        	call8	4037a164 <vPortExitCritical>
}
4037b3b6:	f01d      	retw.n

4037b3b8 <vTaskSwitchContext>:
{
4037b3b8:	004136        	entry	a1, 32
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b3bb:	fec365        	call8	40379ff0 <xPortInIsrContext>
4037b3be:	00ba56        	bnez	a10, 4037b3cd <vTaskSwitchContext+0x15>
4037b3c1:	ffafb2        	movi	a11, -1
4037b3c4:	e633a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b3c7:	fec4e5        	call8	4037a014 <xPortEnterCriticalTimeout>
}
4037b3ca:	000206        	j	4037b3d6 <vTaskSwitchContext+0x1e>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b3cd:	ffafb2        	movi	a11, -1
4037b3d0:	e630a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b3d3:	fec425        	call8	4037a014 <xPortEnterCriticalTimeout>
4037b3d6:	03eb80        	rsr.prid	a8
4037b3d9:	048d80        	extui	a8, a8, 13, 1
        if( uxSchedulerSuspended[ xCurCoreID ] != ( UBaseType_t ) pdFALSE )
4037b3dc:	e61e91        	l32r	a9, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037b3df:	a09890        	addx4	a9, a8, a9
4037b3e2:	0020c0        	memw
4037b3e5:	002992        	l32i	a9, a9, 0
4037b3e8:	010916        	beqz	a9, 4037b3fc <vTaskSwitchContext+0x44>
            xYieldPending[ xCurCoreID ] = pdTRUE;
4037b3eb:	e64091        	l32r	a9, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037b3ee:	a08890        	addx4	a8, a8, a9
4037b3f1:	190c      	movi.n	a9, 1
4037b3f3:	0020c0        	memw
4037b3f6:	0899      	s32i.n	a9, a8, 0
4037b3f8:	001346        	j	4037b449 <vTaskSwitchContext+0x91>
4037b3fb:	00          	.byte	00
            xYieldPending[ xCurCoreID ] = pdFALSE;
4037b3fc:	e63c91        	l32r	a9, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037b3ff:	a09890        	addx4	a9, a8, a9
4037b402:	0a0c      	movi.n	a10, 0
4037b404:	0020c0        	memw
4037b407:	09a9      	s32i.n	a10, a9, 0
            taskCHECK_FOR_STACK_OVERFLOW( xCurCoreID );
4037b409:	e5fb91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b40c:	a09890        	addx4	a9, a8, a9
4037b40f:	0020c0        	memw
4037b412:	0998      	l32i.n	a9, a9, 0
4037b414:	c998      	l32i.n	a9, a9, 48
4037b416:	09b8      	l32i.n	a11, a9, 0
4037b418:	e637a1        	l32r	a10, 40374cf4 <_iram_text_start+0x8f0> (a5a5a5a5 <_rtc_reserved_end+0x4595a5a5>)
4037b41b:	119ba7        	bne	a11, a10, 4037b430 <vTaskSwitchContext+0x78>
4037b41e:	19b8      	l32i.n	a11, a9, 4
4037b420:	0c9ba7        	bne	a11, a10, 4037b430 <vTaskSwitchContext+0x78>
4037b423:	29b8      	l32i.n	a11, a9, 8
4037b425:	079ba7        	bne	a11, a10, 4037b430 <vTaskSwitchContext+0x78>
4037b428:	39a8      	l32i.n	a10, a9, 12
4037b42a:	e63291        	l32r	a9, 40374cf4 <_iram_text_start+0x8f0> (a5a5a5a5 <_rtc_reserved_end+0x4595a5a5>)
4037b42d:	151a97        	beq	a10, a9, 4037b446 <vTaskSwitchContext+0x8e>
4037b430:	e5f291        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b433:	a08890        	addx4	a8, a8, a9
4037b436:	0020c0        	memw
4037b439:	08a8      	l32i.n	a10, a8, 0
4037b43b:	0020c0        	memw
4037b43e:	08b8      	l32i.n	a11, a8, 0
4037b440:	34cbb2        	addi	a11, a11, 52
4037b443:	fedca5        	call8	4037a20c <vApplicationStackOverflowHook>
            taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b446:	ff5a65        	call8	4037a9ec <prvSelectHighestPriorityTaskSMP>
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b449:	feba65        	call8	40379ff0 <xPortInIsrContext>
4037b44c:	8acc      	bnez.n	a10, 4037b458 <vTaskSwitchContext+0xa0>
            taskEXIT_CRITICAL( pxLock );
4037b44e:	e610a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b451:	fed125        	call8	4037a164 <vPortExitCritical>
4037b454:	000186        	j	4037b45e <vTaskSwitchContext+0xa6>
4037b457:	00          	.byte	00
            taskEXIT_CRITICAL_ISR( pxLock );
4037b458:	e60ea1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b45b:	fed0a5        	call8	4037a164 <vPortExitCritical>
}
4037b45e:	f01d      	retw.n

4037b460 <vTaskPlaceOnEventList>:
{
4037b460:	004136        	entry	a1, 32
    configASSERT( pxEventList );
4037b463:	00e256        	bnez	a2, 4037b475 <vTaskPlaceOnEventList+0x15>
4037b466:	e624d1        	l32r	a13, 40374cf8 <_iram_text_start+0x8f4> (3c02342c <_flash_rodata_start+0x330c>)
4037b469:	e624c1        	l32r	a12, 40374cfc <_iram_text_start+0x8f8> (3c027244 <__func__$23>)
4037b46c:	e625b1        	l32r	a11, 40374d00 <_iram_text_start+0x8fc> (ea1 <UserFrameTotalSize+0xda1>)
4037b46f:	e5fea1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b472:	048b65        	call8	4037fd28 <__assert_func>
4037b475:	fb7c      	movi.n	a11, -1
4037b477:	e606a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b47a:	feb9a5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037b47d:	03eb80        	rsr.prid	a8
4037b480:	048d80        	extui	a8, a8, 13, 1
        vListInsert( pxEventList, &( pxCurrentTCBs[ portGET_CORE_ID() ]->xEventListItem ) );
4037b483:	e5dd91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b486:	a08890        	addx4	a8, a8, a9
4037b489:	0020c0        	memw
4037b48c:	0028b2        	l32i	a11, a8, 0
4037b48f:	18cbb2        	addi	a11, a11, 24
4037b492:	20a220        	or	a10, a2, a2
4037b495:	ff3865        	call8	4037a81c <vListInsert>
        prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4037b498:	1b0c      	movi.n	a11, 1
4037b49a:	03ad      	mov.n	a10, a3
4037b49c:	ff8165        	call8	4037acb4 <prvAddCurrentTaskToDelayedList>
    prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037b49f:	e5fca1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b4a2:	fecc25        	call8	4037a164 <vPortExitCritical>
}
4037b4a5:	f01d      	retw.n
	...

4037b4a8 <xTaskRemoveFromEventList>:
    {
4037b4a8:	004136        	entry	a1, 32
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b4ab:	feb465        	call8	40379ff0 <xPortInIsrContext>
4037b4ae:	00ca56        	bnez	a10, 4037b4be <xTaskRemoveFromEventList+0x16>
4037b4b1:	fb7c      	movi.n	a11, -1
4037b4b3:	e5f7a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b4b6:	feb5e5        	call8	4037a014 <xPortEnterCriticalTimeout>
}
4037b4b9:	000286        	j	4037b4c7 <xTaskRemoveFromEventList+0x1f>
4037b4bc:	b20000        	mulsh	a0, a0, a0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b4bf:	af          	.byte	0xaf
4037b4c0:	e5f3a1ff 	ee.vmin.s16.st.incp	q7, a15, q3, q6, q5
4037b4c4:	feb4e5        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( listLIST_IS_EMPTY( pxEventList ) == pdFALSE )
4037b4c7:	0020c0        	memw
4037b4ca:	002282        	l32i	a8, a2, 0
4037b4cd:	1b4816        	beqz	a8, 4037b685 <xTaskRemoveFromEventList+0x1dd>
4037b4d0:	03eb60        	rsr.prid	a6
4037b4d3:	046d60        	extui	a6, a6, 13, 1
4037b4d6:	065d      	mov.n	a5, a6
                pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
4037b4d8:	0020c0        	memw
4037b4db:	3288      	l32i.n	a8, a2, 12
4037b4dd:	3878      	l32i.n	a7, a8, 12
                configASSERT( pxUnblockedTCB );
4037b4df:	00e756        	bnez	a7, 4037b4f1 <xTaskRemoveFromEventList+0x49>
4037b4e2:	e608d1        	l32r	a13, 40374d04 <_iram_text_start+0x900> (3c023438 <_flash_rodata_start+0x3318>)
4037b4e5:	e608c1        	l32r	a12, 40374d08 <_iram_text_start+0x904> (3c027228 <__func__$20>)
4037b4e8:	e609b1        	l32r	a11, 40374d0c <_iram_text_start+0x908> (f36 <UserFrameTotalSize+0xe36>)
4037b4eb:	e5dfa1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b4ee:	0483a5        	call8	4037fd28 <__assert_func>
                listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
4037b4f1:	0020c0        	memw
4037b4f4:	a788      	l32i.n	a8, a7, 40
4037b4f6:	0020c0        	memw
4037b4f9:	7798      	l32i.n	a9, a7, 28
4037b4fb:	0020c0        	memw
4037b4fe:	87a8      	l32i.n	a10, a7, 32
4037b500:	0020c0        	memw
4037b503:	29a9      	s32i.n	a10, a9, 8
4037b505:	0020c0        	memw
4037b508:	8798      	l32i.n	a9, a7, 32
4037b50a:	0020c0        	memw
4037b50d:	77a8      	l32i.n	a10, a7, 28
4037b50f:	0020c0        	memw
4037b512:	19a9      	s32i.n	a10, a9, 4
4037b514:	0020c0        	memw
4037b517:	1898      	l32i.n	a9, a8, 4
4037b519:	18c722        	addi	a2, a7, 24
4037b51c:	099927        	bne	a9, a2, 4037b529 <xTaskRemoveFromEventList+0x81>
4037b51f:	0020c0        	memw
4037b522:	8798      	l32i.n	a9, a7, 32
4037b524:	0020c0        	memw
4037b527:	1899      	s32i.n	a9, a8, 4
4037b529:	00a092        	movi	a9, 0
4037b52c:	0020c0        	memw
4037b52f:	0a6792        	s32i	a9, a7, 40
4037b532:	0020c0        	memw
4037b535:	002892        	l32i	a9, a8, 0
4037b538:	990b      	addi.n	a9, a9, -1
4037b53a:	0020c0        	memw
4037b53d:	0899      	s32i.n	a9, a8, 0
                if( taskCAN_BE_SCHEDULED( pxUnblockedTCB ) == pdTRUE )
4037b53f:	07ad      	mov.n	a10, a7
4037b541:	ff38a5        	call8	4037a8cc <prvCheckTaskCanBeScheduledSMP>
4037b544:	021a26        	beqi	a10, 1, 4037b54a <xTaskRemoveFromEventList+0xa2>
4037b547:	002b86        	j	4037b5f9 <xTaskRemoveFromEventList+0x151>
                    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
4037b54a:	0020c0        	memw
4037b54d:	5788      	l32i.n	a8, a7, 20
4037b54f:	0020c0        	memw
4037b552:	2798      	l32i.n	a9, a7, 8
4037b554:	0020c0        	memw
4037b557:	37a8      	l32i.n	a10, a7, 12
4037b559:	0020c0        	memw
4037b55c:	29a9      	s32i.n	a10, a9, 8
4037b55e:	0020c0        	memw
4037b561:	3798      	l32i.n	a9, a7, 12
4037b563:	0020c0        	memw
4037b566:	27a8      	l32i.n	a10, a7, 8
4037b568:	0020c0        	memw
4037b56b:	19a9      	s32i.n	a10, a9, 4
4037b56d:	0020c0        	memw
4037b570:	18a8      	l32i.n	a10, a8, 4
4037b572:	974b      	addi.n	a9, a7, 4
4037b574:	099a97        	bne	a10, a9, 4037b581 <xTaskRemoveFromEventList+0xd9>
4037b577:	0020c0        	memw
4037b57a:	37a8      	l32i.n	a10, a7, 12
4037b57c:	0020c0        	memw
4037b57f:	18a9      	s32i.n	a10, a8, 4
4037b581:	0a0c      	movi.n	a10, 0
4037b583:	0020c0        	memw
4037b586:	57a9      	s32i.n	a10, a7, 20
4037b588:	0020c0        	memw
4037b58b:	08a8      	l32i.n	a10, a8, 0
4037b58d:	aa0b      	addi.n	a10, a10, -1
4037b58f:	0020c0        	memw
4037b592:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxUnblockedTCB );
4037b594:	b788      	l32i.n	a8, a7, 44
4037b596:	e5b5a1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b599:	0020c0        	memw
4037b59c:	0aa8      	l32i.n	a10, a10, 0
4037b59e:	07ba87        	bgeu	a10, a8, 4037b5a9 <xTaskRemoveFromEventList+0x101>
4037b5a1:	e5b2a1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b5a4:	0020c0        	memw
4037b5a7:	0a89      	s32i.n	a8, a10, 0
4037b5a9:	e5b1a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037b5ac:	a08880        	addx4	a8, a8, a8
4037b5af:	a088a0        	addx4	a8, a8, a10
4037b5b2:	0020c0        	memw
4037b5b5:	1888      	l32i.n	a8, a8, 4
4037b5b7:	0020c0        	memw
4037b5ba:	2789      	s32i.n	a8, a7, 8
4037b5bc:	0020c0        	memw
4037b5bf:	28b8      	l32i.n	a11, a8, 8
4037b5c1:	0020c0        	memw
4037b5c4:	37b9      	s32i.n	a11, a7, 12
4037b5c6:	0020c0        	memw
4037b5c9:	28b8      	l32i.n	a11, a8, 8
4037b5cb:	0020c0        	memw
4037b5ce:	1b99      	s32i.n	a9, a11, 4
4037b5d0:	0020c0        	memw
4037b5d3:	2899      	s32i.n	a9, a8, 8
4037b5d5:	b788      	l32i.n	a8, a7, 44
4037b5d7:	a09880        	addx4	a9, a8, a8
4037b5da:	a099a0        	addx4	a9, a9, a10
4037b5dd:	0020c0        	memw
4037b5e0:	5799      	s32i.n	a9, a7, 20
4037b5e2:	0020c0        	memw
4037b5e5:	0998      	l32i.n	a9, a9, 0
4037b5e7:	991b      	addi.n	a9, a9, 1
4037b5e9:	a08880        	addx4	a8, a8, a8
4037b5ec:	a088a0        	addx4	a8, a8, a10
4037b5ef:	0020c0        	memw
4037b5f2:	0899      	s32i.n	a9, a8, 0
4037b5f4:	001bc6        	j	4037b667 <xTaskRemoveFromEventList+0x1bf>
4037b5f7:	820000        	mull	a0, a0, a0
                    UBaseType_t uxPendCore = ( ( pxUnblockedTCB->xCoreID == tskNO_AFFINITY ) ? xCurCoreID : pxUnblockedTCB->xCoreID );
4037b5fa:	911127        	beq	a1, a2, 4037b58f <xTaskRemoveFromEventList+0xe7>
4037b5fd:	76          	.byte	0x76
4037b5fe:	e4          	.byte	0xe4
4037b5ff:	021897        	beq	a8, a9, 4037b605 <xTaskRemoveFromEventList+0x15d>
4037b602:	206880        	or	a6, a8, a8
                    configASSERT( uxSchedulerSuspended[ uxPendCore ] != ( UBaseType_t ) 0U );
4037b605:	e59381        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037b608:	a08680        	addx4	a8, a6, a8
4037b60b:	0020c0        	memw
4037b60e:	002882        	l32i	a8, a8, 0
4037b611:	00e856        	bnez	a8, 4037b623 <xTaskRemoveFromEventList+0x17b>
4037b614:	e5bfd1        	l32r	a13, 40374d10 <_iram_text_start+0x90c> (3c023448 <_flash_rodata_start+0x3328>)
4037b617:	e5bcc1        	l32r	a12, 40374d08 <_iram_text_start+0x904> (3c027228 <__func__$20>)
4037b61a:	e5beb1        	l32r	a11, 40374d14 <_iram_text_start+0x910> (f59 <UserFrameTotalSize+0xe59>)
4037b61d:	e592a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b620:	047065        	call8	4037fd28 <__assert_func>
                    listINSERT_END( &( xPendingReadyList[ uxPendCore ] ), &( pxUnblockedTCB->xEventListItem ) );
4037b623:	e5a9a1        	l32r	a10, 40374cc8 <_iram_text_start+0x8c4> (3fc95004 <xPendingReadyList>)
4037b626:	a08660        	addx4	a8, a6, a6
4037b629:	a088a0        	addx4	a8, a8, a10
4037b62c:	0020c0        	memw
4037b62f:	012892        	l32i	a9, a8, 4
4037b632:	0020c0        	memw
4037b635:	7799      	s32i.n	a9, a7, 28
4037b637:	0020c0        	memw
4037b63a:	29b8      	l32i.n	a11, a9, 8
4037b63c:	0020c0        	memw
4037b63f:	87b9      	s32i.n	a11, a7, 32
4037b641:	0020c0        	memw
4037b644:	29b8      	l32i.n	a11, a9, 8
4037b646:	0020c0        	memw
4037b649:	1b29      	s32i.n	a2, a11, 4
4037b64b:	0020c0        	memw
4037b64e:	2929      	s32i.n	a2, a9, 8
4037b650:	0020c0        	memw
4037b653:	a789      	s32i.n	a8, a7, 40
4037b655:	0020c0        	memw
4037b658:	0888      	l32i.n	a8, a8, 0
4037b65a:	881b      	addi.n	a8, a8, 1
4037b65c:	a06660        	addx4	a6, a6, a6
4037b65f:	a066a0        	addx4	a6, a6, a10
4037b662:	0020c0        	memw
4037b665:	0689      	s32i.n	a8, a6, 0
                if( taskIS_YIELD_REQUIRED( pxUnblockedTCB, pdFALSE ) == pdTRUE )
4037b667:	0c0c      	movi.n	a12, 0
4037b669:	b7b8      	l32i.n	a11, a7, 44
4037b66b:	07ad      	mov.n	a10, a7
4037b66d:	ff2e25        	call8	4037a950 <prvIsYieldRequiredSMP>
4037b670:	0a2d      	mov.n	a2, a10
4037b672:	141a66        	bnei	a10, 1, 4037b68a <xTaskRemoveFromEventList+0x1e2>
                    xYieldPending[ xCurCoreID ] = pdTRUE;
4037b675:	e59d81        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037b678:	a05580        	addx4	a5, a5, a8
4037b67b:	180c      	movi.n	a8, 1
4037b67d:	0020c0        	memw
4037b680:	0589      	s32i.n	a8, a5, 0
4037b682:	0001c6        	j	4037b68d <xTaskRemoveFromEventList+0x1e5>
                xReturn = pdFALSE;
4037b685:	020c      	movi.n	a2, 0
4037b687:	000086        	j	4037b68d <xTaskRemoveFromEventList+0x1e5>
                    xReturn = pdFALSE;
4037b68a:	00a022        	movi	a2, 0
        if( portCHECK_IF_IN_ISR() == pdFALSE )
4037b68d:	fe9625        	call8	40379ff0 <xPortInIsrContext>
4037b690:	008a56        	bnez	a10, 4037b69c <xTaskRemoveFromEventList+0x1f4>
            taskEXIT_CRITICAL( &xKernelLock );
4037b693:	e57fa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b696:	feace5        	call8	4037a164 <vPortExitCritical>
4037b699:	000146        	j	4037b6a2 <xTaskRemoveFromEventList+0x1fa>
            taskEXIT_CRITICAL_ISR( &xKernelLock );
4037b69c:	e57da1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b69f:	feac65        	call8	4037a164 <vPortExitCritical>
    }
4037b6a2:	f01d      	retw.n

4037b6a4 <vTaskInternalSetTimeOutState>:
{
4037b6a4:	004136        	entry	a1, 32
    pxTimeOut->xOverflowCount = xNumOfOverflows;
4037b6a7:	e59081        	l32r	a8, 40374ce8 <_iram_text_start+0x8e4> (3fc94fb8 <xNumOfOverflows>)
4037b6aa:	0020c0        	memw
4037b6ad:	0888      	l32i.n	a8, a8, 0
4037b6af:	0289      	s32i.n	a8, a2, 0
    pxTimeOut->xTimeOnEntering = xTickCount;
4037b6b1:	e57c81        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037b6b4:	0020c0        	memw
4037b6b7:	0888      	l32i.n	a8, a8, 0
4037b6b9:	1289      	s32i.n	a8, a2, 4
}
4037b6bb:	f01d      	retw.n
4037b6bd:	000000        	ill

4037b6c0 <xTaskCheckForTimeOut>:
{
4037b6c0:	004136        	entry	a1, 32
    configASSERT( pxTimeOut );
4037b6c3:	00e256        	bnez	a2, 4037b6d5 <xTaskCheckForTimeOut+0x15>
4037b6c6:	e594d1        	l32r	a13, 40374d18 <_iram_text_start+0x914> (3c023484 <_flash_rodata_start+0x3364>)
4037b6c9:	e594c1        	l32r	a12, 40374d1c <_iram_text_start+0x918> (3c027210 <__func__$17>)
4037b6cc:	e595b1        	l32r	a11, 40374d20 <_iram_text_start+0x91c> (1046 <UserFrameTotalSize+0xf46>)
4037b6cf:	e566a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b6d2:	046565        	call8	4037fd28 <__assert_func>
    configASSERT( pxTicksToWait );
4037b6d5:	00e356        	bnez	a3, 4037b6e7 <xTaskCheckForTimeOut+0x27>
4037b6d8:	e593d1        	l32r	a13, 40374d24 <_iram_text_start+0x920> (3c023490 <_flash_rodata_start+0x3370>)
4037b6db:	e590c1        	l32r	a12, 40374d1c <_iram_text_start+0x918> (3c027210 <__func__$17>)
4037b6de:	e592b1        	l32r	a11, 40374d28 <_iram_text_start+0x924> (1047 <UserFrameTotalSize+0xf47>)
4037b6e1:	e561a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b6e4:	046425        	call8	4037fd28 <__assert_func>
4037b6e7:	fb7c      	movi.n	a11, -1
4037b6e9:	e569a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b6ec:	fe9265        	call8	4037a014 <xPortEnterCriticalTimeout>
        const TickType_t xConstTickCount = xTickCount;
4037b6ef:	e56d81        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037b6f2:	0020c0        	memw
4037b6f5:	0028b2        	l32i	a11, a8, 0
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
4037b6f8:	12a8      	l32i.n	a10, a2, 4
4037b6fa:	c0cba0        	sub	a12, a11, a10
4037b6fd:	03eb90        	rsr.prid	a9
4037b700:	049d90        	extui	a9, a9, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted != ( uint8_t ) pdFALSE )
4037b703:	e53d81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b706:	a08980        	addx4	a8, a9, a8
4037b709:	0020c0        	memw
4037b70c:	0888      	l32i.n	a8, a8, 0
4037b70e:	01d882        	addmi	a8, a8, 0x100
4037b711:	520882        	l8ui	a8, a8, 82
4037b714:	689c      	beqz.n	a8, 4037b72e <xTaskCheckForTimeOut+0x6e>
                pxCurrentTCBs[ xCurCoreID ]->ucDelayAborted = pdFALSE;
4037b716:	e53881        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b719:	a09980        	addx4	a9, a9, a8
4037b71c:	0020c0        	memw
4037b71f:	0988      	l32i.n	a8, a9, 0
4037b721:	01d882        	addmi	a8, a8, 0x100
4037b724:	090c      	movi.n	a9, 0
4037b726:	524892        	s8i	a9, a8, 82
                xReturn = pdTRUE;
4037b729:	120c      	movi.n	a2, 1
4037b72b:	001006        	j	4037b76f <xTaskCheckForTimeOut+0xaf>
            if( *pxTicksToWait == portMAX_DELAY )
4037b72e:	0388      	l32i.n	a8, a3, 0
4037b730:	390826        	beqi	a8, -1, 4037b76d <xTaskCheckForTimeOut+0xad>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
4037b733:	02d8      	l32i.n	a13, a2, 0
4037b735:	e56c91        	l32r	a9, 40374ce8 <_iram_text_start+0x8e4> (3fc94fb8 <xNumOfOverflows>)
4037b738:	0020c0        	memw
4037b73b:	0998      	l32i.n	a9, a9, 0
4037b73d:	0b1d97        	beq	a13, a9, 4037b74c <xTaskCheckForTimeOut+0x8c>
4037b740:	083ba7        	bltu	a11, a10, 4037b74c <xTaskCheckForTimeOut+0x8c>
            *pxTicksToWait = ( TickType_t ) 0;
4037b743:	080c      	movi.n	a8, 0
4037b745:	0389      	s32i.n	a8, a3, 0
            xReturn = pdTRUE;
4037b747:	120c      	movi.n	a2, 1
            *pxTicksToWait = ( TickType_t ) 0;
4037b749:	000886        	j	4037b76f <xTaskCheckForTimeOut+0xaf>
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
4037b74c:	14bc87        	bgeu	a12, a8, 4037b764 <xTaskCheckForTimeOut+0xa4>
            *pxTicksToWait -= xElapsedTime;
4037b74f:	c0aab0        	sub	a10, a10, a11
4037b752:	80aa80        	add	a10, a10, a8
4037b755:	0063a2        	s32i	a10, a3, 0
            vTaskInternalSetTimeOutState( pxTimeOut );
4037b758:	20a220        	or	a10, a2, a2
4037b75b:	fff4a5        	call8	4037b6a4 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
4037b75e:	020c      	movi.n	a2, 0
4037b760:	0002c6        	j	4037b76f <xTaskCheckForTimeOut+0xaf>
4037b763:	080c00        	lsx	f0, a12, a0
            *pxTicksToWait = ( TickType_t ) 0;
4037b766:	0389      	s32i.n	a8, a3, 0
            xReturn = pdTRUE;
4037b768:	120c      	movi.n	a2, 1
4037b76a:	000046        	j	4037b76f <xTaskCheckForTimeOut+0xaf>
                xReturn = pdFALSE;
4037b76d:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL( &xKernelLock );
4037b76f:	e548a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b772:	fe9f25        	call8	4037a164 <vPortExitCritical>
}
4037b775:	f01d      	retw.n
	...

4037b778 <xTaskGetCurrentTaskHandle>:
    {
4037b778:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037b77b:	0063a0        	rsil	a10, 3
4037b77e:	03eb80        	rsr.prid	a8
4037b781:	048d80        	extui	a8, a8, 13, 1
            xReturn = pxCurrentTCBs[ portGET_CORE_ID() ];
4037b784:	e51d91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b787:	a08890        	addx4	a8, a8, a9
4037b78a:	0020c0        	memw
4037b78d:	0828      	l32i.n	a2, a8, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037b78f:	e50581        	l32r	a8, 40374ba4 <_iram_text_start+0x7a0> (40001c38 <_xtos_set_intlevel>)
4037b792:	0008e0        	callx8	a8
    }
4037b795:	f01d      	retw.n
	...

4037b798 <uxTaskPriorityGet>:
    {
4037b798:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b79b:	ffafb2        	movi	a11, -1
4037b79e:	e53ca1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b7a1:	fe8725        	call8	4037a014 <xPortEnterCriticalTimeout>
            pxTCB = prvGetTCBFromHandle( xTask );
4037b7a4:	005256        	bnez	a2, 4037b7ad <uxTaskPriorityGet+0x15>
4037b7a7:	fffd25        	call8	4037b778 <xTaskGetCurrentTaskHandle>
4037b7aa:	202aa0        	or	a2, a10, a10
            uxReturn = pxTCB->uxPriority;
4037b7ad:	b228      	l32i.n	a2, a2, 44
        taskEXIT_CRITICAL( &xKernelLock );
4037b7af:	e538a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b7b2:	fe9b25        	call8	4037a164 <vPortExitCritical>
    }
4037b7b5:	f01d      	retw.n
	...

4037b7b8 <vTaskPrioritySet>:
    {
4037b7b8:	004136        	entry	a1, 32
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
4037b7bb:	881c      	movi.n	a8, 24
4037b7bd:	0eb837        	bgeu	a8, a3, 4037b7cf <vTaskPrioritySet+0x17>
4037b7c0:	e55bd1        	l32r	a13, 40374d2c <_iram_text_start+0x928> (3c0234a0 <_flash_rodata_start+0x3380>)
4037b7c3:	e55bc1        	l32r	a12, 40374d30 <_iram_text_start+0x92c> (3c0272dc <__func__$38>)
4037b7c6:	00a7b2        	movi	a11, 0x700
4037b7c9:	e527a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b7cc:	0455a5        	call8	4037fd28 <__assert_func>
4037b7cf:	fb7c      	movi.n	a11, -1
4037b7d1:	e52fa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b7d4:	fe83e5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037b7d7:	03eb70        	rsr.prid	a7
4037b7da:	047d70        	extui	a7, a7, 13, 1
            pxTCB = prvGetTCBFromHandle( xTask );
4037b7dd:	004256        	bnez	a2, 4037b7e5 <vTaskPrioritySet+0x2d>
4037b7e0:	fff965        	call8	4037b778 <xTaskGetCurrentTaskHandle>
4037b7e3:	0a2d      	mov.n	a2, a10
                uxCurrentBasePriority = pxTCB->uxBasePriority;
4037b7e5:	132282        	l32i	a8, a2, 76
            if( uxCurrentBasePriority != uxNewPriority )
4037b7e8:	029387        	bne	a3, a8, 4037b7ee <vTaskPrioritySet+0x36>
4037b7eb:	0045c6        	j	4037b906 <vTaskPrioritySet+0x14e>
                if( uxNewPriority > uxCurrentBasePriority )
4037b7ee:	2ab837        	bgeu	a8, a3, 4037b81c <vTaskPrioritySet+0x64>
                    if( taskIS_CURRENTLY_RUNNING( pxTCB ) == pdFALSE )
4037b7f1:	e50181        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b7f4:	0020c0        	memw
4037b7f7:	0888      	l32i.n	a8, a8, 0
4037b7f9:	4c1827        	beq	a8, a2, 4037b849 <vTaskPrioritySet+0x91>
4037b7fc:	e4ff81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b7ff:	0020c0        	memw
4037b802:	1888      	l32i.n	a8, a8, 4
4037b804:	461827        	beq	a8, a2, 4037b84e <vTaskPrioritySet+0x96>
                        if( taskIS_YIELD_REQUIRED_USING_PRIORITY( pxTCB, uxNewPriority, pdTRUE ) == pdTRUE )
4037b807:	1c0c      	movi.n	a12, 1
4037b809:	03bd      	mov.n	a11, a3
4037b80b:	02ad      	mov.n	a10, a2
4037b80d:	ff1425        	call8	4037a950 <prvIsYieldRequiredSMP>
4037b810:	0a7d      	mov.n	a7, a10
4037b812:	471a26        	beqi	a10, 1, 4037b85d <vTaskPrioritySet+0xa5>
        BaseType_t xYieldRequired = pdFALSE;
4037b815:	070c      	movi.n	a7, 0
4037b817:	001086        	j	4037b85d <vTaskPrioritySet+0xa5>
4037b81a:	810000        	src	a0, a0, a0
                else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, xCurCoreID ) == pdTRUE )
4037b81d:	80e4f7        	bbsi	a4, 15, 4037b7a1 <uxTaskPriorityGet+0x9>
4037b820:	c0a087        	bge	a0, a8, 4037b7e4 <vTaskPrioritySet+0x2c>
4037b823:	820020        	mull	a0, a0, a2
4037b826:	0028      	l32i.n	a2, a0, 0
4037b828:	281827        	beq	a8, a2, 4037b854 <vTaskPrioritySet+0x9c>
                    else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, !xCurCoreID ) == pdTRUE )
4037b82b:	40f7a0        	nsau	a10, a7
4037b82e:	41a5a0        	srli	a10, a10, 5
4037b831:	e4f181        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b834:	a08a80        	addx4	a8, a10, a8
4037b837:	0020c0        	memw
4037b83a:	002882        	l32i	a8, a8, 0
4037b83d:	199827        	bne	a8, a2, 4037b85a <vTaskPrioritySet+0xa2>
                        taskYIELD_CORE( !xCurCoreID );
4037b840:	fe9be5        	call8	4037a200 <vPortYieldOtherCore>
        BaseType_t xYieldRequired = pdFALSE;
4037b843:	00a072        	movi	a7, 0
4037b846:	0004c6        	j	4037b85d <vTaskPrioritySet+0xa5>
4037b849:	070c      	movi.n	a7, 0
4037b84b:	000386        	j	4037b85d <vTaskPrioritySet+0xa5>
4037b84e:	070c      	movi.n	a7, 0
4037b850:	000246        	j	4037b85d <vTaskPrioritySet+0xa5>
4037b853:	170c00        	ee.stf.64.xp	f0, f1, a0, a12
                    xYieldRequired = pdTRUE;
4037b856:	0000c6        	j	4037b85d <vTaskPrioritySet+0xa5>
4037b859:	a07200        	addx4	a7, a2, a0
        BaseType_t xYieldRequired = pdFALSE;
4037b85c:	228200        	orb	b8, b2, b0
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
4037b85f:	920b      	addi.n	a9, a2, -1
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
4037b861:	871322        	l16ui	a2, a3, 0x10e
4037b864:	0299      	s32i.n	a9, a2, 0
                        pxTCB->uxPriority = uxNewPriority;
4037b866:	0b6232        	s32i	a3, a2, 44
                    pxTCB->uxBasePriority = uxNewPriority;
4037b869:	136232        	s32i	a3, a2, 76
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037b86c:	0020c0        	memw
4037b86f:	062292        	l32i	a9, a2, 24
4037b872:	00b996        	bltz	a9, 4037b881 <vTaskPrioritySet+0xc9>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b875:	e7c332        	addi	a3, a3, -25
4037b878:	603030        	neg	a3, a3
4037b87b:	0020c0        	memw
4037b87e:	066232        	s32i	a3, a2, 24
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037b881:	0020c0        	memw
4037b884:	5298      	l32i.n	a9, a2, 20
4037b886:	a08880        	addx4	a8, a8, a8
4037b889:	e4f9a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037b88c:	a088a0        	addx4	a8, a8, a10
4037b88f:	679987        	bne	a9, a8, 4037b8fa <vTaskPrioritySet+0x142>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037b892:	324b      	addi.n	a3, a2, 4
4037b894:	03ad      	mov.n	a10, a3
4037b896:	fefe25        	call8	4037a878 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037b899:	b288      	l32i.n	a8, a2, 44
4037b89b:	e4f491        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b89e:	0020c0        	memw
4037b8a1:	0998      	l32i.n	a9, a9, 0
4037b8a3:	07b987        	bgeu	a9, a8, 4037b8ae <vTaskPrioritySet+0xf6>
4037b8a6:	e4f191        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037b8a9:	0020c0        	memw
4037b8ac:	0989      	s32i.n	a8, a9, 0
4037b8ae:	e4f0a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037b8b1:	a08880        	addx4	a8, a8, a8
4037b8b4:	a088a0        	addx4	a8, a8, a10
4037b8b7:	0020c0        	memw
4037b8ba:	1888      	l32i.n	a8, a8, 4
4037b8bc:	0020c0        	memw
4037b8bf:	2289      	s32i.n	a8, a2, 8
4037b8c1:	0020c0        	memw
4037b8c4:	2898      	l32i.n	a9, a8, 8
4037b8c6:	0020c0        	memw
4037b8c9:	3299      	s32i.n	a9, a2, 12
4037b8cb:	0020c0        	memw
4037b8ce:	2898      	l32i.n	a9, a8, 8
4037b8d0:	0020c0        	memw
4037b8d3:	1939      	s32i.n	a3, a9, 4
4037b8d5:	0020c0        	memw
4037b8d8:	2839      	s32i.n	a3, a8, 8
4037b8da:	b288      	l32i.n	a8, a2, 44
4037b8dc:	a09880        	addx4	a9, a8, a8
4037b8df:	a099a0        	addx4	a9, a9, a10
4037b8e2:	0020c0        	memw
4037b8e5:	5299      	s32i.n	a9, a2, 20
4037b8e7:	0020c0        	memw
4037b8ea:	0998      	l32i.n	a9, a9, 0
4037b8ec:	991b      	addi.n	a9, a9, 1
4037b8ee:	a08880        	addx4	a8, a8, a8
4037b8f1:	a088a0        	addx4	a8, a8, a10
4037b8f4:	0020c0        	memw
4037b8f7:	006892        	s32i	a9, a8, 0
                if( xYieldRequired != pdFALSE )
4037b8fa:	008716        	beqz	a7, 4037b906 <vTaskPrioritySet+0x14e>
4037b8fd:	03eba0        	rsr.prid	a10
4037b900:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037b903:	fc3525        	call8	40377c54 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &xKernelLock );
4037b906:	e4e2a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b909:	fe85a5        	call8	4037a164 <vPortExitCritical>
    }
4037b90c:	000090        	retw
	...

4037b910 <pcTaskGetName>:
{
4037b910:	004136        	entry	a1, 32
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
4037b913:	016256        	bnez	a2, 4037b92d <pcTaskGetName+0x1d>
4037b916:	ffe625        	call8	4037b778 <xTaskGetCurrentTaskHandle>
4037b919:	0a2d      	mov.n	a2, a10
    configASSERT( pxTCB );
4037b91b:	00ea56        	bnez	a10, 4037b92d <pcTaskGetName+0x1d>
4037b91e:	e505d1        	l32r	a13, 40374d34 <_iram_text_start+0x930> (3c023394 <_flash_rodata_start+0x3274>)
4037b921:	e505c1        	l32r	a12, 40374d38 <_iram_text_start+0x934> (3c027290 <__func__$30>)
4037b924:	e506b1        	l32r	a11, 40374d3c <_iram_text_start+0x938> (adc <UserFrameTotalSize+0x9dc>)
4037b927:	e4d0a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037b92a:	043fe5        	call8	4037fd28 <__assert_func>
}
4037b92d:	34c222        	addi	a2, a2, 52
4037b930:	f01d      	retw.n
	...

4037b934 <xTaskGetSchedulerState>:
    {
4037b934:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037b937:	0063a0        	rsil	a10, 3
            if( xSchedulerRunning == pdFALSE )
4037b93a:	e4e481        	l32r	a8, 40374ccc <_iram_text_start+0x8c8> (3fc94fc8 <xSchedulerRunning>)
4037b93d:	0020c0        	memw
4037b940:	0888      	l32i.n	a8, a8, 0
4037b942:	689c      	beqz.n	a8, 4037b95c <xTaskGetSchedulerState+0x28>
4037b944:	03eb80        	rsr.prid	a8
4037b947:	048d80        	extui	a8, a8, 13, 1
                if( uxSchedulerSuspended[ portGET_CORE_ID() ] == ( UBaseType_t ) pdFALSE )
4037b94a:	e4c291        	l32r	a9, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037b94d:	a08890        	addx4	a8, a8, a9
4037b950:	0020c0        	memw
4037b953:	0888      	l32i.n	a8, a8, 0
4037b955:	88cc      	bnez.n	a8, 4037b961 <xTaskGetSchedulerState+0x2d>
                    xReturn = taskSCHEDULER_RUNNING;
4037b957:	220c      	movi.n	a2, 2
4037b959:	000186        	j	4037b963 <xTaskGetSchedulerState+0x2f>
                xReturn = taskSCHEDULER_NOT_STARTED;
4037b95c:	120c      	movi.n	a2, 1
4037b95e:	000046        	j	4037b963 <xTaskGetSchedulerState+0x2f>
                    xReturn = taskSCHEDULER_SUSPENDED;
4037b961:	020c      	movi.n	a2, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037b963:	e49081        	l32r	a8, 40374ba4 <_iram_text_start+0x7a0> (40001c38 <_xtos_set_intlevel>)
4037b966:	0008e0        	callx8	a8
    }
4037b969:	f01d      	retw.n
	...

4037b96c <vTaskDelete>:
    {
4037b96c:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b96f:	ffafb2        	movi	a11, -1
4037b972:	e4c7a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037b975:	fe69e5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037b978:	03eb70        	rsr.prid	a7
4037b97b:	047d70        	extui	a7, a7, 13, 1
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
4037b97e:	004256        	bnez	a2, 4037b986 <vTaskDelete+0x1a>
4037b981:	ffdf65        	call8	4037b778 <xTaskGetCurrentTaskHandle>
4037b984:	0a2d      	mov.n	a2, a10
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037b986:	04c262        	addi	a6, a2, 4
4037b989:	20a660        	or	a10, a6, a6
4037b98c:	feeea5        	call8	4037a878 <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037b98f:	0020c0        	memw
4037b992:	a288      	l32i.n	a8, a2, 40
4037b994:	488c      	beqz.n	a8, 4037b99c <vTaskDelete+0x30>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
4037b996:	18c2a2        	addi	a10, a2, 24
4037b999:	feede5        	call8	4037a878 <uxListRemove>
            uxTaskNumber++;
4037b99c:	e4cd91        	l32r	a9, 40374cd0 <_iram_text_start+0x8cc> (3fc94fb4 <uxTaskNumber>)
4037b99f:	002982        	l32i	a8, a9, 0
4037b9a2:	01c882        	addi	a8, a8, 1
4037b9a5:	006982        	s32i	a8, a9, 0
            if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, xCurCoreID ) == pdTRUE )
4037b9a8:	e49481        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b9ab:	a08780        	addx4	a8, a7, a8
4037b9ae:	0020c0        	memw
4037b9b1:	0888      	l32i.n	a8, a8, 0
4037b9b3:	2d1827        	beq	a8, a2, 4037b9e4 <vTaskDelete+0x78>
                else if( taskIS_CURRENTLY_RUNNING_ON_CORE( pxTCB, !xCurCoreID ) == pdTRUE )
4037b9b6:	40f780        	nsau	a8, a7
4037b9b9:	418580        	srli	a8, a8, 5
4037b9bc:	e48f91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037b9bf:	a08890        	addx4	a8, a8, a9
4037b9c2:	0020c0        	memw
4037b9c5:	0888      	l32i.n	a8, a8, 0
4037b9c7:	1f1827        	beq	a8, a2, 4037b9ea <vTaskDelete+0x7e>
                --uxCurrentNumberOfTasks;
4037b9ca:	e4b391        	l32r	a9, 40374c98 <_iram_text_start+0x894> (3fc94fd4 <uxCurrentNumberOfTasks>)
4037b9cd:	0020c0        	memw
4037b9d0:	0988      	l32i.n	a8, a9, 0
4037b9d2:	880b      	addi.n	a8, a8, -1
4037b9d4:	0020c0        	memw
4037b9d7:	0989      	s32i.n	a8, a9, 0
                prvResetNextTaskUnblockTime();
4037b9d9:	fef3a5        	call8	4037a914 <prvResetNextTaskUnblockTime>
                xIsCurRunning = pdFALSE;
4037b9dc:	070c      	movi.n	a7, 0
                xSelfDelete = pdFALSE;
4037b9de:	075d      	mov.n	a5, a7
4037b9e0:	000d06        	j	4037ba18 <vTaskDelete+0xac>
4037b9e3:	150c00        	extui	a0, a0, 28, 2
                xSelfDelete = pdTRUE;
4037b9e6:	0000c6        	j	4037b9ed <vTaskDelete+0x81>
4037b9e9:	a05200        	addx4	a5, a2, a0
                    xSelfDelete = pdFALSE;
4037b9ec:	b66000        	ee.ldf.64.xp	f6, f11, a0, a0
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
4037b9ef:	20          	.byte	0x20
4037b9f0:	e4a9a1        	l32r	a10, 40374c94 <_iram_text_start+0x890> (3fc94ff0 <xTasksWaitingTermination>)
4037b9f3:	fedee5        	call8	4037a7e0 <vListInsertEnd>
                ++uxDeletedTasksWaitingCleanUp;
4037b9f6:	e4a991        	l32r	a9, 40374c9c <_iram_text_start+0x898> (3fc94fec <uxDeletedTasksWaitingCleanUp>)
4037b9f9:	0020c0        	memw
4037b9fc:	002982        	l32i	a8, a9, 0
4037b9ff:	881b      	addi.n	a8, a8, 1
4037ba01:	0020c0        	memw
4037ba04:	0989      	s32i.n	a8, a9, 0
                    if( xSelfDelete == pdFALSE )
4037ba06:	c5cc      	bnez.n	a5, 4037ba16 <vTaskDelete+0xaa>
                        taskYIELD_CORE( !xCurCoreID );
4037ba08:	40f7a0        	nsau	a10, a7
4037ba0b:	41a5a0        	srli	a10, a10, 5
4037ba0e:	fe7f25        	call8	4037a200 <vPortYieldOtherCore>
4037ba11:	170c      	movi.n	a7, 1
4037ba13:	000046        	j	4037ba18 <vTaskDelete+0xac>
4037ba16:	057d      	mov.n	a7, a5
        taskEXIT_CRITICAL( &xKernelLock );
4037ba18:	e49ea1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ba1b:	fe74a5        	call8	4037a164 <vPortExitCritical>
        if( xIsCurRunning == pdFALSE )
4037ba1e:	37cc      	bnez.n	a7, 4037ba25 <vTaskDelete+0xb9>
            prvDeleteTCB( pxTCB );
4037ba20:	02ad      	mov.n	a10, a2
4037ba22:	ff1b25        	call8	4037abd4 <prvDeleteTCB>
4037ba25:	fb7c      	movi.n	a11, -1
4037ba27:	e49aa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ba2a:	fe5ea5        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( xSchedulerRunning != pdFALSE )
4037ba2d:	e4a781        	l32r	a8, 40374ccc <_iram_text_start+0x8c8> (3fc94fc8 <xSchedulerRunning>)
4037ba30:	0020c0        	memw
4037ba33:	002882        	l32i	a8, a8, 0
4037ba36:	e89c      	beqz.n	a8, 4037ba58 <vTaskDelete+0xec>
                if( xSelfDelete == pdTRUE )
4037ba38:	1c1566        	bnei	a5, 1, 4037ba58 <vTaskDelete+0xec>
                    configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdFALSE );
4037ba3b:	ffefa5        	call8	4037b934 <xTaskGetSchedulerState>
4037ba3e:	dacc      	bnez.n	a10, 4037ba4f <vTaskDelete+0xe3>
4037ba40:	e4c0d1        	l32r	a13, 40374d40 <_iram_text_start+0x93c> (3c0234b8 <_flash_rodata_start+0x3398>)
4037ba43:	e4c0c1        	l32r	a12, 40374d44 <_iram_text_start+0x940> (3c02730c <__func__$43>)
4037ba46:	c2a5b2        	movi	a11, 0x5c2
4037ba49:	e487a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037ba4c:	042da5        	call8	4037fd28 <__assert_func>
4037ba4f:	03eba0        	rsr.prid	a10
4037ba52:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037ba55:	fc1fe5        	call8	40377c54 <esp_crosscore_int_send_yield>
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037ba58:	e48ea1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ba5b:	fe70a5        	call8	4037a164 <vPortExitCritical>
    }
4037ba5e:	f01d      	retw.n

4037ba60 <vTaskDelay>:
    {
4037ba60:	004136        	entry	a1, 32
        if( xTicksToDelay > ( TickType_t ) 0U )
4037ba63:	92ac      	beqz.n	a2, 4037ba90 <vTaskDelay+0x30>
            configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdFALSE );
4037ba65:	ffece5        	call8	4037b934 <xTaskGetSchedulerState>
4037ba68:	00ea56        	bnez	a10, 4037ba7a <vTaskDelay+0x1a>
4037ba6b:	e4b5d1        	l32r	a13, 40374d40 <_iram_text_start+0x93c> (3c0234b8 <_flash_rodata_start+0x3398>)
4037ba6e:	e4b6c1        	l32r	a12, 40374d48 <_iram_text_start+0x944> (3c0272f0 <__func__$40>)
4037ba71:	32a6b2        	movi	a11, 0x632
4037ba74:	e47da1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037ba77:	042b25        	call8	4037fd28 <__assert_func>
4037ba7a:	fb7c      	movi.n	a11, -1
4037ba7c:	e485a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ba7f:	fe5965        	call8	4037a014 <xPortEnterCriticalTimeout>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
4037ba82:	0b0c      	movi.n	a11, 0
4037ba84:	20a220        	or	a10, a2, a2
4037ba87:	ff22e5        	call8	4037acb4 <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = prvEXIT_CRITICAL_OR_RESUME_ALL( &xKernelLock );
4037ba8a:	e481a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037ba8d:	fe6d65        	call8	4037a164 <vPortExitCritical>
4037ba90:	03eba0        	rsr.prid	a10
4037ba93:	04ada0        	extui	a10, a10, 13, 1
            portYIELD_WITHIN_API();
4037ba96:	fc1be5        	call8	40377c54 <esp_crosscore_int_send_yield>
    }
4037ba99:	f01d      	retw.n
	...

4037ba9c <xTaskResumeAll>:
{
4037ba9c:	004136        	entry	a1, 32
    configASSERT( taskIS_SCHEDULER_SUSPENDED() == pdTRUE );
4037ba9f:	ffe965        	call8	4037b934 <xTaskGetSchedulerState>
4037baa2:	00ea16        	beqz	a10, 4037bab4 <xTaskResumeAll+0x18>
4037baa5:	e4a9d1        	l32r	a13, 40374d4c <_iram_text_start+0x948> (3c023538 <_flash_rodata_start+0x3418>)
4037baa8:	e4aac1        	l32r	a12, 40374d50 <_iram_text_start+0x94c> (3c0272a0 <__func__$31>)
4037baab:	e4aab1        	l32r	a11, 40374d54 <_iram_text_start+0x950> (a25 <UserFrameTotalSize+0x925>)
4037baae:	e46ea1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037bab1:	042765        	call8	4037fd28 <__assert_func>
4037bab4:	fb7c      	movi.n	a11, -1
4037bab6:	e476a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bab9:	fe55a5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037babc:	03eb60        	rsr.prid	a6
4037babf:	046d60        	extui	a6, a6, 13, 1
4037bac2:	065d      	mov.n	a5, a6
        --uxSchedulerSuspended[ xCurCoreID ];
4037bac4:	e46481        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037bac7:	a08680        	addx4	a8, a6, a8
4037baca:	0020c0        	memw
4037bacd:	0898      	l32i.n	a9, a8, 0
4037bacf:	990b      	addi.n	a9, a9, -1
4037bad1:	0020c0        	memw
4037bad4:	0899      	s32i.n	a9, a8, 0
        if( uxSchedulerSuspended[ xCurCoreID ] == ( UBaseType_t ) pdFALSE )
4037bad6:	0020c0        	memw
4037bad9:	0888      	l32i.n	a8, a8, 0
4037badb:	1a3856        	bnez	a8, 4037bc82 <xTaskResumeAll+0x1e6>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
4037bade:	e46e81        	l32r	a8, 40374c98 <_iram_text_start+0x894> (3fc94fd4 <uxCurrentNumberOfTasks>)
4037bae1:	0020c0        	memw
4037bae4:	0888      	l32i.n	a8, a8, 0
4037bae6:	12c856        	bnez	a8, 4037bc16 <xTaskResumeAll+0x17a>
    BaseType_t xAlreadyYielded = pdFALSE;
4037bae9:	020c      	movi.n	a2, 0
4037baeb:	006546        	j	4037bc84 <xTaskResumeAll+0x1e8>
4037baee:	600000        	neg	a0, a0
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList[ xCurCoreID ] ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037baf1:	91a086        	j	40360177 <rom_rx_gain_force+0x359d4b>
4037baf4:	90e475        	call12	4030c93c <rom_rx_gain_force+0x306510>
4037baf7:	a088      	l32i.n	a8, a0, 40
4037baf9:	0020c0        	memw
4037bafc:	3888      	l32i.n	a8, a8, 12
4037bafe:	3878      	l32i.n	a7, a8, 12
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
4037bb00:	0020c0        	memw
4037bb03:	a788      	l32i.n	a8, a7, 40
4037bb05:	0020c0        	memw
4037bb08:	7798      	l32i.n	a9, a7, 28
4037bb0a:	0020c0        	memw
4037bb0d:	87a8      	l32i.n	a10, a7, 32
4037bb0f:	0020c0        	memw
4037bb12:	29a9      	s32i.n	a10, a9, 8
4037bb14:	0020c0        	memw
4037bb17:	8798      	l32i.n	a9, a7, 32
4037bb19:	0020c0        	memw
4037bb1c:	77a8      	l32i.n	a10, a7, 28
4037bb1e:	0020c0        	memw
4037bb21:	19a9      	s32i.n	a10, a9, 4
4037bb23:	0020c0        	memw
4037bb26:	18a8      	l32i.n	a10, a8, 4
4037bb28:	18c792        	addi	a9, a7, 24
4037bb2b:	099a97        	bne	a10, a9, 4037bb38 <xTaskResumeAll+0x9c>
4037bb2e:	0020c0        	memw
4037bb31:	8798      	l32i.n	a9, a7, 32
4037bb33:	0020c0        	memw
4037bb36:	1899      	s32i.n	a9, a8, 4
4037bb38:	090c      	movi.n	a9, 0
4037bb3a:	0020c0        	memw
4037bb3d:	a799      	s32i.n	a9, a7, 40
4037bb3f:	0020c0        	memw
4037bb42:	0898      	l32i.n	a9, a8, 0
4037bb44:	990b      	addi.n	a9, a9, -1
4037bb46:	0020c0        	memw
4037bb49:	0899      	s32i.n	a9, a8, 0
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037bb4b:	0020c0        	memw
4037bb4e:	5788      	l32i.n	a8, a7, 20
4037bb50:	0020c0        	memw
4037bb53:	2798      	l32i.n	a9, a7, 8
4037bb55:	0020c0        	memw
4037bb58:	37a8      	l32i.n	a10, a7, 12
4037bb5a:	0020c0        	memw
4037bb5d:	29a9      	s32i.n	a10, a9, 8
4037bb5f:	0020c0        	memw
4037bb62:	3798      	l32i.n	a9, a7, 12
4037bb64:	0020c0        	memw
4037bb67:	27a8      	l32i.n	a10, a7, 8
4037bb69:	0020c0        	memw
4037bb6c:	19a9      	s32i.n	a10, a9, 4
4037bb6e:	0020c0        	memw
4037bb71:	18a8      	l32i.n	a10, a8, 4
4037bb73:	974b      	addi.n	a9, a7, 4
4037bb75:	099a97        	bne	a10, a9, 4037bb82 <xTaskResumeAll+0xe6>
4037bb78:	0020c0        	memw
4037bb7b:	37a8      	l32i.n	a10, a7, 12
4037bb7d:	0020c0        	memw
4037bb80:	18a9      	s32i.n	a10, a8, 4
4037bb82:	0a0c      	movi.n	a10, 0
4037bb84:	0020c0        	memw
4037bb87:	57a9      	s32i.n	a10, a7, 20
4037bb89:	0020c0        	memw
4037bb8c:	08a8      	l32i.n	a10, a8, 0
4037bb8e:	aa0b      	addi.n	a10, a10, -1
4037bb90:	0020c0        	memw
4037bb93:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxTCB );
4037bb95:	b788      	l32i.n	a8, a7, 44
4037bb97:	e435a1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037bb9a:	0020c0        	memw
4037bb9d:	0aa8      	l32i.n	a10, a10, 0
4037bb9f:	08ba87        	bgeu	a10, a8, 4037bbab <xTaskResumeAll+0x10f>
4037bba2:	e432a1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037bba5:	0020c0        	memw
4037bba8:	006a82        	s32i	a8, a10, 0
4037bbab:	e431a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037bbae:	a08880        	addx4	a8, a8, a8
4037bbb1:	a088a0        	addx4	a8, a8, a10
4037bbb4:	0020c0        	memw
4037bbb7:	1888      	l32i.n	a8, a8, 4
4037bbb9:	0020c0        	memw
4037bbbc:	2789      	s32i.n	a8, a7, 8
4037bbbe:	0020c0        	memw
4037bbc1:	28b8      	l32i.n	a11, a8, 8
4037bbc3:	0020c0        	memw
4037bbc6:	37b9      	s32i.n	a11, a7, 12
4037bbc8:	0020c0        	memw
4037bbcb:	28b8      	l32i.n	a11, a8, 8
4037bbcd:	0020c0        	memw
4037bbd0:	1b99      	s32i.n	a9, a11, 4
4037bbd2:	0020c0        	memw
4037bbd5:	2899      	s32i.n	a9, a8, 8
4037bbd7:	b788      	l32i.n	a8, a7, 44
4037bbd9:	a09880        	addx4	a9, a8, a8
4037bbdc:	a099a0        	addx4	a9, a9, a10
4037bbdf:	0020c0        	memw
4037bbe2:	5799      	s32i.n	a9, a7, 20
4037bbe4:	0020c0        	memw
4037bbe7:	0998      	l32i.n	a9, a9, 0
4037bbe9:	991b      	addi.n	a9, a9, 1
4037bbeb:	a08880        	addx4	a8, a8, a8
4037bbee:	a088a0        	addx4	a8, a8, a10
4037bbf1:	0020c0        	memw
4037bbf4:	0899      	s32i.n	a9, a8, 0
                    if( taskIS_YIELD_REQUIRED( pxTCB, pdTRUE ) == pdTRUE )
4037bbf6:	1c0c      	movi.n	a12, 1
4037bbf8:	b7b8      	l32i.n	a11, a7, 44
4037bbfa:	20a770        	or	a10, a7, a7
4037bbfd:	fed525        	call8	4037a950 <prvIsYieldRequiredSMP>
4037bc00:	151a66        	bnei	a10, 1, 4037bc19 <xTaskResumeAll+0x17d>
                        xYieldPending[ xCurCoreID ] = pdTRUE;
4037bc03:	e43a81        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037bc06:	a08680        	addx4	a8, a6, a8
4037bc09:	190c      	movi.n	a9, 1
4037bc0b:	0020c0        	memw
4037bc0e:	0899      	s32i.n	a9, a8, 0
4037bc10:	000146        	j	4037bc19 <xTaskResumeAll+0x17d>
4037bc13:	000000        	ill
    TCB_t * pxTCB = NULL;
4037bc16:	00a072        	movi	a7, 0
                while( listLIST_IS_EMPTY( &xPendingReadyList[ xCurCoreID ] ) == pdFALSE )
4037bc19:	a08660        	addx4	a8, a6, a6
4037bc1c:	e42b91        	l32r	a9, 40374cc8 <_iram_text_start+0x8c4> (3fc95004 <xPendingReadyList>)
4037bc1f:	a08890        	addx4	a8, a8, a9
4037bc22:	0020c0        	memw
4037bc25:	002882        	l32i	a8, a8, 0
4037bc28:	ec4856        	bnez	a8, 4037baf0 <xTaskResumeAll+0x54>
                if( pxTCB != NULL )
4037bc2b:	002716        	beqz	a7, 4037bc31 <xTaskResumeAll+0x195>
                    prvResetNextTaskUnblockTime();
4037bc2e:	fece65        	call8	4037a914 <prvResetNextTaskUnblockTime>
                    if( xCurCoreID == 0 )
4037bc31:	f5ec      	bnez.n	a5, 4037bc64 <xTaskResumeAll+0x1c8>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
4037bc33:	e42f81        	l32r	a8, 40374cf0 <_iram_text_start+0x8ec> (3fc94fc4 <xPendedTicks>)
4037bc36:	0020c0        	memw
4037bc39:	0878      	l32i.n	a7, a8, 0
                    if( xPendedCounts > ( TickType_t ) 0U )
4037bc3b:	57ac      	beqz.n	a7, 4037bc64 <xTaskResumeAll+0x1c8>
                            if( xTaskIncrementTick() != pdFALSE )
4037bc3d:	ff4b25        	call8	4037b0f0 <xTaskIncrementTick>
4037bc40:	00ea16        	beqz	a10, 4037bc52 <xTaskResumeAll+0x1b6>
                                xYieldPending[ xCurCoreID ] = pdTRUE;
4037bc43:	e42a81        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037bc46:	a08680        	addx4	a8, a6, a8
4037bc49:	01a092        	movi	a9, 1
4037bc4c:	0020c0        	memw
4037bc4f:	006892        	s32i	a9, a8, 0
                            --xPendedCounts;
4037bc52:	ffc772        	addi	a7, a7, -1
                        } while( xPendedCounts > ( TickType_t ) 0U );
4037bc55:	fe4756        	bnez	a7, 4037bc3d <xTaskResumeAll+0x1a1>
                        xPendedTicks = 0;
4037bc58:	e42681        	l32r	a8, 40374cf0 <_iram_text_start+0x8ec> (3fc94fc4 <xPendedTicks>)
4037bc5b:	00a092        	movi	a9, 0
4037bc5e:	0020c0        	memw
4037bc61:	006892        	s32i	a9, a8, 0
                if( xYieldPending[ xCurCoreID ] != pdFALSE )
4037bc64:	e42281        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037bc67:	a06680        	addx4	a6, a6, a8
4037bc6a:	0020c0        	memw
4037bc6d:	0628      	l32i.n	a2, a6, 0
4037bc6f:	129c      	beqz.n	a2, 4037bc84 <xTaskResumeAll+0x1e8>
4037bc71:	03eba0        	rsr.prid	a10
4037bc74:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037bc77:	fbfde5        	call8	40377c54 <esp_crosscore_int_send_yield>
                        xAlreadyYielded = pdTRUE;
4037bc7a:	120c      	movi.n	a2, 1
4037bc7c:	000106        	j	4037bc84 <xTaskResumeAll+0x1e8>
4037bc7f:	000000        	ill
    BaseType_t xAlreadyYielded = pdFALSE;
4037bc82:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL( &xKernelLock );
4037bc84:	e403a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bc87:	fe4de5        	call8	4037a164 <vPortExitCritical>
}
4037bc8a:	f01d      	retw.n

4037bc8c <xTaskPriorityInherit>:
    {
4037bc8c:	004136        	entry	a1, 32
4037bc8f:	fb7c      	movi.n	a11, -1
4037bc91:	e3ffa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bc94:	fe37e5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037bc97:	03eb70        	rsr.prid	a7
4037bc9a:	047d70        	extui	a7, a7, 13, 1
            if( pxMutexHolder != NULL )
4037bc9d:	0eb216        	beqz	a2, 4037bd8c <xTaskPriorityInherit+0x100>
                if( pxMutexHolderTCB->uxPriority < pxCurrentTCBs[ xCurCoreID ]->uxPriority )
4037bca0:	b288      	l32i.n	a8, a2, 44
4037bca2:	e3d591        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bca5:	a09790        	addx4	a9, a7, a9
4037bca8:	0020c0        	memw
4037bcab:	0998      	l32i.n	a9, a9, 0
4037bcad:	b998      	l32i.n	a9, a9, 44
4037bcaf:	023897        	bltu	a8, a9, 4037bcb5 <xTaskPriorityInherit+0x29>
4037bcb2:	002f86        	j	4037bd74 <xTaskPriorityInherit+0xe8>
                    if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bcb5:	0020c0        	memw
4037bcb8:	6298      	l32i.n	a9, a2, 24
4037bcba:	017996        	bltz	a9, 4037bcd5 <xTaskPriorityInherit+0x49>
                        listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCBs[ xCurCoreID ]->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bcbd:	e3ce91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bcc0:	a09790        	addx4	a9, a7, a9
4037bcc3:	0020c0        	memw
4037bcc6:	0998      	l32i.n	a9, a9, 0
4037bcc8:	b998      	l32i.n	a9, a9, 44
4037bcca:	e7c992        	addi	a9, a9, -25
4037bccd:	609090        	neg	a9, a9
4037bcd0:	0020c0        	memw
4037bcd3:	6299      	s32i.n	a9, a2, 24
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
4037bcd5:	0020c0        	memw
4037bcd8:	5298      	l32i.n	a9, a2, 20
4037bcda:	a08880        	addx4	a8, a8, a8
4037bcdd:	e3e4a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037bce0:	a088a0        	addx4	a8, a8, a10
4037bce3:	799987        	bne	a9, a8, 4037bd60 <xTaskPriorityInherit+0xd4>
                        if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bce6:	624b      	addi.n	a6, a2, 4
4037bce8:	06ad      	mov.n	a10, a6
4037bcea:	feb8e5        	call8	4037a878 <uxListRemove>
                        pxMutexHolderTCB->uxPriority = pxCurrentTCBs[ xCurCoreID ]->uxPriority;
4037bced:	e3c281        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bcf0:	a08780        	addx4	a8, a7, a8
4037bcf3:	0020c0        	memw
4037bcf6:	0888      	l32i.n	a8, a8, 0
4037bcf8:	b888      	l32i.n	a8, a8, 44
4037bcfa:	b289      	s32i.n	a8, a2, 44
                        prvAddTaskToReadyList( pxMutexHolderTCB );
4037bcfc:	e3dc91        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037bcff:	0020c0        	memw
4037bd02:	0998      	l32i.n	a9, a9, 0
4037bd04:	08b987        	bgeu	a9, a8, 4037bd10 <xTaskPriorityInherit+0x84>
4037bd07:	e3d991        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037bd0a:	0020c0        	memw
4037bd0d:	006982        	s32i	a8, a9, 0
4037bd10:	e3d8a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037bd13:	a08880        	addx4	a8, a8, a8
4037bd16:	a088a0        	addx4	a8, a8, a10
4037bd19:	0020c0        	memw
4037bd1c:	1888      	l32i.n	a8, a8, 4
4037bd1e:	0020c0        	memw
4037bd21:	2289      	s32i.n	a8, a2, 8
4037bd23:	0020c0        	memw
4037bd26:	2898      	l32i.n	a9, a8, 8
4037bd28:	0020c0        	memw
4037bd2b:	3299      	s32i.n	a9, a2, 12
4037bd2d:	0020c0        	memw
4037bd30:	2898      	l32i.n	a9, a8, 8
4037bd32:	0020c0        	memw
4037bd35:	1969      	s32i.n	a6, a9, 4
4037bd37:	0020c0        	memw
4037bd3a:	2869      	s32i.n	a6, a8, 8
4037bd3c:	b288      	l32i.n	a8, a2, 44
4037bd3e:	a09880        	addx4	a9, a8, a8
4037bd41:	a099a0        	addx4	a9, a9, a10
4037bd44:	0020c0        	memw
4037bd47:	5299      	s32i.n	a9, a2, 20
4037bd49:	0020c0        	memw
4037bd4c:	0998      	l32i.n	a9, a9, 0
4037bd4e:	991b      	addi.n	a9, a9, 1
4037bd50:	a08880        	addx4	a8, a8, a8
4037bd53:	a088a0        	addx4	a8, a8, a10
4037bd56:	0020c0        	memw
4037bd59:	0899      	s32i.n	a9, a8, 0
                    xReturn = pdTRUE;
4037bd5b:	120c      	movi.n	a2, 1
4037bd5d:	000c86        	j	4037bd93 <xTaskPriorityInherit+0x107>
                        pxMutexHolderTCB->uxPriority = pxCurrentTCBs[ xCurCoreID ]->uxPriority;
4037bd60:	e3a681        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bd63:	a08780        	addx4	a8, a7, a8
4037bd66:	0020c0        	memw
4037bd69:	0888      	l32i.n	a8, a8, 0
4037bd6b:	b888      	l32i.n	a8, a8, 44
4037bd6d:	b289      	s32i.n	a8, a2, 44
                    xReturn = pdTRUE;
4037bd6f:	120c      	movi.n	a2, 1
4037bd71:	000786        	j	4037bd93 <xTaskPriorityInherit+0x107>
                    if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCBs[ xCurCoreID ]->uxPriority )
4037bd74:	132292        	l32i	a9, a2, 76
4037bd77:	e3a081        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bd7a:	a07780        	addx4	a7, a7, a8
4037bd7d:	0020c0        	memw
4037bd80:	0788      	l32i.n	a8, a7, 0
4037bd82:	b888      	l32i.n	a8, a8, 44
4037bd84:	093987        	bltu	a9, a8, 4037bd91 <xTaskPriorityInherit+0x105>
        BaseType_t xReturn = pdFALSE;
4037bd87:	020c      	movi.n	a2, 0
4037bd89:	000186        	j	4037bd93 <xTaskPriorityInherit+0x107>
4037bd8c:	020c      	movi.n	a2, 0
4037bd8e:	000046        	j	4037bd93 <xTaskPriorityInherit+0x107>
                        xReturn = pdTRUE;
4037bd91:	120c      	movi.n	a2, 1
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bd93:	e3bfa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bd96:	fe3ce5        	call8	4037a164 <vPortExitCritical>
    }
4037bd99:	f01d      	retw.n
	...

4037bd9c <xTaskPriorityDisinherit>:
    {
4037bd9c:	004136        	entry	a1, 32
4037bd9f:	fb7c      	movi.n	a11, -1
4037bda1:	e3bba1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bda4:	fe26e5        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( pxMutexHolder != NULL )
4037bda7:	0c5216        	beqz	a2, 4037be70 <xTaskPriorityDisinherit+0xd4>
4037bdaa:	03eb80        	rsr.prid	a8
4037bdad:	048d80        	extui	a8, a8, 13, 1
                configASSERT( pxTCB == pxCurrentTCBs[ portGET_CORE_ID() ] );
4037bdb0:	e39291        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bdb3:	a08890        	addx4	a8, a8, a9
4037bdb6:	0020c0        	memw
4037bdb9:	0888      	l32i.n	a8, a8, 0
4037bdbb:	0e1827        	beq	a8, a2, 4037bdcd <xTaskPriorityDisinherit+0x31>
4037bdbe:	e3e6d1        	l32r	a13, 40374d58 <_iram_text_start+0x954> (3c0235b8 <_flash_rodata_start+0x3498>)
4037bdc1:	e3e6c1        	l32r	a12, 40374d5c <_iram_text_start+0x958> (3c0271f8 <__func__$15>)
4037bdc4:	e3e7b1        	l32r	a11, 40374d60 <_iram_text_start+0x95c> (1424 <UserFrameTotalSize+0x1324>)
4037bdc7:	e3a8a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037bdca:	03f5e5        	call8	4037fd28 <__assert_func>
                configASSERT( pxTCB->uxMutexesHeld );
4037bdcd:	142282        	l32i	a8, a2, 80
4037bdd0:	00e856        	bnez	a8, 4037bde2 <xTaskPriorityDisinherit+0x46>
4037bdd3:	e3e4d1        	l32r	a13, 40374d64 <_iram_text_start+0x960> (3c0235e4 <_flash_rodata_start+0x34c4>)
4037bdd6:	e3e1c1        	l32r	a12, 40374d5c <_iram_text_start+0x958> (3c0271f8 <__func__$15>)
4037bdd9:	e3e3b1        	l32r	a11, 40374d68 <_iram_text_start+0x964> (1425 <UserFrameTotalSize+0x1325>)
4037bddc:	e3a3a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037bddf:	03f4a5        	call8	4037fd28 <__assert_func>
                ( pxTCB->uxMutexesHeld )--;
4037bde2:	880b      	addi.n	a8, a8, -1
4037bde4:	146282        	s32i	a8, a2, 80
                if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4037bde7:	b2a8      	l32i.n	a10, a2, 44
4037bde9:	132292        	l32i	a9, a2, 76
4037bdec:	029a97        	bne	a10, a9, 4037bdf2 <xTaskPriorityDisinherit+0x56>
4037bdef:	002086        	j	4037be75 <xTaskPriorityDisinherit+0xd9>
                    if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4037bdf2:	084856        	bnez	a8, 4037be7a <xTaskPriorityDisinherit+0xde>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bdf5:	04c272        	addi	a7, a2, 4
4037bdf8:	07ad      	mov.n	a10, a7
4037bdfa:	fea7e5        	call8	4037a878 <uxListRemove>
                        pxTCB->uxPriority = pxTCB->uxBasePriority;
4037bdfd:	132282        	l32i	a8, a2, 76
4037be00:	b289      	s32i.n	a8, a2, 44
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037be02:	e7c892        	addi	a9, a8, -25
4037be05:	609090        	neg	a9, a9
4037be08:	0020c0        	memw
4037be0b:	6299      	s32i.n	a9, a2, 24
                        prvAddTaskToReadyList( pxTCB );
4037be0d:	e39791        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037be10:	0020c0        	memw
4037be13:	0998      	l32i.n	a9, a9, 0
4037be15:	07b987        	bgeu	a9, a8, 4037be20 <xTaskPriorityDisinherit+0x84>
4037be18:	e39591        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037be1b:	0020c0        	memw
4037be1e:	0989      	s32i.n	a8, a9, 0
4037be20:	e394a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037be23:	a08880        	addx4	a8, a8, a8
4037be26:	a088a0        	addx4	a8, a8, a10
4037be29:	0020c0        	memw
4037be2c:	1888      	l32i.n	a8, a8, 4
4037be2e:	0020c0        	memw
4037be31:	2289      	s32i.n	a8, a2, 8
4037be33:	0020c0        	memw
4037be36:	2898      	l32i.n	a9, a8, 8
4037be38:	0020c0        	memw
4037be3b:	3299      	s32i.n	a9, a2, 12
4037be3d:	0020c0        	memw
4037be40:	2898      	l32i.n	a9, a8, 8
4037be42:	0020c0        	memw
4037be45:	1979      	s32i.n	a7, a9, 4
4037be47:	0020c0        	memw
4037be4a:	2879      	s32i.n	a7, a8, 8
4037be4c:	b288      	l32i.n	a8, a2, 44
4037be4e:	a09880        	addx4	a9, a8, a8
4037be51:	a099a0        	addx4	a9, a9, a10
4037be54:	0020c0        	memw
4037be57:	5299      	s32i.n	a9, a2, 20
4037be59:	0020c0        	memw
4037be5c:	0998      	l32i.n	a9, a9, 0
4037be5e:	991b      	addi.n	a9, a9, 1
4037be60:	a08880        	addx4	a8, a8, a8
4037be63:	a088a0        	addx4	a8, a8, a10
4037be66:	0020c0        	memw
4037be69:	0899      	s32i.n	a9, a8, 0
                        xReturn = pdTRUE;
4037be6b:	120c      	movi.n	a2, 1
4037be6d:	0002c6        	j	4037be7c <xTaskPriorityDisinherit+0xe0>
        BaseType_t xReturn = pdFALSE;
4037be70:	020c      	movi.n	a2, 0
4037be72:	000186        	j	4037be7c <xTaskPriorityDisinherit+0xe0>
4037be75:	020c      	movi.n	a2, 0
4037be77:	000046        	j	4037be7c <xTaskPriorityDisinherit+0xe0>
4037be7a:	020c      	movi.n	a2, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037be7c:	e385a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037be7f:	fe2e65        	call8	4037a164 <vPortExitCritical>
    }
4037be82:	f01d      	retw.n

4037be84 <vTaskPriorityDisinheritAfterTimeout>:
    {
4037be84:	004136        	entry	a1, 32
4037be87:	ffafb2        	movi	a11, -1
4037be8a:	e381a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037be8d:	fe1865        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( pxMutexHolder != NULL )
4037be90:	0e0216        	beqz	a2, 4037bf74 <vTaskPriorityDisinheritAfterTimeout+0xf0>
                configASSERT( pxTCB->uxMutexesHeld );
4037be93:	1422a2        	l32i	a10, a2, 80
4037be96:	00ea56        	bnez	a10, 4037bea8 <vTaskPriorityDisinheritAfterTimeout+0x24>
4037be99:	e3b2d1        	l32r	a13, 40374d64 <_iram_text_start+0x960> (3c0235e4 <_flash_rodata_start+0x34c4>)
4037be9c:	e3b4c1        	l32r	a12, 40374d6c <_iram_text_start+0x968> (3c0271d4 <__func__$14>)
4037be9f:	e3b4b1        	l32r	a11, 40374d70 <_iram_text_start+0x96c> (147b <UserFrameTotalSize+0x137b>)
4037bea2:	e371a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037bea5:	03e825        	call8	4037fd28 <__assert_func>
                if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4037bea8:	132282        	l32i	a8, a2, 76
4037beab:	02b837        	bgeu	a8, a3, 4037beb1 <vTaskPriorityDisinheritAfterTimeout+0x2d>
                    uxPriorityToUse = uxHighestPriorityWaitingTask;
4037beae:	208330        	or	a8, a3, a3
                if( pxTCB->uxPriority != uxPriorityToUse )
4037beb1:	0b2292        	l32i	a9, a2, 44
4037beb4:	029987        	bne	a9, a8, 4037beba <vTaskPriorityDisinheritAfterTimeout+0x36>
4037beb7:	002e46        	j	4037bf74 <vTaskPriorityDisinheritAfterTimeout+0xf0>
                    if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4037beba:	021a26        	beqi	a10, 1, 4037bec0 <vTaskPriorityDisinheritAfterTimeout+0x3c>
4037bebd:	002cc6        	j	4037bf74 <vTaskPriorityDisinheritAfterTimeout+0xf0>
4037bec0:	03eba0        	rsr.prid	a10
4037bec3:	04ada0        	extui	a10, a10, 13, 1
                        configASSERT( pxTCB != pxCurrentTCBs[ portGET_CORE_ID() ] );
4037bec6:	e34cb1        	l32r	a11, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bec9:	a0aab0        	addx4	a10, a10, a11
4037becc:	0020c0        	memw
4037becf:	002aa2        	l32i	a10, a10, 0
4037bed2:	0e9a27        	bne	a10, a2, 4037bee4 <vTaskPriorityDisinheritAfterTimeout+0x60>
4037bed5:	e3a7d1        	l32r	a13, 40374d74 <_iram_text_start+0x970> (3c0235fc <_flash_rodata_start+0x34dc>)
4037bed8:	e3a5c1        	l32r	a12, 40374d6c <_iram_text_start+0x968> (3c0271d4 <__func__$14>)
4037bedb:	e3a7b1        	l32r	a11, 40374d78 <_iram_text_start+0x974> (1496 <UserFrameTotalSize+0x1396>)
4037bede:	e362a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037bee1:	03e465        	call8	4037fd28 <__assert_func>
                        pxTCB->uxPriority = uxPriorityToUse;
4037bee4:	b289      	s32i.n	a8, a2, 44
                        if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bee6:	0020c0        	memw
4037bee9:	62a8      	l32i.n	a10, a2, 24
4037beeb:	00aa96        	bltz	a10, 4037bef9 <vTaskPriorityDisinheritAfterTimeout+0x75>
                            listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037beee:	e7c882        	addi	a8, a8, -25
4037bef1:	608080        	neg	a8, a8
4037bef4:	0020c0        	memw
4037bef7:	6289      	s32i.n	a8, a2, 24
                        if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037bef9:	0020c0        	memw
4037befc:	052282        	l32i	a8, a2, 20
4037beff:	a09990        	addx4	a9, a9, a9
4037bf02:	e35ba1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037bf05:	a099a0        	addx4	a9, a9, a10
4037bf08:	689897        	bne	a8, a9, 4037bf74 <vTaskPriorityDisinheritAfterTimeout+0xf0>
                            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bf0b:	04c232        	addi	a3, a2, 4
4037bf0e:	20a330        	or	a10, a3, a3
4037bf11:	fe9665        	call8	4037a878 <uxListRemove>
                            prvAddTaskToReadyList( pxTCB );
4037bf14:	b288      	l32i.n	a8, a2, 44
4037bf16:	e35591        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037bf19:	0020c0        	memw
4037bf1c:	0998      	l32i.n	a9, a9, 0
4037bf1e:	07b987        	bgeu	a9, a8, 4037bf29 <vTaskPriorityDisinheritAfterTimeout+0xa5>
4037bf21:	e35291        	l32r	a9, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037bf24:	0020c0        	memw
4037bf27:	0989      	s32i.n	a8, a9, 0
4037bf29:	e351a1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037bf2c:	a08880        	addx4	a8, a8, a8
4037bf2f:	a088a0        	addx4	a8, a8, a10
4037bf32:	0020c0        	memw
4037bf35:	1888      	l32i.n	a8, a8, 4
4037bf37:	0020c0        	memw
4037bf3a:	2289      	s32i.n	a8, a2, 8
4037bf3c:	0020c0        	memw
4037bf3f:	2898      	l32i.n	a9, a8, 8
4037bf41:	0020c0        	memw
4037bf44:	3299      	s32i.n	a9, a2, 12
4037bf46:	0020c0        	memw
4037bf49:	2898      	l32i.n	a9, a8, 8
4037bf4b:	0020c0        	memw
4037bf4e:	1939      	s32i.n	a3, a9, 4
4037bf50:	0020c0        	memw
4037bf53:	2839      	s32i.n	a3, a8, 8
4037bf55:	b288      	l32i.n	a8, a2, 44
4037bf57:	a09880        	addx4	a9, a8, a8
4037bf5a:	a099a0        	addx4	a9, a9, a10
4037bf5d:	0020c0        	memw
4037bf60:	5299      	s32i.n	a9, a2, 20
4037bf62:	0020c0        	memw
4037bf65:	0998      	l32i.n	a9, a9, 0
4037bf67:	991b      	addi.n	a9, a9, 1
4037bf69:	a08880        	addx4	a8, a8, a8
4037bf6c:	a088a0        	addx4	a8, a8, a10
4037bf6f:	0020c0        	memw
4037bf72:	0899      	s32i.n	a9, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bf74:	e347a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bf77:	fe1ee5        	call8	4037a164 <vPortExitCritical>
    }
4037bf7a:	f01d      	retw.n

4037bf7c <pvTaskIncrementMutexHeldCount>:
    {
4037bf7c:	004136        	entry	a1, 32
4037bf7f:	ffafb2        	movi	a11, -1
4037bf82:	e343a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bf85:	fe08e5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037bf88:	03eb80        	rsr.prid	a8
4037bf8b:	048d80        	extui	a8, a8, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ] != NULL )
4037bf8e:	e31a91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bf91:	a09890        	addx4	a9, a8, a9
4037bf94:	0020c0        	memw
4037bf97:	002992        	l32i	a9, a9, 0
4037bf9a:	012916        	beqz	a9, 4037bfb0 <pvTaskIncrementMutexHeldCount+0x34>
                ( pxCurrentTCBs[ xCurCoreID ]->uxMutexesHeld )++;
4037bf9d:	e31691        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bfa0:	a09890        	addx4	a9, a8, a9
4037bfa3:	0020c0        	memw
4037bfa6:	09a8      	l32i.n	a10, a9, 0
4037bfa8:	142a92        	l32i	a9, a10, 80
4037bfab:	991b      	addi.n	a9, a9, 1
4037bfad:	146a92        	s32i	a9, a10, 80
            xReturn = pxCurrentTCBs[ xCurCoreID ];
4037bfb0:	e31291        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bfb3:	a08890        	addx4	a8, a8, a9
4037bfb6:	0020c0        	memw
4037bfb9:	0828      	l32i.n	a2, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037bfbb:	e335a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bfbe:	fe1a65        	call8	4037a164 <vPortExitCritical>
    }
4037bfc1:	f01d      	retw.n
	...

4037bfc4 <ulTaskGenericNotifyTake>:
    {
4037bfc4:	004136        	entry	a1, 32
4037bfc7:	027d      	mov.n	a7, a2
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037bfc9:	d28c      	beqz.n	a2, 4037bfda <ulTaskGenericNotifyTake+0x16>
4037bfcb:	e36cd1        	l32r	a13, 40374d7c <_iram_text_start+0x978> (3c023628 <_flash_rodata_start+0x3508>)
4037bfce:	e36cc1        	l32r	a12, 40374d80 <_iram_text_start+0x97c> (3c0271bc <__func__$13>)
4037bfd1:	e36cb1        	l32r	a11, 40374d84 <_iram_text_start+0x980> (1666 <UserFrameTotalSize+0x1566>)
4037bfd4:	e325a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037bfd7:	03d525        	call8	4037fd28 <__assert_func>
4037bfda:	fb7c      	movi.n	a11, -1
4037bfdc:	e32da1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037bfdf:	fe0365        	call8	4037a014 <xPortEnterCriticalTimeout>
4037bfe2:	03eb90        	rsr.prid	a9
4037bfe5:	049d90        	extui	a9, a9, 13, 1
            if( pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] == 0UL )
4037bfe8:	e30481        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037bfeb:	a08980        	addx4	a8, a9, a8
4037bfee:	0020c0        	memw
4037bff1:	08a8      	l32i.n	a10, a8, 0
4037bff3:	50c282        	addi	a8, a2, 80
4037bff6:	a088a0        	addx4	a8, a8, a10
4037bff9:	0020c0        	memw
4037bffc:	3888      	l32i.n	a8, a8, 12
4037bffe:	a8ec      	bnez.n	a8, 4037c02c <ulTaskGenericNotifyTake+0x68>
                pxCurrentTCBs[ xCurCoreID ]->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4037c000:	e2fe81        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037c003:	a09980        	addx4	a9, a9, a8
4037c006:	0020c0        	memw
4037c009:	0988      	l32i.n	a8, a9, 0
4037c00b:	882a      	add.n	a8, a8, a2
4037c00d:	50a192        	movi	a9, 0x150
4037c010:	889a      	add.n	a8, a8, a9
4037c012:	190c      	movi.n	a9, 1
4037c014:	0020c0        	memw
4037c017:	004892        	s8i	a9, a8, 0
                if( xTicksToWait > ( TickType_t ) 0 )
4037c01a:	e48c      	beqz.n	a4, 4037c02c <ulTaskGenericNotifyTake+0x68>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4037c01c:	1b0c      	movi.n	a11, 1
4037c01e:	04ad      	mov.n	a10, a4
4037c020:	fec925        	call8	4037acb4 <prvAddCurrentTaskToDelayedList>
4037c023:	03eba0        	rsr.prid	a10
4037c026:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037c029:	fbc2a5        	call8	40377c54 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL( &xKernelLock );
4037c02c:	e31941        	l32r	a4, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c02f:	04ad      	mov.n	a10, a4
4037c031:	fe1325        	call8	4037a164 <vPortExitCritical>
4037c034:	fb7c      	movi.n	a11, -1
4037c036:	20a440        	or	a10, a4, a4
4037c039:	fdfda5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037c03c:	03eb80        	rsr.prid	a8
4037c03f:	048d80        	extui	a8, a8, 13, 1
            ulReturn = pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ];
4037c042:	e2ed91        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037c045:	a09890        	addx4	a9, a8, a9
4037c048:	0020c0        	memw
4037c04b:	09a8      	l32i.n	a10, a9, 0
4037c04d:	50c792        	addi	a9, a7, 80
4037c050:	a099a0        	addx4	a9, a9, a10
4037c053:	0020c0        	memw
4037c056:	3928      	l32i.n	a2, a9, 12
            if( ulReturn != 0UL )
4037c058:	52bc      	beqz.n	a2, 4037c091 <ulTaskGenericNotifyTake+0xcd>
                if( xClearCountOnExit != pdFALSE )
4037c05a:	b39c      	beqz.n	a3, 4037c079 <ulTaskGenericNotifyTake+0xb5>
                    pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] = 0UL;
4037c05c:	e2e791        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037c05f:	a09890        	addx4	a9, a8, a9
4037c062:	0020c0        	memw
4037c065:	09a8      	l32i.n	a10, a9, 0
4037c067:	50c792        	addi	a9, a7, 80
4037c06a:	a099a0        	addx4	a9, a9, a10
4037c06d:	0a0c      	movi.n	a10, 0
4037c06f:	0020c0        	memw
4037c072:	39a9      	s32i.n	a10, a9, 12
4037c074:	000646        	j	4037c091 <ulTaskGenericNotifyTake+0xcd>
4037c077:	910000        	srl	a0, a0
                    pxCurrentTCBs[ xCurCoreID ]->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4037c07a:	9890e2df 	ee.stf.128.xp	f0, f1, f14, f9, a13, a2
4037c07e:	20c0a0        	or	a12, a0, a10
4037c081:	09b800        	l32e	a0, a8, -20
4037c084:	a20b      	addi.n	a10, a2, -1
4037c086:	50c792        	addi	a9, a7, 80
4037c089:	a099b0        	addx4	a9, a9, a11
4037c08c:	0020c0        	memw
4037c08f:	39a9      	s32i.n	a10, a9, 12
            pxCurrentTCBs[ xCurCoreID ]->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4037c091:	e2d991        	l32r	a9, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037c094:	a08890        	addx4	a8, a8, a9
4037c097:	0020c0        	memw
4037c09a:	002882        	l32i	a8, a8, 0
4037c09d:	808870        	add	a8, a8, a7
4037c0a0:	50a192        	movi	a9, 0x150
4037c0a3:	808890        	add	a8, a8, a9
4037c0a6:	090c      	movi.n	a9, 0
4037c0a8:	0020c0        	memw
4037c0ab:	004892        	s8i	a9, a8, 0
        taskEXIT_CRITICAL( &xKernelLock );
4037c0ae:	e2f8a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c0b1:	fe0b25        	call8	4037a164 <vPortExitCritical>
    }
4037c0b4:	f01d      	retw.n
	...

4037c0b8 <xTaskGenericNotify>:
    {
4037c0b8:	004136        	entry	a1, 32
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c0bb:	00e316        	beqz	a3, 4037c0cd <xTaskGenericNotify+0x15>
4037c0be:	e332d1        	l32r	a13, 40374d88 <_iram_text_start+0x984> (3c02363c <_flash_rodata_start+0x351c>)
4037c0c1:	e332c1        	l32r	a12, 40374d8c <_iram_text_start+0x988> (3c0271a8 <__func__$11>)
4037c0c4:	e333b1        	l32r	a11, 40374d90 <_iram_text_start+0x98c> (1714 <UserFrameTotalSize+0x1614>)
4037c0c7:	e2e8a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c0ca:	03c5e5        	call8	4037fd28 <__assert_func>
        configASSERT( xTaskToNotify );
4037c0cd:	00e256        	bnez	a2, 4037c0df <xTaskGenericNotify+0x27>
4037c0d0:	e331d1        	l32r	a13, 40374d94 <_iram_text_start+0x990> (3c023650 <_flash_rodata_start+0x3530>)
4037c0d3:	e32ec1        	l32r	a12, 40374d8c <_iram_text_start+0x988> (3c0271a8 <__func__$11>)
4037c0d6:	e330b1        	l32r	a11, 40374d98 <_iram_text_start+0x994> (1715 <UserFrameTotalSize+0x1615>)
4037c0d9:	e2e3a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c0dc:	03c4a5        	call8	4037fd28 <__assert_func>
4037c0df:	fb7c      	movi.n	a11, -1
4037c0e1:	e2eba1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c0e4:	fdf2e5        	call8	4037a014 <xPortEnterCriticalTimeout>
            if( pulPreviousNotificationValue != NULL )
4037c0e7:	00d616        	beqz	a6, 4037c0f8 <xTaskGenericNotify+0x40>
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
4037c0ea:	50c382        	addi	a8, a3, 80
4037c0ed:	a08820        	addx4	a8, a8, a2
4037c0f0:	0020c0        	memw
4037c0f3:	032882        	l32i	a8, a8, 12
4037c0f6:	0689      	s32i.n	a8, a6, 0
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c0f8:	823a      	add.n	a8, a2, a3
4037c0fa:	50a192        	movi	a9, 0x150
4037c0fd:	889a      	add.n	a8, a8, a9
4037c0ff:	0020c0        	memw
4037c102:	000892        	l8ui	a9, a8, 0
4037c105:	749090        	extui	a9, a9, 0, 8
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c108:	2a0c      	movi.n	a10, 2
4037c10a:	0020c0        	memw
4037c10d:	0048a2        	s8i	a10, a8, 0
            switch( eAction )
4037c110:	2c2526        	beqi	a5, 2, 4037c140 <xTaskGenericNotify+0x88>
4037c113:	0935f6        	bgeui	a5, 3, 4037c120 <xTaskGenericNotify+0x68>
4037c116:	077516        	beqz	a5, 4037c191 <xTaskGenericNotify+0xd9>
4037c119:	0c1526        	beqi	a5, 1, 4037c129 <xTaskGenericNotify+0x71>
4037c11c:	001606        	j	4037c178 <xTaskGenericNotify+0xc0>
4037c11f:	352600        	extui	a2, a0, 22, 4
4037c122:	452631        	l32r	a3, 4034d5bc <rom_rx_gain_force+0x347190>
4037c125:	3d          	.byte	0x3d
4037c126:	001386        	j	4037c178 <xTaskGenericNotify+0xc0>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
4037c129:	50c332        	addi	a3, a3, 80
4037c12c:	a03320        	addx4	a3, a3, a2
4037c12f:	0020c0        	memw
4037c132:	3388      	l32i.n	a8, a3, 12
4037c134:	208840        	or	a8, a8, a4
4037c137:	0020c0        	memw
4037c13a:	3389      	s32i.n	a8, a3, 12
                    break;
4037c13c:	001446        	j	4037c191 <xTaskGenericNotify+0xd9>
4037c13f:	c33200        	movf	a3, a2, b0
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c142:	332050        	clamps	a2, a0, 12
4037c145:	20c0a0        	or	a12, a0, a10
4037c148:	338800        	clamps	a8, a8, 7
4037c14b:	881b      	addi.n	a8, a8, 1
4037c14d:	0020c0        	memw
4037c150:	3389      	s32i.n	a8, a3, 12
                    break;
4037c152:	000ec6        	j	4037c191 <xTaskGenericNotify+0xd9>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4037c155:	50c332        	addi	a3, a3, 80
4037c158:	a03320        	addx4	a3, a3, a2
4037c15b:	0020c0        	memw
4037c15e:	3349      	s32i.n	a4, a3, 12
                    break;
4037c160:	000b46        	j	4037c191 <xTaskGenericNotify+0xd9>
4037c163:	00          	.byte	00
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4037c164:	022966        	bnei	a9, 2, 4037c16a <xTaskGenericNotify+0xb2>
4037c167:	004286        	j	4037c275 <xTaskGenericNotify+0x1bd>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4037c16a:	50c332        	addi	a3, a3, 80
4037c16d:	a03320        	addx4	a3, a3, a2
4037c170:	0020c0        	memw
4037c173:	3349      	s32i.n	a4, a3, 12
4037c175:	000606        	j	4037c191 <xTaskGenericNotify+0xd9>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
4037c178:	e2cb81        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037c17b:	0020c0        	memw
4037c17e:	0888      	l32i.n	a8, a8, 0
4037c180:	d88c      	beqz.n	a8, 4037c191 <xTaskGenericNotify+0xd9>
4037c182:	e306d1        	l32r	a13, 40374d9c <_iram_text_start+0x998> (3c023660 <_flash_rodata_start+0x3540>)
4037c185:	e301c1        	l32r	a12, 40374d8c <_iram_text_start+0x988> (3c0271a8 <__func__$11>)
4037c188:	e306b1        	l32r	a11, 40374da0 <_iram_text_start+0x99c> (174a <UserFrameTotalSize+0x164a>)
4037c18b:	e2b7a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c18e:	03b9a5        	call8	4037fd28 <__assert_func>
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c191:	021926        	beqi	a9, 1, 4037c197 <xTaskGenericNotify+0xdf>
4037c194:	003886        	j	4037c27a <xTaskGenericNotify+0x1c2>
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037c197:	0020c0        	memw
4037c19a:	5288      	l32i.n	a8, a2, 20
4037c19c:	0020c0        	memw
4037c19f:	2298      	l32i.n	a9, a2, 8
4037c1a1:	0020c0        	memw
4037c1a4:	32a8      	l32i.n	a10, a2, 12
4037c1a6:	0020c0        	memw
4037c1a9:	29a9      	s32i.n	a10, a9, 8
4037c1ab:	0020c0        	memw
4037c1ae:	3298      	l32i.n	a9, a2, 12
4037c1b0:	0020c0        	memw
4037c1b3:	22a8      	l32i.n	a10, a2, 8
4037c1b5:	0020c0        	memw
4037c1b8:	19a9      	s32i.n	a10, a9, 4
4037c1ba:	0020c0        	memw
4037c1bd:	18a8      	l32i.n	a10, a8, 4
4037c1bf:	924b      	addi.n	a9, a2, 4
4037c1c1:	099a97        	bne	a10, a9, 4037c1ce <xTaskGenericNotify+0x116>
4037c1c4:	0020c0        	memw
4037c1c7:	32a8      	l32i.n	a10, a2, 12
4037c1c9:	0020c0        	memw
4037c1cc:	18a9      	s32i.n	a10, a8, 4
4037c1ce:	0a0c      	movi.n	a10, 0
4037c1d0:	0020c0        	memw
4037c1d3:	0562a2        	s32i	a10, a2, 20
4037c1d6:	0020c0        	memw
4037c1d9:	0028a2        	l32i	a10, a8, 0
4037c1dc:	aa0b      	addi.n	a10, a10, -1
4037c1de:	0020c0        	memw
4037c1e1:	08a9      	s32i.n	a10, a8, 0
                prvAddTaskToReadyList( pxTCB );
4037c1e3:	b288      	l32i.n	a8, a2, 44
4037c1e5:	e2a1a1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037c1e8:	0020c0        	memw
4037c1eb:	0aa8      	l32i.n	a10, a10, 0
4037c1ed:	07ba87        	bgeu	a10, a8, 4037c1f8 <xTaskGenericNotify+0x140>
4037c1f0:	e29fa1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037c1f3:	0020c0        	memw
4037c1f6:	0a89      	s32i.n	a8, a10, 0
4037c1f8:	e29ea1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037c1fb:	a08880        	addx4	a8, a8, a8
4037c1fe:	a088a0        	addx4	a8, a8, a10
4037c201:	0020c0        	memw
4037c204:	1888      	l32i.n	a8, a8, 4
4037c206:	0020c0        	memw
4037c209:	2289      	s32i.n	a8, a2, 8
4037c20b:	0020c0        	memw
4037c20e:	28b8      	l32i.n	a11, a8, 8
4037c210:	0020c0        	memw
4037c213:	32b9      	s32i.n	a11, a2, 12
4037c215:	0020c0        	memw
4037c218:	28b8      	l32i.n	a11, a8, 8
4037c21a:	0020c0        	memw
4037c21d:	1b99      	s32i.n	a9, a11, 4
4037c21f:	0020c0        	memw
4037c222:	2899      	s32i.n	a9, a8, 8
4037c224:	b288      	l32i.n	a8, a2, 44
4037c226:	a09880        	addx4	a9, a8, a8
4037c229:	a099a0        	addx4	a9, a9, a10
4037c22c:	0020c0        	memw
4037c22f:	5299      	s32i.n	a9, a2, 20
4037c231:	0020c0        	memw
4037c234:	0998      	l32i.n	a9, a9, 0
4037c236:	991b      	addi.n	a9, a9, 1
4037c238:	a08880        	addx4	a8, a8, a8
4037c23b:	a088a0        	addx4	a8, a8, a10
4037c23e:	0020c0        	memw
4037c241:	0899      	s32i.n	a9, a8, 0
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c243:	0020c0        	memw
4037c246:	a288      	l32i.n	a8, a2, 40
4037c248:	d88c      	beqz.n	a8, 4037c259 <xTaskGenericNotify+0x1a1>
4037c24a:	e2d6d1        	l32r	a13, 40374da4 <_iram_text_start+0x9a0> (3c023680 <_flash_rodata_start+0x3560>)
4037c24d:	e2cfc1        	l32r	a12, 40374d8c <_iram_text_start+0x988> (3c0271a8 <__func__$11>)
4037c250:	e2d6b1        	l32r	a11, 40374da8 <_iram_text_start+0x9a4> (1759 <UserFrameTotalSize+0x1659>)
4037c253:	e285a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c256:	03ad25        	call8	4037fd28 <__assert_func>
                if( taskIS_YIELD_REQUIRED( pxTCB, pdFALSE ) == pdTRUE )
4037c259:	00a0c2        	movi	a12, 0
4037c25c:	0b22b2        	l32i	a11, a2, 44
4037c25f:	02ad      	mov.n	a10, a2
4037c261:	fe6ee5        	call8	4037a950 <prvIsYieldRequiredSMP>
4037c264:	0a2d      	mov.n	a2, a10
4037c266:	171a66        	bnei	a10, 1, 4037c281 <xTaskGenericNotify+0x1c9>
4037c269:	03eba0        	rsr.prid	a10
4037c26c:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037c26f:	fb9e65        	call8	40377c54 <esp_crosscore_int_send_yield>
4037c272:	000346        	j	4037c283 <xTaskGenericNotify+0x1cb>
                        xReturn = pdFAIL;
4037c275:	020c      	movi.n	a2, 0
4037c277:	000206        	j	4037c283 <xTaskGenericNotify+0x1cb>
4037c27a:	120c      	movi.n	a2, 1
4037c27c:	0000c6        	j	4037c283 <xTaskGenericNotify+0x1cb>
4037c27f:	00          	.byte	00
4037c280:	120c00        	andbc	b0, b12, b0
        taskEXIT_CRITICAL( &xKernelLock );
4037c283:	e283a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c286:	fdede5        	call8	4037a164 <vPortExitCritical>
    }
4037c289:	f01d      	retw.n
	...

4037c28c <vTaskGenericNotifyGiveFromISR>:
    {
4037c28c:	004136        	entry	a1, 32
        configASSERT( xTaskToNotify );
4037c28f:	00e256        	bnez	a2, 4037c2a1 <vTaskGenericNotifyGiveFromISR+0x15>
4037c292:	e2c0d1        	l32r	a13, 40374d94 <_iram_text_start+0x990> (3c023650 <_flash_rodata_start+0x3530>)
4037c295:	e2c5c1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c027188 <__func__$9>)
4037c298:	e2c6b1        	l32r	a11, 40374db0 <_iram_text_start+0x9ac> (181b <UserFrameTotalSize+0x171b>)
4037c29b:	e273a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c29e:	03a8a5        	call8	4037fd28 <__assert_func>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c2a1:	00e316        	beqz	a3, 4037c2b3 <vTaskGenericNotifyGiveFromISR+0x27>
4037c2a4:	e2b9d1        	l32r	a13, 40374d88 <_iram_text_start+0x984> (3c02363c <_flash_rodata_start+0x351c>)
4037c2a7:	e2c1c1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c027188 <__func__$9>)
4037c2aa:	e2c2b1        	l32r	a11, 40374db4 <_iram_text_start+0x9b0> (181c <UserFrameTotalSize+0x171c>)
4037c2ad:	e26ea1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c2b0:	03a765        	call8	4037fd28 <__assert_func>
4037c2b3:	fb7c      	movi.n	a11, -1
4037c2b5:	e276a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c2b8:	fdd5a5        	call8	4037a014 <xPortEnterCriticalTimeout>
4037c2bb:	03eb70        	rsr.prid	a7
4037c2be:	047d70        	extui	a7, a7, 13, 1
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c2c1:	808230        	add	a8, a2, a3
4037c2c4:	50a192        	movi	a9, 0x150
4037c2c7:	889a      	add.n	a8, a8, a9
4037c2c9:	0020c0        	memw
4037c2cc:	000892        	l8ui	a9, a8, 0
4037c2cf:	749090        	extui	a9, a9, 0, 8
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c2d2:	2a0c      	movi.n	a10, 2
4037c2d4:	0020c0        	memw
4037c2d7:	0048a2        	s8i	a10, a8, 0
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c2da:	50c332        	addi	a3, a3, 80
4037c2dd:	a03320        	addx4	a3, a3, a2
4037c2e0:	0020c0        	memw
4037c2e3:	3388      	l32i.n	a8, a3, 12
4037c2e5:	881b      	addi.n	a8, a8, 1
4037c2e7:	0020c0        	memw
4037c2ea:	3389      	s32i.n	a8, a3, 12
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c2ec:	021926        	beqi	a9, 1, 4037c2f2 <vTaskGenericNotifyGiveFromISR+0x66>
4037c2ef:	004d06        	j	4037c427 <vTaskGenericNotifyGiveFromISR+0x19b>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c2f2:	0020c0        	memw
4037c2f5:	a288      	l32i.n	a8, a2, 40
4037c2f7:	d88c      	beqz.n	a8, 4037c308 <vTaskGenericNotifyGiveFromISR+0x7c>
4037c2f9:	e2aad1        	l32r	a13, 40374da4 <_iram_text_start+0x9a0> (3c023680 <_flash_rodata_start+0x3560>)
4037c2fc:	e2acc1        	l32r	a12, 40374dac <_iram_text_start+0x9a8> (3c027188 <__func__$9>)
4037c2ff:	e2aeb1        	l32r	a11, 40374db8 <_iram_text_start+0x9b4> (1845 <UserFrameTotalSize+0x1745>)
4037c302:	e259a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c305:	03a225        	call8	4037fd28 <__assert_func>
                if( taskCAN_BE_SCHEDULED( pxTCB ) == pdTRUE )
4037c308:	20a220        	or	a10, a2, a2
4037c30b:	fe5c25        	call8	4037a8cc <prvCheckTaskCanBeScheduledSMP>
4037c30e:	021a26        	beqi	a10, 1, 4037c314 <vTaskGenericNotifyGiveFromISR+0x88>
4037c311:	002bc6        	j	4037c3c4 <vTaskGenericNotifyGiveFromISR+0x138>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4037c314:	0020c0        	memw
4037c317:	052282        	l32i	a8, a2, 20
4037c31a:	0020c0        	memw
4037c31d:	022292        	l32i	a9, a2, 8
4037c320:	0020c0        	memw
4037c323:	32a8      	l32i.n	a10, a2, 12
4037c325:	0020c0        	memw
4037c328:	29a9      	s32i.n	a10, a9, 8
4037c32a:	0020c0        	memw
4037c32d:	3298      	l32i.n	a9, a2, 12
4037c32f:	0020c0        	memw
4037c332:	22a8      	l32i.n	a10, a2, 8
4037c334:	0020c0        	memw
4037c337:	19a9      	s32i.n	a10, a9, 4
4037c339:	0020c0        	memw
4037c33c:	18a8      	l32i.n	a10, a8, 4
4037c33e:	924b      	addi.n	a9, a2, 4
4037c340:	099a97        	bne	a10, a9, 4037c34d <vTaskGenericNotifyGiveFromISR+0xc1>
4037c343:	0020c0        	memw
4037c346:	32a8      	l32i.n	a10, a2, 12
4037c348:	0020c0        	memw
4037c34b:	18a9      	s32i.n	a10, a8, 4
4037c34d:	0a0c      	movi.n	a10, 0
4037c34f:	0020c0        	memw
4037c352:	52a9      	s32i.n	a10, a2, 20
4037c354:	0020c0        	memw
4037c357:	08a8      	l32i.n	a10, a8, 0
4037c359:	aa0b      	addi.n	a10, a10, -1
4037c35b:	0020c0        	memw
4037c35e:	08a9      	s32i.n	a10, a8, 0
                    prvAddTaskToReadyList( pxTCB );
4037c360:	b288      	l32i.n	a8, a2, 44
4037c362:	e242a1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037c365:	0020c0        	memw
4037c368:	0aa8      	l32i.n	a10, a10, 0
4037c36a:	07ba87        	bgeu	a10, a8, 4037c375 <vTaskGenericNotifyGiveFromISR+0xe9>
4037c36d:	e23fa1        	l32r	a10, 40374c6c <_iram_text_start+0x868> (3fc94fcc <uxTopReadyPriority>)
4037c370:	0020c0        	memw
4037c373:	0a89      	s32i.n	a8, a10, 0
4037c375:	e23ea1        	l32r	a10, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037c378:	a08880        	addx4	a8, a8, a8
4037c37b:	a088a0        	addx4	a8, a8, a10
4037c37e:	0020c0        	memw
4037c381:	1888      	l32i.n	a8, a8, 4
4037c383:	0020c0        	memw
4037c386:	2289      	s32i.n	a8, a2, 8
4037c388:	0020c0        	memw
4037c38b:	28b8      	l32i.n	a11, a8, 8
4037c38d:	0020c0        	memw
4037c390:	32b9      	s32i.n	a11, a2, 12
4037c392:	0020c0        	memw
4037c395:	28b8      	l32i.n	a11, a8, 8
4037c397:	0020c0        	memw
4037c39a:	1b99      	s32i.n	a9, a11, 4
4037c39c:	0020c0        	memw
4037c39f:	2899      	s32i.n	a9, a8, 8
4037c3a1:	b288      	l32i.n	a8, a2, 44
4037c3a3:	a09880        	addx4	a9, a8, a8
4037c3a6:	a099a0        	addx4	a9, a9, a10
4037c3a9:	0020c0        	memw
4037c3ac:	5299      	s32i.n	a9, a2, 20
4037c3ae:	0020c0        	memw
4037c3b1:	0998      	l32i.n	a9, a9, 0
4037c3b3:	991b      	addi.n	a9, a9, 1
4037c3b5:	a08880        	addx4	a8, a8, a8
4037c3b8:	a088a0        	addx4	a8, a8, a10
4037c3bb:	0020c0        	memw
4037c3be:	0899      	s32i.n	a9, a8, 0
4037c3c0:	0010c6        	j	4037c407 <vTaskGenericNotifyGiveFromISR+0x17b>
4037c3c3:	877000        	ee.stf.64.xp	f7, f8, a0, a0
                    listINSERT_END( &( xPendingReadyList[ xCurCoreID ] ), &( pxTCB->xEventListItem ) );
4037c3c6:	a0          	.byte	0xa0
4037c3c7:	e24091        	l32r	a9, 40374cc8 <_iram_text_start+0x8c4> (3fc95004 <xPendingReadyList>)
4037c3ca:	a08890        	addx4	a8, a8, a9
4037c3cd:	0020c0        	memw
4037c3d0:	012892        	l32i	a9, a8, 4
4037c3d3:	0020c0        	memw
4037c3d6:	076292        	s32i	a9, a2, 28
4037c3d9:	0020c0        	memw
4037c3dc:	0229a2        	l32i	a10, a9, 8
4037c3df:	0020c0        	memw
4037c3e2:	82a9      	s32i.n	a10, a2, 32
4037c3e4:	0020c0        	memw
4037c3e7:	29b8      	l32i.n	a11, a9, 8
4037c3e9:	18c2a2        	addi	a10, a2, 24
4037c3ec:	0020c0        	memw
4037c3ef:	1ba9      	s32i.n	a10, a11, 4
4037c3f1:	0020c0        	memw
4037c3f4:	29a9      	s32i.n	a10, a9, 8
4037c3f6:	0020c0        	memw
4037c3f9:	a289      	s32i.n	a8, a2, 40
4037c3fb:	0020c0        	memw
4037c3fe:	0898      	l32i.n	a9, a8, 0
4037c400:	991b      	addi.n	a9, a9, 1
4037c402:	0020c0        	memw
4037c405:	0899      	s32i.n	a9, a8, 0
                if( taskIS_YIELD_REQUIRED( pxTCB, pdFALSE ) == pdTRUE )
4037c407:	0c0c      	movi.n	a12, 0
4037c409:	b2b8      	l32i.n	a11, a2, 44
4037c40b:	02ad      	mov.n	a10, a2
4037c40d:	fe5425        	call8	4037a950 <prvIsYieldRequiredSMP>
4037c410:	131a66        	bnei	a10, 1, 4037c427 <vTaskGenericNotifyGiveFromISR+0x19b>
                    if( pxHigherPriorityTaskWoken != NULL )
4037c413:	248c      	beqz.n	a4, 4037c419 <vTaskGenericNotifyGiveFromISR+0x18d>
                        *pxHigherPriorityTaskWoken = pdTRUE;
4037c415:	180c      	movi.n	a8, 1
4037c417:	0489      	s32i.n	a8, a4, 0
                    xYieldPending[ xCurCoreID ] = pdTRUE;
4037c419:	e23481        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037c41c:	a07780        	addx4	a7, a7, a8
4037c41f:	180c      	movi.n	a8, 1
4037c421:	0020c0        	memw
4037c424:	006782        	s32i	a8, a7, 0
        prvEXIT_CRITICAL_OR_UNMASK_ISR( &xKernelLock, uxSavedInterruptStatus );
4037c427:	e21aa1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c42a:	fdd3a5        	call8	4037a164 <vPortExitCritical>
    }
4037c42d:	f01d      	retw.n
	...

4037c430 <xTaskIncrementTickOtherCores>:
/*----------------------------------------------------------*/

#if ( !CONFIG_FREERTOS_SMP && ( configNUM_CORES > 1 ) )

    BaseType_t xTaskIncrementTickOtherCores( void )
    {
4037c430:	004136        	entry	a1, 32
4037c433:	03eb70        	rsr.prid	a7
4037c436:	047d70        	extui	a7, a7, 13, 1
         * execution */
        BaseType_t xCoreID = portGET_CORE_ID();
        BaseType_t xSwitchRequired = pdFALSE;

        /* This function should never be called by Core 0. */
        configASSERT( xCoreID != 0 );
4037c439:	c7cc      	bnez.n	a7, 4037c449 <xTaskIncrementTickOtherCores+0x19>
4037c43b:	e260d1        	l32r	a13, 40374dbc <_iram_text_start+0x9b8> (3c0236c0 <_flash_rodata_start+0x35a0>)
4037c43e:	e260c1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc> (3c027168 <__func__$7>)
4037c441:	bb5c      	movi.n	a11, 91
4037c443:	e260a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c446:	038e25        	call8	4037fd28 <__assert_func>

        /* Called by the portable layer each time a tick interrupt occurs
         * on a core other than core 0. */
        traceTASK_INCREMENT_TICK( xTickCount );

        if( uxSchedulerSuspended[ xCoreID ] == ( UBaseType_t ) 0U )
4037c449:	e20281        	l32r	a8, 40374c54 <_iram_text_start+0x850> (3fc94fa0 <uxSchedulerSuspended>)
4037c44c:	a08780        	addx4	a8, a7, a8
4037c44f:	0020c0        	memw
4037c452:	0888      	l32i.n	a8, a8, 0
4037c454:	049856        	bnez	a8, 4037c4a1 <xTaskIncrementTickOtherCores+0x71>
4037c457:	ffafb2        	movi	a11, -1
4037c45a:	e20da1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c45d:	fdbb65        	call8	4037a014 <xPortEnterCriticalTimeout>
            /* Tasks of equal priority to the currently running task will share
             * processing time (time slice) if preemption is on, and the application
             * writer has not explicitly turned time slicing off. */
            #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ xCoreID ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037c460:	e1e681        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037c463:	a08780        	addx4	a8, a7, a8
4037c466:	0020c0        	memw
4037c469:	002882        	l32i	a8, a8, 0
4037c46c:	b888      	l32i.n	a8, a8, 44
4037c46e:	a08880        	addx4	a8, a8, a8
4037c471:	1198e0        	slli	a9, a8, 2
4037c474:	e1ff81        	l32r	a8, 40374c70 <_iram_text_start+0x86c> (3fc9505c <pxReadyTasksLists>)
4037c477:	889a      	add.n	a8, a8, a9
4037c479:	0020c0        	memw
4037c47c:	0888      	l32i.n	a8, a8, 0
4037c47e:	0428f6        	bgeui	a8, 2, 4037c486 <xTaskIncrementTickOtherCores+0x56>
        BaseType_t xSwitchRequired = pdFALSE;
4037c481:	020c      	movi.n	a2, 0
4037c483:	000086        	j	4037c489 <xTaskIncrementTickOtherCores+0x59>
                {
                    xSwitchRequired = pdTRUE;
4037c486:	01a022        	movi	a2, 1
            }
            #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */

            /* Release the previously taken kernel lock as we have finished
             * accessing the kernel data structures. */
            taskEXIT_CRITICAL_ISR( &xKernelLock );
4037c489:	e201a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c48c:	fdcd65        	call8	4037a164 <vPortExitCritical>

            #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending[ xCoreID ] != pdFALSE )
4037c48f:	e21781        	l32r	a8, 40374cec <_iram_text_start+0x8e8> (3fc94fbc <xYieldPending>)
4037c492:	a07780        	addx4	a7, a7, a8
4037c495:	0020c0        	memw
4037c498:	002782        	l32i	a8, a7, 0
4037c49b:	007856        	bnez	a8, 4037c4a6 <xTaskIncrementTickOtherCores+0x76>
4037c49e:	000186        	j	4037c4a8 <xTaskIncrementTickOtherCores+0x78>
        BaseType_t xSwitchRequired = pdFALSE;
4037c4a1:	020c      	movi.n	a2, 0
4037c4a3:	000046        	j	4037c4a8 <xTaskIncrementTickOtherCores+0x78>
                {
                    xSwitchRequired = pdTRUE;
4037c4a6:	120c      	movi.n	a2, 1
            vApplicationTickHook();
        }
        #endif

        return xSwitchRequired;
    }
4037c4a8:	f01d      	retw.n
	...

4037c4ac <xTaskCreatePinnedToCore>:
                                        const uint32_t usStackDepth,
                                        void * const pvParameters,
                                        UBaseType_t uxPriority,
                                        TaskHandle_t * const pxCreatedTask,
                                        const BaseType_t xCoreID )
    {
4037c4ac:	008136        	entry	a1, 64
4037c4af:	066172        	s32i	a7, a1, 24
4037c4b2:	046152        	s32i	a5, a1, 16
4037c4b5:	056162        	s32i	a6, a1, 20
4037c4b8:	102152        	l32i	a5, a1, 64
        BaseType_t xReturn;

        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE || xCoreID == tskNO_AFFINITY );
4037c4bb:	180c      	movi.n	a8, 1
4037c4bd:	628850        	saltu	a8, a8, a5
4037c4c0:	880b      	addi.n	a8, a8, -1
4037c4c2:	608080        	neg	a8, a8
4037c4c5:	748080        	extui	a8, a8, 0, 8
4037c4c8:	e0c391        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037c4cb:	c09590        	sub	a9, a5, a9
4037c4ce:	40f990        	nsau	a9, a9
4037c4d1:	419590        	srli	a9, a9, 5
4037c4d4:	208890        	or	a8, a8, a9
4037c4d7:	d8cc      	bnez.n	a8, 4037c4e8 <xTaskCreatePinnedToCore+0x3c>
4037c4d9:	e23bd1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4> (3c023718 <_flash_rodata_start+0x35f8>)
4037c4dc:	e23cc1        	l32r	a12, 40374dcc <_iram_text_start+0x9c8> (3c027150 <__func__$6>)
4037c4df:	a3a0b2        	movi	a11, 163
4037c4e2:	e238a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c4e5:	038425        	call8	4037fd28 <__assert_func>
            #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
4037c4e8:	04ad      	mov.n	a10, a4
4037c4ea:	fdf8e5        	call8	4037a478 <pvPortMalloc>
4037c4ed:	0a7d      	mov.n	a7, a10

                if( pxStack != NULL )
4037c4ef:	049a16        	beqz	a10, 4037c53c <xTaskCreatePinnedToCore+0x90>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
4037c4f2:	54a1a2        	movi	a10, 0x154
4037c4f5:	fdf825        	call8	4037a478 <pvPortMalloc>
4037c4f8:	0a6d      	mov.n	a6, a10

                    if( pxNewTCB != NULL )
4037c4fa:	4abc      	beqz.n	a10, 4037c532 <xTaskCreatePinnedToCore+0x86>
                    {
                        memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
4037c4fc:	54a1c2        	movi	a12, 0x154
4037c4ff:	0b0c      	movi.n	a11, 0
4037c501:	dfed81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037c504:	0008e0        	callx8	a8

                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
4037c507:	c679      	s32i.n	a7, a6, 48
            {
                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
                {
                    /* Tasks can be created statically or dynamically, so note this
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
4037c509:	01d682        	addmi	a8, a6, 0x100
4037c50c:	090c      	movi.n	a9, 0
4037c50e:	514892        	s8i	a9, a8, 81
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL, xCoreID );
4037c511:	2159      	s32i.n	a5, a1, 8
4037c513:	080c      	movi.n	a8, 0
4037c515:	1189      	s32i.n	a8, a1, 4
4037c517:	0169      	s32i.n	a6, a1, 0
4037c519:	61f8      	l32i.n	a15, a1, 24
4037c51b:	51e8      	l32i.n	a14, a1, 20
4037c51d:	41d8      	l32i.n	a13, a1, 16
4037c51f:	04cd      	mov.n	a12, a4
4037c521:	03bd      	mov.n	a11, a3
4037c523:	02ad      	mov.n	a10, a2
4037c525:	fe8ba5        	call8	4037ade0 <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
4037c528:	06ad      	mov.n	a10, a6
4037c52a:	fe9c25        	call8	4037aeec <prvAddNewTaskToReadyList>
                xReturn = pdPASS;
4037c52d:	120c      	movi.n	a2, 1
4037c52f:	0002c6        	j	4037c53e <xTaskCreatePinnedToCore+0x92>
                        vPortFreeStack( pxStack );
4037c532:	07ad      	mov.n	a10, a7
4037c534:	fdf565        	call8	4037a48c <vPortFree>
            }
            else
            {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
4037c537:	f27c      	movi.n	a2, -1
4037c539:	000046        	j	4037c53e <xTaskCreatePinnedToCore+0x92>
4037c53c:	f27c      	movi.n	a2, -1
            }
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c53e:	f01d      	retw.n

4037c540 <xTaskCreateStaticPinnedToCore>:
                                                void * const pvParameters,
                                                UBaseType_t uxPriority,
                                                StackType_t * const puxStackBuffer,
                                                StaticTask_t * const pxTaskBuffer,
                                                const BaseType_t xCoreID )
    {
4037c540:	00a136        	entry	a1, 80
4037c543:	8169      	s32i.n	a6, a1, 32
4037c545:	142162        	l32i	a6, a1, 80
        TaskHandle_t xReturn;

        configASSERT( portVALID_STACK_MEM( puxStackBuffer ) );
4037c548:	07ad      	mov.n	a10, a7
4037c54a:	fdfaa5        	call8	4037a4f4 <xPortcheckValidStackMem>
4037c54d:	dacc      	bnez.n	a10, 4037c55e <xTaskCreateStaticPinnedToCore+0x1e>
4037c54f:	e220d1        	l32r	a13, 40374dd0 <_iram_text_start+0x9cc> (3c0237d4 <_flash_rodata_start+0x36b4>)
4037c552:	e220c1        	l32r	a12, 40374dd4 <_iram_text_start+0x9d0> (3c027118 <__func__$4>)
4037c555:	2ba1b2        	movi	a11, 0x12b
4037c558:	e21ba1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c55b:	037ce5        	call8	4037fd28 <__assert_func>
        configASSERT( portVALID_TCB_MEM( pxTaskBuffer ) );
4037c55e:	20a660        	or	a10, a6, a6
4037c561:	fdf365        	call8	4037a498 <xPortCheckValidTCBMem>
4037c564:	00ea56        	bnez	a10, 4037c576 <xTaskCreateStaticPinnedToCore+0x36>
4037c567:	e21cd1        	l32r	a13, 40374dd8 <_iram_text_start+0x9d4> (3c0237fc <_flash_rodata_start+0x36dc>)
4037c56a:	e21ac1        	l32r	a12, 40374dd4 <_iram_text_start+0x9d0> (3c027118 <__func__$4>)
4037c56d:	2ca1b2        	movi	a11, 0x12c
4037c570:	e215a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c573:	037b65        	call8	4037fd28 <__assert_func>
        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE || xCoreID == tskNO_AFFINITY );
4037c576:	01a082        	movi	a8, 1
4037c579:	152192        	l32i	a9, a1, 84
4037c57c:	628890        	saltu	a8, a8, a9
4037c57f:	ffc882        	addi	a8, a8, -1
4037c582:	608080        	neg	a8, a8
4037c585:	748080        	extui	a8, a8, 0, 8
4037c588:	e09391        	l32r	a9, 403747d4 <_iram_text_start+0x3d0> (7fffffff <_rtc_reserved_end+0x1fefffff>)
4037c58b:	1521a2        	l32i	a10, a1, 84
4037c58e:	c09a90        	sub	a9, a10, a9
4037c591:	40f990        	nsau	a9, a9
4037c594:	419590        	srli	a9, a9, 5
4037c597:	208890        	or	a8, a8, a9
4037c59a:	00e856        	bnez	a8, 4037c5ac <xTaskCreateStaticPinnedToCore+0x6c>
4037c59d:	e20ad1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4> (3c023718 <_flash_rodata_start+0x35f8>)
4037c5a0:	e20dc1        	l32r	a12, 40374dd4 <_iram_text_start+0x9d0> (3c027118 <__func__$4>)
4037c5a3:	2da1b2        	movi	a11, 0x12d
4037c5a6:	e207a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c5a9:	0377e5        	call8	4037fd28 <__assert_func>
            #if ( configASSERT_DEFINED == 1 )
            {
                /* Sanity check that the size of the structure used to declare a
                 * variable of type StaticTask_t equals the size of the real task
                 * structure. */
                volatile size_t xSize = sizeof( StaticTask_t );
4037c5ac:	54a182        	movi	a8, 0x154
4037c5af:	0020c0        	memw
4037c5b2:	5189      	s32i.n	a8, a1, 20
                configASSERT( xSize == sizeof( TCB_t ) );
4037c5b4:	0020c0        	memw
4037c5b7:	052192        	l32i	a9, a1, 20
4037c5ba:	0e1987        	beq	a9, a8, 4037c5cc <xTaskCreateStaticPinnedToCore+0x8c>
4037c5bd:	e207d1        	l32r	a13, 40374ddc <_iram_text_start+0x9d8> (3c023820 <_flash_rodata_start+0x3700>)
4037c5c0:	e205c1        	l32r	a12, 40374dd4 <_iram_text_start+0x9d0> (3c027118 <__func__$4>)
4037c5c3:	57a1b2        	movi	a11, 0x157
4037c5c6:	e1ffa1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c5c9:	0375e5        	call8	4037fd28 <__assert_func>
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
4037c5cc:	0020c0        	memw
4037c5cf:	052182        	l32i	a8, a1, 20
            }
            #endif /* configASSERT_DEFINED */

            if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
4037c5d2:	01a092        	movi	a9, 1
4037c5d5:	839660        	moveqz	a9, a6, a6
4037c5d8:	180c      	movi.n	a8, 1
4037c5da:	838770        	moveqz	a8, a7, a7
4037c5dd:	3b0987        	bnone	a9, a8, 4037c61c <xTaskCreateStaticPinnedToCore+0xdc>
            {
                /* The memory used for the task's TCB and stack are passed into this
                 * function - use them. */
                pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
                memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
4037c5e0:	54a1c2        	movi	a12, 0x154
4037c5e3:	0b0c      	movi.n	a11, 0
4037c5e5:	20a660        	or	a10, a6, a6
4037c5e8:	dfb481        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037c5eb:	0008e0        	callx8	a8
                pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
4037c5ee:	c679      	s32i.n	a7, a6, 48

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
                {
                    /* Tasks can be created statically or dynamically, so note this
                     * task was created statically in case the task is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
4037c5f0:	01d682        	addmi	a8, a6, 0x100
4037c5f3:	290c      	movi.n	a9, 2
4037c5f5:	514892        	s8i	a9, a8, 81
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL, xCoreID );
4037c5f8:	152182        	l32i	a8, a1, 84
4037c5fb:	2189      	s32i.n	a8, a1, 8
4037c5fd:	080c      	movi.n	a8, 0
4037c5ff:	1189      	s32i.n	a8, a1, 4
4037c601:	0169      	s32i.n	a6, a1, 0
4037c603:	10c1f2        	addi	a15, a1, 16
4037c606:	81e8      	l32i.n	a14, a1, 32
4037c608:	05dd      	mov.n	a13, a5
4037c60a:	04cd      	mov.n	a12, a4
4037c60c:	03bd      	mov.n	a11, a3
4037c60e:	02ad      	mov.n	a10, a2
4037c610:	fe7ce5        	call8	4037ade0 <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
4037c613:	06ad      	mov.n	a10, a6
4037c615:	fe8d65        	call8	4037aeec <prvAddNewTaskToReadyList>
4037c618:	000106        	j	4037c620 <xTaskCreateStaticPinnedToCore+0xe0>
4037c61b:	080c00        	lsx	f0, a12, a0
            }
            else
            {
                xReturn = NULL;
4037c61e:	4189      	s32i.n	a8, a1, 16
            }
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c620:	4128      	l32i.n	a2, a1, 16
4037c622:	f01d      	retw.n

4037c624 <prvCreateIdleTasks>:
{
4037c624:	00a136        	entry	a1, 80
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
4037c627:	0c1c      	movi.n	a12, 16
4037c629:	0b0c      	movi.n	a11, 0
4037c62b:	80a1c0        	add	a10, a1, a12
4037c62e:	dfa281        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037c631:	0008e0        	callx8	a8
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c634:	070c      	movi.n	a7, 0
    BaseType_t xReturn = pdPASS;
4037c636:	120c      	movi.n	a2, 1
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c638:	001b86        	j	4037c6aa <prvCreateIdleTasks+0x86>
4037c63b:	d21600        	quos	a1, a6, a0
            if( xReturn == pdFAIL )
4037c63e:	080c06        	j	4037e672 <multi_heap_aligned_free+0x26>
            for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
4037c641:	0004c6        	j	4037c658 <prvCreateIdleTasks+0x34>
                cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
4037c644:	e1e791        	l32r	a9, 40374de0 <_iram_text_start+0x9dc> (3c02383c <_flash_rodata_start+0x371c>)
4037c647:	998a      	add.n	a9, a9, a8
4037c649:	0009a2        	l8ui	a10, a9, 0
4037c64c:	10c192        	addi	a9, a1, 16
4037c64f:	998a      	add.n	a9, a9, a8
4037c651:	0049a2        	s8i	a10, a9, 0
                if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
4037c654:	5a8c      	beqz.n	a10, 4037c65d <prvCreateIdleTasks+0x39>
            for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
4037c656:	881b      	addi.n	a8, a8, 1
4037c658:	d90c      	movi.n	a9, 13
4037c65a:	e6b987        	bgeu	a9, a8, 4037c644 <prvCreateIdleTasks+0x20>
            cIdleName[ xIdleTaskNameIndex ] = ( char ) ( xCoreID + '0' );
4037c65d:	30c792        	addi	a9, a7, 48
4037c660:	10c162        	addi	a6, a1, 16
4037c663:	80a680        	add	a10, a6, a8
4037c666:	004a92        	s8i	a9, a10, 0
            cIdleName[ xIdleTaskNameIndex + 1 ] = '\0';
4037c669:	01c882        	addi	a8, a8, 1
4037c66c:	868a      	add.n	a8, a6, a8
4037c66e:	090c      	movi.n	a9, 0
4037c670:	004892        	s8i	a9, a8, 0
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
4037c673:	050c      	movi.n	a5, 0
4037c675:	a159      	s32i.n	a5, a1, 40
            StackType_t * pxIdleTaskStackBuffer = NULL;
4037c677:	9159      	s32i.n	a5, a1, 36
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
4037c679:	20c1c2        	addi	a12, a1, 32
4037c67c:	24c1b2        	addi	a11, a1, 36
4037c67f:	28c1a2        	addi	a10, a1, 40
4037c682:	fdeca5        	call8	4037a54c <vApplicationGetIdleTaskMemory>
            xIdleTaskHandle[ xCoreID ] = xTaskCreateStaticPinnedToCore( prvIdleTask,
4037c685:	1179      	s32i.n	a7, a1, 4
4037c687:	a188      	l32i.n	a8, a1, 40
4037c689:	0189      	s32i.n	a8, a1, 0
4037c68b:	91f8      	l32i.n	a15, a1, 36
4037c68d:	05ed      	mov.n	a14, a5
4037c68f:	05dd      	mov.n	a13, a5
4037c691:	81c8      	l32i.n	a12, a1, 32
4037c693:	20b660        	or	a11, a6, a6
4037c696:	e1d3a1        	l32r	a10, 40374de4 <_iram_text_start+0x9e0> (4037add0 <prvIdleTask>)
4037c699:	ffea65        	call8	4037c540 <xTaskCreateStaticPinnedToCore>
4037c69c:	e1d381        	l32r	a8, 40374de8 <_iram_text_start+0x9e4> (3fc94fa8 <xIdleTaskHandle>)
4037c69f:	a08780        	addx4	a8, a7, a8
4037c6a2:	08a9      	s32i.n	a10, a8, 0
            if( xIdleTaskHandle[ xCoreID ] != NULL )
4037c6a4:	0acc      	bnez.n	a10, 4037c6a8 <prvCreateIdleTasks+0x84>
                xReturn = pdFAIL;
4037c6a6:	052d      	mov.n	a2, a5
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
4037c6a8:	771b      	addi.n	a7, a7, 1
4037c6aa:	8e27a6        	blti	a7, 2, 4037c63c <prvCreateIdleTasks+0x18>
}
4037c6ad:	f01d      	retw.n
	...

4037c6b0 <vTaskStartScheduler>:
{
4037c6b0:	004136        	entry	a1, 32
    xReturn = prvCreateIdleTasks();
4037c6b3:	fff725        	call8	4037c624 <prvCreateIdleTasks>
        if( xReturn == pdPASS )
4037c6b6:	3b1a66        	bnei	a10, 1, 4037c6f5 <vTaskStartScheduler+0x45>
            xReturn = xTimerCreateTimerTask();
4037c6b9:	001065        	call8	4037c7c0 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
4037c6bc:	351a66        	bnei	a10, 1, 4037c6f5 <vTaskStartScheduler+0x45>
        portDISABLE_INTERRUPTS();
4037c6bf:	006380        	rsil	a8, 3
4037c6c2:	fb7c      	movi.n	a11, -1
4037c6c4:	e173a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c6c7:	fd94e5        	call8	4037a014 <xPortEnterCriticalTimeout>
            xNextTaskUnblockTime = portMAX_DELAY;
4037c6ca:	e16481        	l32r	a8, 40374c5c <_iram_text_start+0x858> (3fc94fb0 <xNextTaskUnblockTime>)
4037c6cd:	f97c      	movi.n	a9, -1
4037c6cf:	0020c0        	memw
4037c6d2:	0899      	s32i.n	a9, a8, 0
            xSchedulerRunning = pdTRUE;
4037c6d4:	e17e81        	l32r	a8, 40374ccc <_iram_text_start+0x8c8> (3fc94fc8 <xSchedulerRunning>)
4037c6d7:	190c      	movi.n	a9, 1
4037c6d9:	0020c0        	memw
4037c6dc:	0899      	s32i.n	a9, a8, 0
            xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
4037c6de:	e17181        	l32r	a8, 40374ca4 <_iram_text_start+0x8a0> (3fc94fd0 <xTickCount>)
4037c6e1:	00a092        	movi	a9, 0
4037c6e4:	0020c0        	memw
4037c6e7:	0899      	s32i.n	a9, a8, 0
        prvEXIT_CRITICAL_SMP_ONLY( &xKernelLock );
4037c6e9:	e169a1        	l32r	a10, 40374c90 <_iram_text_start+0x88c> (3fc92500 <xKernelLock>)
4037c6ec:	fda765        	call8	4037a164 <vPortExitCritical>
        xPortStartScheduler();
4037c6ef:	fd83e5        	call8	40379f2c <xPortStartScheduler>
4037c6f2:	000446        	j	4037c707 <vTaskStartScheduler+0x57>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
4037c6f5:	0e0a66        	bnei	a10, -1, 4037c707 <vTaskStartScheduler+0x57>
4037c6f8:	e1bdd1        	l32r	a13, 40374dec <_iram_text_start+0x9e8> (3c023844 <_flash_rodata_start+0x3724>)
4037c6fb:	e1bdc1        	l32r	a12, 40374df0 <_iram_text_start+0x9ec> (3c0272b0 <__func__$32>)
4037c6fe:	e1bdb1        	l32r	a11, 40374df4 <_iram_text_start+0x9f0> (9a3 <UserFrameTotalSize+0x8a3>)
4037c701:	e159a1        	l32r	a10, 40374c68 <_iram_text_start+0x864> (3c02331a <_flash_rodata_start+0x31fa>)
4037c704:	036225        	call8	4037fd28 <__assert_func>
    ( void ) uxTopUsedPriority;
4037c707:	e1bc81        	l32r	a8, 40374df8 <_iram_text_start+0x9f4> (3c027318 <uxTopUsedPriority>)
4037c70a:	0020c0        	memw
4037c70d:	0888      	l32i.n	a8, a8, 0
}
4037c70f:	f01d      	retw.n
4037c711:	000000        	ill

4037c714 <xTaskGetCoreID>:
/*----------------------------------------------------------*/

/* ------------------------------------------------- Task Utilities ------------------------------------------------- */

BaseType_t xTaskGetCoreID( TaskHandle_t xTask )
{
4037c714:	004136        	entry	a1, 32
            }
        #else /* CONFIG_FREERTOS_SMP */
            TCB_t * pxTCB;

            /* Todo: Remove xCoreID for single core builds (IDF-7894) */
            pxTCB = prvGetTCBFromHandle( xTask );
4037c717:	004256        	bnez	a2, 4037c71f <xTaskGetCoreID+0xb>
4037c71a:	ff05e5        	call8	4037b778 <xTaskGetCurrentTaskHandle>
4037c71d:	0a2d      	mov.n	a2, a10
        xReturn = 0;
    }
    #endif /* configNUM_CORES > 1 */

    return xReturn;
}
4037c71f:	112222        	l32i	a2, a2, 68
4037c722:	f01d      	retw.n

4037c724 <xTaskGetIdleTaskHandleForCore>:
/*----------------------------------------------------------*/

#if ( ( !CONFIG_FREERTOS_SMP ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )

    TaskHandle_t xTaskGetIdleTaskHandleForCore( BaseType_t xCoreID )
    {
4037c724:	004136        	entry	a1, 32
        /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
         * started, then xIdleTaskHandle will be NULL. */
        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE );
4037c727:	01a082        	movi	a8, 1
4037c72a:	0eb827        	bgeu	a8, a2, 4037c73c <xTaskGetIdleTaskHandleForCore+0x18>
4037c72d:	e1b3d1        	l32r	a13, 40374dfc <_iram_text_start+0x9f8> (3c023858 <_flash_rodata_start+0x3738>)
4037c730:	e1b4c1        	l32r	a12, 40374e00 <_iram_text_start+0x9fc> (3c0270f8 <__func__$3>)
4037c733:	c4a1b2        	movi	a11, 0x1c4
4037c736:	e1a3a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c739:	035ee5        	call8	4037fd28 <__assert_func>
        configASSERT( ( xIdleTaskHandle[ xCoreID ] != NULL ) );
4037c73c:	e1ab81        	l32r	a8, 40374de8 <_iram_text_start+0x9e4> (3fc94fa8 <xIdleTaskHandle>)
4037c73f:	a02280        	addx4	a2, a2, a8
4037c742:	002222        	l32i	a2, a2, 0
4037c745:	d2cc      	bnez.n	a2, 4037c756 <xTaskGetIdleTaskHandleForCore+0x32>
4037c747:	e1afd1        	l32r	a13, 40374e04 <_iram_text_start+0xa00> (3c0238e8 <_flash_rodata_start+0x37c8>)
4037c74a:	e1adc1        	l32r	a12, 40374e00 <_iram_text_start+0x9fc> (3c0270f8 <__func__$3>)
4037c74d:	c5a1b2        	movi	a11, 0x1c5
4037c750:	e19da1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c753:	035d65        	call8	4037fd28 <__assert_func>
        return xIdleTaskHandle[ xCoreID ];
    }
4037c756:	f01d      	retw.n

4037c758 <xTaskGetCurrentTaskHandleForCore>:
/*----------------------------------------------------------*/

#if ( ( !CONFIG_FREERTOS_SMP ) && ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) )

    TaskHandle_t xTaskGetCurrentTaskHandleForCore( BaseType_t xCoreID )
    {
4037c758:	004136        	entry	a1, 32
        TaskHandle_t xReturn;

        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE );
4037c75b:	01a082        	movi	a8, 1
4037c75e:	0eb827        	bgeu	a8, a2, 4037c770 <xTaskGetCurrentTaskHandleForCore+0x18>
4037c761:	e1a6d1        	l32r	a13, 40374dfc <_iram_text_start+0x9f8> (3c023858 <_flash_rodata_start+0x3738>)
4037c764:	e1a9c1        	l32r	a12, 40374e08 <_iram_text_start+0xa04> (3c0270d4 <__func__$2>)
4037c767:	d2a1b2        	movi	a11, 0x1d2
4037c76a:	e196a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0> (3c0236f8 <_flash_rodata_start+0x35d8>)
4037c76d:	035ba5        	call8	4037fd28 <__assert_func>
        #else /* CONFIG_FREERTOS_SMP */
        {
            /* A critical section is not required as this function does not
             * guarantee that the TCB will still be valid when this function
             * returns. */
            xReturn = pxCurrentTCBs[ xCoreID ];
4037c770:	e12281        	l32r	a8, 40374bf8 <_iram_text_start+0x7f4> (3fc95250 <pxCurrentTCBs>)
4037c773:	a02280        	addx4	a2, a2, a8
4037c776:	0020c0        	memw
4037c779:	002222        	l32i	a2, a2, 0
        }
        #endif /* CONFIG_FREERTOS_SMP */

        return xReturn;
    }
4037c77c:	000090        	retw
	...

4037c780 <__getreent>:
 * - If FreeRTOS is not running, it will return the global reent struct
 *
 * @return Pointer to a the (current taks's)/(global) reent struct
 */
    struct _reent * __getreent( void )
    {
4037c780:	004136        	entry	a1, 32
        /* No lock needed because if this changes, we won't be running anymore. */
        TCB_t * pxCurTask = ( TCB_t * ) xTaskGetCurrentTaskHandle();
4037c783:	feff65        	call8	4037b778 <xTaskGetCurrentTaskHandle>
        struct _reent * ret;

        if( pxCurTask == NULL )
4037c786:	7a8c      	beqz.n	a10, 4037c791 <__getreent+0x11>
            ret = _GLOBAL_REENT;
        }
        else
        {
            /* We have a currently executing task. Return its reentrant struct. */
            ret = &pxCurTask->xTLSBlock;
4037c788:	5cca22        	addi	a2, a10, 92
4037c78b:	000146        	j	4037c794 <__getreent+0x14>
4037c78e:	000000        	ill
            ret = _GLOBAL_REENT;
4037c791:	e19e21        	l32r	a2, 40374e0c <_iram_text_start+0xa08> (3fc92ab4 <_impure_data>)
        }

        return ret;
    }
4037c794:	f01d      	retw.n
	...

4037c798 <vTaskGetSnapshot>:
}
/*----------------------------------------------------------*/

BaseType_t vTaskGetSnapshot( TaskHandle_t pxTask,
                             TaskSnapshot_t * pxTaskSnapshot )
{
4037c798:	004136        	entry	a1, 32
    ESP_STATIC_ANALYZER_CHECK(!pxTask, pdFALSE);

    if( ( portVALID_TCB_MEM( pxTask ) == false ) || ( pxTaskSnapshot == NULL ) )
4037c79b:	02ad      	mov.n	a10, a2
4037c79d:	fdcfa5        	call8	4037a498 <xPortCheckValidTCBMem>
4037c7a0:	0a9c      	beqz.n	a10, 4037c7b4 <vTaskGetSnapshot+0x1c>
4037c7a2:	339c      	beqz.n	a3, 4037c7b9 <vTaskGetSnapshot+0x21>
    {
        return pdFALSE;
    }

    TCB_t * pxTCB = ( TCB_t * ) pxTask;
    pxTaskSnapshot->pxTCB = pxTCB;
4037c7a4:	0329      	s32i.n	a2, a3, 0
    pxTaskSnapshot->pxTopOfStack = ( StackType_t * ) pxTCB->pxTopOfStack;
4037c7a6:	0288      	l32i.n	a8, a2, 0
4037c7a8:	1389      	s32i.n	a8, a3, 4
    pxTaskSnapshot->pxEndOfStack = ( StackType_t * ) pxTCB->pxEndOfStack;
4037c7aa:	122282        	l32i	a8, a2, 72
4037c7ad:	2389      	s32i.n	a8, a3, 8
    return pdTRUE;
4037c7af:	120c      	movi.n	a2, 1
4037c7b1:	000186        	j	4037c7bb <vTaskGetSnapshot+0x23>
        return pdFALSE;
4037c7b4:	020c      	movi.n	a2, 0
4037c7b6:	000046        	j	4037c7bb <vTaskGetSnapshot+0x23>
4037c7b9:	020c      	movi.n	a2, 0
}
4037c7bb:	f01d      	retw.n
4037c7bd:	000000        	ill

4037c7c0 <xTimerCreateTimerTask>:
    {
4037c7c0:	004136        	entry	a1, 32
    }
4037c7c3:	120c      	movi.n	a2, 1
4037c7c5:	f01d      	retw.n
	...

4037c7c8 <s_cache_hal_init_ctx>:

static cache_hal_context_t ctx;


void s_cache_hal_init_ctx(void)
{
4037c7c8:	004136        	entry	a1, 32
    if (REG_GET_BIT(EXTMEM_DCACHE_AUTOLOAD_CTRL_REG, EXTMEM_DCACHE_AUTOLOAD_ENA)) {
4037c7cb:	e19181        	l32r	a8, 40374e10 <_iram_text_start+0xa0c> (600c404c <SYSTEM+0x404c>)
4037c7ce:	0020c0        	memw
4037c7d1:	0888      	l32i.n	a8, a8, 0
4037c7d3:	05e827        	bbsi	a8, 2, 4037c7dc <s_cache_hal_init_ctx+0x14>
    bool enabled = false;
4037c7d6:	090c      	movi.n	a9, 0
4037c7d8:	000086        	j	4037c7de <s_cache_hal_init_ctx+0x16>
4037c7db:	00          	.byte	00
        enabled = true;
4037c7dc:	190c      	movi.n	a9, 1
    ctx.l1.d_autoload_en = cache_ll_is_cache_autoload_enabled(1, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
4037c7de:	e18d81        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c7e1:	014892        	s8i	a9, a8, 1
    if (REG_GET_BIT(EXTMEM_ICACHE_AUTOLOAD_CTRL_REG, EXTMEM_ICACHE_AUTOLOAD_ENA)) {
4037c7e4:	e18d81        	l32r	a8, 40374e18 <_iram_text_start+0xa14> (600c40a0 <SYSTEM+0x40a0>)
4037c7e7:	0020c0        	memw
4037c7ea:	0888      	l32i.n	a8, a8, 0
4037c7ec:	04e827        	bbsi	a8, 2, 4037c7f4 <s_cache_hal_init_ctx+0x2c>
    bool enabled = false;
4037c7ef:	090c      	movi.n	a9, 0
4037c7f1:	000046        	j	4037c7f6 <s_cache_hal_init_ctx+0x2e>
        enabled = true;
4037c7f4:	190c      	movi.n	a9, 1
    ctx.l1.i_autoload_en = cache_ll_is_cache_autoload_enabled(1, CACHE_TYPE_INSTRUCTION, CACHE_LL_ID_ALL);
4037c7f6:	e18781        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c7f9:	004892        	s8i	a9, a8, 0
    if (REG_GET_BIT(EXTMEM_DCACHE_AUTOLOAD_CTRL_REG, EXTMEM_DCACHE_AUTOLOAD_ENA)) {
4037c7fc:	e18581        	l32r	a8, 40374e10 <_iram_text_start+0xa0c> (600c404c <SYSTEM+0x404c>)
4037c7ff:	0020c0        	memw
4037c802:	0888      	l32i.n	a8, a8, 0
4037c804:	04e827        	bbsi	a8, 2, 4037c80c <s_cache_hal_init_ctx+0x44>
    bool enabled = false;
4037c807:	090c      	movi.n	a9, 0
4037c809:	000046        	j	4037c80e <s_cache_hal_init_ctx+0x46>
        enabled = true;
4037c80c:	190c      	movi.n	a9, 1
    ctx.l2.d_autoload_en = cache_ll_is_cache_autoload_enabled(2, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);
4037c80e:	e18181        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c811:	034892        	s8i	a9, a8, 3
    if (REG_GET_BIT(EXTMEM_ICACHE_AUTOLOAD_CTRL_REG, EXTMEM_ICACHE_AUTOLOAD_ENA)) {
4037c814:	e18181        	l32r	a8, 40374e18 <_iram_text_start+0xa14> (600c40a0 <SYSTEM+0x40a0>)
4037c817:	0020c0        	memw
4037c81a:	0888      	l32i.n	a8, a8, 0
4037c81c:	04e827        	bbsi	a8, 2, 4037c824 <s_cache_hal_init_ctx+0x5c>
    bool enabled = false;
4037c81f:	090c      	movi.n	a9, 0
4037c821:	000046        	j	4037c826 <s_cache_hal_init_ctx+0x5e>
        enabled = true;
4037c824:	190c      	movi.n	a9, 1
    ctx.l2.i_autoload_en = cache_ll_is_cache_autoload_enabled(2, CACHE_TYPE_INSTRUCTION, CACHE_LL_ID_ALL);
4037c826:	e17b81        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c829:	024892        	s8i	a9, a8, 2
}
4037c82c:	f01d      	retw.n
	...

4037c830 <cache_hal_init>:

void cache_hal_init(void)
{
4037c830:	004136        	entry	a1, 32
    s_cache_hal_init_ctx();
4037c833:	fff965        	call8	4037c7c8 <s_cache_hal_init_ctx>

    if (CACHE_LL_LEVEL_EXT_MEM == 1) {
        cache_ll_enable_cache(1, CACHE_TYPE_ALL, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c836:	e17781        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c839:	000892        	l8ui	a9, a8, 0
4037c83c:	010872        	l8ui	a7, a8, 1
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c83f:	698c      	beqz.n	a9, 4037c849 <cache_hal_init+0x19>
4037c841:	4a0c      	movi.n	a10, 4
4037c843:	000106        	j	4037c84b <cache_hal_init+0x1b>
4037c846:	000000        	ill
4037c849:	0a0c      	movi.n	a10, 0
4037c84b:	e17481        	l32r	a8, 40374e1c <_iram_text_start+0xa18> (40001878 <Cache_Enable_ICache>)
4037c84e:	0008e0        	callx8	a8
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c851:	378c      	beqz.n	a7, 4037c858 <cache_hal_init+0x28>
4037c853:	4a0c      	movi.n	a10, 4
4037c855:	000046        	j	4037c85a <cache_hal_init+0x2a>
4037c858:	0a0c      	movi.n	a10, 0
4037c85a:	e17181        	l32r	a8, 40374e20 <_iram_text_start+0xa1c> (40001890 <Cache_Enable_DCache>)
4037c85d:	0008e0        	callx8	a8
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c860:	defb91        	l32r	a9, 4037444c <_iram_text_start+0x48> (600c4064 <SYSTEM+0x4064>)
4037c863:	0020c0        	memw
4037c866:	0988      	l32i.n	a8, a9, 0
4037c868:	0020c0        	memw
4037c86b:	0989      	s32i.n	a8, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c86d:	def881        	l32r	a8, 40374450 <_iram_text_start+0x4c> (600c4004 <SYSTEM+0x4004>)
4037c870:	0020c0        	memw
4037c873:	08a8      	l32i.n	a10, a8, 0
4037c875:	db7c      	movi.n	a11, -3
4037c877:	10aab0        	and	a10, a10, a11
4037c87a:	0020c0        	memw
4037c87d:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c87f:	0020c0        	memw
4037c882:	09a8      	l32i.n	a10, a9, 0
4037c884:	ec7c      	movi.n	a12, -2
4037c886:	10aac0        	and	a10, a10, a12
4037c889:	0020c0        	memw
4037c88c:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c88e:	0020c0        	memw
4037c891:	08a8      	l32i.n	a10, a8, 0
4037c893:	0020c0        	memw
4037c896:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c898:	0020c0        	memw
4037c89b:	09a8      	l32i.n	a10, a9, 0
4037c89d:	0020c0        	memw
4037c8a0:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c8a2:	0020c0        	memw
4037c8a5:	08a8      	l32i.n	a10, a8, 0
4037c8a7:	10aac0        	and	a10, a10, a12
4037c8aa:	0020c0        	memw
4037c8ad:	08a9      	s32i.n	a10, a8, 0
    REG_CLR_BIT(EXTMEM_ICACHE_CTRL1_REG, ibus_mask);
4037c8af:	0020c0        	memw
4037c8b2:	09a8      	l32i.n	a10, a9, 0
4037c8b4:	10aab0        	and	a10, a10, a11
4037c8b7:	0020c0        	memw
4037c8ba:	09a9      	s32i.n	a10, a9, 0
    REG_CLR_BIT(EXTMEM_DCACHE_CTRL1_REG, dbus_mask);
4037c8bc:	0020c0        	memw
4037c8bf:	0898      	l32i.n	a9, a8, 0
4037c8c1:	0020c0        	memw
4037c8c4:	0899      	s32i.n	a9, a8, 0
    ctx.l1.i_cache_enabled = 1;
    ctx.l1.d_cache_enabled = 1;
    ctx.l2.i_cache_enabled = 1;
    ctx.l2.d_cache_enabled = 1;
#endif
}
4037c8c6:	f01d      	retw.n

4037c8c8 <cache_hal_disable>:
    return enabled;
}
#endif  //#if CACHE_LL_ENABLE_DISABLE_STATE_SW

void cache_hal_disable(uint32_t cache_level, cache_type_t type)
{
4037c8c8:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c8cb:	0e1226        	beqi	a2, 1, 4037c8dd <cache_hal_disable+0x15>
4037c8ce:	e155d1        	l32r	a13, 40374e24 <_iram_text_start+0xa20> (3fc93c18 <__func__$0+0x2c>)
4037c8d1:	e155c1        	l32r	a12, 40374e28 <_iram_text_start+0xa24> (3fc945ec <__func__$9>)
4037c8d4:	aca0b2        	movi	a11, 172
4037c8d7:	e155a1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037c8da:	0344e5        	call8	4037fd28 <__assert_func>
    switch (type)
4037c8dd:	00b316        	beqz	a3, 4037c8ec <cache_hal_disable+0x24>
4037c8e0:	111366        	bnei	a3, 1, 4037c8f5 <cache_hal_disable+0x2d>
    Cache_Disable_ICache();
4037c8e3:	df2581        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
4037c8e6:	0008e0        	callx8	a8
}
4037c8e9:	000506        	j	4037c901 <cache_hal_disable+0x39>
    Cache_Disable_DCache();
4037c8ec:	df2481        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
4037c8ef:	0008e0        	callx8	a8
}
4037c8f2:	0002c6        	j	4037c901 <cache_hal_disable+0x39>
    Cache_Disable_ICache();
4037c8f5:	df2081        	l32r	a8, 40374578 <_iram_text_start+0x174> (4000186c <Cache_Disable_ICache>)
4037c8f8:	0008e0        	callx8	a8
    Cache_Disable_DCache();
4037c8fb:	df2081        	l32r	a8, 4037457c <_iram_text_start+0x178> (40001884 <Cache_Disable_DCache>)
4037c8fe:	0008e0        	callx8	a8
    cache_ll_disable_cache(cache_level, type, CACHE_LL_ID_ALL);

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, false);
#endif
}
4037c901:	f01d      	retw.n
	...

4037c904 <cache_hal_enable>:

void cache_hal_enable(uint32_t cache_level, cache_type_t type)
{
4037c904:	004136        	entry	a1, 32
4037c907:	20a330        	or	a10, a3, a3
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c90a:	0e1226        	beqi	a2, 1, 4037c91c <cache_hal_enable+0x18>
4037c90d:	e145d1        	l32r	a13, 40374e24 <_iram_text_start+0xa20> (3fc93c18 <__func__$0+0x2c>)
4037c910:	e148c1        	l32r	a12, 40374e30 <_iram_text_start+0xa2c> (3fc945d8 <__func__$8>)
4037c913:	b7a0b2        	movi	a11, 183
4037c916:	e145a1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037c919:	0340e5        	call8	4037fd28 <__assert_func>

    if (cache_level == 1) {
        cache_ll_enable_cache(1, type, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c91c:	e13e81        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c91f:	000892        	l8ui	a9, a8, 0
4037c922:	010832        	l8ui	a3, a8, 1
    switch (type)
4037c925:	017a16        	beqz	a10, 4037c940 <cache_hal_enable+0x3c>
4037c928:	211a66        	bnei	a10, 1, 4037c94d <cache_hal_enable+0x49>
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c92b:	005916        	beqz	a9, 4037c934 <cache_hal_enable+0x30>
4037c92e:	4a0c      	movi.n	a10, 4
4037c930:	000086        	j	4037c936 <cache_hal_enable+0x32>
4037c933:	0a0c00        	add.s	f0, f12, f0
4037c936:	e13981        	l32r	a8, 40374e1c <_iram_text_start+0xa18> (40001878 <Cache_Enable_ICache>)
4037c939:	0008e0        	callx8	a8
}
4037c93c:	000b06        	j	4037c96c <cache_hal_enable+0x68>
4037c93f:	00          	.byte	00
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c940:	038c      	beqz.n	a3, 4037c944 <cache_hal_enable+0x40>
4037c942:	4a0c      	movi.n	a10, 4
4037c944:	e13781        	l32r	a8, 40374e20 <_iram_text_start+0xa1c> (40001890 <Cache_Enable_DCache>)
4037c947:	0008e0        	callx8	a8
}
4037c94a:	000786        	j	4037c96c <cache_hal_enable+0x68>
    Cache_Enable_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c94d:	398c      	beqz.n	a9, 4037c954 <cache_hal_enable+0x50>
4037c94f:	4a0c      	movi.n	a10, 4
4037c951:	000046        	j	4037c956 <cache_hal_enable+0x52>
4037c954:	0a0c      	movi.n	a10, 0
4037c956:	e13181        	l32r	a8, 40374e1c <_iram_text_start+0xa18> (40001878 <Cache_Enable_ICache>)
4037c959:	0008e0        	callx8	a8
    Cache_Enable_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c95c:	438c      	beqz.n	a3, 4037c964 <cache_hal_enable+0x60>
4037c95e:	4a0c      	movi.n	a10, 4
4037c960:	000086        	j	4037c966 <cache_hal_enable+0x62>
4037c963:	0a0c00        	add.s	f0, f12, f0
4037c966:	e12e81        	l32r	a8, 40374e20 <_iram_text_start+0xa1c> (40001890 <Cache_Enable_DCache>)
4037c969:	0008e0        	callx8	a8
    }

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, true);
#endif
}
4037c96c:	f01d      	retw.n
	...

4037c970 <cache_hal_suspend>:

void cache_hal_suspend(uint32_t cache_level, cache_type_t type)
{
4037c970:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c973:	0e1226        	beqi	a2, 1, 4037c985 <cache_hal_suspend+0x15>
4037c976:	e12bd1        	l32r	a13, 40374e24 <_iram_text_start+0xa20> (3fc93c18 <__func__$0+0x2c>)
4037c979:	e12ec1        	l32r	a12, 40374e34 <_iram_text_start+0xa30> (3fc945c4 <__func__$7>)
4037c97c:	c6a0b2        	movi	a11, 198
4037c97f:	e12ba1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037c982:	033a65        	call8	4037fd28 <__assert_func>
    switch (type)
4037c985:	00b316        	beqz	a3, 4037c994 <cache_hal_suspend+0x24>
4037c988:	111366        	bnei	a3, 1, 4037c99d <cache_hal_suspend+0x2d>
    Cache_Suspend_ICache();
4037c98b:	fcb165        	call8	403794a0 <Cache_Suspend_ICache>
}
4037c98e:	000446        	j	4037c9a3 <cache_hal_suspend+0x33>
4037c991:	000000        	ill
    Cache_Suspend_DCache();
4037c994:	fcb265        	call8	403794bc <Cache_Suspend_DCache>
}
4037c997:	000206        	j	4037c9a3 <cache_hal_suspend+0x33>
4037c99a:	000000        	ill
    Cache_Suspend_ICache();
4037c99d:	fcb025        	call8	403794a0 <Cache_Suspend_ICache>
    Cache_Suspend_DCache();
4037c9a0:	fcb1a5        	call8	403794bc <Cache_Suspend_DCache>
    cache_ll_suspend_cache(cache_level, type, CACHE_LL_ID_ALL);

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, false);
#endif
}
4037c9a3:	f01d      	retw.n
4037c9a5:	000000        	ill

4037c9a8 <cache_hal_resume>:

void cache_hal_resume(uint32_t cache_level, cache_type_t type)
{
4037c9a8:	004136        	entry	a1, 32
4037c9ab:	20a330        	or	a10, a3, a3
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037c9ae:	0e1226        	beqi	a2, 1, 4037c9c0 <cache_hal_resume+0x18>
4037c9b1:	e11cd1        	l32r	a13, 40374e24 <_iram_text_start+0xa20> (3fc93c18 <__func__$0+0x2c>)
4037c9b4:	e121c1        	l32r	a12, 40374e38 <_iram_text_start+0xa34> (3fc945b0 <__func__$6>)
4037c9b7:	d1a0b2        	movi	a11, 209
4037c9ba:	e11ca1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037c9bd:	0336a5        	call8	4037fd28 <__assert_func>

    if (cache_level == 1) {
        cache_ll_resume_cache(1, type, CACHE_LL_ID_ALL, ctx.l1.i_autoload_en, ctx.l1.d_autoload_en);
4037c9c0:	e11581        	l32r	a8, 40374e14 <_iram_text_start+0xa10> (3fc94e1c <ctx>)
4037c9c3:	000892        	l8ui	a9, a8, 0
4037c9c6:	010832        	l8ui	a3, a8, 1
    switch (type)
4037c9c9:	016a16        	beqz	a10, 4037c9e3 <cache_hal_resume+0x3b>
4037c9cc:	211a66        	bnei	a10, 1, 4037c9f1 <cache_hal_resume+0x49>
    Cache_Resume_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c9cf:	005916        	beqz	a9, 4037c9d8 <cache_hal_resume+0x30>
4037c9d2:	4a0c      	movi.n	a10, 4
4037c9d4:	000086        	j	4037c9da <cache_hal_resume+0x32>
4037c9d7:	0a0c00        	add.s	f0, f12, f0
4037c9da:	e11881        	l32r	a8, 40374e3c <_iram_text_start+0xa38> (400018a8 <Cache_Resume_ICache>)
4037c9dd:	0008e0        	callx8	a8
}
4037c9e0:	000b06        	j	4037ca10 <cache_hal_resume+0x68>
    Cache_Resume_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037c9e3:	001316        	beqz	a3, 4037c9e8 <cache_hal_resume+0x40>
4037c9e6:	4a0c      	movi.n	a10, 4
4037c9e8:	deb781        	l32r	a8, 403744c4 <_iram_text_start+0xc0> (400018c0 <Cache_Resume_DCache>)
4037c9eb:	0008e0        	callx8	a8
}
4037c9ee:	000786        	j	4037ca10 <cache_hal_resume+0x68>
    Cache_Resume_ICache(inst_autoload_en ? CACHE_LL_L1_ICACHE_AUTOLOAD : 0);
4037c9f1:	398c      	beqz.n	a9, 4037c9f8 <cache_hal_resume+0x50>
4037c9f3:	4a0c      	movi.n	a10, 4
4037c9f5:	000046        	j	4037c9fa <cache_hal_resume+0x52>
4037c9f8:	0a0c      	movi.n	a10, 0
4037c9fa:	e11081        	l32r	a8, 40374e3c <_iram_text_start+0xa38> (400018a8 <Cache_Resume_ICache>)
4037c9fd:	0008e0        	callx8	a8
    Cache_Resume_DCache(data_autoload_en ? CACHE_LL_L1_DCACHE_AUTOLOAD : 0);
4037ca00:	438c      	beqz.n	a3, 4037ca08 <cache_hal_resume+0x60>
4037ca02:	4a0c      	movi.n	a10, 4
4037ca04:	000086        	j	4037ca0a <cache_hal_resume+0x62>
4037ca07:	0a0c00        	add.s	f0, f12, f0
4037ca0a:	deae81        	l32r	a8, 403744c4 <_iram_text_start+0xc0> (400018c0 <Cache_Resume_DCache>)
4037ca0d:	0008e0        	callx8	a8
    }

#if CACHE_LL_ENABLE_DISABLE_STATE_SW
    s_update_cache_state(cache_level, type, true);
#endif
}
4037ca10:	f01d      	retw.n
	...

4037ca14 <cache_hal_is_cache_enabled>:

bool cache_hal_is_cache_enabled(uint32_t cache_level, cache_type_t type)
{
4037ca14:	004136        	entry	a1, 32
    switch (type)
4037ca17:	538c      	beqz.n	a3, 4037ca20 <cache_hal_is_cache_enabled+0xc>
4037ca19:	131326        	beqi	a3, 1, 4037ca30 <cache_hal_is_cache_enabled+0x1c>
4037ca1c:	000786        	j	4037ca3e <cache_hal_is_cache_enabled+0x2a>
4037ca1f:	088100        	lsx	f8, a1, a0
    return REG_GET_BIT(EXTMEM_DCACHE_CTRL_REG, EXTMEM_DCACHE_ENABLE);
4037ca22:	20c0e1        	l32r	a14, 40344d24 <rom_rx_gain_force+0x33e8f8>
4037ca25:	082800        	lsx	f2, a8, a0
4037ca28:	042020        	extui	a2, a2, 0, 1
        break;
4037ca2b:	000c46        	j	4037ca60 <cache_hal_is_cache_enabled+0x4c>
4037ca2e:	810000        	src	a0, a0, a0
    return REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE);
4037ca31:	c0e105        	call0	4033d844 <rom_rx_gain_force+0x337418>
4037ca34:	20          	.byte	0x20
4037ca35:	082800        	lsx	f2, a8, a0
4037ca38:	042020        	extui	a2, a2, 0, 1
        break;
4037ca3b:	000846        	j	4037ca60 <cache_hal_is_cache_enabled+0x4c>
    return REG_GET_BIT(EXTMEM_DCACHE_CTRL_REG, EXTMEM_DCACHE_ENABLE);
4037ca3e:	e10081        	l32r	a8, 40374e40 <_iram_text_start+0xa3c> (600c4000 <SYSTEM+0x4000>)
4037ca41:	0020c0        	memw
4037ca44:	0888      	l32i.n	a8, a8, 0
        enabled = cache_ll_l1_is_dcache_enabled(0) && cache_ll_l1_is_icache_enabled(0);
4037ca46:	0f6807        	bbci	a8, 0, 4037ca59 <cache_hal_is_cache_enabled+0x45>
    return REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE);
4037ca49:	e0fe81        	l32r	a8, 40374e44 <_iram_text_start+0xa40> (600c4060 <SYSTEM+0x4060>)
4037ca4c:	0020c0        	memw
4037ca4f:	0888      	l32i.n	a8, a8, 0
        enabled = cache_ll_l1_is_dcache_enabled(0) && cache_ll_l1_is_icache_enabled(0);
4037ca51:	096807        	bbci	a8, 0, 4037ca5e <cache_hal_is_cache_enabled+0x4a>
4037ca54:	120c      	movi.n	a2, 1
4037ca56:	000186        	j	4037ca60 <cache_hal_is_cache_enabled+0x4c>
4037ca59:	020c      	movi.n	a2, 0
4037ca5b:	000046        	j	4037ca60 <cache_hal_is_cache_enabled+0x4c>
4037ca5e:	020c      	movi.n	a2, 0
    enabled = s_get_cache_state(cache_level, type);
#else
    enabled = cache_ll_is_cache_enabled(type);
#endif //CACHE_LL_ENABLE_DISABLE_STATE_SW
    return enabled;
}
4037ca60:	f01d      	retw.n
	...

4037ca64 <cache_hal_vaddr_to_cache_level_id>:

bool cache_hal_vaddr_to_cache_level_id(uint32_t vaddr_start, uint32_t len, uint32_t *out_level, uint32_t *out_id)
{
4037ca64:	004136        	entry	a1, 32
    if (!out_level || !out_id) {
4037ca67:	40f480        	nsau	a8, a4
4037ca6a:	418580        	srli	a8, a8, 5
4037ca6d:	40f590        	nsau	a9, a5
4037ca70:	419590        	srli	a9, a9, 5
4037ca73:	208890        	or	a8, a8, a9
4037ca76:	054856        	bnez	a8, 4037cace <cache_hal_vaddr_to_cache_level_id+0x6a>
 */
__attribute__((always_inline))
static inline bool cache_ll_vaddr_to_cache_level_id(uint32_t vaddr_start, uint32_t len, uint32_t *out_level, uint32_t *out_id)
{
    bool valid = false;
    uint32_t vaddr_end = vaddr_start + len - 1;
4037ca79:	323a      	add.n	a3, a2, a3

    valid |= (SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_end));
4037ca7b:	df8f81        	l32r	a8, 403748b8 <_iram_text_start+0x4b4> (be000000 <_rtc_reserved_end+0x5df00000>)
4037ca7e:	828a      	add.n	a8, a2, a8
4037ca80:	df0691        	l32r	a9, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037ca83:	0c3987        	bltu	a9, a8, 4037ca93 <cache_hal_vaddr_to_cache_level_id+0x2f>
4037ca86:	e0f081        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (bdffffff <_rtc_reserved_end+0x5defffff>)
4037ca89:	838a      	add.n	a8, a3, a8
4037ca8b:	09b987        	bgeu	a9, a8, 4037ca98 <cache_hal_vaddr_to_cache_level_id+0x34>
4037ca8e:	080c      	movi.n	a8, 0
4037ca90:	000186        	j	4037ca9a <cache_hal_vaddr_to_cache_level_id+0x36>
4037ca93:	080c      	movi.n	a8, 0
4037ca95:	000046        	j	4037ca9a <cache_hal_vaddr_to_cache_level_id+0x36>
4037ca98:	180c      	movi.n	a8, 1
    valid |= (SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_end));
4037ca9a:	e0ec91        	l32r	a9, 40374e4c <_iram_text_start+0xa48> (c4000000 <_rtc_reserved_end+0x63f00000>)
4037ca9d:	229a      	add.n	a2, a2, a9
4037ca9f:	defe91        	l32r	a9, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037caa2:	0f3927        	bltu	a9, a2, 4037cab5 <cache_hal_vaddr_to_cache_level_id+0x51>
4037caa5:	e0ea91        	l32r	a9, 40374e50 <_iram_text_start+0xa4c> (c3ffffff <_rtc_reserved_end+0x63efffff>)
4037caa8:	339a      	add.n	a3, a3, a9
4037caaa:	defb91        	l32r	a9, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037caad:	09b937        	bgeu	a9, a3, 4037caba <cache_hal_vaddr_to_cache_level_id+0x56>
4037cab0:	090c      	movi.n	a9, 0
4037cab2:	000186        	j	4037cabc <cache_hal_vaddr_to_cache_level_id+0x58>
4037cab5:	090c      	movi.n	a9, 0
4037cab7:	000046        	j	4037cabc <cache_hal_vaddr_to_cache_level_id+0x58>
4037caba:	190c      	movi.n	a9, 1
4037cabc:	208890        	or	a8, a8, a9
4037cabf:	082d      	mov.n	a2, a8

    if (valid) {
4037cac1:	b88c      	beqz.n	a8, 4037cad0 <cache_hal_vaddr_to_cache_level_id+0x6c>
        *out_level = 1;
4037cac3:	180c      	movi.n	a8, 1
4037cac5:	0489      	s32i.n	a8, a4, 0
        *out_id = 0;
4037cac7:	080c      	movi.n	a8, 0
4037cac9:	0589      	s32i.n	a8, a5, 0
4037cacb:	000046        	j	4037cad0 <cache_hal_vaddr_to_cache_level_id+0x6c>
        return false;
4037cace:	020c      	movi.n	a2, 0
    }
    return cache_ll_vaddr_to_cache_level_id(vaddr_start, len, out_level, out_id);
}
4037cad0:	f01d      	retw.n
	...

4037cad4 <cache_hal_invalidate_addr>:

bool cache_hal_invalidate_addr(uint32_t vaddr, uint32_t size)
{
4037cad4:	006136        	entry	a1, 48
4037cad7:	027d      	mov.n	a7, a2
    bool valid = false;
    uint32_t cache_level = 0;
4037cad9:	080c      	movi.n	a8, 0
4037cadb:	0189      	s32i.n	a8, a1, 0
    uint32_t cache_id = 0;
4037cadd:	1189      	s32i.n	a8, a1, 4

    valid = cache_hal_vaddr_to_cache_level_id(vaddr, size, &cache_level, &cache_id);
4037cadf:	d14b      	addi.n	a13, a1, 4
4037cae1:	01cd      	mov.n	a12, a1
4037cae3:	03bd      	mov.n	a11, a3
4037cae5:	02ad      	mov.n	a10, a2
4037cae7:	fff7e5        	call8	4037ca64 <cache_hal_vaddr_to_cache_level_id>
4037caea:	0a2d      	mov.n	a2, a10
    if (valid) {
4037caec:	8a8c      	beqz.n	a10, 4037caf8 <cache_hal_invalidate_addr+0x24>
    Cache_Invalidate_Addr(vaddr, size);
4037caee:	03bd      	mov.n	a11, a3
4037caf0:	07ad      	mov.n	a10, a7
4037caf2:	e0d881        	l32r	a8, 40374e54 <_iram_text_start+0xa50> (400016b0 <Cache_Invalidate_Addr>)
4037caf5:	0008e0        	callx8	a8
        cache_ll_invalidate_addr(cache_level, CACHE_TYPE_ALL, cache_id, vaddr, size);
    }

    return valid;
}
4037caf8:	f01d      	retw.n
	...

4037cafc <cache_hal_freeze>:
}
#endif  //#if SOC_CACHE_WRITEBACK_SUPPORTED

#if SOC_CACHE_FREEZE_SUPPORTED
void cache_hal_freeze(uint32_t cache_level, cache_type_t type)
{
4037cafc:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037caff:	0e1226        	beqi	a2, 1, 4037cb11 <cache_hal_freeze+0x15>
4037cb02:	e0c8d1        	l32r	a13, 40374e24 <_iram_text_start+0xa20> (3fc93c18 <__func__$0+0x2c>)
4037cb05:	e0d4c1        	l32r	a12, 40374e58 <_iram_text_start+0xa54> (3fc9459c <__func__$3>)
4037cb08:	12a1b2        	movi	a11, 0x112
4037cb0b:	e0c8a1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037cb0e:	0321a5        	call8	4037fd28 <__assert_func>
    switch (type)
4037cb11:	00b316        	beqz	a3, 4037cb20 <cache_hal_freeze+0x24>
4037cb14:	101366        	bnei	a3, 1, 4037cb28 <cache_hal_freeze+0x2c>
    Cache_Freeze_ICache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb17:	00a0a2        	movi	a10, 0
4037cb1a:	fc9c65        	call8	403794e0 <Cache_Freeze_ICache_Enable>
}
4037cb1d:	0004c6        	j	4037cb34 <cache_hal_freeze+0x38>
    Cache_Freeze_DCache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb20:	0a0c      	movi.n	a10, 0
4037cb22:	fc9da5        	call8	403794fc <Cache_Freeze_DCache_Enable>
}
4037cb25:	0002c6        	j	4037cb34 <cache_hal_freeze+0x38>
    Cache_Freeze_ICache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb28:	00a0a2        	movi	a10, 0
4037cb2b:	fc9b65        	call8	403794e0 <Cache_Freeze_ICache_Enable>
    Cache_Freeze_DCache_Enable(CACHE_FREEZE_ACK_BUSY);
4037cb2e:	00a0a2        	movi	a10, 0
4037cb31:	fc9ca5        	call8	403794fc <Cache_Freeze_DCache_Enable>

    cache_ll_freeze_cache(cache_level, type, CACHE_LL_ID_ALL);
}
4037cb34:	f01d      	retw.n
	...

4037cb38 <cache_hal_unfreeze>:

void cache_hal_unfreeze(uint32_t cache_level, cache_type_t type)
{
4037cb38:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level && (cache_level <= CACHE_LL_LEVEL_NUMS));
4037cb3b:	0e1226        	beqi	a2, 1, 4037cb4d <cache_hal_unfreeze+0x15>
4037cb3e:	e0b9d1        	l32r	a13, 40374e24 <_iram_text_start+0xa20> (3fc93c18 <__func__$0+0x2c>)
4037cb41:	e0c6c1        	l32r	a12, 40374e5c <_iram_text_start+0xa58> (3fc94588 <__func__$2>)
4037cb44:	19a1b2        	movi	a11, 0x119
4037cb47:	e0b9a1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037cb4a:	031de5        	call8	4037fd28 <__assert_func>
    switch (type)
4037cb4d:	d38c      	beqz.n	a3, 4037cb5e <cache_hal_unfreeze+0x26>
4037cb4f:	151366        	bnei	a3, 1, 4037cb68 <cache_hal_unfreeze+0x30>
    Cache_Freeze_ICache_Disable();
4037cb52:	e0c381        	l32r	a8, 40374e60 <_iram_text_start+0xa5c> (400018f0 <Cache_Freeze_ICache_Disable>)
4037cb55:	0008e0        	callx8	a8
}
4037cb58:	000606        	j	4037cb74 <cache_hal_unfreeze+0x3c>
4037cb5b:	000000        	ill
    Cache_Freeze_DCache_Disable();
4037cb5e:	e0c181        	l32r	a8, 40374e64 <_iram_text_start+0xa60> (40001908 <Cache_Freeze_DCache_Disable>)
4037cb61:	0008e0        	callx8	a8
}
4037cb64:	000306        	j	4037cb74 <cache_hal_unfreeze+0x3c>
4037cb67:	00          	.byte	00
    Cache_Freeze_ICache_Disable();
4037cb68:	e0be81        	l32r	a8, 40374e60 <_iram_text_start+0xa5c> (400018f0 <Cache_Freeze_ICache_Disable>)
4037cb6b:	0008e0        	callx8	a8
    Cache_Freeze_DCache_Disable();
4037cb6e:	e0bd81        	l32r	a8, 40374e64 <_iram_text_start+0xa60> (40001908 <Cache_Freeze_DCache_Disable>)
4037cb71:	0008e0        	callx8	a8

    cache_ll_unfreeze_cache(cache_level, type, CACHE_LL_ID_ALL);
}
4037cb74:	f01d      	retw.n
	...

4037cb78 <cache_hal_get_cache_line_size>:
#endif  //#if SOC_CACHE_FREEZE_SUPPORTED

uint32_t cache_hal_get_cache_line_size(uint32_t cache_level, cache_type_t type)
{
4037cb78:	004136        	entry	a1, 32
    HAL_ASSERT(cache_level <= CACHE_LL_LEVEL_NUMS);
4037cb7b:	01a082        	movi	a8, 1
4037cb7e:	0eb827        	bgeu	a8, a2, 4037cb90 <cache_hal_get_cache_line_size+0x18>
4037cb81:	e0b9d1        	l32r	a13, 40374e68 <_iram_text_start+0xa64> (3fc93c6c <__func__$0+0x80>)
4037cb84:	e0bac1        	l32r	a12, 40374e6c <_iram_text_start+0xa68> (3fc94568 <__func__$1>)
4037cb87:	21a1b2        	movi	a11, 0x121
4037cb8a:	e0a8a1        	l32r	a10, 40374e2c <_iram_text_start+0xa28> (3fc93c4c <__func__$0+0x60>)
4037cb8d:	0319a5        	call8	4037fd28 <__assert_func>
    uint32_t line_size = 0;

#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE
    line_size = cache_ll_get_line_size(cache_level, type, CACHE_LL_ID_ALL);
#else
    if (cache_level == CACHE_LL_LEVEL_EXT_MEM) {
4037cb90:	2b1266        	bnei	a2, 1, 4037cbbf <cache_hal_get_cache_line_size+0x47>
    switch (type)
4037cb93:	00e316        	beqz	a3, 4037cba5 <cache_hal_get_cache_line_size+0x2d>
4037cb96:	161366        	bnei	a3, 1, 4037cbb0 <cache_hal_get_cache_line_size+0x38>
    size = Cache_Get_ICache_Line_Size();
4037cb99:	e0b881        	l32r	a8, 40374e7c <_iram_text_start+0xa78> (400015fc <Cache_Get_ICache_Line_Size>)
4037cb9c:	0008e0        	callx8	a8
4037cb9f:	202aa0        	or	a2, a10, a10
        break;
4037cba2:	0006c6        	j	4037cbc1 <cache_hal_get_cache_line_size+0x49>
    size = Cache_Get_DCache_Line_Size();
4037cba5:	e0b681        	l32r	a8, 40374e80 <_iram_text_start+0xa7c> (40001608 <Cache_Get_DCache_Line_Size>)
4037cba8:	0008e0        	callx8	a8
4037cbab:	0a2d      	mov.n	a2, a10
        break;
4037cbad:	000406        	j	4037cbc1 <cache_hal_get_cache_line_size+0x49>
        HAL_ASSERT(false);
4037cbb0:	e0b0d1        	l32r	a13, 40374e70 <_iram_text_start+0xa6c> (3fc93c94 <__func__$0+0xa8>)
4037cbb3:	e0b0c1        	l32r	a12, 40374e74 <_iram_text_start+0xa70> (3fc94550 <__func__$0>)
4037cbb6:	1ca2b2        	movi	a11, 0x21c
4037cbb9:	e0afa1        	l32r	a10, 40374e78 <_iram_text_start+0xa74> (3fc93c9c <__func__$0+0xb0>)
4037cbbc:	0316a5        	call8	4037fd28 <__assert_func>
    uint32_t line_size = 0;
4037cbbf:	020c      	movi.n	a2, 0
        line_size = cache_ll_get_line_size(cache_level, type, CACHE_LL_ID_ALL);
    }
#endif

    return line_size;
}
4037cbc1:	f01d      	retw.n
	...

4037cbc4 <mmu_ll_check_entry_valid>:
 * @param entry_id MMU entry ID
 *
 * @return         True for MMU entry is valid; False for invalid
 */
static inline bool mmu_ll_check_entry_valid(uint32_t mmu_id, uint32_t entry_id)
{
4037cbc4:	004136        	entry	a1, 32
    (void)mmu_id;
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cbc7:	ffa182        	movi	a8, 0x1ff
4037cbca:	0eb837        	bgeu	a8, a3, 4037cbdc <mmu_ll_check_entry_valid+0x18>
4037cbcd:	e0add1        	l32r	a13, 40374e84 <_iram_text_start+0xa80> (3fc942ec <__func__$0+0x700>)
4037cbd0:	e0aec1        	l32r	a12, 40374e88 <_iram_text_start+0xa84> (3fc94650 <__func__$3>)
4037cbd3:	f0a0b2        	movi	a11, 240
4037cbd6:	e0ada1        	l32r	a10, 40374e8c <_iram_text_start+0xa88> (3fc9430c <__func__$0+0x720>)
4037cbd9:	0314e5        	call8	4037fd28 <__assert_func>

    return (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) & SOC_MMU_INVALID) ? false : true;
4037cbdc:	e0ad81        	l32r	a8, 40374e90 <_iram_text_start+0xa8c> (18031400 <UserFrameTotalSize+0x18031300>)
4037cbdf:	803380        	add	a3, a3, a8
4037cbe2:	1133e0        	slli	a3, a3, 2
4037cbe5:	002322        	l32i	a2, a3, 0
4037cbe8:	042e20        	extui	a2, a2, 14, 1
4037cbeb:	112220        	slli	a2, a2, 14
}
4037cbee:	40f220        	nsau	a2, a2
4037cbf1:	412520        	srli	a2, a2, 5
4037cbf4:	000090        	retw
	...

4037cbf8 <mmu_ll_get_entry_target>:
 * @param entry_id MMU entry ID
 *
 * @return         Target, see `mmu_target_t`
 */
static inline mmu_target_t mmu_ll_get_entry_target(uint32_t mmu_id, uint32_t entry_id)
{
4037cbf8:	004136        	entry	a1, 32
    (void)mmu_id;
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cbfb:	ffa182        	movi	a8, 0x1ff
4037cbfe:	0eb837        	bgeu	a8, a3, 4037cc10 <mmu_ll_get_entry_target+0x18>
4037cc01:	e0a0d1        	l32r	a13, 40374e84 <_iram_text_start+0xa80> (3fc942ec <__func__$0+0x700>)
4037cc04:	e0a4c1        	l32r	a12, 40374e94 <_iram_text_start+0xa90> (3fc94638 <__func__$2>)
4037cc07:	00a1b2        	movi	a11, 0x100
4037cc0a:	e0a0a1        	l32r	a10, 40374e8c <_iram_text_start+0xa88> (3fc9430c <__func__$0+0x720>)
4037cc0d:	0311a5        	call8	4037fd28 <__assert_func>

    bool target_code = (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4)) & SOC_MMU_TYPE;
4037cc10:	e0a081        	l32r	a8, 40374e90 <_iram_text_start+0xa8c> (18031400 <UserFrameTotalSize+0x18031300>)
4037cc13:	803380        	add	a3, a3, a8
4037cc16:	1133e0        	slli	a3, a3, 2
4037cc19:	002382        	l32i	a8, a3, 0
    return (target_code == SOC_MMU_ACCESS_FLASH) ? MMU_TARGET_FLASH0 : MMU_TARGET_PSRAM0;
4037cc1c:	05e8f7        	bbsi	a8, 15, 4037cc25 <mmu_ll_get_entry_target+0x2d>
4037cc1f:	01a022        	movi	a2, 1
4037cc22:	000046        	j	4037cc27 <mmu_ll_get_entry_target+0x2f>
4037cc25:	220c      	movi.n	a2, 2
}
4037cc27:	f01d      	retw.n
4037cc29:	000000        	ill

4037cc2c <mmu_ll_find_entry_id_based_on_map_value>:
 * @param target   physical memory target, see `mmu_target_t`
 *
 * @return         MMU entry ID, -1 for invalid
 */
static inline int mmu_ll_find_entry_id_based_on_map_value(uint32_t mmu_id, uint32_t mmu_val, mmu_target_t target)
{
4037cc2c:	004136        	entry	a1, 32
4037cc2f:	027d      	mov.n	a7, a2
    (void)mmu_id;
    for (int i = 0; i < SOC_MMU_ENTRY_NUM; i++) {
4037cc31:	020c      	movi.n	a2, 0
4037cc33:	0009c6        	j	4037cc5e <mmu_ll_find_entry_id_based_on_map_value+0x32>
        if (mmu_ll_check_entry_valid(mmu_id, i)) {
4037cc36:	20b220        	or	a11, a2, a2
4037cc39:	20a770        	or	a10, a7, a7
4037cc3c:	fff865        	call8	4037cbc4 <mmu_ll_check_entry_valid>
4037cc3f:	019a16        	beqz	a10, 4037cc5c <mmu_ll_find_entry_id_based_on_map_value+0x30>
            if (mmu_ll_get_entry_target(mmu_id, i) == target) {
4037cc42:	02bd      	mov.n	a11, a2
4037cc44:	07ad      	mov.n	a10, a7
4037cc46:	fffb25        	call8	4037cbf8 <mmu_ll_get_entry_target>
4037cc49:	0f9a47        	bne	a10, a4, 4037cc5c <mmu_ll_find_entry_id_based_on_map_value+0x30>
                if (((*(uint32_t *)(DR_REG_MMU_TABLE + i * 4)) & SOC_MMU_VALID_VAL_MASK) == mmu_val) {
4037cc4c:	e09181        	l32r	a8, 40374e90 <_iram_text_start+0xa8c> (18031400 <UserFrameTotalSize+0x18031300>)
4037cc4f:	828a      	add.n	a8, a2, a8
4037cc51:	1188e0        	slli	a8, a8, 2
4037cc54:	0888      	l32i.n	a8, a8, 0
4037cc56:	d48080        	extui	a8, a8, 0, 14
4037cc59:	091837        	beq	a8, a3, 4037cc66 <mmu_ll_find_entry_id_based_on_map_value+0x3a>
    for (int i = 0; i < SOC_MMU_ENTRY_NUM; i++) {
4037cc5c:	221b      	addi.n	a2, a2, 1
4037cc5e:	ffa182        	movi	a8, 0x1ff
4037cc61:	d1a827        	bge	a8, a2, 4037cc36 <mmu_ll_find_entry_id_based_on_map_value+0xa>
                }
            }
        }
    }

    return -1;
4037cc64:	f27c      	movi.n	a2, -1
}
4037cc66:	f01d      	retw.n

4037cc68 <mmu_ll_entry_id_to_paddr_base>:
{
4037cc68:	004136        	entry	a1, 32
    HAL_ASSERT(entry_id < SOC_MMU_ENTRY_NUM);
4037cc6b:	ffa182        	movi	a8, 0x1ff
4037cc6e:	0eb837        	bgeu	a8, a3, 4037cc80 <mmu_ll_entry_id_to_paddr_base+0x18>
4037cc71:	e084d1        	l32r	a13, 40374e84 <_iram_text_start+0xa80> (3fc942ec <__func__$0+0x700>)
4037cc74:	e089c1        	l32r	a12, 40374e98 <_iram_text_start+0xa94> (3fc94618 <__func__$1>)
4037cc77:	11a1b2        	movi	a11, 0x111
4037cc7a:	e084a1        	l32r	a10, 40374e8c <_iram_text_start+0xa88> (3fc9430c <__func__$0+0x720>)
4037cc7d:	030aa5        	call8	4037fd28 <__assert_func>
    return ((*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4)) & SOC_MMU_VALID_VAL_MASK) << 16;
4037cc80:	e08481        	l32r	a8, 40374e90 <_iram_text_start+0xa8c> (18031400 <UserFrameTotalSize+0x18031300>)
4037cc83:	803380        	add	a3, a3, a8
4037cc86:	1133e0        	slli	a3, a3, 2
4037cc89:	002322        	l32i	a2, a3, 0
4037cc8c:	112200        	slli	a2, a2, 16
}
4037cc8f:	d52020        	extui	a2, a2, 16, 14
4037cc92:	112200        	slli	a2, a2, 16
4037cc95:	000090        	retw

4037cc98 <mmu_hal_paddr_to_vaddr>:

    return true;
}

bool mmu_hal_paddr_to_vaddr(uint32_t mmu_id, uint32_t paddr, mmu_target_t target, mmu_vaddr_t type, uint32_t *out_vaddr)
{
4037cc98:	004136        	entry	a1, 32
4037cc9b:	20c440        	or	a12, a4, a4
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cc9e:	e07f81        	l32r	a8, 40374e9c <_iram_text_start+0xa98> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cca1:	0eb837        	bgeu	a8, a3, 4037ccb3 <mmu_hal_paddr_to_vaddr+0x1b>
    HAL_ASSERT(mmu_ll_check_valid_paddr_region(mmu_id, paddr, 1));
4037cca4:	e07fd1        	l32r	a13, 40374ea0 <_iram_text_start+0xa9c> (3fc94340 <__func__$0+0x754>)
4037cca7:	e07fc1        	l32r	a12, 40374ea4 <_iram_text_start+0xaa0> (3fc94600 <__func__$0>)
4037ccaa:	8da0b2        	movi	a11, 141
4037ccad:	e07ea1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037ccb0:	030765        	call8	4037fd28 <__assert_func>

    uint32_t mmu_val = mmu_ll_format_paddr(mmu_id, paddr, target);
    int entry_id = mmu_ll_find_entry_id_based_on_map_value(mmu_id, mmu_val, target);
4037ccb3:	f5b030        	extui	a11, a3, 16, 16
4037ccb6:	20a220        	or	a10, a2, a2
4037ccb9:	fff725        	call8	4037cc2c <mmu_ll_find_entry_id_based_on_map_value>
4037ccbc:	0a7d      	mov.n	a7, a10
    if (entry_id == -1) {
4037ccbe:	2a0a26        	beqi	a10, -1, 4037ccec <mmu_hal_paddr_to_vaddr+0x54>
        return false;
    }

    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ccc1:	1b0c      	movi.n	a11, 1
4037ccc3:	02ad      	mov.n	a10, a2
4037ccc5:	001fa5        	call8	4037cec0 <mmu_hal_pages_to_bytes>
    uint32_t offset = paddr % page_size_in_bytes;
4037ccc8:	e233a0        	remu	a3, a3, a10
 * @param type     virtual address type, could be instruction type or data type. See `mmu_vaddr_t`
 */
static inline uint32_t mmu_ll_entry_id_to_vaddr_base(uint32_t mmu_id, uint32_t entry_id, mmu_vaddr_t type)
{
    (void)mmu_id;
    uint32_t laddr = entry_id << 16;
4037cccb:	117700        	slli	a7, a7, 16
    if (vaddr_type == MMU_VADDR_DATA) {
4037ccce:	0a1526        	beqi	a5, 1, 4037ccdc <mmu_hal_paddr_to_vaddr+0x44>
    return vaddr_base | laddr;
4037ccd1:	e07681        	l32r	a8, 40374eac <_iram_text_start+0xaa8> (42000000 <_iram_bss_end+0x1c7dc00>)
4037ccd4:	207780        	or	a7, a7, a8
    uint32_t vaddr_base = mmu_ll_entry_id_to_vaddr_base(mmu_id, entry_id, type);
    if (vaddr_base == 0) {
4037ccd7:	0001c6        	j	4037cce2 <mmu_hal_paddr_to_vaddr+0x4a>
4037ccda:	810000        	src	a0, a0, a0
4037ccdd:	80e075        	call12	402fdae4 <rom_rx_gain_force+0x2f76b8>
4037cce0:	702077        	blt	a0, a7, 4037cd54 <mmu_hal_map_region+0xc>
        return false;
    }
    *out_vaddr = vaddr_base | offset;
4037cce3:	33          	.byte	0x33
4037cce4:	063920        	ee.ldf.64.xp	f3, f0, a2, a9

    return true;
4037cce7:	120c      	movi.n	a2, 1
4037cce9:	000046        	j	4037ccee <mmu_hal_paddr_to_vaddr+0x56>
        return false;
4037ccec:	020c      	movi.n	a2, 0
}
4037ccee:	f01d      	retw.n

4037ccf0 <mmu_hal_check_valid_ext_vaddr_region>:

bool mmu_hal_check_valid_ext_vaddr_region(uint32_t mmu_id, uint32_t vaddr_start, uint32_t len, mmu_vaddr_t type)
{
4037ccf0:	004136        	entry	a1, 32
    uint32_t vaddr_end = vaddr_start + len - 1;
4037ccf3:	434a      	add.n	a4, a3, a4
    if (type & MMU_VADDR_INSTRUCTION) {
4037ccf5:	216517        	bbci	a5, 1, 4037cd1a <mmu_hal_check_valid_ext_vaddr_region+0x2a>
        valid |= (SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_IRAM0_CACHE(vaddr_end));
4037ccf8:	def081        	l32r	a8, 403748b8 <_iram_text_start+0x4b4> (be000000 <_rtc_reserved_end+0x5df00000>)
4037ccfb:	838a      	add.n	a8, a3, a8
4037ccfd:	de6691        	l32r	a9, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cd00:	0c3987        	bltu	a9, a8, 4037cd10 <mmu_hal_check_valid_ext_vaddr_region+0x20>
4037cd03:	e05181        	l32r	a8, 40374e48 <_iram_text_start+0xa44> (bdffffff <_rtc_reserved_end+0x5defffff>)
4037cd06:	848a      	add.n	a8, a4, a8
4037cd08:	09b987        	bgeu	a9, a8, 4037cd15 <mmu_hal_check_valid_ext_vaddr_region+0x25>
4037cd0b:	020c      	movi.n	a2, 0
4037cd0d:	0002c6        	j	4037cd1c <mmu_hal_check_valid_ext_vaddr_region+0x2c>
4037cd10:	020c      	movi.n	a2, 0
4037cd12:	000186        	j	4037cd1c <mmu_hal_check_valid_ext_vaddr_region+0x2c>
4037cd15:	120c      	movi.n	a2, 1
4037cd17:	000046        	j	4037cd1c <mmu_hal_check_valid_ext_vaddr_region+0x2c>
    bool valid = false;
4037cd1a:	020c      	movi.n	a2, 0
    if (type & MMU_VADDR_DATA) {
4037cd1c:	256507        	bbci	a5, 0, 4037cd45 <mmu_hal_check_valid_ext_vaddr_region+0x55>
        valid |= (SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_start) && SOC_ADDRESS_IN_DRAM0_CACHE(vaddr_end));
4037cd1f:	e04b81        	l32r	a8, 40374e4c <_iram_text_start+0xa48> (c4000000 <_rtc_reserved_end+0x63f00000>)
4037cd22:	338a      	add.n	a3, a3, a8
4037cd24:	de5d81        	l32r	a8, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cd27:	0f3837        	bltu	a8, a3, 4037cd3a <mmu_hal_check_valid_ext_vaddr_region+0x4a>
4037cd2a:	e04981        	l32r	a8, 40374e50 <_iram_text_start+0xa4c> (c3ffffff <_rtc_reserved_end+0x63efffff>)
4037cd2d:	448a      	add.n	a4, a4, a8
4037cd2f:	de5a81        	l32r	a8, 40374698 <_iram_text_start+0x294> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4037cd32:	0ab847        	bgeu	a8, a4, 4037cd40 <mmu_hal_check_valid_ext_vaddr_region+0x50>
4037cd35:	080c      	movi.n	a8, 0
4037cd37:	0001c6        	j	4037cd42 <mmu_hal_check_valid_ext_vaddr_region+0x52>
4037cd3a:	080c      	movi.n	a8, 0
4037cd3c:	000086        	j	4037cd42 <mmu_hal_check_valid_ext_vaddr_region+0x52>
4037cd3f:	180c00        	lsxp	f0, a12, a0
4037cd42:	202280        	or	a2, a2, a8
    return mmu_ll_check_valid_ext_vaddr_region(mmu_id, vaddr_start, len, type);
}
4037cd45:	f01d      	retw.n
	...

4037cd48 <mmu_hal_map_region>:
{
4037cd48:	006136        	entry	a1, 48
4037cd4b:	006172        	s32i	a7, a1, 0
4037cd4e:	207660        	or	a7, a6, a6
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037cd51:	1b0c      	movi.n	a11, 1
4037cd53:	02ad      	mov.n	a10, a2
4037cd55:	0016a5        	call8	4037cec0 <mmu_hal_pages_to_bytes>
4037cd58:	0a6d      	mov.n	a6, a10
    HAL_ASSERT(vaddr % page_size_in_bytes == 0);
4037cd5a:	e284a0        	remu	a8, a4, a10
4037cd5d:	c88c      	beqz.n	a8, 4037cd6d <mmu_hal_map_region+0x25>
4037cd5f:	e055d1        	l32r	a13, 40374eb4 <_iram_text_start+0xab0> (3fc94394 <__func__$0+0x7a8>)
4037cd62:	e055c1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4> (3fc9469c <__func__$7>)
4037cd65:	4b5c      	movi.n	a11, 84
4037cd67:	e050a1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037cd6a:	02fbe5        	call8	4037fd28 <__assert_func>
    HAL_ASSERT(paddr % page_size_in_bytes == 0);
4037cd6d:	e285a0        	remu	a8, a5, a10
4037cd70:	00e816        	beqz	a8, 4037cd82 <mmu_hal_map_region+0x3a>
4037cd73:	e052d1        	l32r	a13, 40374ebc <_iram_text_start+0xab8> (3fc943b4 <__func__$0+0x7c8>)
4037cd76:	e050c1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4> (3fc9469c <__func__$7>)
4037cd79:	55a0b2        	movi	a11, 85
4037cd7c:	e04ba1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037cd7f:	02faa5        	call8	4037fd28 <__assert_func>
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cd82:	e04681        	l32r	a8, 40374e9c <_iram_text_start+0xa98> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cd85:	1d3857        	bltu	a8, a5, 4037cda6 <mmu_hal_map_region+0x5e>
    return (paddr_start < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cd88:	1a3877        	bltu	a8, a7, 4037cda6 <mmu_hal_map_region+0x5e>
           ((paddr_start + len - 1) < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM));
4037cd8b:	808570        	add	a8, a5, a7
4037cd8e:	880b      	addi.n	a8, a8, -1
           (len < (mmu_ll_get_page_size(mmu_id) * SOC_MMU_MAX_PADDR_PAGE_NUM)) &&
4037cd90:	e04391        	l32r	a9, 40374e9c <_iram_text_start+0xa98> (3fffffff <ets_rom_layout_p+0xe0003>)
4037cd93:	0f3987        	bltu	a9, a8, 4037cda6 <mmu_hal_map_region+0x5e>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037cd96:	3d0c      	movi.n	a13, 3
4037cd98:	07cd      	mov.n	a12, a7
4037cd9a:	04bd      	mov.n	a11, a4
4037cd9c:	02ad      	mov.n	a10, a2
4037cd9e:	fff525        	call8	4037ccf0 <mmu_hal_check_valid_ext_vaddr_region>
4037cda1:	dadc      	bnez.n	a10, 4037cdc2 <mmu_hal_map_region+0x7a>
4037cda3:	000346        	j	4037cdb4 <mmu_hal_map_region+0x6c>
    HAL_ASSERT(mmu_ll_check_valid_paddr_region(mmu_id, paddr, len));
4037cda6:	e046d1        	l32r	a13, 40374ec0 <_iram_text_start+0xabc> (3fc943d4 <__func__$0+0x7e8>)
4037cda9:	e043c1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4> (3fc9469c <__func__$7>)
4037cdac:	6b5c      	movi.n	a11, 86
4037cdae:	e03ea1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037cdb1:	02f765        	call8	4037fd28 <__assert_func>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037cdb4:	e044d1        	l32r	a13, 40374ec4 <_iram_text_start+0xac0> (3fc94408 <__func__$0+0x81c>)
4037cdb7:	e040c1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4> (3fc9469c <__func__$7>)
4037cdba:	7b5c      	movi.n	a11, 87
4037cdbc:	e03ba1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037cdbf:	02f6a5        	call8	4037fd28 <__assert_func>
    uint32_t page_num = (len + page_size_in_bytes - 1) / page_size_in_bytes;
4037cdc2:	767a      	add.n	a7, a6, a7
4037cdc4:	ffc772        	addi	a7, a7, -1
4037cdc7:	c27760        	quou	a7, a7, a6
    *out_len = mmu_hal_pages_to_bytes(mmu_id, page_num);
4037cdca:	20b770        	or	a11, a7, a7
4037cdcd:	02ad      	mov.n	a10, a2
4037cdcf:	000f25        	call8	4037cec0 <mmu_hal_pages_to_bytes>
4037cdd2:	0188      	l32i.n	a8, a1, 0
4037cdd4:	08a9      	s32i.n	a10, a8, 0
    return paddr >> 16;
4037cdd6:	f55050        	extui	a5, a5, 16, 16
    while (page_num) {
4037cdd9:	000846        	j	4037cdfe <mmu_hal_map_region+0xb6>
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037cddc:	858040        	extui	a8, a4, 16, 9
    uint32_t target_code = (target == MMU_TARGET_FLASH0) ? SOC_MMU_ACCESS_FLASH : SOC_MMU_ACCESS_SPIRAM;
4037cddf:	051366        	bnei	a3, 1, 4037cde8 <mmu_hal_map_region+0xa0>
4037cde2:	090c      	movi.n	a9, 0
4037cde4:	0000c6        	j	4037cdeb <mmu_hal_map_region+0xa3>
4037cde7:	a09100        	addx4	a9, a1, a0
4037cdea:	dd          	.byte	0xdd
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = mmu_val | target_code | SOC_MMU_VALID;
4037cdeb:	e029a1        	l32r	a10, 40374e90 <_iram_text_start+0xa8c> (18031400 <UserFrameTotalSize+0x18031300>)
4037cdee:	88aa      	add.n	a8, a8, a10
4037cdf0:	1188e0        	slli	a8, a8, 2
4037cdf3:	209590        	or	a9, a5, a9
4037cdf6:	0899      	s32i.n	a9, a8, 0
        vaddr += page_size_in_bytes;
4037cdf8:	446a      	add.n	a4, a4, a6
        mmu_val++;
4037cdfa:	551b      	addi.n	a5, a5, 1
        page_num--;
4037cdfc:	770b      	addi.n	a7, a7, -1
    while (page_num) {
4037cdfe:	fda756        	bnez	a7, 4037cddc <mmu_hal_map_region+0x94>
}
4037ce01:	f01d      	retw.n
	...

4037ce04 <mmu_hal_unmap_region>:
{
4037ce04:	004136        	entry	a1, 32
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ce07:	01a0b2        	movi	a11, 1
4037ce0a:	20a220        	or	a10, a2, a2
4037ce0d:	000b25        	call8	4037cec0 <mmu_hal_pages_to_bytes>
4037ce10:	0a7d      	mov.n	a7, a10
    HAL_ASSERT(vaddr % page_size_in_bytes == 0);
4037ce12:	e283a0        	remu	a8, a3, a10
4037ce15:	d88c      	beqz.n	a8, 4037ce26 <mmu_hal_unmap_region+0x22>
4037ce17:	e027d1        	l32r	a13, 40374eb4 <_iram_text_start+0xab0> (3fc94394 <__func__$0+0x7a8>)
4037ce1a:	e02bc1        	l32r	a12, 40374ec8 <_iram_text_start+0xac4> (3fc94684 <__func__$5>)
4037ce1d:	6ca0b2        	movi	a11, 108
4037ce20:	e022a1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037ce23:	02f065        	call8	4037fd28 <__assert_func>
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, len, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ce26:	03a0d2        	movi	a13, 3
4037ce29:	20c440        	or	a12, a4, a4
4037ce2c:	03bd      	mov.n	a11, a3
4037ce2e:	02ad      	mov.n	a10, a2
4037ce30:	ffebe5        	call8	4037ccf0 <mmu_hal_check_valid_ext_vaddr_region>
4037ce33:	dacc      	bnez.n	a10, 4037ce44 <mmu_hal_unmap_region+0x40>
4037ce35:	e023d1        	l32r	a13, 40374ec4 <_iram_text_start+0xac0> (3fc94408 <__func__$0+0x81c>)
4037ce38:	e024c1        	l32r	a12, 40374ec8 <_iram_text_start+0xac4> (3fc94684 <__func__$5>)
4037ce3b:	6da0b2        	movi	a11, 109
4037ce3e:	e01aa1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037ce41:	02ee65        	call8	4037fd28 <__assert_func>
    uint32_t page_num = (len + page_size_in_bytes - 1) / page_size_in_bytes;
4037ce44:	974a      	add.n	a9, a7, a4
4037ce46:	990b      	addi.n	a9, a9, -1
4037ce48:	c29970        	quou	a9, a9, a7
    while (page_num) {
4037ce4b:	000546        	j	4037ce64 <mmu_hal_unmap_region+0x60>
4037ce4e:	300000        	xor	a0, a0, a0
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037ce51:	80          	.byte	0x80
4037ce52:	0fa185        	call0	4038c86c <_iram_bss_end+0xa46c>
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = SOC_MMU_INVALID;
4037ce55:	e0          	.byte	0xe0
4037ce56:	88aa      	add.n	a8, a8, a10
4037ce58:	1188e0        	slli	a8, a8, 2
4037ce5b:	dd82a1        	l32r	a10, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
4037ce5e:	08a9      	s32i.n	a10, a8, 0
        vaddr += page_size_in_bytes;
4037ce60:	337a      	add.n	a3, a3, a7
        page_num--;
4037ce62:	990b      	addi.n	a9, a9, -1
    while (page_num) {
4037ce64:	fe8956        	bnez	a9, 4037ce50 <mmu_hal_unmap_region+0x4c>
}
4037ce67:	f01d      	retw.n
4037ce69:	000000        	ill

4037ce6c <mmu_hal_vaddr_to_paddr>:
{
4037ce6c:	004136        	entry	a1, 32
4037ce6f:	207220        	or	a7, a2, a2
    HAL_ASSERT(mmu_hal_check_valid_ext_vaddr_region(mmu_id, vaddr, 1, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION));
4037ce72:	03a0d2        	movi	a13, 3
4037ce75:	1c0c      	movi.n	a12, 1
4037ce77:	03bd      	mov.n	a11, a3
4037ce79:	20a220        	or	a10, a2, a2
4037ce7c:	ffe725        	call8	4037ccf0 <mmu_hal_check_valid_ext_vaddr_region>
4037ce7f:	00ea56        	bnez	a10, 4037ce91 <mmu_hal_vaddr_to_paddr+0x25>
4037ce82:	e012d1        	l32r	a13, 40374ecc <_iram_text_start+0xac8> (3fc9446c <__func__$0+0x880>)
4037ce85:	e012c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc> (3fc9466c <__func__$4>)
4037ce88:	7ba0b2        	movi	a11, 123
4037ce8b:	e007a1        	l32r	a10, 40374ea8 <_iram_text_start+0xaa4> (3fc94374 <__func__$0+0x788>)
4037ce8e:	02e9a5        	call8	4037fd28 <__assert_func>
    return ((vaddr & SOC_MMU_VADDR_MASK) >> 16);
4037ce91:	856030        	extui	a6, a3, 16, 9
    if (!mmu_ll_check_entry_valid(mmu_id, entry_id)) {
4037ce94:	06bd      	mov.n	a11, a6
4037ce96:	02ad      	mov.n	a10, a2
4037ce98:	ffd2a5        	call8	4037cbc4 <mmu_ll_check_entry_valid>
4037ce9b:	0a2d      	mov.n	a2, a10
4037ce9d:	da9c      	beqz.n	a10, 4037cebe <mmu_hal_vaddr_to_paddr+0x52>
    uint32_t page_size_in_bytes = mmu_hal_pages_to_bytes(mmu_id, 1);
4037ce9f:	1b0c      	movi.n	a11, 1
4037cea1:	07ad      	mov.n	a10, a7
4037cea3:	0001e5        	call8	4037cec0 <mmu_hal_pages_to_bytes>
    uint32_t offset = (uint32_t)vaddr % page_size_in_bytes;
4037cea6:	e233a0        	remu	a3, a3, a10
    *out_target = mmu_ll_get_entry_target(mmu_id, entry_id);
4037cea9:	06bd      	mov.n	a11, a6
4037ceab:	07ad      	mov.n	a10, a7
4037cead:	ffd4a5        	call8	4037cbf8 <mmu_ll_get_entry_target>
4037ceb0:	05a9      	s32i.n	a10, a5, 0
    uint32_t paddr_base = mmu_ll_entry_id_to_paddr_base(mmu_id, entry_id);
4037ceb2:	06bd      	mov.n	a11, a6
4037ceb4:	07ad      	mov.n	a10, a7
4037ceb6:	ffdb25        	call8	4037cc68 <mmu_ll_entry_id_to_paddr_base>
    *out_paddr = paddr_base | offset;
4037ceb9:	2033a0        	or	a3, a3, a10
4037cebc:	0439      	s32i.n	a3, a4, 0
}
4037cebe:	f01d      	retw.n

4037cec0 <mmu_hal_pages_to_bytes>:
{
4037cec0:	004136        	entry	a1, 32
}
4037cec3:	112300        	slli	a2, a3, 16
4037cec6:	f01d      	retw.n

4037cec8 <spi_flash_encrypt_ll_plaintext_save>:
 * @param buffer Buffer to store the input data.
 * @param size Buffer size.
 *
 */
static inline void spi_flash_encrypt_ll_plaintext_save(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037cec8:	004136        	entry	a1, 32
4037cecb:	03bd      	mov.n	a11, a3
4037cecd:	04cd      	mov.n	a12, a4
    uint32_t plaintext_offs = (address % SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX);
4037cecf:	542020        	extui	a2, a2, 0, 6
    HAL_ASSERT(plaintext_offs + size <= SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX);
4037ced2:	824a      	add.n	a8, a2, a4
4037ced4:	40a092        	movi	a9, 64
4037ced7:	0eb987        	bgeu	a9, a8, 4037cee9 <spi_flash_encrypt_ll_plaintext_save+0x21>
4037ceda:	dffed1        	l32r	a13, 40374ed4 <_iram_text_start+0xad0> (3fc944cc <__func__$0+0x8e0>)
4037cedd:	dffec1        	l32r	a12, 40374ed8 <_iram_text_start+0xad4> (3fc946b0 <__func__$0>)
4037cee0:	5aa0b2        	movi	a11, 90
4037cee3:	dffea1        	l32r	a10, 40374edc <_iram_text_start+0xad8> (3fc9450c <__func__$0+0x920>)
4037cee6:	02e425        	call8	4037fd28 <__assert_func>
    memcpy((void *)(AES_XTS_PLAIN_BASE + plaintext_offs), buffer, size);
4037cee9:	dffda1        	l32r	a10, 40374ee0 <_iram_text_start+0xadc> (600cc000 <SYSTEM+0xc000>)
4037ceec:	a2aa      	add.n	a10, a2, a10
4037ceee:	dd8481        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037cef1:	0008e0        	callx8	a8
}
4037cef4:	f01d      	retw.n
	...

4037cef8 <spi_flash_encryption_hal_enable>:

#include "hal/spi_flash_encrypted_ll.h"
#include "soc/soc_caps.h"

void spi_flash_encryption_hal_enable(void)
{
4037cef8:	004136        	entry	a1, 32
    REG_SET_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037cefb:	dffa91        	l32r	a9, 40374ee4 <_iram_text_start+0xae0> (600c004c <SYSTEM+0x4c>)
4037cefe:	0020c0        	memw
4037cf01:	0988      	l32i.n	a8, a9, 0
4037cf03:	9a0c      	movi.n	a10, 9
4037cf05:	2088a0        	or	a8, a8, a10
4037cf08:	0020c0        	memw
4037cf0b:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(AES_XTS_DESTINATION_REG, type);
4037cf0d:	dff681        	l32r	a8, 40374ee8 <_iram_text_start+0xae4> (600cc044 <SYSTEM+0xc044>)
4037cf10:	090c      	movi.n	a9, 0
4037cf12:	0020c0        	memw
4037cf15:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_aes_accelerator_enable();
#endif //CONFIG_IDF_TARGET_ESP32S2
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_type(FLASH_ENCRYPTION_MANU);
#endif // !CONFIG_IDF_TARGET_ESP32
}
4037cf17:	f01d      	retw.n
4037cf19:	000000        	ill

4037cf1c <spi_flash_encryption_hal_disable>:

void spi_flash_encryption_hal_disable(void)
{
4037cf1c:	004136        	entry	a1, 32
    REG_CLR_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037cf1f:	dff191        	l32r	a9, 40374ee4 <_iram_text_start+0xae0> (600c004c <SYSTEM+0x4c>)
4037cf22:	0020c0        	memw
4037cf25:	0988      	l32i.n	a8, a9, 0
4037cf27:	ea7c      	movi.n	a10, -2
4037cf29:	1088a0        	and	a8, a8, a10
4037cf2c:	0020c0        	memw
4037cf2f:	0989      	s32i.n	a8, a9, 0
    spi_flash_encrypt_ll_disable();
}
4037cf31:	f01d      	retw.n
	...

4037cf34 <spi_flash_encryption_hal_prepare>:

void spi_flash_encryption_hal_prepare(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037cf34:	004136        	entry	a1, 32
4037cf37:	02ad      	mov.n	a10, a2
4037cf39:	03bd      	mov.n	a11, a3
4037cf3b:	04cd      	mov.n	a12, a4
    REG_WRITE(AES_XTS_SIZE_REG, size >> 5);
4037cf3d:	419540        	srli	a9, a4, 5
4037cf40:	dfeb81        	l32r	a8, 40374eec <_iram_text_start+0xae8> (600cc040 <SYSTEM+0xc040>)
4037cf43:	0020c0        	memw
4037cf46:	0899      	s32i.n	a9, a8, 0
 *
 * @param flash_addr flash address to write.
 */
static inline void spi_flash_encrypt_ll_address_save(uint32_t flash_addr)
{
    REG_WRITE(AES_XTS_PHYSICAL_ADDR_REG, flash_addr);
4037cf48:	dfea81        	l32r	a8, 40374ef0 <_iram_text_start+0xaec> (600cc048 <SYSTEM+0xc048>)
4037cf4b:	0020c0        	memw
4037cf4e:	006822        	s32i	a2, a8, 0
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_buffer_length(size);
#endif // !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_address_save(address);
    spi_flash_encrypt_ll_plaintext_save(address, buffer, size);
4037cf51:	fff765        	call8	4037cec8 <spi_flash_encrypt_ll_plaintext_save>
/**
 * Start flash encryption
 */
static inline void spi_flash_encrypt_ll_calculate_start(void)
{
    REG_WRITE(AES_XTS_TRIGGER_REG, 1);
4037cf54:	dfe881        	l32r	a8, 40374ef4 <_iram_text_start+0xaf0> (600cc04c <SYSTEM+0xc04c>)
4037cf57:	190c      	movi.n	a9, 1
4037cf59:	0020c0        	memw
4037cf5c:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_calculate_start();
}
4037cf5e:	f01d      	retw.n

4037cf60 <spi_flash_encryption_hal_done>:

void spi_flash_encryption_hal_done(void)
{
4037cf60:	004136        	entry	a1, 32
/**
 * Wait for flash encryption termination
 */
static inline void spi_flash_encrypt_ll_calculate_wait_idle(void)
{
    while(REG_READ(AES_XTS_STATE_REG) == 0x1) {
4037cf63:	dfe581        	l32r	a8, 40374ef8 <_iram_text_start+0xaf4> (600cc058 <SYSTEM+0xc058>)
4037cf66:	0020c0        	memw
4037cf69:	0888      	l32i.n	a8, a8, 0
4037cf6b:	f41826        	beqi	a8, 1, 4037cf63 <spi_flash_encryption_hal_done+0x3>
/**
 * Finish the flash encryption and make encrypted result accessible to SPI.
 */
static inline void spi_flash_encrypt_ll_done(void)
{
    REG_WRITE(AES_XTS_RELEASE_REG, 1);
4037cf6e:	dfe381        	l32r	a8, 40374efc <_iram_text_start+0xaf8> (600cc050 <SYSTEM+0xc050>)
4037cf71:	190c      	movi.n	a9, 1
4037cf73:	0020c0        	memw
4037cf76:	0899      	s32i.n	a9, a8, 0
    while(REG_READ(AES_XTS_STATE_REG) != 0x3) {
4037cf78:	dfe081        	l32r	a8, 40374ef8 <_iram_text_start+0xaf4> (600cc058 <SYSTEM+0xc058>)
4037cf7b:	0020c0        	memw
4037cf7e:	0888      	l32i.n	a8, a8, 0
4037cf80:	f43866        	bnei	a8, 3, 4037cf78 <spi_flash_encryption_hal_done+0x18>
    spi_flash_encrypt_ll_calculate_wait_idle();
    spi_flash_encrypt_ll_done();
}
4037cf83:	f01d      	retw.n
4037cf85:	000000        	ill

4037cf88 <spi_flash_encryption_hal_destroy>:

void spi_flash_encryption_hal_destroy(void)
{
4037cf88:	004136        	entry	a1, 32
/**
 * Set to destroy encrypted result
 */
static inline void spi_flash_encrypt_ll_destroy(void)
{
    REG_WRITE(AES_XTS_DESTROY_REG, 1);
4037cf8b:	dfdd81        	l32r	a8, 40374f00 <_iram_text_start+0xafc> (600cc054 <SYSTEM+0xc054>)
4037cf8e:	190c      	movi.n	a9, 1
4037cf90:	0020c0        	memw
4037cf93:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_destroy();
}
4037cf95:	f01d      	retw.n
	...

4037cf98 <spi_flash_encryption_hal_check>:

bool spi_flash_encryption_hal_check(uint32_t address, uint32_t length)
{
4037cf98:	004136        	entry	a1, 32
 * @param address the address of written flash partition.
 * @param length Buffer size.
 */
static inline bool spi_flash_encrypt_ll_check(uint32_t address, uint32_t length)
{
    return ((address % length) == 0) ? true : false;
4037cf9b:	e22230        	remu	a2, a2, a3
    return spi_flash_encrypt_ll_check(address, length);
}
4037cf9e:	40f220        	nsau	a2, a2
4037cfa1:	412520        	srli	a2, a2, 5
4037cfa4:	f01d      	retw.n
	...

4037cfa8 <gpspi_flash_ll_set_read_mode>:
 *
 * @param dev Beginning address of the peripheral registers.
 * @param read_mode I/O mode to use in the following transactions.
 */
static inline void gpspi_flash_ll_set_read_mode(spi_dev_t *dev, esp_flash_io_mode_t read_mode)
{
4037cfa8:	006136        	entry	a1, 48
    typeof(dev->ctrl) ctrl;
    ctrl.val = dev->ctrl.val;
4037cfab:	0020c0        	memw
4037cfae:	2288      	l32i.n	a8, a2, 8
4037cfb0:	0020c0        	memw
4037cfb3:	0189      	s32i.n	a8, a1, 0
    typeof(dev->user) user;
    user.val = dev->user.val;
4037cfb5:	0020c0        	memw
4037cfb8:	4288      	l32i.n	a8, a2, 16
4037cfba:	0020c0        	memw
4037cfbd:	1189      	s32i.n	a8, a1, 4

    ctrl.val &= ~(SPI_FCMD_QUAD_M | SPI_FADDR_QUAD_M | SPI_FREAD_QUAD_M | SPI_FCMD_DUAL_M | SPI_FADDR_DUAL_M | SPI_FREAD_DUAL_M);
4037cfbf:	0020c0        	memw
4037cfc2:	0188      	l32i.n	a8, a1, 0
4037cfc4:	dfd091        	l32r	a9, 40374f04 <_iram_text_start+0xb00> (ffff3c9f <_rtc_reserved_end+0x9fef3c9f>)
4037cfc7:	108890        	and	a8, a8, a9
4037cfca:	0020c0        	memw
4037cfcd:	0189      	s32i.n	a8, a1, 0
    user.val &= ~(SPI_FWRITE_QUAD_M | SPI_FWRITE_DUAL_M);
4037cfcf:	0020c0        	memw
4037cfd2:	1188      	l32i.n	a8, a1, 4
4037cfd4:	dfcd91        	l32r	a9, 40374f08 <_iram_text_start+0xb04> (ffffcfff <_rtc_reserved_end+0x9fefcfff>)
4037cfd7:	108890        	and	a8, a8, a9
4037cfda:	0020c0        	memw
4037cfdd:	1189      	s32i.n	a8, a1, 4

    switch (read_mode) {
4037cfdf:	713326        	beqi	a3, 3, 4037d054 <gpspi_flash_ll_set_read_mode+0xac>
4037cfe2:	0e43f6        	bgeui	a3, 4, 4037cff4 <gpspi_flash_ll_set_read_mode+0x4c>
4037cfe5:	0223f6        	bgeui	a3, 2, 4037cfeb <gpspi_flash_ll_set_read_mode+0x43>
4037cfe8:	0030c6        	j	4037d0af <gpspi_flash_ll_set_read_mode+0x107>
4037cfeb:	022366        	bnei	a3, 2, 4037cff1 <gpspi_flash_ll_set_read_mode+0x49>
4037cfee:	002586        	j	4037d088 <gpspi_flash_ll_set_read_mode+0xe0>
4037cff1:	002dc6        	j	4037d0ac <gpspi_flash_ll_set_read_mode+0x104>
4037cff4:	384326        	beqi	a3, 4, 4037d030 <gpspi_flash_ll_set_read_mode+0x88>
4037cff7:	025326        	beqi	a3, 5, 4037cffd <gpspi_flash_ll_set_read_mode+0x55>
4037cffa:	002b86        	j	4037d0ac <gpspi_flash_ll_set_read_mode+0x104>
    case SPI_FLASH_FASTRD:
    //the default option
    case SPI_FLASH_SLOWRD:
        break;
    case SPI_FLASH_QIO:
        ctrl.fread_quad = 1;
4037cffd:	0020c0        	memw
4037d000:	0188      	l32i.n	a8, a1, 0
4037d002:	dd1991        	l32r	a9, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
4037d005:	208890        	or	a8, a8, a9
4037d008:	0020c0        	memw
4037d00b:	0189      	s32i.n	a8, a1, 0
        ctrl.faddr_quad = 1;
4037d00d:	0020c0        	memw
4037d010:	0188      	l32i.n	a8, a1, 0
4037d012:	094c      	movi.n	a9, 64
4037d014:	208890        	or	a8, a8, a9
4037d017:	0020c0        	memw
4037d01a:	0189      	s32i.n	a8, a1, 0
        user.fwrite_quad = 1;
4037d01c:	0020c0        	memw
4037d01f:	1188      	l32i.n	a8, a1, 4
4037d021:	de8b91        	l32r	a9, 40374a50 <_iram_text_start+0x64c> (2000 <UserFrameTotalSize+0x1f00>)
4037d024:	208890        	or	a8, a8, a9
4037d027:	0020c0        	memw
4037d02a:	1189      	s32i.n	a8, a1, 4
        break;
4037d02c:	001fc6        	j	4037d0af <gpspi_flash_ll_set_read_mode+0x107>
4037d02f:	20c000        	or	a12, a0, a0
    case SPI_FLASH_QOUT:
        ctrl.fread_quad = 1;
4037d032:	018800        	slli	a8, a8, 32
4037d035:	dd0c91        	l32r	a9, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
4037d038:	208890        	or	a8, a8, a9
4037d03b:	0020c0        	memw
4037d03e:	0189      	s32i.n	a8, a1, 0
        user.fwrite_quad = 1;
4037d040:	0020c0        	memw
4037d043:	1188      	l32i.n	a8, a1, 4
4037d045:	de8291        	l32r	a9, 40374a50 <_iram_text_start+0x64c> (2000 <UserFrameTotalSize+0x1f00>)
4037d048:	208890        	or	a8, a8, a9
4037d04b:	0020c0        	memw
4037d04e:	1189      	s32i.n	a8, a1, 4
        break;
4037d050:	0016c6        	j	4037d0af <gpspi_flash_ll_set_read_mode+0x107>
4037d053:	20c000        	or	a12, a0, a0
    case SPI_FLASH_DIO:
        ctrl.fread_dual = 1;
4037d056:	018800        	slli	a8, a8, 32
4037d059:	dd0291        	l32r	a9, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
4037d05c:	208890        	or	a8, a8, a9
4037d05f:	0020c0        	memw
4037d062:	0189      	s32i.n	a8, a1, 0
        ctrl.faddr_dual = 1;
4037d064:	0020c0        	memw
4037d067:	0188      	l32i.n	a8, a1, 0
4037d069:	092c      	movi.n	a9, 32
4037d06b:	208890        	or	a8, a8, a9
4037d06e:	0020c0        	memw
4037d071:	0189      	s32i.n	a8, a1, 0
        user.fwrite_dual = 1;
4037d073:	0020c0        	memw
4037d076:	1188      	l32i.n	a8, a1, 4
4037d078:	dd7391        	l32r	a9, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
4037d07b:	208890        	or	a8, a8, a9
4037d07e:	0020c0        	memw
4037d081:	1189      	s32i.n	a8, a1, 4
        break;
4037d083:	000a06        	j	4037d0af <gpspi_flash_ll_set_read_mode+0x107>
4037d086:	c00000        	sub	a0, a0, a0
    case SPI_FLASH_DOUT:
        ctrl.fread_dual = 1;
4037d089:	20          	.byte	0x20
4037d08a:	018800        	slli	a8, a8, 32
4037d08d:	dcf591        	l32r	a9, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
4037d090:	208890        	or	a8, a8, a9
4037d093:	0020c0        	memw
4037d096:	0189      	s32i.n	a8, a1, 0
        user.fwrite_dual = 1;
4037d098:	0020c0        	memw
4037d09b:	1188      	l32i.n	a8, a1, 4
4037d09d:	dd6991        	l32r	a9, 40374644 <_iram_text_start+0x240> (1000 <UserFrameTotalSize+0xf00>)
4037d0a0:	208890        	or	a8, a8, a9
4037d0a3:	0020c0        	memw
4037d0a6:	1189      	s32i.n	a8, a1, 4
        break;
4037d0a8:	0000c6        	j	4037d0af <gpspi_flash_ll_set_read_mode+0x107>
4037d0ab:	bbe500        	movgez.s	f14, f5, a0
    default:
        abort();
4037d0ae:	20c002        	addi	a0, a0, 32
    }

    dev->ctrl.val = ctrl.val;
4037d0b1:	218200        	srai	a8, a0, 2
4037d0b4:	20c000        	or	a12, a0, a0
4037d0b7:	628200        	saltu	a8, a2, a0
4037d0ba:	20c002        	addi	a0, a0, 32
    dev->user.val = user.val;
4037d0bd:	218200        	srai	a8, a0, 2
4037d0c0:	20c001        	l32r	a0, 403453c0 <rom_rx_gain_force+0x33ef94>
4037d0c3:	428900        	xorb	b8, b9, b0
}
4037d0c6:	f01d      	retw.n

4037d0c8 <gpspi_flash_ll_set_buffer_data>:
{
4037d0c8:	006136        	entry	a1, 48
    int num_words = (length + 3) / 4;
4037d0cb:	543b      	addi.n	a5, a4, 3
4037d0cd:	415250        	srli	a5, a5, 2
    for (int i = 0; i < num_words; i++) {
4037d0d0:	060c      	movi.n	a6, 0
4037d0d2:	000a86        	j	4037d100 <gpspi_flash_ll_set_buffer_data+0x38>
        uint32_t word = 0;
4037d0d5:	080c      	movi.n	a8, 0
4037d0d7:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037d0d9:	470c      	movi.n	a7, 4
4037d0db:	637470        	minu	a7, a4, a7
        memcpy(&word, buffer, word_len);
4037d0de:	07cd      	mov.n	a12, a7
4037d0e0:	20b330        	or	a11, a3, a3
4037d0e3:	20a110        	or	a10, a1, a1
4037d0e6:	dd0681        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037d0e9:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d0ec:	24c682        	addi	a8, a6, 36
4037d0ef:	a08820        	addx4	a8, a8, a2
4037d0f2:	0198      	l32i.n	a9, a1, 0
4037d0f4:	0020c0        	memw
4037d0f7:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037d0f9:	c04470        	sub	a4, a4, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037d0fc:	337a      	add.n	a3, a3, a7
    for (int i = 0; i < num_words; i++) {
4037d0fe:	661b      	addi.n	a6, a6, 1
4037d100:	d12657        	blt	a6, a5, 4037d0d5 <gpspi_flash_ll_set_buffer_data+0xd>
}
4037d103:	f01d      	retw.n
4037d105:	000000        	ill

4037d108 <gpspi_flash_ll_get_buffer_data>:
{
4037d108:	006136        	entry	a1, 48
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037d10b:	148030        	extui	a8, a3, 0, 2
4037d10e:	68dc      	bnez.n	a8, 4037d128 <gpspi_flash_ll_get_buffer_data+0x20>
4037d110:	148040        	extui	a8, a4, 0, 2
4037d113:	18dc      	bnez.n	a8, 4037d128 <gpspi_flash_ll_get_buffer_data+0x20>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037d115:	04cd      	mov.n	a12, a4
4037d117:	98a0b2        	movi	a11, 152
4037d11a:	b2ba      	add.n	a11, a2, a11
4037d11c:	03ad      	mov.n	a10, a3
4037d11e:	dcf881        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037d121:	0008e0        	callx8	a8
4037d124:	000d46        	j	4037d15d <gpspi_flash_ll_get_buffer_data+0x55>
4037d127:	045d00        	extui	a5, a0, 13, 1
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d12a:	060c      	movi.n	a6, 0
4037d12c:	000946        	j	4037d155 <gpspi_flash_ll_get_buffer_data+0x4d>
4037d12f:	470c00        	ee.stf.64.xp	f0, f4, a0, a12
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037d132:	637570        	minu	a7, a5, a7
            uint32_t word = dev->data_buf[i];
4037d135:	24c682        	addi	a8, a6, 36
4037d138:	a08820        	addx4	a8, a8, a2
4037d13b:	0020c0        	memw
4037d13e:	2888      	l32i.n	a8, a8, 8
4037d140:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037d142:	07cd      	mov.n	a12, a7
4037d144:	01bd      	mov.n	a11, a1
4037d146:	03ad      	mov.n	a10, a3
4037d148:	dcee81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037d14b:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037d14e:	337a      	add.n	a3, a3, a7
            copy_len -= word_len;
4037d150:	c05570        	sub	a5, a5, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d153:	661b      	addi.n	a6, a6, 1
4037d155:	843b      	addi.n	a8, a4, 3
4037d157:	418280        	srli	a8, a8, 2
4037d15a:	d23687        	bltu	a6, a8, 4037d130 <gpspi_flash_ll_get_buffer_data+0x28>
}
4037d15d:	f01d      	retw.n
	...

4037d160 <spi_flash_hal_gpspi_device_config>:
        //nop
    }
}

esp_err_t spi_flash_hal_device_config(spi_flash_host_inst_t *host)
{
4037d160:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d163:	1288      	l32i.n	a8, a2, 4
    dev->user.val = 0;
4037d165:	090c      	movi.n	a9, 0
4037d167:	0020c0        	memw
4037d16a:	4899      	s32i.n	a9, a8, 16
    dev->ctrl.val = 0;
4037d16c:	0020c0        	memw
4037d16f:	2899      	s32i.n	a9, a8, 8
    dev->clk_gate.clk_en = 1;
4037d171:	0020c0        	memw
4037d174:	3a28a2        	l32i	a10, a8, 232
4037d177:	1b0c      	movi.n	a11, 1
4037d179:	20aab0        	or	a10, a10, a11
4037d17c:	0020c0        	memw
4037d17f:	3a68a2        	s32i	a10, a8, 232
    dev->clk_gate.mst_clk_active = 1;
4037d182:	0020c0        	memw
4037d185:	3a28a2        	l32i	a10, a8, 232
4037d188:	2b0c      	movi.n	a11, 2
4037d18a:	20aab0        	or	a10, a10, a11
4037d18d:	0020c0        	memw
4037d190:	3a68a2        	s32i	a10, a8, 232
    dev->clk_gate.mst_clk_sel = 1;
4037d193:	0020c0        	memw
4037d196:	3a28a2        	l32i	a10, a8, 232
4037d199:	4b0c      	movi.n	a11, 4
4037d19b:	20aab0        	or	a10, a10, a11
4037d19e:	0020c0        	memw
4037d1a1:	3a68a2        	s32i	a10, a8, 232
    dev->dma_conf.val = 0;
4037d1a4:	0020c0        	memw
4037d1a7:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.tx_seg_trans_clr_en = 1;
4037d1a9:	0020c0        	memw
4037d1ac:	c898      	l32i.n	a9, a8, 48
4037d1ae:	df57a1        	l32r	a10, 40374f0c <_iram_text_start+0xb08> (100000 <UserFrameTotalSize+0xfff00>)
4037d1b1:	2099a0        	or	a9, a9, a10
4037d1b4:	0020c0        	memw
4037d1b7:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.rx_seg_trans_clr_en = 1;
4037d1b9:	0020c0        	memw
4037d1bc:	c898      	l32i.n	a9, a8, 48
4037d1be:	dddea1        	l32r	a10, 40374938 <_iram_text_start+0x534> (80000 <UserFrameTotalSize+0x7ff00>)
4037d1c1:	2099a0        	or	a9, a9, a10
4037d1c4:	0020c0        	memw
4037d1c7:	c899      	s32i.n	a9, a8, 48
    dev->dma_conf.dma_seg_trans_en = 0;
4037d1c9:	0020c0        	memw
4037d1cc:	c898      	l32i.n	a9, a8, 48
4037d1ce:	df50a1        	l32r	a10, 40374f10 <_iram_text_start+0xb0c> (fffbffff <_rtc_reserved_end+0x9febffff>)
4037d1d1:	1099a0        	and	a9, a9, a10
4037d1d4:	0020c0        	memw
4037d1d7:	c899      	s32i.n	a9, a8, 48
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    spi_dev_t *dev = get_spi_dev(host);

    spi_flash_ll_reset(dev);
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037d1d9:	22a8      	l32i.n	a10, a2, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037d1db:	0020c0        	memw
4037d1de:	8898      	l32i.n	a9, a8, 32
4037d1e0:	1b0c      	movi.n	a11, 1
4037d1e2:	83baa0        	moveqz	a11, a10, a10
4037d1e5:	ec7c      	movi.n	a12, -2
4037d1e7:	1099c0        	and	a9, a9, a12
4037d1ea:	2099b0        	or	a9, a9, a11
4037d1ed:	0020c0        	memw
4037d1f0:	8899      	s32i.n	a9, a8, 32
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037d1f2:	ba0b      	addi.n	a11, a10, -1
4037d1f4:	0020c0        	memw
4037d1f7:	8898      	l32i.n	a9, a8, 32
4037d1f9:	1a0c      	movi.n	a10, 1
4037d1fb:	83abb0        	moveqz	a10, a11, a11
4037d1fe:	aaaa      	add.n	a10, a10, a10
4037d200:	db7c      	movi.n	a11, -3
4037d202:	1099b0        	and	a9, a9, a11
4037d205:	2099a0        	or	a9, a9, a10
4037d208:	0020c0        	memw
4037d20b:	8899      	s32i.n	a9, a8, 32
 * @param dev Beginning address of the peripheral registers.
 * @param clock_val pointer to the clock value to set
 */
static inline void gpspi_flash_ll_set_clock(spi_dev_t *dev, gpspi_flash_ll_clock_reg_t *clock_val)
{
    dev->clock.val = *clock_val;
4037d20d:	0020c0        	memw
4037d210:	4298      	l32i.n	a9, a2, 16
4037d212:	0020c0        	memw
4037d215:	3899      	s32i.n	a9, a8, 12
    spi_flash_ll_set_clock(dev, &ctx->clock_conf);
    int cs_hold = ctx->cs_hold;
4037d217:	0f0292        	l8ui	a9, a2, 15
 * @param dev Beginning address of the peripheral registers.
 * @param hold_n Cycles of clocks before CS is inactive
 */
static inline void gpspi_flash_ll_set_hold(spi_dev_t *dev, uint32_t hold_n)
{
    dev->user.cs_hold = (hold_n > 0 ? 1 : 0);
4037d21a:	0020c0        	memw
4037d21d:	48a8      	l32i.n	a10, a8, 16
4037d21f:	1b0c      	movi.n	a11, 1
4037d221:	83b990        	moveqz	a11, a9, a9
4037d224:	11bba0        	slli	a11, a11, 6
4037d227:	bfafc2        	movi	a12, -65
4037d22a:	10aac0        	and	a10, a10, a12
4037d22d:	20aab0        	or	a10, a10, a11
4037d230:	0020c0        	memw
4037d233:	48a9      	s32i.n	a10, a8, 16
    if (hold_n > 0) {
4037d235:	b99c      	beqz.n	a9, 4037d254 <spi_flash_hal_gpspi_device_config+0xf4>
        dev->user1.cs_hold_time = hold_n - 1;
4037d237:	990b      	addi.n	a9, a9, -1
4037d239:	0020c0        	memw
4037d23c:	0528a2        	l32i	a10, a8, 20
4037d23f:	449090        	extui	a9, a9, 0, 5
4037d242:	0199a0        	slli	a9, a9, 22
4037d245:	df33b1        	l32r	a11, 40374f14 <_iram_text_start+0xb10> (f83fffff <_rtc_reserved_end+0x982fffff>)
4037d248:	10aab0        	and	a10, a10, a11
4037d24b:	209a90        	or	a9, a10, a9
4037d24e:	0020c0        	memw
4037d251:	056892        	s32i	a9, a8, 20
    spi_flash_ll_set_hold(dev, cs_hold);
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037d254:	0e0292        	l8ui	a9, a2, 14
 * @param dev Beginning address of the peripheral registers.
 * @param cs_setup_time Delay of SPI clocks after the CS active edge, 0 to disable the setup phase.
 */
static inline void gpspi_flash_ll_set_cs_setup(spi_dev_t *dev, uint32_t cs_setup_time)
{
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037d257:	0020c0        	memw
4037d25a:	48a8      	l32i.n	a10, a8, 16
4037d25c:	1b0c      	movi.n	a11, 1
4037d25e:	83b990        	moveqz	a11, a9, a9
4037d261:	11bb90        	slli	a11, a11, 7
4037d264:	7fafc2        	movi	a12, -129
4037d267:	10aac0        	and	a10, a10, a12
4037d26a:	20aab0        	or	a10, a10, a11
4037d26d:	0020c0        	memw
4037d270:	48a9      	s32i.n	a10, a8, 16
    if (cs_setup_time > 0) {
4037d272:	a99c      	beqz.n	a9, 4037d290 <spi_flash_hal_gpspi_device_config+0x130>
        dev->user1.cs_setup_time = cs_setup_time - 1;
4037d274:	990b      	addi.n	a9, a9, -1
4037d276:	0020c0        	memw
4037d279:	58a8      	l32i.n	a10, a8, 20
4037d27b:	449090        	extui	a9, a9, 0, 5
4037d27e:	0199f0        	slli	a9, a9, 17
4037d281:	df25b1        	l32r	a11, 40374f18 <_iram_text_start+0xb14> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
4037d284:	10aab0        	and	a10, a10, a11
4037d287:	209a90        	or	a9, a10, a9
4037d28a:	0020c0        	memw
4037d28d:	056892        	s32i	a9, a8, 20
    dev->ctrl.hold_pol = pol_val;
4037d290:	0020c0        	memw
4037d293:	2898      	l32i.n	a9, a8, 8
4037d295:	df1da1        	l32r	a10, 40374f0c <_iram_text_start+0xb08> (100000 <UserFrameTotalSize+0xfff00>)
4037d298:	2099a0        	or	a9, a9, a10
4037d29b:	0020c0        	memw
4037d29e:	2899      	s32i.n	a9, a8, 8
#else
    gpspi_flash_ll_set_hold_pol(dev, 1);
#endif //GPSPI_BUILD

    return ESP_OK;
}
4037d2a0:	020c      	movi.n	a2, 0
4037d2a2:	f01d      	retw.n

4037d2a4 <spi_flash_hal_gpspi_configure_host_io_mode>:
    spi_flash_host_inst_t *host,
    uint32_t command,
    uint32_t addr_bitlen,
    int dummy_cyclelen_base,
    esp_flash_io_mode_t io_mode)
{
4037d2a4:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d2a7:	12a8      	l32i.n	a10, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    int host_id = spi_flash_ll_hw_get_id(dev);

    uint32_t extra_bits = io_mode & 0xFFFF0000;
    io_mode = io_mode & 0xFFFF;
4037d2a9:	f4b060        	extui	a11, a6, 0, 16
    dev->ctrl.dummy_out = out_en;
4037d2ac:	0020c0        	memw
4037d2af:	2a88      	l32i.n	a8, a10, 8
4037d2b1:	056f60        	extui	a6, a6, 31, 1
4037d2b4:	1166d0        	slli	a6, a6, 3
4037d2b7:	797c      	movi.n	a9, -9
4037d2b9:	108890        	and	a8, a8, a9
4037d2bc:	208860        	or	a8, a8, a6
4037d2bf:	0020c0        	memw
4037d2c2:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.q_pol = out_lev;
4037d2c4:	0020c0        	memw
4037d2c7:	2a88      	l32i.n	a8, a10, 8
4037d2c9:	dd4091        	l32r	a9, 403747cc <_iram_text_start+0x3c8> (40000 <UserFrameTotalSize+0x3ff00>)
4037d2cc:	208890        	or	a8, a8, a9
4037d2cf:	0020c0        	memw
4037d2d2:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.d_pol = out_lev;
4037d2d4:	0020c0        	memw
4037d2d7:	2a88      	l32i.n	a8, a10, 8
4037d2d9:	dd9791        	l32r	a9, 40374938 <_iram_text_start+0x534> (80000 <UserFrameTotalSize+0x7ff00>)
4037d2dc:	208890        	or	a8, a8, a9
4037d2df:	0020c0        	memw
4037d2e2:	2a89      	s32i.n	a8, a10, 8
            spi_flash_ll_set_extra_address(dev, 0);
        }
    }
#endif

    if (command >= 0x100) {
4037d2e4:	ffa082        	movi	a8, 255
4037d2e7:	49b837        	bgeu	a8, a3, 4037d334 <spi_flash_hal_gpspi_configure_host_io_mode+0x90>
    dev->user.usr_command = 1;
4037d2ea:	0020c0        	memw
4037d2ed:	4a88      	l32i.n	a8, a10, 16
4037d2ef:	dd3091        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d2f2:	208890        	or	a8, a8, a9
4037d2f5:	0020c0        	memw
4037d2f8:	4a89      	s32i.n	a8, a10, 16
    typeof(dev->user2) user2 = {
4037d2fa:	080c      	movi.n	a8, 0
4037d2fc:	0020c0        	memw
4037d2ff:	2189      	s32i.n	a8, a1, 8
4037d301:	0020c0        	memw
4037d304:	2188      	l32i.n	a8, a1, 8
4037d306:	743030        	extui	a3, a3, 0, 8
4037d309:	f58080        	extui	a8, a8, 16, 16
4037d30c:	118800        	slli	a8, a8, 16
4037d30f:	208830        	or	a8, a8, a3
4037d312:	0020c0        	memw
4037d315:	2189      	s32i.n	a8, a1, 8
4037d317:	0020c0        	memw
4037d31a:	2188      	l32i.n	a8, a1, 8
4037d31c:	df0091        	l32r	a9, 40374f1c <_iram_text_start+0xb18> (f0000000 <_rtc_reserved_end+0x8ff00000>)
4037d31f:	208890        	or	a8, a8, a9
4037d322:	0020c0        	memw
4037d325:	2189      	s32i.n	a8, a1, 8
    dev->user2.val = user2.val;
4037d327:	0020c0        	memw
4037d32a:	2188      	l32i.n	a8, a1, 8
4037d32c:	0020c0        	memw
4037d32f:	6a89      	s32i.n	a8, a10, 24
}
4037d331:	001306        	j	4037d381 <spi_flash_hal_gpspi_configure_host_io_mode+0xdd>
    dev->user.usr_command = 1;
4037d334:	0020c0        	memw
4037d337:	4a88      	l32i.n	a8, a10, 16
4037d339:	dd1d91        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d33c:	208890        	or	a8, a8, a9
4037d33f:	0020c0        	memw
4037d342:	4a89      	s32i.n	a8, a10, 16
    typeof(dev->user2) user2 = {
4037d344:	080c      	movi.n	a8, 0
4037d346:	0020c0        	memw
4037d349:	1189      	s32i.n	a8, a1, 4
4037d34b:	0020c0        	memw
4037d34e:	1188      	l32i.n	a8, a1, 4
4037d350:	743030        	extui	a3, a3, 0, 8
4037d353:	f58080        	extui	a8, a8, 16, 16
4037d356:	118800        	slli	a8, a8, 16
4037d359:	208830        	or	a8, a8, a3
4037d35c:	0020c0        	memw
4037d35f:	1189      	s32i.n	a8, a1, 4
4037d361:	0020c0        	memw
4037d364:	1188      	l32i.n	a8, a1, 4
4037d366:	1188c0        	slli	a8, a8, 4
4037d369:	418480        	srli	a8, a8, 4
4037d36c:	dd1291        	l32r	a9, 403747b4 <_iram_text_start+0x3b0> (70000000 <_rtc_reserved_end+0xff00000>)
4037d36f:	208890        	or	a8, a8, a9
4037d372:	0020c0        	memw
4037d375:	1189      	s32i.n	a8, a1, 4
    dev->user2.val = user2.val;
4037d377:	0020c0        	memw
4037d37a:	1188      	l32i.n	a8, a1, 4
4037d37c:	0020c0        	memw
4037d37f:	6a89      	s32i.n	a8, a10, 24
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d381:	940b      	addi.n	a9, a4, -1
4037d383:	0020c0        	memw
4037d386:	5a88      	l32i.n	a8, a10, 20
4037d388:	019950        	slli	a9, a9, 27
4037d38b:	1188b0        	slli	a8, a8, 5
4037d38e:	418580        	srli	a8, a8, 5
4037d391:	208890        	or	a8, a8, a9
4037d394:	0020c0        	memw
4037d397:	5a89      	s32i.n	a8, a10, 20
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d399:	0020c0        	memw
4037d39c:	4a88      	l32i.n	a8, a10, 16
4037d39e:	190c      	movi.n	a9, 1
4037d3a0:	839440        	moveqz	a9, a4, a4
4037d3a3:	019920        	slli	a9, a9, 30
4037d3a6:	dd04c1        	l32r	a12, 403747b8 <_iram_text_start+0x3b4> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037d3a9:	1088c0        	and	a8, a8, a12
4037d3ac:	208890        	or	a8, a8, a9
4037d3af:	0020c0        	memw
4037d3b2:	4a89      	s32i.n	a8, a10, 16
    } else {
        spi_flash_ll_set_command(dev, command, 8);
    }
    spi_flash_ll_set_addr_bitlen(dev, addr_bitlen);
    // Add dummy cycles to compensate for latency of GPIO matrix and external delay, if necessary...
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037d3b4:	0c0282        	l8ui	a8, a2, 12
4037d3b7:	585a      	add.n	a5, a8, a5
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d3b9:	0020c0        	memw
4037d3bc:	4a88      	l32i.n	a8, a10, 16
4037d3be:	190c      	movi.n	a9, 1
4037d3c0:	839550        	moveqz	a9, a5, a5
4037d3c3:	019930        	slli	a9, a9, 29
4037d3c6:	dcfec1        	l32r	a12, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d3c9:	1088c0        	and	a8, a8, a12
4037d3cc:	208890        	or	a8, a8, a9
4037d3cf:	0020c0        	memw
4037d3d2:	4a89      	s32i.n	a8, a10, 16
    if (dummy_n > 0) {
4037d3d4:	b5ac      	beqz.n	a5, 4037d403 <spi_flash_hal_gpspi_configure_host_io_mode+0x15f>
        HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037d3d6:	0020c0        	memw
4037d3d9:	5a88      	l32i.n	a8, a10, 20
4037d3db:	0020c0        	memw
4037d3de:	0189      	s32i.n	a8, a1, 0
4037d3e0:	550b      	addi.n	a5, a5, -1
4037d3e2:	0020c0        	memw
4037d3e5:	0188      	l32i.n	a8, a1, 0
4037d3e7:	745050        	extui	a5, a5, 0, 8
4037d3ea:	00af92        	movi	a9, 0xffffff00
4037d3ed:	108890        	and	a8, a8, a9
4037d3f0:	208850        	or	a8, a8, a5
4037d3f3:	0020c0        	memw
4037d3f6:	0189      	s32i.n	a8, a1, 0
4037d3f8:	0020c0        	memw
4037d3fb:	0188      	l32i.n	a8, a1, 0
4037d3fd:	0020c0        	memw
4037d400:	056a82        	s32i	a8, a10, 20
    dev->user.usr_miso = bitlen > 0;
4037d403:	0020c0        	memw
4037d406:	4a88      	l32i.n	a8, a10, 16
4037d408:	dcf091        	l32r	a9, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d40b:	108890        	and	a8, a8, a9
4037d40e:	0020c0        	memw
4037d411:	4a89      	s32i.n	a8, a10, 16
    dev->user.usr_mosi = bitlen > 0;
4037d413:	0020c0        	memw
4037d416:	4a88      	l32i.n	a8, a10, 16
4037d418:	dceb91        	l32r	a9, 403747c4 <_iram_text_start+0x3c0> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037d41b:	108890        	and	a8, a8, a9
4037d41e:	0020c0        	memw
4037d421:	4a89      	s32i.n	a8, a10, 16
    //disable all data phases, enable them later if needed
    spi_flash_ll_set_miso_bitlen(dev, 0);
    spi_flash_ll_set_mosi_bitlen(dev, 0);
    spi_flash_ll_set_read_mode(dev, io_mode);
4037d423:	ffb865        	call8	4037cfa8 <gpspi_flash_ll_set_read_mode>
    if (ctx->fdummy_rin) {
        spimem_flash_ll_set_fdummy_rin((spi_mem_dev_t*)dev, ctx->fdummy_rin);
    }
#endif
    return ESP_OK;
}
4037d426:	020c      	movi.n	a2, 0
4037d428:	f01d      	retw.n
	...

4037d42c <spi_flash_hal_gpspi_common_command>:

esp_err_t spi_flash_hal_common_command(spi_flash_host_inst_t *host, spi_flash_trans_t *trans)
{
4037d42c:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d42f:	1278      	l32i.n	a7, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037d431:	52e8      	l32i.n	a14, a2, 20
    uint16_t command;
    uint8_t dummy_bitlen;
    bool pe_ops = false;

    command = trans->command;
4037d433:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037d436:	160362        	l8ui	a6, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037d439:	4388      	l32i.n	a8, a3, 16
4037d43b:	016817        	bbci	a8, 1, 4037d440 <spi_flash_hal_gpspi_common_command+0x14>
        io_mode = trans->io_mode;
4037d43e:	63e8      	l32i.n	a14, a3, 24
    }

    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037d440:	0288      	l32i.n	a8, a2, 0
4037d442:	f888      	l32i.n	a8, a8, 60
4037d444:	06dd      	mov.n	a13, a6
4037d446:	0303c2        	l8ui	a12, a3, 3
4037d449:	02ad      	mov.n	a10, a2
4037d44b:	0008e0        	callx8	a8

    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037d44e:	1398      	l32i.n	a9, a3, 4
4037d450:	030382        	l8ui	a8, a3, 3
    uint32_t padding_ones = (bitlen == 32 ? 0 : UINT32_MAX >> bitlen);
4037d453:	0ac826        	beqi	a8, 32, 4037d461 <spi_flash_hal_gpspi_common_command+0x35>
4037d456:	fa7c      	movi.n	a10, -1
4037d458:	400800        	ssr	a8
4037d45b:	91a0a0        	srl	a10, a10
4037d45e:	000046        	j	4037d463 <spi_flash_hal_gpspi_common_command+0x37>
4037d461:	0a0c      	movi.n	a10, 0
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037d463:	e0c882        	addi	a8, a8, -32
4037d466:	608080        	neg	a8, a8
4037d469:	401800        	ssl	a8
4037d46c:	a18900        	sll	a8, a9
4037d46f:	2088a0        	or	a8, a8, a10
4037d472:	0020c0        	memw
4037d475:	1789      	s32i.n	a8, a7, 4
    //No extra dummy cycles for compensation if no input data
    if (trans->miso_len == 0) {
4037d477:	020382        	l8ui	a8, a3, 2
4037d47a:	048856        	bnez	a8, 4037d4c6 <spi_flash_hal_gpspi_common_command+0x9a>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d47d:	0020c0        	memw
4037d480:	4788      	l32i.n	a8, a7, 16
4037d482:	190c      	movi.n	a9, 1
4037d484:	839660        	moveqz	a9, a6, a6
4037d487:	019930        	slli	a9, a9, 29
4037d48a:	dccda1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d48d:	1088a0        	and	a8, a8, a10
4037d490:	208890        	or	a8, a8, a9
4037d493:	0020c0        	memw
4037d496:	4789      	s32i.n	a8, a7, 16
    if (dummy_n > 0) {
4037d498:	a6ac      	beqz.n	a6, 4037d4c6 <spi_flash_hal_gpspi_common_command+0x9a>
        HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037d49a:	0020c0        	memw
4037d49d:	5788      	l32i.n	a8, a7, 20
4037d49f:	0020c0        	memw
4037d4a2:	0189      	s32i.n	a8, a1, 0
4037d4a4:	660b      	addi.n	a6, a6, -1
4037d4a6:	0020c0        	memw
4037d4a9:	0188      	l32i.n	a8, a1, 0
4037d4ab:	746060        	extui	a6, a6, 0, 8
4037d4ae:	00af92        	movi	a9, 0xffffff00
4037d4b1:	108890        	and	a8, a8, a9
4037d4b4:	208860        	or	a8, a8, a6
4037d4b7:	0020c0        	memw
4037d4ba:	0189      	s32i.n	a8, a1, 0
4037d4bc:	0020c0        	memw
4037d4bf:	0188      	l32i.n	a8, a1, 0
4037d4c1:	0020c0        	memw
4037d4c4:	5789      	s32i.n	a8, a7, 20
        spi_flash_ll_set_dummy(dev, dummy_bitlen);
    }

    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037d4c6:	0103a2        	l8ui	a10, a3, 1
4037d4c9:	119ad0        	slli	a9, a10, 3
    dev->user.usr_mosi = bitlen > 0;
4037d4cc:	0020c0        	memw
4037d4cf:	4788      	l32i.n	a8, a7, 16
4037d4d1:	1b0c      	movi.n	a11, 1
4037d4d3:	83baa0        	moveqz	a11, a10, a10
4037d4d6:	01bb50        	slli	a11, a11, 27
4037d4d9:	dcbac1        	l32r	a12, 403747c4 <_iram_text_start+0x3c0> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037d4dc:	1088c0        	and	a8, a8, a12
4037d4df:	2088b0        	or	a8, a8, a11
4037d4e2:	0020c0        	memw
4037d4e5:	4789      	s32i.n	a8, a7, 16
    if (bitlen) {
4037d4e7:	9a9c      	beqz.n	a10, 4037d504 <spi_flash_hal_gpspi_common_command+0xd8>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d4e9:	890b      	addi.n	a8, a9, -1
4037d4eb:	0020c0        	memw
4037d4ee:	7798      	l32i.n	a9, a7, 28
4037d4f0:	118820        	slli	a8, a8, 14
4037d4f3:	418e80        	srli	a8, a8, 14
4037d4f6:	d59290        	extui	a9, a9, 18, 14
4037d4f9:	0199e0        	slli	a9, a9, 18
4037d4fc:	209980        	or	a9, a9, a8
4037d4ff:	0020c0        	memw
4037d502:	7799      	s32i.n	a9, a7, 28
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037d504:	0103c2        	l8ui	a12, a3, 1
4037d507:	23b8      	l32i.n	a11, a3, 8
4037d509:	07ad      	mov.n	a10, a7
4037d50b:	ffbbe5        	call8	4037d0c8 <gpspi_flash_ll_set_buffer_data>

    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037d50e:	0203a2        	l8ui	a10, a3, 2
4037d511:	119ad0        	slli	a9, a10, 3
    dev->user.usr_miso = bitlen > 0;
4037d514:	0020c0        	memw
4037d517:	4788      	l32i.n	a8, a7, 16
4037d519:	1b0c      	movi.n	a11, 1
4037d51b:	83baa0        	moveqz	a11, a10, a10
4037d51e:	01bb40        	slli	a11, a11, 28
4037d521:	dca9c1        	l32r	a12, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d524:	1088c0        	and	a8, a8, a12
4037d527:	2088b0        	or	a8, a8, a11
4037d52a:	0020c0        	memw
4037d52d:	4789      	s32i.n	a8, a7, 16
    if (bitlen) {
4037d52f:	9a9c      	beqz.n	a10, 4037d54c <spi_flash_hal_gpspi_common_command+0x120>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d531:	890b      	addi.n	a8, a9, -1
4037d533:	0020c0        	memw
4037d536:	7798      	l32i.n	a9, a7, 28
4037d538:	118820        	slli	a8, a8, 14
4037d53b:	418e80        	srli	a8, a8, 14
4037d53e:	d59290        	extui	a9, a9, 18, 14
4037d541:	0199e0        	slli	a9, a9, 18
4037d544:	209980        	or	a9, a9, a8
4037d547:	0020c0        	memw
4037d54a:	7799      	s32i.n	a9, a7, 28
    dev->cmd.update = 1;
4037d54c:	0020c0        	memw
4037d54f:	0788      	l32i.n	a8, a7, 0
4037d551:	dd0591        	l32r	a9, 40374968 <_iram_text_start+0x564> (800000 <UserFrameTotalSize+0x7fff00>)
4037d554:	208890        	or	a8, a8, a9
4037d557:	0020c0        	memw
4037d55a:	0789      	s32i.n	a8, a7, 0
    while (dev->cmd.update);
4037d55c:	0020c0        	memw
4037d55f:	0788      	l32i.n	a8, a7, 0
4037d561:	f7f877        	bbsi	a8, 23, 4037d55c <spi_flash_hal_gpspi_common_command+0x130>
    dev->cmd.usr = 1;
4037d564:	0020c0        	memw
4037d567:	0788      	l32i.n	a8, a7, 0
4037d569:	de6d91        	l32r	a9, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4037d56c:	208890        	or	a8, a8, a9
4037d56f:	0020c0        	memw
4037d572:	0789      	s32i.n	a8, a7, 0
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_PE_CMD) != 0) {
        pe_ops = true;
    }
    spi_flash_ll_user_start(dev, pe_ops);
    host->driver->poll_cmd_done(host);
4037d574:	002282        	l32i	a8, a2, 0
4037d577:	102882        	l32i	a8, a8, 64
4037d57a:	20a220        	or	a10, a2, a2
4037d57d:	0008e0        	callx8	a8
    if (trans->miso_len > 0) {
4037d580:	0203c2        	l8ui	a12, a3, 2
4037d583:	5c8c      	beqz.n	a12, 4037d58c <spi_flash_hal_gpspi_common_command+0x160>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037d585:	33b8      	l32i.n	a11, a3, 12
4037d587:	07ad      	mov.n	a10, a7
4037d589:	ffb7e5        	call8	4037d108 <gpspi_flash_ll_get_buffer_data>
    }
#if SOC_SPI_MEM_SUPPORT_WB_MODE_INDEPENDENT_CONTROL
    spi_flash_ll_wb_mode_enable(dev, false);
#endif
    return ESP_OK;
}
4037d58c:	020c      	movi.n	a2, 0
4037d58e:	f01d      	retw.n

4037d590 <spi_flash_hal_gpspi_read>:

esp_err_t spi_flash_hal_read(spi_flash_host_inst_t *host, void *buffer, uint32_t address, uint32_t read_len)
{
4037d590:	004136        	entry	a1, 32
4037d593:	02ad      	mov.n	a10, a2
    return ((spi_flash_hal_context_t*)host)->spi;
4037d595:	1278      	l32i.n	a7, a2, 4
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037d597:	0020c0        	memw
4037d59a:	4788      	l32i.n	a8, a7, 16
4037d59c:	1478e7        	bbci	a8, 30, 4037d5b4 <spi_flash_hal_gpspi_read+0x24>
4037d59f:	0020c0        	memw
4037d5a2:	5788      	l32i.n	a8, a7, 20
4037d5a4:	458b80        	extui	a8, a8, 27, 5
4037d5a7:	881b      	addi.n	a8, a8, 1
    spi_dev_t *dev = get_spi_dev(host);
    int bitlen = spi_flash_ll_get_addr_bitlen(dev);
    //Only 24-bit and 32-bit address are supported. The extra length are for M7-M0, which should be
    //filled with ones by the function below
    spi_flash_ll_set_usr_address(dev, address, bitlen & (~7));
4037d5a9:	897c      	movi.n	a9, -8
4037d5ab:	108890        	and	a8, a8, a9
    uint32_t padding_ones = (bitlen == 32 ? 0 : UINT32_MAX >> bitlen);
4037d5ae:	04c866        	bnei	a8, 32, 4037d5b6 <spi_flash_hal_gpspi_read+0x26>
4037d5b1:	000306        	j	4037d5c1 <spi_flash_hal_gpspi_read+0x31>
4037d5b4:	080c      	movi.n	a8, 0
4037d5b6:	f97c      	movi.n	a9, -1
4037d5b8:	400800        	ssr	a8
4037d5bb:	919090        	srl	a9, a9
4037d5be:	000046        	j	4037d5c3 <spi_flash_hal_gpspi_read+0x33>
4037d5c1:	090c      	movi.n	a9, 0
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037d5c3:	e0c882        	addi	a8, a8, -32
4037d5c6:	608080        	neg	a8, a8
4037d5c9:	401800        	ssl	a8
4037d5cc:	a14400        	sll	a4, a4
4037d5cf:	204490        	or	a4, a4, a9
4037d5d2:	0020c0        	memw
4037d5d5:	1749      	s32i.n	a4, a7, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037d5d7:	1185d0        	slli	a8, a5, 3
    dev->user.usr_miso = bitlen > 0;
4037d5da:	0020c0        	memw
4037d5dd:	4798      	l32i.n	a9, a7, 16
4037d5df:	1b0c      	movi.n	a11, 1
4037d5e1:	83b880        	moveqz	a11, a8, a8
4037d5e4:	01bb40        	slli	a11, a11, 28
4037d5e7:	dc78c1        	l32r	a12, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037d5ea:	1099c0        	and	a9, a9, a12
4037d5ed:	2099b0        	or	a9, a9, a11
4037d5f0:	0020c0        	memw
4037d5f3:	4799      	s32i.n	a9, a7, 16
    if (bitlen) {
4037d5f5:	b89c      	beqz.n	a8, 4037d614 <spi_flash_hal_gpspi_read+0x84>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037d5f7:	880b      	addi.n	a8, a8, -1
4037d5f9:	0020c0        	memw
4037d5fc:	072792        	l32i	a9, a7, 28
4037d5ff:	118820        	slli	a8, a8, 14
4037d602:	418e80        	srli	a8, a8, 14
4037d605:	d59290        	extui	a9, a9, 18, 14
4037d608:	0199e0        	slli	a9, a9, 18
4037d60b:	209980        	or	a9, a9, a8
4037d60e:	0020c0        	memw
4037d611:	076792        	s32i	a9, a7, 28
    dev->cmd.update = 1;
4037d614:	0020c0        	memw
4037d617:	0788      	l32i.n	a8, a7, 0
4037d619:	dcd391        	l32r	a9, 40374968 <_iram_text_start+0x564> (800000 <UserFrameTotalSize+0x7fff00>)
4037d61c:	208890        	or	a8, a8, a9
4037d61f:	0020c0        	memw
4037d622:	0789      	s32i.n	a8, a7, 0
    while (dev->cmd.update);
4037d624:	0020c0        	memw
4037d627:	002782        	l32i	a8, a7, 0
4037d62a:	f6f877        	bbsi	a8, 23, 4037d624 <spi_flash_hal_gpspi_read+0x94>
    dev->cmd.usr = 1;
4037d62d:	0020c0        	memw
4037d630:	002782        	l32i	a8, a7, 0
4037d633:	de3b91        	l32r	a9, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4037d636:	208890        	or	a8, a8, a9
4037d639:	0020c0        	memw
4037d63c:	006782        	s32i	a8, a7, 0
    spi_flash_ll_user_start(dev, false);
    host->driver->poll_cmd_done(host);
4037d63f:	0a88      	l32i.n	a8, a10, 0
4037d641:	102882        	l32i	a8, a8, 64
4037d644:	0008e0        	callx8	a8
    if (read_len > 0) {
4037d647:	758c      	beqz.n	a5, 4037d652 <spi_flash_hal_gpspi_read+0xc2>
        spi_flash_ll_get_buffer_data(dev, buffer, read_len);
4037d649:	05cd      	mov.n	a12, a5
4037d64b:	03bd      	mov.n	a11, a3
4037d64d:	07ad      	mov.n	a10, a7
4037d64f:	ffaba5        	call8	4037d108 <gpspi_flash_ll_get_buffer_data>
    }
    return ESP_OK;
}
4037d652:	020c      	movi.n	a2, 0
4037d654:	f01d      	retw.n
	...

4037d658 <spi_flash_hal_gpspi_poll_cmd_done>:
{
4037d658:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d65b:	1288      	l32i.n	a8, a2, 4
    return (dev->cmd.usr == 0);
4037d65d:	0020c0        	memw
4037d660:	0888      	l32i.n	a8, a8, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037d662:	f5f887        	bbsi	a8, 24, 4037d65b <spi_flash_hal_gpspi_poll_cmd_done+0x3>
}
4037d665:	f01d      	retw.n
	...

4037d668 <spi_flash_hal_gpspi_supports_direct_write>:
#define spi_flash_hal_read                      spi_flash_hal_gpspi_read

#include "spi_flash_hal_common.inc"

bool spi_flash_hal_gpspi_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4037d668:	004136        	entry	a1, 32
    return true;
}
4037d66b:	120c      	movi.n	a2, 1
4037d66d:	f01d      	retw.n
	...

4037d670 <spi_flash_hal_gpspi_supports_direct_read>:

bool spi_flash_hal_gpspi_supports_direct_read(spi_flash_host_inst_t *host, const void *p)
{
4037d670:	004136        	entry	a1, 32
    return true;
}
4037d673:	120c      	movi.n	a2, 1
4037d675:	f01d      	retw.n
	...

4037d678 <spi_flash_hal_gpspi_check_status>:

uint32_t spi_flash_hal_gpspi_check_status(spi_flash_host_inst_t *host)
{
4037d678:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d67b:	1288      	l32i.n	a8, a2, 4
    return dev->cmd.usr == 0;
4037d67d:	0020c0        	memw
4037d680:	0828      	l32i.n	a2, a8, 0
4037d682:	052820        	extui	a2, a2, 24, 1
4037d685:	180c      	movi.n	a8, 1
4037d687:	302280        	xor	a2, a2, a8
    spi_dev_t *dev = get_spi_dev(host);
    return spi_flash_ll_host_idle(dev);
}
4037d68a:	042020        	extui	a2, a2, 0, 1
4037d68d:	f01d      	retw.n
	...

4037d690 <spimem_flash_ll_set_read_mode>:
{
4037d690:	006136        	entry	a1, 48
    ctrl.val = dev->ctrl.val;
4037d693:	0020c0        	memw
4037d696:	2288      	l32i.n	a8, a2, 8
4037d698:	0020c0        	memw
4037d69b:	0189      	s32i.n	a8, a1, 0
    ctrl.val &= ~(SPI_MEM_FREAD_QIO_M | SPI_MEM_FREAD_QUAD_M | SPI_MEM_FREAD_DIO_M | SPI_MEM_FREAD_DUAL_M | SPI_MEM_FCMD_OCT | SPI_MEM_FADDR_OCT | SPI_MEM_FDIN_OCT | SPI_MEM_FDOUT_OCT);
4037d69d:	0020c0        	memw
4037d6a0:	0188      	l32i.n	a8, a1, 0
4037d6a2:	de2091        	l32r	a9, 40374f24 <_iram_text_start+0xb20> (fe6fbd8f <_rtc_reserved_end+0x9e5fbd8f>)
4037d6a5:	108890        	and	a8, a8, a9
4037d6a8:	0020c0        	memw
4037d6ab:	0189      	s32i.n	a8, a1, 0
    dev->ddr.fmem_ddr_en = 0;
4037d6ad:	0020c0        	memw
4037d6b0:	382282        	l32i	a8, a2, 224
4037d6b3:	e97c      	movi.n	a9, -2
4037d6b5:	108890        	and	a8, a8, a9
4037d6b8:	0020c0        	memw
4037d6bb:	386282        	s32i	a8, a2, 224
    ctrl.val |= SPI_MEM_FASTRD_MODE_M;
4037d6be:	0020c0        	memw
4037d6c1:	0188      	l32i.n	a8, a1, 0
4037d6c3:	dce391        	l32r	a9, 40374a50 <_iram_text_start+0x64c> (2000 <UserFrameTotalSize+0x1f00>)
4037d6c6:	208890        	or	a8, a8, a9
4037d6c9:	0020c0        	memw
4037d6cc:	0189      	s32i.n	a8, a1, 0
    switch (read_mode) {
4037d6ce:	424326        	beqi	a3, 4, 4037d714 <spimem_flash_ll_set_read_mode+0x84>
4037d6d1:	1b53f6        	bgeui	a3, 5, 4037d6f0 <spimem_flash_ll_set_read_mode+0x60>
4037d6d4:	642326        	beqi	a3, 2, 4037d73c <spimem_flash_ll_set_read_mode+0xac>
4037d6d7:	0d33f6        	bgeui	a3, 3, 4037d6e8 <spimem_flash_ll_set_read_mode+0x58>
4037d6da:	072316        	beqz	a3, 4037d750 <spimem_flash_ll_set_read_mode+0xc0>
4037d6dd:	021366        	bnei	a3, 1, 4037d6e3 <spimem_flash_ll_set_read_mode+0x53>
4037d6e0:	004506        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
4037d6e3:	004386        	j	4037d7f5 <spimem_flash_ll_set_read_mode+0x165>
4037d6e6:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
4037d6e9:	33          	.byte	0x33
4037d6ea:	863c      	movi.n	a6, 56
4037d6ec:	000041        	l32r	a4, 4033d6ec <rom_rx_gain_force+0x3372c0>
4037d6ef:	b32600        	movgez	a2, a6, a0
4037d6f2:	181c70        	lsxp	f1, a12, a7
4037d6f5:	029387        	bne	a3, a8, 4037d6fb <spimem_flash_ll_set_read_mode+0x6b>
4037d6f8:	002a06        	j	4037d7a4 <spimem_flash_ll_set_read_mode+0x114>
4037d6fb:	025326        	beqi	a3, 5, 4037d701 <spimem_flash_ll_set_read_mode+0x71>
4037d6fe:	003cc6        	j	4037d7f5 <spimem_flash_ll_set_read_mode+0x165>
        ctrl.fread_qio = 1;
4037d701:	0020c0        	memw
4037d704:	0188      	l32i.n	a8, a1, 0
4037d706:	de0691        	l32r	a9, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4037d709:	208890        	or	a8, a8, a9
4037d70c:	0020c0        	memw
4037d70f:	0189      	s32i.n	a8, a1, 0
        break;
4037d711:	0038c6        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
        ctrl.fread_quad = 1;
4037d714:	0020c0        	memw
4037d717:	0188      	l32i.n	a8, a1, 0
4037d719:	ddfc91        	l32r	a9, 40374f0c <_iram_text_start+0xb08> (100000 <UserFrameTotalSize+0xfff00>)
4037d71c:	208890        	or	a8, a8, a9
4037d71f:	0020c0        	memw
4037d722:	0189      	s32i.n	a8, a1, 0
        break;
4037d724:	003406        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
4037d727:	20c000        	or	a12, a0, a0
        ctrl.fread_dio = 1;
4037d72a:	018800        	slli	a8, a8, 32
4037d72d:	dc8e91        	l32r	a9, 40374968 <_iram_text_start+0x564> (800000 <UserFrameTotalSize+0x7fff00>)
4037d730:	208890        	or	a8, a8, a9
4037d733:	0020c0        	memw
4037d736:	0189      	s32i.n	a8, a1, 0
        break;
4037d738:	002f06        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
4037d73b:	20c000        	or	a12, a0, a0
        ctrl.fread_dual = 1;
4037d73e:	018800        	slli	a8, a8, 32
4037d741:	db4891        	l32r	a9, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
4037d744:	208890        	or	a8, a8, a9
4037d747:	0020c0        	memw
4037d74a:	0189      	s32i.n	a8, a1, 0
        break;
4037d74c:	002a06        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
4037d74f:	20c000        	or	a12, a0, a0
        ctrl.fastrd_mode = 0;
4037d752:	018800        	slli	a8, a8, 32
4037d755:	dcbf91        	l32r	a9, 40374a54 <_iram_text_start+0x650> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4037d758:	108890        	and	a8, a8, a9
4037d75b:	0020c0        	memw
4037d75e:	0189      	s32i.n	a8, a1, 0
        break;
4037d760:	002506        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
4037d763:	20c000        	or	a12, a0, a0
        ctrl.faddr_oct = 1;
4037d766:	018800        	slli	a8, a8, 32
4037d769:	094c      	movi.n	a9, 64
4037d76b:	208890        	or	a8, a8, a9
4037d76e:	0020c0        	memw
4037d771:	0189      	s32i.n	a8, a1, 0
        ctrl.fcmd_oct = 1;
4037d773:	0020c0        	memw
4037d776:	0188      	l32i.n	a8, a1, 0
4037d778:	00a292        	movi	a9, 0x200
4037d77b:	208890        	or	a8, a8, a9
4037d77e:	0020c0        	memw
4037d781:	0189      	s32i.n	a8, a1, 0
        ctrl.fdin_oct = 1;
4037d783:	0020c0        	memw
4037d786:	0188      	l32i.n	a8, a1, 0
4037d788:	092c      	movi.n	a9, 32
4037d78a:	208890        	or	a8, a8, a9
4037d78d:	0020c0        	memw
4037d790:	0189      	s32i.n	a8, a1, 0
        ctrl.fdout_oct = 1;
4037d792:	0020c0        	memw
4037d795:	0188      	l32i.n	a8, a1, 0
4037d797:	091c      	movi.n	a9, 16
4037d799:	208890        	or	a8, a8, a9
4037d79c:	0020c0        	memw
4037d79f:	0189      	s32i.n	a8, a1, 0
        break;
4037d7a1:	0014c6        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
        ctrl.faddr_oct = 1;
4037d7a4:	0020c0        	memw
4037d7a7:	0188      	l32i.n	a8, a1, 0
4037d7a9:	094c      	movi.n	a9, 64
4037d7ab:	208890        	or	a8, a8, a9
4037d7ae:	0020c0        	memw
4037d7b1:	0189      	s32i.n	a8, a1, 0
        ctrl.fcmd_oct = 1;
4037d7b3:	0020c0        	memw
4037d7b6:	0188      	l32i.n	a8, a1, 0
4037d7b8:	00a292        	movi	a9, 0x200
4037d7bb:	208890        	or	a8, a8, a9
4037d7be:	0020c0        	memw
4037d7c1:	0189      	s32i.n	a8, a1, 0
        ctrl.fdin_oct = 1;
4037d7c3:	0020c0        	memw
4037d7c6:	0188      	l32i.n	a8, a1, 0
4037d7c8:	092c      	movi.n	a9, 32
4037d7ca:	208890        	or	a8, a8, a9
4037d7cd:	0020c0        	memw
4037d7d0:	0189      	s32i.n	a8, a1, 0
        ctrl.fdout_oct = 1;
4037d7d2:	0020c0        	memw
4037d7d5:	0188      	l32i.n	a8, a1, 0
4037d7d7:	091c      	movi.n	a9, 16
4037d7d9:	208890        	or	a8, a8, a9
4037d7dc:	0020c0        	memw
4037d7df:	0189      	s32i.n	a8, a1, 0
        dev->ddr.fmem_ddr_en = 1;
4037d7e1:	0020c0        	memw
4037d7e4:	382282        	l32i	a8, a2, 224
4037d7e7:	190c      	movi.n	a9, 1
4037d7e9:	208890        	or	a8, a8, a9
4037d7ec:	0020c0        	memw
4037d7ef:	386282        	s32i	a8, a2, 224
        break;
4037d7f2:	000086        	j	4037d7f8 <spimem_flash_ll_set_read_mode+0x168>
        abort();
4037d7f5:	024765        	call8	4037fc6c <abort>
    dev->ctrl.val = ctrl.val;
4037d7f8:	0020c0        	memw
4037d7fb:	002182        	l32i	a8, a1, 0
4037d7fe:	0020c0        	memw
4037d801:	026282        	s32i	a8, a2, 8
}
4037d804:	000090        	retw
	...

4037d808 <spimem_flash_ll_get_source_freq_mhz>:
{
4037d808:	004136        	entry	a1, 32
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4037d80b:	dbf381        	l32r	a8, 403747d8 <_iram_text_start+0x3d4> (60003000 <SPIMEM0>)
4037d80e:	0020c0        	memw
4037d811:	3b2882        	l32i	a8, a8, 236
4037d814:	148080        	extui	a8, a8, 0, 2
4037d817:	102826        	beqi	a8, 2, 4037d82b <spimem_flash_ll_get_source_freq_mhz+0x23>
4037d81a:	0738f6        	bgeui	a8, 3, 4037d825 <spimem_flash_ll_get_source_freq_mhz+0x1d>
4037d81d:	389c      	beqz.n	a8, 4037d834 <spimem_flash_ll_get_source_freq_mhz+0x2c>
4037d81f:	161826        	beqi	a8, 1, 4037d839 <spimem_flash_ll_get_source_freq_mhz+0x31>
4037d822:	000086        	j	4037d828 <spimem_flash_ll_get_source_freq_mhz+0x20>
4037d825:	173826        	beqi	a8, 3, 4037d840 <spimem_flash_ll_get_source_freq_mhz+0x38>
        abort();
4037d828:	024425        	call8	4037fc6c <abort>
        clock_val = 160;
4037d82b:	a0a022        	movi	a2, 160
4037d82e:	000446        	j	4037d843 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4037d831:	000000        	ill
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4037d834:	025c      	movi.n	a2, 80
4037d836:	000246        	j	4037d843 <spimem_flash_ll_get_source_freq_mhz+0x3b>
        clock_val = 120;
4037d839:	78a022        	movi	a2, 120
4037d83c:	0000c6        	j	4037d843 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4037d83f:	a02200        	addx4	a2, a2, a0
        clock_val = 240;
4037d842:	f01df0        	subx8	a1, a13, a15
4037d845:	000000        	ill

4037d848 <spimem_flash_ll_program_page>:
{
4037d848:	006136        	entry	a1, 48
    dev->user.usr_dummy = 0;
4037d84b:	0020c0        	memw
4037d84e:	6288      	l32i.n	a8, a2, 24
4037d850:	dbdc91        	l32r	a9, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037d853:	108890        	and	a8, a8, a9
4037d856:	0020c0        	memw
4037d859:	6289      	s32i.n	a8, a2, 24
    int num_words = (length + 3) / 4;
4037d85b:	543b      	addi.n	a5, a4, 3
4037d85d:	415250        	srli	a5, a5, 2
    for (int i = 0; i < num_words; i++) {
4037d860:	060c      	movi.n	a6, 0
4037d862:	000a86        	j	4037d890 <spimem_flash_ll_program_page+0x48>
        uint32_t word = 0;
4037d865:	080c      	movi.n	a8, 0
4037d867:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037d869:	470c      	movi.n	a7, 4
4037d86b:	637470        	minu	a7, a4, a7
        memcpy(&word, buffer, word_len);
4037d86e:	07cd      	mov.n	a12, a7
4037d870:	20b330        	or	a11, a3, a3
4037d873:	20a110        	or	a10, a1, a1
4037d876:	db2281        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037d879:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d87c:	14c682        	addi	a8, a6, 20
4037d87f:	a08820        	addx4	a8, a8, a2
4037d882:	0198      	l32i.n	a9, a1, 0
4037d884:	0020c0        	memw
4037d887:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037d889:	c04470        	sub	a4, a4, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037d88c:	373a      	add.n	a3, a7, a3
    for (int i = 0; i < num_words; i++) {
4037d88e:	661b      	addi.n	a6, a6, 1
4037d890:	d12657        	blt	a6, a5, 4037d865 <spimem_flash_ll_program_page+0x1d>
    dev->cmd.flash_pp = 1;
4037d893:	0020c0        	memw
4037d896:	0288      	l32i.n	a8, a2, 0
4037d898:	db6691        	l32r	a9, 40374630 <_iram_text_start+0x22c> (2000000 <UserFrameTotalSize+0x1ffff00>)
4037d89b:	208890        	or	a8, a8, a9
4037d89e:	0020c0        	memw
4037d8a1:	0289      	s32i.n	a8, a2, 0
}
4037d8a3:	f01d      	retw.n
4037d8a5:	000000        	ill

4037d8a8 <spi_flash_hal_configure_host_io_mode>:
{
4037d8a8:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d8ab:	12a8      	l32i.n	a10, a2, 4
    io_mode = io_mode & 0xFFFF;
4037d8ad:	f4b060        	extui	a11, a6, 0, 16
    dev->ctrl.fdummy_out = out_en;
4037d8b0:	0020c0        	memw
4037d8b3:	2a88      	l32i.n	a8, a10, 8
4037d8b5:	056f60        	extui	a6, a6, 31, 1
4037d8b8:	1166d0        	slli	a6, a6, 3
4037d8bb:	797c      	movi.n	a9, -9
4037d8bd:	108890        	and	a8, a8, a9
4037d8c0:	208860        	or	a8, a8, a6
4037d8c3:	0020c0        	memw
4037d8c6:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.q_pol = out_lev;
4037d8c8:	0020c0        	memw
4037d8cb:	2a88      	l32i.n	a8, a10, 8
4037d8cd:	dbbf91        	l32r	a9, 403747cc <_iram_text_start+0x3c8> (40000 <UserFrameTotalSize+0x3ff00>)
4037d8d0:	208890        	or	a8, a8, a9
4037d8d3:	0020c0        	memw
4037d8d6:	2a89      	s32i.n	a8, a10, 8
    dev->ctrl.d_pol = out_lev;
4037d8d8:	0020c0        	memw
4037d8db:	2a88      	l32i.n	a8, a10, 8
4037d8dd:	dc1691        	l32r	a9, 40374938 <_iram_text_start+0x534> (80000 <UserFrameTotalSize+0x7ff00>)
4037d8e0:	208890        	or	a8, a8, a9
4037d8e3:	0020c0        	memw
4037d8e6:	2a89      	s32i.n	a8, a10, 8
    if (command >= 0x100) {
4037d8e8:	ffa082        	movi	a8, 255
4037d8eb:	62b837        	bgeu	a8, a3, 4037d951 <spi_flash_hal_configure_host_io_mode+0xa9>
    dev->user.usr_command = 1;
4037d8ee:	0020c0        	memw
4037d8f1:	6a88      	l32i.n	a8, a10, 24
4037d8f3:	dbaf91        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d8f6:	208890        	or	a8, a8, a9
4037d8f9:	0020c0        	memw
4037d8fc:	6a89      	s32i.n	a8, a10, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
4037d8fe:	0020c0        	memw
4037d901:	8a88      	l32i.n	a8, a10, 32
4037d903:	0020c0        	memw
4037d906:	3189      	s32i.n	a8, a1, 12
4037d908:	0020c0        	memw
4037d90b:	3188      	l32i.n	a8, a1, 12
4037d90d:	f43030        	extui	a3, a3, 0, 16
4037d910:	f58080        	extui	a8, a8, 16, 16
4037d913:	118800        	slli	a8, a8, 16
4037d916:	208830        	or	a8, a8, a3
4037d919:	0020c0        	memw
4037d91c:	3189      	s32i.n	a8, a1, 12
4037d91e:	0020c0        	memw
4037d921:	3188      	l32i.n	a8, a1, 12
4037d923:	0020c0        	memw
4037d926:	8a89      	s32i.n	a8, a10, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037d928:	0020c0        	memw
4037d92b:	8a88      	l32i.n	a8, a10, 32
4037d92d:	0020c0        	memw
4037d930:	2189      	s32i.n	a8, a1, 8
4037d932:	0020c0        	memw
4037d935:	2188      	l32i.n	a8, a1, 8
4037d937:	dd7991        	l32r	a9, 40374f1c <_iram_text_start+0xb18> (f0000000 <_rtc_reserved_end+0x8ff00000>)
4037d93a:	208890        	or	a8, a8, a9
4037d93d:	0020c0        	memw
4037d940:	2189      	s32i.n	a8, a1, 8
4037d942:	0020c0        	memw
4037d945:	2188      	l32i.n	a8, a1, 8
4037d947:	0020c0        	memw
4037d94a:	8a89      	s32i.n	a8, a10, 32
}
4037d94c:	001946        	j	4037d9b5 <spi_flash_hal_configure_host_io_mode+0x10d>
4037d94f:	c00000        	sub	a0, a0, a0
    dev->user.usr_command = 1;
4037d952:	20          	.byte	0x20
4037d953:	6a8800        	maddn.s	f8, f8, f0
4037d956:	db9691        	l32r	a9, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037d959:	208890        	or	a8, a8, a9
4037d95c:	0020c0        	memw
4037d95f:	6a89      	s32i.n	a8, a10, 24
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_value, command);
4037d961:	0020c0        	memw
4037d964:	8a88      	l32i.n	a8, a10, 32
4037d966:	0020c0        	memw
4037d969:	1189      	s32i.n	a8, a1, 4
4037d96b:	0020c0        	memw
4037d96e:	1188      	l32i.n	a8, a1, 4
4037d970:	f43030        	extui	a3, a3, 0, 16
4037d973:	f58080        	extui	a8, a8, 16, 16
4037d976:	118800        	slli	a8, a8, 16
4037d979:	208830        	or	a8, a8, a3
4037d97c:	0020c0        	memw
4037d97f:	1189      	s32i.n	a8, a1, 4
4037d981:	0020c0        	memw
4037d984:	1188      	l32i.n	a8, a1, 4
4037d986:	0020c0        	memw
4037d989:	8a89      	s32i.n	a8, a10, 32
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user2, usr_command_bitlen, (bitlen - 1));
4037d98b:	0020c0        	memw
4037d98e:	8a88      	l32i.n	a8, a10, 32
4037d990:	0020c0        	memw
4037d993:	0189      	s32i.n	a8, a1, 0
4037d995:	0020c0        	memw
4037d998:	0188      	l32i.n	a8, a1, 0
4037d99a:	1188c0        	slli	a8, a8, 4
4037d99d:	418480        	srli	a8, a8, 4
4037d9a0:	db8591        	l32r	a9, 403747b4 <_iram_text_start+0x3b0> (70000000 <_rtc_reserved_end+0xff00000>)
4037d9a3:	208890        	or	a8, a8, a9
4037d9a6:	0020c0        	memw
4037d9a9:	0189      	s32i.n	a8, a1, 0
4037d9ab:	0020c0        	memw
4037d9ae:	0188      	l32i.n	a8, a1, 0
4037d9b0:	0020c0        	memw
4037d9b3:	8a89      	s32i.n	a8, a10, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d9b5:	e0c482        	addi	a8, a4, -32
4037d9b8:	0020c0        	memw
4037d9bb:	fa98      	l32i.n	a9, a10, 60
4037d9bd:	40f880        	nsau	a8, a8
4037d9c0:	418580        	srli	a8, a8, 5
4037d9c3:	888a      	add.n	a8, a8, a8
4037d9c5:	dc7c      	movi.n	a12, -3
4037d9c7:	1099c0        	and	a9, a9, a12
4037d9ca:	208980        	or	a8, a9, a8
4037d9cd:	0020c0        	memw
4037d9d0:	fa89      	s32i.n	a8, a10, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d9d2:	940b      	addi.n	a9, a4, -1
4037d9d4:	0020c0        	memw
4037d9d7:	7a88      	l32i.n	a8, a10, 28
4037d9d9:	019960        	slli	a9, a9, 26
4037d9dc:	1188a0        	slli	a8, a8, 6
4037d9df:	418680        	srli	a8, a8, 6
4037d9e2:	208890        	or	a8, a8, a9
4037d9e5:	0020c0        	memw
4037d9e8:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d9ea:	0020c0        	memw
4037d9ed:	6a88      	l32i.n	a8, a10, 24
4037d9ef:	190c      	movi.n	a9, 1
4037d9f1:	839440        	moveqz	a9, a4, a4
4037d9f4:	019920        	slli	a9, a9, 30
4037d9f7:	db70c1        	l32r	a12, 403747b8 <_iram_text_start+0x3b4> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037d9fa:	1088c0        	and	a8, a8, a12
4037d9fd:	208890        	or	a8, a8, a9
4037da00:	0020c0        	memw
4037da03:	6a89      	s32i.n	a8, a10, 24
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037da05:	0c0282        	l8ui	a8, a2, 12
4037da08:	585a      	add.n	a5, a8, a5
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037da0a:	0020c0        	memw
4037da0d:	6a88      	l32i.n	a8, a10, 24
4037da0f:	190c      	movi.n	a9, 1
4037da11:	839550        	moveqz	a9, a5, a5
4037da14:	019930        	slli	a9, a9, 29
4037da17:	db6ac1        	l32r	a12, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037da1a:	1088c0        	and	a8, a8, a12
4037da1d:	208890        	or	a8, a8, a9
4037da20:	0020c0        	memw
4037da23:	6a89      	s32i.n	a8, a10, 24
    if (dummy_n > 0) {
4037da25:	659c      	beqz.n	a5, 4037da3f <spi_flash_hal_configure_host_io_mode+0x197>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037da27:	550b      	addi.n	a5, a5, -1
4037da29:	0020c0        	memw
4037da2c:	7a88      	l32i.n	a8, a10, 28
4037da2e:	545050        	extui	a5, a5, 0, 6
4037da31:	c0af92        	movi	a9, -64
4037da34:	108890        	and	a8, a8, a9
4037da37:	208850        	or	a8, a8, a5
4037da3a:	0020c0        	memw
4037da3d:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_miso = bitlen > 0;
4037da3f:	0020c0        	memw
4037da42:	6a88      	l32i.n	a8, a10, 24
4037da44:	db6191        	l32r	a9, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037da47:	108890        	and	a8, a8, a9
4037da4a:	0020c0        	memw
4037da4d:	6a89      	s32i.n	a8, a10, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037da4f:	0020c0        	memw
4037da52:	aa88      	l32i.n	a8, a10, 40
4037da54:	00ac92        	movi	a9, 0xfffffc00
4037da57:	108890        	and	a8, a8, a9
4037da5a:	0020c0        	memw
4037da5d:	aa89      	s32i.n	a8, a10, 40
    dev->user.usr_mosi = bitlen > 0;
4037da5f:	0020c0        	memw
4037da62:	6a88      	l32i.n	a8, a10, 24
4037da64:	db58c1        	l32r	a12, 403747c4 <_iram_text_start+0x3c0> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037da67:	1088c0        	and	a8, a8, a12
4037da6a:	0020c0        	memw
4037da6d:	6a89      	s32i.n	a8, a10, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037da6f:	0020c0        	memw
4037da72:	9a88      	l32i.n	a8, a10, 36
4037da74:	108890        	and	a8, a8, a9
4037da77:	0020c0        	memw
4037da7a:	096a82        	s32i	a8, a10, 36
    spi_flash_ll_set_read_mode(dev, io_mode);
4037da7d:	ffc125        	call8	4037d690 <spimem_flash_ll_set_read_mode>
}
4037da80:	020c      	movi.n	a2, 0
4037da82:	f01d      	retw.n

4037da84 <spi_flash_hal_common_command>:
{
4037da84:	008136        	entry	a1, 64
4037da87:	028d      	mov.n	a8, a2
4037da89:	5129      	s32i.n	a2, a1, 20
    return ((spi_flash_hal_context_t*)host)->spi;
4037da8b:	1228      	l32i.n	a2, a2, 4
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037da8d:	58e8      	l32i.n	a14, a8, 20
    command = trans->command;
4037da8f:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037da92:	160372        	l8ui	a7, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037da95:	4388      	l32i.n	a8, a3, 16
4037da97:	016817        	bbci	a8, 1, 4037da9c <spi_flash_hal_common_command+0x18>
        io_mode = trans->io_mode;
4037da9a:	63e8      	l32i.n	a14, a3, 24
    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037da9c:	51a8      	l32i.n	a10, a1, 20
4037da9e:	0a88      	l32i.n	a8, a10, 0
4037daa0:	f888      	l32i.n	a8, a8, 60
4037daa2:	07dd      	mov.n	a13, a7
4037daa4:	0303c2        	l8ui	a12, a3, 3
4037daa7:	0008e0        	callx8	a8
    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037daaa:	1388      	l32i.n	a8, a3, 4
    dev->addr = addr;
4037daac:	0020c0        	memw
4037daaf:	1289      	s32i.n	a8, a2, 4
    if (trans->miso_len == 0) {
4037dab1:	020382        	l8ui	a8, a3, 2
4037dab4:	48fc      	bnez.n	a8, 4037daec <spi_flash_hal_common_command+0x68>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037dab6:	0020c0        	memw
4037dab9:	6288      	l32i.n	a8, a2, 24
4037dabb:	190c      	movi.n	a9, 1
4037dabd:	839770        	moveqz	a9, a7, a7
4037dac0:	019930        	slli	a9, a9, 29
4037dac3:	db3fa1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4037dac6:	1088a0        	and	a8, a8, a10
4037dac9:	208890        	or	a8, a8, a9
4037dacc:	0020c0        	memw
4037dacf:	6289      	s32i.n	a8, a2, 24
    if (dummy_n > 0) {
4037dad1:	779c      	beqz.n	a7, 4037daec <spi_flash_hal_common_command+0x68>
        dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037dad3:	770b      	addi.n	a7, a7, -1
4037dad5:	0020c0        	memw
4037dad8:	7288      	l32i.n	a8, a2, 28
4037dada:	547070        	extui	a7, a7, 0, 6
4037dadd:	c0af92        	movi	a9, -64
4037dae0:	108890        	and	a8, a8, a9
4037dae3:	208870        	or	a8, a8, a7
4037dae6:	0020c0        	memw
4037dae9:	076282        	s32i	a8, a2, 28
    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037daec:	0103a2        	l8ui	a10, a3, 1
4037daef:	118ad0        	slli	a8, a10, 3
    dev->user.usr_mosi = bitlen > 0;
4037daf2:	0020c0        	memw
4037daf5:	6298      	l32i.n	a9, a2, 24
4037daf7:	1b0c      	movi.n	a11, 1
4037daf9:	83baa0        	moveqz	a11, a10, a10
4037dafc:	01bb50        	slli	a11, a11, 27
4037daff:	db31c1        	l32r	a12, 403747c4 <_iram_text_start+0x3c0> (f7ffffff <_rtc_reserved_end+0x97efffff>)
4037db02:	1099c0        	and	a9, a9, a12
4037db05:	2099b0        	or	a9, a9, a11
4037db08:	0020c0        	memw
4037db0b:	6299      	s32i.n	a9, a2, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037db0d:	7a8c      	beqz.n	a10, 4037db18 <spi_flash_hal_common_command+0x94>
4037db0f:	880b      	addi.n	a8, a8, -1
4037db11:	948080        	extui	a8, a8, 0, 10
4037db14:	000086        	j	4037db1a <spi_flash_hal_common_command+0x96>
4037db17:	080c00        	lsx	f0, a12, a0
4037db1a:	0020c0        	memw
4037db1d:	9298      	l32i.n	a9, a2, 36
4037db1f:	00aca2        	movi	a10, 0xfffffc00
4037db22:	1099a0        	and	a9, a9, a10
4037db25:	208890        	or	a8, a8, a9
4037db28:	0020c0        	memw
4037db2b:	9289      	s32i.n	a8, a2, 36
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037db2d:	2348      	l32i.n	a4, a3, 8
4037db2f:	010352        	l8ui	a5, a3, 1
    int num_words = (length + 3) / 4;
4037db32:	853b      	addi.n	a8, a5, 3
4037db34:	418280        	srli	a8, a8, 2
4037db37:	4189      	s32i.n	a8, a1, 16
    for (int i = 0; i < num_words; i++) {
4037db39:	060c      	movi.n	a6, 0
4037db3b:	000a46        	j	4037db68 <spi_flash_hal_common_command+0xe4>
        uint32_t word = 0;
4037db3e:	080c      	movi.n	a8, 0
4037db40:	0189      	s32i.n	a8, a1, 0
        uint32_t word_len = MIN(length, sizeof(word));
4037db42:	470c      	movi.n	a7, 4
4037db44:	637570        	minu	a7, a5, a7
        memcpy(&word, buffer, word_len);
4037db47:	07cd      	mov.n	a12, a7
4037db49:	04bd      	mov.n	a11, a4
4037db4b:	20a110        	or	a10, a1, a1
4037db4e:	da6c81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037db51:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037db54:	14c682        	addi	a8, a6, 20
4037db57:	a08820        	addx4	a8, a8, a2
4037db5a:	0198      	l32i.n	a9, a1, 0
4037db5c:	0020c0        	memw
4037db5f:	2899      	s32i.n	a9, a8, 8
        length -= word_len;
4037db61:	c05570        	sub	a5, a5, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037db64:	474a      	add.n	a4, a7, a4
    for (int i = 0; i < num_words; i++) {
4037db66:	661b      	addi.n	a6, a6, 1
4037db68:	4188      	l32i.n	a8, a1, 16
4037db6a:	d02687        	blt	a6, a8, 4037db3e <spi_flash_hal_common_command+0xba>
    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037db6d:	0203a2        	l8ui	a10, a3, 2
4037db70:	118ad0        	slli	a8, a10, 3
    dev->user.usr_miso = bitlen > 0;
4037db73:	0020c0        	memw
4037db76:	6298      	l32i.n	a9, a2, 24
4037db78:	1b0c      	movi.n	a11, 1
4037db7a:	83baa0        	moveqz	a11, a10, a10
4037db7d:	01bb40        	slli	a11, a11, 28
4037db80:	db12c1        	l32r	a12, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037db83:	1099c0        	and	a9, a9, a12
4037db86:	2099b0        	or	a9, a9, a11
4037db89:	0020c0        	memw
4037db8c:	6299      	s32i.n	a9, a2, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037db8e:	6a8c      	beqz.n	a10, 4037db98 <spi_flash_hal_common_command+0x114>
4037db90:	880b      	addi.n	a8, a8, -1
4037db92:	948080        	extui	a8, a8, 0, 10
4037db95:	000046        	j	4037db9a <spi_flash_hal_common_command+0x116>
4037db98:	080c      	movi.n	a8, 0
4037db9a:	0020c0        	memw
4037db9d:	a298      	l32i.n	a9, a2, 40
4037db9f:	00aca2        	movi	a10, 0xfffffc00
4037dba2:	1099a0        	and	a9, a9, a10
4037dba5:	208890        	or	a8, a8, a9
4037dba8:	0020c0        	memw
4037dbab:	a289      	s32i.n	a8, a2, 40
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_PE_CMD) != 0) {
4037dbad:	4388      	l32i.n	a8, a3, 16
4037dbaf:	06e837        	bbsi	a8, 3, 4037dbb9 <spi_flash_hal_common_command+0x135>
    uint32_t usr_pe = (pe_ops ? 0x60000 : 0x40000);
4037dbb2:	db0691        	l32r	a9, 403747cc <_iram_text_start+0x3c8> (40000 <UserFrameTotalSize+0x3ff00>)
4037dbb5:	0000c6        	j	4037dbbc <spi_flash_hal_common_command+0x138>
4037dbb8:	649100        	extui	a9, a0, 1, 7
4037dbbb:	c0db      	addi.n	a12, a0, 13
    dev->cmd.val |= usr_pe;
4037dbbd:	20          	.byte	0x20
4037dbbe:	028800        	andb	b8, b8, b0
4037dbc1:	208890        	or	a8, a8, a9
4037dbc4:	0020c0        	memw
4037dbc7:	0289      	s32i.n	a8, a2, 0
    host->driver->poll_cmd_done(host);
4037dbc9:	51a8      	l32i.n	a10, a1, 20
4037dbcb:	002a82        	l32i	a8, a10, 0
4037dbce:	102882        	l32i	a8, a8, 64
4037dbd1:	0008e0        	callx8	a8
    if (trans->miso_len > 0) {
4037dbd4:	020342        	l8ui	a4, a3, 2
4037dbd7:	052416        	beqz	a4, 4037dc2d <spi_flash_hal_common_command+0x1a9>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037dbda:	3358      	l32i.n	a5, a3, 12
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037dbdc:	148050        	extui	a8, a5, 0, 2
4037dbdf:	58dc      	bnez.n	a8, 4037dbf8 <spi_flash_hal_common_command+0x174>
4037dbe1:	148040        	extui	a8, a4, 0, 2
4037dbe4:	08dc      	bnez.n	a8, 4037dbf8 <spi_flash_hal_common_command+0x174>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037dbe6:	04cd      	mov.n	a12, a4
4037dbe8:	58c2b2        	addi	a11, a2, 88
4037dbeb:	20a550        	or	a10, a5, a5
4037dbee:	da4481        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037dbf1:	0008e0        	callx8	a8
4037dbf4:	000d46        	j	4037dc2d <spi_flash_hal_common_command+0x1a9>
4037dbf7:	043d00        	extui	a3, a0, 13, 1
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dbfa:	060c      	movi.n	a6, 0
4037dbfc:	000946        	j	4037dc25 <spi_flash_hal_common_command+0x1a1>
4037dbff:	470c00        	ee.stf.64.xp	f0, f4, a0, a12
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037dc02:	637370        	minu	a7, a3, a7
            uint32_t word = dev->data_buf[i];
4037dc05:	14c682        	addi	a8, a6, 20
4037dc08:	a08820        	addx4	a8, a8, a2
4037dc0b:	0020c0        	memw
4037dc0e:	2888      	l32i.n	a8, a8, 8
4037dc10:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037dc12:	07cd      	mov.n	a12, a7
4037dc14:	01bd      	mov.n	a11, a1
4037dc16:	05ad      	mov.n	a10, a5
4037dc18:	da3a81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037dc1b:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037dc1e:	575a      	add.n	a5, a7, a5
            copy_len -= word_len;
4037dc20:	c03370        	sub	a3, a3, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dc23:	661b      	addi.n	a6, a6, 1
4037dc25:	843b      	addi.n	a8, a4, 3
4037dc27:	418280        	srli	a8, a8, 2
4037dc2a:	d23687        	bltu	a6, a8, 4037dc00 <spi_flash_hal_common_command+0x17c>
}
4037dc2d:	020c      	movi.n	a2, 0
4037dc2f:	f01d      	retw.n
4037dc31:	000000        	ill

4037dc34 <spi_flash_hal_read>:
{
4037dc34:	006136        	entry	a1, 48
4037dc37:	02ad      	mov.n	a10, a2
4037dc39:	052d      	mov.n	a2, a5
    return ((spi_flash_hal_context_t*)host)->spi;
4037dc3b:	1a58      	l32i.n	a5, a10, 4
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037dc3d:	0020c0        	memw
4037dc40:	062582        	l32i	a8, a5, 24
4037dc43:	0578e7        	bbci	a8, 30, 4037dc4c <spi_flash_hal_read+0x18>
4037dc46:	0020c0        	memw
4037dc49:	072582        	l32i	a8, a5, 28
    dev->addr = addr;
4037dc4c:	0020c0        	memw
4037dc4f:	1549      	s32i.n	a4, a5, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037dc51:	1182d0        	slli	a8, a2, 3
    dev->user.usr_miso = bitlen > 0;
4037dc54:	0020c0        	memw
4037dc57:	6598      	l32i.n	a9, a5, 24
4037dc59:	1b0c      	movi.n	a11, 1
4037dc5b:	83b880        	moveqz	a11, a8, a8
4037dc5e:	01bb40        	slli	a11, a11, 28
4037dc61:	dad9c1        	l32r	a12, 403747c8 <_iram_text_start+0x3c4> (efffffff <_rtc_reserved_end+0x8fefffff>)
4037dc64:	1099c0        	and	a9, a9, a12
4037dc67:	2099b0        	or	a9, a9, a11
4037dc6a:	0020c0        	memw
4037dc6d:	6599      	s32i.n	a9, a5, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037dc6f:	688c      	beqz.n	a8, 4037dc79 <spi_flash_hal_read+0x45>
4037dc71:	880b      	addi.n	a8, a8, -1
4037dc73:	948080        	extui	a8, a8, 0, 10
4037dc76:	000046        	j	4037dc7b <spi_flash_hal_read+0x47>
4037dc79:	080c      	movi.n	a8, 0
4037dc7b:	0020c0        	memw
4037dc7e:	a598      	l32i.n	a9, a5, 40
4037dc80:	00acb2        	movi	a11, 0xfffffc00
4037dc83:	1099b0        	and	a9, a9, a11
4037dc86:	208890        	or	a8, a8, a9
4037dc89:	0020c0        	memw
4037dc8c:	a589      	s32i.n	a8, a5, 40
    dev->cmd.val |= usr_pe;
4037dc8e:	0020c0        	memw
4037dc91:	0588      	l32i.n	a8, a5, 0
4037dc93:	dace91        	l32r	a9, 403747cc <_iram_text_start+0x3c8> (40000 <UserFrameTotalSize+0x3ff00>)
4037dc96:	208890        	or	a8, a8, a9
4037dc99:	0020c0        	memw
4037dc9c:	006582        	s32i	a8, a5, 0
    host->driver->poll_cmd_done(host);
4037dc9f:	002a82        	l32i	a8, a10, 0
4037dca2:	102882        	l32i	a8, a8, 64
4037dca5:	0008e0        	callx8	a8
    if (read_len > 0) {
4037dca8:	051216        	beqz	a2, 4037dcfd <spi_flash_hal_read+0xc9>
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037dcab:	148030        	extui	a8, a3, 0, 2
4037dcae:	68dc      	bnez.n	a8, 4037dcc8 <spi_flash_hal_read+0x94>
4037dcb0:	148020        	extui	a8, a2, 0, 2
4037dcb3:	18dc      	bnez.n	a8, 4037dcc8 <spi_flash_hal_read+0x94>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037dcb5:	20c220        	or	a12, a2, a2
4037dcb8:	58c5b2        	addi	a11, a5, 88
4037dcbb:	20a330        	or	a10, a3, a3
4037dcbe:	da1081        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037dcc1:	0008e0        	callx8	a8
4037dcc4:	000d46        	j	4037dcfd <spi_flash_hal_read+0xc9>
4037dcc7:	024d00        	andb	b4, b13, b0
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dcca:	060c      	movi.n	a6, 0
4037dccc:	000946        	j	4037dcf5 <spi_flash_hal_read+0xc1>
4037dccf:	470c00        	ee.stf.64.xp	f0, f4, a0, a12
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037dcd2:	637470        	minu	a7, a4, a7
            uint32_t word = dev->data_buf[i];
4037dcd5:	14c682        	addi	a8, a6, 20
4037dcd8:	a08850        	addx4	a8, a8, a5
4037dcdb:	0020c0        	memw
4037dcde:	2888      	l32i.n	a8, a8, 8
4037dce0:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037dce2:	07cd      	mov.n	a12, a7
4037dce4:	01bd      	mov.n	a11, a1
4037dce6:	03ad      	mov.n	a10, a3
4037dce8:	da0681        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037dceb:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + word_len);
4037dcee:	373a      	add.n	a3, a7, a3
            copy_len -= word_len;
4037dcf0:	c04470        	sub	a4, a4, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037dcf3:	661b      	addi.n	a6, a6, 1
4037dcf5:	823b      	addi.n	a8, a2, 3
4037dcf7:	418280        	srli	a8, a8, 2
4037dcfa:	d23687        	bltu	a6, a8, 4037dcd0 <spi_flash_hal_read+0x9c>
}
4037dcfd:	020c      	movi.n	a2, 0
4037dcff:	f01d      	retw.n
4037dd01:	000000        	ill

4037dd04 <spi_flash_hal_erase_chip>:
//  - MEMSPI
//  - SPI1~3 on ESP32/S2/S3/C3/H4/C2
// The common part is in spi_flash_hal_common.inc

void spi_flash_hal_erase_chip(spi_flash_host_inst_t *host)
{
4037dd04:	004136        	entry	a1, 32
4037dd07:	02ad      	mov.n	a10, a2
    return ((spi_flash_hal_context_t*)host)->spi;
4037dd09:	1298      	l32i.n	a9, a2, 4
    dev->cmd.flash_ce = 1;
4037dd0b:	0020c0        	memw
4037dd0e:	0988      	l32i.n	a8, a9, 0
4037dd10:	dc86b1        	l32r	a11, 40374f28 <_iram_text_start+0xb24> (400000 <UserFrameTotalSize+0x3fff00>)
4037dd13:	2088b0        	or	a8, a8, a11
4037dd16:	0020c0        	memw
4037dd19:	0989      	s32i.n	a8, a9, 0
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_erase_chip(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037dd1b:	6288      	l32i.n	a8, a2, 24
4037dd1d:	07e807        	bbsi	a8, 0, 4037dd28 <spi_flash_hal_erase_chip+0x24>
        host->driver->poll_cmd_done(host);
4037dd20:	0288      	l32i.n	a8, a2, 0
4037dd22:	102882        	l32i	a8, a8, 64
4037dd25:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037dd28:	f01d      	retw.n
	...

4037dd2c <spi_flash_hal_erase_sector>:

// Only support 24bit address
void spi_flash_hal_erase_sector(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037dd2c:	004136        	entry	a1, 32
4037dd2f:	02ad      	mov.n	a10, a2
4037dd31:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037dd33:	0020c0        	memw
4037dd36:	f898      	l32i.n	a9, a8, 60
4037dd38:	db7c      	movi.n	a11, -3
4037dd3a:	1099b0        	and	a9, a9, a11
4037dd3d:	0020c0        	memw
4037dd40:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037dd42:	0020c0        	memw
4037dd45:	7898      	l32i.n	a9, a8, 28
4037dd47:	1199a0        	slli	a9, a9, 6
4037dd4a:	419690        	srli	a9, a9, 6
4037dd4d:	dc77b1        	l32r	a11, 40374f2c <_iram_text_start+0xb28> (5c000000 <_rtc_bss_end+0xc000000>)
4037dd50:	2099b0        	or	a9, a9, a11
4037dd53:	0020c0        	memw
4037dd56:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037dd58:	0020c0        	memw
4037dd5b:	6898      	l32i.n	a9, a8, 24
4037dd5d:	da21b1        	l32r	a11, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037dd60:	2099b0        	or	a9, a9, a11
4037dd63:	0020c0        	memw
4037dd66:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037dd68:	113380        	slli	a3, a3, 8
4037dd6b:	413830        	srli	a3, a3, 8
    dev->addr = addr;
4037dd6e:	0020c0        	memw
4037dd71:	1839      	s32i.n	a3, a8, 4
    dev->ctrl.val = 0;
4037dd73:	090c      	movi.n	a9, 0
4037dd75:	0020c0        	memw
4037dd78:	2899      	s32i.n	a9, a8, 8
    dev->cmd.flash_se = 1;
4037dd7a:	0020c0        	memw
4037dd7d:	0898      	l32i.n	a9, a8, 0
4037dd7f:	dc68b1        	l32r	a11, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4037dd82:	2099b0        	or	a9, a9, a11
4037dd85:	0020c0        	memw
4037dd88:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_sector(dev);

#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037dd8a:	6288      	l32i.n	a8, a2, 24
4037dd8c:	08e807        	bbsi	a8, 0, 4037dd98 <spi_flash_hal_erase_sector+0x6c>
        host->driver->poll_cmd_done(host);
4037dd8f:	002282        	l32i	a8, a2, 0
4037dd92:	102882        	l32i	a8, a8, 64
4037dd95:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037dd98:	f01d      	retw.n
	...

4037dd9c <spi_flash_hal_erase_block>:

// Only support 24bit address
void spi_flash_hal_erase_block(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037dd9c:	004136        	entry	a1, 32
4037dd9f:	02ad      	mov.n	a10, a2
4037dda1:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037dda3:	0020c0        	memw
4037dda6:	f898      	l32i.n	a9, a8, 60
4037dda8:	db7c      	movi.n	a11, -3
4037ddaa:	1099b0        	and	a9, a9, a11
4037ddad:	0020c0        	memw
4037ddb0:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037ddb2:	0020c0        	memw
4037ddb5:	7898      	l32i.n	a9, a8, 28
4037ddb7:	1199a0        	slli	a9, a9, 6
4037ddba:	419690        	srli	a9, a9, 6
4037ddbd:	dc5bb1        	l32r	a11, 40374f2c <_iram_text_start+0xb28> (5c000000 <_rtc_bss_end+0xc000000>)
4037ddc0:	2099b0        	or	a9, a9, a11
4037ddc3:	0020c0        	memw
4037ddc6:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037ddc8:	0020c0        	memw
4037ddcb:	6898      	l32i.n	a9, a8, 24
4037ddcd:	da05b1        	l32r	a11, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037ddd0:	2099b0        	or	a9, a9, a11
4037ddd3:	0020c0        	memw
4037ddd6:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037ddd8:	113380        	slli	a3, a3, 8
4037dddb:	413830        	srli	a3, a3, 8
    dev->addr = addr;
4037ddde:	0020c0        	memw
4037dde1:	1839      	s32i.n	a3, a8, 4
    dev->cmd.flash_be = 1;
4037dde3:	0020c0        	memw
4037dde6:	0898      	l32i.n	a9, a8, 0
4037dde8:	dae0b1        	l32r	a11, 40374968 <_iram_text_start+0x564> (800000 <UserFrameTotalSize+0x7fff00>)
4037ddeb:	2099b0        	or	a9, a9, a11
4037ddee:	0020c0        	memw
4037ddf1:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_block(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037ddf3:	6288      	l32i.n	a8, a2, 24
4037ddf5:	07e807        	bbsi	a8, 0, 4037de00 <spi_flash_hal_erase_block+0x64>
        host->driver->poll_cmd_done(host);
4037ddf8:	0288      	l32i.n	a8, a2, 0
4037ddfa:	102882        	l32i	a8, a8, 64
4037ddfd:	0008e0        	callx8	a8
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037de00:	f01d      	retw.n
	...

4037de04 <spi_flash_hal_program_page>:

// Only support 24bit address
void spi_flash_hal_program_page(spi_flash_host_inst_t *host, const void *buffer, uint32_t address, uint32_t length)
{
4037de04:	004136        	entry	a1, 32
4037de07:	03bd      	mov.n	a11, a3
4037de09:	05cd      	mov.n	a12, a5
4037de0b:	12a8      	l32i.n	a10, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037de0d:	0020c0        	memw
4037de10:	fa88      	l32i.n	a8, a10, 60
4037de12:	d97c      	movi.n	a9, -3
4037de14:	108890        	and	a8, a8, a9
4037de17:	0020c0        	memw
4037de1a:	fa89      	s32i.n	a8, a10, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037de1c:	0020c0        	memw
4037de1f:	7a88      	l32i.n	a8, a10, 28
4037de21:	1188a0        	slli	a8, a8, 6
4037de24:	418680        	srli	a8, a8, 6
4037de27:	dc4191        	l32r	a9, 40374f2c <_iram_text_start+0xb28> (5c000000 <_rtc_bss_end+0xc000000>)
4037de2a:	208890        	or	a8, a8, a9
4037de2d:	0020c0        	memw
4037de30:	7a89      	s32i.n	a8, a10, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037de32:	0020c0        	memw
4037de35:	6a88      	l32i.n	a8, a10, 24
4037de37:	d9eb91        	l32r	a9, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037de3a:	208890        	or	a8, a8, a9
4037de3d:	0020c0        	memw
4037de40:	6a89      	s32i.n	a8, a10, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, (address & ADDRESS_MASK_24BIT) | (length << 24));
4037de42:	114480        	slli	a4, a4, 8
4037de45:	414840        	srli	a4, a4, 8
4037de48:	018580        	slli	a8, a5, 24
4037de4b:	204480        	or	a4, a4, a8
    dev->addr = addr;
4037de4e:	0020c0        	memw
4037de51:	1a49      	s32i.n	a4, a10, 4
    spi_flash_ll_program_page(dev, buffer, length);
4037de53:	ff9f65        	call8	4037d848 <spimem_flash_ll_program_page>
    host->driver->poll_cmd_done(host);
4037de56:	0288      	l32i.n	a8, a2, 0
4037de58:	102882        	l32i	a8, a8, 64
4037de5b:	02ad      	mov.n	a10, a2
4037de5d:	0008e0        	callx8	a8
}
4037de60:	f01d      	retw.n
	...

4037de64 <spi_flash_hal_set_write_protect>:

esp_err_t spi_flash_hal_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
4037de64:	004136        	entry	a1, 32
4037de67:	02ad      	mov.n	a10, a2
4037de69:	743030        	extui	a3, a3, 0, 8
4037de6c:	1288      	l32i.n	a8, a2, 4
    if (wp) {
4037de6e:	239c      	beqz.n	a3, 4037de84 <spi_flash_hal_set_write_protect+0x20>
        dev->cmd.flash_wrdi = 1;
4037de70:	0020c0        	memw
4037de73:	0898      	l32i.n	a9, a8, 0
4037de75:	dac7b1        	l32r	a11, 40374994 <_iram_text_start+0x590> (20000000 <UserFrameTotalSize+0x1fffff00>)
4037de78:	2099b0        	or	a9, a9, a11
4037de7b:	0020c0        	memw
4037de7e:	0899      	s32i.n	a9, a8, 0
4037de80:	000406        	j	4037de94 <spi_flash_hal_set_write_protect+0x30>
4037de83:	20c000        	or	a12, a0, a0
        dev->cmd.flash_wren = 1;
4037de86:	089800        	lsx	f9, a8, a0
4037de89:	d9d6b1        	l32r	a11, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037de8c:	2099b0        	or	a9, a9, a11
4037de8f:	0020c0        	memw
4037de92:	0899      	s32i.n	a9, a8, 0
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_write_protect(dev, wp);
    host->driver->poll_cmd_done(host);
4037de94:	0a88      	l32i.n	a8, a10, 0
4037de96:	102882        	l32i	a8, a8, 64
4037de99:	0008e0        	callx8	a8
    return ESP_OK;
}
4037de9c:	020c      	movi.n	a2, 0
4037de9e:	f01d      	retw.n

4037dea0 <spi_flash_hal_setup_read_suspend>:
    //status and sus_status should be mutual exclusion
    return (status | sus_status);
}

esp_err_t spi_flash_hal_setup_read_suspend(spi_flash_host_inst_t *host, const spi_flash_sus_cmd_conf *sus_conf)
{
4037dea0:	006136        	entry	a1, 48
#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    spi_mem_dev_t *dev = (spi_mem_dev_t *)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    memcpy(&(ctx->sus_cfg), sus_conf, sizeof(spi_flash_sus_cmd_conf));
4037dea3:	8c0c      	movi.n	a12, 8
4037dea5:	03bd      	mov.n	a11, a3
4037dea7:	1cc2a2        	addi	a10, a2, 28
4037deaa:	d99581        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037dead:	0008e0        	callx8	a8
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_sus_ctrl, flash_pes_command, sus_cmd);
4037deb0:	da3e91        	l32r	a9, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037deb3:	0020c0        	memw
4037deb6:	282982        	l32i	a8, a9, 160
4037deb9:	0020c0        	memw
4037debc:	0189      	s32i.n	a8, a1, 0
4037debe:	0020c0        	memw
4037dec1:	0188      	l32i.n	a8, a1, 0
4037dec3:	0503a2        	l8ui	a10, a3, 5
4037dec6:	11aa70        	slli	a10, a10, 9
4037dec9:	dc19b1        	l32r	a11, 40374f30 <_iram_text_start+0xb2c> (fffe01ff <_rtc_reserved_end+0x9fee01ff>)
4037decc:	1088b0        	and	a8, a8, a11
4037decf:	2088a0        	or	a8, a8, a10
4037ded2:	0020c0        	memw
4037ded5:	0189      	s32i.n	a8, a1, 0
4037ded7:	0020c0        	memw
4037deda:	0188      	l32i.n	a8, a1, 0
4037dedc:	0020c0        	memw
4037dedf:	286982        	s32i	a8, a9, 160
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_sus_ctrl, flash_per_command, res_cmd);
4037dee2:	0020c0        	memw
4037dee5:	282982        	l32i	a8, a9, 160
4037dee8:	0020c0        	memw
4037deeb:	1189      	s32i.n	a8, a1, 4
4037deed:	0020c0        	memw
4037def0:	1188      	l32i.n	a8, a1, 4
4037def2:	0603a2        	l8ui	a10, a3, 6
4037def5:	aaaa      	add.n	a10, a10, a10
4037def7:	01aeb2        	movi	a11, 0xfffffe01
4037defa:	1088b0        	and	a8, a8, a11
4037defd:	2088a0        	or	a8, a8, a10
4037df00:	0020c0        	memw
4037df03:	1189      	s32i.n	a8, a1, 4
4037df05:	0020c0        	memw
4037df08:	1188      	l32i.n	a8, a1, 4
4037df0a:	0020c0        	memw
4037df0d:	286982        	s32i	a8, a9, 160
    spimem_flash_ll_set_read_sus_status(dev, sus_conf->sus_mask);
    spimem_flash_ll_rd_sus_cmd_setup(dev, sus_conf->cmd_rdsr);
#endif // SOC_SPI_MEM_SUPPORT_CHECK_SUS
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    return ESP_OK;
}
4037df10:	020c      	movi.n	a2, 0
4037df12:	f01d      	retw.n

4037df14 <spi_flash_hal_setup_auto_suspend_mode>:

#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
void spi_flash_hal_setup_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037df14:	006136        	entry	a1, 48
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    bool pes_waiti_delay = ctx->auto_waiti_pes ? false : true;
4037df17:	2d02a2        	l8ui	a10, a2, 45
4037df1a:	180c      	movi.n	a8, 1
4037df1c:	30aa80        	xor	a10, a10, a8
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05);
4037df1f:	da2281        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037df22:	0020c0        	memw
4037df25:	262892        	l32i	a9, a8, 152
4037df28:	0020c0        	memw
4037df2b:	0199      	s32i.n	a9, a1, 0
4037df2d:	0020c0        	memw
4037df30:	0198      	l32i.n	a9, a1, 0
4037df32:	03acb2        	movi	a11, 0xfffffc03
4037df35:	1099b0        	and	a9, a9, a11
4037df38:	4b1c      	movi.n	a11, 20
4037df3a:	2099b0        	or	a9, a9, a11
4037df3d:	0020c0        	memw
4037df40:	0199      	s32i.n	a9, a1, 0
4037df42:	0020c0        	memw
4037df45:	0198      	l32i.n	a9, a1, 0
4037df47:	0020c0        	memw
4037df4a:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = (per_waiti | pes_waiti);  // enable auto wait-idle function.
4037df4d:	0020c0        	memw
4037df50:	262892        	l32i	a9, a8, 152
4037df53:	1b0c      	movi.n	a11, 1
4037df55:	2099b0        	or	a9, a9, a11
4037df58:	0020c0        	memw
4037df5b:	266892        	s32i	a9, a8, 152
    dev->flash_sus_cmd.flash_per_wait_en = per_waiti;
4037df5e:	0020c0        	memw
4037df61:	272892        	l32i	a9, a8, 156
4037df64:	4b0c      	movi.n	a11, 4
4037df66:	2099b0        	or	a9, a9, a11
4037df69:	0020c0        	memw
4037df6c:	276892        	s32i	a9, a8, 156
    dev->flash_sus_cmd.flash_pes_wait_en = pes_waiti;
4037df6f:	0020c0        	memw
4037df72:	272892        	l32i	a9, a8, 156
4037df75:	04a0a0        	extui	a10, a10, 0, 1
4037df78:	11aad0        	slli	a10, a10, 3
4037df7b:	7b7c      	movi.n	a11, -9
4037df7d:	1099b0        	and	a9, a9, a11
4037df80:	2099a0        	or	a9, a9, a10
4037df83:	0020c0        	memw
4037df86:	276892        	s32i	a9, a8, 156
    spimem_flash_ll_auto_wait_idle_init(dev, true, pes_waiti_delay);
    if (ctx->freq_mhz == 120) {
4037df89:	a298      	l32i.n	a9, a2, 40
4037df8b:	78a082        	movi	a8, 120
4037df8e:	4e9987        	bne	a9, a8, 4037dfe0 <spi_flash_hal_setup_auto_suspend_mode+0xcc>
        spimem_flash_ll_set_wait_idle_dummy_phase(dev, ctx->extra_dummy);
4037df91:	0c0282        	l8ui	a8, a2, 12
    if (extra_dummy > 0) {
4037df94:	48bc      	beqz.n	a8, 4037dfcc <spi_flash_hal_setup_auto_suspend_mode+0xb8>
        dev->flash_waiti_ctrl.waiti_dummy_cyclelen = extra_dummy - 1;
4037df96:	880b      	addi.n	a8, a8, -1
4037df98:	da04a1        	l32r	a10, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037df9b:	0020c0        	memw
4037df9e:	262a92        	l32i	a9, a10, 152
4037dfa1:	548080        	extui	a8, a8, 0, 6
4037dfa4:	118860        	slli	a8, a8, 10
4037dfa7:	dbe3b1        	l32r	a11, 40374f34 <_iram_text_start+0xb30> (ffff03ff <_rtc_reserved_end+0x9fef03ff>)
4037dfaa:	1099b0        	and	a9, a9, a11
4037dfad:	208980        	or	a8, a9, a8
4037dfb0:	0020c0        	memw
4037dfb3:	266a82        	s32i	a8, a10, 152
        dev->flash_waiti_ctrl.waiti_dummy = 1;
4037dfb6:	0020c0        	memw
4037dfb9:	262a82        	l32i	a8, a10, 152
4037dfbc:	290c      	movi.n	a9, 2
4037dfbe:	208890        	or	a8, a8, a9
4037dfc1:	0020c0        	memw
4037dfc4:	266a82        	s32i	a8, a10, 152
4037dfc7:	000546        	j	4037dfe0 <spi_flash_hal_setup_auto_suspend_mode+0xcc>
4037dfca:	910000        	srl	a0, a0
        dev->flash_waiti_ctrl.waiti_dummy = 0;
4037dfcd:	c0d9f7        	bbs	a9, a15, 4037df91 <spi_flash_hal_setup_auto_suspend_mode+0x7d>
4037dfd0:	820020        	mull	a0, a0, a2
4037dfd3:	2629      	s32i.n	a2, a6, 8
4037dfd5:	da7c      	movi.n	a10, -3
4037dfd7:	1088a0        	and	a8, a8, a10
4037dfda:	0020c0        	memw
4037dfdd:	266982        	s32i	a8, a9, 152
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037dfe0:	d9f281        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037dfe3:	0020c0        	memw
4037dfe6:	282892        	l32i	a9, a8, 160
4037dfe9:	1a0c      	movi.n	a10, 1
4037dfeb:	2099a0        	or	a9, a9, a10
4037dfee:	0020c0        	memw
4037dff1:	286892        	s32i	a9, a8, 160
    dev->flash_sus_cmd.pes_per_en = auto_sus;
4037dff4:	0020c0        	memw
4037dff7:	272892        	l32i	a9, a8, 156
4037dffa:	0a1c      	movi.n	a10, 16
4037dffc:	2099a0        	or	a9, a9, a10
4037dfff:	0020c0        	memw
4037e002:	276892        	s32i	a9, a8, 156
    }
    spimem_flash_ll_auto_suspend_init(dev, true);
    // tsus = ceil(ctx->tsus_val * ctx->freq_mhz / spimem_flash_ll_get_tsus_unit_in_cycles);
    uint32_t tsus = (ctx->tsus_val * ctx->freq_mhz / spimem_flash_ll_get_tsus_unit_in_cycles(dev)) + ((ctx->tsus_val * ctx->freq_mhz) % spimem_flash_ll_get_tsus_unit_in_cycles(dev) != 0);
4037e005:	2c0292        	l8ui	a9, a2, 44
4037e008:	a2a8      	l32i.n	a10, a2, 40
4037e00a:	8299a0        	mull	a9, a9, a10
    if (dev->sus_status.flash_pes_dly_256 == 1) {
4037e00d:	0020c0        	memw
4037e010:	292882        	l32i	a8, a8, 164
4037e013:	056867        	bbci	a8, 6, 4037e01c <spi_flash_hal_setup_auto_suspend_mode+0x108>
        tsus_unit = 256;
4037e016:	00a182        	movi	a8, 0x100
4037e019:	000046        	j	4037e01e <spi_flash_hal_setup_auto_suspend_mode+0x10a>
        tsus_unit = 4;
4037e01c:	480c      	movi.n	a8, 4
4037e01e:	c28980        	quou	a8, a9, a8
    if (dev->sus_status.flash_pes_dly_256 == 1) {
4037e021:	d9e1a1        	l32r	a10, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037e024:	0020c0        	memw
4037e027:	292aa2        	l32i	a10, a10, 164
4037e02a:	066a67        	bbci	a10, 6, 4037e034 <spi_flash_hal_setup_auto_suspend_mode+0x120>
        tsus_unit = 256;
4037e02d:	00a1a2        	movi	a10, 0x100
4037e030:	0000c6        	j	4037e037 <spi_flash_hal_setup_auto_suspend_mode+0x123>
4037e033:	a0a200        	addx4	a10, a2, a0
        tsus_unit = 4;
4037e036:	99a004        	ee.vld.l.64.ip	q3, a0, 0x100
4037e039:	a052e2        	s16i	a14, a2, 0x140
4037e03c:	040c01        	l32r	a0, 4033f06c <rom_rx_gain_force+0x338c40>
4037e03f:	04ad      	mov.n	a10, a4
4037e041:	93a590        	movnez	a10, a5, a9
4037e044:	88aa      	add.n	a8, a8, a10
    dev->ctrl1.cs_hold_dly_res = dly_val;
4037e046:	d9d8a1        	l32r	a10, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037e049:	0020c0        	memw
4037e04c:	3a98      	l32i.n	a9, a10, 12
4037e04e:	948080        	extui	a8, a8, 0, 10
4037e051:	1188e0        	slli	a8, a8, 2
4037e054:	dbb9b1        	l32r	a11, 40374f38 <_iram_text_start+0xb34> (fffff003 <_rtc_reserved_end+0x9feff003>)
4037e057:	1099b0        	and	a9, a9, a11
4037e05a:	208980        	or	a8, a9, a8
4037e05d:	0020c0        	memw
4037e060:	3a89      	s32i.n	a8, a10, 12
    dev->sus_status.flash_per_dly_256 = 1;
4037e062:	0020c0        	memw
4037e065:	292a82        	l32i	a8, a10, 164
4037e068:	092c      	movi.n	a9, 32
4037e06a:	208890        	or	a8, a8, a9
4037e06d:	0020c0        	memw
4037e070:	296a82        	s32i	a8, a10, 164
    dev->sus_status.flash_pes_dly_256 = 1;
4037e073:	0020c0        	memw
4037e076:	292a82        	l32i	a8, a10, 164
4037e079:	094c      	movi.n	a9, 64
4037e07b:	208890        	or	a8, a8, a9
4037e07e:	0020c0        	memw
4037e081:	296a82        	s32i	a8, a10, 164
    spimem_flash_ll_set_sus_delay(dev, tsus);
    // tshsl2 = ceil(SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz() * 0.001);
    uint32_t tshsl2 = (SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz() / 1000) + ((SPI_FLASH_TSHSL2_SAFE_VAL_NS * spimem_flash_ll_get_source_freq_mhz()) % 1000 != 0);
4037e084:	ff7825        	call8	4037d808 <spimem_flash_ll_get_source_freq_mhz>
4037e087:	118ac0        	slli	a8, a10, 4
4037e08a:	c0a8a0        	sub	a10, a8, a10
4037e08d:	aaaa      	add.n	a10, a10, a10
4037e08f:	dbab71        	l32r	a7, 40374f3c <_iram_text_start+0xb38> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4037e092:	b26a70        	mulsh	a6, a10, a7
4037e095:	216660        	srai	a6, a6, 6
4037e098:	31afa0        	srai	a10, a10, 31
4037e09b:	c066a0        	sub	a6, a6, a10
4037e09e:	ff76a5        	call8	4037d808 <spimem_flash_ll_get_source_freq_mhz>
4037e0a1:	118ac0        	slli	a8, a10, 4
4037e0a4:	c0a8a0        	sub	a10, a8, a10
4037e0a7:	aaaa      	add.n	a10, a10, a10
4037e0a9:	b28a70        	mulsh	a8, a10, a7
4037e0ac:	218680        	srai	a8, a8, 6
4037e0af:	319fa0        	srai	a9, a10, 31
4037e0b2:	c08890        	sub	a8, a8, a9
4037e0b5:	1198b0        	slli	a9, a8, 5
4037e0b8:	c09980        	sub	a9, a9, a8
4037e0bb:	a08980        	addx4	a8, a9, a8
4037e0be:	1188d0        	slli	a8, a8, 3
4037e0c1:	c08a80        	sub	a8, a10, a8
4037e0c4:	835480        	moveqz	a5, a4, a8
4037e0c7:	665a      	add.n	a6, a6, a5
    SPIMEM0.ctrl2.cs_hold_delay = cs_hold_delay;
4037e0c9:	d9c391        	l32r	a9, 403747d8 <_iram_text_start+0x3d4> (60003000 <SPIMEM0>)
4037e0cc:	0020c0        	memw
4037e0cf:	4988      	l32i.n	a8, a9, 16
4037e0d1:	546060        	extui	a6, a6, 0, 6
4037e0d4:	016670        	slli	a6, a6, 25
4037e0d7:	db9aa1        	l32r	a10, 40374f40 <_iram_text_start+0xb3c> (81ffffff <_rtc_reserved_end+0x21efffff>)
4037e0da:	1088a0        	and	a8, a8, a10
4037e0dd:	208860        	or	a8, a8, a6
4037e0e0:	0020c0        	memw
4037e0e3:	4989      	s32i.n	a8, a9, 16
    spimem_flash_ll_sus_set_spi0_lock_trans(dev, SPIMEM_FLASH_LL_SPI0_MAX_LOCK_VAL_MSPI_TICKS);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, true);
    spimem_flash_ll_res_check_sus_setup(dev, true);
#endif
}
4037e0e5:	f01d      	retw.n
	...

4037e0e8 <spi_flash_hal_setup_auto_resume_mode>:

void spi_flash_hal_setup_auto_resume_mode(spi_flash_host_inst_t *host)
{
4037e0e8:	004136        	entry	a1, 32
    dev->misc.auto_per = auto_res;
4037e0eb:	d9af91        	l32r	a9, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037e0ee:	0020c0        	memw
4037e0f1:	d9a8      	l32i.n	a10, a9, 52
4037e0f3:	db9481        	l32r	a8, 40374f44 <_iram_text_start+0xb40> (800 <UserFrameTotalSize+0x700>)
4037e0f6:	208a80        	or	a8, a10, a8
4037e0f9:	0020c0        	memw
4037e0fc:	d989      	s32i.n	a8, a9, 52
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spimem_flash_ll_auto_resume_init(dev, true);
}
4037e0fe:	f01d      	retw.n

4037e100 <spi_flash_hal_disable_auto_suspend_mode>:

void spi_flash_hal_disable_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037e100:	006136        	entry	a1, 48
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05);
4037e103:	d9a981        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037e106:	0020c0        	memw
4037e109:	262892        	l32i	a9, a8, 152
4037e10c:	0020c0        	memw
4037e10f:	0199      	s32i.n	a9, a1, 0
4037e111:	0020c0        	memw
4037e114:	01a8      	l32i.n	a10, a1, 0
4037e116:	03ac92        	movi	a9, 0xfffffc03
4037e119:	10aa90        	and	a10, a10, a9
4037e11c:	491c      	movi.n	a9, 20
4037e11e:	209a90        	or	a9, a10, a9
4037e121:	0020c0        	memw
4037e124:	0199      	s32i.n	a9, a1, 0
4037e126:	0020c0        	memw
4037e129:	0198      	l32i.n	a9, a1, 0
4037e12b:	0020c0        	memw
4037e12e:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = (per_waiti | pes_waiti);  // enable auto wait-idle function.
4037e131:	0020c0        	memw
4037e134:	2628b2        	l32i	a11, a8, 152
4037e137:	e97c      	movi.n	a9, -2
4037e139:	10ab90        	and	a10, a11, a9
4037e13c:	0020c0        	memw
4037e13f:	2668a2        	s32i	a10, a8, 152
    dev->flash_sus_cmd.flash_per_wait_en = per_waiti;
4037e142:	0020c0        	memw
4037e145:	2728b2        	l32i	a11, a8, 156
4037e148:	ba7c      	movi.n	a10, -5
4037e14a:	10aba0        	and	a10, a11, a10
4037e14d:	0020c0        	memw
4037e150:	2768a2        	s32i	a10, a8, 156
    dev->flash_sus_cmd.flash_pes_wait_en = pes_waiti;
4037e153:	0020c0        	memw
4037e156:	2728b2        	l32i	a11, a8, 156
4037e159:	7a7c      	movi.n	a10, -9
4037e15b:	10aba0        	and	a10, a11, a10
4037e15e:	0020c0        	memw
4037e161:	2768a2        	s32i	a10, a8, 156
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037e164:	0020c0        	memw
4037e167:	2828a2        	l32i	a10, a8, 160
4037e16a:	109a90        	and	a9, a10, a9
4037e16d:	0020c0        	memw
4037e170:	286892        	s32i	a9, a8, 160
    dev->flash_sus_cmd.pes_per_en = auto_sus;
4037e173:	0020c0        	memw
4037e176:	2728a2        	l32i	a10, a8, 156
4037e179:	f96c      	movi.n	a9, -17
4037e17b:	109a90        	and	a9, a10, a9
4037e17e:	0020c0        	memw
4037e181:	276892        	s32i	a9, a8, 156
    spimem_flash_ll_auto_suspend_init(dev, false);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, false);
    spimem_flash_ll_res_check_sus_setup(dev, false);
#endif
}
4037e184:	f01d      	retw.n
	...

4037e188 <spi_flash_hal_disable_auto_resume_mode>:

void spi_flash_hal_disable_auto_resume_mode(spi_flash_host_inst_t *host)
{
4037e188:	004136        	entry	a1, 32
    dev->misc.auto_per = auto_res;
4037e18b:	d98791        	l32r	a9, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
4037e18e:	0020c0        	memw
4037e191:	d9a8      	l32i.n	a10, a9, 52
4037e193:	da1581        	l32r	a8, 403749e8 <_iram_text_start+0x5e4> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
4037e196:	108a80        	and	a8, a10, a8
4037e199:	0020c0        	memw
4037e19c:	d989      	s32i.n	a8, a9, 52
    spi_mem_dev_t *dev = (spi_mem_dev_t*)spi_flash_ll_get_hw(SPI1_HOST);
    spimem_flash_ll_auto_resume_init(dev, false);
}
4037e19e:	f01d      	retw.n

4037e1a0 <spi_flash_hal_device_config>:
{
4037e1a0:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e1a3:	1278      	l32i.n	a7, a2, 4
    dev->user.val = 0;
4037e1a5:	080c      	movi.n	a8, 0
4037e1a7:	0020c0        	memw
4037e1aa:	6789      	s32i.n	a8, a7, 24
    dev->ctrl.val = 0;
4037e1ac:	0020c0        	memw
4037e1af:	2789      	s32i.n	a8, a7, 8
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037e1b1:	2298      	l32i.n	a9, a2, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037e1b3:	0020c0        	memw
4037e1b6:	d788      	l32i.n	a8, a7, 52
4037e1b8:	1a0c      	movi.n	a10, 1
4037e1ba:	83a990        	moveqz	a10, a9, a9
4037e1bd:	eb7c      	movi.n	a11, -2
4037e1bf:	1088b0        	and	a8, a8, a11
4037e1c2:	2088a0        	or	a8, a8, a10
4037e1c5:	0020c0        	memw
4037e1c8:	d789      	s32i.n	a8, a7, 52
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037e1ca:	a90b      	addi.n	a10, a9, -1
4037e1cc:	0020c0        	memw
4037e1cf:	d788      	l32i.n	a8, a7, 52
4037e1d1:	190c      	movi.n	a9, 1
4037e1d3:	839aa0        	moveqz	a9, a10, a10
4037e1d6:	999a      	add.n	a9, a9, a9
4037e1d8:	da7c      	movi.n	a10, -3
4037e1da:	1088a0        	and	a8, a8, a10
4037e1dd:	208890        	or	a8, a8, a9
4037e1e0:	0020c0        	memw
4037e1e3:	d789      	s32i.n	a8, a7, 52
    dev->clock.val = *clock_val;
4037e1e5:	0020c0        	memw
4037e1e8:	4288      	l32i.n	a8, a2, 16
4037e1ea:	0020c0        	memw
4037e1ed:	5789      	s32i.n	a8, a7, 20
    int cs_hold = ctx->cs_hold;
4037e1ef:	0f02a2        	l8ui	a10, a2, 15
    dev->ctrl2.cs_hold_time = hold_n - 1;
4037e1f2:	9a0b      	addi.n	a9, a10, -1
4037e1f4:	0020c0        	memw
4037e1f7:	4788      	l32i.n	a8, a7, 16
4037e1f9:	449090        	extui	a9, a9, 0, 5
4037e1fc:	1199b0        	slli	a9, a9, 5
4037e1ff:	1facb2        	movi	a11, 0xfffffc1f
4037e202:	1088b0        	and	a8, a8, a11
4037e205:	208890        	or	a8, a8, a9
4037e208:	0020c0        	memw
4037e20b:	4789      	s32i.n	a8, a7, 16
    dev->user.cs_hold = (hold_n > 0 ? 1 : 0);
4037e20d:	0020c0        	memw
4037e210:	6788      	l32i.n	a8, a7, 24
4037e212:	190c      	movi.n	a9, 1
4037e214:	839aa0        	moveqz	a9, a10, a10
4037e217:	1199a0        	slli	a9, a9, 6
4037e21a:	bfafa2        	movi	a10, -65
4037e21d:	1088a0        	and	a8, a8, a10
4037e220:	208890        	or	a8, a8, a9
4037e223:	0020c0        	memw
4037e226:	6789      	s32i.n	a8, a7, 24
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037e228:	0e0282        	l8ui	a8, a2, 14
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037e22b:	0020c0        	memw
4037e22e:	6798      	l32i.n	a9, a7, 24
4037e230:	1a0c      	movi.n	a10, 1
4037e232:	83a880        	moveqz	a10, a8, a8
4037e235:	11aa90        	slli	a10, a10, 7
4037e238:	7fafb2        	movi	a11, -129
4037e23b:	1099b0        	and	a9, a9, a11
4037e23e:	2099a0        	or	a9, a9, a10
4037e241:	0020c0        	memw
4037e244:	6799      	s32i.n	a9, a7, 24
    dev->ctrl2.cs_setup_time = cs_setup_time - 1;
4037e246:	880b      	addi.n	a8, a8, -1
4037e248:	0020c0        	memw
4037e24b:	4798      	l32i.n	a9, a7, 16
4037e24d:	448080        	extui	a8, a8, 0, 5
4037e250:	0a6c      	movi.n	a10, -32
4037e252:	1099a0        	and	a9, a9, a10
4037e255:	208980        	or	a8, a9, a8
4037e258:	0020c0        	memw
4037e25b:	4789      	s32i.n	a8, a7, 16
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) != 0) {
4037e25d:	6288      	l32i.n	a8, a2, 24
4037e25f:	096807        	bbci	a8, 0, 4037e26c <spi_flash_hal_device_config+0xcc>
        spi_flash_hal_setup_auto_suspend_mode(host);
4037e262:	20a220        	or	a10, a2, a2
4037e265:	ffcae5        	call8	4037df14 <spi_flash_hal_setup_auto_suspend_mode>
4037e268:	000186        	j	4037e272 <spi_flash_hal_device_config+0xd2>
4037e26b:	a22000        	muluh	a2, a0, a0
        spi_flash_hal_disable_auto_suspend_mode(host);
4037e26e:	20          	.byte	0x20
4037e26f:	ffe925        	call8	4037e100 <spi_flash_hal_disable_auto_suspend_mode>
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME) != 0) {
4037e272:	062282        	l32i	a8, a2, 24
4037e275:	076817        	bbci	a8, 1, 4037e280 <spi_flash_hal_device_config+0xe0>
        spi_flash_hal_setup_auto_resume_mode(host);
4037e278:	02ad      	mov.n	a10, a2
4037e27a:	ffe6e5        	call8	4037e0e8 <spi_flash_hal_setup_auto_resume_mode>
4037e27d:	000146        	j	4037e286 <spi_flash_hal_device_config+0xe6>
        spi_flash_hal_disable_auto_resume_mode(host);
4037e280:	20a220        	or	a10, a2, a2
4037e283:	fff065        	call8	4037e188 <spi_flash_hal_disable_auto_resume_mode>
    dev->timing_cali.extra_dummy_cyclelen = extra_dummy;
4037e286:	0020c0        	memw
4037e289:	2a2782        	l32i	a8, a7, 168
4037e28c:	e3af92        	movi	a9, -29
4037e28f:	108890        	and	a8, a8, a9
4037e292:	0020c0        	memw
4037e295:	2a6782        	s32i	a8, a7, 168
}
4037e298:	00a022        	movi	a2, 0
4037e29b:	f01d      	retw.n
4037e29d:	000000        	ill

4037e2a0 <spi_flash_hal_poll_cmd_done>:
{
4037e2a0:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e2a3:	1288      	l32i.n	a8, a2, 4
    return (dev->cmd.val == 0);
4037e2a5:	0020c0        	memw
4037e2a8:	0888      	l32i.n	a8, a8, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037e2aa:	ff5856        	bnez	a8, 4037e2a3 <spi_flash_hal_poll_cmd_done+0x3>
}
4037e2ad:	f01d      	retw.n
	...

4037e2b0 <spi_flash_hal_check_status>:
{
4037e2b0:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037e2b3:	1288      	l32i.n	a8, a2, 4
    return dev->cmd.val == 0;
4037e2b5:	0020c0        	memw
4037e2b8:	0828      	l32i.n	a2, a8, 0
4037e2ba:	40f220        	nsau	a2, a2
4037e2bd:	412520        	srli	a2, a2, 5
    return dev->sus_status.flash_sus;
4037e2c0:	0020c0        	memw
4037e2c3:	292882        	l32i	a8, a8, 164
    uint32_t sus_status = spimem_flash_ll_sus_status((spi_mem_dev_t*)dev) << 1;
4037e2c6:	048080        	extui	a8, a8, 0, 1
4037e2c9:	888a      	add.n	a8, a8, a8
}
4037e2cb:	202280        	or	a2, a2, a8
4037e2ce:	f01d      	retw.n

4037e2d0 <spi_flash_hal_resume>:
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

void spi_flash_hal_resume(spi_flash_host_inst_t *host)
{
4037e2d0:	004136        	entry	a1, 32
4037e2d3:	02ad      	mov.n	a10, a2
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_resume((spi_mem_dev_t*)(((spi_flash_hal_context_t *)host)->spi));
4037e2d5:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_per = 1;
4037e2d7:	0020c0        	memw
4037e2da:	272982        	l32i	a8, a9, 156
4037e2dd:	1b0c      	movi.n	a11, 1
4037e2df:	2088b0        	or	a8, a8, a11
4037e2e2:	0020c0        	memw
4037e2e5:	276982        	s32i	a8, a9, 156
    host->driver->poll_cmd_done(host);
4037e2e8:	0288      	l32i.n	a8, a2, 0
4037e2ea:	102882        	l32i	a8, a8, 64
4037e2ed:	0008e0        	callx8	a8
#else
    abort();
#endif
}
4037e2f0:	f01d      	retw.n
	...

4037e2f4 <spi_flash_hal_suspend>:

void spi_flash_hal_suspend(spi_flash_host_inst_t *host)
{
4037e2f4:	004136        	entry	a1, 32
4037e2f7:	02ad      	mov.n	a10, a2
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_suspend((spi_mem_dev_t *)(((spi_flash_hal_context_t *)host)->spi));
4037e2f9:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_pes = 1;
4037e2fb:	0020c0        	memw
4037e2fe:	272982        	l32i	a8, a9, 156
4037e301:	2b0c      	movi.n	a11, 2
4037e303:	2088b0        	or	a8, a8, a11
4037e306:	0020c0        	memw
4037e309:	276982        	s32i	a8, a9, 156
    host->driver->poll_cmd_done(host);
4037e30c:	0288      	l32i.n	a8, a2, 0
4037e30e:	102882        	l32i	a8, a8, 64
4037e311:	0008e0        	callx8	a8
#else
    abort();
#endif
}
4037e314:	f01d      	retw.n
	...

4037e318 <systimer_hal_init>:
#include "hal/systimer_types.h"
#include "hal/assert.h"


void systimer_hal_init(systimer_hal_context_t *hal)
{
4037e318:	004136        	entry	a1, 32
    hal->dev = &SYSTIMER;
4037e31b:	db0b81        	l32r	a8, 40374f48 <_iram_text_start+0xb44> (60023000 <SYSTIMER>)
4037e31e:	0289      	s32i.n	a8, a2, 0
    dev->conf.clk_en = en;
4037e320:	0020c0        	memw
4037e323:	0898      	l32i.n	a9, a8, 0
4037e325:	d922a1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037e328:	2099a0        	or	a9, a9, a10
4037e32b:	0020c0        	memw
4037e32e:	0899      	s32i.n	a9, a8, 0
    systimer_ll_enable_clock(hal->dev, true);
#if SOC_SYSTIMER_SUPPORT_ETM
    systimer_ll_enable_etm(&SYSTIMER, true);
#endif
}
4037e330:	f01d      	retw.n
	...

4037e334 <systimer_hal_get_counter_value>:
    hal->ticks_to_us = ops->ticks_to_us;
    hal->us_to_ticks = ops->us_to_ticks;
}

uint64_t systimer_hal_get_counter_value(systimer_hal_context_t *hal, uint32_t counter_id)
{
4037e334:	004136        	entry	a1, 32
4037e337:	03bd      	mov.n	a11, a3
    uint32_t lo, lo_start, hi;
    /* Set the "update" bit and wait for acknowledgment */
    systimer_ll_counter_snapshot(hal->dev, counter_id);
4037e339:	0288      	l32i.n	a8, a2, 0
    dev->unit_op[counter_id].timer_unit_update = 1;
4037e33b:	a08380        	addx4	a8, a3, a8
4037e33e:	0020c0        	memw
4037e341:	1898      	l32i.n	a9, a8, 4
4037e343:	d8a8a1        	l32r	a10, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037e346:	2099a0        	or	a9, a9, a10
4037e349:	0020c0        	memw
4037e34c:	1899      	s32i.n	a9, a8, 4
    while (!systimer_ll_is_counter_value_valid(hal->dev, counter_id));
4037e34e:	02a8      	l32i.n	a10, a2, 0
    return dev->unit_op[counter_id].timer_unit_value_valid;
4037e350:	a08ba0        	addx4	a8, a11, a10
4037e353:	0020c0        	memw
4037e356:	1888      	l32i.n	a8, a8, 4
4037e358:	f278d7        	bbci	a8, 29, 4037e34e <systimer_hal_get_counter_value+0x1a>
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037e35b:	8b8b      	addi.n	a8, a11, 8
4037e35d:	b088a0        	addx8	a8, a8, a10
4037e360:	0020c0        	memw
4037e363:	1898      	l32i.n	a9, a8, 4
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
4037e365:	8b8b      	addi.n	a8, a11, 8
4037e367:	b088a0        	addx8	a8, a8, a10
4037e36a:	0020c0        	memw
4037e36d:	0838      	l32i.n	a3, a8, 0
4037e36f:	113340        	slli	a3, a3, 12
4037e372:	413c30        	srli	a3, a3, 12
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037e375:	092d      	mov.n	a2, a9
4037e377:	0020c0        	memw
4037e37a:	1898      	l32i.n	a9, a8, 4
    lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    do {
        lo = lo_start;
        hi = systimer_ll_get_counter_value_high(hal->dev, counter_id);
        lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    } while (lo_start != lo);
4037e37c:	e59297        	bne	a2, a9, 4037e365 <systimer_hal_get_counter_value+0x31>
        .lo = lo,
        .hi = hi
    };

    return result.val;
}
4037e37f:	f01d      	retw.n
4037e381:	000000        	ill

4037e384 <systimer_hal_set_alarm_period>:
    } while (1);
}
#endif // SOC_SYSTIMER_ALARM_MISS_COMPENSATE

void systimer_hal_set_alarm_period(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t period)
{
4037e384:	004136        	entry	a1, 32
4037e387:	04ad      	mov.n	a10, a4
    systimer_ll_enable_alarm(hal->dev, alarm_id, false);
4037e389:	0298      	l32i.n	a9, a2, 0
        dev->conf.val &= ~(1 << (24 - alarm_id));
4037e38b:	0020c0        	memw
4037e38e:	09b8      	l32i.n	a11, a9, 0
4037e390:	e8c382        	addi	a8, a3, -24
4037e393:	608080        	neg	a8, a8
4037e396:	170c      	movi.n	a7, 1
4037e398:	401800        	ssl	a8
4037e39b:	a17700        	sll	a7, a7
4037e39e:	1087b0        	and	a8, a7, a11
4037e3a1:	3088b0        	xor	a8, a8, a11
4037e3a4:	0020c0        	memw
4037e3a7:	0989      	s32i.n	a8, a9, 0
    systimer_ll_set_alarm_period(hal->dev, alarm_id, hal->us_to_ticks(period));
4037e3a9:	0268      	l32i.n	a6, a2, 0
4037e3ab:	2288      	l32i.n	a8, a2, 8
4037e3ad:	00a0b2        	movi	a11, 0
4037e3b0:	0008e0        	callx8	a8
    HAL_ASSERT(period < (1 << 26));
4037e3b3:	dae681        	l32r	a8, 40374f4c <_iram_text_start+0xb48> (3ffffff <UserFrameTotalSize+0x3fffeff>)
4037e3b6:	0eb8a7        	bgeu	a8, a10, 4037e3c8 <systimer_hal_set_alarm_period+0x44>
4037e3b9:	dae5d1        	l32r	a13, 40374f50 <_iram_text_start+0xb4c> (3fc93cd0 <__func__$0+0xe4>)
4037e3bc:	dae6c1        	l32r	a12, 40374f54 <_iram_text_start+0xb50> (3fc946d4 <__func__$0>)
4037e3bf:	95a0b2        	movi	a11, 149
4037e3c2:	dae5a1        	l32r	a10, 40374f58 <_iram_text_start+0xb54> (3fc93ce4 <__func__$0+0xf8>)
4037e3c5:	019625        	call8	4037fd28 <__assert_func>
    dev->target_conf[alarm_id].target_period = period;
4037e3c8:	93cb      	addi.n	a9, a3, 12
4037e3ca:	a09960        	addx4	a9, a9, a6
4037e3cd:	0020c0        	memw
4037e3d0:	1988      	l32i.n	a8, a9, 4
4037e3d2:	11aaa0        	slli	a10, a10, 6
4037e3d5:	41a6a0        	srli	a10, a10, 6
4037e3d8:	558a80        	extui	a8, a8, 26, 6
4037e3db:	018860        	slli	a8, a8, 26
4037e3de:	2088a0        	or	a8, a8, a10
4037e3e1:	0020c0        	memw
4037e3e4:	1989      	s32i.n	a8, a9, 4
    systimer_ll_apply_alarm_value(hal->dev, alarm_id);
4037e3e6:	0288      	l32i.n	a8, a2, 0
    dev->comp_load[alarm_id].val = 0x01;
4037e3e8:	14c332        	addi	a3, a3, 20
4037e3eb:	a03380        	addx4	a3, a3, a8
4037e3ee:	180c      	movi.n	a8, 1
4037e3f0:	0020c0        	memw
4037e3f3:	0389      	s32i.n	a8, a3, 0
    systimer_ll_enable_alarm(hal->dev, alarm_id, true);
4037e3f5:	0298      	l32i.n	a9, a2, 0
        dev->conf.val |= 1 << (24 - alarm_id);
4037e3f7:	0020c0        	memw
4037e3fa:	0988      	l32i.n	a8, a9, 0
4037e3fc:	208870        	or	a8, a8, a7
4037e3ff:	0020c0        	memw
4037e402:	0989      	s32i.n	a8, a9, 0
}
4037e404:	f01d      	retw.n
	...

4037e408 <systimer_hal_counter_value_advance>:
{
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
}

void systimer_hal_counter_value_advance(systimer_hal_context_t *hal, uint32_t counter_id, int64_t time_us)
{
4037e408:	004136        	entry	a1, 32
    systimer_counter_value_t new_count = {
        .val = systimer_hal_get_counter_value(hal, counter_id) + hal->us_to_ticks(time_us),
4037e40b:	03bd      	mov.n	a11, a3
4037e40d:	02ad      	mov.n	a10, a2
4037e40f:	fff265        	call8	4037e334 <systimer_hal_get_counter_value>
4037e412:	0a6d      	mov.n	a6, a10
4037e414:	0b7d      	mov.n	a7, a11
4037e416:	2288      	l32i.n	a8, a2, 8
4037e418:	04ad      	mov.n	a10, a4
4037e41a:	05bd      	mov.n	a11, a5
4037e41c:	0008e0        	callx8	a8
4037e41f:	b7ba      	add.n	a11, a7, a11
4037e421:	c6aa      	add.n	a12, a6, a10
4037e423:	01bca7        	bgeu	a12, a10, 4037e428 <systimer_hal_counter_value_advance+0x20>
4037e426:	bb1b      	addi.n	a11, a11, 1
    };
    systimer_ll_set_counter_value(hal->dev, counter_id, new_count.val);
4037e428:	0298      	l32i.n	a9, a2, 0
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037e42a:	b09390        	addx8	a9, a3, a9
4037e42d:	0020c0        	memw
4037e430:	3988      	l32i.n	a8, a9, 12
4037e432:	11bb40        	slli	a11, a11, 12
4037e435:	41bcb0        	srli	a11, a11, 12
4037e438:	b58480        	extui	a8, a8, 20, 12
4037e43b:	0188c0        	slli	a8, a8, 20
4037e43e:	2088b0        	or	a8, a8, a11
4037e441:	0020c0        	memw
4037e444:	3989      	s32i.n	a8, a9, 12
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037e446:	0020c0        	memw
4037e449:	49c9      	s32i.n	a12, a9, 16
    systimer_ll_apply_counter_value(hal->dev, counter_id);
4037e44b:	0288      	l32i.n	a8, a2, 0
    dev->unit_load[counter_id].val = 0x01;
4037e44d:	14c332        	addi	a3, a3, 20
4037e450:	a03380        	addx4	a3, a3, a8
4037e453:	180c      	movi.n	a8, 1
4037e455:	0020c0        	memw
4037e458:	3389      	s32i.n	a8, a3, 12
}
4037e45a:	f01d      	retw.n

4037e45c <systimer_hal_select_alarm_mode>:
{
    systimer_ll_enable_counter(hal->dev, counter_id, true);
}

void systimer_hal_select_alarm_mode(systimer_hal_context_t *hal, uint32_t alarm_id, systimer_alarm_mode_t mode)
{
4037e45c:	004136        	entry	a1, 32
    switch (mode) {
4037e45f:	548c      	beqz.n	a4, 4037e468 <systimer_hal_select_alarm_mode+0xc>
4037e461:	1d1426        	beqi	a4, 1, 4037e482 <systimer_hal_select_alarm_mode+0x26>
4037e464:	000c46        	j	4037e499 <systimer_hal_select_alarm_mode+0x3d>
4037e467:	028800        	andb	b8, b8, b0
    dev->target_conf[alarm_id].target_period_mode = 0;
4037e46a:	33cb      	addi.n	a3, a3, 12
4037e46c:	a03380        	addx4	a3, a3, a8
4037e46f:	0020c0        	memw
4037e472:	1388      	l32i.n	a8, a3, 4
4037e474:	d8d191        	l32r	a9, 403747b8 <_iram_text_start+0x3b4> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4037e477:	108890        	and	a8, a8, a9
4037e47a:	0020c0        	memw
4037e47d:	1389      	s32i.n	a8, a3, 4
}
4037e47f:	000586        	j	4037e499 <systimer_hal_select_alarm_mode+0x3d>
    case SYSTIMER_ALARM_MODE_ONESHOT:
        systimer_ll_enable_alarm_oneshot(hal->dev, alarm_id);
        break;
    case SYSTIMER_ALARM_MODE_PERIOD:
        systimer_ll_enable_alarm_period(hal->dev, alarm_id);
4037e482:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_period_mode = 1;
4037e484:	33cb      	addi.n	a3, a3, 12
4037e486:	a03380        	addx4	a3, a3, a8
4037e489:	0020c0        	memw
4037e48c:	1388      	l32i.n	a8, a3, 4
4037e48e:	d85591        	l32r	a9, 403745e4 <_iram_text_start+0x1e0> (40000000 <_heap_end>)
4037e491:	208890        	or	a8, a8, a9
4037e494:	0020c0        	memw
4037e497:	1389      	s32i.n	a8, a3, 4
        break;
    default:
        break;
    }
}
4037e499:	f01d      	retw.n
	...

4037e49c <systimer_hal_set_tick_rate_ops>:
{
4037e49c:	004136        	entry	a1, 32
    hal->ticks_to_us = ops->ticks_to_us;
4037e49f:	0388      	l32i.n	a8, a3, 0
4037e4a1:	1289      	s32i.n	a8, a2, 4
    hal->us_to_ticks = ops->us_to_ticks;
4037e4a3:	1388      	l32i.n	a8, a3, 4
4037e4a5:	2289      	s32i.n	a8, a2, 8
}
4037e4a7:	f01d      	retw.n
4037e4a9:	000000        	ill

4037e4ac <systimer_hal_enable_alarm_int>:
{
4037e4ac:	004136        	entry	a1, 32
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
4037e4af:	02a8      	l32i.n	a10, a2, 0
        dev->int_ena.val |= 1 << alarm_id;
4037e4b1:	0020c0        	memw
4037e4b4:	192a82        	l32i	a8, a10, 100
4037e4b7:	190c      	movi.n	a9, 1
4037e4b9:	401300        	ssl	a3
4037e4bc:	a19900        	sll	a9, a9
4037e4bf:	208890        	or	a8, a8, a9
4037e4c2:	0020c0        	memw
4037e4c5:	196a82        	s32i	a8, a10, 100
}
4037e4c8:	f01d      	retw.n
	...

4037e4cc <systimer_hal_enable_counter>:
{
4037e4cc:	004136        	entry	a1, 32
    systimer_ll_enable_counter(hal->dev, counter_id, true);
4037e4cf:	02a8      	l32i.n	a10, a2, 0
        dev->conf.val |= 1 << (30 - counter_id);
4037e4d1:	0020c0        	memw
4037e4d4:	0a88      	l32i.n	a8, a10, 0
4037e4d6:	e2c332        	addi	a3, a3, -30
4037e4d9:	603030        	neg	a3, a3
4037e4dc:	190c      	movi.n	a9, 1
4037e4de:	401300        	ssl	a3
4037e4e1:	a19900        	sll	a9, a9
4037e4e4:	208890        	or	a8, a8, a9
4037e4e7:	0020c0        	memw
4037e4ea:	0a89      	s32i.n	a8, a10, 0
}
4037e4ec:	f01d      	retw.n
	...

4037e4f0 <systimer_hal_connect_alarm_counter>:

void systimer_hal_connect_alarm_counter(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t counter_id)
{
4037e4f0:	004136        	entry	a1, 32
    systimer_ll_connect_alarm_counter(hal->dev, alarm_id, counter_id);
4037e4f3:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_timer_unit_sel = counter_id;
4037e4f5:	33cb      	addi.n	a3, a3, 12
4037e4f7:	a03380        	addx4	a3, a3, a8
4037e4fa:	0020c0        	memw
4037e4fd:	1388      	l32i.n	a8, a3, 4
4037e4ff:	014410        	slli	a4, a4, 31
4037e502:	888a      	add.n	a8, a8, a8
4037e504:	418180        	srli	a8, a8, 1
4037e507:	208840        	or	a8, a8, a4
4037e50a:	0020c0        	memw
4037e50d:	1389      	s32i.n	a8, a3, 4
}
4037e50f:	f01d      	retw.n
4037e511:	000000        	ill

4037e514 <systimer_hal_counter_can_stall_by_cpu>:

void systimer_hal_counter_can_stall_by_cpu(systimer_hal_context_t *hal, uint32_t counter_id, uint32_t cpu_id, bool can)
{
4037e514:	004136        	entry	a1, 32
4037e517:	745050        	extui	a5, a5, 0, 8
    systimer_ll_counter_can_stall_by_cpu(hal->dev, counter_id, cpu_id, can);
4037e51a:	0298      	l32i.n	a9, a2, 0
    if (can) {
4037e51c:	05ac      	beqz.n	a5, 4037e540 <systimer_hal_counter_can_stall_by_cpu+0x2c>
        dev->conf.val |= 1 << ((28 - counter_id * 2) - cpu_id);
4037e51e:	0020c0        	memw
4037e521:	0988      	l32i.n	a8, a9, 0
4037e523:	f2c332        	addi	a3, a3, -14
4037e526:	603030        	neg	a3, a3
4037e529:	d03340        	subx2	a3, a3, a4
4037e52c:	1a0c      	movi.n	a10, 1
4037e52e:	401300        	ssl	a3
4037e531:	a1aa00        	sll	a10, a10
4037e534:	2088a0        	or	a8, a8, a10
4037e537:	0020c0        	memw
4037e53a:	0989      	s32i.n	a8, a9, 0
4037e53c:	000846        	j	4037e561 <systimer_hal_counter_can_stall_by_cpu+0x4d>
4037e53f:	20c000        	or	a12, a0, a0
        dev->conf.val &= ~(1 << ((28 - counter_id * 2) - cpu_id));
4037e542:	09a800        	l32e	a0, a8, -24
4037e545:	f2c332        	addi	a3, a3, -14
4037e548:	603030        	neg	a3, a3
4037e54b:	d03340        	subx2	a3, a3, a4
4037e54e:	180c      	movi.n	a8, 1
4037e550:	401300        	ssl	a3
4037e553:	a18800        	sll	a8, a8
4037e556:	1088a0        	and	a8, a8, a10
4037e559:	3088a0        	xor	a8, a8, a10
4037e55c:	0020c0        	memw
4037e55f:	0989      	s32i.n	a8, a9, 0
}
4037e561:	f01d      	retw.n
	...

4037e564 <timer_hal_capture_and_get_counter_value>:
    // restore the previous reload value
    timer_ll_set_reload_value(hal->dev, hal->timer_id, old_reload);
}

uint64_t timer_hal_capture_and_get_counter_value(timer_hal_context_t *hal)
{
4037e564:	004136        	entry	a1, 32
    timer_ll_trigger_soft_capture(hal->dev, hal->timer_id);
4037e567:	02a8      	l32i.n	a10, a2, 0
4037e569:	1298      	l32i.n	a9, a2, 4
 * @param timer_num Timer number in the group
 */
__attribute__((always_inline))
static inline void timer_ll_trigger_soft_capture(timg_dev_t *hw, uint32_t timer_num)
{
    hw->hw_timer[timer_num].update.tn_update = 1;
4037e56b:	b08990        	addx8	a8, a9, a9
4037e56e:	a088a0        	addx4	a8, a8, a10
4037e571:	0020c0        	memw
4037e574:	38b8      	l32i.n	a11, a8, 12
4037e576:	d88ec1        	l32r	a12, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
4037e579:	20bbc0        	or	a11, a11, a12
4037e57c:	0020c0        	memw
4037e57f:	38b9      	s32i.n	a11, a8, 12
    // Timer register is in a different clock domain from Timer hardware logic
    // We need to wait for the update to take effect before fetching the count value
    while (hw->hw_timer[timer_num].update.tn_update) {
4037e581:	b08990        	addx8	a8, a9, a9
4037e584:	a088a0        	addx4	a8, a8, a10
4037e587:	0020c0        	memw
4037e58a:	3888      	l32i.n	a8, a8, 12
4037e58c:	ff1896        	bltz	a8, 4037e581 <timer_hal_capture_and_get_counter_value+0x1d>
    return timer_ll_get_counter_value(hal->dev, hal->timer_id);
4037e58f:	02a8      	l32i.n	a10, a2, 0
4037e591:	1288      	l32i.n	a8, a2, 4
 * @return counter value
 */
__attribute__((always_inline))
static inline uint64_t timer_ll_get_counter_value(timg_dev_t *hw, uint32_t timer_num)
{
    return ((uint64_t)hw->hw_timer[timer_num].hi.tn_hi << 32) | (hw->hw_timer[timer_num].lo.tn_lo);
4037e593:	b09880        	addx8	a9, a8, a8
4037e596:	a099a0        	addx4	a9, a9, a10
4037e599:	0020c0        	memw
4037e59c:	2938      	l32i.n	a3, a9, 8
4037e59e:	0020c0        	memw
4037e5a1:	1928      	l32i.n	a2, a9, 4
}
4037e5a3:	113360        	slli	a3, a3, 10
4037e5a6:	413a30        	srli	a3, a3, 10
4037e5a9:	f01d      	retw.n
	...

4037e5ac <assert_valid_block>:

#else // CONFIG_HEAP_TLSF_USE_ROM_IMPL

/* Check a block is valid for this heap. Used to verify parameters. */
__attribute__((noinline)) NOCLONE_ATTR static void assert_valid_block(const heap_t *heap, const multi_heap_block_handle_t block)
{
4037e5ac:	004136        	entry	a1, 32
    pool_t pool = tlsf_get_pool(heap->heap_data);
4037e5af:	42a8      	l32i.n	a10, a2, 16
4037e5b1:	005fe5        	call8	4037ebb0 <tlsf_get_pool>
		tlsf_cast(unsigned char*, ptr) - block_start_offset);
}

static inline __attribute__((always_inline)) void* block_to_ptr(const block_header_t* block)
{
	return tlsf_cast(void*,
4037e5b4:	338b      	addi.n	a3, a3, 8
    void *ptr = block_to_ptr(block);

    MULTI_HEAP_ASSERT((ptr >= pool) &&
4037e5b6:	0733a7        	bltu	a3, a10, 4037e5c1 <assert_valid_block+0x15>
4037e5b9:	3288      	l32i.n	a8, a2, 12
4037e5bb:	80aa80        	add	a10, a10, a8
4037e5be:	1033a7        	bltu	a3, a10, 4037e5d2 <assert_valid_block+0x26>
       Also, it's useful to be able to print the memory address where corruption was detected.
    */
#ifndef NDEBUG
    if(!condition) {
#ifndef CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        esp_rom_printf(format, line, address);
4037e5c1:	03cd      	mov.n	a12, a3
4037e5c3:	7ba0b2        	movi	a11, 123
4037e5c6:	da65a1        	l32r	a10, 40374f5c <_iram_text_start+0xb58> (3c02175c <_flash_rodata_start+0x163c>)
4037e5c9:	d7c481        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
4037e5cc:	0008e0        	callx8	a8
#endif  // CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        abort();
4037e5cf:	0169e5        	call8	4037fc6c <abort>
                    (ptr < pool + heap->pool_size),
                    (uintptr_t)ptr);
}
4037e5d2:	f01d      	retw.n

4037e5d4 <multi_heap_aligned_alloc_impl_offs>:

    return result;
}

void *multi_heap_aligned_alloc_impl_offs(multi_heap_handle_t heap, size_t size, size_t alignment, size_t offset)
{
4037e5d4:	004136        	entry	a1, 32
4037e5d7:	027d      	mov.n	a7, a2
    if(heap == NULL) {
4037e5d9:	043216        	beqz	a2, 4037e620 <multi_heap_aligned_alloc_impl_offs+0x4c>
        return NULL;
    }

    if(!size) {
4037e5dc:	044316        	beqz	a3, 4037e624 <multi_heap_aligned_alloc_impl_offs+0x50>
        return NULL;
    }

    //Alignment must be a power of two:
    if(((alignment & (alignment - 1)) != 0) ||(!alignment)) {
4037e5df:	ffc482        	addi	a8, a4, -1
4037e5e2:	438847        	bany	a8, a4, 4037e629 <multi_heap_aligned_alloc_impl_offs+0x55>
4037e5e5:	045416        	beqz	a4, 4037e62e <multi_heap_aligned_alloc_impl_offs+0x5a>
        return NULL;
    }

    multi_heap_internal_lock(heap);
4037e5e8:	02ad      	mov.n	a10, a2
4037e5ea:	000b65        	call8	4037e6a0 <multi_heap_internal_lock>
    void *result = tlsf_memalign_offs(heap->heap_data, alignment, size, offset);
4037e5ed:	05dd      	mov.n	a13, a5
4037e5ef:	03cd      	mov.n	a12, a3
4037e5f1:	04bd      	mov.n	a11, a4
4037e5f3:	42a8      	l32i.n	a10, a2, 16
4037e5f5:	009965        	call8	4037ef8c <tlsf_memalign_offs>
4037e5f8:	0a2d      	mov.n	a2, a10
    if(result) {
4037e5fa:	01aa16        	beqz	a10, 4037e618 <multi_heap_aligned_alloc_impl_offs+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037e5fd:	001b65        	call8	4037e7b4 <tlsf_block_size>
4037e600:	1788      	l32i.n	a8, a7, 4
4037e602:	c088a0        	sub	a8, a8, a10
4037e605:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037e607:	001a65        	call8	4037e7ac <tlsf_alloc_overhead>
4037e60a:	1788      	l32i.n	a8, a7, 4
4037e60c:	c0a8a0        	sub	a10, a8, a10
4037e60f:	17a9      	s32i.n	a10, a7, 4
        if(heap->free_bytes < heap->minimum_free_bytes) {
4037e611:	2788      	l32i.n	a8, a7, 8
4037e613:	01ba87        	bgeu	a10, a8, 4037e618 <multi_heap_aligned_alloc_impl_offs+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037e616:	27a9      	s32i.n	a10, a7, 8
        }
    }
    multi_heap_internal_unlock(heap);
4037e618:	07ad      	mov.n	a10, a7
4037e61a:	000aa5        	call8	4037e6c4 <multi_heap_internal_unlock>

    return result;
4037e61d:	0003c6        	j	4037e630 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e620:	000306        	j	4037e630 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e623:	020c00        	andb	b0, b12, b0
        return NULL;
4037e626:	000186        	j	4037e630 <multi_heap_aligned_alloc_impl_offs+0x5c>
        return NULL;
4037e629:	020c      	movi.n	a2, 0
4037e62b:	000046        	j	4037e630 <multi_heap_aligned_alloc_impl_offs+0x5c>
4037e62e:	020c      	movi.n	a2, 0
}
4037e630:	f01d      	retw.n
	...

4037e634 <multi_heap_aligned_alloc_offs>:
{
4037e634:	004136        	entry	a1, 32
4037e637:	20a220        	or	a10, a2, a2
4037e63a:	20b330        	or	a11, a3, a3
4037e63d:	20c440        	or	a12, a4, a4
4037e640:	05dd      	mov.n	a13, a5
    return multi_heap_aligned_alloc_impl_offs(heap, size, alignment, offset);
4037e642:	fff925        	call8	4037e5d4 <multi_heap_aligned_alloc_impl_offs>
}
4037e645:	0a2d      	mov.n	a2, a10
4037e647:	f01d      	retw.n
4037e649:	000000        	ill

4037e64c <multi_heap_aligned_free>:
{
4037e64c:	004136        	entry	a1, 32
    if (heap == NULL || p == NULL) {
4037e64f:	40f280        	nsau	a8, a2
4037e652:	418580        	srli	a8, a8, 5
4037e655:	40f390        	nsau	a9, a3
4037e658:	419590        	srli	a9, a9, 5
4037e65b:	208890        	or	a8, a8, a9
4037e65e:	02e856        	bnez	a8, 4037e690 <multi_heap_aligned_free+0x44>
    assert_valid_block(heap, block_from_ptr(p));
4037e661:	f8c3b2        	addi	a11, a3, -8
4037e664:	20a220        	or	a10, a2, a2
4037e667:	fff465        	call8	4037e5ac <assert_valid_block>
    multi_heap_internal_lock(heap);
4037e66a:	20a220        	or	a10, a2, a2
4037e66d:	000325        	call8	4037e6a0 <multi_heap_internal_lock>
    heap->free_bytes += tlsf_block_size(p);
4037e670:	03ad      	mov.n	a10, a3
4037e672:	001425        	call8	4037e7b4 <tlsf_block_size>
4037e675:	1288      	l32i.n	a8, a2, 4
4037e677:	88aa      	add.n	a8, a8, a10
4037e679:	1289      	s32i.n	a8, a2, 4
    heap->free_bytes += tlsf_alloc_overhead();
4037e67b:	001325        	call8	4037e7ac <tlsf_alloc_overhead>
4037e67e:	1288      	l32i.n	a8, a2, 4
4037e680:	88aa      	add.n	a8, a8, a10
4037e682:	1289      	s32i.n	a8, a2, 4
    tlsf_free(heap->heap_data, p);
4037e684:	03bd      	mov.n	a11, a3
4037e686:	42a8      	l32i.n	a10, a2, 16
4037e688:	001425        	call8	4037e7cc <tlsf_free>
    multi_heap_internal_unlock(heap);
4037e68b:	02ad      	mov.n	a10, a2
4037e68d:	000365        	call8	4037e6c4 <multi_heap_internal_unlock>
}
4037e690:	f01d      	retw.n
	...

4037e694 <multi_heap_get_allocated_size>:
{
4037e694:	004136        	entry	a1, 32
4037e697:	03ad      	mov.n	a10, a3
    return tlsf_block_size(p);
4037e699:	0011a5        	call8	4037e7b4 <tlsf_block_size>
}
4037e69c:	0a2d      	mov.n	a2, a10
4037e69e:	f01d      	retw.n

4037e6a0 <multi_heap_internal_lock>:
{
4037e6a0:	004136        	entry	a1, 32
    MULTI_HEAP_LOCK(heap->lock);
4037e6a3:	002272        	l32i	a7, a2, 0
4037e6a6:	018716        	beqz	a7, 4037e6c2 <multi_heap_internal_lock+0x22>
    if (xPortInIsrContext()) {
4037e6a9:	fb9465        	call8	40379ff0 <xPortInIsrContext>
4037e6ac:	8a8c      	beqz.n	a10, 4037e6b8 <multi_heap_internal_lock+0x18>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037e6ae:	fb7c      	movi.n	a11, -1
4037e6b0:	07ad      	mov.n	a10, a7
4037e6b2:	fb9625        	call8	4037a014 <xPortEnterCriticalTimeout>
4037e6b5:	000246        	j	4037e6c2 <multi_heap_internal_lock+0x22>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037e6b8:	fb7c      	movi.n	a11, -1
4037e6ba:	07ad      	mov.n	a10, a7
4037e6bc:	201110        	or	a1, a1, a1
4037e6bf:	fb9565        	call8	4037a014 <xPortEnterCriticalTimeout>
}
4037e6c2:	f01d      	retw.n

4037e6c4 <multi_heap_internal_unlock>:
{
4037e6c4:	004136        	entry	a1, 32
    MULTI_HEAP_UNLOCK(heap->lock);
4037e6c7:	002272        	l32i	a7, a2, 0
4037e6ca:	013716        	beqz	a7, 4037e6e1 <multi_heap_internal_unlock+0x1d>
    if (xPortInIsrContext()) {
4037e6cd:	fb9225        	call8	40379ff0 <xPortInIsrContext>
4037e6d0:	008a16        	beqz	a10, 4037e6dc <multi_heap_internal_unlock+0x18>
        portEXIT_CRITICAL_ISR(mux);
4037e6d3:	07ad      	mov.n	a10, a7
4037e6d5:	fba8e5        	call8	4037a164 <vPortExitCritical>
4037e6d8:	000146        	j	4037e6e1 <multi_heap_internal_unlock+0x1d>
4037e6db:	07ad00        	ee.stf.64.xp	f10, f0, a0, a13
        portEXIT_CRITICAL(mux);
4037e6de:	fba865        	call8	4037a164 <vPortExitCritical>
}
4037e6e1:	f01d      	retw.n
	...

4037e6e4 <multi_heap_malloc>:
{
4037e6e4:	004136        	entry	a1, 32
4037e6e7:	207220        	or	a7, a2, a2
    if (size == 0 || heap == NULL) {
4037e6ea:	40f380        	nsau	a8, a3
4037e6ed:	418580        	srli	a8, a8, 5
4037e6f0:	40f290        	nsau	a9, a2
4037e6f3:	419590        	srli	a9, a9, 5
4037e6f6:	208890        	or	a8, a8, a9
4037e6f9:	033856        	bnez	a8, 4037e730 <multi_heap_malloc+0x4c>
    multi_heap_internal_lock(heap);
4037e6fc:	02ad      	mov.n	a10, a2
4037e6fe:	fffa25        	call8	4037e6a0 <multi_heap_internal_lock>
    void *result = tlsf_malloc(heap->heap_data, size);
4037e701:	03bd      	mov.n	a11, a3
4037e703:	42a8      	l32i.n	a10, a2, 16
4037e705:	004b65        	call8	4037ebbc <tlsf_malloc>
4037e708:	0a2d      	mov.n	a2, a10
    if(result) {
4037e70a:	01aa16        	beqz	a10, 4037e728 <multi_heap_malloc+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037e70d:	000a65        	call8	4037e7b4 <tlsf_block_size>
4037e710:	1788      	l32i.n	a8, a7, 4
4037e712:	c088a0        	sub	a8, a8, a10
4037e715:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037e717:	000965        	call8	4037e7ac <tlsf_alloc_overhead>
4037e71a:	1788      	l32i.n	a8, a7, 4
4037e71c:	c0a8a0        	sub	a10, a8, a10
4037e71f:	17a9      	s32i.n	a10, a7, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037e721:	2788      	l32i.n	a8, a7, 8
4037e723:	01ba87        	bgeu	a10, a8, 4037e728 <multi_heap_malloc+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037e726:	27a9      	s32i.n	a10, a7, 8
    multi_heap_internal_unlock(heap);
4037e728:	07ad      	mov.n	a10, a7
4037e72a:	fff9a5        	call8	4037e6c4 <multi_heap_internal_unlock>
    return result;
4037e72d:	000046        	j	4037e732 <multi_heap_malloc+0x4e>
        return NULL;
4037e730:	020c      	movi.n	a2, 0
}
4037e732:	f01d      	retw.n

4037e734 <multi_heap_realloc>:
{
4037e734:	004136        	entry	a1, 32
4037e737:	027d      	mov.n	a7, a2
    assert(heap != NULL);
4037e739:	d2cc      	bnez.n	a2, 4037e74a <multi_heap_realloc+0x16>
4037e73b:	da09d1        	l32r	a13, 40374f60 <_iram_text_start+0xb5c> (3c0217c0 <_flash_rodata_start+0x16a0>)
4037e73e:	da09c1        	l32r	a12, 40374f64 <_iram_text_start+0xb60> (3c026894 <__func__$4>)
4037e741:	f6a0b2        	movi	a11, 246
4037e744:	da09a1        	l32r	a10, 40374f68 <_iram_text_start+0xb64> (3c0217b2 <_flash_rodata_start+0x1692>)
4037e747:	015e25        	call8	4037fd28 <__assert_func>
    if (p == NULL) {
4037e74a:	c3cc      	bnez.n	a3, 4037e75a <multi_heap_realloc+0x26>
        return multi_heap_malloc_impl(heap, size);
4037e74c:	20b440        	or	a11, a4, a4
4037e74f:	20a220        	or	a10, a2, a2
4037e752:	fff925        	call8	4037e6e4 <multi_heap_malloc>
4037e755:	0a2d      	mov.n	a2, a10
4037e757:	001186        	j	4037e7a1 <multi_heap_realloc+0x6d>
    assert_valid_block(heap, block_from_ptr(p));
4037e75a:	f8c3b2        	addi	a11, a3, -8
4037e75d:	02ad      	mov.n	a10, a2
4037e75f:	ffe4e5        	call8	4037e5ac <assert_valid_block>
    if (heap == NULL) {
4037e762:	03b216        	beqz	a2, 4037e7a1 <multi_heap_realloc+0x6d>
    multi_heap_internal_lock(heap);
4037e765:	20a220        	or	a10, a2, a2
4037e768:	fff365        	call8	4037e6a0 <multi_heap_internal_lock>
    size_t previous_block_size =  tlsf_block_size(p);
4037e76b:	03ad      	mov.n	a10, a3
4037e76d:	000465        	call8	4037e7b4 <tlsf_block_size>
4037e770:	0a6d      	mov.n	a6, a10
    void *result = tlsf_realloc(heap->heap_data, p, size);
4037e772:	04cd      	mov.n	a12, a4
4037e774:	03bd      	mov.n	a11, a3
4037e776:	42a8      	l32i.n	a10, a2, 16
4037e778:	00e625        	call8	4037f5dc <tlsf_realloc>
4037e77b:	0a2d      	mov.n	a2, a10
    if(result) {
4037e77d:	5a9c      	beqz.n	a10, 4037e796 <multi_heap_realloc+0x62>
        heap->free_bytes += previous_block_size;
4037e77f:	1788      	l32i.n	a8, a7, 4
4037e781:	886a      	add.n	a8, a8, a6
4037e783:	1789      	s32i.n	a8, a7, 4
        heap->free_bytes -= tlsf_block_size(result);
4037e785:	0002e5        	call8	4037e7b4 <tlsf_block_size>
4037e788:	1788      	l32i.n	a8, a7, 4
4037e78a:	c0a8a0        	sub	a10, a8, a10
4037e78d:	17a9      	s32i.n	a10, a7, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037e78f:	2788      	l32i.n	a8, a7, 8
4037e791:	01ba87        	bgeu	a10, a8, 4037e796 <multi_heap_realloc+0x62>
            heap->minimum_free_bytes = heap->free_bytes;
4037e794:	27a9      	s32i.n	a10, a7, 8
    multi_heap_internal_unlock(heap);
4037e796:	07ad      	mov.n	a10, a7
4037e798:	fff2a5        	call8	4037e6c4 <multi_heap_internal_unlock>
    return result;
4037e79b:	000086        	j	4037e7a1 <multi_heap_realloc+0x6d>
4037e79e:	000000        	ill
}
4037e7a1:	f01d      	retw.n
	...

4037e7a4 <multi_heap_set_lock>:
{
4037e7a4:	004136        	entry	a1, 32
    heap->lock = lock;
4037e7a7:	0239      	s32i.n	a3, a2, 0
}
4037e7a9:	f01d      	retw.n
	...

4037e7ac <tlsf_alloc_overhead>:
{
	return 2 * block_header_overhead;
}

size_t tlsf_alloc_overhead(void)
{
4037e7ac:	004136        	entry	a1, 32
	return block_header_overhead;
}
4037e7af:	420c      	movi.n	a2, 4
4037e7b1:	f01d      	retw.n
	...

4037e7b4 <tlsf_block_size>:
{
4037e7b4:	004136        	entry	a1, 32
	if (ptr)
4037e7b7:	b28c      	beqz.n	a2, 4037e7c6 <tlsf_block_size+0x12>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e7b9:	f8c222        	addi	a2, a2, -8
4037e7bc:	1228      	l32i.n	a2, a2, 4
4037e7be:	c87c      	movi.n	a8, -4
4037e7c0:	102280        	and	a2, a2, a8
4037e7c3:	000046        	j	4037e7c8 <tlsf_block_size+0x14>
	size_t size = 0;
4037e7c6:	020c      	movi.n	a2, 0
}
4037e7c8:	f01d      	retw.n
	...

4037e7cc <tlsf_free>:
	return tlsf_memalign_offs(tlsf, align, size, 0);
}


void tlsf_free(tlsf_t tlsf, void* ptr)
{
4037e7cc:	004136        	entry	a1, 32
	/* Don't attempt to free a NULL pointer. */
	if (ptr)
4037e7cf:	3d9316        	beqz	a3, 4037ebac <tlsf_free+0x3e0>
	return tlsf_cast(block_header_t*,
4037e7d2:	f8c372        	addi	a7, a3, -8
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e7d5:	1798      	l32i.n	a9, a7, 4
	{
		control_t* control = tlsf_cast(control_t*, tlsf);
		block_header_t* block = block_from_ptr(ptr);
		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037e7d7:	0e6907        	bbci	a9, 0, 4037e7e9 <tlsf_free+0x1d>
4037e7da:	d9e4d1        	l32r	a13, 40374f6c <_iram_text_start+0xb68> (3c021de8 <_flash_rodata_start+0x1cc8>)
4037e7dd:	d9e4c1        	l32r	a12, 40374f70 <_iram_text_start+0xb6c> (3c026920 <__func__$6>)
4037e7e0:	76a2b2        	movi	a11, 0x276
4037e7e3:	d9e4a1        	l32r	a10, 40374f74 <_iram_text_start+0xb70> (3c02184f <_flash_rodata_start+0x172f>)
4037e7e6:	015425        	call8	4037fd28 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e7e9:	c87c      	movi.n	a8, -4
4037e7eb:	108980        	and	a8, a9, a8
}

/* Return location of next existing block. */
static inline __attribute__((always_inline)) block_header_t* block_next(const block_header_t* block)
{
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e7ee:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e7f1:	883a      	add.n	a8, a8, a3
		block_size(block) - block_header_overhead);
	tlsf_assert(!block_is_last(block));
4037e7f3:	3a0c      	movi.n	a10, 3
4037e7f5:	0e3a97        	bltu	a10, a9, 4037e807 <tlsf_free+0x3b>
4037e7f8:	d9e0d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037e7fb:	d9e0c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037e7fe:	a1a0b2        	movi	a11, 161
4037e801:	d9dfa1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037e804:	015225        	call8	4037fd28 <__assert_func>

/* Link a new block with its physical neighbor, return the neighbor. */
static inline __attribute__((always_inline)) block_header_t* block_link_next(block_header_t* block)
{
	block_header_t* next = block_next(block);
	next->prev_phys_block = block;
4037e807:	0879      	s32i.n	a7, a8, 0
	block->size |= block_header_prev_free_bit;
4037e809:	1898      	l32i.n	a9, a8, 4
4037e80b:	2a0c      	movi.n	a10, 2
4037e80d:	2099a0        	or	a9, a9, a10
4037e810:	1899      	s32i.n	a9, a8, 4
	block->size |= block_header_free_bit;
4037e812:	f8c3b2        	addi	a11, a3, -8
4037e815:	1b98      	l32i.n	a9, a11, 4
4037e817:	180c      	movi.n	a8, 1
4037e819:	208980        	or	a8, a9, a8
4037e81c:	1b89      	s32i.n	a8, a11, 4
}

/* Merge a just-freed block with an adjacent previous free block. */
tlsf_decl block_header_t* block_merge_prev(control_t* control, block_header_t* block)
{
	if (block_is_prev_free(block))
4037e81e:	0289a7        	bany	a9, a10, 4037e824 <tlsf_free+0x58>
4037e821:	005506        	j	4037e979 <tlsf_free+0x1ad>
	return block->prev_phys_block;
4037e824:	0b68      	l32i.n	a6, a11, 0
	{
		block_header_t* prev = block_prev(block);
		tlsf_assert(prev && "prev physical block can't be null");
4037e826:	00e656        	bnez	a6, 4037e838 <tlsf_free+0x6c>
4037e829:	d9d6d1        	l32r	a13, 40374f84 <_iram_text_start+0xb80> (3c021e20 <_flash_rodata_start+0x1d00>)
4037e82c:	d9d7c1        	l32r	a12, 40374f88 <_iram_text_start+0xb84> (3c02690c <__func__$5>)
4037e82f:	08a2b2        	movi	a11, 0x208
4037e832:	d9d6a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037e835:	014f25        	call8	4037fd28 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e838:	1688      	l32i.n	a8, a6, 4
		tlsf_assert(block_is_free(prev) && "prev block is not free though marked as such");
4037e83a:	0ee807        	bbsi	a8, 0, 4037e84c <tlsf_free+0x80>
4037e83d:	d9d4d1        	l32r	a13, 40374f90 <_iram_text_start+0xb8c> (3c021e4c <_flash_rodata_start+0x1d2c>)
4037e840:	d9d2c1        	l32r	a12, 40374f88 <_iram_text_start+0xb84> (3c02690c <__func__$5>)
4037e843:	09a2b2        	movi	a11, 0x209
4037e846:	d9d1a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037e849:	014de5        	call8	4037fd28 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e84c:	c97c      	movi.n	a9, -4
4037e84e:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037e851:	4298      	l32i.n	a9, a2, 16
4037e853:	759790        	extui	a9, a9, 23, 8
4037e856:	0fb897        	bgeu	a8, a9, 4037e869 <tlsf_free+0x9d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e859:	42a8      	l32i.n	a10, a2, 16
4037e85b:	54aea0        	extui	a10, a10, 14, 6
4037e85e:	d299a0        	quos	a9, a9, a10
4037e861:	d2a890        	quos	a10, a8, a9
		fl = 0;
4037e864:	0b0c      	movi.n	a11, 0
4037e866:	000d86        	j	4037e8a0 <tlsf_free+0xd4>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e869:	d88c      	beqz.n	a8, 4037e87a <tlsf_free+0xae>
4037e86b:	40f8b0        	nsau	a11, a8
4037e86e:	e0cbb2        	addi	a11, a11, -32
4037e871:	60b0b0        	neg	a11, a11
4037e874:	000146        	j	4037e87d <tlsf_free+0xb1>
4037e877:	000000        	ill
4037e87a:	00a0b2        	movi	a11, 0
	return bit - 1;
4037e87d:	ffcba2        	addi	a10, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e880:	042292        	l32i	a9, a2, 16
4037e883:	25c490        	extui	a12, a9, 20, 3
4037e886:	c0aac0        	sub	a10, a10, a12
4037e889:	400a00        	ssr	a10
4037e88c:	918080        	srl	a8, a8
4037e88f:	1a0c      	movi.n	a10, 1
4037e891:	401c00        	ssl	a12
4037e894:	a1aa00        	sll	a10, a10
4037e897:	30a8a0        	xor	a10, a8, a10
		fl -= (control->fl_index_shift - 1);
4037e89a:	249590        	extui	a9, a9, 5, 3
4037e89d:	c0bb90        	sub	a11, a11, a9
	block_header_t* prev = block->prev_free;
4037e8a0:	3698      	l32i.n	a9, a6, 12
	block_header_t* next = block->next_free;
4037e8a2:	26c8      	l32i.n	a12, a6, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037e8a4:	00e956        	bnez	a9, 4037e8b6 <tlsf_free+0xea>
4037e8a7:	d9bbd1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c021b48 <_flash_rodata_start+0x1a28>)
4037e8aa:	d9bbc1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037e8ad:	74a1b2        	movi	a11, 0x174
4037e8b0:	d9b7a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037e8b3:	014765        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037e8b6:	0cdc      	bnez.n	a12, 4037e8ca <tlsf_free+0xfe>
4037e8b8:	d9b9d1        	l32r	a13, 40374f9c <_iram_text_start+0xb98> (3c021b74 <_flash_rodata_start+0x1a54>)
4037e8bb:	d9b7c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037e8be:	75a1b2        	movi	a11, 0x175
4037e8c1:	d9b2a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037e8c4:	201110        	or	a1, a1, a1
4037e8c7:	014625        	call8	4037fd28 <__assert_func>
	next->prev_free = prev;
4037e8ca:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037e8cc:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037e8ce:	8298      	l32i.n	a9, a2, 32
4037e8d0:	4288      	l32i.n	a8, a2, 16
4037e8d2:	548e80        	extui	a8, a8, 14, 6
4037e8d5:	8288b0        	mull	a8, a8, a11
4037e8d8:	88aa      	add.n	a8, a8, a10
4037e8da:	a08890        	addx4	a8, a8, a9
4037e8dd:	0898      	l32i.n	a9, a8, 0
4037e8df:	369697        	bne	a6, a9, 4037e919 <tlsf_free+0x14d>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037e8e2:	08c9      	s32i.n	a12, a8, 0
		if (next == &control->block_null)
4037e8e4:	319c27        	bne	a12, a2, 4037e919 <tlsf_free+0x14d>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037e8e7:	7298      	l32i.n	a9, a2, 28
4037e8e9:	a09b90        	addx4	a9, a11, a9
4037e8ec:	09c8      	l32i.n	a12, a9, 0
4037e8ee:	180c      	movi.n	a8, 1
4037e8f0:	401a00        	ssl	a10
4037e8f3:	a18800        	sll	a8, a8
4037e8f6:	1088c0        	and	a8, a8, a12
4037e8f9:	3088c0        	xor	a8, a8, a12
4037e8fc:	0989      	s32i.n	a8, a9, 0
			if (!control->sl_bitmap[fl])
4037e8fe:	7288      	l32i.n	a8, a2, 28
4037e900:	a08b80        	addx4	a8, a11, a8
4037e903:	0888      	l32i.n	a8, a8, 0
4037e905:	08dc      	bnez.n	a8, 4037e919 <tlsf_free+0x14d>
				control->fl_bitmap &= ~(1U << fl);
4037e907:	6298      	l32i.n	a9, a2, 24
4037e909:	180c      	movi.n	a8, 1
4037e90b:	401b00        	ssl	a11
4037e90e:	a18800        	sll	a8, a8
4037e911:	108890        	and	a8, a8, a9
4037e914:	308890        	xor	a8, a8, a9
4037e917:	6289      	s32i.n	a8, a2, 24
4037e919:	1698      	l32i.n	a9, a6, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037e91b:	380c      	movi.n	a8, 3
4037e91d:	0e3897        	bltu	a8, a9, 4037e92f <tlsf_free+0x163>
4037e920:	d9a0d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c021e94 <_flash_rodata_start+0x1d74>)
4037e923:	d9a0c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c0268fc <__func__$3>)
4037e926:	f5a1b2        	movi	a11, 0x1f5
4037e929:	d998a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037e92c:	013fa5        	call8	4037fd28 <__assert_func>
4037e92f:	f8c332        	addi	a3, a3, -8
4037e932:	13a8      	l32i.n	a10, a3, 4
4037e934:	c87c      	movi.n	a8, -4
4037e936:	10aa80        	and	a10, a10, a8
	prev->size += block_size(block) + block_header_overhead;
4037e939:	aa4b      	addi.n	a10, a10, 4
4037e93b:	99aa      	add.n	a9, a9, a10
4037e93d:	1699      	s32i.n	a9, a6, 4
	return tlsf_cast(void*,
4037e93f:	a68b      	addi.n	a10, a6, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e941:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e944:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e947:	88aa      	add.n	a8, a8, a10
	tlsf_assert(!block_is_last(block));
4037e949:	3a0c      	movi.n	a10, 3
4037e94b:	0e3a97        	bltu	a10, a9, 4037e95d <tlsf_free+0x191>
4037e94e:	d98ad1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037e951:	d98ac1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037e954:	a1a0b2        	movi	a11, 161
4037e957:	d98aa1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037e95a:	013ce5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037e95d:	0869      	s32i.n	a6, a8, 0
	if (block_absorb_post_hook != NULL)
4037e95f:	d99281        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037e962:	089c      	beqz.n	a8, 4037e976 <tlsf_free+0x1aa>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037e964:	1c0c      	movi.n	a12, 1
4037e966:	0b1c      	movi.n	a11, 16
4037e968:	07ad      	mov.n	a10, a7
4037e96a:	d98f81        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037e96d:	0008e0        	callx8	a8
		block_remove(control, prev);
		block = block_absorb(prev, block);
4037e970:	067d      	mov.n	a7, a6
4037e972:	0000c6        	j	4037e979 <tlsf_free+0x1ad>
4037e975:	766000        	ee.ldf.64.xp	f6, f7, a0, a0
4037e978:	c73220        	ee.stf.64.xp	f3, f12, a2, a2
	return tlsf_cast(void*,
4037e97b:	8808      	l32i.n	a0, a8, 32
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e97d:	ca7c17        	bbci	a12, 17, 4037e94b <tlsf_free+0x17f>
4037e980:	10a8a0        	and	a10, a8, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037e983:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e986:	aa3a      	add.n	a10, a10, a3
4037e988:	0a9d      	mov.n	a9, a10
	tlsf_assert(!block_is_last(block));
4037e98a:	03a0b2        	movi	a11, 3
4037e98d:	0e3b87        	bltu	a11, a8, 4037e99f <tlsf_free+0x1d3>
4037e990:	d97ad1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037e993:	d97ac1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037e996:	a1a0b2        	movi	a11, 161
4037e999:	d979a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037e99c:	0138a5        	call8	4037fd28 <__assert_func>

/* Merge a just-freed block with an adjacent free block. */
tlsf_decl block_header_t* block_merge_next(control_t* control, block_header_t* block)
{
	block_header_t* next = block_next(block);
	tlsf_assert(next && "next physical block can't be null");
4037e99f:	dacc      	bnez.n	a10, 4037e9b0 <tlsf_free+0x1e4>
4037e9a1:	d982d1        	l32r	a13, 40374fac <_iram_text_start+0xba8> (3c021ecc <_flash_rodata_start+0x1dac>)
4037e9a4:	d983c1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c0268e8 <__func__$2>)
4037e9a7:	15a2b2        	movi	a11, 0x215
4037e9aa:	d978a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037e9ad:	0137a5        	call8	4037fd28 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e9b0:	1a88      	l32i.n	a8, a10, 4

	if (block_is_free(next))
4037e9b2:	02e807        	bbsi	a8, 0, 4037e9b8 <tlsf_free+0x1ec>
4037e9b5:	004646        	j	4037ead2 <tlsf_free+0x306>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e9b8:	cb7c      	movi.n	a11, -4
4037e9ba:	10c8b0        	and	a12, a8, a11
	if (size < control->small_block_size)
4037e9bd:	4288      	l32i.n	a8, a2, 16
4037e9bf:	758780        	extui	a8, a8, 23, 8
4037e9c2:	0fbc87        	bgeu	a12, a8, 4037e9d5 <tlsf_free+0x209>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e9c5:	42b8      	l32i.n	a11, a2, 16
4037e9c7:	54beb0        	extui	a11, a11, 14, 6
4037e9ca:	d288b0        	quos	a8, a8, a11
4037e9cd:	d2cc80        	quos	a12, a12, a8
		fl = 0;
4037e9d0:	0b0c      	movi.n	a11, 0
4037e9d2:	000d46        	j	4037ea0b <tlsf_free+0x23f>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e9d5:	cc8c      	beqz.n	a12, 4037e9e5 <tlsf_free+0x219>
4037e9d7:	40fcd0        	nsau	a13, a12
4037e9da:	e0cdd2        	addi	a13, a13, -32
4037e9dd:	60d0d0        	neg	a13, a13
4037e9e0:	000106        	j	4037e9e8 <tlsf_free+0x21c>
4037e9e3:	d20000        	quos	a0, a0, a0
4037e9e6:	8200a0        	mull	a0, a0, a10
	return bit - 1;
4037e9e9:	cd          	.byte	0xcd
4037e9ea:	0422b2ff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 0x120, q6, q6, q2, q2
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e9ee:	25e4b0        	extui	a14, a11, 20, 3
4037e9f1:	c088e0        	sub	a8, a8, a14
4037e9f4:	400800        	ssr	a8
4037e9f7:	9180c0        	srl	a8, a12
4037e9fa:	1c0c      	movi.n	a12, 1
4037e9fc:	401e00        	ssl	a14
4037e9ff:	a1cc00        	sll	a12, a12
4037ea02:	30c8c0        	xor	a12, a8, a12
		fl -= (control->fl_index_shift - 1);
4037ea05:	24b5b0        	extui	a11, a11, 5, 3
4037ea08:	c0bdb0        	sub	a11, a13, a11
	block_header_t* prev = block->prev_free;
4037ea0b:	3a88      	l32i.n	a8, a10, 12
	block_header_t* next = block->next_free;
4037ea0d:	2ad8      	l32i.n	a13, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037ea0f:	00e856        	bnez	a8, 4037ea21 <tlsf_free+0x255>
4037ea12:	d960d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c021b48 <_flash_rodata_start+0x1a28>)
4037ea15:	d960c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037ea18:	74a1b2        	movi	a11, 0x174
4037ea1b:	d95ca1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ea1e:	0130a5        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037ea21:	ddcc      	bnez.n	a13, 4037ea32 <tlsf_free+0x266>
4037ea23:	d95ed1        	l32r	a13, 40374f9c <_iram_text_start+0xb98> (3c021b74 <_flash_rodata_start+0x1a54>)
4037ea26:	d95cc1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037ea29:	75a1b2        	movi	a11, 0x175
4037ea2c:	d958a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ea2f:	012fa5        	call8	4037fd28 <__assert_func>
	next->prev_free = prev;
4037ea32:	3d89      	s32i.n	a8, a13, 12
	prev->next_free = next;
4037ea34:	0268d2        	s32i	a13, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037ea37:	82e8      	l32i.n	a14, a2, 32
4037ea39:	4288      	l32i.n	a8, a2, 16
4037ea3b:	548e80        	extui	a8, a8, 14, 6
4037ea3e:	8288b0        	mull	a8, a8, a11
4037ea41:	88ca      	add.n	a8, a8, a12
4037ea43:	a088e0        	addx4	a8, a8, a14
4037ea46:	08e8      	l32i.n	a14, a8, 0
4037ea48:	3699e7        	bne	a9, a14, 4037ea82 <tlsf_free+0x2b6>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037ea4b:	08d9      	s32i.n	a13, a8, 0
		if (next == &control->block_null)
4037ea4d:	319d27        	bne	a13, a2, 4037ea82 <tlsf_free+0x2b6>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037ea50:	7298      	l32i.n	a9, a2, 28
4037ea52:	a09b90        	addx4	a9, a11, a9
4037ea55:	09d8      	l32i.n	a13, a9, 0
4037ea57:	180c      	movi.n	a8, 1
4037ea59:	401c00        	ssl	a12
4037ea5c:	a18800        	sll	a8, a8
4037ea5f:	1088d0        	and	a8, a8, a13
4037ea62:	3088d0        	xor	a8, a8, a13
4037ea65:	0989      	s32i.n	a8, a9, 0
			if (!control->sl_bitmap[fl])
4037ea67:	7288      	l32i.n	a8, a2, 28
4037ea69:	a08b80        	addx4	a8, a11, a8
4037ea6c:	0888      	l32i.n	a8, a8, 0
4037ea6e:	08dc      	bnez.n	a8, 4037ea82 <tlsf_free+0x2b6>
				control->fl_bitmap &= ~(1U << fl);
4037ea70:	6298      	l32i.n	a9, a2, 24
4037ea72:	180c      	movi.n	a8, 1
4037ea74:	401b00        	ssl	a11
4037ea77:	a18800        	sll	a8, a8
4037ea7a:	108890        	and	a8, a8, a9
4037ea7d:	308890        	xor	a8, a8, a9
4037ea80:	6289      	s32i.n	a8, a2, 24
4037ea82:	1798      	l32i.n	a9, a7, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037ea84:	380c      	movi.n	a8, 3
4037ea86:	0e3897        	bltu	a8, a9, 4037ea98 <tlsf_free+0x2cc>
4037ea89:	d945d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c021e94 <_flash_rodata_start+0x1d74>)
4037ea8c:	d946c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c0268fc <__func__$3>)
4037ea8f:	f5a1b2        	movi	a11, 0x1f5
4037ea92:	d93ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ea95:	012925        	call8	4037fd28 <__assert_func>
4037ea98:	1ab8      	l32i.n	a11, a10, 4
4037ea9a:	c87c      	movi.n	a8, -4
4037ea9c:	10bb80        	and	a11, a11, a8
	prev->size += block_size(block) + block_header_overhead;
4037ea9f:	bb4b      	addi.n	a11, a11, 4
4037eaa1:	99ba      	add.n	a9, a9, a11
4037eaa3:	1799      	s32i.n	a9, a7, 4
4037eaa5:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037eaa8:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037eaab:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037eaad:	3b0c      	movi.n	a11, 3
4037eaaf:	0e3b97        	bltu	a11, a9, 4037eac1 <tlsf_free+0x2f5>
4037eab2:	d931d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037eab5:	d931c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037eab8:	a1a0b2        	movi	a11, 161
4037eabb:	d931a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037eabe:	0126a5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037eac1:	0879      	s32i.n	a7, a8, 0
	if (block_absorb_post_hook != NULL)
4037eac3:	d93981        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037eac6:	888c      	beqz.n	a8, 4037ead2 <tlsf_free+0x306>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037eac8:	1c0c      	movi.n	a12, 1
4037eaca:	0b1c      	movi.n	a11, 16
4037eacc:	d93781        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037eacf:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ead2:	1798      	l32i.n	a9, a7, 4
4037ead4:	c87c      	movi.n	a8, -4
4037ead6:	109980        	and	a9, a9, a8
	if (size < control->small_block_size)
4037ead9:	4288      	l32i.n	a8, a2, 16
4037eadb:	758780        	extui	a8, a8, 23, 8
4037eade:	0fb987        	bgeu	a9, a8, 4037eaf1 <tlsf_free+0x325>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037eae1:	42a8      	l32i.n	a10, a2, 16
4037eae3:	54aea0        	extui	a10, a10, 14, 6
4037eae6:	d288a0        	quos	a8, a8, a10
4037eae9:	d29980        	quos	a9, a9, a8
		fl = 0;
4037eaec:	0a0c      	movi.n	a10, 0
4037eaee:	000d06        	j	4037eb26 <tlsf_free+0x35a>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037eaf1:	b98c      	beqz.n	a9, 4037eb00 <tlsf_free+0x334>
4037eaf3:	40f9a0        	nsau	a10, a9
4037eaf6:	e0caa2        	addi	a10, a10, -32
4037eaf9:	60a0a0        	neg	a10, a10
4037eafc:	0000c6        	j	4037eb03 <tlsf_free+0x337>
4037eaff:	a0a200        	addx4	a10, a2, a0
4037eb02:	cab200        	float.s	f11, a2, 0
	return bit - 1;
4037eb05:	042282ff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 0x120, q6, q0, q2, q2
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037eb09:	25c480        	extui	a12, a8, 20, 3
4037eb0c:	c0bbc0        	sub	a11, a11, a12
4037eb0f:	400b00        	ssr	a11
4037eb12:	919090        	srl	a9, a9
4037eb15:	1b0c      	movi.n	a11, 1
4037eb17:	401c00        	ssl	a12
4037eb1a:	a1bb00        	sll	a11, a11
4037eb1d:	3099b0        	xor	a9, a9, a11
		fl -= (control->fl_index_shift - 1);
4037eb20:	248580        	extui	a8, a8, 5, 3
4037eb23:	c0aa80        	sub	a10, a10, a8
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037eb26:	82b8      	l32i.n	a11, a2, 32
4037eb28:	4288      	l32i.n	a8, a2, 16
4037eb2a:	548e80        	extui	a8, a8, 14, 6
4037eb2d:	8288a0        	mull	a8, a8, a10
4037eb30:	889a      	add.n	a8, a8, a9
4037eb32:	a088b0        	addx4	a8, a8, a11
4037eb35:	0888      	l32i.n	a8, a8, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037eb37:	d8cc      	bnez.n	a8, 4037eb48 <tlsf_free+0x37c>
4037eb39:	d91ed1        	l32r	a13, 40374fb4 <_iram_text_start+0xbb0> (3c021984 <_flash_rodata_start+0x1864>)
4037eb3c:	d91fc1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037eb3f:	90a1b2        	movi	a11, 0x190
4037eb42:	d912a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037eb45:	011e25        	call8	4037fd28 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037eb48:	d7cc      	bnez.n	a7, 4037eb59 <tlsf_free+0x38d>
4037eb4a:	d91cd1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c0219e8 <_flash_rodata_start+0x18c8>)
4037eb4d:	d91ac1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037eb50:	91a1b2        	movi	a11, 0x191
4037eb53:	d90ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037eb56:	011d25        	call8	4037fd28 <__assert_func>
	block->next_free = current;
4037eb59:	2789      	s32i.n	a8, a7, 8
	block->prev_free = &control->block_null;
4037eb5b:	036722        	s32i	a2, a7, 12
	current->prev_free = block;
4037eb5e:	036872        	s32i	a7, a8, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037eb61:	833b      	addi.n	a8, a3, 3
4037eb63:	cb7c      	movi.n	a11, -4
4037eb65:	1088b0        	and	a8, a8, a11
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037eb68:	0e1387        	beq	a3, a8, 4037eb7a <tlsf_free+0x3ae>
4037eb6b:	d915d1        	l32r	a13, 40374fc0 <_iram_text_start+0xbbc> (3c021a24 <_flash_rodata_start+0x1904>)
4037eb6e:	d912c1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037eb71:	96a1b2        	movi	a11, 0x196
4037eb74:	d906a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037eb77:	011b25        	call8	4037fd28 <__assert_func>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037eb7a:	82b8      	l32i.n	a11, a2, 32
4037eb7c:	4288      	l32i.n	a8, a2, 16
4037eb7e:	548e80        	extui	a8, a8, 14, 6
4037eb81:	828a80        	mull	a8, a10, a8
4037eb84:	898a      	add.n	a8, a9, a8
4037eb86:	a088b0        	addx4	a8, a8, a11
4037eb89:	0879      	s32i.n	a7, a8, 0
	control->fl_bitmap |= (1U << fl);
4037eb8b:	62b8      	l32i.n	a11, a2, 24
4037eb8d:	180c      	movi.n	a8, 1
4037eb8f:	401a00        	ssl	a10
4037eb92:	a1c800        	sll	a12, a8
4037eb95:	20bbc0        	or	a11, a11, a12
4037eb98:	62b9      	s32i.n	a11, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037eb9a:	72b8      	l32i.n	a11, a2, 28
4037eb9c:	a0aab0        	addx4	a10, a10, a11
4037eb9f:	0ab8      	l32i.n	a11, a10, 0
4037eba1:	401900        	ssl	a9
4037eba4:	a18800        	sll	a8, a8
4037eba7:	208b80        	or	a8, a11, a8
4037ebaa:	0a89      	s32i.n	a8, a10, 0
		block_mark_as_free(block);
		block = block_merge_prev(control, block);
		block = block_merge_next(control, block);
		block_insert(control, block);
	}
}
4037ebac:	f01d      	retw.n
	...

4037ebb0 <tlsf_get_pool>:
{
4037ebb0:	004136        	entry	a1, 32
	return tlsf_cast(pool_t, (char*)tlsf + tlsf_size(tlsf));
4037ebb3:	02ad      	mov.n	a10, a2
4037ebb5:	00f625        	call8	4037fb18 <tlsf_size>
}
4037ebb8:	22aa      	add.n	a2, a2, a10
4037ebba:	f01d      	retw.n

4037ebbc <tlsf_malloc>:
{
4037ebbc:	004136        	entry	a1, 32
4037ebbf:	028d      	mov.n	a8, a2
	if (size)
4037ebc1:	3af316        	beqz	a3, 4037ef74 <tlsf_malloc+0x3b8>
	return (x + (align - 1)) & ~(align - 1);
4037ebc4:	333b      	addi.n	a3, a3, 3
4037ebc6:	c97c      	movi.n	a9, -4
4037ebc8:	103390        	and	a3, a3, a9
	if (control == NULL)
4037ebcb:	3aa216        	beqz	a2, 4037ef79 <tlsf_malloc+0x3bd>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037ebce:	42a8      	l32i.n	a10, a2, 16
4037ebd0:	54a8a0        	extui	a10, a10, 8, 6
4037ebd3:	190c      	movi.n	a9, 1
4037ebd5:	401a00        	ssl	a10
4037ebd8:	a19900        	sll	a9, a9
		if (aligned < tlsf_block_size_max(control)) 
4037ebdb:	023397        	bltu	a3, a9, 4037ebe1 <tlsf_malloc+0x25>
4037ebde:	00e686        	j	4037ef7c <tlsf_malloc+0x3c0>
			adjust = tlsf_max(aligned, block_size_min);
4037ebe1:	c90c      	movi.n	a9, 12
4037ebe3:	733390        	maxu	a3, a3, a9
	if (*size >= control->small_block_size)
4037ebe6:	4298      	l32i.n	a9, a2, 16
4037ebe8:	759790        	extui	a9, a9, 23, 8
4037ebeb:	09cd      	mov.n	a12, a9
4037ebed:	373397        	bltu	a3, a9, 4037ec28 <tlsf_malloc+0x6c>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ebf0:	40f3a0        	nsau	a10, a3
	return bit - 1;
4037ebf3:	e1caa2        	addi	a10, a10, -31
4037ebf6:	60a0a0        	neg	a10, a10
		const size_t round = (1 << (tlsf_fls_sizet(*size) - control->sl_index_count_log2));
4037ebf9:	42b8      	l32i.n	a11, a2, 16
4037ebfb:	25b4b0        	extui	a11, a11, 20, 3
4037ebfe:	c0bab0        	sub	a11, a10, a11
4037ec01:	1a0c      	movi.n	a10, 1
4037ec03:	401b00        	ssl	a11
4037ec06:	a1aa00        	sll	a10, a10
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037ec09:	ffcab2        	addi	a11, a10, -1
4037ec0c:	0e0ab7        	bnone	a10, a11, 4037ec1e <tlsf_malloc+0x62>
4037ec0f:	d8edd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c021bd4 <_flash_rodata_start+0x1ab4>)
4037ec12:	d8edc1        	l32r	a12, 40374fc8 <_iram_text_start+0xbc4> (3c0269e4 <__func__$19>)
4037ec15:	f3a0b2        	movi	a11, 243
4037ec18:	d8dda1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ec1b:	0110e5        	call8	4037fd28 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037ec1e:	33aa      	add.n	a3, a3, a10
4037ec20:	330b      	addi.n	a3, a3, -1
4037ec22:	60a0a0        	neg	a10, a10
4037ec25:	1033a0        	and	a3, a3, a10
	if (size < control->small_block_size)
4037ec28:	10b3c7        	bgeu	a3, a12, 4037ec3c <tlsf_malloc+0x80>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037ec2b:	48a8      	l32i.n	a10, a8, 16
4037ec2d:	54aea0        	extui	a10, a10, 14, 6
4037ec30:	d299a0        	quos	a9, a9, a10
4037ec33:	d29390        	quos	a9, a3, a9
		fl = 0;
4037ec36:	0a0c      	movi.n	a10, 0
4037ec38:	000c86        	j	4037ec6e <tlsf_malloc+0xb2>
4037ec3b:	a38c00        	movltz	a8, a12, a0
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ec3e:	40f3a0        	nsau	a10, a3
4037ec41:	e0caa2        	addi	a10, a10, -32
4037ec44:	60a0a0        	neg	a10, a10
4037ec47:	000086        	j	4037ec4d <tlsf_malloc+0x91>
4037ec4a:	00a0a2        	movi	a10, 0
	return bit - 1;
4037ec4d:	9a0b      	addi.n	a9, a10, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037ec4f:	48b8      	l32i.n	a11, a8, 16
4037ec51:	25d4b0        	extui	a13, a11, 20, 3
4037ec54:	c099d0        	sub	a9, a9, a13
4037ec57:	400900        	ssr	a9
4037ec5a:	919030        	srl	a9, a3
4037ec5d:	1c0c      	movi.n	a12, 1
4037ec5f:	401d00        	ssl	a13
4037ec62:	a1cc00        	sll	a12, a12
4037ec65:	3099c0        	xor	a9, a9, a12
		fl -= (control->fl_index_shift - 1);
4037ec68:	24b5b0        	extui	a11, a11, 5, 3
4037ec6b:	c0aab0        	sub	a10, a10, a11
		** mapping_search can futz with the size, so for excessively large sizes it can sometimes wind up 
		** with indices that are off the end of the block array.
		** So, we protect against that here, since this is the only callsite of mapping_search.
		** Note that we don't need to check sl, since it comes from a modulo operation that guarantees it's always in range.
		*/
		if (fl < control->fl_index_count)
4037ec6e:	48b8      	l32i.n	a11, a8, 16
4037ec70:	44b0b0        	extui	a11, a11, 0, 5
4037ec73:	022ab7        	blt	a10, a11, 4037ec79 <tlsf_malloc+0xbd>
4037ec76:	00c1c6        	j	4037ef81 <tlsf_malloc+0x3c5>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037ec79:	78c8      	l32i.n	a12, a8, 28
4037ec7b:	a0bac0        	addx4	a11, a10, a12
4037ec7e:	0bd8      	l32i.n	a13, a11, 0
4037ec80:	fb7c      	movi.n	a11, -1
4037ec82:	401900        	ssl	a9
4037ec85:	a19b00        	sll	a9, a11
4037ec88:	10bd90        	and	a11, a13, a9
	if (!sl_map)
4037ec8b:	3b8d97        	bany	a13, a9, 4037ecca <tlsf_malloc+0x10e>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037ec8e:	68b8      	l32i.n	a11, a8, 24
4037ec90:	aa1b      	addi.n	a10, a10, 1
4037ec92:	f97c      	movi.n	a9, -1
4037ec94:	401a00        	ssl	a10
4037ec97:	a19900        	sll	a9, a9
4037ec9a:	10db90        	and	a13, a11, a9
		if (!fl_map)
4037ec9d:	028b97        	bany	a11, a9, 4037eca3 <tlsf_malloc+0xe7>
4037eca0:	00b886        	j	4037ef86 <tlsf_malloc+0x3ca>
	return __builtin_ffs(word) - 1;
4037eca3:	60a0d0        	neg	a10, a13
4037eca6:	10aad0        	and	a10, a10, a13
4037eca9:	40faa0        	nsau	a10, a10
4037ecac:	e1caa2        	addi	a10, a10, -31
4037ecaf:	60a0a0        	neg	a10, a10
		sl_map = control->sl_bitmap[fl];
4037ecb2:	a0cac0        	addx4	a12, a10, a12
4037ecb5:	002cb2        	l32i	a11, a12, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037ecb8:	00eb56        	bnez	a11, 4037ecca <tlsf_malloc+0x10e>
4037ecbb:	d8c4d1        	l32r	a13, 40374fcc <_iram_text_start+0xbc8> (3c021c14 <_flash_rodata_start+0x1af4>)
4037ecbe:	d8c4c1        	l32r	a12, 40374fd0 <_iram_text_start+0xbcc> (3c026970 <__func__$11>)
4037ecc1:	67a1b2        	movi	a11, 0x167
4037ecc4:	d8b2a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ecc7:	010625        	call8	4037fd28 <__assert_func>
	return __builtin_ffs(word) - 1;
4037ecca:	6090b0        	neg	a9, a11
4037eccd:	1099b0        	and	a9, a9, a11
4037ecd0:	40f990        	nsau	a9, a9
4037ecd3:	e1c9b2        	addi	a11, a9, -31
4037ecd6:	60b0b0        	neg	a11, a11
	return control->blocks[fl * control->sl_index_count + sl];
4037ecd9:	88c8      	l32i.n	a12, a8, 32
4037ecdb:	4898      	l32i.n	a9, a8, 16
4037ecdd:	549e90        	extui	a9, a9, 14, 6
4037ece0:	8299a0        	mull	a9, a9, a10
4037ece3:	9b9a      	add.n	a9, a11, a9
4037ece5:	a099c0        	addx4	a9, a9, a12
4037ece8:	0928      	l32i.n	a2, a9, 0
		{
			block = search_suitable_block(control, &fl, &sl);
		}
	}

	if (block)
4037ecea:	29a216        	beqz	a2, 4037ef88 <tlsf_malloc+0x3cc>
4037eced:	1298      	l32i.n	a9, a2, 4
4037ecef:	fcafc2        	movi	a12, -4
4037ecf2:	1099c0        	and	a9, a9, a12
	{
		tlsf_assert(block_size(block) >= *size);
4037ecf5:	0eb937        	bgeu	a9, a3, 4037ed07 <tlsf_malloc+0x14b>
4037ecf8:	d8b7d1        	l32r	a13, 40374fd4 <_iram_text_start+0xbd0> (3c021c50 <_flash_rodata_start+0x1b30>)
4037ecfb:	d8b7c1        	l32r	a12, 40374fd8 <_iram_text_start+0xbd4> (3c026988 <__func__$12>)
4037ecfe:	6aa2b2        	movi	a11, 0x26a
4037ed01:	d8a2a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ed04:	010225        	call8	4037fd28 <__assert_func>
	block_header_t* prev = block->prev_free;
4037ed07:	3298      	l32i.n	a9, a2, 12
	block_header_t* next = block->next_free;
4037ed09:	22c8      	l32i.n	a12, a2, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037ed0b:	00e956        	bnez	a9, 4037ed1d <tlsf_malloc+0x161>
4037ed0e:	d8a1d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c021b48 <_flash_rodata_start+0x1a28>)
4037ed11:	d8a1c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037ed14:	74a1b2        	movi	a11, 0x174
4037ed17:	d89da1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ed1a:	0100e5        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037ed1d:	dccc      	bnez.n	a12, 4037ed2e <tlsf_malloc+0x172>
4037ed1f:	d89fd1        	l32r	a13, 40374f9c <_iram_text_start+0xb98> (3c021b74 <_flash_rodata_start+0x1a54>)
4037ed22:	d89dc1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037ed25:	75a1b2        	movi	a11, 0x175
4037ed28:	d899a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ed2b:	00ffe5        	call8	4037fd28 <__assert_func>
	next->prev_free = prev;
4037ed2e:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037ed30:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037ed32:	88d8      	l32i.n	a13, a8, 32
4037ed34:	4898      	l32i.n	a9, a8, 16
4037ed36:	549e90        	extui	a9, a9, 14, 6
4037ed39:	829a90        	mull	a9, a10, a9
4037ed3c:	9b9a      	add.n	a9, a11, a9
4037ed3e:	a099d0        	addx4	a9, a9, a13
4037ed41:	09d8      	l32i.n	a13, a9, 0
4037ed43:	3792d7        	bne	a2, a13, 4037ed7e <tlsf_malloc+0x1c2>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037ed46:	09c9      	s32i.n	a12, a9, 0
		if (next == &control->block_null)
4037ed48:	329c87        	bne	a12, a8, 4037ed7e <tlsf_malloc+0x1c2>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037ed4b:	78c8      	l32i.n	a12, a8, 28
4037ed4d:	a0cac0        	addx4	a12, a10, a12
4037ed50:	0cd8      	l32i.n	a13, a12, 0
4037ed52:	190c      	movi.n	a9, 1
4037ed54:	401b00        	ssl	a11
4037ed57:	a19900        	sll	a9, a9
4037ed5a:	1099d0        	and	a9, a9, a13
4037ed5d:	3099d0        	xor	a9, a9, a13
4037ed60:	0c99      	s32i.n	a9, a12, 0
			if (!control->sl_bitmap[fl])
4037ed62:	7898      	l32i.n	a9, a8, 28
4037ed64:	a09a90        	addx4	a9, a10, a9
4037ed67:	0998      	l32i.n	a9, a9, 0
4037ed69:	19dc      	bnez.n	a9, 4037ed7e <tlsf_malloc+0x1c2>
				control->fl_bitmap &= ~(1U << fl);
4037ed6b:	68b8      	l32i.n	a11, a8, 24
4037ed6d:	190c      	movi.n	a9, 1
4037ed6f:	401a00        	ssl	a10
4037ed72:	a19900        	sll	a9, a9
4037ed75:	1099b0        	and	a9, a9, a11
4037ed78:	3099b0        	xor	a9, a9, a11
4037ed7b:	066892        	s32i	a9, a8, 24
tlsf_decl void* block_prepare_used(control_t* control, block_header_t* block, size_t size)
{
	void* p = 0;
	if (block)
	{
		tlsf_assert(size && "size must be non-zero");
4037ed7e:	00e356        	bnez	a3, 4037ed90 <tlsf_malloc+0x1d4>
4037ed81:	d896d1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c021c6c <_flash_rodata_start+0x1b4c>)
4037ed84:	d897c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02695c <__func__$10>)
4037ed87:	76a2b2        	movi	a11, 0x276
4037ed8a:	d880a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ed8d:	00f9a5        	call8	4037fd28 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037ed90:	1298      	l32i.n	a9, a2, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037ed92:	0ee907        	bbsi	a9, 0, 4037eda4 <tlsf_malloc+0x1e8>
4037ed95:	d893d1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c021c8c <_flash_rodata_start+0x1b6c>)
4037ed98:	d894c1        	l32r	a12, 40374fe8 <_iram_text_start+0xbe4> (3c02694c <__func__$9>)
4037ed9b:	24a2b2        	movi	a11, 0x224
4037ed9e:	d87ba1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037eda1:	00f865        	call8	4037fd28 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037eda4:	ca7c      	movi.n	a10, -4
4037eda6:	10b9a0        	and	a11, a9, a10
	return block_size(block) >= sizeof(block_header_t) + size;
4037eda9:	10c392        	addi	a9, a3, 16
	if (block_can_split(block, size))
4037edac:	02bb97        	bgeu	a11, a9, 4037edb2 <tlsf_malloc+0x1f6>
4037edaf:	0061c6        	j	4037ef3a <tlsf_malloc+0x37e>
	return tlsf_cast(void*,
4037edb2:	d28b      	addi.n	a13, a2, 8
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037edb4:	93aa      	add.n	a9, a3, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037edb6:	9d9a      	add.n	a9, a13, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037edb8:	c0ab30        	sub	a10, a11, a3
4037edbb:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(void*,
4037edbe:	c98b      	addi.n	a12, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037edc0:	e9bb      	addi.n	a14, a9, 11
4037edc2:	cf7c      	movi.n	a15, -4
4037edc4:	10eef0        	and	a14, a14, a15
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037edc7:	0e1ce7        	beq	a12, a14, 4037edd9 <tlsf_malloc+0x21d>
4037edca:	d888d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c021cbc <_flash_rodata_start+0x1b9c>)
4037edcd:	d888c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037edd0:	c4a1b2        	movi	a11, 0x1c4
4037edd3:	d86ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037edd6:	00f525        	call8	4037fd28 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037edd9:	ea3a      	add.n	a14, a10, a3
4037eddb:	ee4b      	addi.n	a14, a14, 4
4037eddd:	0e1be7        	beq	a11, a14, 4037edef <tlsf_malloc+0x233>
4037ede0:	d885d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c021d30 <_flash_rodata_start+0x1c10>)
4037ede3:	d883c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037ede6:	c7a1b2        	movi	a11, 0x1c7
4037ede9:	d868a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037edec:	00f3a5        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037edef:	19b8      	l32i.n	a11, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037edf1:	14b0b0        	extui	a11, a11, 0, 2
4037edf4:	20aab0        	or	a10, a10, a11
4037edf7:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037edf9:	cb7c      	movi.n	a11, -4
4037edfb:	10aab0        	and	a10, a10, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037edfe:	bb0c      	movi.n	a11, 11
4037ee00:	0e3ba7        	bltu	a11, a10, 4037ee12 <tlsf_malloc+0x256>
4037ee03:	d87dd1        	l32r	a13, 40374ff8 <_iram_text_start+0xbf4> (3c021d70 <_flash_rodata_start+0x1c50>)
4037ee06:	d87ac1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037ee09:	c9a1b2        	movi	a11, 0x1c9
4037ee0c:	d860a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037ee0f:	00f1a5        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037ee12:	12a8      	l32i.n	a10, a2, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037ee14:	14a0a0        	extui	a10, a10, 0, 2
4037ee17:	20aa30        	or	a10, a10, a3
4037ee1a:	12a9      	s32i.n	a10, a2, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee1c:	19b8      	l32i.n	a11, a9, 4
4037ee1e:	ca7c      	movi.n	a10, -4
4037ee20:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ee23:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ee26:	acaa      	add.n	a10, a12, a10
	tlsf_assert(!block_is_last(block));
4037ee28:	3c0c      	movi.n	a12, 3
4037ee2a:	0e3cb7        	bltu	a12, a11, 4037ee3c <tlsf_malloc+0x280>
4037ee2d:	d852d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037ee30:	d853c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037ee33:	a1a0b2        	movi	a11, 161
4037ee36:	d852a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037ee39:	00eee5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037ee3c:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_prev_free_bit;
4037ee3e:	1ab8      	l32i.n	a11, a10, 4
4037ee40:	2c0c      	movi.n	a12, 2
4037ee42:	20bbc0        	or	a11, a11, a12
4037ee45:	1ab9      	s32i.n	a11, a10, 4
	block->size |= block_header_free_bit;
4037ee47:	19a8      	l32i.n	a10, a9, 4
4037ee49:	1b0c      	movi.n	a11, 1
4037ee4b:	20aab0        	or	a10, a10, a11
4037ee4e:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ee50:	12b8      	l32i.n	a11, a2, 4
4037ee52:	ca7c      	movi.n	a10, -4
4037ee54:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ee57:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ee5a:	ddaa      	add.n	a13, a13, a10
	tlsf_assert(!block_is_last(block));
4037ee5c:	3a0c      	movi.n	a10, 3
4037ee5e:	0e3ab7        	bltu	a10, a11, 4037ee70 <tlsf_malloc+0x2b4>
4037ee61:	d845d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037ee64:	d846c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037ee67:	a1a0b2        	movi	a11, 161
4037ee6a:	d845a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037ee6d:	00eba5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037ee70:	0d29      	s32i.n	a2, a13, 0
	block->size |= block_header_prev_free_bit;
4037ee72:	19a8      	l32i.n	a10, a9, 4
4037ee74:	2b0c      	movi.n	a11, 2
4037ee76:	20bab0        	or	a11, a10, a11
4037ee79:	19b9      	s32i.n	a11, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
4037ee7b:	cb7c      	movi.n	a11, -4
4037ee7d:	10aab0        	and	a10, a10, a11
	if (size < control->small_block_size)
4037ee80:	48b8      	l32i.n	a11, a8, 16
4037ee82:	75b7b0        	extui	a11, a11, 23, 8
4037ee85:	0fbab7        	bgeu	a10, a11, 4037ee98 <tlsf_malloc+0x2dc>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037ee88:	48c8      	l32i.n	a12, a8, 16
4037ee8a:	54cec0        	extui	a12, a12, 14, 6
4037ee8d:	d2bbc0        	quos	a11, a11, a12
4037ee90:	d2aab0        	quos	a10, a10, a11
		fl = 0;
4037ee93:	0c0c      	movi.n	a12, 0
4037ee95:	000cc6        	j	4037eecc <tlsf_malloc+0x310>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037ee98:	aa8c      	beqz.n	a10, 4037eea6 <tlsf_malloc+0x2ea>
4037ee9a:	40fac0        	nsau	a12, a10
4037ee9d:	e0ccc2        	addi	a12, a12, -32
4037eea0:	60c0c0        	neg	a12, a12
4037eea3:	000086        	j	4037eea9 <tlsf_malloc+0x2ed>
4037eea6:	00a0c2        	movi	a12, 0
	return bit - 1;
4037eea9:	ffccd2        	addi	a13, a12, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037eeac:	0428b2        	l32i	a11, a8, 16
4037eeaf:	25e4b0        	extui	a14, a11, 20, 3
4037eeb2:	c0dde0        	sub	a13, a13, a14
4037eeb5:	400d00        	ssr	a13
4037eeb8:	91a0a0        	srl	a10, a10
4037eebb:	1d0c      	movi.n	a13, 1
4037eebd:	401e00        	ssl	a14
4037eec0:	a1dd00        	sll	a13, a13
4037eec3:	30aad0        	xor	a10, a10, a13
		fl -= (control->fl_index_shift - 1);
4037eec6:	24b5b0        	extui	a11, a11, 5, 3
4037eec9:	c0ccb0        	sub	a12, a12, a11
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037eecc:	88d8      	l32i.n	a13, a8, 32
4037eece:	48b8      	l32i.n	a11, a8, 16
4037eed0:	54beb0        	extui	a11, a11, 14, 6
4037eed3:	82bbc0        	mull	a11, a11, a12
4037eed6:	bbaa      	add.n	a11, a11, a10
4037eed8:	a0bbd0        	addx4	a11, a11, a13
4037eedb:	0bb8      	l32i.n	a11, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037eedd:	dbcc      	bnez.n	a11, 4037eeee <tlsf_malloc+0x332>
4037eedf:	d835d1        	l32r	a13, 40374fb4 <_iram_text_start+0xbb0> (3c021984 <_flash_rodata_start+0x1864>)
4037eee2:	d835c1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037eee5:	90a1b2        	movi	a11, 0x190
4037eee8:	d829a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037eeeb:	00e3e5        	call8	4037fd28 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037eeee:	09dc      	bnez.n	a9, 4037ef02 <tlsf_malloc+0x346>
4037eef0:	d833d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c0219e8 <_flash_rodata_start+0x18c8>)
4037eef3:	d831c1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037eef6:	91a1b2        	movi	a11, 0x191
4037eef9:	d824a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037eefc:	201110        	or	a1, a1, a1
4037eeff:	00e2a5        	call8	4037fd28 <__assert_func>
	block->next_free = current;
4037ef02:	29b9      	s32i.n	a11, a9, 8
	block->prev_free = &control->block_null;
4037ef04:	3989      	s32i.n	a8, a9, 12
	current->prev_free = block;
4037ef06:	3b99      	s32i.n	a9, a11, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037ef08:	88d8      	l32i.n	a13, a8, 32
4037ef0a:	48b8      	l32i.n	a11, a8, 16
4037ef0c:	54beb0        	extui	a11, a11, 14, 6
4037ef0f:	82bcb0        	mull	a11, a12, a11
4037ef12:	baba      	add.n	a11, a10, a11
4037ef14:	a0bbd0        	addx4	a11, a11, a13
4037ef17:	0b99      	s32i.n	a9, a11, 0
	control->fl_bitmap |= (1U << fl);
4037ef19:	68b8      	l32i.n	a11, a8, 24
4037ef1b:	190c      	movi.n	a9, 1
4037ef1d:	401c00        	ssl	a12
4037ef20:	a1d900        	sll	a13, a9
4037ef23:	20bbd0        	or	a11, a11, a13
4037ef26:	68b9      	s32i.n	a11, a8, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037ef28:	7888      	l32i.n	a8, a8, 28
4037ef2a:	a0cc80        	addx4	a12, a12, a8
4037ef2d:	0c88      	l32i.n	a8, a12, 0
4037ef2f:	401a00        	ssl	a10
4037ef32:	a19900        	sll	a9, a9
4037ef35:	208890        	or	a8, a8, a9
4037ef38:	0c89      	s32i.n	a8, a12, 0
	return tlsf_cast(void*,
4037ef3a:	a28b      	addi.n	a10, a2, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ef3c:	1298      	l32i.n	a9, a2, 4
4037ef3e:	c87c      	movi.n	a8, -4
4037ef40:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037ef43:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037ef46:	88aa      	add.n	a8, a8, a10
	tlsf_assert(!block_is_last(block));
4037ef48:	3b0c      	movi.n	a11, 3
4037ef4a:	0e3b97        	bltu	a11, a9, 4037ef5c <tlsf_malloc+0x3a0>
4037ef4d:	d80ad1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037ef50:	d80bc1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037ef53:	a1a0b2        	movi	a11, 161
4037ef56:	d80aa1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037ef59:	00dce5        	call8	4037fd28 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037ef5c:	1898      	l32i.n	a9, a8, 4
4037ef5e:	db7c      	movi.n	a11, -3
4037ef60:	1099b0        	and	a9, a9, a11
4037ef63:	1899      	s32i.n	a9, a8, 4
	block->size &= ~block_header_free_bit;
4037ef65:	1288      	l32i.n	a8, a2, 4
4037ef67:	e97c      	movi.n	a9, -2
4037ef69:	108890        	and	a8, a8, a9
4037ef6c:	1289      	s32i.n	a8, a2, 4
		block_trim_free(control, block, size);
		block_mark_as_used(block);
		p = block_to_ptr(block);
4037ef6e:	0a2d      	mov.n	a2, a10
4037ef70:	000506        	j	4037ef88 <tlsf_malloc+0x3cc>
4037ef73:	020c00        	andb	b0, b12, b0
		return NULL;
4037ef76:	000386        	j	4037ef88 <tlsf_malloc+0x3cc>
4037ef79:	0002c6        	j	4037ef88 <tlsf_malloc+0x3cc>
4037ef7c:	020c      	movi.n	a2, 0
4037ef7e:	000186        	j	4037ef88 <tlsf_malloc+0x3cc>
	void* p = 0;
4037ef81:	020c      	movi.n	a2, 0
4037ef83:	000046        	j	4037ef88 <tlsf_malloc+0x3cc>
4037ef86:	020c      	movi.n	a2, 0
}
4037ef88:	f01d      	retw.n
	...

4037ef8c <tlsf_memalign_offs>:
{
4037ef8c:	004136        	entry	a1, 32
4037ef8f:	02cd      	mov.n	a12, a2
	if (size)
4037ef91:	74ac      	beqz.n	a4, 4037efbc <tlsf_memalign_offs+0x30>
	return (x + (align - 1)) & ~(align - 1);
4037ef93:	443b      	addi.n	a4, a4, 3
4037ef95:	c87c      	movi.n	a8, -4
4037ef97:	104480        	and	a4, a4, a8
	if (control == NULL)
4037ef9a:	629c      	beqz.n	a2, 4037efb4 <tlsf_memalign_offs+0x28>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037ef9c:	4298      	l32i.n	a9, a2, 16
4037ef9e:	549890        	extui	a9, a9, 8, 6
4037efa1:	180c      	movi.n	a8, 1
4037efa3:	401900        	ssl	a9
4037efa6:	a18800        	sll	a8, a8
		if (aligned < tlsf_block_size_max(control)) 
4037efa9:	0db487        	bgeu	a4, a8, 4037efba <tlsf_memalign_offs+0x2e>
			adjust = tlsf_max(aligned, block_size_min);
4037efac:	c80c      	movi.n	a8, 12
4037efae:	734480        	maxu	a4, a4, a8
4037efb1:	0001c6        	j	4037efbc <tlsf_memalign_offs+0x30>
	size_t adjust = 0;
4037efb4:	040c      	movi.n	a4, 0
4037efb6:	000086        	j	4037efbc <tlsf_memalign_offs+0x30>
4037efb9:	040c00        	extui	a0, a0, 12, 1
	return (x + (align - 1)) & ~(align - 1);
4037efbc:	953b      	addi.n	a9, a5, 3
4037efbe:	c87c      	movi.n	a8, -4
4037efc0:	109980        	and	a9, a9, a8
	const size_t gap_minimum = sizeof(block_header_t) + off_adjust;
4037efc3:	10c9d2        	addi	a13, a9, 16
	const size_t size_with_gap = adjust_request_size(tlsf, adjust + align + gap_minimum - off_adjust, align);
4037efc6:	a34a      	add.n	a10, a3, a4
4037efc8:	aada      	add.n	a10, a10, a13
4037efca:	c08a90        	sub	a8, a10, a9
	if (size)
4037efcd:	3f1a97        	beq	a10, a9, 4037f010 <tlsf_memalign_offs+0x84>
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037efd0:	a30b      	addi.n	a10, a3, -1
4037efd2:	0e03a7        	bnone	a3, a10, 4037efe4 <tlsf_memalign_offs+0x58>
4037efd5:	d7fbd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c021bd4 <_flash_rodata_start+0x1ab4>)
4037efd8:	d7fcc1        	l32r	a12, 40374fc8 <_iram_text_start+0xbc4> (3c0269e4 <__func__$19>)
4037efdb:	f3a0b2        	movi	a11, 243
4037efde:	d7eba1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037efe1:	00d465        	call8	4037fd28 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037efe4:	883a      	add.n	a8, a8, a3
4037efe6:	880b      	addi.n	a8, a8, -1
4037efe8:	60a030        	neg	a10, a3
4037efeb:	1088a0        	and	a8, a8, a10
	if (control == NULL)
4037efee:	6c9c      	beqz.n	a12, 4037f008 <tlsf_memalign_offs+0x7c>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037eff0:	4cb8      	l32i.n	a11, a12, 16
4037eff2:	54b8b0        	extui	a11, a11, 8, 6
4037eff5:	1a0c      	movi.n	a10, 1
4037eff7:	401b00        	ssl	a11
4037effa:	a1aa00        	sll	a10, a10
		if (aligned < tlsf_block_size_max(control)) 
4037effd:	0db8a7        	bgeu	a8, a10, 4037f00e <tlsf_memalign_offs+0x82>
			adjust = tlsf_max(aligned, block_size_min);
4037f000:	ca0c      	movi.n	a10, 12
4037f002:	7388a0        	maxu	a8, a8, a10
4037f005:	0001c6        	j	4037f010 <tlsf_memalign_offs+0x84>
	size_t adjust = 0;
4037f008:	080c      	movi.n	a8, 0
4037f00a:	000086        	j	4037f010 <tlsf_memalign_offs+0x84>
4037f00d:	080c00        	lsx	f0, a12, a0
	size_t aligned_size = (adjust && align > ALIGN_SIZE) ? size_with_gap : adjust;
4037f010:	1e0c      	movi.n	a14, 1
4037f012:	83e440        	moveqz	a14, a4, a4
4037f015:	4a0c      	movi.n	a10, 4
4037f017:	62aa30        	saltu	a10, a10, a3
4037f01a:	018ea7        	bany	a14, a10, 4037f01f <tlsf_memalign_offs+0x93>
4037f01d:	048d      	mov.n	a8, a4
	if (*size)
4037f01f:	3a9816        	beqz	a8, 4037f3cc <tlsf_memalign_offs+0x440>
	if (*size >= control->small_block_size)
4037f022:	4ca8      	l32i.n	a10, a12, 16
4037f024:	75a7a0        	extui	a10, a10, 23, 8
4037f027:	0a5d      	mov.n	a5, a10
4037f029:	3738a7        	bltu	a8, a10, 4037f064 <tlsf_memalign_offs+0xd8>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f02c:	40f8b0        	nsau	a11, a8
	return bit - 1;
4037f02f:	e1cbb2        	addi	a11, a11, -31
4037f032:	60b0b0        	neg	a11, a11
		const size_t round = (1 << (tlsf_fls_sizet(*size) - control->sl_index_count_log2));
4037f035:	4cf8      	l32i.n	a15, a12, 16
4037f037:	25f4f0        	extui	a15, a15, 20, 3
4037f03a:	c0fbf0        	sub	a15, a11, a15
4037f03d:	1b0c      	movi.n	a11, 1
4037f03f:	401f00        	ssl	a15
4037f042:	a1bb00        	sll	a11, a11
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f045:	ffcbf2        	addi	a15, a11, -1
4037f048:	0e0bf7        	bnone	a11, a15, 4037f05a <tlsf_memalign_offs+0xce>
4037f04b:	d7ded1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c021bd4 <_flash_rodata_start+0x1ab4>)
4037f04e:	d7dec1        	l32r	a12, 40374fc8 <_iram_text_start+0xbc4> (3c0269e4 <__func__$19>)
4037f051:	f3a0b2        	movi	a11, 243
4037f054:	d7cea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f057:	00cd25        	call8	4037fd28 <__assert_func>
	return (x + (align - 1)) & ~(align - 1);
4037f05a:	88ba      	add.n	a8, a8, a11
4037f05c:	880b      	addi.n	a8, a8, -1
4037f05e:	60b0b0        	neg	a11, a11
4037f061:	1088b0        	and	a8, a8, a11
	if (size < control->small_block_size)
4037f064:	10b857        	bgeu	a8, a5, 4037f078 <tlsf_memalign_offs+0xec>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f067:	4cb8      	l32i.n	a11, a12, 16
4037f069:	54beb0        	extui	a11, a11, 14, 6
4037f06c:	d2aab0        	quos	a10, a10, a11
4037f06f:	d2a8a0        	quos	a10, a8, a10
		fl = 0;
4037f072:	0b0c      	movi.n	a11, 0
4037f074:	000c86        	j	4037f0aa <tlsf_memalign_offs+0x11e>
4037f077:	00          	.byte	00
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f078:	a88c      	beqz.n	a8, 4037f086 <tlsf_memalign_offs+0xfa>
4037f07a:	40f8b0        	nsau	a11, a8
4037f07d:	e0cbb2        	addi	a11, a11, -32
4037f080:	60b0b0        	neg	a11, a11
4037f083:	000086        	j	4037f089 <tlsf_memalign_offs+0xfd>
4037f086:	00a0b2        	movi	a11, 0
	return bit - 1;
4037f089:	ab0b      	addi.n	a10, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f08b:	4cf8      	l32i.n	a15, a12, 16
4037f08d:	2554f0        	extui	a5, a15, 20, 3
4037f090:	c0aa50        	sub	a10, a10, a5
4037f093:	400a00        	ssr	a10
4037f096:	91a080        	srl	a10, a8
4037f099:	170c      	movi.n	a7, 1
4037f09b:	401500        	ssl	a5
4037f09e:	a17700        	sll	a7, a7
4037f0a1:	30aa70        	xor	a10, a10, a7
		fl -= (control->fl_index_shift - 1);
4037f0a4:	24f5f0        	extui	a15, a15, 5, 3
4037f0a7:	c0bbf0        	sub	a11, a11, a15
		if (fl < control->fl_index_count)
4037f0aa:	4cf8      	l32i.n	a15, a12, 16
4037f0ac:	44f0f0        	extui	a15, a15, 0, 5
4037f0af:	022bf7        	blt	a11, a15, 4037f0b5 <tlsf_memalign_offs+0x129>
4037f0b2:	0145c6        	j	4037f5cd <tlsf_memalign_offs+0x641>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037f0b5:	7c28      	l32i.n	a2, a12, 28
4037f0b7:	a0fb20        	addx4	a15, a11, a2
4037f0ba:	0f78      	l32i.n	a7, a15, 0
4037f0bc:	ff7c      	movi.n	a15, -1
4037f0be:	401a00        	ssl	a10
4037f0c1:	a1af00        	sll	a10, a15
4037f0c4:	1057a0        	and	a5, a7, a10
	if (!sl_map)
4037f0c7:	3b87a7        	bany	a7, a10, 4037f106 <tlsf_memalign_offs+0x17a>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037f0ca:	6cf8      	l32i.n	a15, a12, 24
4037f0cc:	bb1b      	addi.n	a11, a11, 1
4037f0ce:	ffafa2        	movi	a10, -1
4037f0d1:	401b00        	ssl	a11
4037f0d4:	a1aa00        	sll	a10, a10
4037f0d7:	107fa0        	and	a7, a15, a10
		if (!fl_map)
4037f0da:	028fa7        	bany	a15, a10, 4037f0e0 <tlsf_memalign_offs+0x154>
4037f0dd:	013c46        	j	4037f5d2 <tlsf_memalign_offs+0x646>
	return __builtin_ffs(word) - 1;
4037f0e0:	60b070        	neg	a11, a7
4037f0e3:	10bb70        	and	a11, a11, a7
4037f0e6:	40fbb0        	nsau	a11, a11
4037f0e9:	e1cbb2        	addi	a11, a11, -31
4037f0ec:	60b0b0        	neg	a11, a11
		sl_map = control->sl_bitmap[fl];
4037f0ef:	a02b20        	addx4	a2, a11, a2
4037f0f2:	0258      	l32i.n	a5, a2, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037f0f4:	00e556        	bnez	a5, 4037f106 <tlsf_memalign_offs+0x17a>
4037f0f7:	d7b5d1        	l32r	a13, 40374fcc <_iram_text_start+0xbc8> (3c021c14 <_flash_rodata_start+0x1af4>)
4037f0fa:	d7b5c1        	l32r	a12, 40374fd0 <_iram_text_start+0xbcc> (3c026970 <__func__$11>)
4037f0fd:	67a1b2        	movi	a11, 0x167
4037f100:	d7a3a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f103:	00c265        	call8	4037fd28 <__assert_func>
	return __builtin_ffs(word) - 1;
4037f106:	60f050        	neg	a15, a5
4037f109:	10ff50        	and	a15, a15, a5
4037f10c:	40fff0        	nsau	a15, a15
4037f10f:	e1cff2        	addi	a15, a15, -31
4037f112:	60f0f0        	neg	a15, a15
	return control->blocks[fl * control->sl_index_count + sl];
4037f115:	8c78      	l32i.n	a7, a12, 32
4037f117:	4ca8      	l32i.n	a10, a12, 16
4037f119:	54aea0        	extui	a10, a10, 14, 6
4037f11c:	82aab0        	mull	a10, a10, a11
4037f11f:	afaa      	add.n	a10, a15, a10
4037f121:	a0aa70        	addx4	a10, a10, a7
4037f124:	0a28      	l32i.n	a2, a10, 0
	if (block)
4037f126:	4af216        	beqz	a2, 4037f5d9 <tlsf_memalign_offs+0x64d>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f129:	12a8      	l32i.n	a10, a2, 4
4037f12b:	fcaf72        	movi	a7, -4
4037f12e:	10aa70        	and	a10, a10, a7
		tlsf_assert(block_size(block) >= *size);
4037f131:	0eba87        	bgeu	a10, a8, 4037f143 <tlsf_memalign_offs+0x1b7>
4037f134:	d7a8d1        	l32r	a13, 40374fd4 <_iram_text_start+0xbd0> (3c021c50 <_flash_rodata_start+0x1b30>)
4037f137:	d7a8c1        	l32r	a12, 40374fd8 <_iram_text_start+0xbd4> (3c026988 <__func__$12>)
4037f13a:	6aa2b2        	movi	a11, 0x26a
4037f13d:	d793a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f140:	00be65        	call8	4037fd28 <__assert_func>
	block_header_t* prev = block->prev_free;
4037f143:	3288      	l32i.n	a8, a2, 12
	block_header_t* next = block->next_free;
4037f145:	22a8      	l32i.n	a10, a2, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f147:	00e856        	bnez	a8, 4037f159 <tlsf_memalign_offs+0x1cd>
4037f14a:	d792d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c021b48 <_flash_rodata_start+0x1a28>)
4037f14d:	d792c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037f150:	74a1b2        	movi	a11, 0x174
4037f153:	d78ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f156:	00bd25        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f159:	011a56        	bnez	a10, 4037f16e <tlsf_memalign_offs+0x1e2>
4037f15c:	d790d1        	l32r	a13, 40374f9c <_iram_text_start+0xb98> (3c021b74 <_flash_rodata_start+0x1a54>)
4037f15f:	d78ec1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037f162:	75a1b2        	movi	a11, 0x175
4037f165:	d789a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f168:	201110        	or	a1, a1, a1
4037f16b:	00bbe5        	call8	4037fd28 <__assert_func>
	next->prev_free = prev;
4037f16e:	3a89      	s32i.n	a8, a10, 12
	prev->next_free = next;
4037f170:	28a9      	s32i.n	a10, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f172:	8c58      	l32i.n	a5, a12, 32
4037f174:	4c88      	l32i.n	a8, a12, 16
4037f176:	548e80        	extui	a8, a8, 14, 6
4037f179:	828b80        	mull	a8, a11, a8
4037f17c:	8f8a      	add.n	a8, a15, a8
4037f17e:	a08850        	addx4	a8, a8, a5
4037f181:	0878      	l32i.n	a7, a8, 0
4037f183:	369277        	bne	a2, a7, 4037f1bd <tlsf_memalign_offs+0x231>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f186:	08a9      	s32i.n	a10, a8, 0
		if (next == &control->block_null)
4037f188:	319ac7        	bne	a10, a12, 4037f1bd <tlsf_memalign_offs+0x231>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f18b:	7ca8      	l32i.n	a10, a12, 28
4037f18d:	a0aba0        	addx4	a10, a11, a10
4037f190:	0a78      	l32i.n	a7, a10, 0
4037f192:	180c      	movi.n	a8, 1
4037f194:	401f00        	ssl	a15
4037f197:	a18800        	sll	a8, a8
4037f19a:	108870        	and	a8, a8, a7
4037f19d:	308870        	xor	a8, a8, a7
4037f1a0:	0a89      	s32i.n	a8, a10, 0
			if (!control->sl_bitmap[fl])
4037f1a2:	7c88      	l32i.n	a8, a12, 28
4037f1a4:	a08b80        	addx4	a8, a11, a8
4037f1a7:	0888      	l32i.n	a8, a8, 0
4037f1a9:	08dc      	bnez.n	a8, 4037f1bd <tlsf_memalign_offs+0x231>
				control->fl_bitmap &= ~(1U << fl);
4037f1ab:	6ca8      	l32i.n	a10, a12, 24
4037f1ad:	180c      	movi.n	a8, 1
4037f1af:	401b00        	ssl	a11
4037f1b2:	a18800        	sll	a8, a8
4037f1b5:	1088a0        	and	a8, a8, a10
4037f1b8:	3088a0        	xor	a8, a8, a10
4037f1bb:	6c89      	s32i.n	a8, a12, 24
	return tlsf_cast(void*,
4037f1bd:	a28b      	addi.n	a10, a2, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f1bf:	f3aa      	add.n	a15, a3, a10
4037f1c1:	ff0b      	addi.n	a15, a15, -1
4037f1c3:	60b030        	neg	a11, a3
4037f1c6:	10ffb0        	and	a15, a15, a11
	tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
4037f1c9:	830b      	addi.n	a8, a3, -1
4037f1cb:	0e0387        	bnone	a3, a8, 4037f1dd <tlsf_memalign_offs+0x251>
4037f1ce:	d77dd1        	l32r	a13, 40374fc4 <_iram_text_start+0xbc0> (3c021bd4 <_flash_rodata_start+0x1ab4>)
4037f1d1:	d78ac1        	l32r	a12, 40374ffc <_iram_text_start+0xbf8> (3c0269c4 <__func__$16>)
4037f1d4:	01a1b2        	movi	a11, 0x101
4037f1d7:	d76da1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f1da:	00b4e5        	call8	4037fd28 <__assert_func>
		size_t gap = tlsf_cast(size_t,
4037f1dd:	c08fa0        	sub	a8, a15, a10
		if ((gap && gap < gap_minimum) || (!gap && off_adjust && align > ALIGN_SIZE))
4037f1e0:	150c      	movi.n	a5, 1
4037f1e2:	835880        	moveqz	a5, a8, a8
4037f1e5:	6278d0        	saltu	a7, a8, a13
4037f1e8:	108577        	bany	a5, a7, 4037f1fc <tlsf_memalign_offs+0x270>
4037f1eb:	40f870        	nsau	a7, a8
4037f1ee:	417570        	srli	a7, a7, 5
4037f1f1:	150c      	movi.n	a5, 1
4037f1f3:	835990        	moveqz	a5, a9, a9
4037f1f6:	150757        	bnone	a7, a5, 4037f20f <tlsf_memalign_offs+0x283>
4037f1f9:	1253b6        	bltui	a3, 5, 4037f20f <tlsf_memalign_offs+0x283>
			const size_t gap_remain = gap_minimum - gap;
4037f1fc:	c08d80        	sub	a8, a13, a8
			const size_t offset = tlsf_max(gap_remain, align);
4037f1ff:	738380        	maxu	a8, a3, a8
			const void* next_aligned = tlsf_cast(void*,
4037f202:	88fa      	add.n	a8, a8, a15
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f204:	883a      	add.n	a8, a8, a3
4037f206:	ffc882        	addi	a8, a8, -1
4037f209:	10bb80        	and	a11, a11, a8
			gap = tlsf_cast(size_t,
4037f20c:	c08ba0        	sub	a8, a11, a10
		if (gap)
4037f20f:	1be816        	beqz	a8, 4037f3d1 <tlsf_memalign_offs+0x445>
			tlsf_assert(gap >= gap_minimum && "gap size too small");
4037f212:	0eb8d7        	bgeu	a8, a13, 4037f224 <tlsf_memalign_offs+0x298>
4037f215:	d77ad1        	l32r	a13, 40375000 <_iram_text_start+0xbfc> (3c021dbc <_flash_rodata_start+0x1c9c>)
4037f218:	d77bc1        	l32r	a12, 40375004 <_iram_text_start+0xc00> (3c02692c <__func__$7>)
4037f21b:	5ca2b2        	movi	a11, 0x25c
4037f21e:	d755a1        	l32r	a10, 40374f74 <_iram_text_start+0xb70> (3c02184f <_flash_rodata_start+0x172f>)
4037f221:	00b065        	call8	4037fd28 <__assert_func>
			block = block_trim_free_leading(control, block, gap - off_adjust);
4037f224:	c08890        	sub	a8, a8, a9
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f227:	12b8      	l32i.n	a11, a2, 4
4037f229:	c97c      	movi.n	a9, -4
4037f22b:	10bb90        	and	a11, a11, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037f22e:	10c892        	addi	a9, a8, 16
	if (block_can_split(block, size))
4037f231:	02bb97        	bgeu	a11, a9, 4037f237 <tlsf_memalign_offs+0x2ab>
4037f234:	006806        	j	4037f3d8 <tlsf_memalign_offs+0x44c>
		remaining_block = block_split(block, size - block_header_overhead);
4037f237:	fcc8f2        	addi	a15, a8, -4
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f23a:	f8c882        	addi	a8, a8, -8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f23d:	8a8a      	add.n	a8, a10, a8
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f23f:	c09bf0        	sub	a9, a11, a15
4037f242:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(void*,
4037f245:	d88b      	addi.n	a13, a8, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f247:	78bb      	addi.n	a7, a8, 11
4037f249:	c57c      	movi.n	a5, -4
4037f24b:	107750        	and	a7, a7, a5
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f24e:	0e1d77        	beq	a13, a7, 4037f260 <tlsf_memalign_offs+0x2d4>
4037f251:	d766d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c021cbc <_flash_rodata_start+0x1b9c>)
4037f254:	d767c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f257:	c4a1b2        	movi	a11, 0x1c4
4037f25a:	d74ca1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f25d:	00aca5        	call8	4037fd28 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f260:	7f9a      	add.n	a7, a15, a9
4037f262:	04c772        	addi	a7, a7, 4
4037f265:	0e1b77        	beq	a11, a7, 4037f277 <tlsf_memalign_offs+0x2eb>
4037f268:	d763d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c021d30 <_flash_rodata_start+0x1c10>)
4037f26b:	d761c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f26e:	c7a1b2        	movi	a11, 0x1c7
4037f271:	d746a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f274:	00ab25        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037f277:	18b8      	l32i.n	a11, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f279:	14b0b0        	extui	a11, a11, 0, 2
4037f27c:	2099b0        	or	a9, a9, a11
4037f27f:	1899      	s32i.n	a9, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f281:	cb7c      	movi.n	a11, -4
4037f283:	1099b0        	and	a9, a9, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f286:	bb0c      	movi.n	a11, 11
4037f288:	0e3b97        	bltu	a11, a9, 4037f29a <tlsf_memalign_offs+0x30e>
4037f28b:	d75bd1        	l32r	a13, 40374ff8 <_iram_text_start+0xbf4> (3c021d70 <_flash_rodata_start+0x1c50>)
4037f28e:	d758c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f291:	c9a1b2        	movi	a11, 0x1c9
4037f294:	d73ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f297:	00a925        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037f29a:	1298      	l32i.n	a9, a2, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f29c:	149090        	extui	a9, a9, 0, 2
4037f29f:	20ff90        	or	a15, a15, a9
4037f2a2:	12f9      	s32i.n	a15, a2, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f2a4:	18b8      	l32i.n	a11, a8, 4
4037f2a6:	c97c      	movi.n	a9, -4
4037f2a8:	109b90        	and	a9, a11, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f2ab:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f2ae:	dd9a      	add.n	a13, a13, a9
	tlsf_assert(!block_is_last(block));
4037f2b0:	390c      	movi.n	a9, 3
4037f2b2:	0e39b7        	bltu	a9, a11, 4037f2c4 <tlsf_memalign_offs+0x338>
4037f2b5:	d730d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f2b8:	d731c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f2bb:	a1a0b2        	movi	a11, 161
4037f2be:	d730a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f2c1:	00a665        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037f2c4:	0d89      	s32i.n	a8, a13, 0
	block->size |= block_header_prev_free_bit;
4037f2c6:	1d98      	l32i.n	a9, a13, 4
4037f2c8:	2b0c      	movi.n	a11, 2
4037f2ca:	2099b0        	or	a9, a9, a11
4037f2cd:	1d99      	s32i.n	a9, a13, 4
	block->size |= block_header_free_bit;
4037f2cf:	1898      	l32i.n	a9, a8, 4
4037f2d1:	1b0c      	movi.n	a11, 1
4037f2d3:	20b9b0        	or	a11, a9, a11
4037f2d6:	18b9      	s32i.n	a11, a8, 4
	block->size |= block_header_prev_free_bit;
4037f2d8:	3d0c      	movi.n	a13, 3
4037f2da:	2099d0        	or	a9, a9, a13
4037f2dd:	1899      	s32i.n	a9, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f2df:	12b8      	l32i.n	a11, a2, 4
4037f2e1:	c97c      	movi.n	a9, -4
4037f2e3:	109b90        	and	a9, a11, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f2e6:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f2e9:	9a9a      	add.n	a9, a10, a9
	tlsf_assert(!block_is_last(block));
4037f2eb:	0e3db7        	bltu	a13, a11, 4037f2fd <tlsf_memalign_offs+0x371>
4037f2ee:	d722d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f2f1:	d722c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f2f4:	a1a0b2        	movi	a11, 161
4037f2f7:	d722a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f2fa:	00a2e5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037f2fd:	0929      	s32i.n	a2, a9, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f2ff:	1298      	l32i.n	a9, a2, 4
4037f301:	cb7c      	movi.n	a11, -4
4037f303:	1099b0        	and	a9, a9, a11
	if (size < control->small_block_size)
4037f306:	4cb8      	l32i.n	a11, a12, 16
4037f308:	75b7b0        	extui	a11, a11, 23, 8
4037f30b:	0fb9b7        	bgeu	a9, a11, 4037f31e <tlsf_memalign_offs+0x392>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f30e:	4cd8      	l32i.n	a13, a12, 16
4037f310:	54ded0        	extui	a13, a13, 14, 6
4037f313:	d2bbd0        	quos	a11, a11, a13
4037f316:	d299b0        	quos	a9, a9, a11
		fl = 0;
4037f319:	0d0c      	movi.n	a13, 0
4037f31b:	000cc6        	j	4037f352 <tlsf_memalign_offs+0x3c6>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f31e:	a98c      	beqz.n	a9, 4037f32c <tlsf_memalign_offs+0x3a0>
4037f320:	40f9d0        	nsau	a13, a9
4037f323:	e0cdd2        	addi	a13, a13, -32
4037f326:	60d0d0        	neg	a13, a13
4037f329:	000086        	j	4037f32f <tlsf_memalign_offs+0x3a3>
4037f32c:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f32f:	ffcdf2        	addi	a15, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f332:	042cb2        	l32i	a11, a12, 16
4037f335:	2574b0        	extui	a7, a11, 20, 3
4037f338:	c0ff70        	sub	a15, a15, a7
4037f33b:	400f00        	ssr	a15
4037f33e:	919090        	srl	a9, a9
4037f341:	1f0c      	movi.n	a15, 1
4037f343:	401700        	ssl	a7
4037f346:	a1ff00        	sll	a15, a15
4037f349:	3099f0        	xor	a9, a9, a15
		fl -= (control->fl_index_shift - 1);
4037f34c:	24b5b0        	extui	a11, a11, 5, 3
4037f34f:	c0ddb0        	sub	a13, a13, a11
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037f352:	8cf8      	l32i.n	a15, a12, 32
4037f354:	4cb8      	l32i.n	a11, a12, 16
4037f356:	54beb0        	extui	a11, a11, 14, 6
4037f359:	82bbd0        	mull	a11, a11, a13
4037f35c:	bb9a      	add.n	a11, a11, a9
4037f35e:	a0bbf0        	addx4	a11, a11, a15
4037f361:	0bb8      	l32i.n	a11, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037f363:	dbcc      	bnez.n	a11, 4037f374 <tlsf_memalign_offs+0x3e8>
4037f365:	d713d1        	l32r	a13, 40374fb4 <_iram_text_start+0xbb0> (3c021984 <_flash_rodata_start+0x1864>)
4037f368:	d714c1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037f36b:	90a1b2        	movi	a11, 0x190
4037f36e:	d707a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f371:	009b65        	call8	4037fd28 <__assert_func>
	block->next_free = current;
4037f374:	0262b2        	s32i	a11, a2, 8
	block->prev_free = &control->block_null;
4037f377:	0362c2        	s32i	a12, a2, 12
	current->prev_free = block;
4037f37a:	036b22        	s32i	a2, a11, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f37d:	ba3b      	addi.n	a11, a10, 3
4037f37f:	cf7c      	movi.n	a15, -4
4037f381:	10bbf0        	and	a11, a11, a15
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037f384:	0e1ab7        	beq	a10, a11, 4037f396 <tlsf_memalign_offs+0x40a>
4037f387:	d70ed1        	l32r	a13, 40374fc0 <_iram_text_start+0xbbc> (3c021a24 <_flash_rodata_start+0x1904>)
4037f38a:	d70bc1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037f38d:	96a1b2        	movi	a11, 0x196
4037f390:	d6ffa1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f393:	009965        	call8	4037fd28 <__assert_func>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037f396:	8cb8      	l32i.n	a11, a12, 32
4037f398:	4ca8      	l32i.n	a10, a12, 16
4037f39a:	54aea0        	extui	a10, a10, 14, 6
4037f39d:	82ada0        	mull	a10, a13, a10
4037f3a0:	a9aa      	add.n	a10, a9, a10
4037f3a2:	a0aab0        	addx4	a10, a10, a11
4037f3a5:	0a29      	s32i.n	a2, a10, 0
	control->fl_bitmap |= (1U << fl);
4037f3a7:	6cb8      	l32i.n	a11, a12, 24
4037f3a9:	1a0c      	movi.n	a10, 1
4037f3ab:	401d00        	ssl	a13
4037f3ae:	a1fa00        	sll	a15, a10
4037f3b1:	20bbf0        	or	a11, a11, a15
4037f3b4:	6cb9      	s32i.n	a11, a12, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037f3b6:	7cb8      	l32i.n	a11, a12, 28
4037f3b8:	a0ddb0        	addx4	a13, a13, a11
4037f3bb:	0db8      	l32i.n	a11, a13, 0
4037f3bd:	401900        	ssl	a9
4037f3c0:	a1aa00        	sll	a10, a10
4037f3c3:	209ba0        	or	a9, a11, a10
4037f3c6:	0d99      	s32i.n	a9, a13, 0
	return remaining_block;
4037f3c8:	0001c6        	j	4037f3d3 <tlsf_memalign_offs+0x447>
4037f3cb:	080c00        	lsx	f0, a12, a0
	block_header_t* block = block_locate_free(control, &aligned_size);
4037f3ce:	000046        	j	4037f3d3 <tlsf_memalign_offs+0x447>
4037f3d1:	028d      	mov.n	a8, a2
	if (block)
4037f3d3:	48cc      	bnez.n	a8, 4037f3db <tlsf_memalign_offs+0x44f>
4037f3d5:	007f86        	j	4037f5d7 <tlsf_memalign_offs+0x64b>
			block = block_trim_free_leading(control, block, gap - off_adjust);
4037f3d8:	208220        	or	a8, a2, a2
		tlsf_assert(size && "size must be non-zero");
4037f3db:	decc      	bnez.n	a14, 4037f3ec <tlsf_memalign_offs+0x460>
4037f3dd:	d6ffd1        	l32r	a13, 40374fdc <_iram_text_start+0xbd8> (3c021c6c <_flash_rodata_start+0x1b4c>)
4037f3e0:	d700c1        	l32r	a12, 40374fe0 <_iram_text_start+0xbdc> (3c02695c <__func__$10>)
4037f3e3:	76a2b2        	movi	a11, 0x276
4037f3e6:	d6e9a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f3e9:	0093e5        	call8	4037fd28 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f3ec:	1898      	l32i.n	a9, a8, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037f3ee:	0ee907        	bbsi	a9, 0, 4037f400 <tlsf_memalign_offs+0x474>
4037f3f1:	d6fcd1        	l32r	a13, 40374fe4 <_iram_text_start+0xbe0> (3c021c8c <_flash_rodata_start+0x1b6c>)
4037f3f4:	d6fdc1        	l32r	a12, 40374fe8 <_iram_text_start+0xbe4> (3c02694c <__func__$9>)
4037f3f7:	24a2b2        	movi	a11, 0x224
4037f3fa:	d6e4a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f3fd:	0092a5        	call8	4037fd28 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f400:	ca7c      	movi.n	a10, -4
4037f402:	10b9a0        	and	a11, a9, a10
	return block_size(block) >= sizeof(block_header_t) + size;
4037f405:	10c492        	addi	a9, a4, 16
	if (block_can_split(block, size))
4037f408:	02bb97        	bgeu	a11, a9, 4037f40e <tlsf_memalign_offs+0x482>
4037f40b:	0061c6        	j	4037f596 <tlsf_memalign_offs+0x60a>
	return tlsf_cast(void*,
4037f40e:	e88b      	addi.n	a14, a8, 8
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f410:	94aa      	add.n	a9, a4, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f412:	9e9a      	add.n	a9, a14, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f414:	c0ab40        	sub	a10, a11, a4
4037f417:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(void*,
4037f41a:	d98b      	addi.n	a13, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f41c:	f9bb      	addi.n	a15, a9, 11
4037f41e:	c77c      	movi.n	a7, -4
4037f420:	10ff70        	and	a15, a15, a7
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f423:	0e1df7        	beq	a13, a15, 4037f435 <tlsf_memalign_offs+0x4a9>
4037f426:	d6f1d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c021cbc <_flash_rodata_start+0x1b9c>)
4037f429:	d6f1c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f42c:	c4a1b2        	movi	a11, 0x1c4
4037f42f:	d6d7a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f432:	008f65        	call8	4037fd28 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f435:	f4aa      	add.n	a15, a4, a10
4037f437:	ff4b      	addi.n	a15, a15, 4
4037f439:	0e1bf7        	beq	a11, a15, 4037f44b <tlsf_memalign_offs+0x4bf>
4037f43c:	d6eed1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c021d30 <_flash_rodata_start+0x1c10>)
4037f43f:	d6ecc1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f442:	c7a1b2        	movi	a11, 0x1c7
4037f445:	d6d1a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f448:	008de5        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037f44b:	19b8      	l32i.n	a11, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f44d:	14b0b0        	extui	a11, a11, 0, 2
4037f450:	20aab0        	or	a10, a10, a11
4037f453:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f455:	cb7c      	movi.n	a11, -4
4037f457:	10aab0        	and	a10, a10, a11
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f45a:	bb0c      	movi.n	a11, 11
4037f45c:	0e3ba7        	bltu	a11, a10, 4037f46e <tlsf_memalign_offs+0x4e2>
4037f45f:	d6e6d1        	l32r	a13, 40374ff8 <_iram_text_start+0xbf4> (3c021d70 <_flash_rodata_start+0x1c50>)
4037f462:	d6e3c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f465:	c9a1b2        	movi	a11, 0x1c9
4037f468:	d6c9a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f46b:	008be5        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037f46e:	18a8      	l32i.n	a10, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f470:	14a0a0        	extui	a10, a10, 0, 2
4037f473:	2044a0        	or	a4, a4, a10
4037f476:	1849      	s32i.n	a4, a8, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f478:	19b8      	l32i.n	a11, a9, 4
4037f47a:	ca7c      	movi.n	a10, -4
4037f47c:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f47f:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f482:	adaa      	add.n	a10, a13, a10
	tlsf_assert(!block_is_last(block));
4037f484:	3d0c      	movi.n	a13, 3
4037f486:	0e3db7        	bltu	a13, a11, 4037f498 <tlsf_memalign_offs+0x50c>
4037f489:	d6bbd1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f48c:	d6bcc1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f48f:	a1a0b2        	movi	a11, 161
4037f492:	d6bba1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f495:	008925        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037f498:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_prev_free_bit;
4037f49a:	1ab8      	l32i.n	a11, a10, 4
4037f49c:	2d0c      	movi.n	a13, 2
4037f49e:	20bbd0        	or	a11, a11, a13
4037f4a1:	1ab9      	s32i.n	a11, a10, 4
	block->size |= block_header_free_bit;
4037f4a3:	19a8      	l32i.n	a10, a9, 4
4037f4a5:	1b0c      	movi.n	a11, 1
4037f4a7:	20aab0        	or	a10, a10, a11
4037f4aa:	19a9      	s32i.n	a10, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f4ac:	18b8      	l32i.n	a11, a8, 4
4037f4ae:	ca7c      	movi.n	a10, -4
4037f4b0:	10aba0        	and	a10, a11, a10
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f4b3:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f4b6:	eeaa      	add.n	a14, a14, a10
	tlsf_assert(!block_is_last(block));
4037f4b8:	3a0c      	movi.n	a10, 3
4037f4ba:	0e3ab7        	bltu	a10, a11, 4037f4cc <tlsf_memalign_offs+0x540>
4037f4bd:	d6aed1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f4c0:	d6afc1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f4c3:	a1a0b2        	movi	a11, 161
4037f4c6:	d6aea1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f4c9:	0085e5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037f4cc:	0e89      	s32i.n	a8, a14, 0
	block->size |= block_header_prev_free_bit;
4037f4ce:	19b8      	l32i.n	a11, a9, 4
4037f4d0:	2a0c      	movi.n	a10, 2
4037f4d2:	20aba0        	or	a10, a11, a10
4037f4d5:	19a9      	s32i.n	a10, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
4037f4d7:	ca7c      	movi.n	a10, -4
4037f4d9:	10bba0        	and	a11, a11, a10
	if (size < control->small_block_size)
4037f4dc:	4ca8      	l32i.n	a10, a12, 16
4037f4de:	75a7a0        	extui	a10, a10, 23, 8
4037f4e1:	0fbba7        	bgeu	a11, a10, 4037f4f4 <tlsf_memalign_offs+0x568>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f4e4:	4cd8      	l32i.n	a13, a12, 16
4037f4e6:	54ded0        	extui	a13, a13, 14, 6
4037f4e9:	d2aad0        	quos	a10, a10, a13
4037f4ec:	d2bba0        	quos	a11, a11, a10
		fl = 0;
4037f4ef:	0d0c      	movi.n	a13, 0
4037f4f1:	000cc6        	j	4037f528 <tlsf_memalign_offs+0x59c>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f4f4:	ab8c      	beqz.n	a11, 4037f502 <tlsf_memalign_offs+0x576>
4037f4f6:	40fbd0        	nsau	a13, a11
4037f4f9:	e0cdd2        	addi	a13, a13, -32
4037f4fc:	60d0d0        	neg	a13, a13
4037f4ff:	000086        	j	4037f505 <tlsf_memalign_offs+0x579>
4037f502:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f505:	ffcde2        	addi	a14, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f508:	042ca2        	l32i	a10, a12, 16
4037f50b:	25f4a0        	extui	a15, a10, 20, 3
4037f50e:	c0eef0        	sub	a14, a14, a15
4037f511:	400e00        	ssr	a14
4037f514:	91b0b0        	srl	a11, a11
4037f517:	1e0c      	movi.n	a14, 1
4037f519:	401f00        	ssl	a15
4037f51c:	a1ee00        	sll	a14, a14
4037f51f:	30bbe0        	xor	a11, a11, a14
		fl -= (control->fl_index_shift - 1);
4037f522:	24a5a0        	extui	a10, a10, 5, 3
4037f525:	c0dda0        	sub	a13, a13, a10
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037f528:	8ce8      	l32i.n	a14, a12, 32
4037f52a:	4ca8      	l32i.n	a10, a12, 16
4037f52c:	54aea0        	extui	a10, a10, 14, 6
4037f52f:	82aad0        	mull	a10, a10, a13
4037f532:	aaba      	add.n	a10, a10, a11
4037f534:	a0aae0        	addx4	a10, a10, a14
4037f537:	0aa8      	l32i.n	a10, a10, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037f539:	dacc      	bnez.n	a10, 4037f54a <tlsf_memalign_offs+0x5be>
4037f53b:	d69ed1        	l32r	a13, 40374fb4 <_iram_text_start+0xbb0> (3c021984 <_flash_rodata_start+0x1864>)
4037f53e:	d69ec1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037f541:	90a1b2        	movi	a11, 0x190
4037f544:	d692a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f547:	007e25        	call8	4037fd28 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037f54a:	09dc      	bnez.n	a9, 4037f55e <tlsf_memalign_offs+0x5d2>
4037f54c:	d69cd1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c0219e8 <_flash_rodata_start+0x18c8>)
4037f54f:	d69ac1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037f552:	91a1b2        	movi	a11, 0x191
4037f555:	d68da1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f558:	201110        	or	a1, a1, a1
4037f55b:	007ce5        	call8	4037fd28 <__assert_func>
	block->next_free = current;
4037f55e:	29a9      	s32i.n	a10, a9, 8
	block->prev_free = &control->block_null;
4037f560:	39c9      	s32i.n	a12, a9, 12
	current->prev_free = block;
4037f562:	3a99      	s32i.n	a9, a10, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037f564:	8ce8      	l32i.n	a14, a12, 32
4037f566:	4ca8      	l32i.n	a10, a12, 16
4037f568:	54aea0        	extui	a10, a10, 14, 6
4037f56b:	82ada0        	mull	a10, a13, a10
4037f56e:	abaa      	add.n	a10, a11, a10
4037f570:	a0aae0        	addx4	a10, a10, a14
4037f573:	0a99      	s32i.n	a9, a10, 0
	control->fl_bitmap |= (1U << fl);
4037f575:	6ca8      	l32i.n	a10, a12, 24
4037f577:	190c      	movi.n	a9, 1
4037f579:	401d00        	ssl	a13
4037f57c:	a1e900        	sll	a14, a9
4037f57f:	20aae0        	or	a10, a10, a14
4037f582:	6ca9      	s32i.n	a10, a12, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037f584:	7ca8      	l32i.n	a10, a12, 28
4037f586:	a0dda0        	addx4	a13, a13, a10
4037f589:	0da8      	l32i.n	a10, a13, 0
4037f58b:	401b00        	ssl	a11
4037f58e:	a19900        	sll	a9, a9
4037f591:	209a90        	or	a9, a10, a9
4037f594:	0d99      	s32i.n	a9, a13, 0
	return tlsf_cast(void*,
4037f596:	288b      	addi.n	a2, a8, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f598:	18a8      	l32i.n	a10, a8, 4
4037f59a:	c97c      	movi.n	a9, -4
4037f59c:	109a90        	and	a9, a10, a9
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f59f:	fcc992        	addi	a9, a9, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f5a2:	992a      	add.n	a9, a9, a2
	tlsf_assert(!block_is_last(block));
4037f5a4:	3b0c      	movi.n	a11, 3
4037f5a6:	0e3ba7        	bltu	a11, a10, 4037f5b8 <tlsf_memalign_offs+0x62c>
4037f5a9:	d673d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f5ac:	d674c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f5af:	a1a0b2        	movi	a11, 161
4037f5b2:	d673a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f5b5:	007725        	call8	4037fd28 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037f5b8:	19a8      	l32i.n	a10, a9, 4
4037f5ba:	db7c      	movi.n	a11, -3
4037f5bc:	10aab0        	and	a10, a10, a11
4037f5bf:	19a9      	s32i.n	a10, a9, 4
	block->size &= ~block_header_free_bit;
4037f5c1:	1898      	l32i.n	a9, a8, 4
4037f5c3:	ea7c      	movi.n	a10, -2
4037f5c5:	1099a0        	and	a9, a9, a10
4037f5c8:	1899      	s32i.n	a9, a8, 4
		p = block_to_ptr(block);
4037f5ca:	0002c6        	j	4037f5d9 <tlsf_memalign_offs+0x64d>
	void* p = 0;
4037f5cd:	020c      	movi.n	a2, 0
4037f5cf:	000186        	j	4037f5d9 <tlsf_memalign_offs+0x64d>
4037f5d2:	020c      	movi.n	a2, 0
4037f5d4:	000046        	j	4037f5d9 <tlsf_memalign_offs+0x64d>
4037f5d7:	082d      	mov.n	a2, a8
}
4037f5d9:	f01d      	retw.n
	...

4037f5dc <tlsf_realloc>:
**   untouched
** - an extended buffer size will leave the newly-allocated area with
**   contents undefined
*/
void* tlsf_realloc(tlsf_t tlsf, void* ptr, size_t size)
{
4037f5dc:	004136        	entry	a1, 32
4037f5df:	207220        	or	a7, a2, a2
	control_t* control = tlsf_cast(control_t*, tlsf);
	void* p = 0;

	/* Zero-size requests are treated as free. */
	if (ptr && size == 0)
4037f5e2:	01a092        	movi	a9, 1
4037f5e5:	839330        	moveqz	a9, a3, a3
4037f5e8:	40f480        	nsau	a8, a4
4037f5eb:	418580        	srli	a8, a8, 5
4037f5ee:	0c0987        	bnone	a9, a8, 4037f5fe <tlsf_realloc+0x22>
	{
		tlsf_free(tlsf, ptr);
4037f5f1:	20b330        	or	a11, a3, a3
4037f5f4:	02ad      	mov.n	a10, a2
4037f5f6:	ff1d65        	call8	4037e7cc <tlsf_free>
	void* p = 0;
4037f5f9:	020c      	movi.n	a2, 0
4037f5fb:	014546        	j	4037fb14 <tlsf_realloc+0x538>
	}
	/* Requests with NULL pointers are treated as malloc. */
	else if (!ptr)
4037f5fe:	00e356        	bnez	a3, 4037f610 <tlsf_realloc+0x34>
	{
		p = tlsf_malloc(tlsf, size);
4037f601:	20b440        	or	a11, a4, a4
4037f604:	20a220        	or	a10, a2, a2
4037f607:	ff5b65        	call8	4037ebbc <tlsf_malloc>
4037f60a:	0a2d      	mov.n	a2, a10
4037f60c:	014106        	j	4037fb14 <tlsf_realloc+0x538>
4037f60f:	c3b200        	movf	a11, a2, b0
	return tlsf_cast(block_header_t*,
4037f612:	92f8      	l32i.n	a15, a2, 36
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f614:	012b      	addi.n	a0, a1, 2
4037f616:	fcaf62        	movi	a6, -4
4037f619:	106960        	and	a6, a9, a6
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f61c:	fcc6a2        	addi	a10, a6, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f61f:	aa3a      	add.n	a10, a10, a3
4037f621:	0acd      	mov.n	a12, a10
	tlsf_assert(!block_is_last(block));
4037f623:	380c      	movi.n	a8, 3
4037f625:	0e3897        	bltu	a8, a9, 4037f637 <tlsf_realloc+0x5b>
4037f628:	d654d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f62b:	d654c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f62e:	a1a0b2        	movi	a11, 161
4037f631:	d653a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f634:	006f25        	call8	4037fd28 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f637:	1ae8      	l32i.n	a14, a10, 4
4037f639:	c87c      	movi.n	a8, -4
4037f63b:	108e80        	and	a8, a14, a8
	{
		block_header_t* block = block_from_ptr(ptr);
		block_header_t* next = block_next(block);

		const size_t cursize = block_size(block);
		const size_t combined = cursize + block_size(next) + block_header_overhead;
4037f63e:	d86a      	add.n	a13, a8, a6
4037f640:	dd4b      	addi.n	a13, a13, 4
	if (size)
4037f642:	4bb416        	beqz	a4, 4037fb01 <tlsf_realloc+0x525>
	return (x + (align - 1)) & ~(align - 1);
4037f645:	543b      	addi.n	a5, a4, 3
4037f647:	cf7c      	movi.n	a15, -4
4037f649:	1055f0        	and	a5, a5, a15
	if (control == NULL)
4037f64c:	4b8216        	beqz	a2, 4037fb08 <tlsf_realloc+0x52c>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037f64f:	4228      	l32i.n	a2, a2, 16
4037f651:	542820        	extui	a2, a2, 8, 6
4037f654:	1f0c      	movi.n	a15, 1
4037f656:	401200        	ssl	a2
4037f659:	a1ff00        	sll	a15, a15
		if (aligned < tlsf_block_size_max(control)) 
4037f65c:	0235f7        	bltu	a5, a15, 4037f662 <tlsf_realloc+0x86>
4037f65f:	012a46        	j	4037fb0c <tlsf_realloc+0x530>
			adjust = tlsf_max(aligned, block_size_min);
4037f662:	cf0c      	movi.n	a15, 12
4037f664:	7355f0        	maxu	a5, a5, a15
		if (adjust == 0)
		{
			return p;
		}

		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037f667:	0e6907        	bbci	a9, 0, 4037f679 <tlsf_realloc+0x9d>
4037f66a:	d640d1        	l32r	a13, 40374f6c <_iram_text_start+0xb68> (3c021de8 <_flash_rodata_start+0x1cc8>)
4037f66d:	d666c1        	l32r	a12, 40375008 <_iram_text_start+0xc04> (3c0268d8 <__func__$1>)
4037f670:	a9a2b2        	movi	a11, 0x2a9
4037f673:	d640a1        	l32r	a10, 40374f74 <_iram_text_start+0xb70> (3c02184f <_flash_rodata_start+0x172f>)
4037f676:	006b25        	call8	4037fd28 <__assert_func>

		/*
		** If the next block is used, or when combined with the current
		** block, does not offer enough space, we must reallocate and copy.
		*/
		if (adjust > cursize && (!block_is_free(next) || adjust > combined))
4037f679:	27b657        	bgeu	a6, a5, 4037f6a4 <tlsf_realloc+0xc8>
4037f67c:	026e07        	bbci	a14, 0, 4037f682 <tlsf_realloc+0xa6>
4037f67f:	21bd57        	bgeu	a13, a5, 4037f6a4 <tlsf_realloc+0xc8>
		{
			p = tlsf_malloc(tlsf, size);
4037f682:	04bd      	mov.n	a11, a4
4037f684:	07ad      	mov.n	a10, a7
4037f686:	ff5365        	call8	4037ebbc <tlsf_malloc>
4037f689:	0a2d      	mov.n	a2, a10
			if (p)
4037f68b:	485a16        	beqz	a10, 4037fb14 <tlsf_realloc+0x538>
			{
				const size_t minsize = tlsf_min(cursize, size);
				memcpy(p, ptr, minsize);
4037f68e:	63c460        	minu	a12, a4, a6
4037f691:	03bd      	mov.n	a11, a3
4037f693:	d39b81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037f696:	0008e0        	callx8	a8
				tlsf_free(tlsf, ptr);
4037f699:	03bd      	mov.n	a11, a3
4037f69b:	07ad      	mov.n	a10, a7
4037f69d:	ff12e5        	call8	4037e7cc <tlsf_free>
4037f6a0:	011c06        	j	4037fb14 <tlsf_realloc+0x538>
4037f6a3:	365700        	ee.ldf.64.xp	f5, f3, a0, a7
			}
		}
		else
		{
			/* Do we need to expand to the next block? */
			if (adjust > cursize)
4037f6a6:	5b0602        	l8ui	a0, a6, 91
4037f6a9:	ea5600        	utrunc.s	a5, f6, 0
	tlsf_assert(next && "next physical block can't be null");
4037f6ac:	00          	.byte	00
4037f6ad:	d63fd1        	l32r	a13, 40374fac <_iram_text_start+0xba8> (3c021ecc <_flash_rodata_start+0x1dac>)
4037f6b0:	d640c1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c0268e8 <__func__$2>)
4037f6b3:	15a2b2        	movi	a11, 0x215
4037f6b6:	d635a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f6b9:	0066e5        	call8	4037fd28 <__assert_func>
	if (block_is_free(next))
4037f6bc:	02ee07        	bbsi	a14, 0, 4037f6c2 <tlsf_realloc+0xe6>
4037f6bf:	004706        	j	4037f7df <tlsf_realloc+0x203>
	if (size < control->small_block_size)
4037f6c2:	042792        	l32i	a9, a7, 16
4037f6c5:	759790        	extui	a9, a9, 23, 8
4037f6c8:	10b897        	bgeu	a8, a9, 4037f6dc <tlsf_realloc+0x100>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f6cb:	0427d2        	l32i	a13, a7, 16
4037f6ce:	54ded0        	extui	a13, a13, 14, 6
4037f6d1:	d299d0        	quos	a9, a9, a13
4037f6d4:	d28890        	quos	a8, a8, a9
		fl = 0;
4037f6d7:	0d0c      	movi.n	a13, 0
4037f6d9:	000cc6        	j	4037f710 <tlsf_realloc+0x134>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f6dc:	a88c      	beqz.n	a8, 4037f6ea <tlsf_realloc+0x10e>
4037f6de:	40f8d0        	nsau	a13, a8
4037f6e1:	e0cdd2        	addi	a13, a13, -32
4037f6e4:	60d0d0        	neg	a13, a13
4037f6e7:	000086        	j	4037f6ed <tlsf_realloc+0x111>
4037f6ea:	00a0d2        	movi	a13, 0
	return bit - 1;
4037f6ed:	ffcde2        	addi	a14, a13, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f6f0:	042792        	l32i	a9, a7, 16
4037f6f3:	25f490        	extui	a15, a9, 20, 3
4037f6f6:	c0eef0        	sub	a14, a14, a15
4037f6f9:	400e00        	ssr	a14
4037f6fc:	918080        	srl	a8, a8
4037f6ff:	1e0c      	movi.n	a14, 1
4037f701:	401f00        	ssl	a15
4037f704:	a1ee00        	sll	a14, a14
4037f707:	3088e0        	xor	a8, a8, a14
		fl -= (control->fl_index_shift - 1);
4037f70a:	249590        	extui	a9, a9, 5, 3
4037f70d:	c0dd90        	sub	a13, a13, a9
	block_header_t* prev = block->prev_free;
4037f710:	3a98      	l32i.n	a9, a10, 12
	block_header_t* next = block->next_free;
4037f712:	2ae8      	l32i.n	a14, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f714:	00e956        	bnez	a9, 4037f726 <tlsf_realloc+0x14a>
4037f717:	d61fd1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c021b48 <_flash_rodata_start+0x1a28>)
4037f71a:	d61fc1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037f71d:	74a1b2        	movi	a11, 0x174
4037f720:	d61ba1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f723:	006065        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f726:	0edc      	bnez.n	a14, 4037f73a <tlsf_realloc+0x15e>
4037f728:	d61dd1        	l32r	a13, 40374f9c <_iram_text_start+0xb98> (3c021b74 <_flash_rodata_start+0x1a54>)
4037f72b:	d61bc1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037f72e:	75a1b2        	movi	a11, 0x175
4037f731:	d616a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f734:	201110        	or	a1, a1, a1
4037f737:	005f25        	call8	4037fd28 <__assert_func>
	next->prev_free = prev;
4037f73a:	3e99      	s32i.n	a9, a14, 12
	prev->next_free = next;
4037f73c:	29e9      	s32i.n	a14, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f73e:	87f8      	l32i.n	a15, a7, 32
4037f740:	4798      	l32i.n	a9, a7, 16
4037f742:	549e90        	extui	a9, a9, 14, 6
4037f745:	8299d0        	mull	a9, a9, a13
4037f748:	998a      	add.n	a9, a9, a8
4037f74a:	a099f0        	addx4	a9, a9, a15
4037f74d:	09f8      	l32i.n	a15, a9, 0
4037f74f:	369cf7        	bne	a12, a15, 4037f789 <tlsf_realloc+0x1ad>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f752:	09e9      	s32i.n	a14, a9, 0
		if (next == &control->block_null)
4037f754:	319e77        	bne	a14, a7, 4037f789 <tlsf_realloc+0x1ad>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f757:	77c8      	l32i.n	a12, a7, 28
4037f759:	a0cdc0        	addx4	a12, a13, a12
4037f75c:	0ce8      	l32i.n	a14, a12, 0
4037f75e:	190c      	movi.n	a9, 1
4037f760:	401800        	ssl	a8
4037f763:	a18900        	sll	a8, a9
4037f766:	1088e0        	and	a8, a8, a14
4037f769:	3088e0        	xor	a8, a8, a14
4037f76c:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037f76e:	7788      	l32i.n	a8, a7, 28
4037f770:	a08d80        	addx4	a8, a13, a8
4037f773:	0888      	l32i.n	a8, a8, 0
4037f775:	08dc      	bnez.n	a8, 4037f789 <tlsf_realloc+0x1ad>
				control->fl_bitmap &= ~(1U << fl);
4037f777:	6798      	l32i.n	a9, a7, 24
4037f779:	180c      	movi.n	a8, 1
4037f77b:	401d00        	ssl	a13
4037f77e:	a18800        	sll	a8, a8
4037f781:	108890        	and	a8, a8, a9
4037f784:	308890        	xor	a8, a8, a9
4037f787:	6789      	s32i.n	a8, a7, 24
4037f789:	f8c382        	addi	a8, a3, -8
4037f78c:	1898      	l32i.n	a9, a8, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037f78e:	380c      	movi.n	a8, 3
4037f790:	0e3897        	bltu	a8, a9, 4037f7a2 <tlsf_realloc+0x1c6>
4037f793:	d603d1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c021e94 <_flash_rodata_start+0x1d74>)
4037f796:	d603c1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c0268fc <__func__$3>)
4037f799:	f5a1b2        	movi	a11, 0x1f5
4037f79c:	d5fca1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f79f:	0058a5        	call8	4037fd28 <__assert_func>
4037f7a2:	1ac8      	l32i.n	a12, a10, 4
4037f7a4:	c87c      	movi.n	a8, -4
4037f7a6:	10cc80        	and	a12, a12, a8
	prev->size += block_size(block) + block_header_overhead;
4037f7a9:	cc4b      	addi.n	a12, a12, 4
4037f7ab:	99ca      	add.n	a9, a9, a12
4037f7ad:	f8c3c2        	addi	a12, a3, -8
4037f7b0:	1c99      	s32i.n	a9, a12, 4
4037f7b2:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f7b5:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f7b8:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037f7ba:	3c0c      	movi.n	a12, 3
4037f7bc:	0e3c97        	bltu	a12, a9, 4037f7ce <tlsf_realloc+0x1f2>
4037f7bf:	d5eed1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f7c2:	d5eec1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f7c5:	a1a0b2        	movi	a11, 161
4037f7c8:	d5eea1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f7cb:	0055e5        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037f7ce:	08b9      	s32i.n	a11, a8, 0
	if (block_absorb_post_hook != NULL)
4037f7d0:	d5f681        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037f7d3:	888c      	beqz.n	a8, 4037f7df <tlsf_realloc+0x203>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037f7d5:	1c0c      	movi.n	a12, 1
4037f7d7:	0b1c      	movi.n	a11, 16
4037f7d9:	d5f381        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037f7dc:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f7df:	f8c382        	addi	a8, a3, -8
4037f7e2:	1898      	l32i.n	a9, a8, 4
4037f7e4:	c87c      	movi.n	a8, -4
4037f7e6:	108980        	and	a8, a9, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f7e9:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f7ec:	838a      	add.n	a8, a3, a8
	tlsf_assert(!block_is_last(block));
4037f7ee:	3a0c      	movi.n	a10, 3
4037f7f0:	0e3a97        	bltu	a10, a9, 4037f802 <tlsf_realloc+0x226>
4037f7f3:	d5e1d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f7f6:	d5e1c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f7f9:	a1a0b2        	movi	a11, 161
4037f7fc:	d5e1a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f7ff:	0052a5        	call8	4037fd28 <__assert_func>
	block->size &= ~block_header_prev_free_bit;
4037f802:	1898      	l32i.n	a9, a8, 4
4037f804:	da7c      	movi.n	a10, -3
4037f806:	1099a0        	and	a9, a9, a10
4037f809:	1899      	s32i.n	a9, a8, 4
	block->size &= ~block_header_free_bit;
4037f80b:	f8c392        	addi	a9, a3, -8
4037f80e:	1988      	l32i.n	a8, a9, 4
4037f810:	ea7c      	movi.n	a10, -2
4037f812:	1088a0        	and	a8, a8, a10
4037f815:	1989      	s32i.n	a8, a9, 4
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f817:	f8c382        	addi	a8, a3, -8
4037f81a:	1888      	l32i.n	a8, a8, 4
	tlsf_assert(!block_is_free(block) && "block must be used");
4037f81c:	0e6807        	bbci	a8, 0, 4037f82e <tlsf_realloc+0x252>
4037f81f:	d5fbd1        	l32r	a13, 4037500c <_iram_text_start+0xc08> (3c021ef8 <_flash_rodata_start+0x1dd8>)
4037f822:	d5fbc1        	l32r	a12, 40375010 <_iram_text_start+0xc0c> (3c0268c8 <__func__$0>)
4037f825:	31a2b2        	movi	a11, 0x231
4037f828:	d5d9a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f82b:	004fe5        	call8	4037fd28 <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f82e:	c97c      	movi.n	a9, -4
4037f830:	10a890        	and	a10, a8, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037f833:	10c582        	addi	a8, a5, 16
	if (block_can_split(block, size))
4037f836:	02ba87        	bgeu	a10, a8, 4037f83c <tlsf_realloc+0x260>
4037f839:	00b546        	j	4037fb12 <tlsf_realloc+0x536>
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037f83c:	659a      	add.n	a6, a5, a9
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f83e:	636a      	add.n	a6, a3, a6
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037f840:	c08a50        	sub	a8, a10, a5
4037f843:	889a      	add.n	a8, a8, a9
	return tlsf_cast(void*,
4037f845:	968b      	addi.n	a9, a6, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037f847:	b6bb      	addi.n	a11, a6, 11
4037f849:	fcafc2        	movi	a12, -4
4037f84c:	10bbc0        	and	a11, a11, a12
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037f84f:	0e19b7        	beq	a9, a11, 4037f861 <tlsf_realloc+0x285>
4037f852:	d5e6d1        	l32r	a13, 40374fec <_iram_text_start+0xbe8> (3c021cbc <_flash_rodata_start+0x1b9c>)
4037f855:	d5e6c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f858:	c4a1b2        	movi	a11, 0x1c4
4037f85b:	d5cca1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f85e:	004ca5        	call8	4037fd28 <__assert_func>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037f861:	80b580        	add	a11, a5, a8
4037f864:	04cbb2        	addi	a11, a11, 4
4037f867:	0e1ab7        	beq	a10, a11, 4037f879 <tlsf_realloc+0x29d>
4037f86a:	d5e2d1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0> (3c021d30 <_flash_rodata_start+0x1c10>)
4037f86d:	d5e0c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f870:	c7a1b2        	movi	a11, 0x1c7
4037f873:	d5c6a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f876:	004b25        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037f879:	0126a2        	l32i	a10, a6, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f87c:	14a0a0        	extui	a10, a10, 0, 2
4037f87f:	2088a0        	or	a8, a8, a10
4037f882:	1689      	s32i.n	a8, a6, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f884:	ca7c      	movi.n	a10, -4
4037f886:	1088a0        	and	a8, a8, a10
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037f889:	ba0c      	movi.n	a10, 11
4037f88b:	0e3a87        	bltu	a10, a8, 4037f89d <tlsf_realloc+0x2c1>
4037f88e:	d5dad1        	l32r	a13, 40374ff8 <_iram_text_start+0xbf4> (3c021d70 <_flash_rodata_start+0x1c50>)
4037f891:	d5d7c1        	l32r	a12, 40374ff0 <_iram_text_start+0xbec> (3c026940 <__func__$8>)
4037f894:	c9a1b2        	movi	a11, 0x1c9
4037f897:	d5bda1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f89a:	0048e5        	call8	4037fd28 <__assert_func>
	const size_t oldsize = block->size;
4037f89d:	f8c3a2        	addi	a10, a3, -8
4037f8a0:	1a88      	l32i.n	a8, a10, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037f8a2:	148080        	extui	a8, a8, 0, 2
4037f8a5:	205580        	or	a5, a5, a8
4037f8a8:	1a59      	s32i.n	a5, a10, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f8aa:	16a8      	l32i.n	a10, a6, 4
4037f8ac:	c87c      	movi.n	a8, -4
4037f8ae:	108a80        	and	a8, a10, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f8b1:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f8b4:	898a      	add.n	a8, a9, a8
	tlsf_assert(!block_is_last(block));
4037f8b6:	3b0c      	movi.n	a11, 3
4037f8b8:	0e3ba7        	bltu	a11, a10, 4037f8ca <tlsf_realloc+0x2ee>
4037f8bb:	d5afd1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f8be:	d5afc1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f8c1:	a1a0b2        	movi	a11, 161
4037f8c4:	d5afa1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f8c7:	004625        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037f8ca:	0869      	s32i.n	a6, a8, 0
	block->size |= block_header_prev_free_bit;
4037f8cc:	18a8      	l32i.n	a10, a8, 4
4037f8ce:	2b0c      	movi.n	a11, 2
4037f8d0:	20aab0        	or	a10, a10, a11
4037f8d3:	18a9      	s32i.n	a10, a8, 4
	block->size |= block_header_free_bit;
4037f8d5:	1688      	l32i.n	a8, a6, 4
4037f8d7:	1a0c      	movi.n	a10, 1
4037f8d9:	20b8a0        	or	a11, a8, a10
4037f8dc:	16b9      	s32i.n	a11, a6, 4
	block->size &= ~block_header_prev_free_bit;
4037f8de:	db7c      	movi.n	a11, -3
4037f8e0:	10b8b0        	and	a11, a8, a11
4037f8e3:	20bba0        	or	a11, a11, a10
4037f8e6:	16b9      	s32i.n	a11, a6, 4
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037f8e8:	ca7c      	movi.n	a10, -4
4037f8ea:	10a8a0        	and	a10, a8, a10
4037f8ed:	fccaa2        	addi	a10, a10, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037f8f0:	a9aa      	add.n	a10, a9, a10
4037f8f2:	0acd      	mov.n	a12, a10
	tlsf_assert(!block_is_last(block));
4037f8f4:	380c      	movi.n	a8, 3
4037f8f6:	0e38b7        	bltu	a8, a11, 4037f908 <tlsf_realloc+0x32c>
4037f8f9:	d59fd1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037f8fc:	d5a0c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037f8ff:	a1a0b2        	movi	a11, 161
4037f902:	d59fa1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037f905:	004225        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next physical block can't be null");
4037f908:	dacc      	bnez.n	a10, 4037f919 <tlsf_realloc+0x33d>
4037f90a:	d5a8d1        	l32r	a13, 40374fac <_iram_text_start+0xba8> (3c021ecc <_flash_rodata_start+0x1dac>)
4037f90d:	d5a8c1        	l32r	a12, 40374fb0 <_iram_text_start+0xbac> (3c0268e8 <__func__$2>)
4037f910:	15a2b2        	movi	a11, 0x215
4037f913:	d59ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f916:	004125        	call8	4037fd28 <__assert_func>
	return tlsf_cast(int, block->size & block_header_free_bit);
4037f919:	1a88      	l32i.n	a8, a10, 4
	if (block_is_free(next))
4037f91b:	02e807        	bbsi	a8, 0, 4037f921 <tlsf_realloc+0x345>
4037f91e:	004606        	j	4037fa3a <tlsf_realloc+0x45e>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037f921:	cb7c      	movi.n	a11, -4
4037f923:	10b8b0        	and	a11, a8, a11
	if (size < control->small_block_size)
4037f926:	4788      	l32i.n	a8, a7, 16
4037f928:	758780        	extui	a8, a8, 23, 8
4037f92b:	0fbb87        	bgeu	a11, a8, 4037f93e <tlsf_realloc+0x362>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037f92e:	47d8      	l32i.n	a13, a7, 16
4037f930:	54ded0        	extui	a13, a13, 14, 6
4037f933:	d288d0        	quos	a8, a8, a13
4037f936:	d2bb80        	quos	a11, a11, a8
		fl = 0;
4037f939:	0e0c      	movi.n	a14, 0
4037f93b:	000d06        	j	4037f973 <tlsf_realloc+0x397>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037f93e:	bb8c      	beqz.n	a11, 4037f94d <tlsf_realloc+0x371>
4037f940:	40fbe0        	nsau	a14, a11
4037f943:	e0cee2        	addi	a14, a14, -32
4037f946:	60e0e0        	neg	a14, a14
4037f949:	0000c6        	j	4037f950 <tlsf_realloc+0x374>
4037f94c:	a0e200        	addx4	a14, a2, a0
4037f94f:	00          	.byte	00
	return bit - 1;
4037f950:	ffced2        	addi	a13, a14, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037f953:	042782        	l32i	a8, a7, 16
4037f956:	25f480        	extui	a15, a8, 20, 3
4037f959:	c0ddf0        	sub	a13, a13, a15
4037f95c:	400d00        	ssr	a13
4037f95f:	91b0b0        	srl	a11, a11
4037f962:	1d0c      	movi.n	a13, 1
4037f964:	401f00        	ssl	a15
4037f967:	a1dd00        	sll	a13, a13
4037f96a:	30bbd0        	xor	a11, a11, a13
		fl -= (control->fl_index_shift - 1);
4037f96d:	248580        	extui	a8, a8, 5, 3
4037f970:	c0ee80        	sub	a14, a14, a8
	block_header_t* prev = block->prev_free;
4037f973:	3a88      	l32i.n	a8, a10, 12
	block_header_t* next = block->next_free;
4037f975:	2ad8      	l32i.n	a13, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037f977:	d8cc      	bnez.n	a8, 4037f988 <tlsf_realloc+0x3ac>
4037f979:	d586d1        	l32r	a13, 40374f94 <_iram_text_start+0xb90> (3c021b48 <_flash_rodata_start+0x1a28>)
4037f97c:	d587c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037f97f:	74a1b2        	movi	a11, 0x174
4037f982:	d582a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f985:	003a25        	call8	4037fd28 <__assert_func>
	tlsf_assert(next && "next_free field can not be null");
4037f988:	ddcc      	bnez.n	a13, 4037f999 <tlsf_realloc+0x3bd>
4037f98a:	d584d1        	l32r	a13, 40374f9c <_iram_text_start+0xb98> (3c021b74 <_flash_rodata_start+0x1a54>)
4037f98d:	d582c1        	l32r	a12, 40374f98 <_iram_text_start+0xb94> (3c0269b0 <__func__$14>)
4037f990:	75a1b2        	movi	a11, 0x175
4037f993:	d57ea1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f996:	003925        	call8	4037fd28 <__assert_func>
	next->prev_free = prev;
4037f999:	3d89      	s32i.n	a8, a13, 12
	prev->next_free = next;
4037f99b:	0268d2        	s32i	a13, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037f99e:	87f8      	l32i.n	a15, a7, 32
4037f9a0:	4788      	l32i.n	a8, a7, 16
4037f9a2:	548e80        	extui	a8, a8, 14, 6
4037f9a5:	8288e0        	mull	a8, a8, a14
4037f9a8:	88ba      	add.n	a8, a8, a11
4037f9aa:	a088f0        	addx4	a8, a8, a15
4037f9ad:	08f8      	l32i.n	a15, a8, 0
4037f9af:	379cf7        	bne	a12, a15, 4037f9ea <tlsf_realloc+0x40e>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037f9b2:	08d9      	s32i.n	a13, a8, 0
		if (next == &control->block_null)
4037f9b4:	329d77        	bne	a13, a7, 4037f9ea <tlsf_realloc+0x40e>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037f9b7:	77c8      	l32i.n	a12, a7, 28
4037f9b9:	11dee0        	slli	a13, a14, 2
4037f9bc:	ccda      	add.n	a12, a12, a13
4037f9be:	0cf8      	l32i.n	a15, a12, 0
4037f9c0:	180c      	movi.n	a8, 1
4037f9c2:	401b00        	ssl	a11
4037f9c5:	a18800        	sll	a8, a8
4037f9c8:	1088f0        	and	a8, a8, a15
4037f9cb:	3088f0        	xor	a8, a8, a15
4037f9ce:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037f9d0:	7788      	l32i.n	a8, a7, 28
4037f9d2:	88da      	add.n	a8, a8, a13
4037f9d4:	0888      	l32i.n	a8, a8, 0
4037f9d6:	08dc      	bnez.n	a8, 4037f9ea <tlsf_realloc+0x40e>
				control->fl_bitmap &= ~(1U << fl);
4037f9d8:	67b8      	l32i.n	a11, a7, 24
4037f9da:	180c      	movi.n	a8, 1
4037f9dc:	401e00        	ssl	a14
4037f9df:	a18800        	sll	a8, a8
4037f9e2:	1088b0        	and	a8, a8, a11
4037f9e5:	3088b0        	xor	a8, a8, a11
4037f9e8:	6789      	s32i.n	a8, a7, 24
4037f9ea:	1688      	l32i.n	a8, a6, 4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037f9ec:	3b0c      	movi.n	a11, 3
4037f9ee:	0e3b87        	bltu	a11, a8, 4037fa00 <tlsf_realloc+0x424>
4037f9f1:	d56bd1        	l32r	a13, 40374fa0 <_iram_text_start+0xb9c> (3c021e94 <_flash_rodata_start+0x1d74>)
4037f9f4:	d56cc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0> (3c0268fc <__func__$3>)
4037f9f7:	f5a1b2        	movi	a11, 0x1f5
4037f9fa:	d564a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037f9fd:	0032a5        	call8	4037fd28 <__assert_func>
4037fa00:	1ac8      	l32i.n	a12, a10, 4
4037fa02:	cb7c      	movi.n	a11, -4
4037fa04:	10ccb0        	and	a12, a12, a11
	prev->size += block_size(block) + block_header_overhead;
4037fa07:	cc4b      	addi.n	a12, a12, 4
4037fa09:	88ca      	add.n	a8, a8, a12
4037fa0b:	1689      	s32i.n	a8, a6, 4
4037fa0d:	10b8b0        	and	a11, a8, a11
	block_header_t* next = offset_to_block(block_to_ptr(block),
4037fa10:	fccbb2        	addi	a11, a11, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037fa13:	99ba      	add.n	a9, a9, a11
	tlsf_assert(!block_is_last(block));
4037fa15:	3b0c      	movi.n	a11, 3
4037fa17:	0e3b87        	bltu	a11, a8, 4037fa29 <tlsf_realloc+0x44d>
4037fa1a:	d557d1        	l32r	a13, 40374f78 <_iram_text_start+0xb74> (3c0218c4 <_flash_rodata_start+0x17a4>)
4037fa1d:	d557c1        	l32r	a12, 40374f7c <_iram_text_start+0xb78> (3c0269f0 <__func__$20>)
4037fa20:	a1a0b2        	movi	a11, 161
4037fa23:	d557a1        	l32r	a10, 40374f80 <_iram_text_start+0xb7c> (3c0218f7 <_flash_rodata_start+0x17d7>)
4037fa26:	003025        	call8	4037fd28 <__assert_func>
	next->prev_phys_block = block;
4037fa29:	0969      	s32i.n	a6, a9, 0
	if (block_absorb_post_hook != NULL)
4037fa2b:	d55f81        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037fa2e:	888c      	beqz.n	a8, 4037fa3a <tlsf_realloc+0x45e>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037fa30:	1c0c      	movi.n	a12, 1
4037fa32:	0b1c      	movi.n	a11, 16
4037fa34:	d55d81        	l32r	a8, 40374fa8 <_iram_text_start+0xba4> (0 <IDF_TARGET_ESP32S3>)
4037fa37:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037fa3a:	1688      	l32i.n	a8, a6, 4
4037fa3c:	c97c      	movi.n	a9, -4
4037fa3e:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037fa41:	4798      	l32i.n	a9, a7, 16
4037fa43:	759790        	extui	a9, a9, 23, 8
4037fa46:	0fb897        	bgeu	a8, a9, 4037fa59 <tlsf_realloc+0x47d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037fa49:	47a8      	l32i.n	a10, a7, 16
4037fa4b:	54aea0        	extui	a10, a10, 14, 6
4037fa4e:	d299a0        	quos	a9, a9, a10
4037fa51:	d28890        	quos	a8, a8, a9
		fl = 0;
4037fa54:	0a0c      	movi.n	a10, 0
4037fa56:	000d06        	j	4037fa8e <tlsf_realloc+0x4b2>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037fa59:	b88c      	beqz.n	a8, 4037fa68 <tlsf_realloc+0x48c>
4037fa5b:	40f8a0        	nsau	a10, a8
4037fa5e:	e0caa2        	addi	a10, a10, -32
4037fa61:	60a0a0        	neg	a10, a10
4037fa64:	0000c6        	j	4037fa6b <tlsf_realloc+0x48f>
4037fa67:	a0a200        	addx4	a10, a2, a0
4037fa6a:	cab200        	float.s	f11, a2, 0
	return bit - 1;
4037fa6d:	042792ff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 0x120, q6, q2, q2, q7
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037fa71:	25c490        	extui	a12, a9, 20, 3
4037fa74:	c0bbc0        	sub	a11, a11, a12
4037fa77:	400b00        	ssr	a11
4037fa7a:	918080        	srl	a8, a8
4037fa7d:	1b0c      	movi.n	a11, 1
4037fa7f:	401c00        	ssl	a12
4037fa82:	a1bb00        	sll	a11, a11
4037fa85:	3088b0        	xor	a8, a8, a11
		fl -= (control->fl_index_shift - 1);
4037fa88:	249590        	extui	a9, a9, 5, 3
4037fa8b:	c0aa90        	sub	a10, a10, a9
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037fa8e:	87b8      	l32i.n	a11, a7, 32
4037fa90:	4798      	l32i.n	a9, a7, 16
4037fa92:	549e90        	extui	a9, a9, 14, 6
4037fa95:	8299a0        	mull	a9, a9, a10
4037fa98:	998a      	add.n	a9, a9, a8
4037fa9a:	a099b0        	addx4	a9, a9, a11
4037fa9d:	0998      	l32i.n	a9, a9, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037fa9f:	d9cc      	bnez.n	a9, 4037fab0 <tlsf_realloc+0x4d4>
4037faa1:	d544d1        	l32r	a13, 40374fb4 <_iram_text_start+0xbb0> (3c021984 <_flash_rodata_start+0x1864>)
4037faa4:	d545c1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037faa7:	90a1b2        	movi	a11, 0x190
4037faaa:	d538a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037faad:	0027a5        	call8	4037fd28 <__assert_func>
	tlsf_assert(block && "cannot insert a null entry into the free list");
4037fab0:	d6cc      	bnez.n	a6, 4037fac1 <tlsf_realloc+0x4e5>
4037fab2:	d542d1        	l32r	a13, 40374fbc <_iram_text_start+0xbb8> (3c0219e8 <_flash_rodata_start+0x18c8>)
4037fab5:	d540c1        	l32r	a12, 40374fb8 <_iram_text_start+0xbb4> (3c0269d0 <__func__$17>)
4037fab8:	91a1b2        	movi	a11, 0x191
4037fabb:	d534a1        	l32r	a10, 40374f8c <_iram_text_start+0xb88> (3c0219cf <_flash_rodata_start+0x18af>)
4037fabe:	0026a5        	call8	4037fd28 <__assert_func>
	block->next_free = current;
4037fac1:	2699      	s32i.n	a9, a6, 8
	block->prev_free = &control->block_null;
4037fac3:	3679      	s32i.n	a7, a6, 12
	current->prev_free = block;
4037fac5:	3969      	s32i.n	a6, a9, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037fac7:	87b8      	l32i.n	a11, a7, 32
4037fac9:	4798      	l32i.n	a9, a7, 16
4037facb:	549e90        	extui	a9, a9, 14, 6
4037face:	829a90        	mull	a9, a10, a9
4037fad1:	989a      	add.n	a9, a8, a9
4037fad3:	a099b0        	addx4	a9, a9, a11
4037fad6:	0969      	s32i.n	a6, a9, 0
	control->fl_bitmap |= (1U << fl);
4037fad8:	67b8      	l32i.n	a11, a7, 24
4037fada:	190c      	movi.n	a9, 1
4037fadc:	401a00        	ssl	a10
4037fadf:	a1c900        	sll	a12, a9
4037fae2:	20bbc0        	or	a11, a11, a12
4037fae5:	67b9      	s32i.n	a11, a7, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037fae7:	77b8      	l32i.n	a11, a7, 28
4037fae9:	a0aab0        	addx4	a10, a10, a11
4037faec:	0ab8      	l32i.n	a11, a10, 0
4037faee:	401800        	ssl	a8
4037faf1:	a19900        	sll	a9, a9
4037faf4:	208b90        	or	a8, a11, a9
4037faf7:	0a89      	s32i.n	a8, a10, 0
				block_mark_as_used(block);
			}

			/* Trim the resulting block and return the original pointer. */
			block_trim_used(control, block, adjust);
			p = ptr;
4037faf9:	032d      	mov.n	a2, a3
}
4037fafb:	000546        	j	4037fb14 <tlsf_realloc+0x538>
4037fafe:	000000        	ill
			return p;
4037fb01:	020c      	movi.n	a2, 0
4037fb03:	000346        	j	4037fb14 <tlsf_realloc+0x538>
4037fb06:	060000        	ee.ldf.64.xp	f0, f0, a0, a0
4037fb09:	000002        	l8ui	a0, a0, 0
4037fb0c:	020c      	movi.n	a2, 0
4037fb0e:	000086        	j	4037fb14 <tlsf_realloc+0x538>
4037fb11:	00          	.byte	00
			p = ptr;
4037fb12:	032d      	mov.n	a2, a3
		}
	}

	return p;
}
4037fb14:	f01d      	retw.n
	...

4037fb18 <tlsf_size>:
{
4037fb18:	004136        	entry	a1, 32
	if (tlsf == NULL)
4037fb1b:	328c      	beqz.n	a2, 4037fb22 <tlsf_size+0xa>
	return control->size;
4037fb1d:	5228      	l32i.n	a2, a2, 20
4037fb1f:	000046        	j	4037fb24 <tlsf_size+0xc>
		return 0;
4037fb22:	020c      	movi.n	a2, 0
}
4037fb24:	f01d      	retw.n
	...

4037fb28 <esp_log>:
    }
#endif // ESP_LOG_VERSION == 2
}

void __attribute__((optimize("-O3"))) esp_log(esp_log_config_t config, const char* tag, const char* format, ...)
{
4037fb28:	00c136        	entry	a1, 96
    if (1) {
#else // ESP_LOG_VERSION == 2
    if (is_level_loggable(config)) {
#endif
        va_list args;
        va_start(args, format);
4037fb2b:	40c1a2        	addi	a10, a1, 64
4037fb2e:	c80c      	movi.n	a8, 12
4037fb30:	20c192        	addi	a9, a1, 32
4037fb33:	31a9      	s32i.n	a10, a1, 12
4037fb35:	5189      	s32i.n	a8, a1, 20
4037fb37:	01a9      	s32i.n	a10, a1, 0
4037fb39:	2189      	s32i.n	a8, a1, 8
4037fb3b:	b159      	s32i.n	a5, a1, 44
    if (config.opts.log_level != ESP_LOG_NONE && esp_log_is_tag_loggable(config.opts.log_level, tag)) {
4037fb3d:	248020        	extui	a8, a2, 0, 3
        va_start(args, format);
4037fb40:	c169      	s32i.n	a6, a1, 48
4037fb42:	d179      	s32i.n	a7, a1, 52
4037fb44:	4199      	s32i.n	a9, a1, 16
4037fb46:	1199      	s32i.n	a9, a1, 4
        esp_log_va(config, tag, format, args);
4037fb48:	08ad      	mov.n	a10, a8
    if (config.opts.log_level != ESP_LOG_NONE && esp_log_is_tag_loggable(config.opts.log_level, tag)) {
4037fb4a:	889c      	beqz.n	a8, 4037fb66 <esp_log+0x3e>
4037fb4c:	03bd      	mov.n	a11, a3
4037fb4e:	d53281        	l32r	a8, 40375018 <_iram_text_start+0xc14> (42002b64 <esp_log_is_tag_loggable>)
4037fb51:	0008e0        	callx8	a8
4037fb54:	ea8c      	beqz.n	a10, 4037fb66 <esp_log+0x3e>
        esp_log_vprint_func(format, args);
4037fb56:	d52f81        	l32r	a8, 40375014 <_iram_text_start+0xc10> (3fc92434 <esp_log_vprint_func>)
4037fb59:	01b8      	l32i.n	a11, a1, 0
4037fb5b:	0888      	l32i.n	a8, a8, 0
4037fb5d:	11c8      	l32i.n	a12, a1, 4
4037fb5f:	21d8      	l32i.n	a13, a1, 8
4037fb61:	04ad      	mov.n	a10, a4
4037fb63:	0008e0        	callx8	a8
        va_end(args);
    }
}
4037fb66:	f01d      	retw.n

4037fb68 <esp_log_impl_lock>:
#define MAX_MUTEX_WAIT_TICKS ((MAX_MUTEX_WAIT_MS + portTICK_PERIOD_MS - 1) / portTICK_PERIOD_MS)

static SemaphoreHandle_t s_log_mutex = NULL;

void esp_log_impl_lock(void)
{
4037fb68:	004136        	entry	a1, 32
    if (unlikely(!s_log_mutex)) {
4037fb6b:	d52c81        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fb6e:	0888      	l32i.n	a8, a8, 0
4037fb70:	98cc      	bnez.n	a8, 4037fb7d <esp_log_impl_lock+0x15>
        s_log_mutex = xSemaphoreCreateMutex();
4037fb72:	01a0a2        	movi	a10, 1
4037fb75:	f9ff65        	call8	40379b6c <xQueueCreateMutex>
4037fb78:	d52981        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fb7b:	08a9      	s32i.n	a10, a8, 0
    }
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fb7d:	fbdb65        	call8	4037b934 <xTaskGetSchedulerState>
4037fb80:	091a26        	beqi	a10, 1, 4037fb8d <esp_log_impl_lock+0x25>
        return;
    }
    xSemaphoreTake(s_log_mutex, portMAX_DELAY);
4037fb83:	fb7c      	movi.n	a11, -1
4037fb85:	d52581        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fb88:	08a8      	l32i.n	a10, a8, 0
4037fb8a:	fa1125        	call8	40379c9c <xQueueSemaphoreTake>
}
4037fb8d:	f01d      	retw.n
	...

4037fb90 <esp_log_impl_lock_timeout>:

bool esp_log_impl_lock_timeout(void)
{
4037fb90:	004136        	entry	a1, 32
    if (unlikely(!s_log_mutex)) {
4037fb93:	d52281        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fb96:	0888      	l32i.n	a8, a8, 0
4037fb98:	98cc      	bnez.n	a8, 4037fba5 <esp_log_impl_lock_timeout+0x15>
        s_log_mutex = xSemaphoreCreateMutex();
4037fb9a:	01a0a2        	movi	a10, 1
4037fb9d:	f9fce5        	call8	40379b6c <xQueueCreateMutex>
4037fba0:	d51f81        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fba3:	08a9      	s32i.n	a10, a8, 0
    }
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fba5:	fbd8e5        	call8	4037b934 <xTaskGetSchedulerState>
4037fba8:	181a26        	beqi	a10, 1, 4037fbc4 <esp_log_impl_lock_timeout+0x34>
        return true;
    }
    return xSemaphoreTake(s_log_mutex, MAX_MUTEX_WAIT_TICKS) == pdTRUE;
4037fbab:	01a0b2        	movi	a11, 1
4037fbae:	d51b81        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fbb1:	0028a2        	l32i	a10, a8, 0
4037fbb4:	fa0e65        	call8	40379c9c <xQueueSemaphoreTake>
4037fbb7:	ffca22        	addi	a2, a10, -1
4037fbba:	40f220        	nsau	a2, a2
4037fbbd:	412520        	srli	a2, a2, 5
4037fbc0:	000086        	j	4037fbc6 <esp_log_impl_lock_timeout+0x36>
4037fbc3:	120c00        	andbc	b0, b12, b0
}
4037fbc6:	f01d      	retw.n

4037fbc8 <esp_log_impl_unlock>:

void esp_log_impl_unlock(void)
{
4037fbc8:	004136        	entry	a1, 32
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fbcb:	fbd6a5        	call8	4037b934 <xTaskGetSchedulerState>
4037fbce:	0f1a26        	beqi	a10, 1, 4037fbe1 <esp_log_impl_unlock+0x19>
        return;
    }
    xSemaphoreGive(s_log_mutex);
4037fbd1:	00a0d2        	movi	a13, 0
4037fbd4:	20cdd0        	or	a12, a13, a13
4037fbd7:	0dbd      	mov.n	a11, a13
4037fbd9:	d51081        	l32r	a8, 4037501c <_iram_text_start+0xc18> (3fc94f30 <s_log_mutex>)
4037fbdc:	08a8      	l32i.n	a10, a8, 0
4037fbde:	f9e165        	call8	403799f4 <xQueueGenericSend>
}
4037fbe1:	f01d      	retw.n
	...

4037fbe4 <esp_log_early_timestamp>:
    return base + tick_count * (1000 / configTICK_RATE_HZ);
}

/* FIXME: define an API for getting the timestamp in soc/hal IDF-2351 */
uint32_t esp_log_early_timestamp(void)
{
4037fbe4:	004136        	entry	a1, 32
    RSR(CCOUNT, ccount);
4037fbe7:	03ea20        	rsr.ccount	a2
#if CONFIG_IDF_TARGET_ESP32
    /* ESP32 ROM stores separate clock rate values for each CPU, but we want the PRO CPU value always */
    extern uint32_t g_ticks_per_us_pro;
    return esp_cpu_get_cycle_count() / (g_ticks_per_us_pro * 1000);
#else
    return esp_cpu_get_cycle_count() / (esp_rom_get_cpu_ticks_per_us() * 1000);
4037fbea:	d2b181        	l32r	a8, 403746b0 <_iram_text_start+0x2ac> (40001a40 <esp_rom_get_cpu_ticks_per_us>)
4037fbed:	0008e0        	callx8	a8
4037fbf0:	118ab0        	slli	a8, a10, 5
4037fbf3:	c088a0        	sub	a8, a8, a10
4037fbf6:	a088a0        	addx4	a8, a8, a10
4037fbf9:	1188d0        	slli	a8, a8, 3
#endif
}
4037fbfc:	c22280        	quou	a2, a2, a8
4037fbff:	f01d      	retw.n
4037fc01:	000000        	ill

4037fc04 <esp_log_timestamp>:
{
4037fc04:	004136        	entry	a1, 32
    if (unlikely(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)) {
4037fc07:	fbd2e5        	call8	4037b934 <xTaskGetSchedulerState>
4037fc0a:	0a1a66        	bnei	a10, 1, 4037fc18 <esp_log_timestamp+0x14>
        return esp_log_early_timestamp();
4037fc0d:	fffd65        	call8	4037fbe4 <esp_log_early_timestamp>
4037fc10:	0a2d      	mov.n	a2, a10
4037fc12:	000d06        	j	4037fc4a <esp_log_timestamp+0x46>
4037fc15:	000000        	ill
    if (base == 0 && xPortGetCoreID() == 0) {
4037fc18:	d50281        	l32r	a8, 40375020 <_iram_text_start+0xc1c> (3fc94e20 <base$0>)
4037fc1b:	002882        	l32i	a8, a8, 0
4037fc1e:	e8cc      	bnez.n	a8, 4037fc30 <esp_log_timestamp+0x2c>
    asm volatile (
4037fc20:	03eb80        	rsr.prid	a8
4037fc23:	048d80        	extui	a8, a8, 13, 1
4037fc26:	68cc      	bnez.n	a8, 4037fc30 <esp_log_timestamp+0x2c>
        base = esp_log_early_timestamp();
4037fc28:	fffba5        	call8	4037fbe4 <esp_log_early_timestamp>
4037fc2b:	d4fd81        	l32r	a8, 40375020 <_iram_text_start+0xc1c> (3fc94e20 <base$0>)
4037fc2e:	08a9      	s32i.n	a10, a8, 0
    TickType_t tick_count = xPortInIsrContext() ? xTaskGetTickCountFromISR() : xTaskGetTickCount();
4037fc30:	fa3be5        	call8	40379ff0 <xPortInIsrContext>
4037fc33:	5a8c      	beqz.n	a10, 4037fc3c <esp_log_timestamp+0x38>
4037fc35:	fb49a5        	call8	4037b0d0 <xTaskGetTickCountFromISR>
4037fc38:	0000c6        	j	4037fc3f <esp_log_timestamp+0x3b>
4037fc3b:	482500        	ssx	f2, a5, a0
4037fc3e:	a0fb      	addi.n	a10, a0, 15
    return base + tick_count * (1000 / configTICK_RATE_HZ);
4037fc40:	a0aa      	add.n	a10, a0, a10
4037fc42:	d4f781        	l32r	a8, 40375020 <_iram_text_start+0xc1c> (3fc94e20 <base$0>)
4037fc45:	0888      	l32i.n	a8, a8, 0
4037fc47:	902a80        	addx2	a2, a10, a8
}
4037fc4a:	f01d      	retw.n

4037fc4c <esp_log_level_get_timeout>:
    log_level_set(tag, level);
#endif
}

esp_log_level_t esp_log_level_get_timeout(const char *tag)
{
4037fc4c:	004136        	entry	a1, 32
4037fc4f:	02ad      	mov.n	a10, a2
#if CONFIG_LOG_TAG_LEVEL_IMPL_NONE
    (void)tag;
    return esp_log_get_default_level();
#else
    return log_level_get(tag, true);
4037fc51:	1b0c      	movi.n	a11, 1
4037fc53:	d4f481        	l32r	a8, 40375024 <_iram_text_start+0xc20> (420195c4 <log_level_get>)
4037fc56:	0008e0        	callx8	a8
#endif
}
4037fc59:	0a2d      	mov.n	a2, a10
4037fc5b:	f01d      	retw.n
4037fc5d:	000000        	ill

4037fc60 <esp_log_util_set_cache_enabled_cb>:
#include "sdkconfig.h"

static esp_log_cache_enabled_t esp_log_cache_enabled = NULL;

void esp_log_util_set_cache_enabled_cb(esp_log_cache_enabled_t func)
{
4037fc60:	004136        	entry	a1, 32
    esp_log_cache_enabled = func;
4037fc63:	d4f181        	l32r	a8, 40375028 <_iram_text_start+0xc24> (3fc94e24 <esp_log_cache_enabled>)
4037fc66:	0829      	s32i.n	a2, a8, 0
}
4037fc68:	f01d      	retw.n
	...

4037fc6c <abort>:
#include "esp_cpu.h"

#include "soc/soc_caps.h"

void __attribute__((noreturn)) abort(void)
{
4037fc6c:	00e136        	entry	a1, 112
#define ERR_STR2  " on core "

    _Static_assert(UINTPTR_MAX == 0xffffffff, "abort() assumes 32-bit addresses");
    _Static_assert(SOC_CPU_CORES_NUM < 10, "abort() assumes number of cores is 1 to 9");

    char addr_buf[9] = { 0 };
4037fc6f:	9c0c      	movi.n	a12, 9
4037fc71:	00a0b2        	movi	a11, 0
4037fc74:	01ad      	mov.n	a10, a1
4037fc76:	d21081        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037fc79:	0008e0        	callx8	a8
    char core_buf[2] = { 0 };
4037fc7c:	719b      	addi.n	a7, a1, 9
4037fc7e:	2c0c      	movi.n	a12, 2
4037fc80:	00a0b2        	movi	a11, 0
4037fc83:	20a770        	or	a10, a7, a7
4037fc86:	d20c81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037fc89:	0008e0        	callx8	a8

    char buf[sizeof(ERR_STR1) + sizeof(addr_buf) + sizeof(core_buf) + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037fc8c:	2c3c      	movi.n	a12, 50
4037fc8e:	0b0c      	movi.n	a11, 0
4037fc90:	0bc1a2        	addi	a10, a1, 11
4037fc93:	d20981        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037fc96:	0008e0        	callx8	a8

    itoa((uint32_t)(__builtin_return_address(0) - 3), addr_buf, 16);
4037fc99:	d4e481        	l32r	a8, 4037502c <_iram_text_start+0xc28> (4037fc99 <abort+0x2d>)
4037fc9c:	158e80        	extui	a8, a8, 30, 2
4037fc9f:	018820        	slli	a8, a8, 30
4037fca2:	11a0e0        	slli	a10, a0, 2
4037fca5:	41a2a0        	srli	a10, a10, 2
4037fca8:	20aa80        	or	a10, a10, a8
4037fcab:	0c1c      	movi.n	a12, 16
4037fcad:	01bd      	mov.n	a11, a1
4037fcaf:	fdcaa2        	addi	a10, a10, -3
4037fcb2:	d4e181        	l32r	a8, 40375038 <_iram_text_start+0xc34> (400014c4 <itoa>)
4037fcb5:	0008e0        	callx8	a8
4037fcb8:	03eba0        	rsr.prid	a10
4037fcbb:	04ada0        	extui	a10, a10, 13, 1
    itoa(esp_cpu_get_core_id(), core_buf, 10);
4037fcbe:	ac0c      	movi.n	a12, 10
4037fcc0:	07bd      	mov.n	a11, a7
4037fcc2:	d4dd81        	l32r	a8, 40375038 <_iram_text_start+0xc34> (400014c4 <itoa>)
4037fcc5:	0008e0        	callx8	a8

    const char *str[] = { ERR_STR1, addr_buf, ERR_STR2, core_buf };
4037fcc8:	d4da81        	l32r	a8, 40375030 <_iram_text_start+0xc2c> (3fc93ecc <__func__$0+0x2e0>)
4037fccb:	106182        	s32i	a8, a1, 64
4037fcce:	116112        	s32i	a1, a1, 68
4037fcd1:	d4d881        	l32r	a8, 40375034 <_iram_text_start+0xc30> (3fc93ee8 <__func__$0+0x2fc>)
4037fcd4:	126182        	s32i	a8, a1, 72
4037fcd7:	136172        	s32i	a7, a1, 76

    char *dest = buf;

    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fcda:	070c      	movi.n	a7, 0
4037fcdc:	000406        	j	4037fcf0 <abort+0x84>
4037fcdf:	871000        	ee.stf.64.xp	f1, f8, a0, a0
        strcat(dest, str[i]);
4037fce2:	a0          	.byte	0xa0
4037fce3:	1028b2        	l32i	a11, a8, 64
4037fce6:	a1bb      	addi.n	a10, a1, 11
4037fce8:	d3c281        	l32r	a8, 40374bf0 <_iram_text_start+0x7ec> (40001374 <strcat>)
4037fceb:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fcee:	771b      	addi.n	a7, a7, 1
4037fcf0:	ec47b6        	bltui	a7, 4, 4037fce0 <abort+0x74>
    }

    esp_system_abort(buf);
4037fcf3:	a1bb      	addi.n	a10, a1, 11
4037fcf5:	f99b25        	call8	403796a8 <esp_system_abort>

4037fcf8 <ra_to_str>:
#elif __riscv
#define INST_LEN         4
#endif

static inline void ra_to_str(char *addr)
{
4037fcf8:	004136        	entry	a1, 32
    addr[0] = '0';
4037fcfb:	083c      	movi.n	a8, 48
4037fcfd:	004282        	s8i	a8, a2, 0
    addr[1] = 'x';
4037fd00:	78a082        	movi	a8, 120
4037fd03:	014282        	s8i	a8, a2, 1
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037fd06:	d4cd81        	l32r	a8, 4037503c <_iram_text_start+0xc38> (4037fd06 <ra_to_str+0xe>)
4037fd09:	158e80        	extui	a8, a8, 30, 2
4037fd0c:	018820        	slli	a8, a8, 30
4037fd0f:	11a0e0        	slli	a10, a0, 2
4037fd12:	41a2a0        	srli	a10, a10, 2
4037fd15:	20aa80        	or	a10, a10, a8
4037fd18:	0c1c      	movi.n	a12, 16
4037fd1a:	b22b      	addi.n	a11, a2, 2
4037fd1c:	fdcaa2        	addi	a10, a10, -3
4037fd1f:	d4c681        	l32r	a8, 40375038 <_iram_text_start+0xc34> (400014c4 <itoa>)
4037fd22:	0008e0        	callx8	a8
}
4037fd25:	f01d      	retw.n
	...

4037fd28 <__assert_func>:

/* Overriding assert function so that whenever assert is called from critical section,
 * it does not lead to a crash of its own.
 */
void __attribute__((noreturn)) __assert_func(const char *file, int line, const char *func, const char *expr)
{
4037fd28:	024136        	entry	a1, 0x120

    ra_to_str(&buff[sizeof(ASSERT_STR) - 1]);

    esp_system_abort(buff);
#else
    char addr[11] = { 0 };
4037fd2b:	bc0c      	movi.n	a12, 11
4037fd2d:	0b0c      	movi.n	a11, 0
4037fd2f:	01ad      	mov.n	a10, a1
4037fd31:	d1e181        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4037fd34:	0008e0        	callx8	a8
    char buff[200];
    char lbuf[5];
    uint32_t rem_len = sizeof(buff) - 1;
    uint32_t off = 0;

    itoa(line, lbuf, 10);
4037fd37:	ac0c      	movi.n	a12, 10
4037fd39:	d3a0b2        	movi	a11, 211
4037fd3c:	b1ba      	add.n	a11, a1, a11
4037fd3e:	03ad      	mov.n	a10, a3
4037fd40:	d4be81        	l32r	a8, 40375038 <_iram_text_start+0xc34> (400014c4 <itoa>)
4037fd43:	0008e0        	callx8	a8

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
    if (!spi_flash_cache_enabled())
4037fd46:	f7c6e5        	call8	403779b4 <spi_flash_cache_enabled>
4037fd49:	048a56        	bnez	a10, 4037fd95 <__assert_func+0x6d>
    return ((intptr_t)p >= drom_start_addr && (intptr_t)p < SOC_DROM_HIGH);
4037fd4c:	d2a691        	l32r	a9, 403747e4 <_iram_text_start+0x3e0> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fd4f:	729920        	salt	a9, a9, a2
4037fd52:	d2a581        	l32r	a8, 403747e8 <_iram_text_start+0x3e4> (3dffffff <_esp_system_init_fn_array_end+0x1fd6d5b>)
4037fd55:	728820        	salt	a8, a8, a2
4037fd58:	880b      	addi.n	a8, a8, -1
4037fd5a:	608080        	neg	a8, a8
#endif
    {
        if (esp_ptr_in_drom(file)) {
4037fd5d:	020897        	bnone	a8, a9, 4037fd63 <__assert_func+0x3b>
            file = CACHE_DISABLED_STR;
4037fd60:	d4b821        	l32r	a2, 40375040 <_iram_text_start+0xc3c> (3fc93ef4 <__func__$0+0x308>)
4037fd63:	d2a091        	l32r	a9, 403747e4 <_iram_text_start+0x3e0> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fd66:	729940        	salt	a9, a9, a4
4037fd69:	d29f81        	l32r	a8, 403747e8 <_iram_text_start+0x3e4> (3dffffff <_esp_system_init_fn_array_end+0x1fd6d5b>)
4037fd6c:	728840        	salt	a8, a8, a4
4037fd6f:	880b      	addi.n	a8, a8, -1
4037fd71:	608080        	neg	a8, a8
        }

        if (esp_ptr_in_drom(func)) {
4037fd74:	060897        	bnone	a8, a9, 4037fd7e <__assert_func+0x56>
            ra_to_str(addr);
4037fd77:	01ad      	mov.n	a10, a1
4037fd79:	fff7e5        	call8	4037fcf8 <ra_to_str>
            func = addr;
4037fd7c:	014d      	mov.n	a4, a1
4037fd7e:	d29991        	l32r	a9, 403747e4 <_iram_text_start+0x3e0> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
4037fd81:	729950        	salt	a9, a9, a5
4037fd84:	d29981        	l32r	a8, 403747e8 <_iram_text_start+0x3e4> (3dffffff <_esp_system_init_fn_array_end+0x1fd6d5b>)
4037fd87:	728850        	salt	a8, a8, a5
4037fd8a:	880b      	addi.n	a8, a8, -1
4037fd8c:	608080        	neg	a8, a8
        }

        if (esp_ptr_in_drom(expr)) {
4037fd8f:	020897        	bnone	a8, a9, 4037fd95 <__assert_func+0x6d>
            expr = CACHE_DISABLED_STR;
4037fd92:	d4ab51        	l32r	a5, 40375040 <_iram_text_start+0xc3c> (3fc93ef4 <__func__$0+0x308>)
        }
    }

    const char *str[] = {ASSERT_STR, func ? func : "\b", " ", file, ":", lbuf, " (", expr, ")"};
4037fd95:	d4ac81        	l32r	a8, 40375048 <_iram_text_start+0xc44> (3fc93f0c <__func__$0+0x320>)
4037fd98:	366182        	s32i	a8, a1, 216
4037fd9b:	14cc      	bnez.n	a4, 4037fda0 <__assert_func+0x78>
4037fd9d:	d4a941        	l32r	a4, 40375044 <_iram_text_start+0xc40> (3fc93f08 <__func__$0+0x31c>)
4037fda0:	d8a082        	movi	a8, 216
4037fda3:	818a      	add.n	a8, a1, a8
4037fda5:	1849      	s32i.n	a4, a8, 4
4037fda7:	d4a991        	l32r	a9, 4037504c <_iram_text_start+0xc48> (3fc93f1c <__func__$0+0x330>)
4037fdaa:	2899      	s32i.n	a9, a8, 8
4037fdac:	3829      	s32i.n	a2, a8, 12
4037fdae:	d4a891        	l32r	a9, 40375050 <_iram_text_start+0xc4c> (3fc93f20 <__func__$0+0x334>)
4037fdb1:	4899      	s32i.n	a9, a8, 16
4037fdb3:	d3a092        	movi	a9, 211
4037fdb6:	919a      	add.n	a9, a1, a9
4037fdb8:	5899      	s32i.n	a9, a8, 20
4037fdba:	d4a691        	l32r	a9, 40375054 <_iram_text_start+0xc50> (3fc93f24 <__func__$0+0x338>)
4037fdbd:	6899      	s32i.n	a9, a8, 24
4037fdbf:	7859      	s32i.n	a5, a8, 28
4037fdc1:	d4a591        	l32r	a9, 40375058 <_iram_text_start+0xc54> (3fc93f28 <__func__$0+0x33c>)
4037fdc4:	8899      	s32i.n	a9, a8, 32

    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fdc6:	060c      	movi.n	a6, 0
    uint32_t off = 0;
4037fdc8:	064d      	mov.n	a4, a6
    uint32_t rem_len = sizeof(buff) - 1;
4037fdca:	c7a052        	movi	a5, 199
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fdcd:	000b46        	j	4037fdfe <__assert_func+0xd6>
        uint32_t len = strlen(str[i]);
4037fdd0:	d8a082        	movi	a8, 216
4037fdd3:	818a      	add.n	a8, a1, a8
4037fdd5:	a08680        	addx4	a8, a6, a8
4037fdd8:	0838      	l32i.n	a3, a8, 0
4037fdda:	20a330        	or	a10, a3, a3
4037fddd:	d49f81        	l32r	a8, 4037505c <_iram_text_start+0xc58> (40001248 <strlen>)
4037fde0:	0008e0        	callx8	a8
        uint32_t cpy_len = MIN(len, rem_len);
4037fde3:	6375a0        	minu	a7, a5, a10
        memcpy(buff + off, str[i], cpy_len);
4037fde6:	07cd      	mov.n	a12, a7
4037fde8:	03bd      	mov.n	a11, a3
4037fdea:	a1bb      	addi.n	a10, a1, 11
4037fdec:	aa4a      	add.n	a10, a10, a4
4037fdee:	d1c481        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
4037fdf1:	0008e0        	callx8	a8
        rem_len -= cpy_len;
4037fdf4:	c05570        	sub	a5, a5, a7
        off += cpy_len;
4037fdf7:	447a      	add.n	a4, a4, a7
        if (rem_len == 0) {
4037fdf9:	758c      	beqz.n	a5, 4037fe04 <__assert_func+0xdc>
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037fdfb:	01c662        	addi	a6, a6, 1
4037fdfe:	08a082        	movi	a8, 8
4037fe01:	cbb867        	bgeu	a8, a6, 4037fdd0 <__assert_func+0xa8>
            break;
        }
    }
    buff[off] = '\0';
4037fe04:	a1bb      	addi.n	a10, a1, 11
4037fe06:	4a4a      	add.n	a4, a10, a4
4037fe08:	080c      	movi.n	a8, 0
4037fe0a:	004482        	s8i	a8, a4, 0
    esp_system_abort(buff);
4037fe0d:	f989a5        	call8	403796a8 <esp_system_abort>

4037fe10 <esp_libc_include_assert_impl>:
    __assert_func(file, line, NULL, failedexpr);
}

/* No-op function, used to force linker to include these changes */
void esp_libc_include_assert_impl(void)
{
4037fe10:	004136        	entry	a1, 32
}
4037fe13:	f01d      	retw.n
4037fe15:	000000        	ill

4037fe18 <esp_set_time_from_rtc>:
    _lock_release(&s_boot_time_lock);
    return result;
}

void esp_set_time_from_rtc(void)
{
4037fe18:	004136        	entry	a1, 32
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    // initialize time from RTC clock
    s_microseconds_offset = esp_rtc_get_time_us() - esp_system_get_time();
4037fe1b:	f80165        	call8	40377e30 <esp_rtc_get_time_us>
4037fe1e:	206aa0        	or	a6, a10, a10
4037fe21:	207bb0        	or	a7, a11, a11
4037fe24:	f53a65        	call8	403751cc <esp_system_get_time>
4037fe27:	c0b7b0        	sub	a11, a7, a11
4037fe2a:	02b6a7        	bgeu	a6, a10, 4037fe30 <esp_set_time_from_rtc+0x18>
4037fe2d:	ffcbb2        	addi	a11, a11, -1
4037fe30:	c066a0        	sub	a6, a6, a10
4037fe33:	d48b81        	l32r	a8, 40375060 <_iram_text_start+0xc5c> (3fc95358 <s_microseconds_offset>)
4037fe36:	0869      	s32i.n	a6, a8, 0
4037fe38:	18b9      	s32i.n	a11, a8, 4
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER && CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
}
4037fe3a:	f01d      	retw.n

4037fe3c <esp_time_impl_get_boot_time>:
{
4037fe3c:	004136        	entry	a1, 32
    _lock_acquire(&s_boot_time_lock);
4037fe3f:	d489a1        	l32r	a10, 40375064 <_iram_text_start+0xc60> (3fc95350 <s_boot_time_lock>)
4037fe42:	f6bfa5        	call8	40376a3c <_lock_acquire>
    result = ((uint64_t) REG_READ(RTC_BOOT_TIME_LOW_REG)) + (((uint64_t) REG_READ(RTC_BOOT_TIME_HIGH_REG)) << 32);
4037fe45:	d48881        	l32r	a8, 40375068 <_iram_text_start+0xc64> (60008058 <RTCCNTL+0x58>)
4037fe48:	0020c0        	memw
4037fe4b:	002822        	l32i	a2, a8, 0
4037fe4e:	d48781        	l32r	a8, 4037506c <_iram_text_start+0xc68> (6000805c <RTCCNTL+0x5c>)
4037fe51:	0020c0        	memw
4037fe54:	002832        	l32i	a3, a8, 0
    _lock_release(&s_boot_time_lock);
4037fe57:	d483a1        	l32r	a10, 40375064 <_iram_text_start+0xc60> (3fc95350 <s_boot_time_lock>)
4037fe5a:	f6c225        	call8	40376a7c <_lock_release>
}
4037fe5d:	f01d      	retw.n
	...

4037fe60 <esp_time_impl_set_boot_time>:
{
4037fe60:	004136        	entry	a1, 32
    _lock_acquire(&s_boot_time_lock);
4037fe63:	d480a1        	l32r	a10, 40375064 <_iram_text_start+0xc60> (3fc95350 <s_boot_time_lock>)
4037fe66:	f6bd65        	call8	40376a3c <_lock_acquire>
    REG_WRITE(RTC_BOOT_TIME_LOW_REG, (uint32_t)(time_us & 0xffffffff));
4037fe69:	d47f81        	l32r	a8, 40375068 <_iram_text_start+0xc64> (60008058 <RTCCNTL+0x58>)
4037fe6c:	0020c0        	memw
4037fe6f:	006822        	s32i	a2, a8, 0
    REG_WRITE(RTC_BOOT_TIME_HIGH_REG, (uint32_t)(time_us >> 32));
4037fe72:	d47e81        	l32r	a8, 4037506c <_iram_text_start+0xc68> (6000805c <RTCCNTL+0x5c>)
4037fe75:	0020c0        	memw
4037fe78:	006832        	s32i	a3, a8, 0
    _lock_release(&s_boot_time_lock);
4037fe7b:	d47aa1        	l32r	a10, 40375064 <_iram_text_start+0xc60> (3fc95350 <s_boot_time_lock>)
4037fe7e:	f6bfe5        	call8	40376a7c <_lock_release>
}
4037fe81:	f01d      	retw.n
	...

4037fe84 <malloc>:
extern void *heap_caps_malloc_default(size_t size);
extern void *heap_caps_realloc_default(void *ptr, size_t size);
extern void *heap_caps_aligned_alloc_default(size_t alignment, size_t size);

void* malloc(size_t size)
{
4037fe84:	004136        	entry	a1, 32
4037fe87:	02ad      	mov.n	a10, a2
    return heap_caps_malloc_default(size);
4037fe89:	f60665        	call8	40375ef0 <heap_caps_malloc_default>
}
4037fe8c:	0a2d      	mov.n	a2, a10
4037fe8e:	f01d      	retw.n

4037fe90 <cfree>:
{
    return heap_caps_realloc_default(ptr, size);
}

void free(void *ptr)
{
4037fe90:	004136        	entry	a1, 32
4037fe93:	02ad      	mov.n	a10, a2
    heap_caps_free(ptr);
4037fe95:	f629e5        	call8	40376134 <heap_caps_free>
}
4037fe98:	f01d      	retw.n
	...

4037fe9c <calloc>:

ESP_COMPILER_DIAGNOSTIC_PUSH_IGNORE("-Wanalyzer-malloc-leak")
void* calloc(size_t nmemb, size_t size)
{
4037fe9c:	004136        	entry	a1, 32
    void *result;
    size_t size_bytes;
    if (__builtin_mul_overflow(nmemb, size, &size_bytes)) {
4037fe9f:	080c      	movi.n	a8, 0
4037fea1:	827230        	mull	a7, a2, a3
4037fea4:	a22230        	muluh	a2, a2, a3
4037fea7:	001216        	beqz	a2, 4037feac <calloc+0x10>
4037feaa:	180c      	movi.n	a8, 1
4037feac:	48dc      	bnez.n	a8, 4037fec4 <calloc+0x28>
        return NULL;
    }

    result = heap_caps_malloc_default(size_bytes);
4037feae:	07ad      	mov.n	a10, a7
4037feb0:	f603e5        	call8	40375ef0 <heap_caps_malloc_default>
4037feb3:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
4037feb5:	00da16        	beqz	a10, 4037fec6 <calloc+0x2a>
        bzero(result, size_bytes);
4037feb8:	07bd      	mov.n	a11, a7
4037feba:	d46d81        	l32r	a8, 40375070 <_iram_text_start+0xc6c> (40001260 <bzero>)
4037febd:	0008e0        	callx8	a8
4037fec0:	000086        	j	4037fec6 <calloc+0x2a>
4037fec3:	020c00        	andb	b0, b12, b0
    }
    return result;
}
4037fec6:	f01d      	retw.n

4037fec8 <_free_r>:
ESP_COMPILER_DIAGNOSTIC_POP("-Wanalyzer-malloc-leak")

#if CONFIG_LIBC_NEWLIB
void _free_r(struct _reent *r, void* ptr)
{
4037fec8:	004136        	entry	a1, 32
4037fecb:	03ad      	mov.n	a10, a3
    heap_caps_free(ptr);
4037fecd:	f62665        	call8	40376134 <heap_caps_free>
}
4037fed0:	f01d      	retw.n
	...

4037fed4 <_realloc_r>:

void* _realloc_r(struct _reent *r, void* ptr, size_t size)
{
4037fed4:	004136        	entry	a1, 32
4037fed7:	20a330        	or	a10, a3, a3
4037feda:	20b440        	or	a11, a4, a4
    return heap_caps_realloc_default(ptr, size);
4037fedd:	f60a65        	call8	40375f84 <heap_caps_realloc_default>
}
4037fee0:	202aa0        	or	a2, a10, a10
4037fee3:	f01d      	retw.n
4037fee5:	000000        	ill

4037fee8 <_malloc_r>:

void* _malloc_r(struct _reent *r, size_t size)
{
4037fee8:	004136        	entry	a1, 32
4037feeb:	03ad      	mov.n	a10, a3
    return heap_caps_malloc_default(size);
4037feed:	f60025        	call8	40375ef0 <heap_caps_malloc_default>
}
4037fef0:	0a2d      	mov.n	a2, a10
4037fef2:	f01d      	retw.n

4037fef4 <_calloc_r>:

void* _calloc_r(struct _reent *r, size_t nmemb, size_t size)
{
4037fef4:	004136        	entry	a1, 32
4037fef7:	20a330        	or	a10, a3, a3
4037fefa:	20b440        	or	a11, a4, a4
    return calloc(nmemb, size);
4037fefd:	fff9e5        	call8	4037fe9c <calloc>
}
4037ff00:	202aa0        	or	a2, a10, a10
4037ff03:	f01d      	retw.n
4037ff05:	000000        	ill

4037ff08 <esp_libc_include_heap_impl>:

/* No-op function, used to force linking this file,
   instead of the heap implementation from newlib.
 */
void esp_libc_include_heap_impl(void)
{
4037ff08:	004136        	entry	a1, 32
}
4037ff0b:	f01d      	retw.n
4037ff0d:	000000        	ill

4037ff10 <__atomic_fetch_or_8>:
#define _ATOMIC_HW_STUB_SYNC_LOCK_RELEASE(n, type)
#endif // CONFIG_STDATOMIC_S32C1I_SPIRAM_WORKAROUND

_Static_assert(sizeof(long long unsigned int) == 8, "atomics require a 8-bytes type");

ATOMIC_FUNCTIONS(8, long long unsigned int)
4037ff10:	004136        	entry	a1, 32
4037ff13:	207220        	or	a7, a2, a2
    if (xPortInIsrContext()) {
4037ff16:	fa0da5        	call8	40379ff0 <xPortInIsrContext>
4037ff19:	00ca16        	beqz	a10, 4037ff29 <__atomic_fetch_or_8+0x19>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037ff1c:	ffafb2        	movi	a11, -1
4037ff1f:	d455a1        	l32r	a10, 40375074 <_iram_text_start+0xc70> (3fc92a98 <s_atomic_lock>)
4037ff22:	fa0f25        	call8	4037a014 <xPortEnterCriticalTimeout>
4037ff25:	000246        	j	4037ff32 <__atomic_fetch_or_8+0x22>
4037ff28:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4037ff29:	ffafb2        	movi	a11, -1
4037ff2c:	d452a1        	l32r	a10, 40375074 <_iram_text_start+0xc70> (3fc92a98 <s_atomic_lock>)
4037ff2f:	fa0e65        	call8	4037a014 <xPortEnterCriticalTimeout>
4037ff32:	0020c0        	memw
4037ff35:	0728      	l32i.n	a2, a7, 0
4037ff37:	0020c0        	memw
4037ff3a:	1738      	l32i.n	a3, a7, 4
4037ff3c:	208240        	or	a8, a2, a4
4037ff3f:	209350        	or	a9, a3, a5
4037ff42:	0020c0        	memw
4037ff45:	0789      	s32i.n	a8, a7, 0
4037ff47:	0020c0        	memw
4037ff4a:	016792        	s32i	a9, a7, 4
    if (xPortInIsrContext()) {
4037ff4d:	fa0a25        	call8	40379ff0 <xPortInIsrContext>
4037ff50:	8a8c      	beqz.n	a10, 4037ff5c <__atomic_fetch_or_8+0x4c>
        portEXIT_CRITICAL_ISR(mux);
4037ff52:	d448a1        	l32r	a10, 40375074 <_iram_text_start+0xc70> (3fc92a98 <s_atomic_lock>)
4037ff55:	fa20e5        	call8	4037a164 <vPortExitCritical>
4037ff58:	000186        	j	4037ff62 <__atomic_fetch_or_8+0x52>
4037ff5b:	46a100        	ee.ldf.64.xp	f10, f4, a0, a1
        portEXIT_CRITICAL(mux);
4037ff5e:	d4          	.byte	0xd4
4037ff5f:	fa2065        	call8	4037a164 <vPortExitCritical>
4037ff62:	f01d      	retw.n

4037ff64 <check_chip_pointer_default>:
{
4037ff64:	004136        	entry	a1, 32
    esp_flash_t *chip = *inout_chip;
4037ff67:	0022a2        	l32i	a10, a2, 0
    if (chip == NULL) {
4037ff6a:	009a56        	bnez	a10, 4037ff77 <check_chip_pointer_default+0x13>
        chip = esp_flash_default_chip;
4037ff6d:	d44281        	l32r	a8, 40375078 <_iram_text_start+0xc74> (3fc953c4 <esp_flash_default_chip>)
4037ff70:	0028a2        	l32i	a10, a8, 0
    *inout_chip = chip;
4037ff73:	02a9      	s32i.n	a10, a2, 0
    if (chip == NULL || !esp_flash_chip_driver_initialized(chip)) {
4037ff75:	3a8c      	beqz.n	a10, 4037ff7c <check_chip_pointer_default+0x18>
4037ff77:	000a25        	call8	40380018 <esp_flash_chip_driver_initialized>
4037ff7a:	4acc      	bnez.n	a10, 4037ff82 <check_chip_pointer_default+0x1e>
        return ESP_ERR_FLASH_NOT_INITIALISED;
4037ff7c:	d23821        	l32r	a2, 4037485c <_iram_text_start+0x458> (6003 <UserFrameTotalSize+0x5f03>)
4037ff7f:	000046        	j	4037ff84 <check_chip_pointer_default+0x20>
    return ESP_OK;
4037ff82:	020c      	movi.n	a2, 0
}
4037ff84:	f01d      	retw.n
	...

4037ff88 <detect_spi_flash_chip>:

    return read_unique_id(chip, out_uid);
}

static esp_err_t detect_spi_flash_chip(esp_flash_t *chip)
{
4037ff88:	004136        	entry	a1, 32
4037ff8b:	027d      	mov.n	a7, a2
    esp_err_t err;
    uint32_t flash_id = chip->chip_id;
4037ff8d:	6258      	l32i.n	a5, a2, 24

    // Detect the chip and set the chip_drv structure for it
    const spi_flash_chip_t **drivers = esp_flash_registered_chips;
4037ff8f:	d43b81        	l32r	a8, 4037507c <_iram_text_start+0xc78> (3fc92a54 <esp_flash_registered_chips>)
4037ff92:	0868      	l32i.n	a6, a8, 0
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
4037ff94:	000f06        	j	4037ffd4 <detect_spi_flash_chip+0x4c>
4037ff97:	172900        	ee.stf.64.xp	f2, f1, a0, a9
        chip->chip_drv = *drivers;
        // start/end SPI operation each time, for multitasking
        // and also so esp_flash_registered_flash_drivers can live in flash
        ESP_EARLY_LOGD(TAG, "trying chip: %s", chip->chip_drv->name);

        err = rom_spiflash_api_funcs->start(chip);
4037ff9a:	d23181        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
4037ff9d:	0888      	l32i.n	a8, a8, 0
4037ff9f:	0888      	l32i.n	a8, a8, 0
4037ffa1:	07ad      	mov.n	a10, a7
4037ffa3:	0008e0        	callx8	a8
4037ffa6:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
4037ffa8:	068a56        	bnez	a10, 40380014 <detect_spi_flash_chip+0x8c>
            return err;
        }

        if (chip->chip_drv->probe(chip, flash_id) != ESP_OK) {
4037ffab:	1788      	l32i.n	a8, a7, 4
4037ffad:	2888      	l32i.n	a8, a8, 8
4037ffaf:	05bd      	mov.n	a11, a5
4037ffb1:	07ad      	mov.n	a10, a7
4037ffb3:	0008e0        	callx8	a8
4037ffb6:	2a8c      	beqz.n	a10, 4037ffbc <detect_spi_flash_chip+0x34>
            chip->chip_drv = NULL;
4037ffb8:	080c      	movi.n	a8, 0
4037ffba:	1789      	s32i.n	a8, a7, 4
        }
        // if probe succeeded, chip->drv stays set
        drivers++;
4037ffbc:	04c662        	addi	a6, a6, 4

        err = rom_spiflash_api_funcs->end(chip, err);
4037ffbf:	d22881        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
4037ffc2:	002882        	l32i	a8, a8, 0
4037ffc5:	012882        	l32i	a8, a8, 4
4037ffc8:	02bd      	mov.n	a11, a2
4037ffca:	07ad      	mov.n	a10, a7
4037ffcc:	0008e0        	callx8	a8
4037ffcf:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
4037ffd1:	03fa56        	bnez	a10, 40380014 <detect_spi_flash_chip+0x8c>
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
4037ffd4:	0628      	l32i.n	a2, a6, 0
4037ffd6:	628c      	beqz.n	a2, 4037ffe0 <detect_spi_flash_chip+0x58>
4037ffd8:	07ad      	mov.n	a10, a7
4037ffda:	0003e5        	call8	40380018 <esp_flash_chip_driver_initialized>
4037ffdd:	fb7a16        	beqz	a10, 4037ff98 <detect_spi_flash_chip+0x10>
            return err;
        }
    }
    if (!esp_flash_chip_driver_initialized(chip)) {
4037ffe0:	20a770        	or	a10, a7, a7
4037ffe3:	000365        	call8	40380018 <esp_flash_chip_driver_initialized>
4037ffe6:	022a16        	beqz	a10, 4038000c <detect_spi_flash_chip+0x84>
4037ffe9:	d12581        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
4037ffec:	0888      	l32i.n	a8, a8, 0
        return ESP_ERR_NOT_FOUND;
    }
    ESP_EARLY_LOGI(TAG, "detected chip: %s", chip->chip_drv->name);
4037ffee:	2038b6        	bltui	a8, 3, 40380012 <detect_spi_flash_chip+0x8a>
4037fff1:	ffc125        	call8	4037fc04 <esp_log_timestamp>
4037fff4:	1788      	l32i.n	a8, a7, 4
4037fff6:	08d8      	l32i.n	a13, a8, 0
4037fff8:	d422c1        	l32r	a12, 40375080 <_iram_text_start+0xc7c> (3fc9398c <TAG>)
4037fffb:	0abd      	mov.n	a11, a10
4037fffd:	d421a1        	l32r	a10, 40375084 <_iram_text_start+0xc80> (3c0253a4 <_flash_rodata_start+0x5284>)
40380000:	d13781        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40380003:	0008e0        	callx8	a8
    return ESP_OK;
40380006:	020c      	movi.n	a2, 0
40380008:	000206        	j	40380014 <detect_spi_flash_chip+0x8c>
4038000b:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
4038000e:	004605        	call0	40380470 <memspi_host_erase_block+0x2c>
40380011:	020c00        	andb	b0, b12, b0
}
40380014:	f01d      	retw.n
	...

40380018 <esp_flash_chip_driver_initialized>:
{
40380018:	004136        	entry	a1, 32
    if (!chip->chip_drv) return false;
4038001b:	1288      	l32i.n	a8, a2, 4
4038001d:	388c      	beqz.n	a8, 40380024 <esp_flash_chip_driver_initialized+0xc>
    return true;
4038001f:	120c      	movi.n	a2, 1
40380021:	000046        	j	40380026 <esp_flash_chip_driver_initialized+0xe>
    if (!chip->chip_drv) return false;
40380024:	020c      	movi.n	a2, 0
}
40380026:	f01d      	retw.n

40380028 <esp_flash_get_physical_size>:

esp_err_t esp_flash_get_physical_size(esp_flash_t *chip, uint32_t *flash_size)
{
40380028:	008136        	entry	a1, 64
4038002b:	4129      	s32i.n	a2, a1, 16
    esp_err_t err = rom_spiflash_api_funcs->chip_check(&chip);
4038002d:	d20c81        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
40380030:	0888      	l32i.n	a8, a8, 0
40380032:	2888      	l32i.n	a8, a8, 8
40380034:	10c1a2        	addi	a10, a1, 16
40380037:	0008e0        	callx8	a8
4038003a:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4038003c:	054a56        	bnez	a10, 40380094 <esp_flash_get_physical_size+0x6c>
        return err;
    }
    VERIFY_CHIP_OP(detect_size);
4038003f:	41a8      	l32i.n	a10, a1, 16
40380041:	1a88      	l32i.n	a8, a10, 4
40380043:	4888      	l32i.n	a8, a8, 16
40380045:	040816        	beqz	a8, 40380089 <esp_flash_get_physical_size+0x61>
    if (flash_size == NULL) {
40380048:	045316        	beqz	a3, 40380091 <esp_flash_get_physical_size+0x69>
        return ESP_ERR_INVALID_ARG;
    }

    err = rom_spiflash_api_funcs->start(chip);
4038004b:	d20581        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
4038004e:	0888      	l32i.n	a8, a8, 0
40380050:	002882        	l32i	a8, a8, 0
40380053:	0008e0        	callx8	a8
40380056:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40380058:	8afc      	bnez.n	a10, 40380094 <esp_flash_get_physical_size+0x6c>
        return err;
    }
    uint32_t detect_size;
    err = chip->chip_drv->detect_size(chip, &detect_size);
4038005a:	41a8      	l32i.n	a10, a1, 16
4038005c:	1a88      	l32i.n	a8, a10, 4
4038005e:	4888      	l32i.n	a8, a8, 16
40380060:	20b110        	or	a11, a1, a1
40380063:	0008e0        	callx8	a8
40380066:	0abd      	mov.n	a11, a10
    if (err == ESP_OK) {
40380068:	cacc      	bnez.n	a10, 40380078 <esp_flash_get_physical_size+0x50>
        if (chip->size == 0) {
4038006a:	4188      	l32i.n	a8, a1, 16
4038006c:	5898      	l32i.n	a9, a8, 20
4038006e:	29cc      	bnez.n	a9, 40380074 <esp_flash_get_physical_size+0x4c>
            // chip->size will not be changed if detected, it will always be equal to configured flash size.
            chip->size = detect_size;
40380070:	0198      	l32i.n	a9, a1, 0
40380072:	5899      	s32i.n	a9, a8, 20
        }
        *flash_size = detect_size;
40380074:	0188      	l32i.n	a8, a1, 0
40380076:	0389      	s32i.n	a8, a3, 0
    }
    return rom_spiflash_api_funcs->end(chip, err);
40380078:	d1fa81        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
4038007b:	0888      	l32i.n	a8, a8, 0
4038007d:	1888      	l32i.n	a8, a8, 4
4038007f:	41a8      	l32i.n	a10, a1, 16
40380081:	0008e0        	callx8	a8
40380084:	0a2d      	mov.n	a2, a10
40380086:	000286        	j	40380094 <esp_flash_get_physical_size+0x6c>
    VERIFY_CHIP_OP(detect_size);
40380089:	d3ff21        	l32r	a2, 40375088 <_iram_text_start+0xc84> (6005 <UserFrameTotalSize+0x5f05>)
4038008c:	000106        	j	40380094 <esp_flash_get_physical_size+0x6c>
4038008f:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
40380092:	1d02a1        	l32r	a10, 4034749c <rom_rx_gain_force+0x341070>
}
40380095:	0000f0        	callx12	a0

40380098 <esp_flash_init_main>:
{
40380098:	006136        	entry	a1, 48
4038009b:	027d      	mov.n	a7, a2
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
4038009d:	14b216        	beqz	a2, 403801ec <esp_flash_init_main+0x154>
403800a0:	0288      	l32i.n	a8, a2, 0
403800a2:	14e816        	beqz	a8, 403801f4 <esp_flash_init_main+0x15c>
403800a5:	0898      	l32i.n	a9, a8, 0
403800a7:	14f916        	beqz	a9, 403801fa <esp_flash_init_main+0x162>
        ((memspi_host_inst_t*)chip->host)->spi == NULL) {
403800aa:	1888      	l32i.n	a8, a8, 4
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
403800ac:	151816        	beqz	a8, 40380201 <esp_flash_init_main+0x169>
    octal_mode = (chip->read_mode >= SPI_FLASH_OPI_FLAG);
403800af:	4258      	l32i.n	a5, a2, 16
    uint32_t flash_id = 0;
403800b1:	080c      	movi.n	a8, 0
403800b3:	0189      	s32i.n	a8, a1, 0
    if (octal_mode) {
403800b5:	f80c      	movi.n	a8, 15
403800b7:	0bb857        	bgeu	a8, a5, 403800c6 <esp_flash_init_main+0x2e>
        flash_id = g_rom_flashchip.device_id;
403800ba:	d1c081        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
403800bd:	0888      	l32i.n	a8, a8, 0
403800bf:	0888      	l32i.n	a8, a8, 0
403800c1:	0189      	s32i.n	a8, a1, 0
    if (err != ESP_OK) {
403800c3:	000846        	j	403800e8 <esp_flash_init_main+0x50>
        int retries = 10;
403800c6:	a60c      	movi.n	a6, 10
403800c8:	000086        	j	403800ce <esp_flash_init_main+0x36>
403800cb:	086d00        	lsx	f6, a13, a0
            err = esp_flash_read_chip_id(chip, &flash_id);
403800ce:	01bd      	mov.n	a11, a1
403800d0:	07ad      	mov.n	a10, a7
403800d2:	d3f381        	l32r	a8, 403750a0 <_iram_text_start+0xc9c> (42019680 <esp_flash_read_chip_id>)
403800d5:	0008e0        	callx8	a8
403800d8:	0a2d      	mov.n	a2, a10
        } while (err == ESP_ERR_FLASH_NOT_INITIALISED && retries-- > 0);
403800da:	d1e081        	l32r	a8, 4037485c <_iram_text_start+0x458> (6003 <UserFrameTotalSize+0x5f03>)
403800dd:	049a87        	bne	a10, a8, 403800e5 <esp_flash_init_main+0x4d>
403800e0:	860b      	addi.n	a8, a6, -1
403800e2:	e616e6        	bgei	a6, 1, 403800cc <esp_flash_init_main+0x34>
    if (err != ESP_OK) {
403800e5:	11b256        	bnez	a2, 40380204 <esp_flash_init_main+0x16c>
    chip->chip_id = flash_id;
403800e8:	0188      	l32i.n	a8, a1, 0
403800ea:	6789      	s32i.n	a8, a7, 24
    if (!esp_flash_chip_driver_initialized(chip)) {
403800ec:	07ad      	mov.n	a10, a7
403800ee:	fff2a5        	call8	40380018 <esp_flash_chip_driver_initialized>
403800f1:	9acc      	bnez.n	a10, 403800fe <esp_flash_init_main+0x66>
        err = detect_spi_flash_chip(chip);
403800f3:	07ad      	mov.n	a10, a7
403800f5:	ffe925        	call8	4037ff88 <detect_spi_flash_chip>
403800f8:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
403800fb:	105a56        	bnez	a10, 40380204 <esp_flash_init_main+0x16c>
    err = esp_flash_get_physical_size(chip, &size);
403800fe:	04c1b2        	addi	a11, a1, 4
40380101:	20a770        	or	a10, a7, a7
40380104:	fff225        	call8	40380028 <esp_flash_get_physical_size>
40380107:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40380109:	01ca16        	beqz	a10, 40380129 <esp_flash_init_main+0x91>
4038010c:	d0dd81        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
4038010f:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "failed to get chip size");
40380112:	0ee816        	beqz	a8, 40380204 <esp_flash_init_main+0x16c>
40380115:	ffaee5        	call8	4037fc04 <esp_log_timestamp>
40380118:	d3dac1        	l32r	a12, 40375080 <_iram_text_start+0xc7c> (3fc9398c <TAG>)
4038011b:	0abd      	mov.n	a11, a10
4038011d:	d3dba1        	l32r	a10, 4037508c <_iram_text_start+0xc88> (3c025440 <_flash_rodata_start+0x5320>)
40380120:	d0ef81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40380123:	0008e0        	callx8	a8
        return err;
40380126:	003686        	j	40380204 <esp_flash_init_main+0x16c>
    if (chip->chip_drv->get_chip_caps == NULL) {
40380129:	1788      	l32i.n	a8, a7, 4
4038012b:	1d2882        	l32i	a8, a8, 116
4038012e:	01c856        	bnez	a8, 4038014e <esp_flash_init_main+0xb6>
40380131:	d0d381        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40380134:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGW(TAG, "get_chip_caps function pointer hasn't been initialized");
40380136:	4328b6        	bltui	a8, 2, 4038017d <esp_flash_init_main+0xe5>
40380139:	ffaca5        	call8	4037fc04 <esp_log_timestamp>
4038013c:	d3d1c1        	l32r	a12, 40375080 <_iram_text_start+0xc7c> (3fc9398c <TAG>)
4038013f:	0abd      	mov.n	a11, a10
40380141:	d3d3a1        	l32r	a10, 40375090 <_iram_text_start+0xc8c> (3c0253c4 <_flash_rodata_start+0x52a4>)
40380144:	d0e681        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40380147:	0008e0        	callx8	a8
4038014a:	000bc6        	j	4038017d <esp_flash_init_main+0xe5>
4038014d:	07ad00        	ee.stf.64.xp	f10, f0, a0, a13
        if (((chip->chip_drv->get_chip_caps(chip) & SPI_FLASH_CHIP_CAP_32MB_SUPPORT) == 0) && (size > (16 *1024 * 1024))) {
40380150:	0008e0        	callx8	a8
40380153:	26ea17        	bbsi	a10, 1, 4038017d <esp_flash_init_main+0xe5>
40380156:	1188      	l32i.n	a8, a1, 4
40380158:	d37291        	l32r	a9, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4038015b:	1eb987        	bgeu	a9, a8, 4038017d <esp_flash_init_main+0xe5>
4038015e:	d0c881        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40380161:	0888      	l32i.n	a8, a8, 0
            ESP_EARLY_LOGW(TAG, "Detected flash size > 16 MB, but access beyond 16 MB is not supported for this flash model yet.");
40380163:	1128b6        	bltui	a8, 2, 40380178 <esp_flash_init_main+0xe0>
40380166:	ffa9e5        	call8	4037fc04 <esp_log_timestamp>
40380169:	d3c5c1        	l32r	a12, 40375080 <_iram_text_start+0xc7c> (3fc9398c <TAG>)
4038016c:	20baa0        	or	a11, a10, a10
4038016f:	d3c9a1        	l32r	a10, 40375094 <_iram_text_start+0xc90> (3c025468 <_flash_rodata_start+0x5348>)
40380172:	d0da81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40380175:	0008e0        	callx8	a8
            size = (16 * 1024 * 1024);
40380178:	d36a81        	l32r	a8, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4038017b:	1189      	s32i.n	a8, a1, 4
4038017d:	d0c081        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40380180:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "flash io: %s", io_mode_str[chip->read_mode]);
40380182:	1b38b6        	bltui	a8, 3, 403801a1 <esp_flash_init_main+0x109>
40380185:	ffa7e5        	call8	4037fc04 <esp_log_timestamp>
40380188:	47d8      	l32i.n	a13, a7, 16
4038018a:	a0ddd0        	addx4	a13, a13, a13
4038018d:	d3c281        	l32r	a8, 40375098 <_iram_text_start+0xc94> (3c0279c0 <io_mode_str>)
40380190:	90dd80        	addx2	a13, a13, a8
40380193:	d3bbc1        	l32r	a12, 40375080 <_iram_text_start+0xc7c> (3fc9398c <TAG>)
40380196:	0abd      	mov.n	a11, a10
40380198:	d3c1a1        	l32r	a10, 4037509c <_iram_text_start+0xc98> (3c0254d8 <_flash_rodata_start+0x53b8>)
4038019b:	d0d081        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
4038019e:	0008e0        	callx8	a8
    err = rom_spiflash_api_funcs->start(chip);
403801a1:	d1af81        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
403801a4:	0888      	l32i.n	a8, a8, 0
403801a6:	0888      	l32i.n	a8, a8, 0
403801a8:	07ad      	mov.n	a10, a7
403801aa:	0008e0        	callx8	a8
403801ad:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
403801af:	051a56        	bnez	a10, 40380204 <esp_flash_init_main+0x16c>
    if (err == ESP_OK && !octal_mode) {
403801b2:	f80c      	movi.n	a8, 15
403801b4:	203857        	bltu	a8, a5, 403801d8 <esp_flash_init_main+0x140>
        err = chip->chip_drv->set_io_mode(chip);
403801b7:	1788      	l32i.n	a8, a7, 4
403801b9:	162882        	l32i	a8, a8, 88
403801bc:	07ad      	mov.n	a10, a7
403801be:	0008e0        	callx8	a8
        if (err == ESP_ERR_FLASH_NO_RESPONSE && !esp_flash_is_quad_mode(chip)) {
403801c1:	08a182        	movi	a8, 0x108
403801c4:	0e9a87        	bne	a10, a8, 403801d6 <esp_flash_init_main+0x13e>
 *
 * @return true if flash works in quad mode, otherwise false
 */
static inline bool esp_flash_is_quad_mode(const esp_flash_t *chip)
{
    return (chip->read_mode == SPI_FLASH_QIO) || (chip->read_mode == SPI_FLASH_QOUT);
403801c7:	4788      	l32i.n	a8, a7, 16
403801c9:	fcc882        	addi	a8, a8, -4
403801cc:	0828f6        	bgeui	a8, 2, 403801d8 <esp_flash_init_main+0x140>
        err = chip->chip_drv->set_io_mode(chip);
403801cf:	0a2d      	mov.n	a2, a10
403801d1:	0000c6        	j	403801d8 <esp_flash_init_main+0x140>
403801d4:	00          	.byte	00
403801d5:	0a2d00        	add.s	f2, f13, f0
    return rom_spiflash_api_funcs->end(chip, err);
403801d8:	d1a281        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
403801db:	0888      	l32i.n	a8, a8, 0
403801dd:	1888      	l32i.n	a8, a8, 4
403801df:	02bd      	mov.n	a11, a2
403801e1:	07ad      	mov.n	a10, a7
403801e3:	0008e0        	callx8	a8
403801e6:	0a2d      	mov.n	a2, a10
403801e8:	000606        	j	40380204 <esp_flash_init_main+0x16c>
403801eb:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
403801ee:	044602        	s8i	a0, a6, 4
403801f1:	000000        	ill
403801f4:	02a122        	movi	a2, 0x102
403801f7:	000246        	j	40380204 <esp_flash_init_main+0x16c>
403801fa:	02a122        	movi	a2, 0x102
403801fd:	0000c6        	j	40380204 <esp_flash_init_main+0x16c>
40380200:	a12200        	sll	a2, a2
40380203:	f01d02        	l16ui	a0, a13, 0x1e0
	...

40380208 <flash_end_flush_cache>:
{
40380208:	004136        	entry	a1, 32
4038020b:	744040        	extui	a4, a4, 0, 8
    if (!bus_acquired) {
4038020e:	64dc      	bnez.n	a4, 40380228 <flash_end_flush_cache+0x20>
        esp_err_t acquire_err = rom_spiflash_api_funcs->start(chip);
40380210:	d19481        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
40380213:	0888      	l32i.n	a8, a8, 0
40380215:	0888      	l32i.n	a8, a8, 0
40380217:	02ad      	mov.n	a10, a2
40380219:	0008e0        	callx8	a8
        if (acquire_err != ESP_OK) {
4038021c:	8a8c      	beqz.n	a10, 40380228 <flash_end_flush_cache+0x20>
            return (err == ESP_OK)? acquire_err: err;
4038021e:	03cc      	bnez.n	a3, 40380222 <flash_end_flush_cache+0x1a>
40380220:	0a3d      	mov.n	a3, a10
40380222:	032d      	mov.n	a2, a3
40380224:	000906        	j	4038024c <flash_end_flush_cache+0x44>
40380227:	02a800        	andb	b10, b8, b0
    if (chip->host->driver->flush_cache) {
4038022a:	0a88      	l32i.n	a8, a10, 0
4038022c:	112882        	l32i	a8, a8, 68
4038022f:	988c      	beqz.n	a8, 4038023c <flash_end_flush_cache+0x34>
        esp_err_t flush_err = chip->host->driver->flush_cache(chip->host, address, length);
40380231:	06cd      	mov.n	a12, a6
40380233:	05bd      	mov.n	a11, a5
40380235:	0008e0        	callx8	a8
        if (err == ESP_OK) {
40380238:	03cc      	bnez.n	a3, 4038023c <flash_end_flush_cache+0x34>
            err = flush_err;
4038023a:	0a3d      	mov.n	a3, a10
    return rom_spiflash_api_funcs->end(chip, err);
4038023c:	d18981        	l32r	a8, 40374860 <_iram_text_start+0x45c> (3fc93978 <rom_spiflash_api_funcs>)
4038023f:	0888      	l32i.n	a8, a8, 0
40380241:	1888      	l32i.n	a8, a8, 4
40380243:	03bd      	mov.n	a11, a3
40380245:	02ad      	mov.n	a10, a2
40380247:	0008e0        	callx8	a8
4038024a:	0a2d      	mov.n	a2, a10
}
4038024c:	f01d      	retw.n
	...

40380250 <spiflash_end_default>:
{
40380250:	004136        	entry	a1, 32
40380253:	028d      	mov.n	a8, a2
40380255:	032d      	mov.n	a2, a3
    if (chip->os_func != NULL
40380257:	2898      	l32i.n	a9, a8, 8
40380259:	b98c      	beqz.n	a9, 40380268 <spiflash_end_default+0x18>
        && chip->os_func->end != NULL) {
4038025b:	1998      	l32i.n	a9, a9, 4
4038025d:	798c      	beqz.n	a9, 40380268 <spiflash_end_default+0x18>
        esp_err_t end_err = chip->os_func->end(chip->os_func_data);
4038025f:	38a8      	l32i.n	a10, a8, 12
40380261:	0009e0        	callx8	a9
        if (err == ESP_OK) {
40380264:	03cc      	bnez.n	a3, 40380268 <spiflash_end_default+0x18>
            err = end_err; // Only return the 'end' error if we haven't already failed
40380266:	0a2d      	mov.n	a2, a10
}
40380268:	f01d      	retw.n
	...

4038026c <spiflash_start_default>:
{
4038026c:	004136        	entry	a1, 32
4038026f:	027d      	mov.n	a7, a2
    if (chip->os_func != NULL && chip->os_func->start != NULL) {
40380271:	2288      	l32i.n	a8, a2, 8
40380273:	b88c      	beqz.n	a8, 40380282 <spiflash_start_default+0x16>
40380275:	0888      	l32i.n	a8, a8, 0
40380277:	788c      	beqz.n	a8, 40380282 <spiflash_start_default+0x16>
        esp_err_t err = chip->os_func->start(chip->os_func_data);
40380279:	32a8      	l32i.n	a10, a2, 12
4038027b:	0008e0        	callx8	a8
4038027e:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380280:	aacc      	bnez.n	a10, 4038028e <spiflash_start_default+0x22>
    chip->host->driver->dev_config(chip->host);
40380282:	07a8      	l32i.n	a10, a7, 0
40380284:	002a82        	l32i	a8, a10, 0
40380287:	0888      	l32i.n	a8, a8, 0
40380289:	0008e0        	callx8	a8
    return ESP_OK;
4038028c:	020c      	movi.n	a2, 0
}
4038028e:	f01d      	retw.n

40380290 <spi_flash_needs_reset_check>:
static bool flash_brownout_needs_reset = false;
static bool flash_erasing = false;

// This function could be called in startup
void spi_flash_needs_reset_check(void)
{
40380290:	004136        	entry	a1, 32
    // Currently only XMC is suggested to reset when brownout
#if CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC
    if ((g_rom_flashchip.device_id >> 16) == 0x20) {
40380293:	d14a81        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40380296:	0888      	l32i.n	a8, a8, 0
40380298:	011882        	l16ui	a8, a8, 2
4038029b:	07c866        	bnei	a8, 32, 403802a6 <spi_flash_needs_reset_check+0x16>
        flash_brownout_needs_reset = true;
4038029e:	d38181        	l32r	a8, 403750a4 <_iram_text_start+0xca0> (3fc953b1 <flash_brownout_needs_reset>)
403802a1:	190c      	movi.n	a9, 1
403802a3:	004892        	s8i	a9, a8, 0
    }
#endif
}
403802a6:	f01d      	retw.n

403802a8 <spi_flash_set_erasing_flag>:

void spi_flash_set_erasing_flag(bool status)
{
403802a8:	004136        	entry	a1, 32
    flash_erasing = status;
403802ab:	d37f81        	l32r	a8, 403750a8 <_iram_text_start+0xca4> (3fc953b0 <flash_erasing>)
403802ae:	004822        	s8i	a2, a8, 0
}
403802b1:	f01d      	retw.n
	...

403802b4 <spi_flash_brownout_need_reset>:

bool spi_flash_brownout_need_reset(void)
{
403802b4:	004136        	entry	a1, 32
    return (flash_brownout_needs_reset && flash_erasing);
403802b7:	d37b81        	l32r	a8, 403750a4 <_iram_text_start+0xca0> (3fc953b1 <flash_brownout_needs_reset>)
403802ba:	000882        	l8ui	a8, a8, 0
403802bd:	b88c      	beqz.n	a8, 403802cc <spi_flash_brownout_need_reset+0x18>
403802bf:	d37a81        	l32r	a8, 403750a8 <_iram_text_start+0xca4> (3fc953b0 <flash_erasing>)
403802c2:	000882        	l8ui	a8, a8, 0
403802c5:	88cc      	bnez.n	a8, 403802d1 <spi_flash_brownout_need_reset+0x1d>
403802c7:	020c      	movi.n	a2, 0
403802c9:	000186        	j	403802d3 <spi_flash_brownout_need_reset+0x1f>
403802cc:	020c      	movi.n	a2, 0
403802ce:	000046        	j	403802d3 <spi_flash_brownout_need_reset+0x1f>
403802d1:	120c      	movi.n	a2, 1
}
403802d3:	f01d      	retw.n
403802d5:	000000        	ill

403802d8 <memspi_host_read_status_hs>:
    ESP_EARLY_LOGV(TAG, "chip_id: %X\n", *id);
    return ESP_OK;
}

esp_err_t memspi_host_read_status_hs(spi_flash_host_inst_t *host, uint8_t *out_sr)
{
403802d8:	008136        	entry	a1, 64
    //NOTE: we do have a read id function, however it doesn't work in high freq
    uint32_t stat_buf = 0;
403802db:	0b0c      	movi.n	a11, 0
403802dd:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
403802df:	714b      	addi.n	a7, a1, 4
403802e1:	cc1c      	movi.n	a12, 28
403802e3:	20a770        	or	a10, a7, a7
403802e6:	d07481        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403802e9:	0008e0        	callx8	a8
403802ec:	180c      	movi.n	a8, 1
403802ee:	064182        	s8i	a8, a1, 6
403802f1:	4119      	s32i.n	a1, a1, 16
403802f3:	580c      	movi.n	a8, 5
403802f5:	0c5182        	s16i	a8, a1, 24
        .command = CMD_RDSR,
        .miso_data = ((uint8_t*) &stat_buf),
        .miso_len = 1
    };
    esp_err_t err = host->driver->common_command(host, &t);
403802f8:	0288      	l32i.n	a8, a2, 0
403802fa:	1888      	l32i.n	a8, a8, 4
403802fc:	07bd      	mov.n	a11, a7
403802fe:	20a220        	or	a10, a2, a2
40380301:	0008e0        	callx8	a8
40380304:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40380306:	3acc      	bnez.n	a10, 4038030d <memspi_host_read_status_hs+0x35>
        return err;
    }
    *out_sr = stat_buf;
40380308:	0188      	l32i.n	a8, a1, 0
4038030a:	004382        	s8i	a8, a3, 0
    return ESP_OK;
}
4038030d:	f01d      	retw.n
	...

40380310 <memspi_host_erase_chip>:
    }
    return ESP_OK;
}

void memspi_host_erase_chip(spi_flash_host_inst_t *host)
{
40380310:	008136        	entry	a1, 64
    spi_flash_trans_t t = { 0 };
40380313:	cc1c      	movi.n	a12, 28
40380315:	0b0c      	movi.n	a11, 0
40380317:	20a110        	or	a10, a1, a1
4038031a:	d06781        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4038031d:	0008e0        	callx8	a8
    t.command = CMD_CHIP_ERASE;
40380320:	c7a082        	movi	a8, 199
40380323:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380326:	0288      	l32i.n	a8, a2, 0
40380328:	1888      	l32i.n	a8, a8, 4
4038032a:	01bd      	mov.n	a11, a1
4038032c:	02ad      	mov.n	a10, a2
4038032e:	0008e0        	callx8	a8
}
40380331:	f01d      	retw.n
	...

40380334 <memspi_host_set_write_protect>:
    host->driver->common_command(host, &t);
    return ESP_OK;
}

esp_err_t memspi_host_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
40380334:	008136        	entry	a1, 64
40380337:	743030        	extui	a3, a3, 0, 8
    spi_flash_trans_t t = {
4038033a:	cc1c      	movi.n	a12, 28
4038033c:	0b0c      	movi.n	a11, 0
4038033e:	01ad      	mov.n	a10, a1
40380340:	d05e81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380343:	0008e0        	callx8	a8
40380346:	338c      	beqz.n	a3, 4038034d <memspi_host_set_write_protect+0x19>
40380348:	480c      	movi.n	a8, 4
4038034a:	000046        	j	4038034f <memspi_host_set_write_protect+0x1b>
4038034d:	680c      	movi.n	a8, 6
4038034f:	0a5182        	s16i	a8, a1, 20
        .command = wp ? CMD_WRDI : CMD_WREN
    };
    host->driver->common_command(host, &t);
40380352:	0288      	l32i.n	a8, a2, 0
40380354:	1888      	l32i.n	a8, a8, 4
40380356:	01bd      	mov.n	a11, a1
40380358:	02ad      	mov.n	a10, a2
4038035a:	0008e0        	callx8	a8
    return ESP_OK;
}
4038035d:	020c      	movi.n	a2, 0
4038035f:	f01d      	retw.n
40380361:	000000        	ill

40380364 <memspi_host_read_id_hs>:
{
40380364:	008136        	entry	a1, 64
    uint32_t id_buf = 0;
40380367:	0b0c      	movi.n	a11, 0
40380369:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
4038036b:	714b      	addi.n	a7, a1, 4
4038036d:	cc1c      	movi.n	a12, 28
4038036f:	07ad      	mov.n	a10, a7
40380371:	d05181        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380374:	0008e0        	callx8	a8
40380377:	380c      	movi.n	a8, 3
40380379:	064182        	s8i	a8, a1, 6
4038037c:	4119      	s32i.n	a1, a1, 16
4038037e:	9fa082        	movi	a8, 159
40380381:	0c5182        	s16i	a8, a1, 24
    host->driver->common_command(host, &t);
40380384:	0288      	l32i.n	a8, a2, 0
40380386:	1888      	l32i.n	a8, a8, 4
40380388:	20b770        	or	a11, a7, a7
4038038b:	20a220        	or	a10, a2, a2
4038038e:	0008e0        	callx8	a8
    uint32_t raw_flash_id = id_buf;
40380391:	0198      	l32i.n	a9, a1, 0
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
40380393:	d34681        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
40380396:	c08980        	sub	a8, a9, a8
40380399:	40f880        	nsau	a8, a8
4038039c:	418580        	srli	a8, a8, 5
4038039f:	40f9a0        	nsau	a10, a9
403803a2:	41a5a0        	srli	a10, a10, 5
403803a5:	2088a0        	or	a8, a8, a10
403803a8:	c89c      	beqz.n	a8, 403803c8 <memspi_host_read_id_hs+0x64>
403803aa:	d03581        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
403803ad:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "no response\n");
403803af:	f88c      	beqz.n	a8, 403803c2 <memspi_host_read_id_hs+0x5e>
403803b1:	ff8525        	call8	4037fc04 <esp_log_timestamp>
403803b4:	d33fc1        	l32r	a12, 403750b0 <_iram_text_start+0xcac> (3fc94744 <TAG>)
403803b7:	0abd      	mov.n	a11, a10
403803b9:	d33ea1        	l32r	a10, 403750b4 <_iram_text_start+0xcb0> (3fc941dc <__func__$0+0x5f0>)
403803bc:	d04881        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
403803bf:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_NO_RESPONSE;
403803c2:	08a122        	movi	a2, 0x108
403803c5:	0006c6        	j	403803e4 <memspi_host_read_id_hs+0x80>
    uint16_t flash_id = (raw_flash_id >> 16) | (raw_flash_id & 0xFF00);
403803c8:	f58090        	extui	a8, a9, 16, 16
403803cb:	00afa2        	movi	a10, 0xffffff00
403803ce:	10a9a0        	and	a10, a9, a10
403803d1:	f4a0a0        	extui	a10, a10, 0, 16
403803d4:	2088a0        	or	a8, a8, a10
    *id = ((uint32_t)mfg_id << 16) | flash_id;
403803d7:	749090        	extui	a9, a9, 0, 8
403803da:	119900        	slli	a9, a9, 16
403803dd:	208890        	or	a8, a8, a9
403803e0:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
403803e2:	020c      	movi.n	a2, 0
}
403803e4:	f01d      	retw.n
	...

403803e8 <memspi_host_flush_cache>:
{
403803e8:	004136        	entry	a1, 32
    if ((void*)((memspi_host_inst_t*)host)->spi == (void*) spi_flash_ll_get_hw(SPI1_HOST)) {
403803eb:	012292        	l32i	a9, a2, 4
403803ee:	d0ee81        	l32r	a8, 403747a8 <_iram_text_start+0x3a4> (60002000 <SPIMEM1>)
403803f1:	089987        	bne	a9, a8, 403803fd <memspi_host_flush_cache+0x15>
        spi_flash_check_and_flush_cache(addr, size);
403803f4:	20b440        	or	a11, a4, a4
403803f7:	20a330        	or	a10, a3, a3
403803fa:	f761a5        	call8	40377a14 <spi_flash_check_and_flush_cache>
}
403803fd:	020c      	movi.n	a2, 0
403803ff:	f01d      	retw.n
40380401:	000000        	ill

40380404 <memspi_host_erase_sector>:
{
40380404:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
40380407:	d32981        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
4038040a:	0eb837        	bgeu	a8, a3, 4038041c <memspi_host_erase_sector+0x18>
4038040d:	d32ad1        	l32r	a13, 403750b8 <_iram_text_start+0xcb4> (3fc94214 <__func__$0+0x628>)
40380410:	d32bc1        	l32r	a12, 403750bc <_iram_text_start+0xcb8> (3fc94728 <__func__$2>)
40380413:	96a0b2        	movi	a11, 150
40380416:	d32aa1        	l32r	a10, 403750c0 <_iram_text_start+0xcbc> (3fc9424b <__func__$0+0x65f>)
40380419:	ff90e5        	call8	4037fd28 <__assert_func>
    spi_flash_trans_t t = {
4038041c:	cc1c      	movi.n	a12, 28
4038041e:	0b0c      	movi.n	a11, 0
40380420:	01ad      	mov.n	a10, a1
40380422:	d02581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380425:	0008e0        	callx8	a8
40380428:	881c      	movi.n	a8, 24
4038042a:	034182        	s8i	a8, a1, 3
4038042d:	1139      	s32i.n	a3, a1, 4
4038042f:	082c      	movi.n	a8, 32
40380431:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380434:	0288      	l32i.n	a8, a2, 0
40380436:	1888      	l32i.n	a8, a8, 4
40380438:	01bd      	mov.n	a11, a1
4038043a:	20a220        	or	a10, a2, a2
4038043d:	0008e0        	callx8	a8
}
40380440:	f01d      	retw.n
	...

40380444 <memspi_host_erase_block>:
{
40380444:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
40380447:	d31981        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
4038044a:	0eb837        	bgeu	a8, a3, 4038045c <memspi_host_erase_block+0x18>
4038044d:	d31ad1        	l32r	a13, 403750b8 <_iram_text_start+0xcb4> (3fc94214 <__func__$0+0x628>)
40380450:	d31dc1        	l32r	a12, 403750c4 <_iram_text_start+0xcc0> (3fc94710 <__func__$1>)
40380453:	a2a0b2        	movi	a11, 162
40380456:	d31aa1        	l32r	a10, 403750c0 <_iram_text_start+0xcbc> (3fc9424b <__func__$0+0x65f>)
40380459:	ff8ce5        	call8	4037fd28 <__assert_func>
    spi_flash_trans_t t = {
4038045c:	cc1c      	movi.n	a12, 28
4038045e:	0b0c      	movi.n	a11, 0
40380460:	01ad      	mov.n	a10, a1
40380462:	d01581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380465:	0008e0        	callx8	a8
40380468:	881c      	movi.n	a8, 24
4038046a:	034182        	s8i	a8, a1, 3
4038046d:	1139      	s32i.n	a3, a1, 4
4038046f:	d8a082        	movi	a8, 216
40380472:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
40380475:	0288      	l32i.n	a8, a2, 0
40380477:	1888      	l32i.n	a8, a8, 4
40380479:	01bd      	mov.n	a11, a1
4038047b:	02ad      	mov.n	a10, a2
4038047d:	0008e0        	callx8	a8
}
40380480:	f01d      	retw.n
	...

40380484 <memspi_host_program_page>:
{
40380484:	008136        	entry	a1, 64
    assert(address + length <= 0x1000000);
40380487:	845a      	add.n	a8, a4, a5
40380489:	d2a591        	l32r	a9, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
4038048c:	0eb987        	bgeu	a9, a8, 4038049e <memspi_host_program_page+0x1a>
4038048f:	d30ed1        	l32r	a13, 403750c8 <_iram_text_start+0xcc4> (3fc94260 <__func__$0+0x674>)
40380492:	d30ec1        	l32r	a12, 403750cc <_iram_text_start+0xcc8> (3fc946f4 <__func__$0>)
40380495:	aea0b2        	movi	a11, 174
40380498:	d30aa1        	l32r	a10, 403750c0 <_iram_text_start+0xcbc> (3fc9424b <__func__$0+0x65f>)
4038049b:	ff88e5        	call8	4037fd28 <__assert_func>
    spi_flash_trans_t t = {
4038049e:	cc1c      	movi.n	a12, 28
403804a0:	0b0c      	movi.n	a11, 0
403804a2:	01ad      	mov.n	a10, a1
403804a4:	d00581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403804a7:	0008e0        	callx8	a8
403804aa:	014152        	s8i	a5, a1, 1
403804ad:	881c      	movi.n	a8, 24
403804af:	034182        	s8i	a8, a1, 3
403804b2:	1149      	s32i.n	a4, a1, 4
403804b4:	2139      	s32i.n	a3, a1, 8
403804b6:	280c      	movi.n	a8, 2
403804b8:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
403804bb:	0288      	l32i.n	a8, a2, 0
403804bd:	1888      	l32i.n	a8, a8, 4
403804bf:	01bd      	mov.n	a11, a1
403804c1:	02ad      	mov.n	a10, a2
403804c3:	0008e0        	callx8	a8
}
403804c6:	f01d      	retw.n

403804c8 <memspi_host_init_pointers>:
{
403804c8:	004136        	entry	a1, 32
403804cb:	02ad      	mov.n	a10, a2
403804cd:	03bd      	mov.n	a11, a3
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
403804cf:	d06391        	l32r	a9, 4037465c <_iram_text_start+0x258> (c0378000 <_rtc_reserved_end+0x60278000>)
403804d2:	929a      	add.n	a9, a2, a9
403804d4:	d1d081        	l32r	a8, 40374c14 <_iram_text_start+0x810> (757fff <UserFrameTotalSize+0x757eff>)
403804d7:	628890        	saltu	a8, a8, a9
403804da:	880b      	addi.n	a8, a8, -1
403804dc:	608080        	neg	a8, a8
403804df:	748080        	extui	a8, a8, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
403804e2:	d1cd91        	l32r	a9, 40374c18 <_iram_text_start+0x814> (b0000000 <_rtc_reserved_end+0x4ff00000>)
403804e5:	929a      	add.n	a9, a2, a9
403804e7:	d03ec1        	l32r	a12, 403745e0 <_iram_text_start+0x1dc> (1fff <UserFrameTotalSize+0x1eff>)
403804ea:	629c90        	saltu	a9, a12, a9
403804ed:	990b      	addi.n	a9, a9, -1
403804ef:	609090        	neg	a9, a9
403804f2:	749090        	extui	a9, a9, 0, 8
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403804f5:	d039d1        	l32r	a13, 403745dc <_iram_text_start+0x1d8> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
403804f8:	d2da      	add.n	a13, a2, a13
403804fa:	62ccd0        	saltu	a12, a12, a13
403804fd:	cc0b      	addi.n	a12, a12, -1
403804ff:	60c0c0        	neg	a12, a12
40380502:	74c0c0        	extui	a12, a12, 0, 8
    if (!esp_ptr_internal(host) && cfg->host_id == SPI1_HOST) {
40380505:	208890        	or	a8, a8, a9
40380508:	48cc      	bnez.n	a8, 40380510 <memspi_host_init_pointers+0x48>
4038050a:	2ccc      	bnez.n	a12, 40380510 <memspi_host_init_pointers+0x48>
4038050c:	8388      	l32i.n	a8, a3, 32
4038050e:	b89c      	beqz.n	a8, 4038052d <memspi_host_init_pointers+0x65>
    if (cfg->host_id == SPI1_HOST)
40380510:	8b88      	l32i.n	a8, a11, 32
40380512:	78cc      	bnez.n	a8, 4038051d <memspi_host_init_pointers+0x55>
        host->inst.driver = &esp_flash_default_host;
40380514:	d2ef81        	l32r	a8, 403750d0 <_iram_text_start+0xccc> (3fc93a8c <esp_flash_default_host>)
40380517:	0a89      	s32i.n	a8, a10, 0
40380519:	000146        	j	40380522 <memspi_host_init_pointers+0x5a>
4038051c:	00          	.byte	00
        host->inst.driver = &esp_flash_gpspi_host;
4038051d:	d2ed81        	l32r	a8, 403750d4 <_iram_text_start+0xcd0> (3fc9474c <esp_flash_gpspi_host>)
40380520:	0a89      	s32i.n	a8, a10, 0
    esp_err_t err = spi_flash_hal_init(host, cfg);
40380522:	d2ed81        	l32r	a8, 403750d8 <_iram_text_start+0xcd4> (4200bfa4 <spi_flash_hal_init>)
40380525:	0008e0        	callx8	a8
40380528:	0a2d      	mov.n	a2, a10
    return err;
4038052a:	000086        	j	40380530 <memspi_host_init_pointers+0x68>
        return ESP_ERR_INVALID_ARG;
4038052d:	02a122        	movi	a2, 0x102
}
40380530:	f01d      	retw.n
	...

40380534 <memspi_host_write_data_slicer>:

// When encryption is enabled, etc. the data slicer may be complicated
// This is the simple case where the hardware has no other requirements than the size and page boundary
int memspi_host_write_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
40380534:	004136        	entry	a1, 32
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
40380537:	9288      	l32i.n	a8, a2, 36
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
40380539:	186807        	bbci	a8, 0, 40380555 <memspi_host_write_data_slicer+0x21>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
4038053c:	106307        	bbci	a3, 0, 40380550 <memspi_host_write_data_slicer+0x1c>
4038053f:	066407        	bbci	a4, 0, 40380549 <memspi_host_write_data_slicer+0x15>
            align_addr -= 1;
40380542:	330b      	addi.n	a3, a3, -1
            len += 1;
40380544:	441b      	addi.n	a4, a4, 1
40380546:	0002c6        	j	40380555 <memspi_host_write_data_slicer+0x21>
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
40380549:	330b      	addi.n	a3, a3, -1
            len += 2;
4038054b:	442b      	addi.n	a4, a4, 2
4038054d:	000106        	j	40380555 <memspi_host_write_data_slicer+0x21>
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
40380550:	016407        	bbci	a4, 0, 40380555 <memspi_host_write_data_slicer+0x21>
            len += 1;
40380553:	441b      	addi.n	a4, a4, 1
        }
    }

    uint32_t end_bound = (align_addr/page_size + 1) * page_size;
    // Shouldn't program cross the page, or longer than SPI_FLASH_HAL_MAX_WRITE_BYTES
    uint32_t max_len = MIN(end_bound - align_addr, SPI_FLASH_HAL_MAX_WRITE_BYTES);
40380555:	e28360        	remu	a8, a3, a6
40380558:	c06680        	sub	a6, a6, a8
4038055b:	084c      	movi.n	a8, 64
4038055d:	636680        	minu	a6, a6, a8
    *align_address = align_addr;
40380560:	0539      	s32i.n	a3, a5, 0
    return MIN(max_len, len);
}
40380562:	632460        	minu	a2, a4, a6
40380565:	f01d      	retw.n
	...

40380568 <memspi_host_read_data_slicer>:

int memspi_host_read_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
40380568:	004136        	entry	a1, 32
    // Shouldn't read longer than SPI_FLASH_HAL_MAX_READ_BYTES
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
4038056b:	9288      	l32i.n	a8, a2, 36
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
4038056d:	186807        	bbci	a8, 0, 40380589 <memspi_host_read_data_slicer+0x21>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
40380570:	106307        	bbci	a3, 0, 40380584 <memspi_host_read_data_slicer+0x1c>
40380573:	066407        	bbci	a4, 0, 4038057d <memspi_host_read_data_slicer+0x15>
            align_addr -= 1;
40380576:	330b      	addi.n	a3, a3, -1
            len += 1;
40380578:	441b      	addi.n	a4, a4, 1
4038057a:	0002c6        	j	40380589 <memspi_host_read_data_slicer+0x21>
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
4038057d:	330b      	addi.n	a3, a3, -1
            len += 2;
4038057f:	442b      	addi.n	a4, a4, 2
40380581:	000106        	j	40380589 <memspi_host_read_data_slicer+0x21>
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
40380584:	016407        	bbci	a4, 0, 40380589 <memspi_host_read_data_slicer+0x21>
            len += 1;
40380587:	441b      	addi.n	a4, a4, 1
        }
    }
    uint32_t max_len = SPI_FLASH_HAL_MAX_READ_BYTES;
    *align_address = align_addr;
40380589:	0539      	s32i.n	a3, a5, 0
    return MIN(max_len, len);
}
4038058b:	024c      	movi.n	a2, 64
4038058d:	632420        	minu	a2, a4, a2
40380590:	f01d      	retw.n
	...

40380594 <spi_flash_chip_boya_probe>:
#include "spi_flash_chip_generic.h"
#include "spi_flash_chip_gd.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_boya_probe(esp_flash_t *chip, uint32_t flash_id)
{
40380594:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x68;
    if (flash_id >> 16 != MFG_ID) {
40380597:	f59030        	extui	a9, a3, 16, 16
4038059a:	68a082        	movi	a8, 104
4038059d:	109987        	bne	a9, a8, 403805b1 <spi_flash_chip_boya_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
403805a0:	743830        	extui	a3, a3, 8, 8
403805a3:	113380        	slli	a3, a3, 8
403805a6:	cfaf81        	l32r	a8, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
403805a9:	0b9387        	bne	a3, a8, 403805b8 <spi_flash_chip_boya_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
403805ac:	020c      	movi.n	a2, 0
403805ae:	000246        	j	403805bb <spi_flash_chip_boya_probe+0x27>
        return ESP_ERR_NOT_FOUND;
403805b1:	05a122        	movi	a2, 0x105
403805b4:	0000c6        	j	403805bb <spi_flash_chip_boya_probe+0x27>
403805b7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403805ba:	f01d05        	call0	4037078c <rom_rx_gain_force+0x36a360>
403805bd:	000000        	ill

403805c0 <spi_flash_chip_boya_get_caps>:
}

spi_flash_caps_t spi_flash_chip_boya_get_caps(esp_flash_t *chip)
{
403805c0:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
403805c3:	420c      	movi.n	a2, 4
403805c5:	f01d      	retw.n
	...

403805c8 <spi_flash_chip_gd_detect_size>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_gd_detect_size(esp_flash_t *chip, uint32_t *size)
{
403805c8:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
403805cb:	62c8      	l32i.n	a12, a2, 24
    *size = 0;
403805cd:	0b0c      	movi.n	a11, 0
403805cf:	03b9      	s32i.n	a11, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
403805d1:	f490c0        	extui	a9, a12, 0, 16
403805d4:	180c      	movi.n	a8, 1
403805d6:	0bad      	mov.n	a10, a11
403805d8:	83a890        	moveqz	a10, a8, a9
403805db:	cfa6d1        	l32r	a13, 40374474 <_iram_text_start+0x70> (ffff <UserFrameTotalSize+0xfeff>)
403805de:	c099d0        	sub	a9, a9, a13
403805e1:	938b90        	movnez	a8, a11, a9
403805e4:	208a80        	or	a8, a10, a8
403805e7:	d8cc      	bnez.n	a8, 403805f8 <spi_flash_chip_gd_detect_size+0x30>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    *size = 1 << (id & 0xFF);
403805e9:	180c      	movi.n	a8, 1
403805eb:	401c00        	ssl	a12
403805ee:	a18800        	sll	a8, a8
403805f1:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
403805f3:	0b2d      	mov.n	a2, a11
403805f5:	000086        	j	403805fb <spi_flash_chip_gd_detect_size+0x33>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
403805f8:	d2a421        	l32r	a2, 40375088 <_iram_text_start+0xc84> (6005 <UserFrameTotalSize+0x5f05>)
}
403805fb:	f01d      	retw.n
403805fd:	000000        	ill

40380600 <spi_flash_chip_gd_suspend_cmd_conf>:
    return ret;
}
#endif //CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_gd_suspend_cmd_conf(esp_flash_t *chip)
{
40380600:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
40380603:	8c0c      	movi.n	a12, 8
40380605:	00a0b2        	movi	a11, 0
40380608:	01ad      	mov.n	a10, a1
4038060a:	cfab81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4038060d:	0008e0        	callx8	a8
40380610:	84a082        	movi	a8, 132
40380613:	0189      	s32i.n	a8, a1, 0
40380615:	583c      	movi.n	a8, 53
40380617:	044182        	s8i	a8, a1, 4
4038061a:	75a082        	movi	a8, 117
4038061d:	054182        	s8i	a8, a1, 5
40380620:	7aa082        	movi	a8, 122
40380623:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
40380626:	02a8      	l32i.n	a10, a2, 0
40380628:	0a88      	l32i.n	a8, a10, 0
4038062a:	152882        	l32i	a8, a8, 84
4038062d:	01bd      	mov.n	a11, a1
4038062f:	0008e0        	callx8	a8
}
40380632:	0a2d      	mov.n	a2, a10
40380634:	f01d      	retw.n
	...

40380638 <spi_flash_chip_gd_set_io_mode>:
{
40380638:	004136        	entry	a1, 32
4038063b:	02ad      	mov.n	a10, a2
    if (WRSR_16B_REQUIRED(chip->chip_id)) {
4038063d:	6288      	l32i.n	a8, a2, 24
4038063f:	749880        	extui	a9, a8, 8, 8
40380642:	119980        	slli	a9, a9, 8
40380645:	d2a5b1        	l32r	a11, 403750dc <_iram_text_start+0xcd8> (6000 <UserFrameTotalSize+0x5f00>)
40380648:	0819b7        	beq	a9, a11, 40380654 <spi_flash_chip_gd_set_io_mode+0x1c>
4038064b:	748080        	extui	a8, a8, 0, 8
4038064e:	15a092        	movi	a9, 21
40380651:	113987        	bltu	a9, a8, 40380666 <spi_flash_chip_gd_set_io_mode+0x2e>
        return spi_flash_common_set_io_mode(chip,
40380654:	00a2d2        	movi	a13, 0x200
40380657:	d2a2c1        	l32r	a12, 403750e0 <_iram_text_start+0xcdc> (40380a8c <spi_flash_common_read_status_16b_rdsr_rdsr2>)
4038065a:	d2a2b1        	l32r	a11, 403750e4 <_iram_text_start+0xce0> (40380ac4 <spi_flash_common_write_status_16b_wrsr>)
4038065d:	00abe5        	call8	4038111c <spi_flash_common_set_io_mode>
40380660:	0a2d      	mov.n	a2, a10
40380662:	0003c6        	j	40380675 <spi_flash_chip_gd_set_io_mode+0x3d>
40380665:	a0d200        	addx4	a13, a2, a0
        return spi_flash_common_set_io_mode(chip,
40380668:	9fc102        	addi	a0, a1, -97
4038066b:	a0b1d2        	l32ai	a13, a1, 0x280
4038066e:	aae5d2        	s32c1i	a13, a5, 0x2a8
40380671:	2aa000        	mul.s	f10, f0, f0
40380674:	009020        	all4	b2, b0:b1:b2:b3
	...

40380678 <spi_flash_chip_gd_get_io_mode>:
{
40380678:	006136        	entry	a1, 48
4038067b:	20a220        	or	a10, a2, a2
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
4038067e:	20b110        	or	a11, a1, a1
40380681:	006e25        	call8	40380d64 <spi_flash_common_read_status_8b_rdsr2>
40380684:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380687:	9acc      	bnez.n	a10, 40380694 <spi_flash_chip_gd_get_io_mode+0x1c>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380689:	0188      	l32i.n	a8, a1, 0
4038068b:	888a      	add.n	a8, a8, a8
4038068d:	490c      	movi.n	a9, 4
4038068f:	108890        	and	a8, a8, a9
40380692:	0389      	s32i.n	a8, a3, 0
}
40380694:	f01d      	retw.n
	...

40380698 <spi_flash_chip_gd_get_caps>:
{
40380698:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4038069b:	180282        	l8ui	a8, a2, 24
4038069e:	891c      	movi.n	a9, 24
403806a0:	043987        	bltu	a9, a8, 403806a8 <spi_flash_chip_gd_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
403806a3:	020c      	movi.n	a2, 0
403806a5:	000046        	j	403806aa <spi_flash_chip_gd_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_32MB_SUPPORT;
403806a8:	220c      	movi.n	a2, 2
}
403806aa:	480c      	movi.n	a8, 4
403806ac:	202280        	or	a2, a2, a8
403806af:	f01d      	retw.n
403806b1:	000000        	ill

403806b4 <spi_flash_chip_gd_probe>:
{
403806b4:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
403806b7:	f59030        	extui	a9, a3, 16, 16
403806ba:	c8a082        	movi	a8, 200
403806bd:	1f9987        	bne	a9, a8, 403806e0 <spi_flash_chip_gd_probe+0x2c>
    uint32_t product_id = flash_id & FLASH_ID_MASK;
403806c0:	743830        	extui	a3, a3, 8, 8
403806c3:	113380        	slli	a3, a3, 8
    if (product_id != GD25Q_PRODUCT_ID && product_id != GD25LQ_PRODUCT_ID) {
403806c6:	c0d382        	addmi	a8, a3, 0xffffc000
403806c9:	190c      	movi.n	a9, 1
403806cb:	839880        	moveqz	a9, a8, a8
403806ce:	a0d332        	addmi	a3, a3, 0xffffa000
403806d1:	180c      	movi.n	a8, 1
403806d3:	838330        	moveqz	a8, a3, a3
403806d6:	0e8987        	bany	a9, a8, 403806e8 <spi_flash_chip_gd_probe+0x34>
    return ESP_OK;
403806d9:	020c      	movi.n	a2, 0
403806db:	000306        	j	403806eb <spi_flash_chip_gd_probe+0x37>
403806de:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
403806e1:	0605a1        	l32r	a10, 40341ef8 <rom_rx_gain_force+0x33bacc>
403806e4:	000001        	l32r	a0, 403406e4 <rom_rx_gain_force+0x33a2b8>
403806e7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403806ea:	f01d05        	call0	403708bc <rom_rx_gain_force+0x36a490>
403806ed:	000000        	ill

403806f0 <spi_flash_chip_generic_detect_size>:
} while(0)

static const char TAG[] = "chip_generic";

esp_err_t spi_flash_chip_generic_detect_size(esp_flash_t *chip, uint32_t *size)
{
403806f0:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
403806f3:	6288      	l32i.n	a8, a2, 24
    *size = 0;
403806f5:	0c0c      	movi.n	a12, 0
403806f7:	03c9      	s32i.n	a12, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
403806f9:	f4a080        	extui	a10, a8, 0, 16
403806fc:	190c      	movi.n	a9, 1
403806fe:	0cbd      	mov.n	a11, a12
40380700:	83b9a0        	moveqz	a11, a9, a10
40380703:	cf5cd1        	l32r	a13, 40374474 <_iram_text_start+0x70> (ffff <UserFrameTotalSize+0xfeff>)
40380706:	c0aad0        	sub	a10, a10, a13
40380709:	939ca0        	movnez	a9, a12, a10
4038070c:	209b90        	or	a9, a11, a9
4038070f:	99dc      	bnez.n	a9, 4038072c <spi_flash_chip_generic_detect_size+0x3c>

    /* Get flash capacity from flash chip id depends on different vendors. According to majority of flash datasheets,
       Flash 256Mb to 512Mb directly from 0x19 to 0x20, instead of from 0x19 to 0x1a. So here we leave the common behavior.
       However, some other flash vendors also have their own rule, we will add them in chip specific files.
     */
    uint32_t mem_density = (id & 0xFF);
40380711:	748080        	extui	a8, a8, 0, 8
    if (mem_density > SPI_FLASH_LINEAR_DENSITY_LAST_VALUE ) {
40380714:	991c      	movi.n	a9, 25
40380716:	02b987        	bgeu	a9, a8, 4038071c <spi_flash_chip_generic_detect_size+0x2c>
        mem_density -= SPI_FLASH_HEX_A_F_RANGE;
40380719:	fac882        	addi	a8, a8, -6
    }

    *size = 1 << mem_density;
4038071c:	190c      	movi.n	a9, 1
4038071e:	401800        	ssl	a8
40380721:	a18900        	sll	a8, a9
40380724:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40380726:	020c      	movi.n	a2, 0
40380728:	0000c6        	j	4038072f <spi_flash_chip_generic_detect_size+0x3f>
4038072b:	572100        	ee.stf.64.xp	f2, f5, a0, a1
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4038072e:	f01dd2        	l16ui	a13, a13, 0x1e0
40380731:	000000        	ill

40380734 <spi_flash_chip_generic_reset>:
    // else has claimed it yet.
    return ESP_OK;
}

esp_err_t spi_flash_chip_generic_reset(esp_flash_t *chip)
{
40380734:	008136        	entry	a1, 64
    //this is written following the winbond spec..
    spi_flash_trans_t t;
    t = (spi_flash_trans_t) {
40380737:	cc1c      	movi.n	a12, 28
40380739:	0b0c      	movi.n	a11, 0
4038073b:	20a110        	or	a10, a1, a1
4038073e:	cf5e81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380741:	0008e0        	callx8	a8
40380744:	66a082        	movi	a8, 102
40380747:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RST_EN,
    };
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4038074a:	02a8      	l32i.n	a10, a2, 0
4038074c:	0a88      	l32i.n	a8, a10, 0
4038074e:	1888      	l32i.n	a8, a8, 4
40380750:	20b110        	or	a11, a1, a1
40380753:	0008e0        	callx8	a8
    if (err != ESP_OK) {
40380756:	baec      	bnez.n	a10, 40380785 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    t = (spi_flash_trans_t) {
40380758:	cc1c      	movi.n	a12, 28
4038075a:	0b0c      	movi.n	a11, 0
4038075c:	01ad      	mov.n	a10, a1
4038075e:	cf5681        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380761:	0008e0        	callx8	a8
40380764:	99a082        	movi	a8, 153
40380767:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RST_DEV,
    };
    err = chip->host->driver->common_command(chip->host, &t);
4038076a:	02a8      	l32i.n	a10, a2, 0
4038076c:	0a88      	l32i.n	a8, a10, 0
4038076e:	1888      	l32i.n	a8, a8, 4
40380770:	01bd      	mov.n	a11, a1
40380772:	0008e0        	callx8	a8
    if (err != ESP_OK) {
40380775:	cacc      	bnez.n	a10, 40380785 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380777:	1288      	l32i.n	a8, a2, 4
40380779:	152892        	l32i	a9, a8, 84
4038077c:	1888      	l32i.n	a8, a8, 4
4038077e:	08b8      	l32i.n	a11, a8, 0
40380780:	02ad      	mov.n	a10, a2
40380782:	0009e0        	callx8	a9
    return err;
}
40380785:	0a2d      	mov.n	a2, a10
40380787:	f01d      	retw.n
40380789:	000000        	ill

4038078c <spi_flash_chip_generic_config_host_io_mode>:
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
}

#if !CONFIG_SECURE_TEE_EXT_FLASH_MEMPROT_SPI1
esp_err_t spi_flash_chip_generic_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
4038078c:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    bool conf_required = false;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4038078f:	42e8      	l32i.n	a14, a2, 16
    bool addr_32bit = (flags & SPI_FLASH_CONFIG_IO_MODE_32B_ADDR);
40380791:	043030        	extui	a3, a3, 0, 1

    switch (read_mode & 0xFFFF) {
40380794:	f480e0        	extui	a8, a14, 0, 16
40380797:	6c3826        	beqi	a8, 3, 40380807 <spi_flash_chip_generic_config_host_io_mode+0x7b>
4038079a:	1648f6        	bgeui	a8, 4, 403807b4 <spi_flash_chip_generic_config_host_io_mode+0x28>
4038079d:	021866        	bnei	a8, 1, 403807a3 <spi_flash_chip_generic_config_host_io_mode+0x17>
403807a0:	002b06        	j	40380850 <spi_flash_chip_generic_config_host_io_mode+0xc4>
403807a3:	022866        	bnei	a8, 2, 403807a9 <spi_flash_chip_generic_config_host_io_mode+0x1d>
403807a6:	0020c6        	j	4038082d <spi_flash_chip_generic_config_host_io_mode+0xa1>
403807a9:	0c5816        	beqz	a8, 40380872 <spi_flash_chip_generic_config_host_io_mode+0xe6>
403807ac:	d02c21        	l32r	a2, 4037485c <_iram_text_start+0x458> (6003 <UserFrameTotalSize+0x5f03>)
403807af:	004c06        	j	403808e3 <spi_flash_chip_generic_config_host_io_mode+0x157>
403807b2:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
403807b5:	2a48      	l32i.n	a4, a10, 8
403807b7:	025826        	beqi	a8, 5, 403807bd <spi_flash_chip_generic_config_host_io_mode+0x31>
403807ba:	004886        	j	403808e0 <spi_flash_chip_generic_config_host_io_mode+0x154>
    case SPI_FLASH_QIO:
        //for QIO mode, the 4 bit right after the address are used for continuous mode, should be set to 0 to avoid that.
        addr_bitlen = SPI_FLASH_QIO_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qio_dummy_bitlen : rom_flash_chip_dummy->qio_dummy_bitlen);
403807bd:	7288      	l32i.n	a8, a2, 28
403807bf:	0a6817        	bbci	a8, 1, 403807cd <spi_flash_chip_generic_config_host_io_mode+0x41>
403807c2:	d24b81        	l32r	a8, 403750f0 <_iram_text_start+0xcec> (3fc93a74 <rom_flash_chip_dummy_hpm>)
403807c5:	0888      	l32i.n	a8, a8, 0
403807c7:	0108d2        	l8ui	a13, a8, 1
403807ca:	0001c6        	j	403807d5 <spi_flash_chip_generic_config_host_io_mode+0x49>
403807cd:	d24981        	l32r	a8, 403750f4 <_iram_text_start+0xcf0> (3fc93a78 <rom_flash_chip_dummy>)
403807d0:	0888      	l32i.n	a8, a8, 0
403807d2:	0108d2        	l8ui	a13, a8, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
403807d5:	0bc356        	bnez	a3, 40380895 <spi_flash_chip_generic_config_host_io_mode+0x109>
        conf_required = true;
403807d8:	130c      	movi.n	a3, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
403807da:	eba0b2        	movi	a11, 235
403807dd:	8c1c      	movi.n	a12, 24
403807df:	003946        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_QOUT:
        addr_bitlen = SPI_FLASH_QOUT_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qout_dummy_bitlen : rom_flash_chip_dummy->qout_dummy_bitlen);
403807e2:	7288      	l32i.n	a8, a2, 28
403807e4:	0c6817        	bbci	a8, 1, 403807f4 <spi_flash_chip_generic_config_host_io_mode+0x68>
403807e7:	d24281        	l32r	a8, 403750f0 <_iram_text_start+0xcec> (3fc93a74 <rom_flash_chip_dummy_hpm>)
403807ea:	0888      	l32i.n	a8, a8, 0
403807ec:	0208d2        	l8ui	a13, a8, 2
403807ef:	000246        	j	403807fc <spi_flash_chip_generic_config_host_io_mode+0x70>
403807f2:	810000        	src	a0, a0, a0
403807f5:	40          	.byte	0x40
403807f6:	d2          	.byte	0xd2
403807f7:	0888      	l32i.n	a8, a8, 0
403807f9:	0208d2        	l8ui	a13, a8, 2
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
403807fc:	09d356        	bnez	a3, 4038089d <spi_flash_chip_generic_config_host_io_mode+0x111>
403807ff:	6ba0b2        	movi	a11, 107
40380802:	8c1c      	movi.n	a12, 24
40380804:	003006        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_DIO:
        //for DIO mode, the 4 bit right after the address are used for continuous mode, should be set to 0 to avoid that.
        addr_bitlen = SPI_FLASH_DIO_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dio_dummy_bitlen : rom_flash_chip_dummy->dio_dummy_bitlen);
40380807:	7288      	l32i.n	a8, a2, 28
40380809:	0b6817        	bbci	a8, 1, 40380818 <spi_flash_chip_generic_config_host_io_mode+0x8c>
4038080c:	d23981        	l32r	a8, 403750f0 <_iram_text_start+0xcec> (3fc93a74 <rom_flash_chip_dummy_hpm>)
4038080f:	0888      	l32i.n	a8, a8, 0
40380811:	0008d2        	l8ui	a13, a8, 0
40380814:	000206        	j	40380820 <spi_flash_chip_generic_config_host_io_mode+0x94>
40380817:	378100        	ee.stf.64.xp	f8, f3, a0, a1
4038081a:	d2          	.byte	0xd2
4038081b:	0888      	l32i.n	a8, a8, 0
4038081d:	0008d2        	l8ui	a13, a8, 0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
40380820:	084356        	bnez	a3, 403808a8 <spi_flash_chip_generic_config_host_io_mode+0x11c>
        conf_required = true;
40380823:	130c      	movi.n	a3, 1
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
40380825:	bba0b2        	movi	a11, 187
40380828:	8c1c      	movi.n	a12, 24
4038082a:	002686        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_DOUT:
        addr_bitlen = SPI_FLASH_DOUT_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dout_dummy_bitlen : rom_flash_chip_dummy->dout_dummy_bitlen);
4038082d:	7288      	l32i.n	a8, a2, 28
4038082f:	0a6817        	bbci	a8, 1, 4038083d <spi_flash_chip_generic_config_host_io_mode+0xb1>
40380832:	d22f81        	l32r	a8, 403750f0 <_iram_text_start+0xcec> (3fc93a74 <rom_flash_chip_dummy_hpm>)
40380835:	0888      	l32i.n	a8, a8, 0
40380837:	0308d2        	l8ui	a13, a8, 3
4038083a:	0001c6        	j	40380845 <spi_flash_chip_generic_config_host_io_mode+0xb9>
4038083d:	d22d81        	l32r	a8, 403750f4 <_iram_text_start+0xcf0> (3fc93a78 <rom_flash_chip_dummy>)
40380840:	0888      	l32i.n	a8, a8, 0
40380842:	0308d2        	l8ui	a13, a8, 3
        read_command = (addr_32bit? CMD_FASTRD_DUAL_4B: CMD_FASTRD_DUAL);
40380845:	067356        	bnez	a3, 403808b0 <spi_flash_chip_generic_config_host_io_mode+0x124>
40380848:	bb3c      	movi.n	a11, 59
4038084a:	8c1c      	movi.n	a12, 24
4038084c:	001e06        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
4038084f:	728800        	salt	a8, a8, a0
        break;
    case SPI_FLASH_FASTRD:
        addr_bitlen = SPI_FLASH_FASTRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
40380852:	0a6817        	bbci	a8, 1, 40380860 <spi_flash_chip_generic_config_host_io_mode+0xd4>
40380855:	d22681        	l32r	a8, 403750f0 <_iram_text_start+0xcec> (3fc93a74 <rom_flash_chip_dummy_hpm>)
40380858:	0888      	l32i.n	a8, a8, 0
4038085a:	0408d2        	l8ui	a13, a8, 4
4038085d:	0001c6        	j	40380868 <spi_flash_chip_generic_config_host_io_mode+0xdc>
40380860:	d22581        	l32r	a8, 403750f4 <_iram_text_start+0xcf0> (3fc93a78 <rom_flash_chip_dummy>)
40380863:	0888      	l32i.n	a8, a8, 0
40380865:	0408d2        	l8ui	a13, a8, 4
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
40380868:	04d356        	bnez	a3, 403808b9 <spi_flash_chip_generic_config_host_io_mode+0x12d>
4038086b:	bb0c      	movi.n	a11, 11
4038086d:	8c1c      	movi.n	a12, 24
4038086f:	001546        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        break;
    case SPI_FLASH_SLOWRD:
        addr_bitlen = SPI_FLASH_SLOWRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->slowrd_dummy_bitlen : rom_flash_chip_dummy->slowrd_dummy_bitlen);
40380872:	7288      	l32i.n	a8, a2, 28
40380874:	0c6817        	bbci	a8, 1, 40380884 <spi_flash_chip_generic_config_host_io_mode+0xf8>
40380877:	d21e81        	l32r	a8, 403750f0 <_iram_text_start+0xcec> (3fc93a74 <rom_flash_chip_dummy_hpm>)
4038087a:	0888      	l32i.n	a8, a8, 0
4038087c:	0508d2        	l8ui	a13, a8, 5
4038087f:	000246        	j	4038088c <spi_flash_chip_generic_config_host_io_mode+0x100>
40380882:	810000        	src	a0, a0, a0
40380885:	d21c      	movi.n	a2, 29
40380887:	0888      	l32i.n	a8, a8, 0
40380889:	0508d2        	l8ui	a13, a8, 5
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
4038088c:	23fc      	bnez.n	a3, 403808c2 <spi_flash_chip_generic_config_host_io_mode+0x136>
4038088e:	3b0c      	movi.n	a11, 3
40380890:	8c1c      	movi.n	a12, 24
40380892:	000c86        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
40380895:	eca0b2        	movi	a11, 236
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }
    //For W25Q256 chip, the only difference between 4-Byte address command and 3-Byte version is the command value and the address bit length.
    if (addr_32bit) {
        addr_bitlen += 8;
40380898:	0c2c      	movi.n	a12, 32
4038089a:	000a86        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
4038089d:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
4038089f:	6ca0b2        	movi	a11, 108
        addr_bitlen += 8;
403808a2:	0c2c      	movi.n	a12, 32
403808a4:	000806        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
403808a7:	a0b200        	addx4	a11, a2, a0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
403808aa:	2cbc      	beqz.n	a12, 403808e0 <spi_flash_chip_generic_config_host_io_mode+0x154>
        addr_bitlen += 8;
403808ac:	c60c      	movi.n	a6, 12
403808ae:	0c0005        	call0	4038c8b0 <_iram_bss_end+0xa4b0>
    bool conf_required = false;
403808b1:	03          	.byte	0x3
        read_command = (addr_32bit? CMD_FASTRD_DUAL_4B: CMD_FASTRD_DUAL);
403808b2:	cb3c      	movi.n	a11, 60
        addr_bitlen += 8;
403808b4:	0c2c      	movi.n	a12, 32
403808b6:	000386        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
403808b9:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
403808bb:	cb0c      	movi.n	a11, 12
        addr_bitlen += 8;
403808bd:	0c2c      	movi.n	a12, 32
403808bf:	000146        	j	403808c8 <spi_flash_chip_generic_config_host_io_mode+0x13c>
    bool conf_required = false;
403808c2:	030c      	movi.n	a3, 0
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
403808c4:	3b1c      	movi.n	a11, 19
        addr_bitlen += 8;
403808c6:	0c2c      	movi.n	a12, 32
    }

    if (conf_required) {
403808c8:	438c      	beqz.n	a3, 403808d0 <spi_flash_chip_generic_config_host_io_mode+0x144>
        read_mode |= SPI_FLASH_CONFIG_CONF_BITS;
403808ca:	cfb981        	l32r	a8, 403747b0 <_iram_text_start+0x3ac> (80000000 <_rtc_reserved_end+0x1ff00000>)
403808cd:	20ee80        	or	a14, a14, a8
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
403808d0:	02a8      	l32i.n	a10, a2, 0
403808d2:	0a88      	l32i.n	a8, a10, 0
403808d4:	f888      	l32i.n	a8, a8, 60
403808d6:	0008e0        	callx8	a8
403808d9:	0a2d      	mov.n	a2, a10
403808db:	000106        	j	403808e3 <spi_flash_chip_generic_config_host_io_mode+0x157>
403808de:	210000        	srai	a0, a0, 0
    switch (read_mode & 0xFFFF) {
403808e1:	f01dcfdf 	ee.vmulas.u16.qacc.ld.xp	q1, a13, a15, q7, q0
403808e5:	000000        	ill

403808e8 <spi_flash_chip_generic_write_encrypted>:
}
#endif // CONFIG_SPI_FLASH_ROM_IMPL

#if !CONFIG_SPI_FLASH_ROM_IMPL || ESP_ROM_HAS_ENCRYPTED_WRITES_USING_LEGACY_DRV
esp_err_t spi_flash_chip_generic_write_encrypted(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
403808e8:	004136        	entry	a1, 32
403808eb:	027d      	mov.n	a7, a2
    spi_flash_encryption_t *esp_flash_encryption = &esp_flash_encryption_default;
    esp_err_t err = ESP_OK;
    // Encryption must happen on main flash.
    if (chip != esp_flash_default_chip) {
403808ed:	d1e281        	l32r	a8, 40375078 <_iram_text_start+0xc74> (3fc953c4 <esp_flash_default_chip>)
403808f0:	0888      	l32i.n	a8, a8, 0
403808f2:	021827        	beq	a8, a2, 403808f8 <spi_flash_chip_generic_write_encrypted+0x10>
403808f5:	002bc6        	j	403809a8 <spi_flash_chip_generic_write_encrypted+0xc0>
        return ESP_ERR_NOT_SUPPORTED;
    }

    /* Check if the buffer and length can qualify the requirements */
    if (esp_flash_encryption->flash_encryption_check(address, length) != true) {
403808f8:	d20081        	l32r	a8, 403750f8 <_iram_text_start+0xcf4> (3fc93a5c <esp_flash_encryption_default>)
403808fb:	5888      	l32i.n	a8, a8, 20
403808fd:	05bd      	mov.n	a11, a5
403808ff:	20a440        	or	a10, a4, a4
40380902:	0008e0        	callx8	a8
40380905:	0a8a16        	beqz	a10, 403809b1 <spi_flash_chip_generic_write_encrypted+0xc9>
        return ESP_ERR_NOT_SUPPORTED;
    }

    const uint8_t *data_bytes = (const uint8_t *)buffer;
    esp_flash_encryption->flash_encryption_enable();
40380908:	d1fc81        	l32r	a8, 403750f8 <_iram_text_start+0xcf4> (3fc93a5c <esp_flash_encryption_default>)
4038090b:	0888      	l32i.n	a8, a8, 0
4038090d:	0008e0        	callx8	a8
    esp_err_t err = ESP_OK;
40380910:	020c      	movi.n	a2, 0

#if SOC_FLASH_ENCRYPTION_XTS_AES_SUPPORT_PSEUDO_ROUND
    spi_flash_encryption_hal_enable_pseudo_rounds(ESP_XTS_AES_PSEUDO_ROUNDS_LOW, XTS_AES_PSEUDO_ROUNDS_BASE, XTS_AES_PSEUDO_ROUNDS_INC, XTS_AES_PSEUDO_ROUNDS_RNG_CNT);
#endif /* SOC_FLASH_ENCRYPTION_XTS_AES_SUPPORT_PSEUDO_ROUND */

    while (length > 0) {
40380912:	002086        	j	40380998 <spi_flash_chip_generic_write_encrypted+0xb0>
        int block_size;
        /* Write the largest block if possible */
        if (address % 64 == 0 && length >= 64) {
40380915:	548040        	extui	a8, a4, 0, 6
40380918:	48cc      	bnez.n	a8, 40380920 <spi_flash_chip_generic_write_encrypted+0x38>
4038091a:	3fa082        	movi	a8, 63
4038091d:	0f3857        	bltu	a8, a5, 40380930 <spi_flash_chip_generic_write_encrypted+0x48>
            block_size = 64;
        } else if (address % 32 == 0 && length >= 32) {
40380920:	448040        	extui	a8, a4, 0, 5
40380923:	e8cc      	bnez.n	a8, 40380935 <spi_flash_chip_generic_write_encrypted+0x4d>
40380925:	f81c      	movi.n	a8, 31
40380927:	0f3857        	bltu	a8, a5, 4038093a <spi_flash_chip_generic_write_encrypted+0x52>
            block_size = 32;
        } else {
            block_size = 16;
4038092a:	061c      	movi.n	a6, 16
4038092c:	000306        	j	4038093c <spi_flash_chip_generic_write_encrypted+0x54>
4038092f:	064c00        	ee.ldf.64.xp	f4, f0, a0, a12
            block_size = 64;
40380932:	000186        	j	4038093c <spi_flash_chip_generic_write_encrypted+0x54>
            block_size = 16;
40380935:	061c      	movi.n	a6, 16
40380937:	000046        	j	4038093c <spi_flash_chip_generic_write_encrypted+0x54>
            block_size = 32;
4038093a:	062c      	movi.n	a6, 32
        }
        // Prepare the flash chip (same time as AES operation, for performance)
        esp_flash_encryption->flash_encryption_data_prepare(address, (uint32_t *)data_bytes, block_size);
4038093c:	d1ef81        	l32r	a8, 403750f8 <_iram_text_start+0xcf4> (3fc93a5c <esp_flash_encryption_default>)
4038093f:	2888      	l32i.n	a8, a8, 8
40380941:	06cd      	mov.n	a12, a6
40380943:	03bd      	mov.n	a11, a3
40380945:	04ad      	mov.n	a10, a4
40380947:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
4038094a:	1788      	l32i.n	a8, a7, 4
4038094c:	b888      	l32i.n	a8, a8, 44
4038094e:	0b0c      	movi.n	a11, 0
40380950:	07ad      	mov.n	a10, a7
40380952:	0008e0        	callx8	a8
40380955:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380957:	059a56        	bnez	a10, 403809b4 <spi_flash_chip_generic_write_encrypted+0xcc>
            return err;
        }
        // Waiting for encrypting buffer to finish and making result visible for SPI1
        esp_flash_encryption->flash_encryption_done();
4038095a:	d1e781        	l32r	a8, 403750f8 <_iram_text_start+0xcf4> (3fc93a5c <esp_flash_encryption_default>)
4038095d:	3888      	l32i.n	a8, a8, 12
4038095f:	0008e0        	callx8	a8

        // Note: For encryption function, after write flash command is sent. The hardware will write the encrypted buffer
        // prepared in XTS_FLASH_ENCRYPTION register in function `flash_encryption_data_prepare`, instead of the origin
        // buffer named `data_bytes`.

        err = chip->chip_drv->write(chip, (uint32_t *)data_bytes, address, length);
40380962:	1788      	l32i.n	a8, a7, 4
40380964:	112882        	l32i	a8, a8, 68
40380967:	05dd      	mov.n	a13, a5
40380969:	04cd      	mov.n	a12, a4
4038096b:	03bd      	mov.n	a11, a3
4038096d:	07ad      	mov.n	a10, a7
4038096f:	0008e0        	callx8	a8
40380972:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380974:	cafc      	bnez.n	a10, 403809b4 <spi_flash_chip_generic_write_encrypted+0xcc>
            return err;
        }
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40380976:	1788      	l32i.n	a8, a7, 4
40380978:	152892        	l32i	a9, a8, 84
4038097b:	1888      	l32i.n	a8, a8, 4
4038097d:	48b8      	l32i.n	a11, a8, 16
4038097f:	07ad      	mov.n	a10, a7
40380981:	0009e0        	callx8	a9
40380984:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40380986:	aaec      	bnez.n	a10, 403809b4 <spi_flash_chip_generic_write_encrypted+0xcc>

        // Note: we don't wait for idle status here, because this way
        // the AES peripheral can start encrypting the next
        // block while the SPI flash chip is busy completing the write

        esp_flash_encryption->flash_encryption_destroy();
40380988:	d1dc81        	l32r	a8, 403750f8 <_iram_text_start+0xcf4> (3fc93a5c <esp_flash_encryption_default>)
4038098b:	4888      	l32i.n	a8, a8, 16
4038098d:	0008e0        	callx8	a8

        length -= block_size;
40380990:	c05560        	sub	a5, a5, a6
        data_bytes += block_size;
40380993:	336a      	add.n	a3, a3, a6
        address += block_size;
40380995:	804460        	add	a4, a4, a6
    while (length > 0) {
40380998:	f79556        	bnez	a5, 40380915 <spi_flash_chip_generic_write_encrypted+0x2d>
    }

    esp_flash_encryption->flash_encryption_disable();
4038099b:	d1d781        	l32r	a8, 403750f8 <_iram_text_start+0xcf4> (3fc93a5c <esp_flash_encryption_default>)
4038099e:	012882        	l32i	a8, a8, 4
403809a1:	0008e0        	callx8	a8
    return err;
403809a4:	000306        	j	403809b4 <spi_flash_chip_generic_write_encrypted+0xcc>
403809a7:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
403809aa:	014606        	j	40380ec6 <spi_flash_chip_generic_erase_sector+0x32>
403809ad:	000000        	ill
403809b0:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
403809b3:	f01d06        	j	4037ca2b <cache_hal_is_cache_enabled+0x17>
	...

403809b8 <spi_flash_chip_generic_get_caps>:
    // For flash doesn't support read unique id.
    return ESP_ERR_NOT_SUPPORTED;
}

spi_flash_caps_t spi_flash_chip_generic_get_caps(esp_flash_t *chip)
{
403809b8:	008136        	entry	a1, 64
    spi_flash_caps_t caps_flags = 0;
    // 32M-bits address support

    // flash suspend support
    // XMC-D support suspend
    if (chip->chip_id >> 16 == 0x46) {
403809bb:	0d1282        	l16ui	a8, a2, 26
403809be:	694c      	movi.n	a9, 70
403809c0:	041897        	beq	a8, a9, 403809c8 <spi_flash_chip_generic_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
403809c3:	070c      	movi.n	a7, 0
403809c5:	000046        	j	403809ca <spi_flash_chip_generic_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
403809c8:	170c      	movi.n	a7, 1
    }

    // XMC-D support suspend (some D series flash chip begin with 0x20, difference checked by SFDP)
    if (chip->chip_id >> 16 == 0x20) {
403809ca:	42c866        	bnei	a8, 32, 40380a10 <spi_flash_chip_generic_get_caps+0x58>
        uint8_t data = 0;
403809cd:	080c      	movi.n	a8, 0
403809cf:	1c4182        	s8i	a8, a1, 28
        spi_flash_trans_t t = {
403809d2:	cc1c      	movi.n	a12, 28
403809d4:	0b0c      	movi.n	a11, 0
403809d6:	01ad      	mov.n	a10, a1
403809d8:	ceb881        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403809db:	0008e0        	callx8	a8
403809de:	180c      	movi.n	a8, 1
403809e0:	024182        	s8i	a8, a1, 2
403809e3:	881c      	movi.n	a8, 24
403809e5:	034182        	s8i	a8, a1, 3
403809e8:	283c      	movi.n	a8, 50
403809ea:	1189      	s32i.n	a8, a1, 4
403809ec:	1cc182        	addi	a8, a1, 28
403809ef:	3189      	s32i.n	a8, a1, 12
403809f1:	a85c      	movi.n	a8, 90
403809f3:	0a5182        	s16i	a8, a1, 20
403809f6:	860c      	movi.n	a6, 8
403809f8:	164162        	s8i	a6, a1, 22
            .mosi_data = 0,
            .miso_len = 1,
            .miso_data = &data,
            .dummy_bitlen = 8,
        };
        chip->host->driver->common_command(chip->host, &t);
403809fb:	02a8      	l32i.n	a10, a2, 0
403809fd:	0a88      	l32i.n	a8, a10, 0
403809ff:	012882        	l32i	a8, a8, 4
40380a02:	20b110        	or	a11, a1, a1
40380a05:	0008e0        	callx8	a8
        if((data & 0x8) == 0x8) {
40380a08:	1c0182        	l8ui	a8, a1, 28
40380a0b:	010867        	bnone	a8, a6, 40380a10 <spi_flash_chip_generic_get_caps+0x58>
            caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
40380a0e:	170c      	movi.n	a7, 1
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
    }
#endif

    // FM support suspend
    if (chip->chip_id >> 16 == 0xa1) {
40380a10:	0d1292        	l16ui	a9, a2, 26
40380a13:	a1a082        	movi	a8, 161
40380a16:	049987        	bne	a9, a8, 40380a1e <spi_flash_chip_generic_get_caps+0x66>
        caps_flags |= SPI_FLASH_CHIP_CAP_SUSPEND;
40380a19:	180c      	movi.n	a8, 1
40380a1b:	207780        	or	a7, a7, a8
    }
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
40380a1e:	420c      	movi.n	a2, 4
40380a20:	202720        	or	a2, a7, a2
40380a23:	f01d      	retw.n
40380a25:	000000        	ill

40380a28 <spi_flash_common_read_qe_sr>:
/*******************************************************************************
 * Utility functions
 ******************************************************************************/

static esp_err_t spi_flash_common_read_qe_sr(esp_flash_t *chip, uint8_t qe_rdsr_command, uint8_t qe_sr_bitwidth, uint32_t *sr)
{
40380a28:	008136        	entry	a1, 64
    uint32_t sr_buf = 0;
40380a2b:	0b0c      	movi.n	a11, 0
40380a2d:	01b9      	s32i.n	a11, a1, 0
    spi_flash_trans_t t = {
40380a2f:	714b      	addi.n	a7, a1, 4
40380a31:	1ca0c2        	movi	a12, 28
40380a34:	07ad      	mov.n	a10, a7
40380a36:	cea081        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380a39:	0008e0        	callx8	a8
40380a3c:	414340        	srli	a4, a4, 3
40380a3f:	064142        	s8i	a4, a1, 6
40380a42:	4119      	s32i.n	a1, a1, 16
40380a44:	0c5132        	s16i	a3, a1, 24
        .command = qe_rdsr_command,
        .miso_data = (uint8_t*) &sr_buf,
        .miso_len = qe_sr_bitwidth / 8,
    };
    esp_err_t ret = chip->host->driver->common_command(chip->host, &t);
40380a47:	02a8      	l32i.n	a10, a2, 0
40380a49:	0a88      	l32i.n	a8, a10, 0
40380a4b:	1888      	l32i.n	a8, a8, 4
40380a4d:	07bd      	mov.n	a11, a7
40380a4f:	0008e0        	callx8	a8
    *sr = sr_buf;
40380a52:	0188      	l32i.n	a8, a1, 0
40380a54:	0589      	s32i.n	a8, a5, 0
    return ret;
}
40380a56:	0a2d      	mov.n	a2, a10
40380a58:	f01d      	retw.n
	...

40380a5c <spi_flash_common_write_qe_sr>:

static esp_err_t spi_flash_common_write_qe_sr(esp_flash_t *chip, uint8_t qe_wrsr_command, uint8_t qe_sr_bitwidth, uint32_t qe)
{
40380a5c:	00a136        	entry	a1, 80
40380a5f:	8159      	s32i.n	a5, a1, 32
    spi_flash_trans_t t = {
40380a61:	cc1c      	movi.n	a12, 28
40380a63:	0b0c      	movi.n	a11, 0
40380a65:	01ad      	mov.n	a10, a1
40380a67:	ce9481        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380a6a:	0008e0        	callx8	a8
40380a6d:	414340        	srli	a4, a4, 3
40380a70:	014142        	s8i	a4, a1, 1
40380a73:	20c182        	addi	a8, a1, 32
40380a76:	2189      	s32i.n	a8, a1, 8
40380a78:	0a5132        	s16i	a3, a1, 20
        .command = qe_wrsr_command,
        .mosi_data = ((uint8_t*) &qe),
        .mosi_len = qe_sr_bitwidth / 8,
        .miso_len = 0,
    };
    return chip->host->driver->common_command(chip->host, &t);
40380a7b:	02a8      	l32i.n	a10, a2, 0
40380a7d:	0a88      	l32i.n	a8, a10, 0
40380a7f:	1888      	l32i.n	a8, a8, 4
40380a81:	01bd      	mov.n	a11, a1
40380a83:	0008e0        	callx8	a8
}
40380a86:	0a2d      	mov.n	a2, a10
40380a88:	f01d      	retw.n
	...

40380a8c <spi_flash_common_read_status_16b_rdsr_rdsr2>:

esp_err_t spi_flash_common_read_status_16b_rdsr_rdsr2(esp_flash_t* chip, uint32_t* out_sr)
{
40380a8c:	006136        	entry	a1, 48
40380a8f:	207220        	or	a7, a2, a2
    uint32_t sr, sr2;
    esp_err_t ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, &sr2);
40380a92:	04c1d2        	addi	a13, a1, 4
40380a95:	8c0c      	movi.n	a12, 8
40380a97:	35a0b2        	movi	a11, 53
40380a9a:	02ad      	mov.n	a10, a2
40380a9c:	fff8a5        	call8	40380a28 <spi_flash_common_read_qe_sr>
40380a9f:	0a2d      	mov.n	a2, a10
    if (ret == ESP_OK) {
40380aa1:	dadc      	bnez.n	a10, 40380ac2 <spi_flash_common_read_status_16b_rdsr_rdsr2+0x36>
        ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, &sr);
40380aa3:	01dd      	mov.n	a13, a1
40380aa5:	8c0c      	movi.n	a12, 8
40380aa7:	5b0c      	movi.n	a11, 5
40380aa9:	07ad      	mov.n	a10, a7
40380aab:	fff7e5        	call8	40380a28 <spi_flash_common_read_qe_sr>
40380aae:	0a2d      	mov.n	a2, a10
    }
    if (ret == ESP_OK) {
40380ab0:	eacc      	bnez.n	a10, 40380ac2 <spi_flash_common_read_status_16b_rdsr_rdsr2+0x36>
        *out_sr = (sr & 0xff) | ((sr2 & 0xff) << 8);
40380ab2:	000192        	l8ui	a9, a1, 0
40380ab5:	1188      	l32i.n	a8, a1, 4
40380ab7:	118880        	slli	a8, a8, 8
40380aba:	f48080        	extui	a8, a8, 0, 16
40380abd:	208980        	or	a8, a9, a8
40380ac0:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
40380ac2:	f01d      	retw.n

40380ac4 <spi_flash_common_write_status_16b_wrsr>:
{
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
}

esp_err_t spi_flash_common_write_status_16b_wrsr(esp_flash_t* chip, uint32_t sr)
{
40380ac4:	004136        	entry	a1, 32
40380ac7:	20a220        	or	a10, a2, a2
40380aca:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 16, sr);
40380acd:	10a0c2        	movi	a12, 16
40380ad0:	1b0c      	movi.n	a11, 1
40380ad2:	fff8a5        	call8	40380a5c <spi_flash_common_write_qe_sr>
}
40380ad5:	0a2d      	mov.n	a2, a10
40380ad7:	f01d      	retw.n
40380ad9:	000000        	ill

40380adc <spi_flash_chip_generic_suspend_cmd_conf>:
}

#endif // !CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_generic_suspend_cmd_conf(esp_flash_t *chip)
{
40380adc:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
40380adf:	8c0c      	movi.n	a12, 8
40380ae1:	00a0b2        	movi	a11, 0
40380ae4:	01ad      	mov.n	a10, a1
40380ae6:	ce7481        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380ae9:	0008e0        	callx8	a8
40380aec:	80a082        	movi	a8, 128
40380aef:	0189      	s32i.n	a8, a1, 0
40380af1:	583c      	movi.n	a8, 53
40380af3:	044182        	s8i	a8, a1, 4
40380af6:	75a082        	movi	a8, 117
40380af9:	054182        	s8i	a8, a1, 5
40380afc:	7aa082        	movi	a8, 122
40380aff:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
40380b02:	02a8      	l32i.n	a10, a2, 0
40380b04:	0a88      	l32i.n	a8, a10, 0
40380b06:	152882        	l32i	a8, a8, 84
40380b09:	01bd      	mov.n	a11, a1
40380b0b:	0008e0        	callx8	a8
}
40380b0e:	0a2d      	mov.n	a2, a10
40380b10:	f01d      	retw.n
	...

40380b14 <spi_flash_chip_generic_read>:
{
40380b14:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
40380b17:	012282        	l32i	a8, a2, 4
40380b1a:	132892        	l32i	a9, a8, 76
40380b1d:	176192        	s32i	a9, a1, 92
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
40380b20:	1e2882        	l32i	a8, a8, 120
40380b23:	00a0b2        	movi	a11, 0
40380b26:	02ad      	mov.n	a10, a2
40380b28:	0008e0        	callx8	a8
40380b2b:	1561a2        	s32i	a10, a1, 84
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380b2e:	06a182        	movi	a8, 0x106
40380b31:	021a87        	beq	a10, a8, 40380b37 <spi_flash_chip_generic_read+0x23>
40380b34:	001e06        	j	40380bb0 <spi_flash_chip_generic_read+0x9c>
        ESP_LOGE(TAG, "configure host io mode failed - unsupported");
40380b37:	ff0ce5        	call8	4037fc04 <esp_log_timestamp>
40380b3a:	d170b1        	l32r	a11, 403750fc <_iram_text_start+0xcf8> (3fc94958 <TAG>)
40380b3d:	0bed      	mov.n	a14, a11
40380b3f:	0add      	mov.n	a13, a10
40380b41:	d16fc1        	l32r	a12, 40375100 <_iram_text_start+0xcfc> (3fc94090 <__func__$0+0x4a4>)
40380b44:	1a0c      	movi.n	a10, 1
40380b46:	fefe25        	call8	4037fb28 <esp_log>
        return err;
40380b49:	001c06        	j	40380bbd <spi_flash_chip_generic_read+0xa9>
40380b4c:	00          	.byte	00
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
40380b4d:	614b      	addi.n	a6, a1, 4
40380b4f:	0c4c      	movi.n	a12, 64
40380b51:	ffa0b2        	movi	a11, 255
40380b54:	06ad      	mov.n	a10, a6
40380b56:	ce5881        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380b59:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
40380b5c:	02a8      	l32i.n	a10, a2, 0
40380b5e:	0a88      	l32i.n	a8, a10, 0
40380b60:	d888      	l32i.n	a8, a8, 52
40380b62:	1721e2        	l32i	a14, a1, 92
40380b65:	01dd      	mov.n	a13, a1
40380b67:	05cd      	mov.n	a12, a5
40380b69:	04bd      	mov.n	a11, a4
40380b6b:	0008e0        	callx8	a8
40380b6e:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
40380b70:	01c8      	l32i.n	a12, a1, 0
40380b72:	c084c0        	sub	a8, a4, a12
40380b75:	166182        	s32i	a8, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
40380b78:	754a      	add.n	a7, a5, a4
40380b7a:	8caa      	add.n	a8, a12, a10
40380b7c:	637780        	minu	a7, a7, a8
40380b7f:	c08740        	sub	a8, a7, a4
40380b82:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
40380b85:	02a8      	l32i.n	a10, a2, 0
40380b87:	0a88      	l32i.n	a8, a10, 0
40380b89:	b888      	l32i.n	a8, a8, 44
40380b8b:	20b660        	or	a11, a6, a6
40380b8e:	0008e0        	callx8	a8
40380b91:	1561a2        	s32i	a10, a1, 84
        memcpy(buffer, temp_buffer + left_off, data_len);
40380b94:	1421c2        	l32i	a12, a1, 80
40380b97:	162192        	l32i	a9, a1, 88
40380b9a:	b69a      	add.n	a11, a6, a9
40380b9c:	03ad      	mov.n	a10, a3
40380b9e:	ce5881        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40380ba1:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
40380ba4:	142182        	l32i	a8, a1, 80
40380ba7:	338a      	add.n	a3, a3, a8
        length = length - data_len;
40380ba9:	c04470        	sub	a4, a4, a7
40380bac:	554a      	add.n	a5, a5, a4
        address += data_len;
40380bae:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
40380bb0:	180c      	movi.n	a8, 1
40380bb2:	838550        	moveqz	a8, a5, a5
40380bb5:	152192        	l32i	a9, a1, 84
40380bb8:	19cc      	bnez.n	a9, 40380bbd <spi_flash_chip_generic_read+0xa9>
40380bba:	f8f856        	bnez	a8, 40380b4d <spi_flash_chip_generic_read+0x39>
}
40380bbd:	152122        	l32i	a2, a1, 84
40380bc0:	f01d      	retw.n
	...

40380bc4 <spi_flash_chip_generic_write>:
{
40380bc4:	010136        	entry	a1, 128
40380bc7:	026d      	mov.n	a6, a2
40380bc9:	146132        	s32i	a3, a1, 80
    const uint32_t page_size = chip->chip_drv->page_size;
40380bcc:	1288      	l32i.n	a8, a2, 4
40380bce:	132882        	l32i	a8, a8, 76
40380bd1:	156182        	s32i	a8, a1, 84
    esp_err_t err = ESP_OK;
40380bd4:	0a0c      	movi.n	a10, 0
    while (err == ESP_OK && length > 0) {
40380bd6:	001f06        	j	40380c56 <spi_flash_chip_generic_write+0x92>
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
40380bd9:	214b      	addi.n	a2, a1, 4
40380bdb:	0c4c      	movi.n	a12, 64
40380bdd:	ffa0b2        	movi	a11, 255
40380be0:	02ad      	mov.n	a10, a2
40380be2:	ce3581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380be5:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
40380be8:	06a8      	l32i.n	a10, a6, 0
40380bea:	0a88      	l32i.n	a8, a10, 0
40380bec:	a888      	l32i.n	a8, a8, 40
40380bee:	1521e2        	l32i	a14, a1, 84
40380bf1:	01dd      	mov.n	a13, a1
40380bf3:	05cd      	mov.n	a12, a5
40380bf5:	04bd      	mov.n	a11, a4
40380bf7:	0008e0        	callx8	a8
40380bfa:	0a9d      	mov.n	a9, a10
40380bfc:	1661a2        	s32i	a10, a1, 88
        uint32_t left_off = address - align_address;
40380bff:	0188      	l32i.n	a8, a1, 0
40380c01:	c0a480        	sub	a10, a4, a8
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
40380c04:	745a      	add.n	a7, a4, a5
40380c06:	889a      	add.n	a8, a8, a9
40380c08:	637780        	minu	a7, a7, a8
40380c0b:	c08740        	sub	a8, a7, a4
40380c0e:	176182        	s32i	a8, a1, 92
        memcpy(temp_buffer + left_off, buffer, write_len);
40380c11:	08cd      	mov.n	a12, a8
40380c13:	1421b2        	l32i	a11, a1, 80
40380c16:	a2aa      	add.n	a10, a2, a10
40380c18:	ce3a81        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40380c1b:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
40380c1e:	1688      	l32i.n	a8, a6, 4
40380c20:	b888      	l32i.n	a8, a8, 44
40380c22:	0b0c      	movi.n	a11, 0
40380c24:	06ad      	mov.n	a10, a6
40380c26:	0008e0        	callx8	a8
        if (err == ESP_OK && length > 0) {
40380c29:	40fa80        	nsau	a8, a10
40380c2c:	418580        	srli	a8, a8, 5
40380c2f:	230837        	bnone	a8, a3, 40380c56 <spi_flash_chip_generic_write+0x92>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
40380c32:	1688      	l32i.n	a8, a6, 4
40380c34:	122882        	l32i	a8, a8, 72
40380c37:	1621d2        	l32i	a13, a1, 88
40380c3a:	01c8      	l32i.n	a12, a1, 0
40380c3c:	20b220        	or	a11, a2, a2
40380c3f:	06ad      	mov.n	a10, a6
40380c41:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + write_len);
40380c44:	142182        	l32i	a8, a1, 80
40380c47:	172192        	l32i	a9, a1, 92
40380c4a:	889a      	add.n	a8, a8, a9
40380c4c:	146182        	s32i	a8, a1, 80
            length -= write_len;
40380c4f:	c04470        	sub	a4, a4, a7
40380c52:	554a      	add.n	a5, a5, a4
            address += write_len;
40380c54:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
40380c56:	130c      	movi.n	a3, 1
40380c58:	833550        	moveqz	a3, a5, a5
40380c5b:	1acc      	bnez.n	a10, 40380c60 <spi_flash_chip_generic_write+0x9c>
40380c5d:	f78356        	bnez	a3, 40380bd9 <spi_flash_chip_generic_write+0x15>
}
40380c60:	0a2d      	mov.n	a2, a10
40380c62:	f01d      	retw.n

40380c64 <spi_flash_chip_generic_get_write_protect>:
{
40380c64:	006136        	entry	a1, 48
40380c67:	02ad      	mov.n	a10, a2
    assert(out_write_protect!=NULL);
40380c69:	d3cc      	bnez.n	a3, 40380c7a <spi_flash_chip_generic_get_write_protect+0x16>
40380c6b:	d126d1        	l32r	a13, 40375104 <_iram_text_start+0xd00> (3fc940cc <__func__$0+0x4e0>)
40380c6e:	d126c1        	l32r	a12, 40375108 <_iram_text_start+0xd04> (3fc948a8 <__func__$0>)
40380c71:	4aa1b2        	movi	a11, 0x14a
40380c74:	d126a1        	l32r	a10, 4037510c <_iram_text_start+0xd08> (3fc940ff <__func__$0+0x513>)
40380c77:	ff0b25        	call8	4037fd28 <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
40380c7a:	1288      	l32i.n	a8, a2, 4
40380c7c:	192882        	l32i	a8, a8, 100
40380c7f:	01cd      	mov.n	a12, a1
40380c81:	1b0c      	movi.n	a11, 1
40380c83:	0008e0        	callx8	a8
40380c86:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40380c88:	eacc      	bnez.n	a10, 40380c9a <spi_flash_chip_generic_get_write_protect+0x36>
    *out_write_protect = ((status & SR_WREN) == 0);
40380c8a:	280c      	movi.n	a8, 2
40380c8c:	0198      	l32i.n	a9, a1, 0
40380c8e:	108890        	and	a8, a8, a9
40380c91:	40f880        	nsau	a8, a8
40380c94:	418580        	srli	a8, a8, 5
40380c97:	004382        	s8i	a8, a3, 0
}
40380c9a:	f01d      	retw.n

40380c9c <spi_flash_chip_generic_yield>:
{
40380c9c:	006136        	entry	a1, 48
40380c9f:	027d      	mov.n	a7, a2
    uint32_t flags = wip? 1: 0; //check_yield() and yield() impls should not issue suspend/resume if this flag is zero
40380ca1:	1b0c      	movi.n	a11, 1
40380ca3:	83b330        	moveqz	a11, a3, a3
    if (chip->os_func->check_yield) {
40380ca6:	2288      	l32i.n	a8, a2, 8
40380ca8:	6888      	l32i.n	a8, a8, 24
40380caa:	08bc      	beqz.n	a8, 40380cde <spi_flash_chip_generic_yield+0x42>
        err = chip->os_func->check_yield(chip->os_func_data, flags, &request);
40380cac:	c14b      	addi.n	a12, a1, 4
40380cae:	0322a2        	l32i	a10, a2, 12
40380cb1:	0008e0        	callx8	a8
40380cb4:	0a2d      	mov.n	a2, a10
        if (err == ESP_OK) {
40380cb6:	3adc      	bnez.n	a10, 40380ccd <spi_flash_chip_generic_yield+0x31>
            if (err == ESP_OK && (request & SPI_FLASH_YIELD_REQ_YIELD) != 0) {
40380cb8:	1188      	l32i.n	a8, a1, 4
40380cba:	226807        	bbci	a8, 0, 40380ce0 <spi_flash_chip_generic_yield+0x44>
                err = chip->os_func->yield(chip->os_func_data, &status);
40380cbd:	2788      	l32i.n	a8, a7, 8
40380cbf:	7888      	l32i.n	a8, a8, 28
40380cc1:	01bd      	mov.n	a11, a1
40380cc3:	37a8      	l32i.n	a10, a7, 12
40380cc5:	0008e0        	callx8	a8
40380cc8:	0a2d      	mov.n	a2, a10
40380cca:	000486        	j	40380ce0 <spi_flash_chip_generic_yield+0x44>
        } else if (err == ESP_ERR_TIMEOUT) {
40380ccd:	07a182        	movi	a8, 0x107
40380cd0:	021a87        	beq	a10, a8, 40380cd6 <spi_flash_chip_generic_yield+0x3a>
            abort();
40380cd3:	fef9a5        	call8	4037fc6c <abort>
            err = ESP_OK;
40380cd6:	020c      	movi.n	a2, 0
40380cd8:	000106        	j	40380ce0 <spi_flash_chip_generic_yield+0x44>
40380cdb:	000000        	ill
    esp_err_t err = ESP_OK;
40380cde:	020c      	movi.n	a2, 0
}
40380ce0:	f01d      	retw.n
	...

40380ce4 <spi_flash_chip_generic_read_unique_id>:
{
40380ce4:	00a136        	entry	a1, 80
    uint64_t unique_id_buf = 0;
40380ce7:	080c      	movi.n	a8, 0
40380ce9:	0189      	s32i.n	a8, a1, 0
40380ceb:	1189      	s32i.n	a8, a1, 4
    spi_flash_trans_t transfer = {
40380ced:	718b      	addi.n	a7, a1, 8
40380cef:	cc1c      	movi.n	a12, 28
40380cf1:	20b880        	or	a11, a8, a8
40380cf4:	07ad      	mov.n	a10, a7
40380cf6:	cdf081        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40380cf9:	0008e0        	callx8	a8
40380cfc:	880c      	movi.n	a8, 8
40380cfe:	0a4182        	s8i	a8, a1, 10
40380d01:	5119      	s32i.n	a1, a1, 20
40380d03:	b84c      	movi.n	a8, 75
40380d05:	0e5182        	s16i	a8, a1, 28
40380d08:	082c      	movi.n	a8, 32
40380d0a:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &transfer);
40380d0d:	02a8      	l32i.n	a10, a2, 0
40380d0f:	0a88      	l32i.n	a8, a10, 0
40380d11:	1888      	l32i.n	a8, a8, 4
40380d13:	07bd      	mov.n	a11, a7
40380d15:	0008e0        	callx8	a8
40380d18:	0a2d      	mov.n	a2, a10
    if (unique_id_buf == 0 || unique_id_buf == UINT64_MAX) {
40380d1a:	01a8      	l32i.n	a10, a1, 0
40380d1c:	11b8      	l32i.n	a11, a1, 4
40380d1e:	fc7c      	movi.n	a12, -1
40380d20:	8bca      	add.n	a8, a11, a12
40380d22:	9aca      	add.n	a9, a10, a12
40380d24:	01b9c7        	bgeu	a9, a12, 40380d29 <spi_flash_chip_generic_read_unique_id+0x45>
40380d27:	0b8d      	mov.n	a8, a11
40380d29:	2b0866        	bnei	a8, -1, 40380d58 <spi_flash_chip_generic_read_unique_id+0x74>
40380d2c:	d87c      	movi.n	a8, -3
40380d2e:	26b897        	bgeu	a8, a9, 40380d58 <spi_flash_chip_generic_read_unique_id+0x74>
40380d31:	cdd381        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40380d34:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "No response from device when trying to retrieve Unique ID\n");
40380d36:	010816        	beqz	a8, 40380d4a <spi_flash_chip_generic_read_unique_id+0x66>
40380d39:	feeca5        	call8	4037fc04 <esp_log_timestamp>
40380d3c:	d0f0c1        	l32r	a12, 403750fc <_iram_text_start+0xcf8> (3fc94958 <TAG>)
40380d3f:	0abd      	mov.n	a11, a10
40380d41:	d0f3a1        	l32r	a10, 40375110 <_iram_text_start+0xd0c> (3fc94118 <__func__$0+0x52c>)
40380d44:	cde681        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40380d47:	0008e0        	callx8	a8
        *flash_unique_id = unique_id_buf;
40380d4a:	0188      	l32i.n	a8, a1, 0
40380d4c:	1198      	l32i.n	a9, a1, 4
40380d4e:	0389      	s32i.n	a8, a3, 0
40380d50:	1399      	s32i.n	a9, a3, 4
        return ESP_ERR_NOT_SUPPORTED;
40380d52:	06a122        	movi	a2, 0x106
40380d55:	000246        	j	40380d62 <spi_flash_chip_generic_read_unique_id+0x7e>
    *flash_unique_id = __builtin_bswap64(unique_id_buf);
40380d58:	d0ef81        	l32r	a8, 40375114 <_iram_text_start+0xd10> (400021cc <__bswapdi2>)
40380d5b:	0008e0        	callx8	a8
40380d5e:	03a9      	s32i.n	a10, a3, 0
40380d60:	13b9      	s32i.n	a11, a3, 4
}
40380d62:	f01d      	retw.n

40380d64 <spi_flash_common_read_status_8b_rdsr2>:
{
40380d64:	004136        	entry	a1, 32
40380d67:	20a220        	or	a10, a2, a2
40380d6a:	20d330        	or	a13, a3, a3
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, out_sr);
40380d6d:	08a0c2        	movi	a12, 8
40380d70:	5b3c      	movi.n	a11, 53
40380d72:	ffcb65        	call8	40380a28 <spi_flash_common_read_qe_sr>
}
40380d75:	0a2d      	mov.n	a2, a10
40380d77:	f01d      	retw.n
40380d79:	000000        	ill

40380d7c <spi_flash_chip_generic_get_io_mode>:
{
40380d7c:	006136        	entry	a1, 48
40380d7f:	20a220        	or	a10, a2, a2
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
40380d82:	20b110        	or	a11, a1, a1
40380d85:	fffde5        	call8	40380d64 <spi_flash_common_read_status_8b_rdsr2>
40380d88:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40380d8b:	9acc      	bnez.n	a10, 40380d98 <spi_flash_chip_generic_get_io_mode+0x1c>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40380d8d:	0188      	l32i.n	a8, a1, 0
40380d8f:	888a      	add.n	a8, a8, a8
40380d91:	490c      	movi.n	a9, 4
40380d93:	108890        	and	a8, a8, a9
40380d96:	0389      	s32i.n	a8, a3, 0
}
40380d98:	f01d      	retw.n
	...

40380d9c <spi_flash_common_read_status_8b_rdsr>:
{
40380d9c:	004136        	entry	a1, 32
40380d9f:	20a220        	or	a10, a2, a2
40380da2:	20d330        	or	a13, a3, a3
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
40380da5:	08a0c2        	movi	a12, 8
40380da8:	5b0c      	movi.n	a11, 5
40380daa:	ffc7e5        	call8	40380a28 <spi_flash_common_read_qe_sr>
}
40380dad:	0a2d      	mov.n	a2, a10
40380daf:	f01d      	retw.n
40380db1:	000000        	ill

40380db4 <spi_flash_common_write_status_8b_wrsr>:
{
40380db4:	004136        	entry	a1, 32
40380db7:	20a220        	or	a10, a2, a2
40380dba:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 8, sr);
40380dbd:	08a0c2        	movi	a12, 8
40380dc0:	1b0c      	movi.n	a11, 1
40380dc2:	ffc9a5        	call8	40380a5c <spi_flash_common_write_qe_sr>
}
40380dc5:	0a2d      	mov.n	a2, a10
40380dc7:	f01d      	retw.n
40380dc9:	000000        	ill

40380dcc <spi_flash_common_write_status_8b_wrsr2>:
{
40380dcc:	004136        	entry	a1, 32
40380dcf:	20a220        	or	a10, a2, a2
40380dd2:	20d330        	or	a13, a3, a3
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR2, 8, sr);
40380dd5:	08a0c2        	movi	a12, 8
40380dd8:	1b3c      	movi.n	a11, 49
40380dda:	ffc825        	call8	40380a5c <spi_flash_common_write_qe_sr>
}
40380ddd:	0a2d      	mov.n	a2, a10
40380ddf:	f01d      	retw.n
40380de1:	000000        	ill

40380de4 <spi_flash_chip_generic_set_io_mode>:
{
40380de4:	004136        	entry	a1, 32
40380de7:	20a220        	or	a10, a2, a2
    return spi_flash_common_set_io_mode(chip,
40380dea:	00a2d2        	movi	a13, 0x200
40380ded:	d0bcc1        	l32r	a12, 403750e0 <_iram_text_start+0xcdc> (40380a8c <spi_flash_common_read_status_16b_rdsr_rdsr2>)
40380df0:	d0bdb1        	l32r	a11, 403750e4 <_iram_text_start+0xce0> (40380ac4 <spi_flash_common_write_status_16b_wrsr>)
40380df3:	0032a5        	call8	4038111c <spi_flash_common_set_io_mode>
}
40380df6:	202aa0        	or	a2, a10, a10
40380df9:	000090        	retw

40380dfc <spi_flash_chip_generic_probe>:
{
40380dfc:	004136        	entry	a1, 32
}
40380dff:	020c      	movi.n	a2, 0
40380e01:	f01d      	retw.n
	...

40380e04 <spi_flash_chip_generic_erase_chip>:
{
40380e04:	004136        	entry	a1, 32
40380e07:	027d      	mov.n	a7, a2
    err = chip->chip_drv->set_chip_write_protect(chip, false);
40380e09:	1288      	l32i.n	a8, a2, 4
40380e0b:	b888      	l32i.n	a8, a8, 44
40380e0d:	0b0c      	movi.n	a11, 0
40380e0f:	02ad      	mov.n	a10, a2
40380e11:	0008e0        	callx8	a8
40380e14:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380e16:	eacc      	bnez.n	a10, 40380e28 <spi_flash_chip_generic_erase_chip+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380e18:	1788      	l32i.n	a8, a7, 4
40380e1a:	152892        	l32i	a9, a8, 84
40380e1d:	1888      	l32i.n	a8, a8, 4
40380e1f:	08b8      	l32i.n	a11, a8, 0
40380e21:	07ad      	mov.n	a10, a7
40380e23:	0009e0        	callx8	a9
40380e26:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380e28:	40f290        	nsau	a9, a2
40380e2b:	419590        	srli	a9, a9, 5
40380e2e:	faae82        	movi	a8, 0xfffffefa
40380e31:	828a      	add.n	a8, a2, a8
40380e33:	40f880        	nsau	a8, a8
40380e36:	418580        	srli	a8, a8, 5
40380e39:	209980        	or	a9, a9, a8
40380e3c:	050916        	beqz	a9, 40380e90 <spi_flash_chip_generic_erase_chip+0x8c>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380e3f:	2788      	l32i.n	a8, a7, 8
40380e41:	9888      	l32i.n	a8, a8, 36
40380e43:	388c      	beqz.n	a8, 40380e4a <spi_flash_chip_generic_erase_chip+0x46>
40380e45:	1a0c      	movi.n	a10, 1
40380e47:	0008e0        	callx8	a8
        chip->host->driver->erase_chip(chip->host);
40380e4a:	07a8      	l32i.n	a10, a7, 0
40380e4c:	002a82        	l32i	a8, a10, 0
40380e4f:	3888      	l32i.n	a8, a8, 12
40380e51:	0008e0        	callx8	a8
        chip->busy = 1;
40380e54:	7788      	l32i.n	a8, a7, 28
40380e56:	190c      	movi.n	a9, 1
40380e58:	208890        	or	a8, a8, a9
40380e5b:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
40380e5d:	1788      	l32i.n	a8, a7, 4
40380e5f:	152892        	l32i	a9, a8, 84
40380e62:	012882        	l32i	a8, a8, 4
40380e65:	0128b2        	l32i	a11, a8, 4
40380e68:	20a770        	or	a10, a7, a7
40380e6b:	0009e0        	callx8	a9
40380e6e:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380e70:	2788      	l32i.n	a8, a7, 8
40380e72:	9888      	l32i.n	a8, a8, 36
40380e74:	005816        	beqz	a8, 40380e7d <spi_flash_chip_generic_erase_chip+0x79>
40380e77:	00a0a2        	movi	a10, 0
40380e7a:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380e7d:	06a182        	movi	a8, 0x106
40380e80:	0c9287        	bne	a2, a8, 40380e90 <spi_flash_chip_generic_erase_chip+0x8c>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380e83:	1788      	l32i.n	a8, a7, 4
40380e85:	b888      	l32i.n	a8, a8, 44
40380e87:	1b0c      	movi.n	a11, 1
40380e89:	07ad      	mov.n	a10, a7
40380e8b:	0008e0        	callx8	a8
40380e8e:	0a2d      	mov.n	a2, a10
}
40380e90:	f01d      	retw.n
	...

40380e94 <spi_flash_chip_generic_erase_sector>:
{
40380e94:	004136        	entry	a1, 32
40380e97:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40380e99:	1288      	l32i.n	a8, a2, 4
40380e9b:	b888      	l32i.n	a8, a8, 44
40380e9d:	0b0c      	movi.n	a11, 0
40380e9f:	02ad      	mov.n	a10, a2
40380ea1:	0008e0        	callx8	a8
40380ea4:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380ea6:	eacc      	bnez.n	a10, 40380eb8 <spi_flash_chip_generic_erase_sector+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380ea8:	1788      	l32i.n	a8, a7, 4
40380eaa:	152892        	l32i	a9, a8, 84
40380ead:	1888      	l32i.n	a8, a8, 4
40380eaf:	08b8      	l32i.n	a11, a8, 0
40380eb1:	07ad      	mov.n	a10, a7
40380eb3:	0009e0        	callx8	a9
40380eb6:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380eb8:	40f290        	nsau	a9, a2
40380ebb:	419590        	srli	a9, a9, 5
40380ebe:	faae82        	movi	a8, 0xfffffefa
40380ec1:	828a      	add.n	a8, a2, a8
40380ec3:	40f880        	nsau	a8, a8
40380ec6:	418580        	srli	a8, a8, 5
40380ec9:	209980        	or	a9, a9, a8
40380ecc:	04c916        	beqz	a9, 40380f1c <spi_flash_chip_generic_erase_sector+0x88>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380ecf:	2788      	l32i.n	a8, a7, 8
40380ed1:	9888      	l32i.n	a8, a8, 36
40380ed3:	388c      	beqz.n	a8, 40380eda <spi_flash_chip_generic_erase_sector+0x46>
40380ed5:	1a0c      	movi.n	a10, 1
40380ed7:	0008e0        	callx8	a8
        chip->host->driver->erase_sector(chip->host, start_address);
40380eda:	07a8      	l32i.n	a10, a7, 0
40380edc:	0a88      	l32i.n	a8, a10, 0
40380ede:	4888      	l32i.n	a8, a8, 16
40380ee0:	03bd      	mov.n	a11, a3
40380ee2:	0008e0        	callx8	a8
        chip->busy = 1;
40380ee5:	7788      	l32i.n	a8, a7, 28
40380ee7:	190c      	movi.n	a9, 1
40380ee9:	208890        	or	a8, a8, a9
40380eec:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40380eee:	1788      	l32i.n	a8, a7, 4
40380ef0:	152892        	l32i	a9, a8, 84
40380ef3:	1888      	l32i.n	a8, a8, 4
40380ef5:	38b8      	l32i.n	a11, a8, 12
40380ef7:	07ad      	mov.n	a10, a7
40380ef9:	0009e0        	callx8	a9
40380efc:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380efe:	2788      	l32i.n	a8, a7, 8
40380f00:	9888      	l32i.n	a8, a8, 36
40380f02:	388c      	beqz.n	a8, 40380f09 <spi_flash_chip_generic_erase_sector+0x75>
40380f04:	0a0c      	movi.n	a10, 0
40380f06:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380f09:	06a182        	movi	a8, 0x106
40380f0c:	0c9287        	bne	a2, a8, 40380f1c <spi_flash_chip_generic_erase_sector+0x88>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380f0f:	1788      	l32i.n	a8, a7, 4
40380f11:	b888      	l32i.n	a8, a8, 44
40380f13:	1b0c      	movi.n	a11, 1
40380f15:	07ad      	mov.n	a10, a7
40380f17:	0008e0        	callx8	a8
40380f1a:	0a2d      	mov.n	a2, a10
}
40380f1c:	f01d      	retw.n
	...

40380f20 <spi_flash_chip_generic_erase_block>:
{
40380f20:	004136        	entry	a1, 32
40380f23:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40380f25:	1288      	l32i.n	a8, a2, 4
40380f27:	b888      	l32i.n	a8, a8, 44
40380f29:	0b0c      	movi.n	a11, 0
40380f2b:	02ad      	mov.n	a10, a2
40380f2d:	0008e0        	callx8	a8
40380f30:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40380f32:	eacc      	bnez.n	a10, 40380f44 <spi_flash_chip_generic_erase_block+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380f34:	1788      	l32i.n	a8, a7, 4
40380f36:	152892        	l32i	a9, a8, 84
40380f39:	1888      	l32i.n	a8, a8, 4
40380f3b:	08b8      	l32i.n	a11, a8, 0
40380f3d:	07ad      	mov.n	a10, a7
40380f3f:	0009e0        	callx8	a9
40380f42:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380f44:	40f290        	nsau	a9, a2
40380f47:	419590        	srli	a9, a9, 5
40380f4a:	faae82        	movi	a8, 0xfffffefa
40380f4d:	828a      	add.n	a8, a2, a8
40380f4f:	40f880        	nsau	a8, a8
40380f52:	418580        	srli	a8, a8, 5
40380f55:	209980        	or	a9, a9, a8
40380f58:	04c916        	beqz	a9, 40380fa8 <spi_flash_chip_generic_erase_block+0x88>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40380f5b:	2788      	l32i.n	a8, a7, 8
40380f5d:	9888      	l32i.n	a8, a8, 36
40380f5f:	388c      	beqz.n	a8, 40380f66 <spi_flash_chip_generic_erase_block+0x46>
40380f61:	1a0c      	movi.n	a10, 1
40380f63:	0008e0        	callx8	a8
        chip->host->driver->erase_block(chip->host, start_address);
40380f66:	07a8      	l32i.n	a10, a7, 0
40380f68:	0a88      	l32i.n	a8, a10, 0
40380f6a:	5888      	l32i.n	a8, a8, 20
40380f6c:	03bd      	mov.n	a11, a3
40380f6e:	0008e0        	callx8	a8
        chip->busy = 1;
40380f71:	7788      	l32i.n	a8, a7, 28
40380f73:	190c      	movi.n	a9, 1
40380f75:	208890        	or	a8, a8, a9
40380f78:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
40380f7a:	1788      	l32i.n	a8, a7, 4
40380f7c:	152892        	l32i	a9, a8, 84
40380f7f:	1888      	l32i.n	a8, a8, 4
40380f81:	28b8      	l32i.n	a11, a8, 8
40380f83:	07ad      	mov.n	a10, a7
40380f85:	0009e0        	callx8	a9
40380f88:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40380f8a:	2788      	l32i.n	a8, a7, 8
40380f8c:	9888      	l32i.n	a8, a8, 36
40380f8e:	388c      	beqz.n	a8, 40380f95 <spi_flash_chip_generic_erase_block+0x75>
40380f90:	0a0c      	movi.n	a10, 0
40380f92:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40380f95:	06a182        	movi	a8, 0x106
40380f98:	0c9287        	bne	a2, a8, 40380fa8 <spi_flash_chip_generic_erase_block+0x88>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40380f9b:	1788      	l32i.n	a8, a7, 4
40380f9d:	b888      	l32i.n	a8, a8, 44
40380f9f:	1b0c      	movi.n	a11, 1
40380fa1:	07ad      	mov.n	a10, a7
40380fa3:	0008e0        	callx8	a8
40380fa6:	0a2d      	mov.n	a2, a10
}
40380fa8:	f01d      	retw.n
	...

40380fac <spi_flash_chip_generic_page_program>:
{
40380fac:	004136        	entry	a1, 32
40380faf:	027d      	mov.n	a7, a2
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40380fb1:	1288      	l32i.n	a8, a2, 4
40380fb3:	152892        	l32i	a9, a8, 84
40380fb6:	1888      	l32i.n	a8, a8, 4
40380fb8:	0028b2        	l32i	a11, a8, 0
40380fbb:	02ad      	mov.n	a10, a2
40380fbd:	0009e0        	callx8	a9
40380fc0:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40380fc2:	40fa90        	nsau	a9, a10
40380fc5:	419590        	srli	a9, a9, 5
40380fc8:	faae82        	movi	a8, 0xfffffefa
40380fcb:	8a8a      	add.n	a8, a10, a8
40380fcd:	40f880        	nsau	a8, a8
40380fd0:	418580        	srli	a8, a8, 5
40380fd3:	209980        	or	a9, a9, a8
40380fd6:	c9bc      	beqz.n	a9, 40381016 <spi_flash_chip_generic_page_program+0x6a>
        chip->host->driver->program_page(chip->host, buffer, address, length);
40380fd8:	07a8      	l32i.n	a10, a7, 0
40380fda:	0a88      	l32i.n	a8, a10, 0
40380fdc:	8888      	l32i.n	a8, a8, 32
40380fde:	05dd      	mov.n	a13, a5
40380fe0:	20c440        	or	a12, a4, a4
40380fe3:	03bd      	mov.n	a11, a3
40380fe5:	0008e0        	callx8	a8
        chip->busy = 1;
40380fe8:	7788      	l32i.n	a8, a7, 28
40380fea:	190c      	movi.n	a9, 1
40380fec:	208890        	or	a8, a8, a9
40380fef:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40380ff1:	1788      	l32i.n	a8, a7, 4
40380ff3:	152892        	l32i	a9, a8, 84
40380ff6:	1888      	l32i.n	a8, a8, 4
40380ff8:	0428b2        	l32i	a11, a8, 16
40380ffb:	07ad      	mov.n	a10, a7
40380ffd:	0009e0        	callx8	a9
40381000:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381002:	06a182        	movi	a8, 0x106
40381005:	0d9a87        	bne	a10, a8, 40381016 <spi_flash_chip_generic_page_program+0x6a>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381008:	1788      	l32i.n	a8, a7, 4
4038100a:	b888      	l32i.n	a8, a8, 44
4038100c:	01a0b2        	movi	a11, 1
4038100f:	07ad      	mov.n	a10, a7
40381011:	0008e0        	callx8	a8
40381014:	0a2d      	mov.n	a2, a10
}
40381016:	f01d      	retw.n

40381018 <spi_flash_chip_generic_set_write_protect>:
{
40381018:	006136        	entry	a1, 48
4038101b:	743030        	extui	a3, a3, 0, 8
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4038101e:	1288      	l32i.n	a8, a2, 4
40381020:	152892        	l32i	a9, a8, 84
40381023:	1888      	l32i.n	a8, a8, 4
40381025:	08b8      	l32i.n	a11, a8, 0
40381027:	02ad      	mov.n	a10, a2
40381029:	0009e0        	callx8	a9
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4038102c:	40fa90        	nsau	a9, a10
4038102f:	419590        	srli	a9, a9, 5
40381032:	faae82        	movi	a8, 0xfffffefa
40381035:	8a8a      	add.n	a8, a10, a8
40381037:	40f880        	nsau	a8, a8
4038103a:	418580        	srli	a8, a8, 5
4038103d:	209980        	or	a9, a9, a8
40381040:	998c      	beqz.n	a9, 4038104d <spi_flash_chip_generic_set_write_protect+0x35>
        chip->host->driver->set_write_protect(chip->host, write_protect);
40381042:	02a8      	l32i.n	a10, a2, 0
40381044:	0a88      	l32i.n	a8, a10, 0
40381046:	7888      	l32i.n	a8, a8, 28
40381048:	03bd      	mov.n	a11, a3
4038104a:	0008e0        	callx8	a8
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
4038104d:	1288      	l32i.n	a8, a2, 4
4038104f:	a888      	l32i.n	a8, a8, 40
40381051:	01bd      	mov.n	a11, a1
40381053:	02ad      	mov.n	a10, a2
40381055:	0008e0        	callx8	a8
40381058:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
4038105a:	7acc      	bnez.n	a10, 40381065 <spi_flash_chip_generic_set_write_protect+0x4d>
4038105c:	000182        	l8ui	a8, a1, 0
4038105f:	021837        	beq	a8, a3, 40381065 <spi_flash_chip_generic_set_write_protect+0x4d>
        err = ESP_ERR_NOT_FOUND;
40381062:	05a122        	movi	a2, 0x105
}
40381065:	f01d      	retw.n
	...

40381068 <spi_flash_chip_generic_read_reg>:
{
40381068:	004136        	entry	a1, 32
4038106b:	04bd      	mov.n	a11, a4
    return chip->host->driver->read_status(chip->host, (uint8_t*)out_reg);
4038106d:	02a8      	l32i.n	a10, a2, 0
4038106f:	0a88      	l32i.n	a8, a10, 0
40381071:	6888      	l32i.n	a8, a8, 24
40381073:	0008e0        	callx8	a8
}
40381076:	0a2d      	mov.n	a2, a10
40381078:	f01d      	retw.n
	...

4038107c <spi_flash_chip_generic_wait_idle>:
{
4038107c:	006136        	entry	a1, 48
    if (timeout_us == ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT) {
4038107f:	040326        	beqi	a3, -1, 40381087 <spi_flash_chip_generic_wait_idle+0xb>
40381082:	037d      	mov.n	a7, a3
40381084:	000046        	j	40381089 <spi_flash_chip_generic_wait_idle+0xd>
        timeout_us = 0;// In order to go into while
40381087:	070c      	movi.n	a7, 0
    timeout_us++; // allow at least one pass before timeout, last one has no sleep cycle
40381089:	771b      	addi.n	a7, a7, 1
    while (timeout_us > 0) {
4038108b:	001c86        	j	40381101 <spi_flash_chip_generic_wait_idle+0x85>
4038108e:	000000        	ill
            if (timeout_us > 1) {
40381091:	1327b6        	bltui	a7, 2, 403810a8 <spi_flash_chip_generic_wait_idle+0x2c>
                int delay = MIN(HOST_DELAY_INTERVAL_US, timeout_us);
40381094:	150c      	movi.n	a5, 1
40381096:	635750        	minu	a5, a7, a5
                chip->os_func->delay_us(chip->os_func_data, delay);
40381099:	2288      	l32i.n	a8, a2, 8
4038109b:	3888      	l32i.n	a8, a8, 12
4038109d:	05bd      	mov.n	a11, a5
4038109f:	0322a2        	l32i	a10, a2, 12
403810a2:	0008e0        	callx8	a8
                timeout_us -= delay;
403810a5:	c07750        	sub	a7, a7, a5
        while (!chip->host->driver->host_status(chip->host) && timeout_us > 0) {
403810a8:	02a8      	l32i.n	a10, a2, 0
403810aa:	0a88      	l32i.n	a8, a10, 0
403810ac:	e888      	l32i.n	a8, a8, 56
403810ae:	0008e0        	callx8	a8
403810b1:	1acc      	bnez.n	a10, 403810b6 <spi_flash_chip_generic_wait_idle+0x3a>
403810b3:	fda756        	bnez	a7, 40381091 <spi_flash_chip_generic_wait_idle+0x15>
        esp_err_t err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &read);
403810b6:	1288      	l32i.n	a8, a2, 4
403810b8:	192882        	l32i	a8, a8, 100
403810bb:	01cd      	mov.n	a12, a1
403810bd:	1b0c      	movi.n	a11, 1
403810bf:	02ad      	mov.n	a10, a2
403810c1:	0008e0        	callx8	a8
        if (err != ESP_OK) {
403810c4:	048a56        	bnez	a10, 40381110 <spi_flash_chip_generic_wait_idle+0x94>
        status = read;
403810c7:	0188      	l32i.n	a8, a1, 0
        if ((status & SR_WIP) == 0 && (suspend_state == false)) { // Verify write in progress is complete
403810c9:	11e807        	bbsi	a8, 0, 403810de <spi_flash_chip_generic_wait_idle+0x62>
            if (chip->busy == 1) {
403810cc:	7298      	l32i.n	a9, a2, 28
403810ce:	326907        	bbci	a9, 0, 40381104 <spi_flash_chip_generic_wait_idle+0x88>
                chip->busy = 0;
403810d1:	ea7c      	movi.n	a10, -2
403810d3:	1099a0        	and	a9, a9, a10
403810d6:	7299      	s32i.n	a9, a2, 28
                if ((status & SR_WREN) != 0) { // The previous command is not accepted, leaving the WEL still set.
403810d8:	286817        	bbci	a8, 1, 40381104 <spi_flash_chip_generic_wait_idle+0x88>
403810db:	000706        	j	403810fb <spi_flash_chip_generic_wait_idle+0x7f>
        if (timeout_us > 0 && interval > 0) {
403810de:	f79c      	beqz.n	a7, 40381101 <spi_flash_chip_generic_wait_idle+0x85>
            int delay = MIN(interval, timeout_us);
403810e0:	451c      	movi.n	a5, 20
403810e2:	635750        	minu	a5, a7, a5
            chip->os_func->delay_us(chip->os_func_data, delay);
403810e5:	2288      	l32i.n	a8, a2, 8
403810e7:	3888      	l32i.n	a8, a8, 12
403810e9:	05bd      	mov.n	a11, a5
403810eb:	32a8      	l32i.n	a10, a2, 12
403810ed:	0008e0        	callx8	a8
            if (timeout_en) {
403810f0:	0d0326        	beqi	a3, -1, 40381101 <spi_flash_chip_generic_wait_idle+0x85>
                timeout_us -= delay;
403810f3:	c07750        	sub	a7, a7, a5
403810f6:	0001c6        	j	40381101 <spi_flash_chip_generic_wait_idle+0x85>
403810f9:	a20000        	muluh	a0, a0, a0
                    return ESP_ERR_NOT_SUPPORTED;
403810fc:	8606a1        	l32r	a10, 40362914 <rom_rx_gain_force+0x35c4e8>
403810ff:	560003        	lsi	f0, a0, 0x158
    while (timeout_us > 0) {
40381102:	8cfa37        	bbsi	a10, 19, 40381092 <spi_flash_chip_generic_wait_idle+0x16>
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
40381105:	0a0c57        	bnone	a12, a5, 40381113 <spi_flash_chip_generic_wait_idle+0x97>
40381108:	000106        	j	40381110 <spi_flash_chip_generic_wait_idle+0x94>
4038110b:	a20000        	muluh	a0, a0, a0
4038110e:	2d07a1        	l32r	a10, 4034c52c <rom_rx_gain_force+0x346100>
}
40381111:	1d0a      	add.n	a1, a13, a0
40381113:	f0          	.byte	0xf0

40381114 <spi_flash_chip_generic_read_unique_id_none>:
{
40381114:	004136        	entry	a1, 32
}
40381117:	06a122        	movi	a2, 0x106
4038111a:	f01d      	retw.n

4038111c <spi_flash_common_set_io_mode>:
{
4038111c:	006136        	entry	a1, 48
4038111f:	027d      	mov.n	a7, a2
40381121:	4288      	l32i.n	a8, a2, 16
40381123:	fcc882        	addi	a8, a8, -4
    if (need_check) {
40381126:	0228b6        	bltui	a8, 2, 4038112c <spi_flash_common_set_io_mode+0x10>
40381129:	002146        	j	403811b2 <spi_flash_common_set_io_mode+0x96>
        ret = (*rdsr_func)(chip, &sr);
4038112c:	01bd      	mov.n	a11, a1
4038112e:	20a220        	or	a10, a2, a2
40381131:	0004e0        	callx8	a4
40381134:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40381136:	07aa56        	bnez	a10, 403811b4 <spi_flash_common_set_io_mode+0x98>
            sr_update = sr | qe_sr_bit;
40381139:	0188      	l32i.n	a8, a1, 0
4038113b:	206850        	or	a6, a8, a5
        if (sr != sr_update) {
4038113e:	724857        	ball	a8, a5, 403811b4 <spi_flash_common_set_io_mode+0x98>
        chip->chip_drv->set_chip_write_protect(chip, false);
40381141:	1788      	l32i.n	a8, a7, 4
40381143:	b888      	l32i.n	a8, a8, 44
40381145:	0b0c      	movi.n	a11, 0
40381147:	20a770        	or	a10, a7, a7
4038114a:	0008e0        	callx8	a8
        ret = (*wrsr_func)(chip, sr_update);
4038114d:	06bd      	mov.n	a11, a6
4038114f:	20a770        	or	a10, a7, a7
40381152:	0003e0        	callx8	a3
40381155:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
40381157:	da8c      	beqz.n	a10, 40381168 <spi_flash_common_set_io_mode+0x4c>
            chip->chip_drv->set_chip_write_protect(chip, true);
40381159:	1788      	l32i.n	a8, a7, 4
4038115b:	b888      	l32i.n	a8, a8, 44
4038115d:	1b0c      	movi.n	a11, 1
4038115f:	07ad      	mov.n	a10, a7
40381161:	0008e0        	callx8	a8
            return ret;
40381164:	001306        	j	403811b4 <spi_flash_common_set_io_mode+0x98>
40381167:	178800        	ee.stf.64.xp	f8, f1, a0, a8
        ret = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4038116a:	152892        	l32i	a9, a8, 84
4038116d:	1888      	l32i.n	a8, a8, 4
4038116f:	08b8      	l32i.n	a11, a8, 0
40381171:	07ad      	mov.n	a10, a7
40381173:	0009e0        	callx8	a9
40381176:	0a2d      	mov.n	a2, a10
        if (ret == ESP_ERR_NOT_SUPPORTED) {
40381178:	06a182        	movi	a8, 0x106
4038117b:	0a9a87        	bne	a10, a8, 40381189 <spi_flash_common_set_io_mode+0x6d>
            chip->chip_drv->set_chip_write_protect(chip, true);
4038117e:	1788      	l32i.n	a8, a7, 4
40381180:	b888      	l32i.n	a8, a8, 44
40381182:	1b0c      	movi.n	a11, 1
40381184:	07ad      	mov.n	a10, a7
40381186:	0008e0        	callx8	a8
        if (ret != ESP_OK && ret != ESP_ERR_NOT_SUPPORTED) {
40381189:	180c      	movi.n	a8, 1
4038118b:	838220        	moveqz	a8, a2, a2
4038118e:	faae92        	movi	a9, 0xfffffefa
40381191:	929a      	add.n	a9, a2, a9
40381193:	1a0c      	movi.n	a10, 1
40381195:	83a990        	moveqz	a10, a9, a9
40381198:	1888a7        	bany	a8, a10, 403811b4 <spi_flash_common_set_io_mode+0x98>
        ret = (*rdsr_func)(chip, &sr);
4038119b:	01bd      	mov.n	a11, a1
4038119d:	07ad      	mov.n	a10, a7
4038119f:	0004e0        	callx8	a4
403811a2:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
403811a4:	cacc      	bnez.n	a10, 403811b4 <spi_flash_common_set_io_mode+0x98>
        if (sr != sr_update) {
403811a6:	0188      	l32i.n	a8, a1, 0
403811a8:	081867        	beq	a8, a6, 403811b4 <spi_flash_common_set_io_mode+0x98>
            ret = ESP_ERR_FLASH_NO_RESPONSE;
403811ab:	08a122        	movi	a2, 0x108
403811ae:	000086        	j	403811b4 <spi_flash_common_set_io_mode+0x98>
403811b1:	020c00        	andb	b0, b12, b0
}
403811b4:	f01d      	retw.n
	...

403811b8 <spi_flash_chip_issi_probe>:
#include "spi_flash_defs.h"

/* Driver for ISSI flash chip, as used in ESP32 D2WD */

esp_err_t spi_flash_chip_issi_probe(esp_flash_t *chip, uint32_t flash_id)
{
403811b8:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x9D;
    if (flash_id >> 16 != MFG_ID) {
403811bb:	f59030        	extui	a9, a3, 16, 16
403811be:	9da082        	movi	a8, 157
403811c1:	109987        	bne	a9, a8, 403811d5 <spi_flash_chip_issi_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xCF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
403811c4:	cfd581        	l32r	a8, 40375118 <_iram_text_start+0xd14> (cf00 <UserFrameTotalSize+0xce00>)
403811c7:	103380        	and	a3, a3, a8
403811ca:	cca681        	l32r	a8, 40374464 <_iram_text_start+0x60> (4000 <UserFrameTotalSize+0x3f00>)
403811cd:	0b9387        	bne	a3, a8, 403811dc <spi_flash_chip_issi_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
403811d0:	020c      	movi.n	a2, 0
403811d2:	000246        	j	403811df <spi_flash_chip_issi_probe+0x27>
        return ESP_ERR_NOT_FOUND;
403811d5:	05a122        	movi	a2, 0x105
403811d8:	0000c6        	j	403811df <spi_flash_chip_issi_probe+0x27>
403811db:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
403811de:	f01d05        	call0	403713b0 <rom_rx_gain_force+0x36af84>
403811e1:	000000        	ill

403811e4 <spi_flash_chip_issi_set_io_mode>:
}

esp_err_t spi_flash_chip_issi_set_io_mode(esp_flash_t *chip)
{
403811e4:	004136        	entry	a1, 32
403811e7:	02ad      	mov.n	a10, a2
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    return spi_flash_common_set_io_mode(chip,
403811e9:	0d4c      	movi.n	a13, 64
403811eb:	cfccc1        	l32r	a12, 4037511c <_iram_text_start+0xd18> (40380d9c <spi_flash_common_read_status_8b_rdsr>)
403811ee:	cfccb1        	l32r	a11, 40375120 <_iram_text_start+0xd1c> (40380db4 <spi_flash_common_write_status_8b_wrsr>)
403811f1:	fff2a5        	call8	4038111c <spi_flash_common_set_io_mode>
                                        spi_flash_common_write_status_8b_wrsr,
                                        spi_flash_common_read_status_8b_rdsr,
                                        BIT_QE);
}
403811f4:	0a2d      	mov.n	a2, a10
403811f6:	f01d      	retw.n

403811f8 <spi_flash_chip_issi_get_io_mode>:

esp_err_t spi_flash_chip_issi_get_io_mode(esp_flash_t *chip, esp_flash_io_mode_t* out_io_mode)
{
403811f8:	006136        	entry	a1, 48
403811fb:	20a220        	or	a10, a2, a2
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    uint32_t sr;
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr(chip, &sr);
403811fe:	20b110        	or	a11, a1, a1
40381201:	ffb9a5        	call8	40380d9c <spi_flash_common_read_status_8b_rdsr>
40381204:	202aa0        	or	a2, a10, a10
    if (ret == ESP_OK) {
40381207:	aacc      	bnez.n	a10, 40381215 <spi_flash_chip_issi_get_io_mode+0x1d>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
40381209:	0188      	l32i.n	a8, a1, 0
4038120b:	418480        	srli	a8, a8, 4
4038120e:	490c      	movi.n	a9, 4
40381210:	108890        	and	a8, a8, a9
40381213:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
40381215:	f01d      	retw.n
	...

40381218 <spi_flash_chip_issi_get_caps>:

spi_flash_caps_t spi_flash_chip_issi_get_caps(esp_flash_t *chip)
{
40381218:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
4038121b:	420c      	movi.n	a2, 4
4038121d:	f01d      	retw.n
	...

40381220 <spi_flash_chip_mxic_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_detect_size(esp_flash_t *chip, uint32_t *size)
{
40381220:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40381223:	6288      	l32i.n	a8, a2, 24
    *size = 0;
40381225:	0c0c      	movi.n	a12, 0
40381227:	03c9      	s32i.n	a12, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
40381229:	f4a080        	extui	a10, a8, 0, 16
4038122c:	190c      	movi.n	a9, 1
4038122e:	0cbd      	mov.n	a11, a12
40381230:	83b9a0        	moveqz	a11, a9, a10
40381233:	cc90d1        	l32r	a13, 40374474 <_iram_text_start+0x70> (ffff <UserFrameTotalSize+0xfeff>)
40381236:	c0aad0        	sub	a10, a10, a13
40381239:	939ca0        	movnez	a9, a12, a10
4038123c:	209b90        	or	a9, a11, a9
4038123f:	99dc      	bnez.n	a9, 4038125c <spi_flash_chip_mxic_detect_size+0x3c>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    uint32_t mem_density = (id & 0xFF);
40381241:	748080        	extui	a8, a8, 0, 8
    if (mem_density > 0x30) { // For OPI chips
40381244:	093c      	movi.n	a9, 48
40381246:	02b987        	bgeu	a9, a8, 4038124c <spi_flash_chip_mxic_detect_size+0x2c>
        mem_density -= 0x20;
40381249:	e0c882        	addi	a8, a8, -32
    }

    *size = 1 << mem_density;
4038124c:	190c      	movi.n	a9, 1
4038124e:	401800        	ssl	a8
40381251:	a18900        	sll	a8, a9
40381254:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
40381256:	020c      	movi.n	a2, 0
40381258:	0000c6        	j	4038125f <spi_flash_chip_mxic_detect_size+0x3f>
4038125b:	8b2100        	moveqz.s	f2, f1, a0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4038125e:	00f01dcf 	ee.vmulas.s16.accx.ld.ip.qup	q0, a12, 208, q4, q3, q7, q0
	...

40381264 <spi_flash_chip_mxic_probe>:
{
40381264:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40381267:	f53030        	extui	a3, a3, 16, 16
4038126a:	c2a082        	movi	a8, 194
4038126d:	0b9387        	bne	a3, a8, 4038127c <spi_flash_chip_mxic_probe+0x18>
    if (chip->read_mode >= SPI_FLASH_OPI_FLAG) {
40381270:	4288      	l32i.n	a8, a2, 16
40381272:	f90c      	movi.n	a9, 15
40381274:	0c3987        	bltu	a9, a8, 40381284 <spi_flash_chip_mxic_probe+0x20>
    return ESP_OK;
40381277:	020c      	movi.n	a2, 0
40381279:	000286        	j	40381287 <spi_flash_chip_mxic_probe+0x23>
        return ESP_ERR_NOT_FOUND;
4038127c:	05a122        	movi	a2, 0x105
4038127f:	000106        	j	40381287 <spi_flash_chip_mxic_probe+0x23>
40381282:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40381285:	1d05a1        	l32r	a10, 4034869c <rom_rx_gain_force+0x342270>
}
40381288:	0000f0        	callx12	a0
	...

4038128c <spi_flash_chip_mxic_get_caps>:
#define spi_flash_chip_mxic_read_reg        spi_flash_chip_generic_read_reg

static const char chip_name[] = "mxic";

spi_flash_caps_t spi_flash_chip_mxic_get_caps(esp_flash_t *chip)
{
4038128c:	004136        	entry	a1, 32
    spi_flash_caps_t caps_flags = 0;
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // reading unique id is not supported.
    return caps_flags;
}
4038128f:	020c      	movi.n	a2, 0
40381291:	f01d      	retw.n
	...

40381294 <spi_flash_chip_mxic_opi_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_opi_detect_size(esp_flash_t *chip, uint32_t *size)
{
40381294:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
40381297:	62c8      	l32i.n	a12, a2, 24
    *size = 0;
40381299:	0b0c      	movi.n	a11, 0
4038129b:	03b9      	s32i.n	a11, a3, 0

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
4038129d:	f490c0        	extui	a9, a12, 0, 16
403812a0:	180c      	movi.n	a8, 1
403812a2:	0bad      	mov.n	a10, a11
403812a4:	83a890        	moveqz	a10, a8, a9
403812a7:	cc73d1        	l32r	a13, 40374474 <_iram_text_start+0x70> (ffff <UserFrameTotalSize+0xfeff>)
403812aa:	c099d0        	sub	a9, a9, a13
403812ad:	938b90        	movnez	a8, a11, a9
403812b0:	208a80        	or	a8, a10, a8
403812b3:	d8cc      	bnez.n	a8, 403812c4 <spi_flash_chip_mxic_opi_detect_size+0x30>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
    }

    *size = 1 << ((id & 0xFF) - 0x20);
403812b5:	180c      	movi.n	a8, 1
403812b7:	401c00        	ssl	a12
403812ba:	a18800        	sll	a8, a8
403812bd:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
403812bf:	0b2d      	mov.n	a2, a11
403812c1:	000086        	j	403812c7 <spi_flash_chip_mxic_opi_detect_size+0x33>
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
403812c4:	cf7121        	l32r	a2, 40375088 <_iram_text_start+0xc84> (6005 <UserFrameTotalSize+0x5f05>)
}
403812c7:	f01d      	retw.n
403812c9:	000000        	ill

403812cc <spi_flash_chip_mxic_opi_set_write_protect>:
    // reading unique id is not supported.
    return caps_flags;
}

esp_err_t spi_flash_chip_mxic_opi_set_write_protect(esp_flash_t *chip, bool write_protect)
{
403812cc:	008136        	entry	a1, 64
403812cf:	743030        	extui	a3, a3, 0, 8
    esp_err_t err = ESP_OK;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403812d2:	1288      	l32i.n	a8, a2, 4
403812d4:	152892        	l32i	a9, a8, 84
403812d7:	1888      	l32i.n	a8, a8, 4
403812d9:	0028b2        	l32i	a11, a8, 0
403812dc:	20a220        	or	a10, a2, a2
403812df:	0009e0        	callx8	a9
403812e2:	0a7d      	mov.n	a7, a10
    spi_flash_trans_t t = {};
403812e4:	cc1c      	movi.n	a12, 28
403812e6:	0b0c      	movi.n	a11, 0
403812e8:	01ad      	mov.n	a10, a1
403812ea:	cc7381        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403812ed:	0008e0        	callx8	a8
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403812f0:	40f790        	nsau	a9, a7
403812f3:	419590        	srli	a9, a9, 5
403812f6:	faae82        	movi	a8, 0xfffffefa
403812f9:	878a      	add.n	a8, a7, a8
403812fb:	40f880        	nsau	a8, a8
403812fe:	418580        	srli	a8, a8, 5
40381301:	209980        	or	a9, a9, a8
40381304:	a99c      	beqz.n	a9, 40381322 <spi_flash_chip_mxic_opi_set_write_protect+0x56>
        if(write_protect) {
40381306:	738c      	beqz.n	a3, 40381311 <spi_flash_chip_mxic_opi_set_write_protect+0x45>
            t.command = CMD_OPI_FLASH_MXIC(CMD_WRDI);
40381308:	04ab82        	movi	a8, 0xfffffb04
4038130b:	0a5182        	s16i	a8, a1, 20
4038130e:	000146        	j	40381317 <spi_flash_chip_mxic_opi_set_write_protect+0x4b>
        } else {
            t.command = CMD_OPI_FLASH_MXIC(CMD_WREN);
40381311:	06a982        	movi	a8, 0xfffff906
40381314:	0a5182        	s16i	a8, a1, 20
        }
        err = chip->host->driver->common_command(chip->host, &t);
40381317:	02a8      	l32i.n	a10, a2, 0
40381319:	0a88      	l32i.n	a8, a10, 0
4038131b:	1888      	l32i.n	a8, a8, 4
4038131d:	01bd      	mov.n	a11, a1
4038131f:	0008e0        	callx8	a8
    }

    bool wp_read;
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
40381322:	1288      	l32i.n	a8, a2, 4
40381324:	a888      	l32i.n	a8, a8, 40
40381326:	1cc1b2        	addi	a11, a1, 28
40381329:	02ad      	mov.n	a10, a2
4038132b:	0008e0        	callx8	a8
4038132e:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
40381330:	008a56        	bnez	a10, 4038133c <spi_flash_chip_mxic_opi_set_write_protect+0x70>
40381333:	1c0182        	l8ui	a8, a1, 28
40381336:	021837        	beq	a8, a3, 4038133c <spi_flash_chip_mxic_opi_set_write_protect+0x70>
        err = ESP_ERR_NOT_FOUND;
40381339:	05a122        	movi	a2, 0x105
    }
    return err;
}
4038133c:	f01d      	retw.n
	...

40381340 <spi_flash_chip_mxic_opi_erase_chip>:
    *out_write_protected = ((status & SR_WREN) == 0);
    return err;
}

esp_err_t spi_flash_chip_mxic_opi_erase_chip(esp_flash_t *chip)
{
40381340:	008136        	entry	a1, 64
40381343:	027d      	mov.n	a7, a2
    esp_err_t err;

    err = chip->chip_drv->set_chip_write_protect(chip, false);
40381345:	1288      	l32i.n	a8, a2, 4
40381347:	b888      	l32i.n	a8, a8, 44
40381349:	00a0b2        	movi	a11, 0
4038134c:	20a220        	or	a10, a2, a2
4038134f:	0008e0        	callx8	a8
40381352:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40381354:	0adc      	bnez.n	a10, 40381368 <spi_flash_chip_mxic_opi_erase_chip+0x28>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381356:	1788      	l32i.n	a8, a7, 4
40381358:	152892        	l32i	a9, a8, 84
4038135b:	1888      	l32i.n	a8, a8, 4
4038135d:	08b8      	l32i.n	a11, a8, 0
4038135f:	20a770        	or	a10, a7, a7
40381362:	0009e0        	callx8	a9
40381365:	202aa0        	or	a2, a10, a10
    }

    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381368:	40f290        	nsau	a9, a2
4038136b:	419590        	srli	a9, a9, 5
4038136e:	faae82        	movi	a8, 0xfffffefa
40381371:	828a      	add.n	a8, a2, a8
40381373:	40f880        	nsau	a8, a8
40381376:	418580        	srli	a8, a8, 5
40381379:	209980        	or	a9, a9, a8
4038137c:	048916        	beqz	a9, 403813c8 <spi_flash_chip_mxic_opi_erase_chip+0x88>
        // Do erase chip here.
        spi_flash_trans_t t = {
4038137f:	cc1c      	movi.n	a12, 28
40381381:	0b0c      	movi.n	a11, 0
40381383:	20a110        	or	a10, a1, a1
40381386:	cc4c81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40381389:	0008e0        	callx8	a8
4038138c:	cf6681        	l32r	a8, 40375124 <_iram_text_start+0xd20> (ffff9f60 <_rtc_reserved_end+0x9fef9f60>)
4038138f:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC_CHIP_ERASE,
        };
        err = chip->host->driver->common_command(chip->host, &t);
40381392:	07a8      	l32i.n	a10, a7, 0
40381394:	0a88      	l32i.n	a8, a10, 0
40381396:	1888      	l32i.n	a8, a8, 4
40381398:	20b110        	or	a11, a1, a1
4038139b:	0008e0        	callx8	a8
        chip->busy = 1;
4038139e:	7788      	l32i.n	a8, a7, 28
403813a0:	190c      	movi.n	a9, 1
403813a2:	208890        	or	a8, a8, a9
403813a5:	7789      	s32i.n	a8, a7, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
403813a7:	1788      	l32i.n	a8, a7, 4
403813a9:	152892        	l32i	a9, a8, 84
403813ac:	1888      	l32i.n	a8, a8, 4
403813ae:	18b8      	l32i.n	a11, a8, 4
403813b0:	07ad      	mov.n	a10, a7
403813b2:	0009e0        	callx8	a9
403813b5:	0a2d      	mov.n	a2, a10
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
403813b7:	06a182        	movi	a8, 0x106
403813ba:	0a9a87        	bne	a10, a8, 403813c8 <spi_flash_chip_mxic_opi_erase_chip+0x88>
        chip->chip_drv->set_chip_write_protect(chip, true);
403813bd:	1788      	l32i.n	a8, a7, 4
403813bf:	b888      	l32i.n	a8, a8, 44
403813c1:	1b0c      	movi.n	a11, 1
403813c3:	07ad      	mov.n	a10, a7
403813c5:	0008e0        	callx8	a8
    }

    return err;

}
403813c8:	f01d      	retw.n
	...

403813cc <spi_flash_chip_mxic_opi_erase_sector>:

esp_err_t spi_flash_chip_mxic_opi_erase_sector(esp_flash_t *chip, uint32_t start_address)
{
403813cc:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
403813cf:	1288      	l32i.n	a8, a2, 4
403813d1:	b888      	l32i.n	a8, a8, 44
403813d3:	0b0c      	movi.n	a11, 0
403813d5:	02ad      	mov.n	a10, a2
403813d7:	0008e0        	callx8	a8
    if (err == ESP_OK) {
403813da:	eacc      	bnez.n	a10, 403813ec <spi_flash_chip_mxic_opi_erase_sector+0x20>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403813dc:	1288      	l32i.n	a8, a2, 4
403813de:	152892        	l32i	a9, a8, 84
403813e1:	1888      	l32i.n	a8, a8, 4
403813e3:	0028b2        	l32i	a11, a8, 0
403813e6:	20a220        	or	a10, a2, a2
403813e9:	0009e0        	callx8	a9
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403813ec:	40fa90        	nsau	a9, a10
403813ef:	419590        	srli	a9, a9, 5
403813f2:	faae82        	movi	a8, 0xfffffefa
403813f5:	8a8a      	add.n	a8, a10, a8
403813f7:	40f880        	nsau	a8, a8
403813fa:	418580        	srli	a8, a8, 5
403813fd:	209980        	or	a9, a9, a8
40381400:	04d916        	beqz	a9, 40381451 <spi_flash_chip_mxic_opi_erase_sector+0x85>
        spi_flash_trans_t t = {
40381403:	cc1c      	movi.n	a12, 28
40381405:	0b0c      	movi.n	a11, 0
40381407:	20a110        	or	a10, a1, a1
4038140a:	cc2b81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4038140d:	0008e0        	callx8	a8
40381410:	082c      	movi.n	a8, 32
40381412:	034182        	s8i	a8, a1, 3
40381415:	1139      	s32i.n	a3, a1, 4
40381417:	cf4481        	l32r	a8, 40375128 <_iram_text_start+0xd24> (ffffde21 <_rtc_reserved_end+0x9fefde21>)
4038141a:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC(CMD_SECTOR_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
4038141d:	02a8      	l32i.n	a10, a2, 0
4038141f:	0a88      	l32i.n	a8, a10, 0
40381421:	1888      	l32i.n	a8, a8, 4
40381423:	20b110        	or	a11, a1, a1
40381426:	0008e0        	callx8	a8
        chip->busy = 1;
40381429:	7288      	l32i.n	a8, a2, 28
4038142b:	190c      	movi.n	a9, 1
4038142d:	208890        	or	a8, a8, a9
40381430:	7289      	s32i.n	a8, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40381432:	1288      	l32i.n	a8, a2, 4
40381434:	152892        	l32i	a9, a8, 84
40381437:	1888      	l32i.n	a8, a8, 4
40381439:	38b8      	l32i.n	a11, a8, 12
4038143b:	02ad      	mov.n	a10, a2
4038143d:	0009e0        	callx8	a9
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381440:	06a182        	movi	a8, 0x106
40381443:	0a9a87        	bne	a10, a8, 40381451 <spi_flash_chip_mxic_opi_erase_sector+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381446:	1288      	l32i.n	a8, a2, 4
40381448:	b888      	l32i.n	a8, a8, 44
4038144a:	1b0c      	movi.n	a11, 1
4038144c:	02ad      	mov.n	a10, a2
4038144e:	0008e0        	callx8	a8
    }

    return err;
}
40381451:	0a2d      	mov.n	a2, a10
40381453:	f01d      	retw.n
40381455:	000000        	ill

40381458 <spi_flash_chip_mxic_opi_erase_block>:

esp_err_t spi_flash_chip_mxic_opi_erase_block(esp_flash_t *chip, uint32_t start_address)
{
40381458:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4038145b:	1288      	l32i.n	a8, a2, 4
4038145d:	b888      	l32i.n	a8, a8, 44
4038145f:	0b0c      	movi.n	a11, 0
40381461:	02ad      	mov.n	a10, a2
40381463:	0008e0        	callx8	a8
    if (err == ESP_OK) {
40381466:	eacc      	bnez.n	a10, 40381478 <spi_flash_chip_mxic_opi_erase_block+0x20>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381468:	1288      	l32i.n	a8, a2, 4
4038146a:	152892        	l32i	a9, a8, 84
4038146d:	1888      	l32i.n	a8, a8, 4
4038146f:	0028b2        	l32i	a11, a8, 0
40381472:	20a220        	or	a10, a2, a2
40381475:	0009e0        	callx8	a9
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381478:	40fa90        	nsau	a9, a10
4038147b:	419590        	srli	a9, a9, 5
4038147e:	faae82        	movi	a8, 0xfffffefa
40381481:	8a8a      	add.n	a8, a10, a8
40381483:	40f880        	nsau	a8, a8
40381486:	418580        	srli	a8, a8, 5
40381489:	209980        	or	a9, a9, a8
4038148c:	04d916        	beqz	a9, 403814dd <spi_flash_chip_mxic_opi_erase_block+0x85>
        spi_flash_trans_t t = {
4038148f:	cc1c      	movi.n	a12, 28
40381491:	0b0c      	movi.n	a11, 0
40381493:	20a110        	or	a10, a1, a1
40381496:	cc0881        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40381499:	0008e0        	callx8	a8
4038149c:	082c      	movi.n	a8, 32
4038149e:	034182        	s8i	a8, a1, 3
403814a1:	1139      	s32i.n	a3, a1, 4
403814a3:	cf2281        	l32r	a8, 4037512c <_iram_text_start+0xd28> (23dc <UserFrameTotalSize+0x22dc>)
403814a6:	0a5182        	s16i	a8, a1, 20
            .command = CMD_OPI_FLASH_MXIC(CMD_LARGE_BLOCK_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
403814a9:	02a8      	l32i.n	a10, a2, 0
403814ab:	0a88      	l32i.n	a8, a10, 0
403814ad:	1888      	l32i.n	a8, a8, 4
403814af:	20b110        	or	a11, a1, a1
403814b2:	0008e0        	callx8	a8
        chip->busy = 1;
403814b5:	7288      	l32i.n	a8, a2, 28
403814b7:	190c      	movi.n	a9, 1
403814b9:	208890        	or	a8, a8, a9
403814bc:	7289      	s32i.n	a8, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
403814be:	1288      	l32i.n	a8, a2, 4
403814c0:	152892        	l32i	a9, a8, 84
403814c3:	1888      	l32i.n	a8, a8, 4
403814c5:	28b8      	l32i.n	a11, a8, 8
403814c7:	02ad      	mov.n	a10, a2
403814c9:	0009e0        	callx8	a9
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
403814cc:	06a182        	movi	a8, 0x106
403814cf:	0a9a87        	bne	a10, a8, 403814dd <spi_flash_chip_mxic_opi_erase_block+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
403814d2:	1288      	l32i.n	a8, a2, 4
403814d4:	b888      	l32i.n	a8, a8, 44
403814d6:	1b0c      	movi.n	a11, 1
403814d8:	02ad      	mov.n	a10, a2
403814da:	0008e0        	callx8	a8
    }

    return err;
}
403814dd:	0a2d      	mov.n	a2, a10
403814df:	f01d      	retw.n
403814e1:	000000        	ill

403814e4 <spi_flash_chip_mxic_opi_page_program>:

esp_err_t spi_flash_chip_mxic_opi_page_program(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
403814e4:	008136        	entry	a1, 64
403814e7:	027d      	mov.n	a7, a2
    esp_err_t err;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403814e9:	1288      	l32i.n	a8, a2, 4
403814eb:	152892        	l32i	a9, a8, 84
403814ee:	012882        	l32i	a8, a8, 4
403814f1:	0028b2        	l32i	a11, a8, 0
403814f4:	20a220        	or	a10, a2, a2
403814f7:	0009e0        	callx8	a9
403814fa:	0a2d      	mov.n	a2, a10
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403814fc:	40fa90        	nsau	a9, a10
403814ff:	419590        	srli	a9, a9, 5
40381502:	faae82        	movi	a8, 0xfffffefa
40381505:	8a8a      	add.n	a8, a10, a8
40381507:	40f880        	nsau	a8, a8
4038150a:	418580        	srli	a8, a8, 5
4038150d:	209980        	or	a9, a9, a8
40381510:	056916        	beqz	a9, 4038156a <spi_flash_chip_mxic_opi_page_program+0x86>
        // Perform the actual Page Program command
        spi_flash_trans_t t = {
40381513:	cc1c      	movi.n	a12, 28
40381515:	00a0b2        	movi	a11, 0
40381518:	20a110        	or	a10, a1, a1
4038151b:	cbe781        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4038151e:	0008e0        	callx8	a8
40381521:	014152        	s8i	a5, a1, 1
40381524:	082c      	movi.n	a8, 32
40381526:	034182        	s8i	a8, a1, 3
40381529:	1149      	s32i.n	a4, a1, 4
4038152b:	2139      	s32i.n	a3, a1, 8
4038152d:	cf0081        	l32r	a8, 40375130 <_iram_text_start+0xd2c> (ffffed12 <_rtc_reserved_end+0x9fefed12>)
40381530:	0a5182        	s16i	a8, a1, 20
            .address_bitlen = 32,
            .address = address,
            .mosi_len = length,
            .mosi_data = buffer,
        };
        chip->host->driver->common_command(chip->host, &t);
40381533:	07a8      	l32i.n	a10, a7, 0
40381535:	0a88      	l32i.n	a8, a10, 0
40381537:	1888      	l32i.n	a8, a8, 4
40381539:	01bd      	mov.n	a11, a1
4038153b:	0008e0        	callx8	a8
        chip->busy = 1;
4038153e:	7788      	l32i.n	a8, a7, 28
40381540:	190c      	movi.n	a9, 1
40381542:	208890        	or	a8, a8, a9
40381545:	7789      	s32i.n	a8, a7, 28

        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
40381547:	1788      	l32i.n	a8, a7, 4
40381549:	152892        	l32i	a9, a8, 84
4038154c:	1888      	l32i.n	a8, a8, 4
4038154e:	48b8      	l32i.n	a11, a8, 16
40381550:	07ad      	mov.n	a10, a7
40381552:	0009e0        	callx8	a9
40381555:	0a2d      	mov.n	a2, a10
    }
    // Ensure WEL is 0, even if the page program failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381557:	06a182        	movi	a8, 0x106
4038155a:	0c9a87        	bne	a10, a8, 4038156a <spi_flash_chip_mxic_opi_page_program+0x86>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4038155d:	1788      	l32i.n	a8, a7, 4
4038155f:	b888      	l32i.n	a8, a8, 44
40381561:	1b0c      	movi.n	a11, 1
40381563:	07ad      	mov.n	a10, a7
40381565:	0008e0        	callx8	a8
40381568:	0a2d      	mov.n	a2, a10
    }
    return err;
}
4038156a:	f01d      	retw.n

4038156c <spi_flash_chip_xmic_opi_config_host_io_mode>:
}

// This function should only be called after opi mode initialization. So, only configure for OPI-STR/OPI-DTR mode
// not support other mode in this file, return `ESP_ERR_FLASH_NOT_INITIALISED` directly.
esp_err_t spi_flash_chip_xmic_opi_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
4038156c:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4038156f:	42e8      	l32i.n	a14, a2, 16

    switch (read_mode & 0xFFFF) {
40381571:	f480e0        	extui	a8, a14, 0, 16
40381574:	0cb826        	beqi	a8, 16, 40381584 <spi_flash_chip_xmic_opi_config_host_io_mode+0x18>
40381577:	191c      	movi.n	a9, 17
40381579:	1c9897        	bne	a8, a9, 40381599 <spi_flash_chip_xmic_opi_config_host_io_mode+0x2d>
        read_command = CMD_OPI_FLASH_MXIC_READ_STR;
        break;
    case SPI_FLASH_OPI_DTR:
        addr_bitlen = SPI_FLASH_OPIDTR_ADDR_BITLEN;
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
        read_command = CMD_OPI_FLASH_MXIC_READ_DTR;
4038157c:	ceefb1        	l32r	a11, 40375138 <_iram_text_start+0xd34> (11ee <UserFrameTotalSize+0x10ee>)
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
4038157f:	8d2c      	movi.n	a13, 40
40381581:	000106        	j	40381589 <spi_flash_chip_xmic_opi_config_host_io_mode+0x1d>
    switch (read_mode & 0xFFFF) {
40381584:	ceecb1        	l32r	a11, 40375134 <_iram_text_start+0xd30> (13ec <UserFrameTotalSize+0x12ec>)
40381587:	4d1c      	movi.n	a13, 20
        break;
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
40381589:	02a8      	l32i.n	a10, a2, 0
4038158b:	0a88      	l32i.n	a8, a10, 0
4038158d:	f888      	l32i.n	a8, a8, 60
4038158f:	0c2c      	movi.n	a12, 32
40381591:	0008e0        	callx8	a8
40381594:	0a2d      	mov.n	a2, a10
40381596:	000086        	j	4038159c <spi_flash_chip_xmic_opi_config_host_io_mode+0x30>
    switch (read_mode & 0xFFFF) {
40381599:	ccb021        	l32r	a2, 4037485c <_iram_text_start+0x458> (6003 <UserFrameTotalSize+0x5f03>)
}
4038159c:	f01d      	retw.n
	...

403815a0 <spi_flash_chip_mxic_opi_get_data_length_zoom>:
{
403815a0:	004136        	entry	a1, 32
    assert((io_mode == SPI_FLASH_OPI_STR) || (io_mode == SPI_FLASH_OPI_DTR));
403815a3:	f0c282        	addi	a8, a2, -16
403815a6:	190c      	movi.n	a9, 1
403815a8:	0db987        	bgeu	a9, a8, 403815b9 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x19>
403815ab:	cee4d1        	l32r	a13, 4037513c <_iram_text_start+0xd38> (3fc94160 <__func__$0+0x574>)
403815ae:	cee4c1        	l32r	a12, 40375140 <_iram_text_start+0xd3c> (3fc94a9c <__func__$1>)
403815b1:	db5c      	movi.n	a11, 93
403815b3:	cee4a1        	l32r	a10, 40375144 <_iram_text_start+0xd40> (3fc941bf <__func__$0+0x5d3>)
403815b6:	fe7725        	call8	4037fd28 <__assert_func>
    *length_zoom = (io_mode == SPI_FLASH_OPI_STR) ? 1 : 2;
403815b9:	07b266        	bnei	a2, 16, 403815c4 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x24>
403815bc:	180c      	movi.n	a8, 1
403815be:	000106        	j	403815c6 <spi_flash_chip_mxic_opi_get_data_length_zoom+0x26>
403815c1:	000000        	ill
403815c4:	280c      	movi.n	a8, 2
403815c6:	0389      	s32i.n	a8, a3, 0
}
403815c8:	f01d      	retw.n
	...

403815cc <spi_flash_chip_mxic_opi_read_id>:
{
403815cc:	00a136        	entry	a1, 80
    uint64_t id_buf = 0;
403815cf:	080c      	movi.n	a8, 0
403815d1:	0189      	s32i.n	a8, a1, 0
403815d3:	1189      	s32i.n	a8, a1, 4
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
403815d5:	b18b      	addi.n	a11, a1, 8
403815d7:	42a8      	l32i.n	a10, a2, 16
403815d9:	fffc65        	call8	403815a0 <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
403815dc:	71cb      	addi.n	a7, a1, 12
403815de:	cc1c      	movi.n	a12, 28
403815e0:	0b0c      	movi.n	a11, 0
403815e2:	07ad      	mov.n	a10, a7
403815e4:	cbb581        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403815e7:	0008e0        	callx8	a8
403815ea:	080182        	l8ui	a8, a1, 8
403815ed:	909880        	addx2	a9, a8, a8
403815f0:	0e4192        	s8i	a9, a1, 14
403815f3:	092c      	movi.n	a9, 32
403815f5:	0f4192        	s8i	a9, a1, 15
403815f8:	6119      	s32i.n	a1, a1, 24
403815fa:	ced391        	l32r	a9, 40375148 <_iram_text_start+0xd44> (609f <UserFrameTotalSize+0x5f9f>)
403815fd:	105192        	s16i	a9, a1, 32
40381600:	1188e0        	slli	a8, a8, 2
40381603:	224182        	s8i	a8, a1, 34
    chip->host->driver->common_command(chip->host, &t);
40381606:	02a8      	l32i.n	a10, a2, 0
40381608:	0a88      	l32i.n	a8, a10, 0
4038160a:	1888      	l32i.n	a8, a8, 4
4038160c:	20b770        	or	a11, a7, a7
4038160f:	0008e0        	callx8	a8
    if(chip->read_mode == SPI_FLASH_OPI_DTR) {
40381612:	4298      	l32i.n	a9, a2, 16
40381614:	181c      	movi.n	a8, 17
40381616:	2c9987        	bne	a9, a8, 40381646 <spi_flash_chip_mxic_opi_read_id+0x7a>
        id_buf = (id_buf & 0xff) | ((id_buf & 0xff0000) >> 8) | ((id_buf & 0xff00000000) >> 16);
40381619:	0188      	l32i.n	a8, a1, 0
4038161b:	749080        	extui	a9, a8, 0, 8
4038161e:	41a880        	srli	a10, a8, 8
40381621:	74a8a0        	extui	a10, a10, 8, 8
40381624:	11aa80        	slli	a10, a10, 8
40381627:	2099a0        	or	a9, a9, a10
4038162a:	11a8      	l32i.n	a10, a1, 4
4038162c:	11aa00        	slli	a10, a10, 16
4038162f:	f58080        	extui	a8, a8, 16, 16
40381632:	208a80        	or	a8, a10, a8
40381635:	758080        	extui	a8, a8, 16, 8
40381638:	118800        	slli	a8, a8, 16
4038163b:	208980        	or	a8, a9, a8
4038163e:	0189      	s32i.n	a8, a1, 0
40381640:	00a082        	movi	a8, 0
40381643:	016182        	s32i	a8, a1, 4
    uint32_t raw_flash_id = __builtin_bswap32(id_buf);
40381646:	0178      	l32i.n	a7, a1, 0
40381648:	07ad      	mov.n	a10, a7
4038164a:	cec281        	l32r	a8, 40375154 <_iram_text_start+0xd50> (400021d8 <__bswapsi2>)
4038164d:	0008e0        	callx8	a8
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
40381650:	01d782        	addmi	a8, a7, 0x100
40381653:	40f880        	nsau	a8, a8
40381656:	418580        	srli	a8, a8, 5
40381659:	40f770        	nsau	a7, a7
4038165c:	417570        	srli	a7, a7, 5
4038165f:	208870        	or	a8, a8, a7
40381662:	e89c      	beqz.n	a8, 40381684 <spi_flash_chip_mxic_opi_read_id+0xb8>
40381664:	cb8781        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40381667:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(chip_name, "no response\n");
40381669:	f88c      	beqz.n	a8, 4038167c <spi_flash_chip_mxic_opi_read_id+0xb0>
4038166b:	fe59a5        	call8	4037fc04 <esp_log_timestamp>
4038166e:	ceb7c1        	l32r	a12, 4037514c <_iram_text_start+0xd48> (3fc94b48 <chip_name>)
40381671:	0abd      	mov.n	a11, a10
40381673:	ceb7a1        	l32r	a10, 40375150 <_iram_text_start+0xd4c> (3fc941dc <__func__$0+0x5f0>)
40381676:	cb9981        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40381679:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_NO_RESPONSE;
4038167c:	08a122        	movi	a2, 0x108
4038167f:	000206        	j	4038168b <spi_flash_chip_mxic_opi_read_id+0xbf>
40381682:	a00000        	addx4	a0, a0, a0
    *out_chip_id = (raw_flash_id >> 8);
40381685:	41a8      	l32i.n	a10, a1, 16
40381687:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
40381689:	020c      	movi.n	a2, 0
}
4038168b:	f01d      	retw.n
4038168d:	000000        	ill

40381690 <spi_flash_chip_mxic_opi_read_reg>:
{
40381690:	00a136        	entry	a1, 80
    uint32_t stat_buf = 0;
40381693:	060c      	movi.n	a6, 0
40381695:	0169      	s32i.n	a6, a1, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
40381697:	b14b      	addi.n	a11, a1, 4
40381699:	42a8      	l32i.n	a10, a2, 16
4038169b:	fff065        	call8	403815a0 <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
4038169e:	718b      	addi.n	a7, a1, 8
403816a0:	cc1c      	movi.n	a12, 28
403816a2:	06bd      	mov.n	a11, a6
403816a4:	07ad      	mov.n	a10, a7
403816a6:	cb8481        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403816a9:	0008e0        	callx8	a8
403816ac:	040182        	l8ui	a8, a1, 4
403816af:	0a4182        	s8i	a8, a1, 10
403816b2:	092c      	movi.n	a9, 32
403816b4:	0b4192        	s8i	a9, a1, 11
403816b7:	5119      	s32i.n	a1, a1, 20
403816b9:	05aa92        	movi	a9, 0xfffffa05
403816bc:	0e5192        	s16i	a9, a1, 28
403816bf:	1188e0        	slli	a8, a8, 2
403816c2:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
403816c5:	02a8      	l32i.n	a10, a2, 0
403816c7:	0a88      	l32i.n	a8, a10, 0
403816c9:	1888      	l32i.n	a8, a8, 4
403816cb:	07bd      	mov.n	a11, a7
403816cd:	0008e0        	callx8	a8
403816d0:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
403816d2:	3acc      	bnez.n	a10, 403816d9 <spi_flash_chip_mxic_opi_read_reg+0x49>
    *out_reg = (stat_buf & 0xff);
403816d4:	000182        	l8ui	a8, a1, 0
403816d7:	0489      	s32i.n	a8, a4, 0
}
403816d9:	f01d      	retw.n
	...

403816dc <spi_flash_chip_mxic_opi_get_io_mode>:
{
403816dc:	00a136        	entry	a1, 80
403816df:	027d      	mov.n	a7, a2
    uint32_t stat_buf = 0;
403816e1:	060c      	movi.n	a6, 0
403816e3:	0169      	s32i.n	a6, a1, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
403816e5:	b14b      	addi.n	a11, a1, 4
403816e7:	42a8      	l32i.n	a10, a2, 16
403816e9:	ffeb65        	call8	403815a0 <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
403816ec:	218b      	addi.n	a2, a1, 8
403816ee:	cc1c      	movi.n	a12, 28
403816f0:	20b660        	or	a11, a6, a6
403816f3:	20a220        	or	a10, a2, a2
403816f6:	cb7081        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403816f9:	0008e0        	callx8	a8
403816fc:	040182        	l8ui	a8, a1, 4
403816ff:	0a4182        	s8i	a8, a1, 10
40381702:	092c      	movi.n	a9, 32
40381704:	0b4192        	s8i	a9, a1, 11
40381707:	5119      	s32i.n	a1, a1, 20
40381709:	ce9391        	l32r	a9, 40375158 <_iram_text_start+0xd54> (ffff8e71 <_rtc_reserved_end+0x9fef8e71>)
4038170c:	0e5192        	s16i	a9, a1, 28
4038170f:	1188e0        	slli	a8, a8, 2
40381712:	1e4182        	s8i	a8, a1, 30
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
40381715:	07a8      	l32i.n	a10, a7, 0
40381717:	0a88      	l32i.n	a8, a10, 0
40381719:	1888      	l32i.n	a8, a8, 4
4038171b:	02bd      	mov.n	a11, a2
4038171d:	0008e0        	callx8	a8
40381720:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40381722:	8aec      	bnez.n	a10, 4038174e <spi_flash_chip_mxic_opi_get_io_mode+0x72>
    switch (stat_buf & 0xff)
40381724:	000182        	l8ui	a8, a1, 0
40381727:	051826        	beqi	a8, 1, 40381730 <spi_flash_chip_mxic_opi_get_io_mode+0x54>
4038172a:	0a2826        	beqi	a8, 2, 40381738 <spi_flash_chip_mxic_opi_get_io_mode+0x5c>
4038172d:	000386        	j	4038173f <spi_flash_chip_mxic_opi_get_io_mode+0x63>
        *out_io_mode = SPI_FLASH_OPI_STR;
40381730:	081c      	movi.n	a8, 16
40381732:	0389      	s32i.n	a8, a3, 0
        break;
40381734:	0002c6        	j	40381743 <spi_flash_chip_mxic_opi_get_io_mode+0x67>
40381737:	181c00        	lsxp	f1, a12, a0
        *out_io_mode = SPI_FLASH_OPI_DTR;
4038173a:	0389      	s32i.n	a8, a3, 0
        break;
4038173c:	0000c6        	j	40381743 <spi_flash_chip_mxic_opi_get_io_mode+0x67>
        *out_io_mode = 0;
4038173f:	080c      	movi.n	a8, 0
40381741:	0389      	s32i.n	a8, a3, 0
    if (*out_io_mode != chip->read_mode) {
40381743:	0398      	l32i.n	a9, a3, 0
40381745:	4788      	l32i.n	a8, a7, 16
40381747:	031987        	beq	a9, a8, 4038174e <spi_flash_chip_mxic_opi_get_io_mode+0x72>
        *out_io_mode = 0;
4038174a:	080c      	movi.n	a8, 0
4038174c:	0389      	s32i.n	a8, a3, 0
}
4038174e:	f01d      	retw.n

40381750 <spi_flash_chip_mxic_opi_get_write_protect>:
{
40381750:	006136        	entry	a1, 48
40381753:	02ad      	mov.n	a10, a2
    assert(out_write_protected!=NULL);
40381755:	d3cc      	bnez.n	a3, 40381766 <spi_flash_chip_mxic_opi_get_write_protect+0x16>
40381757:	ce81d1        	l32r	a13, 4037515c <_iram_text_start+0xd58> (3fc941f8 <__func__$0+0x60c>)
4038175a:	ce81c1        	l32r	a12, 40375160 <_iram_text_start+0xd5c> (3fc94a70 <__func__$0>)
4038175d:	9ea0b2        	movi	a11, 158
40381760:	ce79a1        	l32r	a10, 40375144 <_iram_text_start+0xd40> (3fc941bf <__func__$0+0x5d3>)
40381763:	fe5c65        	call8	4037fd28 <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
40381766:	1288      	l32i.n	a8, a2, 4
40381768:	192882        	l32i	a8, a8, 100
4038176b:	01cd      	mov.n	a12, a1
4038176d:	1b0c      	movi.n	a11, 1
4038176f:	0008e0        	callx8	a8
40381772:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40381774:	eacc      	bnez.n	a10, 40381786 <spi_flash_chip_mxic_opi_get_write_protect+0x36>
    *out_write_protected = ((status & SR_WREN) == 0);
40381776:	280c      	movi.n	a8, 2
40381778:	0198      	l32i.n	a9, a1, 0
4038177a:	108890        	and	a8, a8, a9
4038177d:	40f880        	nsau	a8, a8
40381780:	418580        	srli	a8, a8, 5
40381783:	004382        	s8i	a8, a3, 0
}
40381786:	f01d      	retw.n

40381788 <spi_flash_chip_mxic_opi_write>:
{
40381788:	010136        	entry	a1, 128
4038178b:	026d      	mov.n	a6, a2
4038178d:	146132        	s32i	a3, a1, 80
    const uint32_t page_size = chip->chip_drv->page_size;
40381790:	1288      	l32i.n	a8, a2, 4
40381792:	132882        	l32i	a8, a8, 76
40381795:	156182        	s32i	a8, a1, 84
    esp_err_t err = ESP_OK;
40381798:	0a0c      	movi.n	a10, 0
    while (err == ESP_OK && length > 0) {
4038179a:	001f06        	j	4038181a <spi_flash_chip_mxic_opi_write+0x92>
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
4038179d:	214b      	addi.n	a2, a1, 4
4038179f:	0c4c      	movi.n	a12, 64
403817a1:	ffa0b2        	movi	a11, 255
403817a4:	02ad      	mov.n	a10, a2
403817a6:	cb4481        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403817a9:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
403817ac:	06a8      	l32i.n	a10, a6, 0
403817ae:	0a88      	l32i.n	a8, a10, 0
403817b0:	a888      	l32i.n	a8, a8, 40
403817b2:	1521e2        	l32i	a14, a1, 84
403817b5:	01dd      	mov.n	a13, a1
403817b7:	05cd      	mov.n	a12, a5
403817b9:	04bd      	mov.n	a11, a4
403817bb:	0008e0        	callx8	a8
403817be:	0a9d      	mov.n	a9, a10
403817c0:	1661a2        	s32i	a10, a1, 88
        uint32_t left_off = address - align_address;
403817c3:	0188      	l32i.n	a8, a1, 0
403817c5:	c0a480        	sub	a10, a4, a8
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
403817c8:	745a      	add.n	a7, a4, a5
403817ca:	889a      	add.n	a8, a8, a9
403817cc:	637780        	minu	a7, a7, a8
403817cf:	c08740        	sub	a8, a7, a4
403817d2:	176182        	s32i	a8, a1, 92
        memcpy(temp_buffer + left_off, buffer, write_len);
403817d5:	08cd      	mov.n	a12, a8
403817d7:	1421b2        	l32i	a11, a1, 80
403817da:	a2aa      	add.n	a10, a2, a10
403817dc:	cb4981        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
403817df:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
403817e2:	1688      	l32i.n	a8, a6, 4
403817e4:	b888      	l32i.n	a8, a8, 44
403817e6:	0b0c      	movi.n	a11, 0
403817e8:	06ad      	mov.n	a10, a6
403817ea:	0008e0        	callx8	a8
        if (err == ESP_OK && length > 0) {
403817ed:	40fa80        	nsau	a8, a10
403817f0:	418580        	srli	a8, a8, 5
403817f3:	230837        	bnone	a8, a3, 4038181a <spi_flash_chip_mxic_opi_write+0x92>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
403817f6:	1688      	l32i.n	a8, a6, 4
403817f8:	122882        	l32i	a8, a8, 72
403817fb:	1621d2        	l32i	a13, a1, 88
403817fe:	01c8      	l32i.n	a12, a1, 0
40381800:	20b220        	or	a11, a2, a2
40381803:	06ad      	mov.n	a10, a6
40381805:	0008e0        	callx8	a8
            buffer = (void *)((intptr_t)buffer + write_len);
40381808:	142182        	l32i	a8, a1, 80
4038180b:	172192        	l32i	a9, a1, 92
4038180e:	889a      	add.n	a8, a8, a9
40381810:	146182        	s32i	a8, a1, 80
            length -= write_len;
40381813:	c04470        	sub	a4, a4, a7
40381816:	554a      	add.n	a5, a5, a4
            address += write_len;
40381818:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
4038181a:	130c      	movi.n	a3, 1
4038181c:	833550        	moveqz	a3, a5, a5
4038181f:	1acc      	bnez.n	a10, 40381824 <spi_flash_chip_mxic_opi_write+0x9c>
40381821:	f78356        	bnez	a3, 4038179d <spi_flash_chip_mxic_opi_write+0x15>
}
40381824:	0a2d      	mov.n	a2, a10
40381826:	f01d      	retw.n

40381828 <spi_flash_chip_mxic_opi_probe>:
{
40381828:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
4038182b:	f53030        	extui	a3, a3, 16, 16
4038182e:	c2a082        	movi	a8, 194
40381831:	0b9387        	bne	a3, a8, 40381840 <spi_flash_chip_mxic_opi_probe+0x18>
    if (chip->read_mode < SPI_FLASH_OPI_FLAG) {
40381834:	4288      	l32i.n	a8, a2, 16
40381836:	f90c      	movi.n	a9, 15
40381838:	0cb987        	bgeu	a9, a8, 40381848 <spi_flash_chip_mxic_opi_probe+0x20>
    return ESP_OK;
4038183b:	020c      	movi.n	a2, 0
4038183d:	000286        	j	4038184b <spi_flash_chip_mxic_opi_probe+0x23>
        return ESP_ERR_NOT_FOUND;
40381840:	05a122        	movi	a2, 0x105
40381843:	000106        	j	4038184b <spi_flash_chip_mxic_opi_probe+0x23>
40381846:	220000        	orb	b0, b0, b0
        return ESP_ERR_NOT_FOUND;
40381849:	1d05a1        	l32r	a10, 40348c60 <rom_rx_gain_force+0x342834>
}
4038184c:	0000f0        	callx12	a0
	...

40381850 <spi_flash_chip_mxic_opi_get_caps>:
{
40381850:	004136        	entry	a1, 32
}
40381853:	220c      	movi.n	a2, 2
40381855:	f01d      	retw.n
	...

40381858 <spi_flash_chip_xmic_opi_set_io_mode>:
{
40381858:	004136        	entry	a1, 32
}
4038185b:	020c      	movi.n	a2, 0
4038185d:	f01d      	retw.n
	...

40381860 <spi_flash_chip_th_probe>:
#include <stdlib.h>
#include "spi_flash_chip_generic.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_th_probe(esp_flash_t *chip, uint32_t flash_id)
{
40381860:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0xcd;
    if (flash_id >> 16 != MFG_ID) {
40381863:	f59030        	extui	a9, a3, 16, 16
40381866:	cda082        	movi	a8, 205
40381869:	109987        	bne	a9, a8, 4038187d <spi_flash_chip_th_probe+0x1d>
        return ESP_ERR_NOT_FOUND;
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x6000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
4038186c:	743830        	extui	a3, a3, 8, 8
4038186f:	113380        	slli	a3, a3, 8
40381872:	ce1a81        	l32r	a8, 403750dc <_iram_text_start+0xcd8> (6000 <UserFrameTotalSize+0x5f00>)
40381875:	0b9387        	bne	a3, a8, 40381884 <spi_flash_chip_th_probe+0x24>
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
40381878:	020c      	movi.n	a2, 0
4038187a:	000246        	j	40381887 <spi_flash_chip_th_probe+0x27>
        return ESP_ERR_NOT_FOUND;
4038187d:	05a122        	movi	a2, 0x105
40381880:	0000c6        	j	40381887 <spi_flash_chip_th_probe+0x27>
40381883:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40381886:	f01d05        	call0	40371a58 <rom_rx_gain_force+0x36b62c>
40381889:	000000        	ill

4038188c <spi_flash_chip_th_get_caps>:
}

spi_flash_caps_t spi_flash_chip_th_get_caps(esp_flash_t *chip)
{
4038188c:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
4038188f:	420c      	movi.n	a2, 4
40381891:	f01d      	retw.n
	...

40381894 <spi_flash_chip_winbond_suspend_cmd_conf>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_winbond_suspend_cmd_conf(esp_flash_t *chip)
{
40381894:	006136        	entry	a1, 48
    spi_flash_sus_cmd_conf sus_conf = {
40381897:	8c0c      	movi.n	a12, 8
40381899:	00a0b2        	movi	a11, 0
4038189c:	01ad      	mov.n	a10, a1
4038189e:	cb0681        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403818a1:	0008e0        	callx8	a8
403818a4:	80a082        	movi	a8, 128
403818a7:	0189      	s32i.n	a8, a1, 0
403818a9:	583c      	movi.n	a8, 53
403818ab:	044182        	s8i	a8, a1, 4
403818ae:	75a082        	movi	a8, 117
403818b1:	054182        	s8i	a8, a1, 5
403818b4:	7aa082        	movi	a8, 122
403818b7:	064182        	s8i	a8, a1, 6
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
403818ba:	02a8      	l32i.n	a10, a2, 0
403818bc:	0a88      	l32i.n	a8, a10, 0
403818be:	152882        	l32i	a8, a8, 84
403818c1:	01bd      	mov.n	a11, a1
403818c3:	0008e0        	callx8	a8
}
403818c6:	0a2d      	mov.n	a2, a10
403818c8:	f01d      	retw.n
	...

403818cc <spi_flash_command_winbond_program_4B>:
    .config_host_io_mode = spi_flash_chip_generic_config_host_io_mode,
};


static esp_err_t spi_flash_command_winbond_program_4B(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
403818cc:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(address);
    spi_flash_trans_t t = {
403818cf:	cc1c      	movi.n	a12, 28
403818d1:	0b0c      	movi.n	a11, 0
403818d3:	20a110        	or	a10, a1, a1
403818d6:	caf881        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
403818d9:	0008e0        	callx8	a8
403818dc:	014152        	s8i	a5, a1, 1
403818df:	cdf381        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
403818e2:	04b847        	bgeu	a8, a4, 403818ea <spi_flash_command_winbond_program_4B+0x1e>
403818e5:	082c      	movi.n	a8, 32
403818e7:	000046        	j	403818ec <spi_flash_command_winbond_program_4B+0x20>
403818ea:	881c      	movi.n	a8, 24
403818ec:	034182        	s8i	a8, a1, 3
403818ef:	1149      	s32i.n	a4, a1, 4
403818f1:	2139      	s32i.n	a3, a1, 8
403818f3:	880c      	movi.n	a8, 8
403818f5:	4189      	s32i.n	a8, a1, 16
403818f7:	cded81        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
403818fa:	04b847        	bgeu	a8, a4, 40381902 <spi_flash_command_winbond_program_4B+0x36>
403818fd:	281c      	movi.n	a8, 18
403818ff:	000046        	j	40381904 <spi_flash_command_winbond_program_4B+0x38>
40381902:	280c      	movi.n	a8, 2
40381904:	0a5182        	s16i	a8, a1, 20
        .address = address,
        .mosi_len = length,
        .mosi_data = buffer,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
40381907:	02a8      	l32i.n	a10, a2, 0
40381909:	0a88      	l32i.n	a8, a10, 0
4038190b:	1888      	l32i.n	a8, a8, 4
4038190d:	01bd      	mov.n	a11, a1
4038190f:	0008e0        	callx8	a8
}
40381912:	0a2d      	mov.n	a2, a10
40381914:	f01d      	retw.n
	...

40381918 <spi_flash_chip_winbond_page_program>:
{
40381918:	004136        	entry	a1, 32
4038191b:	027d      	mov.n	a7, a2
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4038191d:	1288      	l32i.n	a8, a2, 4
4038191f:	152892        	l32i	a9, a8, 84
40381922:	1888      	l32i.n	a8, a8, 4
40381924:	08b8      	l32i.n	a11, a8, 0
40381926:	02ad      	mov.n	a10, a2
40381928:	0009e0        	callx8	a9
4038192b:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4038192d:	40fa90        	nsau	a9, a10
40381930:	419590        	srli	a9, a9, 5
40381933:	faae82        	movi	a8, 0xfffffefa
40381936:	8a8a      	add.n	a8, a10, a8
40381938:	40f880        	nsau	a8, a8
4038193b:	418580        	srli	a8, a8, 5
4038193e:	209980        	or	a9, a9, a8
40381941:	99bc      	beqz.n	a9, 4038197e <spi_flash_chip_winbond_page_program+0x66>
        err = spi_flash_command_winbond_program_4B(chip, buffer, address, length);
40381943:	05dd      	mov.n	a13, a5
40381945:	04cd      	mov.n	a12, a4
40381947:	03bd      	mov.n	a11, a3
40381949:	07ad      	mov.n	a10, a7
4038194b:	fff825        	call8	403818cc <spi_flash_command_winbond_program_4B>
4038194e:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40381950:	aaec      	bnez.n	a10, 4038197e <spi_flash_chip_winbond_page_program+0x66>
        chip->busy = 1;
40381952:	7788      	l32i.n	a8, a7, 28
40381954:	190c      	movi.n	a9, 1
40381956:	208890        	or	a8, a8, a9
40381959:	7789      	s32i.n	a8, a7, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
4038195b:	1788      	l32i.n	a8, a7, 4
4038195d:	152892        	l32i	a9, a8, 84
40381960:	1888      	l32i.n	a8, a8, 4
40381962:	48b8      	l32i.n	a11, a8, 16
40381964:	07ad      	mov.n	a10, a7
40381966:	0009e0        	callx8	a9
40381969:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
4038196b:	06a182        	movi	a8, 0x106
4038196e:	0c9a87        	bne	a10, a8, 4038197e <spi_flash_chip_winbond_page_program+0x66>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381971:	1788      	l32i.n	a8, a7, 4
40381973:	b888      	l32i.n	a8, a8, 44
40381975:	1b0c      	movi.n	a11, 1
40381977:	07ad      	mov.n	a10, a7
40381979:	0008e0        	callx8	a8
4038197c:	0a2d      	mov.n	a2, a10
}
4038197e:	f01d      	retw.n

40381980 <spi_flash_command_winbond_erase_sector_4B>:

esp_err_t spi_flash_command_winbond_erase_sector_4B(esp_flash_t *chip, uint32_t start_address)
{
40381980:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
40381983:	cc1c      	movi.n	a12, 28
40381985:	0b0c      	movi.n	a11, 0
40381987:	20a110        	or	a10, a1, a1
4038198a:	cacb81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
4038198d:	0008e0        	callx8	a8
40381990:	cdc781        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
40381993:	05b837        	bgeu	a8, a3, 4038199c <spi_flash_command_winbond_erase_sector_4B+0x1c>
40381996:	082c      	movi.n	a8, 32
40381998:	000086        	j	4038199e <spi_flash_command_winbond_erase_sector_4B+0x1e>
4038199b:	00          	.byte	00
4038199c:	881c      	movi.n	a8, 24
4038199e:	034182        	s8i	a8, a1, 3
403819a1:	1139      	s32i.n	a3, a1, 4
403819a3:	880c      	movi.n	a8, 8
403819a5:	4189      	s32i.n	a8, a1, 16
403819a7:	cdc181        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
403819aa:	04b837        	bgeu	a8, a3, 403819b2 <spi_flash_command_winbond_erase_sector_4B+0x32>
403819ad:	182c      	movi.n	a8, 33
403819af:	000046        	j	403819b4 <spi_flash_command_winbond_erase_sector_4B+0x34>
403819b2:	082c      	movi.n	a8, 32
403819b4:	0a5182        	s16i	a8, a1, 20
        .command = (addr_4b? CMD_SECTOR_ERASE_4B: CMD_SECTOR_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
403819b7:	02a8      	l32i.n	a10, a2, 0
403819b9:	0a88      	l32i.n	a8, a10, 0
403819bb:	1888      	l32i.n	a8, a8, 4
403819bd:	01bd      	mov.n	a11, a1
403819bf:	0008e0        	callx8	a8
}
403819c2:	0a2d      	mov.n	a2, a10
403819c4:	f01d      	retw.n
	...

403819c8 <spi_flash_chip_winbond_erase_sector>:
{
403819c8:	004136        	entry	a1, 32
403819cb:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
403819cd:	1288      	l32i.n	a8, a2, 4
403819cf:	b888      	l32i.n	a8, a8, 44
403819d1:	0b0c      	movi.n	a11, 0
403819d3:	02ad      	mov.n	a10, a2
403819d5:	0008e0        	callx8	a8
403819d8:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
403819da:	eacc      	bnez.n	a10, 403819ec <spi_flash_chip_winbond_erase_sector+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
403819dc:	1788      	l32i.n	a8, a7, 4
403819de:	152892        	l32i	a9, a8, 84
403819e1:	1888      	l32i.n	a8, a8, 4
403819e3:	08b8      	l32i.n	a11, a8, 0
403819e5:	07ad      	mov.n	a10, a7
403819e7:	0009e0        	callx8	a9
403819ea:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
403819ec:	40f290        	nsau	a9, a2
403819ef:	419590        	srli	a9, a9, 5
403819f2:	faae82        	movi	a8, 0xfffffefa
403819f5:	828a      	add.n	a8, a2, a8
403819f7:	40f880        	nsau	a8, a8
403819fa:	418580        	srli	a8, a8, 5
403819fd:	209980        	or	a9, a9, a8
40381a00:	068916        	beqz	a9, 40381a6c <spi_flash_chip_winbond_erase_sector+0xa4>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40381a03:	2788      	l32i.n	a8, a7, 8
40381a05:	9888      	l32i.n	a8, a8, 36
40381a07:	388c      	beqz.n	a8, 40381a0e <spi_flash_chip_winbond_erase_sector+0x46>
40381a09:	1a0c      	movi.n	a10, 1
40381a0b:	0008e0        	callx8	a8
        err = spi_flash_command_winbond_erase_sector_4B(chip, start_address);
40381a0e:	20b330        	or	a11, a3, a3
40381a11:	20a770        	or	a10, a7, a7
40381a14:	fff6a5        	call8	40381980 <spi_flash_command_winbond_erase_sector_4B>
40381a17:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
40381a1a:	04ea56        	bnez	a10, 40381a6c <spi_flash_chip_winbond_erase_sector+0xa4>
        chip->busy = 1;
40381a1d:	7788      	l32i.n	a8, a7, 28
40381a1f:	190c      	movi.n	a9, 1
40381a21:	208890        	or	a8, a8, a9
40381a24:	7789      	s32i.n	a8, a7, 28
        if (chip->host->driver->flush_cache) {
40381a26:	07a8      	l32i.n	a10, a7, 0
40381a28:	0a88      	l32i.n	a8, a10, 0
40381a2a:	112882        	l32i	a8, a8, 68
40381a2d:	b88c      	beqz.n	a8, 40381a3c <spi_flash_chip_winbond_erase_sector+0x74>
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->sector_size);
40381a2f:	1798      	l32i.n	a9, a7, 4
40381a31:	89c8      	l32i.n	a12, a9, 32
40381a33:	03bd      	mov.n	a11, a3
40381a35:	0008e0        	callx8	a8
40381a38:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
40381a3a:	eaec      	bnez.n	a10, 40381a6c <spi_flash_chip_winbond_erase_sector+0xa4>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
40381a3c:	1788      	l32i.n	a8, a7, 4
40381a3e:	152892        	l32i	a9, a8, 84
40381a41:	1888      	l32i.n	a8, a8, 4
40381a43:	38b8      	l32i.n	a11, a8, 12
40381a45:	07ad      	mov.n	a10, a7
40381a47:	0009e0        	callx8	a9
40381a4a:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40381a4c:	2788      	l32i.n	a8, a7, 8
40381a4e:	9888      	l32i.n	a8, a8, 36
40381a50:	488c      	beqz.n	a8, 40381a58 <spi_flash_chip_winbond_erase_sector+0x90>
40381a52:	00a0a2        	movi	a10, 0
40381a55:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381a58:	06a182        	movi	a8, 0x106
40381a5b:	0d9287        	bne	a2, a8, 40381a6c <spi_flash_chip_winbond_erase_sector+0xa4>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381a5e:	1788      	l32i.n	a8, a7, 4
40381a60:	b888      	l32i.n	a8, a8, 44
40381a62:	1b0c      	movi.n	a11, 1
40381a64:	20a770        	or	a10, a7, a7
40381a67:	0008e0        	callx8	a8
40381a6a:	0a2d      	mov.n	a2, a10
}
40381a6c:	f01d      	retw.n
	...

40381a70 <spi_flash_command_erase_block_4B>:

esp_err_t spi_flash_command_erase_block_4B(esp_flash_t *chip, uint32_t start_address)
{
40381a70:	008136        	entry	a1, 64
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
40381a73:	cc1c      	movi.n	a12, 28
40381a75:	0b0c      	movi.n	a11, 0
40381a77:	20a110        	or	a10, a1, a1
40381a7a:	ca8f81        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40381a7d:	0008e0        	callx8	a8
40381a80:	cd8b81        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
40381a83:	05b837        	bgeu	a8, a3, 40381a8c <spi_flash_command_erase_block_4B+0x1c>
40381a86:	082c      	movi.n	a8, 32
40381a88:	000086        	j	40381a8e <spi_flash_command_erase_block_4B+0x1e>
40381a8b:	00          	.byte	00
40381a8c:	881c      	movi.n	a8, 24
40381a8e:	034182        	s8i	a8, a1, 3
40381a91:	1139      	s32i.n	a3, a1, 4
40381a93:	880c      	movi.n	a8, 8
40381a95:	4189      	s32i.n	a8, a1, 16
40381a97:	cd8581        	l32r	a8, 403750ac <_iram_text_start+0xca8> (ffffff <UserFrameTotalSize+0xfffeff>)
40381a9a:	06b837        	bgeu	a8, a3, 40381aa4 <spi_flash_command_erase_block_4B+0x34>
40381a9d:	dca082        	movi	a8, 220
40381aa0:	0000c6        	j	40381aa7 <spi_flash_command_erase_block_4B+0x37>
40381aa3:	a08200        	addx4	a8, a2, a0
40381aa6:	82d8      	l32i.n	a13, a2, 32
40381aa8:	a80a51        	l32r	a5, 4036bad0 <rom_rx_gain_force+0x3656a4>
        .command = (addr_4b? CMD_LARGE_BLOCK_ERASE_4B: CMD_LARGE_BLOCK_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
        .flags = SPI_FLASH_TRANS_FLAG_PE_CMD,
    };
    return chip->host->driver->common_command(chip->host, &t);
40381aab:	02          	.byte	0x2
40381aac:	0a88      	l32i.n	a8, a10, 0
40381aae:	1888      	l32i.n	a8, a8, 4
40381ab0:	01bd      	mov.n	a11, a1
40381ab2:	0008e0        	callx8	a8
}
40381ab5:	0a2d      	mov.n	a2, a10
40381ab7:	f01d      	retw.n
40381ab9:	000000        	ill

40381abc <spi_flash_chip_winbond_erase_block>:
{
40381abc:	004136        	entry	a1, 32
40381abf:	027d      	mov.n	a7, a2
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
40381ac1:	1288      	l32i.n	a8, a2, 4
40381ac3:	b888      	l32i.n	a8, a8, 44
40381ac5:	0b0c      	movi.n	a11, 0
40381ac7:	02ad      	mov.n	a10, a2
40381ac9:	0008e0        	callx8	a8
40381acc:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK) {
40381ace:	eacc      	bnez.n	a10, 40381ae0 <spi_flash_chip_winbond_erase_block+0x24>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
40381ad0:	1788      	l32i.n	a8, a7, 4
40381ad2:	152892        	l32i	a9, a8, 84
40381ad5:	1888      	l32i.n	a8, a8, 4
40381ad7:	08b8      	l32i.n	a11, a8, 0
40381ad9:	07ad      	mov.n	a10, a7
40381adb:	0009e0        	callx8	a9
40381ade:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
40381ae0:	40f290        	nsau	a9, a2
40381ae3:	419590        	srli	a9, a9, 5
40381ae6:	faae82        	movi	a8, 0xfffffefa
40381ae9:	828a      	add.n	a8, a2, a8
40381aeb:	40f880        	nsau	a8, a8
40381aee:	418580        	srli	a8, a8, 5
40381af1:	209980        	or	a9, a9, a8
40381af4:	068916        	beqz	a9, 40381b60 <spi_flash_chip_winbond_erase_block+0xa4>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
40381af7:	2788      	l32i.n	a8, a7, 8
40381af9:	9888      	l32i.n	a8, a8, 36
40381afb:	388c      	beqz.n	a8, 40381b02 <spi_flash_chip_winbond_erase_block+0x46>
40381afd:	1a0c      	movi.n	a10, 1
40381aff:	0008e0        	callx8	a8
        err = spi_flash_command_erase_block_4B(chip, start_address);
40381b02:	20b330        	or	a11, a3, a3
40381b05:	20a770        	or	a10, a7, a7
40381b08:	fff665        	call8	40381a70 <spi_flash_command_erase_block_4B>
40381b0b:	202aa0        	or	a2, a10, a10
        if (err != ESP_OK) {
40381b0e:	04ea56        	bnez	a10, 40381b60 <spi_flash_chip_winbond_erase_block+0xa4>
        chip->busy = 1;
40381b11:	7788      	l32i.n	a8, a7, 28
40381b13:	190c      	movi.n	a9, 1
40381b15:	208890        	or	a8, a8, a9
40381b18:	7789      	s32i.n	a8, a7, 28
        if (chip->host->driver->flush_cache) {
40381b1a:	07a8      	l32i.n	a10, a7, 0
40381b1c:	0a88      	l32i.n	a8, a10, 0
40381b1e:	112882        	l32i	a8, a8, 68
40381b21:	b88c      	beqz.n	a8, 40381b30 <spi_flash_chip_winbond_erase_block+0x74>
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->block_erase_size);
40381b23:	1798      	l32i.n	a9, a7, 4
40381b25:	99c8      	l32i.n	a12, a9, 36
40381b27:	03bd      	mov.n	a11, a3
40381b29:	0008e0        	callx8	a8
40381b2c:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
40381b2e:	eaec      	bnez.n	a10, 40381b60 <spi_flash_chip_winbond_erase_block+0xa4>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
40381b30:	1788      	l32i.n	a8, a7, 4
40381b32:	152892        	l32i	a9, a8, 84
40381b35:	1888      	l32i.n	a8, a8, 4
40381b37:	28b8      	l32i.n	a11, a8, 8
40381b39:	07ad      	mov.n	a10, a7
40381b3b:	0009e0        	callx8	a9
40381b3e:	0a2d      	mov.n	a2, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
40381b40:	2788      	l32i.n	a8, a7, 8
40381b42:	9888      	l32i.n	a8, a8, 36
40381b44:	488c      	beqz.n	a8, 40381b4c <spi_flash_chip_winbond_erase_block+0x90>
40381b46:	00a0a2        	movi	a10, 0
40381b49:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381b4c:	06a182        	movi	a8, 0x106
40381b4f:	0d9287        	bne	a2, a8, 40381b60 <spi_flash_chip_winbond_erase_block+0xa4>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
40381b52:	1788      	l32i.n	a8, a7, 4
40381b54:	b888      	l32i.n	a8, a8, 44
40381b56:	1b0c      	movi.n	a11, 1
40381b58:	20a770        	or	a10, a7, a7
40381b5b:	0008e0        	callx8	a8
40381b5e:	0a2d      	mov.n	a2, a10
}
40381b60:	f01d      	retw.n
	...

40381b64 <spi_flash_chip_winbond_read>:
{
40381b64:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
40381b67:	1288      	l32i.n	a8, a2, 4
40381b69:	132892        	l32i	a9, a8, 76
40381b6c:	176192        	s32i	a9, a1, 92
    if (REGION_32BIT(address, length)) {
40381b6f:	945a      	add.n	a9, a4, a5
40381b71:	cceba1        	l32r	a10, 40374f20 <_iram_text_start+0xb1c> (1000000 <UserFrameTotalSize+0xffff00>)
40381b74:	063a97        	bltu	a10, a9, 40381b7e <spi_flash_chip_winbond_read+0x1a>
    uint32_t config_io_flags = 0;
40381b77:	0b0c      	movi.n	a11, 0
40381b79:	000106        	j	40381b81 <spi_flash_chip_winbond_read+0x1d>
40381b7c:	b20000        	mulsh	a0, a0, a0
        config_io_flags |= SPI_FLASH_CONFIG_IO_MODE_32B_ADDR;
40381b7f:	8201a0        	mull	a0, a1, a10
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
40381b82:	1e28      	l32i.n	a2, a14, 4
40381b84:	20a220        	or	a10, a2, a2
40381b87:	0008e0        	callx8	a8
40381b8a:	1561a2        	s32i	a10, a1, 84
    if (err == ESP_ERR_NOT_SUPPORTED) {
40381b8d:	06a182        	movi	a8, 0x106
40381b90:	021a87        	beq	a10, a8, 40381b96 <spi_flash_chip_winbond_read+0x32>
40381b93:	001e46        	j	40381c10 <spi_flash_chip_winbond_read+0xac>
        ESP_LOGE(TAG, "configure host io mode failed - unsupported");
40381b96:	fe06e5        	call8	4037fc04 <esp_log_timestamp>
40381b99:	cd72b1        	l32r	a11, 40375164 <_iram_text_start+0xd60> (3fc94c58 <TAG>)
40381b9c:	20ebb0        	or	a14, a11, a11
40381b9f:	0add      	mov.n	a13, a10
40381ba1:	cd71c1        	l32r	a12, 40375168 <_iram_text_start+0xd64> (3fc94090 <__func__$0+0x4a4>)
40381ba4:	1a0c      	movi.n	a10, 1
40381ba6:	fdf825        	call8	4037fb28 <esp_log>
        return err;
40381ba9:	001c06        	j	40381c1d <spi_flash_chip_winbond_read+0xb9>
40381bac:	00          	.byte	00
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
40381bad:	614b      	addi.n	a6, a1, 4
40381baf:	0c4c      	movi.n	a12, 64
40381bb1:	ffa0b2        	movi	a11, 255
40381bb4:	06ad      	mov.n	a10, a6
40381bb6:	ca4081        	l32r	a8, 403744b8 <_iram_text_start+0xb4> (400011e8 <memset>)
40381bb9:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
40381bbc:	02a8      	l32i.n	a10, a2, 0
40381bbe:	0a88      	l32i.n	a8, a10, 0
40381bc0:	d888      	l32i.n	a8, a8, 52
40381bc2:	1721e2        	l32i	a14, a1, 92
40381bc5:	01dd      	mov.n	a13, a1
40381bc7:	05cd      	mov.n	a12, a5
40381bc9:	04bd      	mov.n	a11, a4
40381bcb:	0008e0        	callx8	a8
40381bce:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
40381bd0:	01c8      	l32i.n	a12, a1, 0
40381bd2:	c084c0        	sub	a8, a4, a12
40381bd5:	166182        	s32i	a8, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
40381bd8:	754a      	add.n	a7, a5, a4
40381bda:	8caa      	add.n	a8, a12, a10
40381bdc:	637780        	minu	a7, a7, a8
40381bdf:	c08740        	sub	a8, a7, a4
40381be2:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
40381be5:	02a8      	l32i.n	a10, a2, 0
40381be7:	0a88      	l32i.n	a8, a10, 0
40381be9:	b888      	l32i.n	a8, a8, 44
40381beb:	20b660        	or	a11, a6, a6
40381bee:	0008e0        	callx8	a8
40381bf1:	1561a2        	s32i	a10, a1, 84
        memcpy(buffer, temp_buffer + left_off, data_len);
40381bf4:	1421c2        	l32i	a12, a1, 80
40381bf7:	162192        	l32i	a9, a1, 88
40381bfa:	b69a      	add.n	a11, a6, a9
40381bfc:	03ad      	mov.n	a10, a3
40381bfe:	ca4081        	l32r	a8, 40374500 <_iram_text_start+0xfc> (400011f4 <memcpy>)
40381c01:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
40381c04:	142182        	l32i	a8, a1, 80
40381c07:	338a      	add.n	a3, a3, a8
        length = length - data_len;
40381c09:	c04470        	sub	a4, a4, a7
40381c0c:	554a      	add.n	a5, a5, a4
        address += data_len;
40381c0e:	074d      	mov.n	a4, a7
    while (err == ESP_OK && length > 0) {
40381c10:	180c      	movi.n	a8, 1
40381c12:	838550        	moveqz	a8, a5, a5
40381c15:	152192        	l32i	a9, a1, 84
40381c18:	19cc      	bnez.n	a9, 40381c1d <spi_flash_chip_winbond_read+0xb9>
40381c1a:	f8f856        	bnez	a8, 40381bad <spi_flash_chip_winbond_read+0x49>
}
40381c1d:	152122        	l32i	a2, a1, 84
40381c20:	f01d      	retw.n
	...

40381c24 <spi_flash_chip_winbond_probe>:
{
40381c24:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
40381c27:	f53030        	extui	a3, a3, 16, 16
40381c2a:	efa082        	movi	a8, 239
40381c2d:	049387        	bne	a3, a8, 40381c35 <spi_flash_chip_winbond_probe+0x11>
    return ESP_OK;
40381c30:	020c      	movi.n	a2, 0
40381c32:	000086        	j	40381c38 <spi_flash_chip_winbond_probe+0x14>
        return ESP_ERR_NOT_FOUND;
40381c35:	05a122        	movi	a2, 0x105
}
40381c38:	f01d      	retw.n
	...

40381c3c <spi_flash_chip_winbond_get_caps>:
{
40381c3c:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
40381c3f:	180282        	l8ui	a8, a2, 24
40381c42:	891c      	movi.n	a9, 24
40381c44:	043987        	bltu	a9, a8, 40381c4c <spi_flash_chip_winbond_get_caps+0x10>
    spi_flash_caps_t caps_flags = 0;
40381c47:	020c      	movi.n	a2, 0
40381c49:	000046        	j	40381c4e <spi_flash_chip_winbond_get_caps+0x12>
        caps_flags |= SPI_FLASH_CHIP_CAP_32MB_SUPPORT;
40381c4c:	220c      	movi.n	a2, 2
}
40381c4e:	480c      	movi.n	a8, 4
40381c50:	202280        	or	a2, a2, a8
40381c53:	f01d      	retw.n
40381c55:	000000        	ill

40381c58 <spi_flash_enable_high_performance_mode>:
//!CONFIG_SPI_FLASH_UNDER_HIGH_FREQ

static spi_flash_hpm_dummy_conf_t s_dummy_conf;

esp_err_t spi_flash_enable_high_performance_mode(void)
{
40381c58:	004136        	entry	a1, 32
    return ESP_OK;
}
40381c5b:	020c      	movi.n	a2, 0
40381c5d:	f01d      	retw.n
	...

40381c60 <s_register_rom_function>:
extern const spiflash_legacy_funcs_t *rom_spiflash_legacy_funcs;
static uint32_t s_chip_id;


static void s_register_rom_function(void)
{
40381c60:	004136        	entry	a1, 32
        .write = esp_rom_opiflash_write,
        .wait_idle = esp_rom_opiflash_wait_idle,
        .wren = esp_rom_opiflash_wren,
        .erase_area = esp_rom_opiflash_erase_area,
    };
    rom_spiflash_legacy_funcs = &rom_func;
40381c63:	cd4281        	l32r	a8, 4037516c <_iram_text_start+0xd68> (3fceffe8 <rom_spiflash_legacy_funcs>)
40381c66:	cd4291        	l32r	a9, 40375170 <_iram_text_start+0xd6c> (3fc92a18 <rom_func$0>)
40381c69:	0899      	s32i.n	a9, a8, 0
}
40381c6b:	f01d      	retw.n
40381c6d:	000000        	ill

40381c70 <s_set_pin_drive_capability>:
                              ESP_ROM_OPIFLASH_SEL_CS0,
                              false);
}

static void s_set_pin_drive_capability(uint8_t drv)
{
40381c70:	004136        	entry	a1, 32
    //flash clock
    REG_SET_FIELD(SPI_MEM_DATE_REG(0), SPI_MEM_SPI_FMEM_SPICLK_FUN_DRV, 3);
40381c73:	cb2091        	l32r	a9, 403748f4 <_iram_text_start+0x4f0> (600033fc <SPIMEM0+0x3fc>)
40381c76:	0020c0        	memw
40381c79:	0988      	l32i.n	a8, a9, 0
40381c7b:	ca0c      	movi.n	a10, 12
40381c7d:	2088a0        	or	a8, a8, a10
40381c80:	0020c0        	memw
40381c83:	0989      	s32i.n	a8, a9, 0
    //cs0
    PIN_SET_DRV(IO_MUX_GPIO29_REG, 3);
40381c85:	cd3b91        	l32r	a9, 40375174 <_iram_text_start+0xd70> (60009078 <SENS+0x878>)
40381c88:	0020c0        	memw
40381c8b:	0988      	l32i.n	a8, a9, 0
40381c8d:	cb1ba1        	l32r	a10, 403748fc <_iram_text_start+0x4f8> (c00 <UserFrameTotalSize+0xb00>)
40381c90:	2088a0        	or	a8, a8, a10
40381c93:	0020c0        	memw
40381c96:	0989      	s32i.n	a8, a9, 0
}
40381c98:	f01d      	retw.n
	...

40381c9c <s_probe_mxic_chip>:
{
40381c9c:	004136        	entry	a1, 32
    if (chip_id >> 16 != ESP_FLASH_CHIP_MXIC_OCT) {
40381c9f:	f59020        	extui	a9, a2, 16, 16
40381ca2:	c2a082        	movi	a8, 194
40381ca5:	379987        	bne	a9, a8, 40381ce0 <s_probe_mxic_chip+0x44>
    if (((chip_id >> 8) & 0xf0) != 0x80) {
40381ca8:	342c20        	extui	a2, a2, 12, 4
40381cab:	112240        	slli	a2, a2, 12
40381cae:	c9ee81        	l32r	a8, 40374468 <_iram_text_start+0x64> (8000 <UserFrameTotalSize+0x7f00>)
40381cb1:	1f1287        	beq	a2, a8, 40381cd4 <s_probe_mxic_chip+0x38>
40381cb4:	c9f381        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40381cb7:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Detected MXIC Flash, but memory type is not Octal");
40381cb9:	f88c      	beqz.n	a8, 40381ccc <s_probe_mxic_chip+0x30>
40381cbb:	fdf4a5        	call8	4037fc04 <esp_log_timestamp>
40381cbe:	cd2ec1        	l32r	a12, 40375178 <_iram_text_start+0xd74> (3fc93fe0 <__func__$0+0x3f4>)
40381cc1:	0abd      	mov.n	a11, a10
40381cc3:	cd2ea1        	l32r	a10, 4037517c <_iram_text_start+0xd78> (3fc93fec <__func__$0+0x400>)
40381cc6:	ca0581        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40381cc9:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
40381ccc:	05a122        	movi	a2, 0x105
40381ccf:	000406        	j	40381ce3 <s_probe_mxic_chip+0x47>
40381cd2:	820000        	mull	a0, a0, a0
    *out_vendor_id = ESP_FLASH_CHIP_MXIC_OCT;
40381cd5:	4382c2af 	ee.vmulas.u16.accx.ld.ip.qup	q6, a10, 32, q7, q1, q0, q2
40381cd9:	020c00        	andb	b0, b12, b0
    return ESP_OK;
40381cdc:	0000c6        	j	40381ce3 <s_probe_mxic_chip+0x47>
40381cdf:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_FOUND;
40381ce2:	f01d05        	call0	40371eb4 <rom_rx_gain_force+0x36ba88>
40381ce5:	000000        	ill

40381ce8 <s_mxic_set_required_regs>:
    esp_rom_opiflash_wait_idle();
}
#endif   // #if CONFIG_SPI_FLASH_SUPPORT_MXIC_OPI_CHIP

static void s_mxic_set_required_regs(uint32_t chip_id)
{
40381ce8:	004136        	entry	a1, 32
#if CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_DTR
    is_swap = true;
#else
    //STR mode does not need to enable ddr_swap registers
#endif
    esp_rom_spi_set_dtr_swap_mode(0, is_swap, is_swap);
40381ceb:	0c0c      	movi.n	a12, 0
40381ced:	0cbd      	mov.n	a11, a12
40381cef:	20acc0        	or	a10, a12, a12
40381cf2:	cd2381        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381cf5:	0008e0        	callx8	a8
    esp_rom_spi_set_dtr_swap_mode(1, is_swap, is_swap);
40381cf8:	0c0c      	movi.n	a12, 0
40381cfa:	0cbd      	mov.n	a11, a12
40381cfc:	1a0c      	movi.n	a10, 1
40381cfe:	cd2081        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381d01:	0008e0        	callx8	a8
}
40381d04:	f01d      	retw.n
	...

40381d08 <s_set_flash_ouput_driver_strength>:
{
40381d08:	00a136        	entry	a1, 80
    uint16_t reg_val = 0;
40381d0b:	080c      	movi.n	a8, 0
40381d0d:	105182        	s16i	a8, a1, 32
    uint8_t sr_reg_val = 0;
40381d10:	224182        	s8i	a8, a1, 34
    uint8_t cr_reg_val = 0;
40381d13:	234182        	s8i	a8, a1, 35
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381d16:	070c      	movi.n	a7, 0
40381d18:	6179      	s32i.n	a7, a1, 24
40381d1a:	150c      	movi.n	a5, 1
40381d1c:	5159      	s32i.n	a5, a1, 20
40381d1e:	860c      	movi.n	a6, 8
40381d20:	4169      	s32i.n	a6, a1, 16
40381d22:	22c182        	addi	a8, a1, 34
40381d25:	3189      	s32i.n	a8, a1, 12
40381d27:	2179      	s32i.n	a7, a1, 8
40381d29:	1179      	s32i.n	a7, a1, 4
40381d2b:	0179      	s32i.n	a7, a1, 0
40381d2d:	07fd      	mov.n	a15, a7
40381d2f:	07ed      	mov.n	a14, a7
40381d31:	06dd      	mov.n	a13, a6
40381d33:	5c0c      	movi.n	a12, 5
40381d35:	4b0c      	movi.n	a11, 4
40381d37:	20a220        	or	a10, a2, a2
40381d3a:	cd1281        	l32r	a8, 40375184 <_iram_text_start+0xd80> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381d3d:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381d40:	6179      	s32i.n	a7, a1, 24
40381d42:	5159      	s32i.n	a5, a1, 20
40381d44:	4169      	s32i.n	a6, a1, 16
40381d46:	23c182        	addi	a8, a1, 35
40381d49:	3189      	s32i.n	a8, a1, 12
40381d4b:	2179      	s32i.n	a7, a1, 8
40381d4d:	1179      	s32i.n	a7, a1, 4
40381d4f:	0179      	s32i.n	a7, a1, 0
40381d51:	07fd      	mov.n	a15, a7
40381d53:	07ed      	mov.n	a14, a7
40381d55:	06dd      	mov.n	a13, a6
40381d57:	5c1c      	movi.n	a12, 21
40381d59:	4b0c      	movi.n	a11, 4
40381d5b:	20a220        	or	a10, a2, a2
40381d5e:	cd0981        	l32r	a8, 40375184 <_iram_text_start+0xd80> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381d61:	0008e0        	callx8	a8
    reg_val = (((cr_reg_val & 0xf8) | strength) << 8) | sr_reg_val;
40381d64:	230182        	l8ui	a8, a1, 35
40381d67:	897c      	movi.n	a9, -8
40381d69:	108890        	and	a8, a8, a9
40381d6c:	203380        	or	a3, a3, a8
40381d6f:	401600        	ssl	a6
40381d72:	a13300        	sll	a3, a3
40381d75:	220182        	l8ui	a8, a1, 34
40381d78:	208830        	or	a8, a8, a3
40381d7b:	105182        	s16i	a8, a1, 32
    esp_rom_spiflash_write_enable(&g_rom_flashchip);
40381d7e:	ca8f81        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40381d81:	08a8      	l32i.n	a10, a8, 0
40381d83:	cd0181        	l32r	a8, 40375188 <_iram_text_start+0xd84> (40000a44 <SPI_write_enable>)
40381d86:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381d89:	6179      	s32i.n	a7, a1, 24
40381d8b:	5159      	s32i.n	a5, a1, 20
40381d8d:	4179      	s32i.n	a7, a1, 16
40381d8f:	3179      	s32i.n	a7, a1, 12
40381d91:	081c      	movi.n	a8, 16
40381d93:	2189      	s32i.n	a8, a1, 8
40381d95:	20c182        	addi	a8, a1, 32
40381d98:	1189      	s32i.n	a8, a1, 4
40381d9a:	0179      	s32i.n	a7, a1, 0
40381d9c:	07fd      	mov.n	a15, a7
40381d9e:	07ed      	mov.n	a14, a7
40381da0:	06dd      	mov.n	a13, a6
40381da2:	05cd      	mov.n	a12, a5
40381da4:	4b0c      	movi.n	a11, 4
40381da6:	02ad      	mov.n	a10, a2
40381da8:	ccf781        	l32r	a8, 40375184 <_iram_text_start+0xd80> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381dab:	0008e0        	callx8	a8
}
40381dae:	f01d      	retw.n

40381db0 <s_set_flash_dtr_str_opi_mode>:
{
40381db0:	00a136        	entry	a1, 80
40381db3:	204132        	s8i	a3, a1, 32
    esp_rom_spiflash_write_enable(&g_rom_flashchip);
40381db6:	ca8181        	l32r	a8, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40381db9:	0028a2        	l32i	a10, a8, 0
40381dbc:	ccf381        	l32r	a8, 40375188 <_iram_text_start+0xd84> (40000a44 <SPI_write_enable>)
40381dbf:	0008e0        	callx8	a8
    esp_rom_opiflash_exec_cmd(spi_num, ESP_ROM_SPIFLASH_FASTRD_MODE,
40381dc2:	0e0c      	movi.n	a14, 0
40381dc4:	61e9      	s32i.n	a14, a1, 24
40381dc6:	180c      	movi.n	a8, 1
40381dc8:	5189      	s32i.n	a8, a1, 20
40381dca:	41e9      	s32i.n	a14, a1, 16
40381dcc:	31e9      	s32i.n	a14, a1, 12
40381dce:	8d0c      	movi.n	a13, 8
40381dd0:	21d9      	s32i.n	a13, a1, 8
40381dd2:	20c182        	addi	a8, a1, 32
40381dd5:	1189      	s32i.n	a8, a1, 4
40381dd7:	01e9      	s32i.n	a14, a1, 0
40381dd9:	0f2c      	movi.n	a15, 32
40381ddb:	72a0c2        	movi	a12, 114
40381dde:	4b0c      	movi.n	a11, 4
40381de0:	02ad      	mov.n	a10, a2
40381de2:	cce881        	l32r	a8, 40375184 <_iram_text_start+0xd80> (400008b8 <esp_rom_opiflash_exec_cmd>)
40381de5:	0008e0        	callx8	a8
}
40381de8:	f01d      	retw.n
	...

40381dec <s_flash_init_mxic>:
{
40381dec:	004136        	entry	a1, 32
    esp_rom_opiflash_legacy_driver_init(&opiflash_cmd_def_mxic);
40381def:	cce7a1        	l32r	a10, 4037518c <_iram_text_start+0xd88> (3fc94c60 <opiflash_cmd_def_mxic$1>)
40381df2:	cce881        	l32r	a8, 40375194 <_iram_text_start+0xd90> (40000954 <esp_rom_opiflash_legacy_driver_init>)
40381df5:	0008e0        	callx8	a8
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40381df8:	ca7171        	l32r	a7, 403747bc <_iram_text_start+0x3b8> (3fceffe4 <rom_spiflash_legacy_data>)
40381dfb:	0027a2        	l32i	a10, a7, 0
40381dfe:	cce681        	l32r	a8, 40375198 <_iram_text_start+0xd94> (40000960 <esp_rom_spiflash_wait_idle>)
40381e01:	0008e0        	callx8	a8
    s_set_flash_ouput_driver_strength(1, 7);
40381e04:	7b0c      	movi.n	a11, 7
40381e06:	1a0c      	movi.n	a10, 1
40381e08:	ffefe5        	call8	40381d08 <s_set_flash_ouput_driver_strength>
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40381e0b:	07a8      	l32i.n	a10, a7, 0
40381e0d:	cce281        	l32r	a8, 40375198 <_iram_text_start+0xd94> (40000960 <esp_rom_spiflash_wait_idle>)
40381e10:	0008e0        	callx8	a8
    s_set_pin_drive_capability(3);
40381e13:	3a0c      	movi.n	a10, 3
40381e15:	ffe5a5        	call8	40381c70 <s_set_pin_drive_capability>
    s_set_flash_dtr_str_opi_mode(1, 0x1);
40381e18:	1b0c      	movi.n	a11, 1
40381e1a:	0bad      	mov.n	a10, a11
40381e1c:	fff925        	call8	40381db0 <s_set_flash_dtr_str_opi_mode>
    esp_rom_opiflash_cache_mode_config(mode, &rom_opiflash_cmd_def->cache_rd_cmd);
40381e1f:	ccdc81        	l32r	a8, 40375190 <_iram_text_start+0xd8c> (3fcefff4 <rom_opiflash_cmd_def>)
40381e22:	08b8      	l32i.n	a11, a8, 0
40381e24:	54cbb2        	addi	a11, a11, 84
40381e27:	02ad      	mov.n	a10, a2
40381e29:	f76f65        	call8	40379520 <esp_rom_opiflash_cache_mode_config>
    esp_rom_spi_set_dtr_swap_mode(0, false, false);
40381e2c:	0c0c      	movi.n	a12, 0
40381e2e:	0cbd      	mov.n	a11, a12
40381e30:	0cad      	mov.n	a10, a12
40381e32:	ccd381        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381e35:	0008e0        	callx8	a8
    esp_rom_spi_set_dtr_swap_mode(1, false, false);
40381e38:	0c0c      	movi.n	a12, 0
40381e3a:	0cbd      	mov.n	a11, a12
40381e3c:	1a0c      	movi.n	a10, 1
40381e3e:	ccd081        	l32r	a8, 40375180 <_iram_text_start+0xd7c> (4000093c <esp_rom_spi_set_dtr_swap_mode>)
40381e41:	0008e0        	callx8	a8
    esp_rom_opiflash_wait_idle();
40381e44:	ccd681        	l32r	a8, 4037519c <_iram_text_start+0xd98> (400008e8 <esp_rom_opiflash_wait_idle>)
40381e47:	0008e0        	callx8	a8
}
40381e4a:	f01d      	retw.n

40381e4c <esp_opiflash_init>:

//To check which Flash chip is used
static const opi_flash_func_t **s_chip_func = NULL;

esp_err_t esp_opiflash_init(uint32_t chip_id)
{
40381e4c:	006136        	entry	a1, 48
    mode = ESP_ROM_SPIFLASH_FASTRD_MODE;
#endif

    const opi_flash_func_t **chip_func = &registered_chip_funcs[0];

    uint8_t vendor_id = 0;
40381e4f:	080c      	movi.n	a8, 0
40381e51:	004182        	s8i	a8, a1, 0
    const opi_flash_func_t **chip_func = &registered_chip_funcs[0];
40381e54:	ccd361        	l32r	a6, 403751a0 <_iram_text_start+0xd9c> (3fc92a4c <registered_chip_funcs>)
    esp_err_t ret = ESP_FAIL;
40381e57:	f77c      	movi.n	a7, -1
    while (*chip_func) {
40381e59:	0009c6        	j	40381e84 <esp_opiflash_init+0x38>
40381e5c:	00          	.byte	00
        ret = (*chip_func)->probe(chip_id, &vendor_id);
40381e5d:	002882        	l32i	a8, a8, 0
40381e60:	20b110        	or	a11, a1, a1
40381e63:	20a220        	or	a10, a2, a2
40381e66:	0008e0        	callx8	a8
40381e69:	0a7d      	mov.n	a7, a10
        if (ret == ESP_OK) {
40381e6b:	2adc      	bnez.n	a10, 40381e81 <esp_opiflash_init+0x35>
            // Detect this is the supported chip type
            s_chip_id = chip_id;
40381e6d:	cccd81        	l32r	a8, 403751a4 <_iram_text_start+0xda0> (3fc953cc <s_chip_id>)
40381e70:	0829      	s32i.n	a2, a8, 0
            (*chip_func)->init(mode);
40381e72:	0688      	l32i.n	a8, a6, 0
40381e74:	1888      	l32i.n	a8, a8, 4
40381e76:	6a0c      	movi.n	a10, 6
40381e78:	0008e0        	callx8	a8
            s_register_rom_function();
40381e7b:	ffde65        	call8	40381c60 <s_register_rom_function>
            break;
40381e7e:	000206        	j	40381e8a <esp_opiflash_init+0x3e>
        }
        chip_func++;
40381e81:	04c662        	addi	a6, a6, 4
    while (*chip_func) {
40381e84:	002682        	l32i	a8, a6, 0
40381e87:	fd2856        	bnez	a8, 40381e5d <esp_opiflash_init+0x11>
    }
    s_chip_func = chip_func;
40381e8a:	ccc781        	l32r	a8, 403751a8 <_iram_text_start+0xda4> (3fc953c8 <s_chip_func>)
40381e8d:	0869      	s32i.n	a6, a8, 0

    if (ret != ESP_OK) {
40381e8f:	979c      	beqz.n	a7, 40381eac <esp_opiflash_init+0x60>
40381e91:	c97b81        	l32r	a8, 40374480 <_iram_text_start+0x7c> (3fc92438 <esp_log_default_level>)
40381e94:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "No detected Flash chip, please check the menuconfig to see if the chip is supported");
40381e96:	f88c      	beqz.n	a8, 40381ea9 <esp_opiflash_init+0x5d>
40381e98:	fdd6a5        	call8	4037fc04 <esp_log_timestamp>
40381e9b:	ccb7c1        	l32r	a12, 40375178 <_iram_text_start+0xd74> (3fc93fe0 <__func__$0+0x3f4>)
40381e9e:	0abd      	mov.n	a11, a10
40381ea0:	ccc3a1        	l32r	a10, 403751ac <_iram_text_start+0xda8> (3fc9402c <__func__$0+0x440>)
40381ea3:	c98e81        	l32r	a8, 403744dc <_iram_text_start+0xd8> (400005d0 <esp_rom_printf>)
40381ea6:	0008e0        	callx8	a8
        abort();
40381ea9:	fddc25        	call8	4037fc6c <abort>
    }

    return ESP_OK;
}
40381eac:	020c      	movi.n	a2, 0
40381eae:	f01d      	retw.n

40381eb0 <delay_us>:
{
40381eb0:	004136        	entry	a1, 32
40381eb3:	20a330        	or	a10, a3, a3
    esp_rom_delay_us(us);
40381eb6:	c95781        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40381eb9:	0008e0        	callx8	a8
}
40381ebc:	020c      	movi.n	a2, 0
40381ebe:	f01d      	retw.n

40381ec0 <get_buffer_malloc>:
{
40381ec0:	004136        	entry	a1, 32
    unsigned retries = 5;
40381ec3:	580c      	movi.n	a8, 5
    void* ret = NULL;
40381ec5:	0a0c      	movi.n	a10, 0
    while(ret == NULL && retries--) {
40381ec7:	000a86        	j	40381ef5 <get_buffer_malloc+0x35>
40381eca:	a10000        	sll	a0, a0
        read_chunk_size = MIN(read_chunk_size, heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT));
40381ecd:	81cb51        	l32r	a5, 403625fc <rom_rx_gain_force+0x35c1d0>
40381ed0:	ccb8      	l32i.n	a11, a12, 48
40381ed2:	0008e0        	callx8	a8
40381ed5:	0b33a7        	bltu	a3, a10, 40381ee4 <get_buffer_malloc+0x24>
40381ed8:	cb4ea1        	l32r	a10, 40374c10 <_iram_text_start+0x80c> (804 <UserFrameTotalSize+0x704>)
40381edb:	ccb581        	l32r	a8, 403751b0 <_iram_text_start+0xdac> (42002dd4 <heap_caps_get_largest_free_block>)
40381ede:	0008e0        	callx8	a8
40381ee1:	203aa0        	or	a3, a10, a10
        read_chunk_size = (read_chunk_size + 3) & ~3;
40381ee4:	333b      	addi.n	a3, a3, 3
40381ee6:	c87c      	movi.n	a8, -4
40381ee8:	103380        	and	a3, a3, a8
        ret = heap_caps_malloc(read_chunk_size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
40381eeb:	cb49b1        	l32r	a11, 40374c10 <_iram_text_start+0x80c> (804 <UserFrameTotalSize+0x704>)
40381eee:	03ad      	mov.n	a10, a3
40381ef0:	f3fd25        	call8	40375ec4 <heap_caps_malloc>
    while(ret == NULL && retries--) {
40381ef3:	078d      	mov.n	a8, a7
40381ef5:	3acc      	bnez.n	a10, 40381efc <get_buffer_malloc+0x3c>
40381ef7:	780b      	addi.n	a7, a8, -1
40381ef9:	fcf856        	bnez	a8, 40381ecc <get_buffer_malloc+0xc>
    *out_size = (ret != NULL? read_chunk_size: 0);
40381efc:	0acc      	bnez.n	a10, 40381f00 <get_buffer_malloc+0x40>
40381efe:	030c      	movi.n	a3, 0
40381f00:	0439      	s32i.n	a3, a4, 0
}
40381f02:	0a2d      	mov.n	a2, a10
40381f04:	f01d      	retw.n
	...

40381f08 <main_flash_op_status>:
{
40381f08:	004136        	entry	a1, 32
    spi_flash_set_erasing_flag(is_erasing);
40381f0b:	04a020        	extui	a10, a2, 0, 1
40381f0e:	fe39a5        	call8	403802a8 <spi_flash_set_erasing_flag>
}
40381f11:	f01d      	retw.n
	...

40381f14 <main_flash_region_protected>:
{
40381f14:	004136        	entry	a1, 32
    if (!esp_partition_is_flash_region_writable(start_addr, size)) {
40381f17:	04bd      	mov.n	a11, a4
40381f19:	03ad      	mov.n	a10, a3
40381f1b:	cca681        	l32r	a8, 403751b4 <_iram_text_start+0xdb0> (4200c5a4 <esp_partition_is_flash_region_writable>)
40381f1e:	0008e0        	callx8	a8
40381f21:	4a9c      	beqz.n	a10, 40381f39 <main_flash_region_protected+0x25>
    if (((app_func_arg_t*)arg)->no_protect || esp_partition_main_flash_region_safe(start_addr, size)) {
40381f23:	040282        	l8ui	a8, a2, 4
40381f26:	a8cc      	bnez.n	a8, 40381f34 <main_flash_region_protected+0x20>
40381f28:	04bd      	mov.n	a11, a4
40381f2a:	03ad      	mov.n	a10, a3
40381f2c:	cca381        	l32r	a8, 403751b8 <_iram_text_start+0xdb4> (4200c5f4 <esp_partition_main_flash_region_safe>)
40381f2f:	0008e0        	callx8	a8
40381f32:	aa8c      	beqz.n	a10, 40381f40 <main_flash_region_protected+0x2c>
        return ESP_OK;
40381f34:	020c      	movi.n	a2, 0
40381f36:	000246        	j	40381f43 <main_flash_region_protected+0x2f>
        return ESP_ERR_NOT_ALLOWED;
40381f39:	0da122        	movi	a2, 0x10d
40381f3c:	0000c6        	j	40381f43 <main_flash_region_protected+0x2f>
40381f3f:	a12200        	sll	a2, a2
        return ESP_ERR_NOT_SUPPORTED;
40381f42:	f01d06        	j	4037dfba <spi_flash_hal_setup_auto_suspend_mode+0xa6>
40381f45:	000000        	ill

40381f48 <release_buffer_malloc>:
{
40381f48:	004136        	entry	a1, 32
40381f4b:	03ad      	mov.n	a10, a3
    free(temp_buf);
40381f4d:	fdf425        	call8	4037fe90 <cfree>
}
40381f50:	f01d      	retw.n
	...

40381f54 <spi_flash_os_check_yield>:
{
40381f54:	004136        	entry	a1, 32
40381f57:	02ad      	mov.n	a10, a2
    assert (chip_status == 0);  //TODO: support suspend
40381f59:	039c      	beqz.n	a3, 40381f6d <spi_flash_os_check_yield+0x19>
40381f5b:	cc98d1        	l32r	a13, 403751bc <_iram_text_start+0xdb8> (3c025684 <_flash_rodata_start+0x5564>)
40381f5e:	cc98c1        	l32r	a12, 403751c0 <_iram_text_start+0xdbc> (3c027a9c <__func__$0>)
40381f61:	afa0b2        	movi	a11, 175
40381f64:	cc98a1        	l32r	a10, 403751c4 <_iram_text_start+0xdc0> (3c0256b3 <_flash_rodata_start+0x5593>)
40381f67:	201110        	or	a1, a1, a1
40381f6a:	fddbe5        	call8	4037fd28 <__assert_func>
    if (on_spi_check_yield((app_func_arg_t *)arg)) {
40381f6d:	f5bae5        	call8	40377b1c <on_spi_check_yield>
40381f70:	9acc      	bnez.n	a10, 40381f7d <spi_flash_os_check_yield+0x29>
    uint32_t request = 0;
40381f72:	080c      	movi.n	a8, 0
    esp_err_t ret = ESP_ERR_TIMEOUT;    //Nothing happened
40381f74:	07a122        	movi	a2, 0x107
40381f77:	000186        	j	40381f81 <spi_flash_os_check_yield+0x2d>
40381f7a:	000000        	ill
        request = SPI_FLASH_YIELD_REQ_YIELD;
40381f7d:	180c      	movi.n	a8, 1
        ret = ESP_OK;
40381f7f:	020c      	movi.n	a2, 0
    if (out_request) {
40381f81:	048c      	beqz.n	a4, 40381f85 <spi_flash_os_check_yield+0x31>
        *out_request = request;
40381f83:	0489      	s32i.n	a8, a4, 0
}
40381f85:	f01d      	retw.n
	...

40381f88 <spi_flash_os_yield>:
{
40381f88:	004136        	entry	a1, 32
    if (likely(xTaskGetSchedulerState() == taskSCHEDULER_RUNNING)) {
40381f8b:	f99aa5        	call8	4037b934 <xTaskGetSchedulerState>
40381f8e:	052a66        	bnei	a10, 2, 40381f97 <spi_flash_os_yield+0xf>
        vTaskDelay(CONFIG_SPI_FLASH_ERASE_YIELD_TICKS);
40381f91:	01a0a2        	movi	a10, 1
40381f94:	f9aca5        	call8	4037ba60 <vTaskDelay>
    // in that function instead.
}

static inline IRAM_ATTR void on_spi_yielded(app_func_arg_t* ctx)
{
    uint32_t time = esp_system_get_time();
40381f97:	f32365        	call8	403751cc <esp_system_get_time>
    ctx->acquired_since_us = time;
40381f9a:	22a9      	s32i.n	a10, a2, 8
}
40381f9c:	020c      	movi.n	a2, 0
40381f9e:	f01d      	retw.n

40381fa0 <delay_us>:

static esp_err_t delay_us(void *arg, uint32_t us)
{
40381fa0:	004136        	entry	a1, 32
40381fa3:	20a330        	or	a10, a3, a3
    esp_rom_delay_us(us);
40381fa6:	c91b81        	l32r	a8, 40374414 <_iram_text_start+0x10> (40000600 <esp_rom_delay_us>)
40381fa9:	0008e0        	callx8	a8
    return ESP_OK;
}
40381fac:	020c      	movi.n	a2, 0
40381fae:	f01d      	retw.n

40381fb0 <xthal_window_spill_nw>:
40381fb0:	034820        	rsr.windowbase	a2
40381fb3:	221b      	addi.n	a2, a2, 1
40381fb5:	400200        	ssr	a2
40381fb8:	034930        	rsr.windowstart	a3
40381fbb:	912030        	srl	a2, a3
40381fbe:	a13300        	sll	a3, a3
40381fc1:	0bf3d6        	bgez	a3, 40382084 <xthal_window_spill_nw+0xd4>
40381fc4:	f53030        	extui	a3, a3, 16, 16
40381fc7:	202230        	or	a2, a2, a3
40381fca:	603020        	neg	a3, a2
40381fcd:	103320        	and	a3, a3, a2
40381fd0:	40f330        	nsau	a3, a3
40381fd3:	401300        	ssl	a3
40381fd6:	912020        	srl	a2, a2
40381fd9:	134920        	wsr.windowstart	a2
40381fdc:	034820        	rsr.windowbase	a2
40381fdf:	1fc222        	addi	a2, a2, 31
40381fe2:	c03230        	sub	a3, a2, a3
40381fe5:	134830        	wsr.windowbase	a3
40381fe8:	002010        	rsync
40381feb:	034920        	rsr.windowstart	a2
40381fee:	07a216        	beqz	a2, 4038206c <xthal_window_spill_nw+0xbc>
40381ff1:	08e207        	bbsi	a2, 0, 40381ffd <xthal_window_spill_nw+0x4d>
40381ff4:	19e217        	bbsi	a2, 1, 40382011 <xthal_window_spill_nw+0x61>
40381ff7:	3ae227        	bbsi	a2, 2, 40382035 <xthal_window_spill_nw+0x85>
40381ffa:	002306        	j	4038208a <xthal_window_spill_nw+0xda>
40381ffd:	f0c932        	addi	a3, a9, -16
40382000:	0349      	s32i.n	a4, a3, 0
40382002:	1359      	s32i.n	a5, a3, 4
40382004:	2369      	s32i.n	a6, a3, 8
40382006:	3379      	s32i.n	a7, a3, 12
40382008:	416120        	srli	a6, a2, 1
4038200b:	408010        	rotw	1
4038200e:	fff706        	j	40381fee <xthal_window_spill_nw+0x3e>
40382011:	f0cd32        	addi	a3, a13, -16
40382014:	0349      	s32i.n	a4, a3, 0
40382016:	1359      	s32i.n	a5, a3, 4
40382018:	2369      	s32i.n	a6, a3, 8
4038201a:	3379      	s32i.n	a7, a3, 12
4038201c:	f4c532        	addi	a3, a5, -12
4038201f:	0338      	l32i.n	a3, a3, 0
40382021:	e0c332        	addi	a3, a3, -32
40382024:	0389      	s32i.n	a8, a3, 0
40382026:	1399      	s32i.n	a9, a3, 4
40382028:	23a9      	s32i.n	a10, a3, 8
4038202a:	33b9      	s32i.n	a11, a3, 12
4038202c:	41a220        	srli	a10, a2, 2
4038202f:	408020        	rotw	2
40382032:	ffee06        	j	40381fee <xthal_window_spill_nw+0x3e>
40382035:	408010        	rotw	1
40382038:	f0cdd2        	addi	a13, a13, -16
4038203b:	0d09      	s32i.n	a0, a13, 0
4038203d:	1d19      	s32i.n	a1, a13, 4
4038203f:	2d29      	s32i.n	a2, a13, 8
40382041:	3d39      	s32i.n	a3, a13, 12
40382043:	f4c132        	addi	a3, a1, -12
40382046:	0338      	l32i.n	a3, a3, 0
40382048:	10cdd2        	addi	a13, a13, 16
4038204b:	d0c332        	addi	a3, a3, -48
4038204e:	0349      	s32i.n	a4, a3, 0
40382050:	1359      	s32i.n	a5, a3, 4
40382052:	2369      	s32i.n	a6, a3, 8
40382054:	3379      	s32i.n	a7, a3, 12
40382056:	4389      	s32i.n	a8, a3, 16
40382058:	5399      	s32i.n	a9, a3, 20
4038205a:	63a9      	s32i.n	a10, a3, 24
4038205c:	73b9      	s32i.n	a11, a3, 28
4038205e:	4080f0        	rotw	-1
40382061:	41e320        	srli	a14, a2, 3
40382064:	408030        	rotw	3
40382067:	ffe0c6        	j	40381fee <xthal_window_spill_nw+0x3e>
4038206a:	100000        	and	a0, a0, a0
4038206d:	204080        	or	a4, a0, a8
40382070:	0348      	l32i.n	a4, a3, 0
40382072:	401200        	ssl	a2
40382075:	120c      	movi.n	a2, 1
40382077:	a12200        	sll	a2, a2
4038207a:	134920        	wsr.windowstart	a2
4038207d:	002010        	rsync
40382080:	020c      	movi.n	a2, 0
40382082:	f00d      	ret.n
40382084:	120c      	movi.n	a2, 1
40382086:	f00d      	ret.n
40382088:	f00000        	subx8	a0, a0, a0
4038208b:	1b1122        	l16ui	a2, a1, 54
4038208e:	22          	.byte	0x22
4038208f:	034830        	rsr.windowbase	a3
40382092:	0ae2f7        	bbsi	a2, 15, 403820a0 <xthal_window_spill_nw+0xf0>
40382095:	330b      	addi.n	a3, a3, -1
40382097:	1122f0        	slli	a2, a2, 1
4038209a:	f762f7        	bbci	a2, 15, 40382095 <xthal_window_spill_nw+0xe5>
4038209d:	343030        	extui	a3, a3, 0, 4
403820a0:	401300        	ssl	a3
403820a3:	113200        	slli	a3, a2, 16
403820a6:	812230        	src	a2, a2, a3
403820a9:	f42020        	extui	a2, a2, 0, 16
403820ac:	134920        	wsr.windowstart	a2
403820af:	030330        	rsr.sar	a3
403820b2:	022c      	movi.n	a2, 32
403820b4:	c03230        	sub	a3, a2, a3
403820b7:	134830        	wsr.windowbase	a3
403820ba:	002010        	rsync
403820bd:	220c      	movi.n	a2, 2
403820bf:	f00d      	ret.n
403820c1:	000000        	ill

403820c4 <xthal_window_spill>:
403820c4:	002136        	entry	a1, 16
403820c7:	cad061        	l32r	a6, 40374c08 <_iram_text_start+0x804> (fffbfff0 <_rtc_reserved_end+0x9febfff0>)
403820ca:	03e650        	rsr.ps	a5
403820cd:	004d      	mov.n	a4, a0
403820cf:	102560        	and	a2, a5, a6
403820d2:	223b      	addi.n	a2, a2, 3
403820d4:	13e620        	wsr.ps	a2
403820d7:	002010        	rsync
403820da:	ffed45        	call0	40381fb0 <xthal_window_spill_nw>
403820dd:	040d      	mov.n	a0, a4
403820df:	13e650        	wsr.ps	a5
403820e2:	002010        	rsync
403820e5:	f01d      	retw.n
	...

403820e8 <xthal_restore_extra_nw>:
403820e8:	0238      	l32i.n	a3, a2, 0
403820ea:	f3e730        	wur.threadptr	a3
403820ed:	1238      	l32i.n	a3, a2, 4
403820ef:	131030        	wsr.acclo	a3
403820f2:	2238      	l32i.n	a3, a2, 8
403820f4:	131130        	wsr.acchi	a3
403820f7:	3238      	l32i.n	a3, a2, 12
403820f9:	130430        	wsr.br	a3
403820fc:	4238      	l32i.n	a3, a2, 16
403820fe:	130c30        	wsr.scompare1	a3
40382101:	5238      	l32i.n	a3, a2, 20
40382103:	132030        	wsr.m0	a3
40382106:	6238      	l32i.n	a3, a2, 24
40382108:	132130        	wsr.m1	a3
4038210b:	7238      	l32i.n	a3, a2, 28
4038210d:	132230        	wsr.m2	a3
40382110:	8238      	l32i.n	a3, a2, 32
40382112:	132330        	wsr.m3	a3
40382115:	f00d      	ret.n
	...

40382118 <xthal_save_extra_nw>:
40382118:	e33e70        	rur.threadptr	a3
4038211b:	0239      	s32i.n	a3, a2, 0
4038211d:	031030        	rsr.acclo	a3
40382120:	1239      	s32i.n	a3, a2, 4
40382122:	031130        	rsr.acchi	a3
40382125:	2239      	s32i.n	a3, a2, 8
40382127:	030430        	rsr.br	a3
4038212a:	3239      	s32i.n	a3, a2, 12
4038212c:	030c30        	rsr.scompare1	a3
4038212f:	4239      	s32i.n	a3, a2, 16
40382131:	032030        	rsr.m0	a3
40382134:	5239      	s32i.n	a3, a2, 20
40382136:	032130        	rsr.m1	a3
40382139:	6239      	s32i.n	a3, a2, 24
4038213b:	032230        	rsr.m2	a3
4038213e:	7239      	s32i.n	a3, a2, 28
40382140:	032330        	rsr.m3	a3
40382143:	8239      	s32i.n	a3, a2, 32
40382145:	f00d      	ret.n
	...

40382148 <_xt_context_save>:
    .literal_position
    .align  4

_xt_context_save:

    s32i    a2,  sp, XT_STK_A2
40382148:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
4038214a:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
4038214c:	7149      	s32i.n	a4, a1, 28
    s32i    a5,  sp, XT_STK_A5
4038214e:	8159      	s32i.n	a5, a1, 32
    s32i    a6,  sp, XT_STK_A6
40382150:	9169      	s32i.n	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40382152:	a179      	s32i.n	a7, a1, 40
    s32i    a8,  sp, XT_STK_A8
40382154:	b189      	s32i.n	a8, a1, 44
    s32i    a9,  sp, XT_STK_A9
40382156:	c199      	s32i.n	a9, a1, 48
    s32i    a10, sp, XT_STK_A10
40382158:	d1a9      	s32i.n	a10, a1, 52
    s32i    a11, sp, XT_STK_A11
4038215a:	e1b9      	s32i.n	a11, a1, 56
    Call0 ABI callee-saved regs a12-15 do not need to be saved here.
    a12-13 are the caller's responsibility so it can use them as scratch.
    So only need to save a14-a15 here for Windowed ABI (not Call0).
    */
    #ifndef __XTENSA_CALL0_ABI__
    s32i    a14, sp, XT_STK_A14
4038215c:	1161e2        	s32i	a14, a1, 68
    s32i    a15, sp, XT_STK_A15
4038215f:	1261f2        	s32i	a15, a1, 72
    #endif

    rsr     a3,  SAR
40382162:	030330        	rsr.sar	a3
    s32i    a3,  sp, XT_STK_SAR
40382165:	136132        	s32i	a3, a1, 76

    #if XCHAL_HAVE_LOOPS
    rsr     a3,  LBEG
40382168:	030030        	rsr.lbeg	a3
    s32i    a3,  sp, XT_STK_LBEG
4038216b:	166132        	s32i	a3, a1, 88
    rsr     a3,  LEND
4038216e:	030130        	rsr.lend	a3
    s32i    a3,  sp, XT_STK_LEND
40382171:	176132        	s32i	a3, a1, 92
    rsr     a3,  LCOUNT
40382174:	030230        	rsr.lcount	a3
    s32i    a3,  sp, XT_STK_LCOUNT
40382177:	186132        	s32i	a3, a1, 96
    l32i    a3,  a3, 0
    s32i    a3,  sp, XT_STK_VPRI
    #endif

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a9,  a0                     /* preserve ret addr */
4038217a:	009d      	mov.n	a9, a0
    #endif

    s32i    a12, sp, XT_STK_TMP0        /* temp. save stuff in stack frame */
4038217c:	1961c2        	s32i	a12, a1, 100
    s32i    a13, sp, XT_STK_TMP1
4038217f:	1a61d2        	s32i	a13, a1, 104
    s32i    a9,  sp, XT_STK_TMP2
40382182:	1b6192        	s32i	a9, a1, 108

    l32i    a12, sp, XT_STK_A12         /* recover original a9,12,13 */
40382185:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
40382187:	1021d2        	l32i	a13, a1, 64
    l32i    a9,  sp, XT_STK_A9
4038218a:	c198      	l32i.n	a9, a1, 48

    #if XCHAL_EXTRA_SA_SIZE > 0
    addi    a2,  sp, XT_STK_EXTRA       /* where to save it */
4038218c:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_save_extra_nw         /* destroys a0,2,3 */
4038218f:	fff885        	call0	40382118 <xthal_save_extra_nw>
     * may contain live windows belonging to previous frames in the call stack.
     * These frames will be spilled by SPILL_ALL_WINDOWS, and if the register was
     * used as a temporary by this code, the temporary value would get stored
     * onto the stack, instead of the real value.
     */
    rsr     a2, PS                     /* to be restored after SPILL_ALL_WINDOWS */
40382192:	03e620        	rsr.ps	a2
    movi    a0, PS_INTLEVEL_MASK
40382195:	f00c      	movi.n	a0, 15
    and     a3, a2, a0                 /* get the current INTLEVEL */
40382197:	103200        	and	a3, a2, a0
    bgeui   a3, XCHAL_EXCM_LEVEL, 1f   /* calculate max(INTLEVEL, XCHAL_EXCM_LEVEL) */
4038219a:	0233f6        	bgeui	a3, 3, 403821a0 <_xt_context_save+0x58>
    movi    a3, XCHAL_EXCM_LEVEL
4038219d:	03a032        	movi	a3, 3
1:
    movi    a0, PS_UM | PS_WOE         /* clear EXCM, enable window overflow, set new INTLEVEL */
403821a0:	cc0a01        	l32r	a0, 403751c8 <_iram_text_start+0xdc4> (40020 <UserFrameTotalSize+0x3ff20>)
    or      a3, a3, a0
403821a3:	203300        	or	a3, a3, a0
    wsr     a3, ps
403821a6:	13e630        	wsr.ps	a3
    rsr     a0, EPC1                   /* to be restored after SPILL_ALL_WINDOWS */
403821a9:	03b100        	rsr.epc1	a0

    addi    sp,  sp, XT_STK_FRMSZ      /* go back to spill register region */
403821ac:	01d112        	addmi	a1, a1, 0x100
403821af:	c0c112        	addi	a1, a1, -64
    SPILL_ALL_WINDOWS                  /* place the live register windows there */
403821b2:	10ccc0        	and	a12, a12, a12
403821b5:	408030        	rotw	3
403821b8:	10ccc0        	and	a12, a12, a12
403821bb:	408030        	rotw	3
403821be:	10ccc0        	and	a12, a12, a12
403821c1:	408030        	rotw	3
403821c4:	10ccc0        	and	a12, a12, a12
403821c7:	408030        	rotw	3
403821ca:	10ccc0        	and	a12, a12, a12
403821cd:	408040        	rotw	4
    addi    sp,  sp, -XT_STK_FRMSZ     /* return the current stack pointer and proceed with context save*/
403821d0:	ffd112        	addmi	a1, a1, 0xffffff00
403821d3:	40c112        	addi	a1, a1, 64

    wsr     a2, PS                     /* restore to the value at entry */
403821d6:	13e620        	wsr.ps	a2
    rsync
403821d9:	002010        	rsync
    wsr     a0, EPC1                   /* likewise */
403821dc:	13b100        	wsr.epc1	a0

    #endif /* __XTENSA_CALL0_ABI__ */

    l32i    a12, sp, XT_STK_TMP0       /* restore the temp saved registers */
403821df:	1921c2        	l32i	a12, a1, 100
    l32i    a13, sp, XT_STK_TMP1       /* our return address is there */
403821e2:	1a21d2        	l32i	a13, a1, 104
    l32i    a9,  sp, XT_STK_TMP2
403821e5:	1b2192        	l32i	a9, a1, 108

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a0, a9                      /* retrieve ret addr */
403821e8:	090d      	mov.n	a0, a9
    #endif

    ret
403821ea:	f00d      	ret.n

403821ec <_xt_context_restore>:
    affected, but it is generally unlikely. If that ever happens,
    more registers need to be saved/restored around this macro invocation.
    Here we only assume a13 is preserved.
    Future Xtensa tools releases might limit the regs that can be affected.
    */
    mov     a13, a0                     /* preserve ret addr */
403821ec:	00dd      	mov.n	a13, a0
    addi    a2,  sp, XT_STK_EXTRA       /* where to find it */
403821ee:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_restore_extra_nw      /* destroys a0,2,3,4,5 */
403821f1:	ffef45        	call0	403820e8 <xthal_restore_extra_nw>
    mov     a0,  a13                    /* retrieve ret addr */
403821f4:	0d0d      	mov.n	a0, a13
    #endif

    #if XCHAL_HAVE_LOOPS
    l32i    a2,  sp, XT_STK_LBEG
403821f6:	162122        	l32i	a2, a1, 88
    l32i    a3,  sp, XT_STK_LEND
403821f9:	172132        	l32i	a3, a1, 92
    wsr     a2,  LBEG
403821fc:	130020        	wsr.lbeg	a2
    l32i    a2,  sp, XT_STK_LCOUNT
403821ff:	182122        	l32i	a2, a1, 96
    wsr     a3,  LEND
40382202:	130130        	wsr.lend	a3
    wsr     a2,  LCOUNT
40382205:	130220        	wsr.lcount	a2
    and     a4,  a4, a5
    wsr     a4,  INTENABLE              /* update INTENABLE */
    s32i    a5,  a3, 4                  /* restore _xt_vpri_mask */
    #endif

    l32i    a3,  sp, XT_STK_SAR
40382208:	132132        	l32i	a3, a1, 76
    l32i    a2,  sp, XT_STK_A2
4038220b:	5128      	l32i.n	a2, a1, 20
    wsr     a3,  SAR
4038220d:	130330        	wsr.sar	a3
    l32i    a3,  sp, XT_STK_A3
40382210:	6138      	l32i.n	a3, a1, 24
    l32i    a4,  sp, XT_STK_A4
40382212:	7148      	l32i.n	a4, a1, 28
    l32i    a5,  sp, XT_STK_A5
40382214:	8158      	l32i.n	a5, a1, 32
    l32i    a6,  sp, XT_STK_A6
40382216:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40382218:	a178      	l32i.n	a7, a1, 40
    l32i    a8,  sp, XT_STK_A8
4038221a:	b188      	l32i.n	a8, a1, 44
    l32i    a9,  sp, XT_STK_A9
4038221c:	c198      	l32i.n	a9, a1, 48
    l32i    a10, sp, XT_STK_A10
4038221e:	d1a8      	l32i.n	a10, a1, 52
    l32i    a11, sp, XT_STK_A11
40382220:	e1b8      	l32i.n	a11, a1, 56
    /*
    Call0 ABI callee-saved regs a12-15 do not need to be restored here.
    However a12-13 were saved for scratch before XT_RTOS_INT_ENTER(),
    so need to be restored anyway, despite being callee-saved in Call0.
    */
    l32i    a12, sp, XT_STK_A12
40382222:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
40382224:	1021d2        	l32i	a13, a1, 64
    #ifndef __XTENSA_CALL0_ABI__
    l32i    a14, sp, XT_STK_A14
40382227:	1121e2        	l32i	a14, a1, 68
    l32i    a15, sp, XT_STK_A15
4038222a:	1221f2        	l32i	a15, a1, 72
    #endif

    ret
4038222d:	f00d      	ret.n
	...

40382230 <_xt_coproc_init>:
    .type   _xt_coproc_init,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_init:
    ENTRY0
40382230:	002136        	entry	a1, 16

    /* Initialize thread co-processor ownerships to 0 (unowned). */
    movi    a2, _xt_coproc_owner_sa         /* a2 = base of owner array */
40382233:	c94d21        	l32r	a2, 40374768 <_iram_text_start+0x364> (3fc929c0 <_xt_coproc_owner_sa>)
    addi    a3, a2, (XCHAL_CP_MAX*portNUM_PROCESSORS) << 2       /* a3 = top+1 of owner array */
40382236:	20c232        	addi	a3, a2, 32
    movi    a4, 0                           /* a4 = 0 (unowned) */
40382239:	00a042        	movi	a4, 0
1:  s32i    a4, a2, 0
4038223c:	0249      	s32i.n	a4, a2, 0
    addi    a2, a2, 4
4038223e:	224b      	addi.n	a2, a2, 4
    bltu    a2, a3, 1b
40382240:	f83237        	bltu	a2, a3, 4038223c <_xt_coproc_init+0xc>

    RET0
40382243:	f01d      	retw.n
40382245:	000000        	ill

40382248 <_xt_coproc_release>:
    .type   _xt_coproc_release,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_release:
    ENTRY0                                  /* a2 = base of save area */
40382248:	002136        	entry	a1, 16
                                            /* a3 = xTargetCoreID */

    movi    a4, XCHAL_CP_MAX << 2           /* a4 = size of an owner array */
4038224b:	041c      	movi.n	a4, 16
    mull    a4, a3, a4                      /* a4 = offset to the owner array of the target core */
4038224d:	824340        	mull	a4, a3, a4
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of all owner arrays */
40382250:	c94631        	l32r	a3, 40374768 <_iram_text_start+0x364> (3fc929c0 <_xt_coproc_owner_sa>)
    add     a3, a3, a4                      /* a3 = base of owner array of the target core */
40382253:	334a      	add.n	a3, a3, a4
    addi    a4, a3, XCHAL_CP_MAX << 2       /* a4 = top+1 of owner array of the target core */
40382255:	10c342        	addi	a4, a3, 16
    movi    a5, 0                           /* a5 = 0 (unowned) */
40382258:	050c      	movi.n	a5, 0

    rsil    a6, XCHAL_EXCM_LEVEL            /* lock interrupts */
4038225a:	006360        	rsil	a6, 3
#if portNUM_PROCESSORS > 1
    /* If multicore, we must also acquire the _xt_coproc_owner_sa_lock spinlock
     * to ensure thread safe access of _xt_coproc_owner_sa between cores. */
    spinlock_take a7 a8 _xt_coproc_owner_sa_lock
4038225d:	c94371        	l32r	a7, 4037476c <_iram_text_start+0x368> (3fc929e0 <_xt_coproc_owner_sa_lock>)
40382260:	080c      	movi.n	a8, 0
40382262:	130c80        	wsr.scompare1	a8
40382265:	002010        	rsync
40382268:	03eb80        	rsr.prid	a8
4038226b:	00e782        	s32c1i	a8, a7, 0
4038226e:	fee856        	bnez	a8, 40382260 <_xt_coproc_release+0x18>
#endif /* portNUM_PROCESSORS > 1 */

1:  l32i    a7, a3, 0                       /* a7 = owner at a3 */
40382271:	0378      	l32i.n	a7, a3, 0
    bne     a2, a7, 2f                      /* if (coproc_sa_base == owner) */
40382273:	019277        	bne	a2, a7, 40382278 <_xt_coproc_release+0x30>
    s32i    a5, a3, 0                       /*   owner = unowned */
40382276:	0359      	s32i.n	a5, a3, 0
2:  addi    a3, a3, 1<<2                    /* a3 = next entry in owner array */
40382278:	334b      	addi.n	a3, a3, 4
    bltu    a3, a4, 1b                      /* repeat until end of array */
4038227a:	f33347        	bltu	a3, a4, 40382271 <_xt_coproc_release+0x29>

#if portNUM_PROCESSORS > 1
    /* Release previously taken spinlock */
    spinlock_release a7 a8 _xt_coproc_owner_sa_lock
4038227d:	c93b71        	l32r	a7, 4037476c <_iram_text_start+0x368> (3fc929e0 <_xt_coproc_owner_sa_lock>)
40382280:	080c      	movi.n	a8, 0
40382282:	0789      	s32i.n	a8, a7, 0
#endif /* portNUM_PROCESSORS > 1 */
    wsr     a6, PS                          /* restore interrupts */
40382284:	13e660        	wsr.ps	a6

    RET0
40382287:	f01d      	retw.n
40382289:	000000        	ill

4038228c <_xt_coproc_savecs>:
    .align      4
_xt_coproc_savecs:

    /* At entry, CPENABLE should be showing which CPs are enabled. */

    rsr     a2, CPENABLE                /* a2 = which CPs are enabled      */
4038228c:	03e020        	rsr.cpenable	a2
    beqz    a2, .Ldone                  /* quick exit if none              */
4038228f:	d29c      	beqz.n	a2, 403822b0 <_xt_coproc_savecs+0x24>
    mov     a14, a0                     /* save return address             */
40382291:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
40382293:	f81745        	call0	4037a408 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
40382296:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone                 /* if none then nothing to do      */
40382298:	4f9c      	beqz.n	a15, 403822b0 <_xt_coproc_savecs+0x24>
    s16i    a2, a15, XT_CP_CS_ST        /* save mask of CPs being stored   */
4038229a:	025f22        	s16i	a2, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
4038229d:	c934d1        	l32r	a13, 40374770 <_iram_text_start+0x36c> (3c0276e0 <_xt_coproc_sa_offset>)
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
403822a0:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
403822a2:	036207        	bbci	a2, 0, 403822a9 <_xt_coproc_savecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
403822a5:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
403822a7:	3efa      	add.n	a3, a14, a15
    xchal_cp2_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
403822a9:	036237        	bbci	a2, 3, 403822b0 <_xt_coproc_savecs+0x24>
    l32i    a14, a13, 12
403822ac:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
403822ae:	3efa      	add.n	a3, a14, a15
    xchal_cp7_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone:
    ret
403822b0:	f00d      	ret.n
	...

403822b4 <_xt_coproc_restorecs>:
    .align  4
    .literal_position
    .align      4
_xt_coproc_restorecs:

    mov     a14, a0                     /* save return address             */
403822b4:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
403822b6:	f81505        	call0	4037a408 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
403822b9:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone2                /* if none then nothing to do      */
403822bb:	9f9c      	beqz.n	a15, 403822d8 <_xt_coproc_restorecs+0x24>
    l16ui   a3, a15, XT_CP_CS_ST        /* a3 = which CPs have been saved  */
403822bd:	021f32        	l16ui	a3, a15, 4
    xor     a3, a3, a2                  /* clear the ones being restored   */
403822c0:	303320        	xor	a3, a3, a2
    s32i    a3, a15, XT_CP_CS_ST        /* update saved CP mask            */
403822c3:	1f39      	s32i.n	a3, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
403822c5:	c92ad1        	l32r	a13, 40374770 <_iram_text_start+0x36c> (3c0276e0 <_xt_coproc_sa_offset>)
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
403822c8:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
403822ca:	036207        	bbci	a2, 0, 403822d1 <_xt_coproc_restorecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
403822cd:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
403822cf:	3efa      	add.n	a3, a14, a15
    xchal_cp2_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
403822d1:	036237        	bbci	a2, 3, 403822d8 <_xt_coproc_restorecs+0x24>
    l32i    a14, a13, 12
403822d4:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
403822d6:	3efa      	add.n	a3, a14, a15
    xchal_cp7_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone2:
    ret
403822d8:	f00d      	ret.n
	...

403822dc <xt_ints_on>:
    .global xt_ints_on
    .type   xt_ints_on,@function

xt_ints_on:

    ENTRY0
403822dc:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable |= mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts       */
    mov     a2, a3               /* Previous mask             */
#else
    movi    a3, 0
403822df:	030c      	movi.n	a3, 0
    xsr     a3, INTENABLE        /* Disables all interrupts   */
403822e1:	61e430        	xsr.intenable	a3
    rsync
403822e4:	002010        	rsync
    or      a2, a3, a2           /* set bits in mask */
403822e7:	202320        	or	a2, a3, a2
    wsr     a2, INTENABLE        /* Re-enable ints */
403822ea:	13e420        	wsr.intenable	a2
    rsync
403822ed:	002010        	rsync
    mov     a2, a3               /* return prev mask */
403822f0:	032d      	mov.n	a2, a3
#endif
#else
    movi    a2, 0                /* Return zero */
#endif
    RET0
403822f2:	f01d      	retw.n

403822f4 <xt_ints_off>:
    .global xt_ints_off
    .type   xt_ints_off,@function

xt_ints_off:

    ENTRY0
403822f4:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable &= ~mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts        */
    mov     a2, a3               /* Previous mask              */
#else
    movi    a4, 0
403822f7:	040c      	movi.n	a4, 0
    xsr     a4, INTENABLE        /* Disables all interrupts   */
403822f9:	61e440        	xsr.intenable	a4
    rsync
403822fc:	002010        	rsync
    or      a3, a4, a2           /* set bits in mask */
403822ff:	203420        	or	a3, a4, a2
    xor     a3, a3, a2           /* invert bits in mask set in mask, essentially clearing them */
40382302:	303320        	xor	a3, a3, a2
    wsr     a3, INTENABLE        /* Re-enable ints */
40382305:	13e430        	wsr.intenable	a3
    rsync
40382308:	002010        	rsync
    mov     a2, a4               /* return prev mask */
4038230b:	042d      	mov.n	a2, a4
#endif
#else
    movi    a2, 0                /* return zero */
#endif
    RET0
4038230d:	f01d      	retw.n

Disassembly of section .flash.text:

42000020 <_stext>:
42000020:	4cc8      	l32i.n	a12, a12, 16
42000022:	3fc9      	s32i.n	a12, a15, 12
42000024:	0200b0        	andb	b0, b0, b11
42000027:	f43c      	movi.n	a4, 63
42000029:	400011        	l32r	a1, 41fd002c <_iram_bss_end+0x1c4dc2c>
4200002c:	2438      	l32i.n	a3, a4, 8
4200002e:	3fc9      	s32i.n	a12, a15, 12
42000030:	020120        	andb	b0, b1, b2
42000033:	2c3c      	movi.n	a12, 50
42000035:	3c0201        	l32r	a0, 41fcf040 <_iram_bss_end+0x1c4cc40>
42000038:	020050        	andb	b0, b0, b5
4200003b:	543c      	movi.n	a4, 53
4200003d:	3c0201        	l32r	a0, 41fcf048 <_iram_bss_end+0x1c4cc48>
42000040:	020030        	andb	b0, b0, b3
42000043:	783c      	movi.n	a8, 55
42000045:	3c0201        	l32r	a0, 41fcf050 <_iram_bss_end+0x1c4cc50>
42000048:	020070        	andb	b0, b0, b7
4200004b:	803c      	movi.n	a0, 56
4200004d:	00          	.byte	00
4200004e:	02          	.byte	0x2
4200004f:	9c3c      	movi.n	a12, 57
42000051:	3c0201        	l32r	a0, 41fcf05c <_iram_bss_end+0x1c4cc5c>
42000054:	0201c4        	ee.st.accx.ip	a12, 8
42000057:	903c      	movi.n	a0, 57
42000059:	00          	.byte	00
4200005a:	02          	.byte	0x2
4200005b:	ec3c      	movi.n	a12, 62
4200005d:	3c0201        	l32r	a0, 41fcf068 <_iram_bss_end+0x1c4cc68>
42000060:	04          	.byte	0x4
42000061:	37fc      	bnez.n	a7, 42000098 <_stext+0x78>
42000063:	05d040        	extui	a13, a4, 16, 1
42000066:	104000        	and	a4, a0, a0
42000069:	3c0202        	l8ui	a0, a2, 60
4200006c:	020ee4        	ee.st.accx.ip	a14, 112
4200006f:	283c      	movi.n	a8, 50
42000071:	3c0202        	l8ui	a0, a2, 60
42000074:	020234        	ee.st.accx.ip	a3, 16
42000077:	5c3c      	movi.n	a12, 53
42000079:	3c0202        	l8ui	a0, a2, 60
4200007c:	51eb851f 	ee.vmulas.u16.qacc.ld.ip.qup	q3, a1, 80, q6, q1, q6, q3
42000080:	0288      	l32i.n	a8, a2, 0
42000082:	02          	.byte	0x2
42000083:	b03c      	movi.n	a0, 59
42000085:	5d          	.byte	0x5d
42000086:	984037        	ball	a0, a3, 42000022 <_stext+0x2>
42000089:	5d          	.byte	0x5d
4200008a:	b44037        	ball	a0, a3, 42000042 <_stext+0x22>
4200008d:	3c0263        	lsi	f6, a2, 240
42000090:	0202b0        	andb	b0, b2, b11
42000093:	283c      	movi.n	a8, 50
42000095:	37fb      	addi.n	a3, a7, 15
42000097:	40          	.byte	0x40
42000098:	4d08      	l32i.n	a0, a13, 16
4200009a:	3fc9      	s32i.n	a12, a15, 12
4200009c:	4cd8      	l32i.n	a13, a12, 16
4200009e:	3fc9      	s32i.n	a12, a15, 12
420000a0:	9628      	l32i.n	a2, a6, 36
420000a2:	e44201        	l32r	a0, 41ff91ac <_iram_bss_end+0x1c76dac>
420000a5:	3c0202        	l8ui	a0, a2, 60
420000a8:	0202f0        	andb	b0, b2, b15
420000ab:	303c      	movi.n	a0, 51
420000ad:	7e          	.byte	0x7e
420000ae:	e84037        	ball	a0, a3, 4200009a <_stext+0x7a>
420000b1:	403751        	l32r	a5, 41fd0190 <_iram_bss_end+0x1c4dd90>
420000b4:	4cec      	bnez.n	a12, 420000dc <_stext+0xbc>
420000b6:	3fc9      	s32i.n	a12, a15, 12
420000b8:	37b090        	ee.stf.64.xp	f11, f3, a9, a0
420000bb:	57b840        	ee.stf.64.xp	f11, f5, a4, a8
420000be:	f04037        	ball	a0, a3, 420000b2 <_stext+0x92>
420000c1:	3c0291        	l32r	a9, 41fcf0cc <_iram_bss_end+0x1c4cccc>
420000c4:	91ec      	bnez.n	a1, 420000f1 <_stext+0xd1>
420000c6:	02          	.byte	0x2
420000c7:	1c3c      	movi.n	a12, 49
420000c9:	3c0292        	l8ui	a9, a2, 60
420000cc:	032c      	movi.n	a3, 32
420000ce:	02          	.byte	0x2
420000cf:	383c      	movi.n	a8, 51
420000d1:	3c0203        	lsi	f0, a2, 240
420000d4:	a4          	.byte	0xa4
420000d5:	3c0292        	l8ui	a9, a2, 60
420000d8:	c94d04        	ee.vld.l.64.ip	q0, a0, 0xfffffe68
420000db:	37fc6c3f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x1c0, q5, q5, q7, q4
420000df:	060040        	ee.ldf.64.xp	f0, f0, a4, a0
420000e2:	004000        	break	0, 0
420000e5:	4d          	.byte	0x4d
420000e6:	3fc9      	s32i.n	a12, a15, 12
420000e8:	032c      	movi.n	a3, 32
420000ea:	02          	.byte	0x2
420000eb:	743c      	movi.n	a4, 55
420000ed:	3c0203        	lsi	f0, a2, 240
420000f0:	039c      	beqz.n	a3, 42000104 <_stext+0xe4>
420000f2:	02          	.byte	0x2
420000f3:	143c      	movi.n	a4, 49
420000f5:	403764        	ee.ld.qacc_l.l.128.ip	a6, 0xfffffb70
420000f8:	03bc      	beqz.n	a3, 4200012c <_stext+0x10c>
420000fa:	02          	.byte	0x2
420000fb:	e43c      	movi.n	a4, 62
420000fd:	3c0263        	lsi	f6, a2, 240
42000100:	03ec      	bnez.n	a3, 42000124 <_stext+0x104>
42000102:	02          	.byte	0x2
42000103:	b43c      	movi.n	a4, 59
42000105:	3779      	s32i.n	a7, a7, 12
42000107:	40          	.byte	0x40
42000108:	fd28      	l32i.n	a2, a13, 60
4200010a:	904037        	ball	a0, a3, 4200009e <_stext+0x7e>
4200010d:	02          	.byte	0x2
4200010e:	4038      	l32i.n	a3, a0, 16
42000110:	37fc60        	ee.stf.64.xp	f15, f3, a6, a12
42000113:	800040        	add	a0, a0, a4
42000116:	e06000        	subx4	a6, a0, a0
42000119:	000d      	mov.n	a0, a0
4200011b:	40          	.byte	0x40
4200011c:	000e04        	ee.ld.qacc_l.l.128.ip	a0, 224
4200011f:	40          	.byte	0x40
42000120:	0dec      	bnez.n	a13, 42000144 <_stext+0x124>
42000122:	544000        	extui	a4, a0, 0, 6
42000125:	001b      	addi.n	a0, a0, 1
42000127:	40          	.byte	0x40
42000128:	032c      	movi.n	a3, 32
4200012a:	02          	.byte	0x2
4200012b:	fc3c      	movi.n	a12, 63
4200012d:	3c0203        	lsi	f0, a2, 240
42000130:	020460        	andb	b0, b4, b6
42000133:	003c      	movi.n	a0, 48
42000135:	00          	.byte	00
42000136:	600c      	movi.n	a0, 6
42000138:	375230        	ee.stf.64.xp	f5, f3, a3, a2
4200013b:	40          	.byte	0x40
4200013c:	4d18      	l32i.n	a1, a13, 16
4200013e:	3fc9      	s32i.n	a12, a15, 12
42000140:	377db0        	ee.stf.64.xp	f7, f3, a11, a13
42000143:	072040        	ee.stf.64.xp	f2, f0, a4, a0
42000146:	104000        	and	a4, a0, a0
42000149:	4d          	.byte	0x4d
4200014a:	3fc9      	s32i.n	a12, a15, 12
4200014c:	020624        	ee.st.accx.ip	a2, 48
4200014f:	283c      	movi.n	a8, 50
42000151:	3c0206        	j	4200f15d <_vfprintf_r+0x1819>
42000154:	44          	.byte	0x44
42000155:	403785        	call0	420404d0 <_etext+0x26d9a>
42000158:	34          	.byte	0x34
42000159:	403786        	j	4201023b <_vfprintf_r+0x28f7>
4200015c:	84          	.byte	0x84
4200015d:	403791        	l32r	a9, 41fd023c <_iram_bss_end+0x1c4de3c>
42000160:	86d8      	l32i.n	a13, a6, 32
42000162:	944037        	ball	a0, a3, 420000fa <_stext+0xda>
42000165:	403787        	bltu	a7, a8, 420001a9 <_stext+0x189>
42000168:	8688      	l32i.n	a8, a6, 32
4200016a:	204037        	ball	a0, a3, 4200018e <_stext+0x16e>
4200016d:	1c40377e 	ee.vmulas.s16.qacc.ld.ip.qup	q0, a7, -144, q0, q6, q4, q0
42000171:	64          	.byte	0x64
42000172:	02          	.byte	0x2
42000173:	003c      	movi.n	a0, 48
42000175:	400000        	ssr	a0
42000178:	d4          	.byte	0xd4
42000179:	403756        	bnez	a7, 42000580 <_stext+0x560>
4200017c:	057c      	movi.n	a5, -16
4200017e:	00          	.byte	00
4200017f:	067840        	ee.ldf.64.xp	f7, f0, a4, a8
42000182:	02          	.byte	0x2
42000183:	203c      	movi.n	a0, 50
42000185:	64          	.byte	0x64
42000186:	02          	.byte	0x2
42000187:	d53c      	movi.n	a5, 61
42000189:	3c0206        	j	4200f195 <_vfprintf_r+0x1851>
4200018c:	2328      	l32i.n	a2, a3, 8
4200018e:	00          	.byte	00
4200018f:	06dc00        	ee.ldf.64.xp	f13, f0, a0, a12
42000192:	02          	.byte	0x2
42000193:	2c3c      	movi.n	a12, 50
42000195:	3789      	s32i.n	a8, a7, 12
42000197:	877840        	ee.stf.64.xp	f7, f8, a4, a8
4200019a:	e44037        	ball	a0, a3, 42000182 <_stext+0x162>
4200019d:	3788      	l32i.n	a8, a7, 12
4200019f:	40          	.byte	0x40
420001a0:	88bc      	beqz.n	a8, 420001dc <_stext+0x1bc>
420001a2:	444037        	ball	a0, a3, 420001ea <_stext+0x1ca>
420001a5:	400025        	call8	420401a8 <_etext+0x26a72>
420001a8:	0e1c      	movi.n	a14, 16
420001aa:	d44000        	extui	a4, a0, 0, 14
420001ad:	000d      	mov.n	a0, a0
420001af:	40          	.byte	0x40
420001b0:	d4          	.byte	0xd4
420001b1:	3789      	s32i.n	a8, a7, 12
420001b3:	40          	.byte	0x40
420001b4:	896c      	movi.n	a9, -24
420001b6:	9c4037        	ball	a0, a3, 42000156 <_stext+0x136>
420001b9:	400006        	j	420101bd <_vfprintf_r+0x2879>
420001bc:	378d30        	ee.stf.64.xp	f8, f3, a3, a13
420001bf:	302040        	xor	a2, a0, a4
420001c2:	00          	.byte	00
420001c3:	00          	.byte	00
420001c4:	8ff8      	l32i.n	a15, a15, 32
420001c6:	8efb      	addi.n	a8, a14, 15
420001c8:	0018      	l32i.n	a1, a0, 0
420001ca:	600c      	movi.n	a0, 6
420001cc:	001c      	movi.n	a0, 16
420001ce:	600c      	movi.n	a0, 6
420001d0:	026014        	ee.st.accx.ip	a1, 0x300
420001d3:	13f060        	wsr.ccompare0	a6
420001d6:	2088e5        	call8	42020a64 <_etext+0x732e>
420001d9:	00          	.byte	00
420001da:	600c      	movi.n	a0, 6
420001dc:	0c0024        	ee.st.qacc_l.l.128.ip	a2, 0
420001df:	60          	.byte	0x60
420001e0:	00fb9fcf 	ee.vmulas.s16.accx.ld.ip.qup	q1, a12, 240, q6, q3, q7, q3
420001e4:	0028      	l32i.n	a2, a0, 0
420001e6:	600c      	movi.n	a0, 6
420001e8:	002c      	movi.n	a0, 32
420001ea:	600c      	movi.n	a0, 6
420001ec:	ff          	.byte	0xff
420001ed:	00f0ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q7, q7, q0
420001f1:	010000        	slli	a0, a0, 32
420001f4:	0c40e4        	ee.st.qacc_l.l.128.ip	a14, 0x400
420001f7:	645060        	extui	a5, a6, 0, 7
420001fa:	02          	.byte	0x2
420001fb:	243c      	movi.n	a4, 50
420001fd:	4d          	.byte	0x4d
420001fe:	3fc9      	s32i.n	a12, a15, 12
42000200:	026440        	andb	b6, b4, b4
42000203:	f03c      	movi.n	a0, 63
42000205:	40          	.byte	0x40
42000206:	600c      	movi.n	a0, 6
42000208:	4d1c      	movi.n	a13, 20
4200020a:	3fc9      	s32i.n	a12, a15, 12
4200020c:	40fc      	bnez.n	a0, 42000244 <_stext+0x224>
4200020e:	600c      	movi.n	a0, 6
42000210:	0c4104        	ee.st.qacc_l.l.128.ip	a0, 0x410
42000213:	411460        	srli	a1, a6, 4
42000216:	600c      	movi.n	a0, 6
42000218:	20          	.byte	0x20
42000219:	4d          	.byte	0x4d
4200021a:	3fc9      	s32i.n	a12, a15, 12
4200021c:	40ec      	bnez.n	a0, 42000244 <_stext+0x224>
4200021e:	600c      	movi.n	a0, 6
42000220:	40f8      	l32i.n	a15, a0, 16
42000222:	600c      	movi.n	a0, 6
42000224:	e0          	.byte	0xe0
42000225:	40          	.byte	0x40
42000226:	600c      	movi.n	a0, 6
42000228:	40dc      	bnez.n	a0, 42000240 <_stext+0x220>
4200022a:	600c      	movi.n	a0, 6
4200022c:	40e8      	l32i.n	a14, a0, 16
4200022e:	600c      	movi.n	a0, 6
42000230:	0c40f4        	ee.st.qacc_l.l.128.ip	a15, 0x400
42000233:	600060        	neg	a0, a6
42000236:	006002        	s32i	a0, a0, 0
42000239:	00          	.byte	00
4200023a:	4000ffff 	ee.vmulas.u16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q0
4200023e:	440000        	extui	a0, a0, 0, 5
42000241:	403766        	bnei	a7, 3, 42000285 <_stext+0x265>
42000244:	6578      	l32i.n	a7, a5, 24
42000246:	004037        	ball	a0, a3, 4200024a <_stext+0x22a>
42000249:	3759      	s32i.n	a5, a7, 12
4200024b:	591c40        	s32nb	a4, a12, 4
4200024e:	304037        	ball	a0, a3, 42000282 <_stext+0x262>
42000251:	400006        	j	42010255 <_vfprintf_r+0x2911>
42000254:	00          	.byte	00
42000255:	00          	.byte	00
42000256:	600c      	movi.n	a0, 6
42000258:	008000        	any4	b0, b0:b1:b2:b3
4200025b:	00          	.byte	00
4200025c:	ff          	.byte	0xff
4200025d:	00ffff7f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a7, 240, q7, q7, q7, q7
42000261:	00          	.byte	00
42000262:	ff6002        	s32i	a0, a0, 0x3fc
42000265:	40ffffbf 	ee.vmulas.u16.accx.ld.ip.qup	q1, a11, 240, q7, q7, q7, q7
42000269:	009c      	beqz.n	a0, 4200027d <_stext+0x25d>
4200026b:	00          	.byte	00
4200026c:	4d2c      	movi.n	a13, 36
4200026e:	3fc9      	s32i.n	a12, a15, 12
42000270:	10          	.byte	0x10
42000271:	000027        	bnone	a0, a2, 42000275 <_stext+0x255>
42000274:	378200        	ee.stf.64.xp	f8, f3, a0, a2
42000277:	81f040        	src	a15, a0, a4
4200027a:	bc4037        	ball	a0, a3, 4200023a <_stext+0x21a>
4200027d:	000d      	mov.n	a0, a0
4200027f:	40          	.byte	0x40
42000280:	0df8      	l32i.n	a15, a13, 0
42000282:	00          	.byte	00
42000283:	593c40        	s32nb	a4, a12, 12
42000286:	084037        	ball	a0, a3, 42000292 <_stext+0x272>
42000289:	24          	.byte	0x24
4200028a:	3fc9      	s32i.n	a12, a15, 12
4200028c:	c94d34        	ee.vld.l.64.ip	q0, a3, 0xfffffe68
4200028f:	0380003f 	ee.vmulas.s16.accx.ld.ip.qup	q6, a3, 0, q4, q1, q0, q0
42000293:	60          	.byte	0x60
42000294:	4d38      	l32i.n	a3, a13, 16
42000296:	3fc9      	s32i.n	a12, a15, 12
42000298:	666667        	bbci	a6, 6, 42000302 <_stext+0x2e2>
4200029b:	64b066        	bnei	a0, 16, 42000303 <_stext+0x2e3>
4200029e:	02          	.byte	0x2
4200029f:	b83c      	movi.n	a8, 59
420002a1:	64          	.byte	0x64
420002a2:	02          	.byte	0x2
420002a3:	0c3c      	movi.n	a12, 48
420002a5:	24          	.byte	0x24
420002a6:	3fc9      	s32i.n	a12, a15, 12
420002a8:	624dd3        	ssi	f13, a13, 0x188
420002ab:	2ba810        	oeq.s	b10, f8, f1
420002ae:	3fc9      	s32i.n	a12, a15, 12
420002b0:	000e34        	ee.ld.qacc_l.l.128.ip	a3, 224
420002b3:	086840        	lsx	f6, a8, a4
420002b6:	02          	.byte	0x2
420002b7:	043c      	movi.n	a4, 48
420002b9:	420020        	xorb	b0, b0, b2
420002bc:	4d3c      	movi.n	a13, 52
420002be:	3fc9      	s32i.n	a12, a15, 12
420002c0:	0208b4        	ee.st.accx.ip	a11, 64
420002c3:	d43c      	movi.n	a4, 61
420002c5:	0208      	l32i.n	a0, a2, 0
420002c7:	e03c      	movi.n	a0, 62
420002c9:	0208      	l32i.n	a0, a2, 0
420002cb:	343c      	movi.n	a4, 51
420002cd:	0209      	s32i.n	a0, a2, 0
420002cf:	0c3c      	movi.n	a12, 48
420002d1:	001020        	movsp	a2, a0
420002d4:	0208e4        	ee.st.accx.ip	a14, 64
420002d7:	003c      	movi.n	a0, 48
420002d9:	0209      	s32i.n	a0, a2, 0
420002db:	143c      	movi.n	a4, 49
420002dd:	0209      	s32i.n	a0, a2, 0
420002df:	283c      	movi.n	a8, 50
420002e1:	0209      	s32i.n	a0, a2, 0
420002e3:	483c      	movi.n	a8, 52
420002e5:	400012        	l8ui	a1, a0, 64
420002e8:	7cf8      	l32i.n	a15, a12, 28
420002ea:	f04037        	ball	a0, a3, 420002de <_stext+0x2be>
420002ed:	377c      	movi.n	a7, -13
420002ef:	093840        	l32e	a4, a8, -52
420002f2:	02          	.byte	0x2
420002f3:	a03c      	movi.n	a0, 58
420002f5:	420024        	ee.st.accx.ip	a2, 0xfffffc00
420002f8:	40          	.byte	0x40
420002f9:	4d          	.byte	0x4d
420002fa:	3fc9      	s32i.n	a12, a15, 12
420002fc:	3fffffff 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q7, q7
42000300:	374400        	ee.stf.64.xp	f4, f3, a0, a4
42000303:	11e840        	slli	a14, a8, 12
42000306:	00          	.byte	00
42000307:	40          	.byte	0x40
42000308:	7d2c      	movi.n	a13, 39
4200030a:	104037        	ball	a0, a3, 4200031e <_stext+0x2fe>
4200030d:	375a      	add.n	a3, a7, a5
4200030f:	40          	.byte	0x40
42000310:	7ef8      	l32i.n	a15, a14, 28
42000312:	344037        	ball	a0, a3, 4200034a <_stext+0x32a>
42000315:	0209      	s32i.n	a0, a2, 0
42000317:	483c      	movi.n	a8, 52
42000319:	4d          	.byte	0x4d
4200031a:	3fc9      	s32i.n	a12, a15, 12
4200031c:	020940        	andb	b0, b9, b4
4200031f:	5c3c      	movi.n	a12, 53
42000321:	0209      	s32i.n	a0, a2, 0
42000323:	683c      	movi.n	a8, 54
42000325:	0209      	s32i.n	a0, a2, 0
42000327:	783c      	movi.n	a8, 55
42000329:	0209      	s32i.n	a0, a2, 0
4200032b:	903c      	movi.n	a0, 57
4200032d:	0209      	s32i.n	a0, a2, 0
4200032f:	a83c      	movi.n	a8, 58
42000331:	0209      	s32i.n	a0, a2, 0
42000333:	b83c      	movi.n	a8, 59
42000335:	0209      	s32i.n	a0, a2, 0
42000337:	c83c      	movi.n	a8, 60
42000339:	0209      	s32i.n	a0, a2, 0
4200033b:	fc3c      	movi.n	a12, 63
4200033d:	ff          	.byte	0xff
4200033e:	ff          	.byte	0xff
4200033f:	bf          	.byte	0xbf
42000340:	03ffffff 	ee.vmulas.s16.accx.ld.ip.qup	q7, a15, 240, q7, q7, q7, q7
42000344:	0209d4        	ee.st.accx.ip	a13, 72
42000347:	e83c      	movi.n	a8, 62
42000349:	0209      	s32i.n	a0, a2, 0
4200034b:	4c3c      	movi.n	a12, 52
4200034d:	020a      	add.n	a0, a2, a0
4200034f:	ec3c      	movi.n	a12, 62
42000351:	0209      	s32i.n	a0, a2, 0
42000353:	003c      	movi.n	a0, 48
42000355:	020a      	add.n	a0, a2, a0
42000357:	143c      	movi.n	a4, 49
42000359:	020a      	add.n	a0, a2, a0
4200035b:	343c      	movi.n	a4, 51
4200035d:	0209      	s32i.n	a0, a2, 0
4200035f:	c03c      	movi.n	a0, 60
42000361:	64          	.byte	0x64
42000362:	02          	.byte	0x2
42000363:	483c      	movi.n	a8, 52
42000365:	020a      	add.n	a0, a2, a0
42000367:	503c      	movi.n	a0, 53
42000369:	020a      	add.n	a0, a2, a0
4200036b:	8c3c      	movi.n	a12, 56
4200036d:	020a      	add.n	a0, a2, a0
4200036f:	603c      	movi.n	a0, 54
42000371:	020a      	add.n	a0, a2, a0
42000373:	643c      	movi.n	a4, 54
42000375:	020a      	add.n	a0, a2, a0
42000377:	843c      	movi.n	a4, 56
42000379:	020a      	add.n	a0, a2, a0
4200037b:	943c      	movi.n	a4, 57
4200037d:	020a      	add.n	a0, a2, a0
4200037f:	a43c      	movi.n	a4, 58
42000381:	020a      	add.n	a0, a2, a0
42000383:	b43c      	movi.n	a4, 59
42000385:	020a      	add.n	a0, a2, a0
42000387:	a83c      	movi.n	a8, 58
42000389:	3768      	l32i.n	a6, a7, 12
4200038b:	654040        	extui	a4, a4, 16, 7
4200038e:	02          	.byte	0x2
4200038f:	383c      	movi.n	a8, 51
42000391:	0209      	s32i.n	a0, a2, 0
42000393:	e43c      	movi.n	a4, 62
42000395:	020b      	addi.n	a0, a2, -1
42000397:	843c      	movi.n	a4, 56
42000399:	420025        	call8	4204239c <_etext+0x28c66>
4200039c:	020c00        	andb	b0, b12, b0
4200039f:	203c      	movi.n	a0, 50
420003a1:	3c0265        	call8	4203c3c8 <_etext+0x22c92>
420003a4:	002534        	ee.ld.qacc_l.l.128.ip	a3, 0x250
420003a7:	25d842        	addmi	a4, a8, 0x2500
420003aa:	344200        	extui	a4, a0, 2, 4
420003ad:	375b      	addi.n	a3, a7, 5
420003af:	40          	.byte	0x40
420003b0:	c94d94        	ee.vld.l.64.ip	q0, a9, 0xfffffe68
420003b3:	c94d8c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q6, q0, q4, q5
420003b7:	c94d743f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q5, q6, q4, q5
420003bb:	c94d6c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q5, q4, q4, q5
420003bf:	c94d7c3f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a12, q5, q6, q4, q5
420003c3:	c94d843f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q6, q0, q4, q5
420003c7:	37b9343f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x140, q4, q7, q3, q1
420003cb:	b77840        	ee.stf.64.xp	f7, f11, a4, a8
420003ce:	984037        	ball	a0, a3, 4200036a <_stext+0x34a>
420003d1:	4037b7        	bltu	a7, a11, 42000415 <_stext+0x3f5>
420003d4:	b7b8      	l32i.n	a11, a7, 44
420003d6:	9c4037        	ball	a0, a3, 42000376 <_stext+0x356>
420003d9:	379c      	beqz.n	a7, 420003f0 <_stext+0x3d0>
420003db:	c0b840        	sub	a11, a8, a4
420003de:	f44037        	ball	a0, a3, 420003d6 <_stext+0x3b6>
420003e1:	3799      	s32i.n	a9, a7, 12
420003e3:	40          	.byte	0x40
420003e4:	0fa8      	l32i.n	a10, a15, 0
420003e6:	02          	.byte	0x2
420003e7:	583c      	movi.n	a8, 53
420003e9:	c92c      	movi.n	a9, 44
420003eb:	c92bb03f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q6, q6, q2, q3
420003ef:	375c883f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x180, q6, q0, q5, q4
420003f3:	40          	.byte	0x40
420003f4:	0f98      	l32i.n	a9, a15, 0
420003f6:	02          	.byte	0x2
420003f7:	ec3c      	movi.n	a12, 62
420003f9:	3c0265        	call8	4203c420 <_etext+0x22cea>
420003fc:	0f8c      	beqz.n	a15, 42000400 <_stext+0x3e0>
420003fe:	02          	.byte	0x2
420003ff:	843c      	movi.n	a4, 56
42000401:	379b      	addi.n	a3, a7, 9
42000403:	40          	.byte	0x40
42000404:	98d8      	l32i.n	a13, a8, 36
42000406:	ac4037        	ball	a0, a3, 420003b6 <_stext+0x396>
42000409:	4037c4        	ee.ld.qacc_l.l.128.ip	a12, 0xfffffb70
4200040c:	c94d64        	ee.vld.l.64.ip	q0, a6, 0xfffffe68
4200040f:	c94d583f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q5, q2, q4, q5
42000413:	c94d603f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a0, q5, q4, q4, q5
42000417:	377d183f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x180, q4, q2, q7, q5
4200041b:	40          	.byte	0x40
4200041c:	379ff0        	ee.stf.64.xp	f9, f3, a15, a15
4200041f:	c28c40        	quou	a8, a12, a4
42000422:	dc4037        	ball	a0, a3, 42000402 <_stext+0x3e2>
42000425:	4d          	.byte	0x4d
42000426:	3fc9      	s32i.n	a12, a15, 12
42000428:	7e08      	l32i.n	a0, a14, 28
4200042a:	284037        	ball	a0, a3, 42000456 <_stext+0x436>
4200042d:	24          	.byte	0x24
4200042e:	3fc9      	s32i.n	a12, a15, 12
42000430:	14          	.byte	0x14
42000431:	a0          	.byte	0xa0
42000432:	644037        	ball	a0, a3, 4200049a <_stext+0x47a>
42000435:	4037a1        	l32r	a10, 41fd0514 <_iram_bss_end+0x1c4e114>
42000438:	4d9c      	beqz.n	a13, 42000450 <_stext+0x430>
4200043a:	3fc9      	s32i.n	a12, a15, 12
4200043c:	65fc      	bnez.n	a5, 42000476 <_stext+0x456>
4200043e:	02          	.byte	0x2
4200043f:	043c      	movi.n	a4, 48
42000441:	3c0266        	bnei	a2, -1, 42000481 <_stext+0x461>
42000444:	fc4c      	movi.n	a12, 79
42000446:	284037        	ball	a0, a3, 42000472 <_stext+0x452>
42000449:	303fc94e 	ee.vmulas.s8.qacc.ld.ip.qup	q1, a4, 144, q3, q0, q3, q7
4200044d:	400012        	l8ui	a1, a0, 64
42000450:	4e38      	l32i.n	a3, a14, 16
42000452:	3fc9      	s32i.n	a12, a15, 12
42000454:	30          	.byte	0x30
42000455:	343fc94e 	ee.vmulas.s8.qacc.ld.ip.qup	q1, a4, 0x190, q3, q0, q3, q7
42000459:	643fc94e 	ee.vmulas.u8.accx.ld.ip.qup	q1, a4, 0x190, q3, q0, q3, q7
4200045d:	3c0215        	call4	4203c480 <_etext+0x22d4a>
42000460:	67bc      	beqz.n	a7, 4200049a <_stext+0x47a>
42000462:	02          	.byte	0x2
42000463:	e73c      	movi.n	a7, 62
42000465:	3c0215        	call4	4203c488 <_etext+0x22d52>
42000468:	4e2c      	movi.n	a14, 36
4200046a:	3fc9      	s32i.n	a12, a15, 12
4200046c:	1fffffff 	ee.vmulas.s16.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q7, q7
42000470:	4f38      	l32i.n	a3, a15, 16
42000472:	3fc9      	s32i.n	a12, a15, 12
42000474:	000000        	ill
42000477:	15fc02        	s32ri	a0, a12, 84
4200047a:	02          	.byte	0x2
4200047b:	843c      	movi.n	a4, 56
4200047d:	0268      	l32i.n	a6, a2, 0
4200047f:	2e3c      	movi.n	a14, 50
42000481:	3c0216        	beqz	a2, 42000845 <_stext+0x825>
42000484:	a4          	.byte	0xa4
42000485:	4037e7        	bltu	a7, a14, 420004c9 <_stext+0x4a9>
42000488:	021640        	andb	b1, b6, b4
4200048b:	4c3c      	movi.n	a12, 52
4200048d:	3c0216        	beqz	a2, 42000851 <_stext+0x831>
42000490:	021690        	andb	b1, b6, b9
42000493:	743c      	movi.n	a4, 55
42000495:	0268      	l32i.n	a6, a2, 0
42000497:	e43c      	movi.n	a4, 62
42000499:	026a      	add.n	a0, a2, a6
4200049b:	a83c      	movi.n	a8, 58
4200049d:	3c0216        	beqz	a2, 42000861 <_stext+0x841>
420004a0:	026860        	andb	b6, b8, b6
420004a3:	d83c      	movi.n	a8, 61
420004a5:	3c0216        	beqz	a2, 42000869 <_stext+0x849>
420004a8:	b33fffff 	ee.vmulas.s16.accx.ld.xp.qup	q7, a15, a15, q7, q6, q3, q7
420004ac:	0216e4        	ee.st.accx.ip	a14, 176
420004af:	103c      	movi.n	a0, 49
420004b1:	3c0217        	bnone	a2, a1, 420004f1 <_stext+0x4d1>
420004b4:	1728      	l32i.n	a2, a7, 4
420004b6:	02          	.byte	0x2
420004b7:	043c      	movi.n	a4, 48
420004b9:	0008      	l32i.n	a0, a0, 0
420004bb:	174800        	ee.stf.64.xp	f4, f1, a0, a8
420004be:	02          	.byte	0x2
420004bf:	e43c      	movi.n	a4, 62
420004c1:	4037e6        	bgei	a7, 3, 42000505 <_stext+0x4e5>
420004c4:	921c      	movi.n	a2, 25
420004c6:	02          	.byte	0x2
420004c7:	f43c      	movi.n	a4, 63
420004c9:	3c0291        	l32r	a9, 41fcf4d4 <_iram_bss_end+0x1c4d0d4>
420004cc:	fffc      	bnez.n	a15, 4200050f <_stext+0x4ef>
420004ce:	003ff1        	l32r	a15, 41fc05cc <_iram_bss_end+0x1c3e1cc>
420004d1:	00          	.byte	00
420004d2:	65bc3fcf 	ee.vmulas.u8.accx.ld.ip.qup	q3, a12, 0x1f0, q4, q7, q3, q4
420004d6:	284201        	l32r	a0, 41fca5e0 <_iram_bss_end+0x1c481e0>
420004d9:	1f          	.byte	0x1f
420004da:	02          	.byte	0x2
420004db:	fc3c      	movi.n	a12, 63
420004dd:	0269      	s32i.n	a6, a2, 0
420004df:	6b3c      	movi.n	a11, 54
420004e1:	843c021f 	ee.ldf.128.ip	f9, f9, f0, f3, a1, 32
420004e5:	b03c021f 	ee.vmulas.s16.accx.ld.xp.qup	q1, a1, a2, q4, q0, q3, q4
420004e9:	c03c021f 	ee.vmulas.u16.accx.ld.xp.qup	q1, a1, a2, q4, q0, q3, q4
420004ed:	883c021f 	ee.ldf.128.xp	f1, f9, f0, f3, a1, a2
420004f1:	400014        	ee.ld.qacc_l.l.128.ip	a1, 0xfffff800
420004f4:	6a18      	l32i.n	a1, a10, 24
420004f6:	02          	.byte	0x2
420004f7:	1c3c      	movi.n	a12, 49
420004f9:	026a      	add.n	a0, a2, a6
420004fb:	cd3c      	movi.n	a13, 60
420004fd:	cccc      	bnez.n	a12, 4200050d <_stext+0x4ed>
420004ff:	50cc      	bnez.n	a0, 42000508 <_stext+0x4e8>
42000501:	4f          	.byte	0x4f
42000502:	3fc9      	s32i.n	a12, a15, 12
42000504:	ff          	.byte	0xff
42000505:	ff          	.byte	0xff
42000506:	ffffc1        	l32r	a12, 42000504 <_stext+0x4e4> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
42000509:	c4fffeff 	ee.vmulas.u16.qacc.ld.xp.qup	q1, a15, a14, q7, q7, q7, q7
4200050d:	1840375e 	ee.vmulas.s16.qacc.ld.ip.qup	q0, a5, 0xfffffe70, q0, q6, q4, q0
42000511:	3c0222        	l8ui	a2, a2, 60
42000514:	6c0c      	movi.n	a12, 6
42000516:	02          	.byte	0x2
42000517:	443c      	movi.n	a4, 52
42000519:	3c0222        	l8ui	a2, a2, 60
4200051c:	022254        	ee.st.accx.ip	a5, 0x110
4200051f:	f83c      	movi.n	a8, 63
42000521:	026b      	addi.n	a0, a2, 6
42000523:	ff3c      	movi.n	a15, 63
42000525:	007fffff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 240, q7, q6, q7, q7
42000529:	00          	.byte	00
4200052a:	bfc9      	s32i.n	a12, a15, 44
4200052c:	0006ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q6
42000530:	f02000        	subx8	a2, a0, a0
42000533:	001fff9f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a9, 240, q7, q6, q1, q7
42000537:	000000        	ill
4200053a:	00          	.byte	00
4200053b:	c0          	.byte	0xc0
4200053c:	0005ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q5
42000540:	244c      	movi.n	a4, 66
42000542:	3fc9      	s32i.n	a12, a15, 12
42000544:	7c0c      	movi.n	a12, 7
42000546:	02          	.byte	0x2
42000547:	a03c      	movi.n	a0, 58
42000549:	3c0222        	l8ui	a2, a2, 60
4200054c:	22ac      	beqz.n	a2, 42000572 <_stext+0x552>
4200054e:	02          	.byte	0x2
4200054f:	f03c      	movi.n	a0, 63
42000551:	3c0222        	l8ui	a2, a2, 60
42000554:	6bdc      	bnez.n	a11, 4200056e <_stext+0x54e>
42000556:	02          	.byte	0x2
42000557:	483c      	movi.n	a8, 52
42000559:	3c0223        	lsi	f2, a2, 240
4200055c:	64          	.byte	0x64
4200055d:	403764        	ee.ld.qacc_l.l.128.ip	a6, 0xfffffb70
42000560:	026bc4        	ee.st.accx.ip	a12, 0x358
42000563:	ff3c      	movi.n	a15, 63
42000565:	48c03fff 	ee.vmulas.u16.accx.ld.ip.qup	q0, a15, 0xfffffef0, q4, q7, q4, q0
42000569:	903fc94f 	ee.stf.128.ip	f1, f15, f12, f3, a4, -112
4200056d:	fe          	.byte	0xfe
4200056e:	e44037        	ball	a0, a3, 42000556 <_stext+0x536>
42000571:	001b      	addi.n	a0, a0, 1
42000573:	665440        	ee.ldf.64.xp	f5, f6, a4, a4
42000576:	544037        	ball	a0, a3, 420005ce <_stext+0x5ae>
42000579:	3c0223        	lsi	f2, a2, 240
4200057c:	6ba8      	l32i.n	a10, a11, 24
4200057e:	02          	.byte	0x2
4200057f:	003c      	movi.n	a0, 48
42000581:	274000        	ee.stf.64.xp	f4, f2, a0, a0
42000584:	003b74        	ee.ld.qacc_l.l.128.ip	a7, 0x3b0
42000587:	c71442        	l16ui	a4, a4, 0x18e
4200058a:	144037        	ball	a0, a3, 420005a2 <_stext+0x582>
4200058d:	2d          	.byte	0x2d
4200058e:	3fc9      	s32i.n	a12, a15, 12
42000590:	00          	.byte	00
42000591:	2d          	.byte	0x2d
42000592:	3fc9      	s32i.n	a12, a15, 12
42000594:	80          	.byte	0x80
42000595:	403fc94f 	ee.vmulas.u16.accx.ld.ip.qup	q1, a4, 144, q7, q0, q3, q7
42000599:	600080        	neg	a0, a8
4200059c:	804c      	movi.n	a0, 72
4200059e:	00          	.byte	00
4200059f:	674c60        	ee.stf.64.xp	f4, f6, a6, a12
420005a2:	0c4037        	ball	a0, a3, 420005b2 <_stext+0x592>
420005a5:	2d          	.byte	0x2d
420005a6:	3fc9      	s32i.n	a12, a15, 12
420005a8:	00          	.byte	00
420005a9:	0008      	l32i.n	a0, a0, 0
420005ab:	00          	.byte	00
420005ac:	2d08      	l32i.n	a0, a13, 8
420005ae:	3fc9      	s32i.n	a12, a15, 12
420005b0:	0223a4        	ee.st.accx.ip	a10, 0x118
420005b3:	b03c      	movi.n	a0, 59
420005b5:	3c0223        	lsi	f2, a2, 240
420005b8:	0003fffe 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q3, q6, q0, q3
420005bc:	ff          	.byte	0xff
420005bd:	ff          	.byte	0xff
420005be:	3f          	.byte	0x3f
420005bf:	fffc      	bnez.n	a15, 42000602 <_stext+0x5e2>
420005c1:	bc0001ff 	ee.vmulas.s8.qacc.ld.xp.qup	q0, a15, a1, q4, q0, q0, q0
420005c5:	403775        	call12	4204093c <_etext+0x27206>
420005c8:	0223f0        	andb	b2, b3, b15
420005cb:	f83c      	movi.n	a8, 63
420005cd:	3c0223        	lsi	f2, a2, 240
420005d0:	022400        	andb	b2, b4, b0
420005d3:	e03c      	movi.n	a0, 62
420005d5:	600080        	neg	a0, a8
420005d8:	44          	.byte	0x44
420005d9:	3c0283        	lsi	f8, a2, 240
420005dc:	80d8      	l32i.n	a13, a0, 32
420005de:	746000        	extui	a6, a0, 0, 8
420005e1:	3c3c027e 	ee.vmulas.s8.qacc.ld.ip.qup	q1, a7, -224, q0, q0, q3, q4
420005e5:	026c      	movi.n	a2, -32
420005e7:	ec3c      	movi.n	a12, 62
420005e9:	403767        	bltu	a7, a6, 4200062d <_stext+0x60d>
420005ec:	e0          	.byte	0xe0
420005ed:	10          	.byte	0x10
420005ee:	600c      	movi.n	a0, 6
420005f0:	ff          	.byte	0xff
420005f1:	8f          	.byte	0x8f
420005f2:	7fffffff 	ee.vmulas.u8.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q7, q7
420005f6:	fffc      	bnez.n	a15, 42000639 <_stext+0x619>
420005f8:	6cd8      	l32i.n	a13, a12, 24
420005fa:	02          	.byte	0x2
420005fb:	f43c      	movi.n	a4, 63
420005fd:	026c      	movi.n	a2, -32
420005ff:	003c      	movi.n	a0, 48
42000601:	80          	.byte	0x80
42000602:	bfc8      	l32i.n	a12, a15, 44
42000604:	00067fff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q5, q6, q0, q6
42000608:	ff          	.byte	0xff
42000609:	fffff1        	l32r	a15, 42000608 <_stext+0x5e8> (fffff1ff <_rtc_reserved_end+0x9feff1ff>)
4200060c:	0c10e4        	ee.st.qacc_l.l.128.ip	a14, 0x100
4200060f:	10f060        	and	a15, a0, a6
42000612:	600c      	movi.n	a0, 6
42000614:	10e8      	l32i.n	a14, a0, 4
42000616:	600c      	movi.n	a0, 6
42000618:	0c10f4        	ee.st.qacc_l.l.128.ip	a15, 0x100
4200061b:	112460        	slli	a2, a4, 10
4200061e:	600c      	movi.n	a0, 6
42000620:	d0          	.byte	0xd0
42000621:	600c11        	l32r	a1, 41fd8654 <_iram_bss_end+0x1c56254>
42000624:	00          	.byte	00
42000625:	3ff8      	l32i.n	a15, a15, 12
42000627:	114800        	slli	a4, a8, 16
4200062a:	600c      	movi.n	a0, 6
4200062c:	0c11f4        	ee.st.qacc_l.l.128.ip	a15, 0x110
4200062f:	60          	.byte	0x60
42000630:	00          	.byte	00
42000631:	4c00000e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a0, 0xffffff00, q0, q0, q0, q0
42000635:	600c11        	l32r	a1, 41fd8668 <_iram_bss_end+0x1c56268>
42000638:	11f8      	l32i.n	a15, a1, 4
4200063a:	600c      	movi.n	a0, 6
4200063c:	119c      	beqz.n	a1, 42000651 <_stext+0x631>
4200063e:	600c      	movi.n	a0, 6
42000640:	1248      	l32i.n	a4, a2, 4
42000642:	600c      	movi.n	a0, 6
42000644:	a0          	.byte	0xa0
42000645:	600c11        	l32r	a1, 41fd8678 <_iram_bss_end+0x1c56278>
42000648:	124c      	movi.n	a2, 65
4200064a:	600c      	movi.n	a0, 6
4200064c:	910000        	srl	a0, a0
4200064f:	378000ff 	ee.vmulas.s8.qacc.ld.ip.qup	q6, a15, 0x100, q4, q1, q0, q0
42000653:	1100c0        	slli	a0, a0, 4
42000656:	600c      	movi.n	a0, 6
42000658:	0c1104        	ee.st.qacc_l.l.128.ip	a0, 0x110
4200065b:	111460        	slli	a1, a4, 10
4200065e:	600c      	movi.n	a0, 6
42000660:	1108      	l32i.n	a0, a1, 4
42000662:	600c      	movi.n	a0, 6
42000664:	1118      	l32i.n	a1, a1, 4
42000666:	600c      	movi.n	a0, 6
42000668:	d008      	l32i.n	a0, a0, 52
4200066a:	00          	.byte	00
4200066b:	246c00        	extui	a6, a0, 12, 3
4200066e:	3fc9      	s32i.n	a12, a15, 12
42000670:	00          	.byte	00
42000671:	403824        	ee.ld.qacc_l.l.128.ip	a2, 0xfffffb80
42000674:	00          	.byte	00
42000675:	e0          	.byte	0xe0
42000676:	d001600f 	ee.fft.ams.s16.ld.incp	q0, a0, q4, q0, q5, q0, q1, 0
4200067a:	020000        	andb	b0, b0, b0
4200067d:	0000d0        	callx4	a0
42000680:	0c10c4        	ee.st.qacc_l.l.128.ip	a12, 0x100
42000683:	10c860        	and	a12, a8, a6
42000686:	600c      	movi.n	a0, 6
42000688:	10cc      	bnez.n	a0, 4200068d <_stext+0x66d>
4200068a:	600c      	movi.n	a0, 6
4200068c:	d0          	.byte	0xd0
4200068d:	10          	.byte	0x10
4200068e:	600c      	movi.n	a0, 6
42000690:	0c10d4        	ee.st.qacc_l.l.128.ip	a13, 0x100
42000693:	10c060        	and	a12, a0, a6
42000696:	600c      	movi.n	a0, 6
42000698:	10d8      	l32i.n	a13, a0, 4
4200069a:	600c      	movi.n	a0, 6
4200069c:	10fc      	bnez.n	a0, 420006d1 <_stext+0x6b1>
4200069e:	600c      	movi.n	a0, 6
420006a0:	022520        	andb	b2, b5, b2
420006a3:	803c      	movi.n	a0, 56
420006a5:	3c0225        	call8	4203c6c8 <_etext+0x22f92>
420006a8:	0225e0        	andb	b2, b5, b14
420006ab:	403c      	movi.n	a0, 52
420006ad:	3c0226        	beqi	a2, -1, 420006ed <_stext+0x6cd>
420006b0:	0226a0        	andb	b2, b6, b10
420006b3:	003c      	movi.n	a0, 48
420006b5:	3c0227        	bnone	a2, a2, 420006f5 <_stext+0x6d5>
420006b8:	275c      	movi.n	a7, 82
420006ba:	02          	.byte	0x2
420006bb:	b83c      	movi.n	a8, 59
420006bd:	3c0227        	bnone	a2, a2, 420006fd <_stext+0x6dd>
420006c0:	022814        	ee.st.accx.ip	a1, 0x140
420006c3:	703c      	movi.n	a0, 55
420006c5:	0228      	l32i.n	a2, a2, 0
420006c7:	cc3c      	movi.n	a12, 60
420006c9:	0228      	l32i.n	a2, a2, 0
420006cb:	283c      	movi.n	a8, 50
420006cd:	0229      	s32i.n	a2, a2, 0
420006cf:	843c      	movi.n	a4, 56
420006d1:	0229      	s32i.n	a2, a2, 0
420006d3:	e03c      	movi.n	a0, 62
420006d5:	0229      	s32i.n	a2, a2, 0
420006d7:	3c3c      	movi.n	a12, 51
420006d9:	022a      	add.n	a0, a2, a2
420006db:	983c      	movi.n	a8, 57
420006dd:	022a      	add.n	a0, a2, a2
420006df:	fc3c      	movi.n	a12, 63
420006e1:	022a      	add.n	a0, a2, a2
420006e3:	603c      	movi.n	a0, 54
420006e5:	022b      	addi.n	a0, a2, 2
420006e7:	cc3c      	movi.n	a12, 60
420006e9:	022b      	addi.n	a0, a2, 2
420006eb:	303c      	movi.n	a0, 51
420006ed:	022c      	movi.n	a2, 32
420006ef:	943c      	movi.n	a4, 57
420006f1:	022c      	movi.n	a2, 32
420006f3:	d83c      	movi.n	a8, 61
420006f5:	400006        	j	420106f9 <get_arg$isra$0+0xcd>
420006f8:	03          	.byte	0x3
420006f9:	0000d0        	callx4	a0
420006fc:	04          	.byte	0x4
420006fd:	0000d0        	callx4	a0
42000700:	00d005        	call0	42001404 <__esp_system_init_fn_init_show_app_info+0xa8>
42000703:	d00600        	subx2	a0, a6, a0
42000706:	070000        	ee.stf.64.xp	f0, f0, a0, a0
42000709:	0000d0        	callx4	a0
4200070c:	022d00        	andb	b2, b13, b0
4200070f:	103c      	movi.n	a0, 49
42000711:	026d      	mov.n	a6, a2
42000713:	753c      	movi.n	a5, 55
42000715:	022d      	mov.n	a2, a2
42000717:	283c      	movi.n	a8, 50
42000719:	026d      	mov.n	a6, a2
4200071b:	543c      	movi.n	a4, 53
4200071d:	683c022e 	ee.vmulas.u8.accx.ld.ip.qup	q1, a2, 0xfffffe20, q0, q0, q3, q4
42000721:	8d3c026f 	ee.ldf.128.xp	f11, f9, f0, f3, a6, a2
42000725:	003c022e 	ee.vmulas.s16.accx.ld.ip.qup	q1, a2, 32, q0, q0, q3, q4
42000729:	120000        	andbc	b0, b0, b0
4200072c:	010b07        	bnone	a11, a0, 42000731 <_stext+0x711>
4200072f:	00          	.byte	00
42000730:	c94f94        	ee.vld.l.64.ip	q0, a9, 0xfffffe78
42000733:	3792fc3f 	ee.vmulas.s8.qacc.ld.ip.qup	q6, a3, 0x1c0, q7, q7, q1, q2
42000737:	805440        	add	a5, a4, a4
4200073a:	606000        	neg	a6, a0
4200073d:	010b07        	bnone	a11, a0, 42000742 <_stext+0x722>
42000740:	74          	.byte	0x74
42000741:	600080        	neg	a0, a8
42000744:	40          	.byte	0x40
42000745:	000f42        	l8ui	a4, a15, 0
42000748:	022ea4        	ee.st.accx.ip	a10, 0x170
4200074b:	443c      	movi.n	a4, 52
4200074d:	333c026f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a6, 32, q4, q0, q3, q4
42000751:	bb10c4        	ee.vst.h.64.ip	q6, a12, 128
42000754:	11dc      	bnez.n	a1, 42000769 <_stext+0x749>
42000756:	00          	.byte	00
42000757:	40          	.byte	0x40
42000758:	52e8      	l32i.n	a14, a2, 20
4200075a:	3fc9      	s32i.n	a12, a15, 12
4200075c:	023d00        	andb	b3, b13, b0
4200075f:	a83c      	movi.n	a8, 58
42000761:	3c0273        	lsi	f7, a2, 240
42000764:	023cb4        	ee.st.accx.ip	a11, 0x1e0
42000767:	943c      	movi.n	a4, 57
42000769:	3fc952        	addi	a5, a9, 63
4200076c:	023d30        	andb	b3, b13, b3
4200076f:	483c      	movi.n	a8, 52
42000771:	3fc953        	ssip	f5, a9, 252
42000774:	40          	.byte	0x40
42000775:	3fc953        	ssip	f5, a9, 252
42000778:	fe3c      	movi.n	a14, 63
4200077a:	604037        	ball	a0, a3, 420007de <_stext+0x7be>
4200077d:	3c4037fe 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a15, -144, q0, q6, q4, q0
42000781:	3fc953        	ssip	f5, a9, 252
42000784:	6a3c      	movi.n	a10, 54
42000786:	7c4037        	ball	a0, a3, 42000806 <_stext+0x7e6>
42000789:	376a      	add.n	a3, a7, a6
4200078b:	257440        	extui	a7, a4, 20, 3
4200078e:	c04000        	sub	a4, a0, a0
42000791:	b0          	.byte	0xb0
42000792:	184037        	ball	a0, a3, 420007ae <_stext+0x78e>
42000795:	604037fe 	ee.vmulas.u8.accx.ld.ip.qup	q0, a15, 112, q0, q6, q4, q0
42000799:	400006        	j	4201079d <get_arg$isra$0+0x171>
4200079c:	002000        	isync
4200079f:	2ab400        	mul.s	f11, f4, f0
420007a2:	3fc9      	s32i.n	a12, a15, 12
420007a4:	d4          	.byte	0xd4
420007a5:	103fceff 	ee.vmulas.s16.qacc.ld.ip.qup	q1, a15, 224, q7, q0, q3, q7
420007a9:	3fc925        	call8	4204043c <_etext+0x26d06>
420007ac:	c92aa4        	ee.vld.l.64.ip	q0, a10, 0xfffffd50
420007af:	ceffd03f 	ee.vmulas.u8.qacc.ld.xp.qup	q5, a3, a0, q7, q3, q7, q7
420007b3:	0062143f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 64, q4, q2, q6, q2
420007b7:	2aa042        	movi	a4, 42
420007ba:	3fc9      	s32i.n	a12, a15, 12
420007bc:	84          	.byte	0x84
420007bd:	644037fe 	ee.vmulas.u8.accx.ld.ip.qup	q0, a15, 0x170, q0, q6, q4, q0
420007c1:	3fc953        	ssip	f5, a9, 252
420007c4:	60          	.byte	0x60
420007c5:	3fc953        	ssip	f5, a9, 252
420007c8:	6b9c      	beqz.n	a11, 420007e2 <_stext+0x7c2>
420007ca:	244037        	ball	a0, a3, 420007f2 <_stext+0x7d2>
420007cd:	403785        	call0	42040b48 <_etext+0x27412>
420007d0:	3d68      	l32i.n	a6, a13, 12
420007d2:	02          	.byte	0x2
420007d3:	7c3c      	movi.n	a12, 55
420007d5:	023d      	mov.n	a3, a2
420007d7:	943c      	movi.n	a4, 57
420007d9:	023d      	mov.n	a3, a2
420007db:	b03c      	movi.n	a0, 59
420007dd:	023d      	mov.n	a3, a2
420007df:	cc3c      	movi.n	a12, 60
420007e1:	023d      	mov.n	a3, a2
420007e3:	e43c      	movi.n	a4, 62
420007e5:	023d      	mov.n	a3, a2
420007e7:	003c      	movi.n	a0, 48
420007e9:	143c023e 	ee.vmulas.s16.qacc.ld.ip.qup	q1, a3, 0x120, q0, q0, q3, q4
420007ed:	2c3c023e 	ee.vmulas.s8.accx.ld.ip.qup	q1, a3, -224, q0, q0, q3, q4
420007f1:	3c3c023e 	ee.vmulas.s8.qacc.ld.ip.qup	q1, a3, -224, q0, q0, q3, q4
420007f5:	543c023e 	ee.vmulas.u16.qacc.ld.ip.qup	q1, a3, 0x120, q0, q0, q3, q4
420007f9:	643c023e 	ee.vmulas.u8.accx.ld.ip.qup	q1, a3, 0x120, q0, q0, q3, q4
420007fd:	7c3c023e 	ee.vmulas.u8.qacc.ld.ip.qup	q1, a3, -224, q0, q0, q3, q4
42000801:	883c023e 	ee.ldf.128.xp	f1, f8, f0, f3, a3, a2
42000805:	a03c023e 	ee.fft.ams.s16.st.incp	q3, q1, a3, a2, q4, q0, q0, 0
42000809:	bc3c023e 	ee.vmulas.s8.qacc.ld.xp.qup	q1, a3, a2, q0, q0, q3, q4
4200080d:	c83c023e 	ee.vmulas.u8.accx.ld.xp.qup	q1, a3, a2, q0, q0, q3, q4
42000811:	d83c023e 	ee.fft.ams.s16.ld.r32.decp	q2, a3, q0, q2, q0, q3, q4, 0
42000815:	e43c023e 	ee.vadds.s8.st.incp	q3, a3, q4, q0, q0
42000819:	683c023e 	ee.vmulas.u8.accx.ld.ip.qup	q1, a3, 0xfffffe20, q0, q0, q3, q4
4200081d:	3fc953        	ssip	f5, a9, 252
42000820:	25ac      	beqz.n	a5, 42000846 <_stext+0x826>
42000822:	3fc9      	s32i.n	a12, a15, 12
42000824:	023ef0        	andb	b3, b14, b15
42000827:	cc3c      	movi.n	a12, 60
42000829:	3c0275        	call12	4203c850 <_etext+0x2311a>
4200082c:	3f1c      	movi.n	a15, 19
4200082e:	02          	.byte	0x2
4200082f:	4c3c      	movi.n	a12, 52
42000831:	7c3c023f 	ee.vmulas.u8.qacc.ld.ip.qup	q1, a3, -224, q4, q0, q3, q4
42000835:	403796        	bltz	a7, 42000c3c <_stext+0xc1c>
42000838:	023f64        	ee.st.accx.ip	a6, 0x1f8
4200083b:	c03c      	movi.n	a0, 60
4200083d:	3c0275        	call12	4203c864 <_etext+0x2312e>
42000840:	3f7c      	movi.n	a15, -13
42000842:	02          	.byte	0x2
42000843:	b43c      	movi.n	a4, 59
42000845:	3c0275        	call12	4203c86c <_etext+0x23136>
42000848:	023f94        	ee.st.accx.ip	a9, 0x1f8
4200084b:	bc3c      	movi.n	a12, 59
4200084d:	e03c023f 	ee.src.q.ld.ip	q4, a3, 0x220, q4, q3
42000851:	a43c023f 	ee.fft.ams.s16.st.incp	q3, q1, a3, a2, q4, q4, q0, 1
42000855:	3c0275        	call12	4203c87c <_etext+0x23146>
42000858:	3ffc      	bnez.n	a15, 4200088f <_stext+0x86f>
4200085a:	02          	.byte	0x2
4200085b:	ff3c      	movi.n	a15, 63
4200085d:	0000007f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a7, 0, q4, q0, q0, q0
42000861:	80          	.byte	0x80
42000862:	0000ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q0
42000866:	008000        	any4	b0, b0:b1:b2:b3
42000869:	000000        	ill
4200086c:	0000ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q0
42000870:	4018      	l32i.n	a1, a0, 16
42000872:	02          	.byte	0x2
42000873:	d83c      	movi.n	a8, 61
42000875:	3c0275        	call12	4203c89c <_etext+0x23166>
42000878:	403c      	movi.n	a0, 52
4200087a:	02          	.byte	0x2
4200087b:	503c      	movi.n	a0, 53
4200087d:	40          	.byte	0x40
4200087e:	02          	.byte	0x2
4200087f:	5c3c      	movi.n	a12, 53
42000881:	40          	.byte	0x40
42000882:	02          	.byte	0x2
42000883:	6c3c      	movi.n	a12, 54
42000885:	40          	.byte	0x40
42000886:	02          	.byte	0x2
42000887:	903c      	movi.n	a0, 57
42000889:	40          	.byte	0x40
4200088a:	02          	.byte	0x2
4200088b:	b43c      	movi.n	a4, 59
4200088d:	40          	.byte	0x40
4200088e:	02          	.byte	0x2
4200088f:	d03c      	movi.n	a0, 61
42000891:	40          	.byte	0x40
42000892:	02          	.byte	0x2
42000893:	ec3c      	movi.n	a12, 62
42000895:	40          	.byte	0x40
42000896:	02          	.byte	0x2
42000897:	fc3c      	movi.n	a12, 63
42000899:	40          	.byte	0x40
4200089a:	02          	.byte	0x2
4200089b:	1c3c      	movi.n	a12, 49
4200089d:	3c0241        	l32r	a4, 41fcf8a8 <_iram_bss_end+0x1c4d4a8>
420008a0:	0014a0        	movsp	a10, a4
420008a3:	758c40        	extui	a8, a4, 28, 8
420008a6:	02          	.byte	0x2
420008a7:	3c3c      	movi.n	a12, 51
420008a9:	3c0241        	l32r	a4, 41fcf8b4 <_iram_bss_end+0x1c4d4b4>
420008ac:	415c      	movi.n	a1, 84
420008ae:	02          	.byte	0x2
420008af:	7c3c      	movi.n	a12, 55
420008b1:	3c0275        	call12	4203c8d8 <_etext+0x231a2>
420008b4:	024174        	ee.st.accx.ip	a7, 0x208
420008b7:	643c      	movi.n	a4, 54
420008b9:	3c0275        	call12	4203c8e0 <_etext+0x231aa>
420008bc:	024184        	ee.st.accx.ip	a8, 0x208
420008bf:	4c3c      	movi.n	a12, 52
420008c1:	3c0275        	call12	4203c8e8 <_etext+0x231b2>
420008c4:	419c      	beqz.n	a1, 420008dc <_stext+0x8bc>
420008c6:	02          	.byte	0x2
420008c7:	a83c      	movi.n	a8, 58
420008c9:	3c0241        	l32r	a4, 41fcf8d4 <_iram_bss_end+0x1c4d4d4>
420008cc:	0241c0        	andb	b4, b1, b12
420008cf:	303c      	movi.n	a0, 51
420008d1:	3c0275        	call12	4203c8f8 <_etext+0x231c2>
420008d4:	41d8      	l32i.n	a13, a1, 16
420008d6:	02          	.byte	0x2
420008d7:	103c      	movi.n	a0, 49
420008d9:	3c0275        	call12	4203c900 <_etext+0x231ca>
420008dc:	0241e0        	andb	b4, b1, b14
420008df:	ec3c      	movi.n	a12, 62
420008e1:	3c0241        	l32r	a4, 41fcf8ec <_iram_bss_end+0x1c4d4ec>
420008e4:	024210        	andb	b4, b2, b1
420008e7:	2c3c      	movi.n	a12, 50
420008e9:	3c0242        	l8ui	a4, a2, 60
420008ec:	424c      	movi.n	a2, 68
420008ee:	02          	.byte	0x2
420008ef:	6c3c      	movi.n	a12, 54
420008f1:	3c0242        	l8ui	a4, a2, 60
420008f4:	4288      	l32i.n	a8, a2, 16
420008f6:	02          	.byte	0x2
420008f7:	ec3c      	movi.n	a12, 62
420008f9:	74          	.byte	0x74
420008fa:	02          	.byte	0x2
420008fb:	d43c      	movi.n	a4, 61
420008fd:	74          	.byte	0x74
420008fe:	02          	.byte	0x2
420008ff:	a83c      	movi.n	a8, 58
42000901:	3c0242        	l8ui	a4, a2, 60
42000904:	0242b4        	ee.st.accx.ip	a11, 0x210
42000907:	b83c      	movi.n	a8, 59
42000909:	74          	.byte	0x74
4200090a:	02          	.byte	0x2
4200090b:	cc3c      	movi.n	a12, 60
4200090d:	3c0242        	l8ui	a4, a2, 60
42000910:	74a8      	l32i.n	a10, a4, 28
42000912:	02          	.byte	0x2
42000913:	013c      	movi.n	a1, 48
42000915:	800080        	add	a0, a0, a8
42000918:	0242d4        	ee.st.accx.ip	a13, 0x210
4200091b:	083c      	movi.n	a8, 48
4200091d:	3c0243        	lsi	f4, a2, 240
42000920:	433c      	movi.n	a3, 52
42000922:	02          	.byte	0x2
42000923:	4c3c      	movi.n	a12, 52
42000925:	3c0243        	lsi	f4, a2, 240
42000928:	0233b0        	andb	b3, b3, b11
4200092b:	943c      	movi.n	a4, 57
4200092d:	74          	.byte	0x74
4200092e:	02          	.byte	0x2
4200092f:	883c      	movi.n	a8, 56
42000931:	3c0243        	lsi	f4, a2, 240
42000934:	43bc      	beqz.n	a3, 4200096c <_stext+0x94c>
42000936:	02          	.byte	0x2
42000937:	f03c      	movi.n	a0, 63
42000939:	3c0243        	lsi	f4, a2, 240
4200093c:	0022a4        	ee.ld.qacc_l.l.128.ip	a10, 0x220
4200093f:	747440        	extui	a7, a4, 4, 8
42000942:	02          	.byte	0x2
42000943:	2c3c      	movi.n	a12, 50
42000945:	3c0244        	muls.ad.ll	a2, m3
42000948:	deadbeef 	ee.fft.cmul.s16.ld.xp	q7, a14, a14, q5, q6, q2, 5
4200094c:	027460        	andb	b7, b4, b6
4200094f:	443c      	movi.n	a4, 52
42000951:	3c0244        	muls.ad.ll	a2, m3
42000954:	024480        	andb	b4, b4, b8
42000957:	b83c      	movi.n	a8, 59
42000959:	3c0244        	muls.ad.ll	a2, m3
4200095c:	44d8      	l32i.n	a13, a4, 16
4200095e:	02          	.byte	0x2
4200095f:	483c      	movi.n	a8, 52
42000961:	74          	.byte	0x74
42000962:	02          	.byte	0x2
42000963:	ec3c      	movi.n	a12, 62
42000965:	3c0244        	muls.ad.ll	a2, m3
42000968:	452c      	movi.n	a5, 36
4200096a:	02          	.byte	0x2
4200096b:	683c      	movi.n	a8, 54
4200096d:	3c0245        	call0	4203c994 <_etext+0x2325e>
42000970:	7438      	l32i.n	a3, a4, 28
42000972:	02          	.byte	0x2
42000973:	903c      	movi.n	a0, 57
42000975:	3c0245        	call0	4203c99c <_etext+0x23266>
42000978:	027424        	ee.st.accx.ip	a2, 0x3a0
4200097b:	a03c      	movi.n	a0, 58
4200097d:	3c0245        	call0	4203c9a4 <_etext+0x2326e>
42000980:	740c      	movi.n	a4, 7
42000982:	02          	.byte	0x2
42000983:	b43c      	movi.n	a4, 59
42000985:	3c0245        	call0	4203c9ac <_etext+0x23276>
42000988:	45c8      	l32i.n	a12, a5, 16
4200098a:	02          	.byte	0x2
4200098b:	ac3c      	movi.n	a12, 58
4200098d:	400014        	ee.ld.qacc_l.l.128.ip	a1, 0xfffff800
42000990:	0245e4        	ee.st.accx.ip	a14, 0x228
42000993:	f83c      	movi.n	a8, 63
42000995:	3c0245        	call0	4203c9bc <_etext+0x23286>
42000998:	001000        	movsp	a0, a0
4200099b:	00          	.byte	00
4200099c:	6028      	l32i.n	a2, a0, 24
4200099e:	004037        	ball	a0, a3, 420009a2 <_stext+0x982>
420009a1:	00          	.byte	00
420009a2:	80          	.byte	0x80
420009a3:	8000002f 	ee.ldf.128.ip	f0, f1, f0, f0, a2, 0
420009a7:	0246203f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 0, q4, q4, q4, q6
420009ab:	343c      	movi.n	a4, 51
420009ad:	3c0246        	j	4200f9ba <_vfprintf_r+0x2076>
420009b0:	022ea4        	ee.st.accx.ip	a10, 0x170
420009b3:	e83c      	movi.n	a8, 62
420009b5:	3c0275        	call12	4203c9dc <_etext+0x232a6>
420009b8:	4688      	l32i.n	a8, a6, 16
420009ba:	02          	.byte	0x2
420009bb:	173c      	movi.n	a7, 49
420009bd:	38d1b7        	bbs	a1, a11, 420009f9 <_stext+0x9d9>
420009c0:	0246a0        	andb	b4, b6, b10
420009c3:	b43c      	movi.n	a4, 59
420009c5:	3c0246        	j	4200f9d2 <_vfprintf_r+0x208e>
420009c8:	0246d0        	andb	b4, b6, b13
420009cb:	ec3c      	movi.n	a12, 62
420009cd:	3c0246        	j	4200f9da <_vfprintf_r+0x2096>
420009d0:	024724        	ee.st.accx.ip	a2, 0x238
420009d3:	3c3c      	movi.n	a12, 51
420009d5:	3c0247        	bnone	a2, a4, 42000a15 <_stext+0x9f5>
420009d8:	34          	.byte	0x34
420009d9:	403761        	l32r	a6, 41fd0ab8 <_iram_bss_end+0x1c4e6b8>
420009dc:	ff8001        	l32r	a0, 420007dc <_stext+0x7bc> (3c023db0 <_flash_rodata_start+0x3c90>)
420009df:	01f000ff 	ee.vmulas.s16.accx.ld.ip.qup	q2, a15, 0, q4, q1, q7, q0
420009e3:	4ad460        	madd.s	f13, f4, f6
420009e6:	02          	.byte	0x2
420009e7:	883c      	movi.n	a8, 56
420009e9:	3c0276        	bf	b2, 42000a29 <_stext+0xa09>
420009ec:	4af8      	l32i.n	a15, a10, 16
420009ee:	02          	.byte	0x2
420009ef:	fe3c      	movi.n	a14, 63
420009f1:	2c0000ff 	ee.vmulas.s8.accx.ld.ip.qup	q0, a15, 0xffffff00, q4, q0, q0, q0
420009f5:	024b      	addi.n	a0, a2, 4
420009f7:	6c3c      	movi.n	a12, 54
420009f9:	3c0276        	bf	b2, 42000a39 <_stext+0xa19>
420009fc:	e0001fff 	ee.cmul.s16.ld.incp	q0, a15, q0, q4, q2, 3
42000a00:	536c      	movi.n	a3, -27
42000a02:	3fc9      	s32i.n	a12, a15, 12
42000a04:	ff          	.byte	0xff
42000a05:	5cffffdf 	ee.vmulas.u16.qacc.ld.ip.qup	q1, a13, -16, q7, q7, q7, q7
42000a09:	7e          	.byte	0x7e
42000a0a:	02          	.byte	0x2
42000a0b:	f83c      	movi.n	a8, 63
42000a0d:	5040375f 	ee.vmulas.u16.qacc.ld.ip.qup	q0, a5, 112, q4, q6, q4, q0
42000a11:	024b      	addi.n	a0, a2, 4
42000a13:	c03c      	movi.n	a0, 60
42000a15:	3c0276        	bf	b2, 42000a55 <_stext+0xa35>
42000a18:	024b94        	ee.st.accx.ip	a9, 0x258
42000a1b:	6c3c      	movi.n	a12, 54
42000a1d:	82          	.byte	0x82
42000a1e:	544037        	ball	a0, a3, 42000a76 <_stext+0xa56>
42000a21:	82          	.byte	0x82
42000a22:	a44037        	ball	a0, a3, 420009ca <_stext+0x9aa>
42000a25:	3c0276        	bf	b2, 42000a65 <_stext+0xa45>
42000a28:	024774        	ee.st.accx.ip	a7, 0x238
42000a2b:	a83c      	movi.n	a8, 58
42000a2d:	024b      	addi.n	a0, a2, 4
42000a2f:	e03c      	movi.n	a0, 62
42000a31:	024b      	addi.n	a0, a2, 4
42000a33:	e43c      	movi.n	a4, 62
42000a35:	ff          	.byte	0xff
42000a36:	74fc3fce 	ee.vmulas.u8.qacc.ld.ip.qup	q1, a12, 0x1f0, q0, q7, q7, q4
42000a3a:	ff4037        	ball	a0, a3, 42000a3d <_stext+0xa1d>
42000a3d:	ff          	.byte	0xff
42000a3e:	ff          	.byte	0xff
42000a3f:	ffff41        	l32r	a4, 42000a3c <_stext+0xa1c> (41ffffff <_iram_bss_end+0x1c7dbff>)
42000a42:	ff          	.byte	0xff
42000a43:	43          	.byte	0x43
42000a44:	3bffffff 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a15, 0xfffffef0, q7, q7, q7, q7
42000a48:	3dffffff 	ee.vmulas.s8.qacc.ld.ip.qup	q3, a15, -16, q7, q7, q7, q7
42000a4c:	0233b0        	andb	b3, b3, b11
42000a4f:	903c      	movi.n	a0, 57
42000a51:	3c0277        	bnone	a2, a7, 42000a91 <_stext+0xa71>
42000a54:	020504        	ee.st.accx.ip	a0, 40
42000a57:	363c      	movi.n	a6, 51
42000a59:	420197        	bnone	a1, a9, 42000a9f <_stext+0xa7f>
42000a5c:	20          	.byte	0x20
42000a5d:	420000        	xorb	b0, b0, b0
42000a60:	01ffffff 	ee.vmulas.s16.accx.ld.ip.qup	q3, a15, 240, q7, q7, q7, q7
42000a64:	4cb8      	l32i.n	a11, a12, 16
42000a66:	02          	.byte	0x2
42000a67:	a43c      	movi.n	a4, 58
42000a69:	3c0277        	bnone	a2, a7, 42000aa9 <_stext+0xa89>
42000a6c:	4d68      	l32i.n	a6, a13, 16
42000a6e:	02          	.byte	0x2
42000a6f:	a43c      	movi.n	a4, 58
42000a71:	3c0292        	l8ui	a9, a2, 60
42000a74:	020020        	andb	b0, b0, b2
42000a77:	783c      	movi.n	a8, 55
42000a79:	024d      	mov.n	a4, a2
42000a7b:	783c      	movi.n	a8, 55
42000a7d:	3c0277        	bnone	a2, a7, 42000abd <_stext+0xa9d>
42000a80:	0277d0        	andb	b7, b7, b13
42000a83:	0c3c      	movi.n	a12, 48
42000a85:	bc3c024e 	ee.vmulas.s8.qacc.ld.xp.qup	q1, a4, a2, q0, q0, q3, q4
42000a89:	3c0277        	bnone	a2, a7, 42000ac9 <_stext+0xaa9>
42000a8c:	80          	.byte	0x80
42000a8d:	3fc953        	ssip	f5, a9, 252
42000a90:	4e48      	l32i.n	a4, a14, 16
42000a92:	02          	.byte	0x2
42000a93:	6c3c      	movi.n	a12, 54
42000a95:	c939      	s32i.n	a3, a9, 48
42000a97:	02776c3f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 192, q5, q4, q7, q7
42000a9b:	6c3c      	movi.n	a12, 54
42000a9d:	b43c024e 	ee.vmulas.s16.qacc.ld.xp.qup	q1, a4, a2, q0, q0, q3, q4
42000aa1:	903c024e 	ee.stf.128.ip	f1, f8, f0, f3, a4, 32
42000aa5:	ac3c024e 	ee.fft.cmul.s16.st.xp	q0, q3, q4, a4, a2, 0, 1, 2
42000aa9:	3fc953        	ssip	f5, a9, 252
42000aac:	c95384        	ee.vld.l.64.ip	q0, a8, 0xfffffe98
42000aaf:	024f143f 	ee.vmulas.s16.accx.ld.ip.qup	q5, a3, 64, q4, q2, q4, q7
42000ab3:	403c      	movi.n	a0, 52
42000ab5:	5c3c024f 	ee.vmulas.u16.qacc.ld.ip.qup	q1, a4, -224, q4, q0, q3, q4
42000ab9:	ac3c024f 	ee.fft.cmul.s16.st.xp	q4, q3, q4, a4, a2, 0, 1, 2
42000abd:	003c024f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a4, 32, q4, q0, q3, q4
42000ac1:	50          	.byte	0x50
42000ac2:	02          	.byte	0x2
42000ac3:	603c      	movi.n	a0, 54
42000ac5:	3c0277        	bnone	a2, a7, 42000b05 <_stext+0xae5>
42000ac8:	000000        	ill
42000acb:	000042        	l8ui	a4, a0, 0
42000ace:	00          	.byte	00
42000acf:	f83c      	movi.n	a8, 63
42000ad1:	403775        	call12	42040e48 <_etext+0x27712>
42000ad4:	027750        	andb	b7, b7, b5
42000ad7:	083c      	movi.n	a8, 48
42000ad9:	50          	.byte	0x50
42000ada:	02          	.byte	0x2
42000adb:	583c      	movi.n	a8, 53
42000add:	50          	.byte	0x50
42000ade:	02          	.byte	0x2
42000adf:	e43c      	movi.n	a4, 62
42000ae1:	76          	.byte	0x76
42000ae2:	384037        	ball	a0, a3, 42000b1e <_stext+0xafe>
42000ae5:	3c0277        	bnone	a2, a7, 42000b25 <_stext+0xb05>
42000ae8:	025094        	ee.st.accx.ip	a9, 0x280
42000aeb:	d03c      	movi.n	a0, 61
42000aed:	50          	.byte	0x50
42000aee:	02          	.byte	0x2
42000aef:	f03c      	movi.n	a0, 63
42000af1:	37cc      	bnez.n	a7, 42000af8 <_stext+0xad8>
42000af3:	76fc40        	ee.ldf.64.xp	f15, f7, a4, a12
42000af6:	e04037        	ball	a0, a3, 42000ada <_stext+0xaba>
42000af9:	0278      	l32i.n	a7, a2, 0
42000afb:	f83c      	movi.n	a8, 63
42000afd:	50          	.byte	0x50
42000afe:	02          	.byte	0x2
42000aff:	003c      	movi.n	a0, 48
42000b01:	3c0251        	l32r	a5, 41fcfb0c <_iram_bss_end+0x1c4d70c>
42000b04:	5118      	l32i.n	a1, a1, 20
42000b06:	02          	.byte	0x2
42000b07:	983c      	movi.n	a8, 57
42000b09:	027d      	mov.n	a7, a2
42000b0b:	c43c      	movi.n	a4, 60
42000b0d:	0278      	l32i.n	a7, a2, 0
42000b0f:	a83c      	movi.n	a8, 58
42000b11:	0278      	l32i.n	a7, a2, 0
42000b13:	2c3c      	movi.n	a12, 50
42000b15:	3c0251        	l32r	a5, 41fcfb20 <_iram_bss_end+0x1c4d720>
42000b18:	788c      	beqz.n	a8, 42000b23 <_stext+0xb03>
42000b1a:	02          	.byte	0x2
42000b1b:	583c      	movi.n	a8, 53
42000b1d:	0278      	l32i.n	a7, a2, 0
42000b1f:	f43c      	movi.n	a4, 63
42000b21:	c929      	s32i.n	a2, a9, 48
42000b23:	0278403f 	ee.vmulas.s16.accx.ld.ip.qup	q5, a3, 0, q5, q0, q7, q0
42000b27:	283c      	movi.n	a8, 50
42000b29:	0278      	l32i.n	a7, a2, 0
42000b2b:	103c      	movi.n	a0, 49
42000b2d:	0278      	l32i.n	a7, a2, 0
42000b2f:	f83c      	movi.n	a8, 63
42000b31:	0278      	l32i.n	a7, a2, 0
42000b33:	703c      	movi.n	a0, 55
42000b35:	0278      	l32i.n	a7, a2, 0
42000b37:	483c      	movi.n	a8, 52
42000b39:	3c0251        	l32r	a5, 41fcfb44 <_iram_bss_end+0x1c4d744>
42000b3c:	025160        	andb	b5, b1, b6
42000b3f:	fc3c      	movi.n	a12, 63
42000b41:	3c0277        	bnone	a2, a7, 42000b81 <_stext+0xb61>
42000b44:	77e8      	l32i.n	a14, a7, 28
42000b46:	02          	.byte	0x2
42000b47:	b43c      	movi.n	a4, 59
42000b49:	3fc953        	ssip	f5, a9, 252
42000b4c:	519c      	beqz.n	a1, 42000b65 <_stext+0xb45>
42000b4e:	02          	.byte	0x2
42000b4f:	7c3c      	movi.n	a12, 55
42000b51:	0279      	s32i.n	a7, a2, 0
42000b53:	d33c      	movi.n	a3, 61
42000b55:	3c0251        	l32r	a5, 41fcfb60 <_iram_bss_end+0x1c4d760>
42000b58:	9b6c      	movi.n	a11, -23
42000b5a:	a44037        	ball	a0, a3, 42000b02 <_stext+0xae2>
42000b5d:	9d          	.byte	0x9d
42000b5e:	a04037        	ball	a0, a3, 42000b02 <_stext+0xae2>
42000b61:	379b      	addi.n	a3, a7, 9
42000b63:	533040        	max	a3, a0, a4
42000b66:	02          	.byte	0x2
42000b67:	903c      	movi.n	a0, 57
42000b69:	0279      	s32i.n	a7, a2, 0
42000b6b:	233c      	movi.n	a3, 50
42000b6d:	3c0253        	lsi	f5, a2, 240
42000b70:	025364        	ee.st.accx.ip	a6, 0x298
42000b73:	a43c      	movi.n	a4, 58
42000b75:	0279      	s32i.n	a7, a2, 0
42000b77:	973c      	movi.n	a7, 57
42000b79:	3c0253        	lsi	f5, a2, 240
42000b7c:	0279b4        	ee.st.accx.ip	a11, 0x3c8
42000b7f:	a43c      	movi.n	a4, 58
42000b81:	7440001f 	ee.vmulas.u8.qacc.ld.ip.qup	q0, a1, 0x100, q4, q0, q4, q0
42000b85:	0040001f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a1, 0, q4, q0, q4, q0
42000b89:	600030        	neg	a0, a3
42000b8c:	0254f4        	ee.st.accx.ip	a15, 0x2a0
42000b8f:	903c      	movi.n	a0, 57
42000b91:	027a      	add.n	a0, a2, a7
42000b93:	f83c      	movi.n	a8, 63
42000b95:	54          	.byte	0x54
42000b96:	02          	.byte	0x2
42000b97:	983c      	movi.n	a8, 57
42000b99:	c939      	s32i.n	a3, a9, 48
42000b9b:	c939b83f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q6, q6, q3, q1
42000b9f:	0255603f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 0, q5, q4, q5, q5
42000ba3:	c83c      	movi.n	a8, 60
42000ba5:	3c0255        	call4	4203cbcc <_etext+0x23496>
42000ba8:	027a74        	ee.st.accx.ip	a7, 0x3d0
42000bab:	4c3c      	movi.n	a12, 52
42000bad:	3c0256        	bnez	a2, 42000f71 <_stext+0xf51>
42000bb0:	c953c4        	ee.vld.l.64.ip	q0, a12, 0xfffffe98
42000bb3:	3781e83f 	ee.vmulas.s8.qacc.ld.ip.qup	q6, a3, 0x180, q7, q5, q0, q1
42000bb7:	817440        	src	a7, a4, a4
42000bba:	c84037        	ball	a0, a3, 42000b86 <_stext+0xb66>
42000bbd:	403804        	ee.ld.qacc_l.l.128.ip	a0, 0xfffffb80
42000bc0:	0098      	l32i.n	a9, a0, 0
42000bc2:	4038      	l32i.n	a3, a0, 16
42000bc4:	377d00        	ee.stf.64.xp	f7, f3, a0, a13
42000bc7:	40          	.byte	0x40
42000bc8:	70          	.byte	0x70
42000bc9:	c939      	s32i.n	a3, a9, 48
42000bcb:	377a6c3f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x1c0, q5, q4, q7, q2
42000bcf:	2a7c40        	mul.s	f7, f12, f4
42000bd2:	3fc9      	s32i.n	a12, a15, 12
42000bd4:	d0          	.byte	0xd0
42000bd5:	3fc953        	ssip	f5, a9, 252
42000bd8:	a4          	.byte	0xa4
42000bd9:	377b      	addi.n	a3, a7, 7
42000bdb:	53d440        	max	a13, a4, a4
42000bde:	3fc9      	s32i.n	a12, a15, 12
42000be0:	025724        	ee.st.accx.ip	a2, 0x2b8
42000be3:	d03c      	movi.n	a0, 61
42000be5:	027a      	add.n	a0, a2, a7
42000be7:	283c      	movi.n	a8, 50
42000be9:	3c0257        	bnone	a2, a5, 42000c29 <_stext+0xc09>
42000bec:	0648      	l32i.n	a4, a6, 0
42000bee:	00          	.byte	00
42000bef:	53d840        	max	a13, a8, a4
42000bf2:	3fc9      	s32i.n	a12, a15, 12
42000bf4:	84          	.byte	0x84
42000bf5:	377c      	movi.n	a7, -13
42000bf7:	2a8440        	mul.s	f8, f4, f4
42000bfa:	3fc9      	s32i.n	a12, a15, 12
42000bfc:	027b20        	andb	b7, b11, b2
42000bff:	543c      	movi.n	a4, 53
42000c01:	3c0257        	bnone	a2, a5, 42000c41 <_stext+0xc21>
42000c04:	025760        	andb	b5, b7, b6
42000c07:	9c3c      	movi.n	a12, 57
42000c09:	3c0257        	bnone	a2, a5, 42000c49 <_stext+0xc29>
42000c0c:	57cc      	bnez.n	a7, 42000c15 <_stext+0xbf5>
42000c0e:	02          	.byte	0x2
42000c0f:	9c3c      	movi.n	a12, 57
42000c11:	fe          	.byte	0xfe
42000c12:	e84037        	ball	a0, a3, 42000bfe <_stext+0xbde>
42000c15:	027a      	add.n	a0, a2, a7
42000c17:	fc3c      	movi.n	a12, 63
42000c19:	3c0257        	bnone	a2, a5, 42000c59 <_stext+0xc39>
42000c1c:	025820        	andb	b5, b8, b2
42000c1f:	443c      	movi.n	a4, 52
42000c21:	0258      	l32i.n	a5, a2, 0
42000c23:	5c3c      	movi.n	a12, 53
42000c25:	0258      	l32i.n	a5, a2, 0
42000c27:	9c3c      	movi.n	a12, 57
42000c29:	027b      	addi.n	a0, a2, 7
42000c2b:	913c      	movi.n	a1, 57
42000c2d:	0258      	l32i.n	a5, a2, 0
42000c2f:	dc3c      	movi.n	a12, 61
42000c31:	3fc953        	ssip	f5, a9, 252
42000c34:	589c      	beqz.n	a8, 42000c4d <_stext+0xc2d>
42000c36:	02          	.byte	0x2
42000c37:	d03c      	movi.n	a0, 61
42000c39:	0258      	l32i.n	a5, a2, 0
42000c3b:	983c      	movi.n	a8, 57
42000c3d:	4037c7        	bltu	a7, a12, 42000c81 <_stext+0xc61>
42000c40:	59fc      	bnez.n	a9, 42000c79 <_stext+0xc59>
42000c42:	404037        	ball	a0, a3, 42000c86 <_stext+0xc66>
42000c45:	375c      	movi.n	a7, 83
42000c47:	40          	.byte	0x40
42000c48:	74          	.byte	0x74
42000c49:	377c      	movi.n	a7, -13
42000c4b:	40          	.byte	0x40
42000c4c:	64          	.byte	0x64
42000c4d:	377c      	movi.n	a7, -13
42000c4f:	7b2c40        	ule.s	b2, f12, f4
42000c52:	02          	.byte	0x2
42000c53:	f43c      	movi.n	a4, 63
42000c55:	0258      	l32i.n	a5, a2, 0
42000c57:	243c      	movi.n	a4, 50
42000c59:	0259      	s32i.n	a5, a2, 0
42000c5b:	683c      	movi.n	a8, 54
42000c5d:	027b      	addi.n	a0, a2, 7
42000c5f:	383c      	movi.n	a8, 51
42000c61:	0259      	s32i.n	a5, a2, 0
42000c63:	5c3c      	movi.n	a12, 53
42000c65:	0259      	s32i.n	a5, a2, 0
42000c67:	943c      	movi.n	a4, 57
42000c69:	00b9      	s32i.n	a11, a0, 0
42000c6b:	42          	.byte	0x42
42000c6c:	598c      	beqz.n	a9, 42000c75 <_stext+0xc55>
42000c6e:	02          	.byte	0x2
42000c6f:	243c      	movi.n	a4, 50
42000c71:	4037c7        	bltu	a7, a12, 42000cb5 <_stext+0xc95>
42000c74:	7b88      	l32i.n	a8, a11, 28
42000c76:	02          	.byte	0x2
42000c77:	cc3c      	movi.n	a12, 60
42000c79:	0259      	s32i.n	a5, a2, 0
42000c7b:	f43c      	movi.n	a4, 63
42000c7d:	0259      	s32i.n	a5, a2, 0
42000c7f:	243c      	movi.n	a4, 50
42000c81:	025a      	add.n	a0, a2, a5
42000c83:	a83c      	movi.n	a8, 58
42000c85:	00bb      	addi.n	a0, a0, 11
42000c87:	7b0c42        	l8ui	a4, a12, 123
42000c8a:	02          	.byte	0x2
42000c8b:	f83c      	movi.n	a8, 63
42000c8d:	027a      	add.n	a0, a2, a7
42000c8f:	543c      	movi.n	a4, 53
42000c91:	027b      	addi.n	a0, a2, 7
42000c93:	503c      	movi.n	a0, 53
42000c95:	025a      	add.n	a0, a2, a5
42000c97:	403c      	movi.n	a0, 52
42000c99:	027b      	addi.n	a0, a2, 7
42000c9b:	783c      	movi.n	a8, 55
42000c9d:	025a      	add.n	a0, a2, a5
42000c9f:	ac3c      	movi.n	a12, 58
42000ca1:	025a      	add.n	a0, a2, a5
42000ca3:	b83c      	movi.n	a8, 59
42000ca5:	025a      	add.n	a0, a2, a5
42000ca7:	c43c      	movi.n	a4, 60
42000ca9:	025a      	add.n	a0, a2, a5
42000cab:	d03c      	movi.n	a0, 61
42000cad:	025a      	add.n	a0, a2, a5
42000caf:	2c3c      	movi.n	a12, 50
42000cb1:	025b      	addi.n	a0, a2, 5
42000cb3:	3c3c      	movi.n	a12, 51
42000cb5:	025b      	addi.n	a0, a2, 5
42000cb7:	543c      	movi.n	a4, 53
42000cb9:	025b      	addi.n	a0, a2, 5
42000cbb:	103c      	movi.n	a0, 49
42000cbd:	37b9      	s32i.n	a11, a7, 12
42000cbf:	40          	.byte	0x40
42000cc0:	c93ae4        	ee.vld.l.64.ip	q0, a14, 0xfffffdd0
42000cc3:	025b5c3f 	ee.vmulas.s16.accx.ld.ip.qup	q5, a3, 192, q5, q2, q5, q3
42000cc7:	003c      	movi.n	a0, 48
42000cc9:	000000        	ill
42000ccc:	025b74        	ee.st.accx.ip	a7, 0x2d8
42000ccf:	783c      	movi.n	a8, 55
42000cd1:	027b      	addi.n	a0, a2, 7
42000cd3:	583c      	movi.n	a8, 53
42000cd5:	4037c7        	bltu	a7, a12, 42000d19 <_stext+0xcf9>
42000cd8:	53e8      	l32i.n	a14, a3, 20
42000cda:	3fc9      	s32i.n	a12, a15, 12
42000cdc:	e0          	.byte	0xe0
42000cdd:	3fc953        	ssip	f5, a9, 252
42000ce0:	025b84        	ee.st.accx.ip	a8, 0x2d8
42000ce3:	b43c      	movi.n	a4, 59
42000ce5:	027b      	addi.n	a0, a2, 7
42000ce7:	a83c      	movi.n	a8, 58
42000ce9:	025b      	addi.n	a0, a2, 5
42000ceb:	e83c      	movi.n	a8, 62
42000ced:	025b      	addi.n	a0, a2, 5
42000cef:	c83c      	movi.n	a8, 60
42000cf1:	000d      	mov.n	a0, a0
42000cf3:	40          	.byte	0x40
42000cf4:	10          	.byte	0x10
42000cf5:	4c40000e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a0, 0xffffff00, q0, q0, q4, q0
42000cf9:	600070        	neg	a0, a7
42000cfc:	50          	.byte	0x50
42000cfd:	600070        	neg	a0, a7
42000d00:	5c08      	l32i.n	a0, a12, 20
42000d02:	02          	.byte	0x2
42000d03:	143c      	movi.n	a4, 49
42000d05:	025c      	movi.n	a2, 80
42000d07:	503c      	movi.n	a0, 53
42000d09:	025c      	movi.n	a2, 80
42000d0b:	643c      	movi.n	a4, 54
42000d0d:	400014        	ee.ld.qacc_l.l.128.ip	a1, 0xfffff800
42000d10:	002000        	isync
42000d13:	60          	.byte	0x60
42000d14:	024000        	andb	b4, b0, b0
42000d17:	60          	.byte	0x60
42000d18:	025000        	andb	b5, b0, b0
42000d1b:	b40060        	extui	a0, a6, 0, 12
42000d1e:	4004c4        	ee.ld.qacc_l.l.128.ip	a12, 0xfffff840
42000d21:	000213        	lsi	f1, a2, 0
42000d24:	022ea4        	ee.st.accx.ip	a10, 0x170
42000d27:	d43c      	movi.n	a4, 61
42000d29:	027b      	addi.n	a0, a2, 7
42000d2b:	843c      	movi.n	a4, 56
42000d2d:	025c      	movi.n	a2, 80
42000d2f:	c03c      	movi.n	a0, 60
42000d31:	600080        	neg	a0, a8
42000d34:	5cbc      	beqz.n	a12, 42000d6d <_stext+0xd4d>
42000d36:	02          	.byte	0x2
42000d37:	c43c      	movi.n	a4, 60
42000d39:	025c      	movi.n	a2, 80
42000d3b:	103c      	movi.n	a0, 49
42000d3d:	00          	.byte	00
42000d3e:	600c      	movi.n	a0, 6
42000d40:	7bec      	bnez.n	a11, 42000d6b <_stext+0xd4b>
42000d42:	02          	.byte	0x2
42000d43:	003c      	movi.n	a0, 48
42000d45:	025d      	mov.n	a5, a2
42000d47:	603c      	movi.n	a0, 54
42000d49:	00          	.byte	00
42000d4a:	600c      	movi.n	a0, 6
42000d4c:	5d2c      	movi.n	a13, 37
42000d4e:	02          	.byte	0x2
42000d4f:	243c      	movi.n	a4, 50
42000d51:	83          	.byte	0x83
42000d52:	ff4037        	ball	a0, a3, 42000d55 <_stext+0xd35>
42000d55:	0fefffff 	ee.vmulas.s16.accx.ld.ip.qup	q7, a15, -16, q7, q7, q6, q7
42000d59:	c0          	.byte	0xc0
42000d5a:	0000ffff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 240, q7, q6, q0, q0
42000d5e:	00          	.byte	00
42000d5f:	20          	.byte	0x20
42000d60:	dfffffff 	ee.fft.cmul.s16.ld.xp	q7, a15, a15, q7, q7, q7, 7
42000d64:	00          	.byte	00
42000d65:	00          	.byte	00
42000d66:	ff          	.byte	0xff
42000d67:	03          	.byte	0x3
42000d68:	ff          	.byte	0xff
42000d69:	00fbffff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 240, q7, q7, q7, q3
42000d6d:	080000        	lsx	f0, a0, a0
42000d70:	bfffffff 	ee.vmulas.s8.qacc.ld.xp.qup	q7, a15, a15, q7, q7, q7, q7
42000d74:	8408      	l32i.n	a0, a4, 32
42000d76:	02          	.byte	0x2
42000d77:	903c      	movi.n	a0, 57
42000d79:	c92a      	add.n	a12, a9, a2
42000d7b:	37ff103f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x100, q4, q3, q7, q7
42000d7f:	40          	.byte	0x40
42000d80:	00          	.byte	00
42000d81:	8968      	l32i.n	a6, a9, 32
42000d83:	1c09      	s32i.n	a0, a12, 4
42000d85:	84          	.byte	0x84
42000d86:	02          	.byte	0x2
42000d87:	c03c      	movi.n	a0, 60
42000d89:	3c0261        	l32r	a6, 41fcfd94 <_iram_bss_end+0x1c4d994>
42000d8c:	0261d0        	andb	b6, b1, b13
42000d8f:	f83c      	movi.n	a8, 63
42000d91:	3c0261        	l32r	a6, 41fcfd9c <_iram_bss_end+0x1c4d99c>
42000d94:	4e6c      	movi.n	a14, -28
42000d96:	02          	.byte	0x2
42000d97:	203c      	movi.n	a0, 50
42000d99:	3c0262        	l8ui	a6, a2, 60
42000d9c:	008c00        	any4	b0, b12:b13:b14:b15
42000d9f:	75cc00        	extui	a12, a0, 28, 8
42000da2:	004037        	ball	a0, a3, 42000da6 <_stext+0xd86>
42000da5:	000090        	retw
42000da8:	026260        	andb	b6, b2, b6
42000dab:	6c3c      	movi.n	a12, 54
42000dad:	3c0262        	l8ui	a6, a2, 60
42000db0:	629c      	beqz.n	a2, 42000dca <_stext+0xdaa>
42000db2:	02          	.byte	0x2
42000db3:	f03c      	movi.n	a0, 63
42000db5:	3fc953        	ssip	f5, a9, 252
42000db8:	50aa      	add.n	a5, a0, a10
42000dba:	00          	.byte	00
42000dbb:	00          	.byte	00
42000dbc:	ebeb      	addi.n	a14, a11, 14
42000dbe:	00          	.byte	00
42000dbf:	00          	.byte	00
42000dc0:	1c5c      	movi.n	a12, 81
42000dc2:	00          	.byte	00
42000dc3:	40          	.byte	0x40
42000dc4:	1c68      	l32i.n	a6, a12, 4
42000dc6:	244000        	extui	a4, a0, 0, 3
42000dc9:	400012        	l8ui	a1, a0, 64
42000dcc:	001c74        	ee.ld.qacc_l.l.128.ip	a7, 0x1c0
42000dcf:	120c40        	andbc	b0, b12, b4
42000dd2:	00          	.byte	00
42000dd3:	53ec40        	max	a14, a12, a4
42000dd6:	3fc9      	s32i.n	a12, a15, 12
42000dd8:	62c8      	l32i.n	a12, a2, 24
42000dda:	02          	.byte	0x2
42000ddb:	303c      	movi.n	a0, 51
42000ddd:	3c0202        	l8ui	a0, a2, 60
42000de0:	54          	.byte	0x54
42000de1:	84          	.byte	0x84
42000de2:	02          	.byte	0x2
42000de3:	333c      	movi.n	a3, 51
42000de5:	3c0263        	lsi	f6, a2, 240
42000de8:	026340        	andb	b6, b3, b4
42000deb:	403c      	movi.n	a0, 52
42000ded:	84          	.byte	0x84
42000dee:	02          	.byte	0x2
42000def:	f43c      	movi.n	a4, 63
42000df1:	3fc953        	ssip	f5, a9, 252
42000df4:	64          	.byte	0x64
42000df5:	00c9      	s32i.n	a12, a0, 0
42000df7:	635442        	s16i	a4, a4, 198
42000dfa:	02          	.byte	0x2
42000dfb:	683c      	movi.n	a8, 54
42000dfd:	84          	.byte	0x84
42000dfe:	02          	.byte	0x2
42000dff:	983c      	movi.n	a8, 57
42000e01:	3c0263        	lsi	f6, a2, 240
42000e04:	63a8      	l32i.n	a10, a3, 24
42000e06:	02          	.byte	0x2
42000e07:	043c      	movi.n	a4, 48
42000e09:	376b      	addi.n	a3, a7, 6
42000e0b:	6b8840        	ole.s	b8, f8, f4
42000e0e:	c84037        	ball	a0, a3, 42000dda <_stext+0xdba>
42000e11:	d44037fe 	ee.fft.ams.s16.ld.incp.uaup	q7, a15, q6, q0, q0, q4, q0, 0
42000e15:	376a      	add.n	a3, a7, a6
42000e17:	c78040        	ee.stf.64.xp	f8, f12, a4, a0
42000e1a:	014037        	ball	a0, a3, 42000e1f <_stext+0xdff>
42000e1d:	204000        	or	a4, a0, a0
42000e20:	f4          	.byte	0xf4
42000e21:	00cb      	addi.n	a0, a0, 12
42000e23:	d1b842        	l32ai	a4, a8, 0x344
42000e26:	f44200        	extui	a4, a0, 2, 16
42000e29:	4200d1        	l32r	a13, 41fd162c <_iram_bss_end+0x1c4f22c>
42000e2c:	30          	.byte	0x30
42000e2d:	4200d2        	l8ui	a13, a0, 66
42000e30:	d26c      	movi.n	a2, -19
42000e32:	644200        	extui	a4, a0, 2, 7
42000e35:	54          	.byte	0x54
42000e36:	3fc9      	s32i.n	a12, a15, 12
42000e38:	53fc      	bnez.n	a3, 42000e71 <_stext+0xe51>
42000e3a:	3fc9      	s32i.n	a12, a15, 12
42000e3c:	54cc      	bnez.n	a4, 42000e45 <_stext+0xe25>
42000e3e:	3fc9      	s32i.n	a12, a15, 12
42000e40:	376ab0        	ee.stf.64.xp	f6, f3, a11, a10
42000e43:	40          	.byte	0x40
42000e44:	e4          	.byte	0xe4
42000e45:	00c9      	s32i.n	a12, a0, 0
42000e47:	42          	.byte	0x42
42000e48:	c95534        	ee.vld.l.64.ip	q0, a3, 0xfffffea8
42000e4b:	00cce43f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a3, 64, q7, q5, q4, q4
42000e4f:	000142        	l8ui	a4, a1, 0
42000e52:	ff          	.byte	0xff
42000e53:	37fee8ff 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a15, 0x180, q7, q5, q7, q6
42000e57:	40          	.byte	0x40
42000e58:	ccf8      	l32i.n	a15, a12, 48
42000e5a:	304200        	xor	a4, a2, a0
42000e5d:	00cd      	mov.n	a12, a0
42000e5f:	cd4c42        	s8i	a4, a12, 205
42000e62:	804200        	add	a4, a2, a0
42000e65:	d47fffff 	ee.fft.ams.s16.ld.incp.uaup	q7, a15, q6, q3, q7, q7, q7, 0
42000e69:	004037fe 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 112, q0, q6, q4, q0
42000e6d:	400012        	l8ui	a1, a0, 64
42000e70:	001344        	ee.ld.qacc_l.l.128.ip	a4, 0x130
42000e73:	2ab040        	mul.s	f11, f0, f4
42000e76:	3fc9      	s32i.n	a12, a15, 12
42000e78:	8e7c      	movi.n	a14, -8
42000e7a:	02          	.byte	0x2
42000e7b:	103c      	movi.n	a0, 49
42000e7d:	a43c028e 	ee.fft.ams.s16.st.incp	q3, q1, a8, a2, q4, q0, q0, 1
42000e81:	028d      	mov.n	a8, a2
42000e83:	a83c      	movi.n	a8, 58
42000e85:	84          	.byte	0x84
42000e86:	02          	.byte	0x2
42000e87:	213c      	movi.n	a1, 50
42000e89:	1208      	l32i.n	a0, a2, 4
42000e8b:	84c800        	extui	a12, a0, 8, 9
42000e8e:	02          	.byte	0x2
42000e8f:	283c      	movi.n	a8, 50
42000e91:	3c0285        	call0	4203cebc <_etext+0x23786>
42000e94:	028540        	andb	b8, b5, b4
42000e97:	e43c      	movi.n	a4, 62
42000e99:	3c0286        	j	4200fea7 <_vfprintf_r+0x2563>
42000e9c:	86e8      	l32i.n	a14, a6, 32
42000e9e:	02          	.byte	0x2
42000e9f:	ec3c      	movi.n	a12, 62
42000ea1:	3c0286        	j	4200feaf <_vfprintf_r+0x256b>
42000ea4:	0286f0        	andb	b8, b6, b15
42000ea7:	f43c      	movi.n	a4, 63
42000ea9:	3c0286        	j	4200feb7 <_vfprintf_r+0x2573>
42000eac:	028705        	call0	42003720 <esp_intr_alloc_intrstatus_bind+0x6c>
42000eaf:	583c      	movi.n	a8, 53
42000eb1:	3c0285        	call0	4203cedc <_etext+0x237a6>
42000eb4:	d4          	.byte	0xd4
42000eb5:	3c0286        	j	4200fec3 <_vfprintf_r+0x257f>
42000eb8:	c4          	.byte	0xc4
42000eb9:	3c0286        	j	4200fec7 <_vfprintf_r+0x2583>
42000ebc:	028716        	beqz	a7, 42000ee8 <_stext+0xec8>
42000ebf:	003c      	movi.n	a0, 48
42000ec1:	00          	.byte	00
42000ec2:	e0          	.byte	0xe0
42000ec3:	3f          	.byte	0x3f
42000ec4:	7fefffff 	ee.vmulas.u8.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q6, q7
42000ec8:	258c      	beqz.n	a5, 42000ece <_stext+0xeae>
42000eca:	00          	.byte	00
42000ecb:	23b840        	sext	a11, a8, 11
42000ece:	00          	.byte	00
42000ecf:	23dc40        	sext	a13, a12, 11
42000ed2:	184000        	lsxp	f4, a0, a0
42000ed5:	400024        	ee.ld.qacc_l.l.128.ip	a2, 0xfffff800
42000ed8:	228c      	beqz.n	a2, 42000ede <_stext+0xebe>
42000eda:	d44000        	extui	a4, a0, 0, 14
42000edd:	400022        	l8ui	a2, a0, 64
42000ee0:	002334        	ee.ld.qacc_l.l.128.ip	a3, 0x230
42000ee3:	24fc40        	extui	a15, a4, 12, 3
42000ee6:	00          	.byte	00
42000ee7:	246c40        	extui	a6, a4, 12, 3
42000eea:	a04000        	addx4	a4, a0, a0
42000eed:	400023        	lsi	f2, a0, 0x100
42000ef0:	028800        	andb	b8, b8, b0
42000ef3:	203c      	movi.n	a0, 50
42000ef5:	0288      	l32i.n	a8, a2, 0
42000ef7:	803c      	movi.n	a0, 56
42000ef9:	0288      	l32i.n	a8, a2, 0
42000efb:	983c      	movi.n	a8, 57
42000efd:	0288      	l32i.n	a8, a2, 0
42000eff:	053c      	movi.n	a5, 48
42000f01:	3c0287        	bnone	a2, a8, 42000f41 <_stext+0xf21>
42000f04:	f4          	.byte	0xf4
42000f05:	3c0286        	j	4200ff13 <_vfprintf_r+0x25cf>
42000f08:	0288b0        	andb	b8, b8, b11
42000f0b:	2c3c      	movi.n	a12, 50
42000f0d:	028a      	add.n	a0, a2, a8
42000f0f:	1c3c      	movi.n	a12, 49
42000f11:	028a      	add.n	a0, a2, a8
42000f13:	a43c      	movi.n	a4, 58
42000f15:	c92b      	addi.n	a12, a9, 2
42000f17:	0fffff3f 	ee.vmulas.s16.accx.ld.ip.qup	q7, a3, -16, q7, q7, q7, q7
42000f1b:	871880        	ee.stf.64.xp	f1, f8, a8, a8
42000f1e:	02          	.byte	0x2
42000f1f:	203c      	movi.n	a0, 50
42000f21:	3c0287        	bnone	a2, a8, 42000f61 <_stext+0xf41>
42000f24:	028721        	l32r	a2, 41fc1940 <_iram_bss_end+0x1c3f540>
42000f27:	243c      	movi.n	a4, 50
42000f29:	3c0287        	bnone	a2, a8, 42000f69 <_stext+0xf49>
42000f2c:	028716        	beqz	a7, 42000f58 <_stext+0xf38>
42000f2f:	253c      	movi.n	a5, 50
42000f31:	3c0287        	bnone	a2, a8, 42000f71 <_stext+0xf51>
42000f34:	873c      	movi.n	a7, 56
42000f36:	02          	.byte	0x2
42000f37:	173c      	movi.n	a7, 49
42000f39:	3c0287        	bnone	a2, a8, 42000f79 <_stext+0xf59>
42000f3c:	f00000        	subx8	a0, a0, a0
42000f3f:	028aa03f 	ee.vmulas.s16.accx.ld.ip.qup	q5, a3, 0, q6, q5, q0, q2
42000f43:	903c      	movi.n	a0, 57
42000f45:	3c0287        	bnone	a2, a8, 42000f85 <_stext+0xf65>
42000f48:	8a78      	l32i.n	a7, a10, 32
42000f4a:	02          	.byte	0x2
42000f4b:	003c      	movi.n	a0, 48
42000f4d:	402400        	ssa8l	a4
42000f50:	140000        	extui	a0, a0, 0, 2
42000f53:	40          	.byte	0x40
42000f54:	00          	.byte	00
42000f55:	401c00        	ssl	a12
42000f58:	6f4361        	l32r	a6, 41fdcc64 <_iram_bss_end+0x1c5a864>
42000f5b:	63          	.byte	0x63
42000f5c:	d287a7        	bany	a7, a10, 42000f32 <_stext+0xf12>
42000f5f:	60c8b33f 	ee.vmulas.u8.accx.ld.ip.qup	q1, a3, 48, q6, q7, q4, q0
42000f63:	288b      	addi.n	a2, a8, 8
42000f65:	c68a      	add.n	a12, a6, a8
42000f67:	9f79fb3f 	ee.stf.128.xp	f15, f3, f15, f7, a3, a11
42000f6b:	441350        	extui	a1, a5, 3, 5
42000f6e:	d3          	.byte	0xd3
42000f6f:	0023643f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a3, 64, q5, q4, q2, q3
42000f73:	218440        	srai	a8, a4, 4
42000f76:	504000        	iitlb	a0
42000f79:	400022        	l8ui	a2, a0, 64
42000f7c:	028725        	call8	420037f0 <esp_intr_alloc_intrstatus_bind+0x13c>
42000f7f:	a13c      	movi.n	a1, 58
42000f81:	3c0287        	bnone	a2, a8, 42000fc1 <_stext+0xfa1>
42000f84:	f4          	.byte	0xf4
42000f85:	904037fe 	ee.stf.128.ip	f0, f0, f3, f4, a15, 112
42000f89:	3c0287        	bnone	a2, a8, 42000fc9 <_stext+0xfa9>
42000f8c:	8e39      	s32i.n	a3, a14, 32
42000f8e:	e3          	.byte	0xe3
42000f8f:	4038      	l32i.n	a3, a0, 16
42000f91:	028a      	add.n	a0, a2, a8
42000f93:	683c      	movi.n	a8, 54
42000f95:	028b      	addi.n	a0, a2, 8
42000f97:	883c      	movi.n	a8, 56
42000f99:	028b      	addi.n	a0, a2, 8
42000f9b:	e83c      	movi.n	a8, 62
42000f9d:	028b      	addi.n	a0, a2, 8
42000f9f:	003c      	movi.n	a0, 48
42000fa1:	028c      	beqz.n	a2, 42000fa5 <_stext+0xf85>
42000fa3:	053c      	movi.n	a5, 48
42000fa5:	3c0287        	bnone	a2, a8, 42000fe5 <_stext+0xfc5>
42000fa8:	f4          	.byte	0xf4
42000fa9:	3c0286        	j	4200ffb7 <_vfprintf_r+0x2673>
42000fac:	8c18      	l32i.n	a1, a12, 32
42000fae:	02          	.byte	0x2
42000faf:	943c      	movi.n	a4, 57
42000fb1:	028d      	mov.n	a8, a2
42000fb3:	843c      	movi.n	a4, 56
42000fb5:	028d      	mov.n	a8, a2
42000fb7:	3c3c      	movi.n	a12, 51
42000fb9:	3c0276        	bf	b2, 42000ff9 <_stext+0xfd9>
42000fbc:	024774        	ee.st.accx.ip	a7, 0x238
42000fbf:	7c3c      	movi.n	a12, 55
42000fc1:	3c0247        	bnone	a2, a4, 42001001 <_stext+0xfe1>
42000fc4:	47a8      	l32i.n	a10, a7, 16
42000fc6:	02          	.byte	0x2
42000fc7:	2c3c      	movi.n	a12, 50
42000fc9:	3c0276        	bf	b2, 42001009 <_stext+0xfe9>
42000fcc:	47cc      	bnez.n	a7, 42000fd4 <_stext+0xfb4>
42000fce:	02          	.byte	0x2
42000fcf:	f83c      	movi.n	a8, 63
42000fd1:	3c0247        	bnone	a2, a4, 42001011 <_stext+0xff1>
42000fd4:	7658      	l32i.n	a5, a6, 28
42000fd6:	02          	.byte	0x2
42000fd7:	303c      	movi.n	a0, 51
42000fd9:	0248      	l32i.n	a4, a2, 0
42000fdb:	583c      	movi.n	a8, 53
42000fdd:	0248      	l32i.n	a4, a2, 0
42000fdf:	8c3c      	movi.n	a12, 56
42000fe1:	0248      	l32i.n	a4, a2, 0
42000fe3:	c03c      	movi.n	a0, 60
42000fe5:	0248      	l32i.n	a4, a2, 0
42000fe7:	fc3c      	movi.n	a12, 63
42000fe9:	0248      	l32i.n	a4, a2, 0
42000feb:	243c      	movi.n	a4, 50
42000fed:	0249      	s32i.n	a4, a2, 0
42000fef:	503c      	movi.n	a0, 53
42000ff1:	0249      	s32i.n	a4, a2, 0
42000ff3:	183c      	movi.n	a8, 49
42000ff5:	3c0276        	bf	b2, 42001035 <_stext+0x1015>
42000ff8:	024980        	andb	b4, b9, b8
42000ffb:	b03c      	movi.n	a0, 59
42000ffd:	0249      	s32i.n	a4, a2, 0
42000fff:	643c      	movi.n	a4, 54
42001001:	4037e5        	call8	42041380 <_etext+0x27c4a>
42001004:	7608      	l32i.n	a0, a6, 28
42001006:	02          	.byte	0x2
42001007:	dc3c      	movi.n	a12, 61
42001009:	0249      	s32i.n	a4, a2, 0
4200100b:	083c      	movi.n	a8, 48
4200100d:	024a      	add.n	a0, a2, a4
4200100f:	083c      	movi.n	a8, 48
42001011:	7d          	.byte	0x7d
42001012:	884037        	ball	a0, a3, 42000f9e <_stext+0xf7e>
42001015:	403765        	call8	4204138c <_etext+0x27c56>
42001018:	75f8      	l32i.n	a15, a5, 28
4200101a:	02          	.byte	0x2
4200101b:	403c      	movi.n	a0, 52
4200101d:	024a      	add.n	a0, a2, a4
4200101f:	703c      	movi.n	a0, 55
42001021:	024a      	add.n	a0, a2, a4
42001023:	a83c      	movi.n	a8, 58
42001025:	024a      	add.n	a0, a2, a4
42001027:	103c      	movi.n	a0, 49
42001029:	7d          	.byte	0x7d
4200102a:	004037        	ball	a0, a3, 4200102e <_stext+0x100e>
4200102d:	100000        	and	a0, a0, a0
42001030:	800000        	add	a0, a0, a0
42001033:	000000        	ill
42001036:	000004        	ee.ld.qacc_l.l.128.ip	a0, 0
42001039:	002000        	isync
4200103c:	020000        	andb	b0, b0, b0
4200103f:	000000        	ill
42001042:	10          	.byte	0x10
42001043:	000000        	ill
42001046:	000001        	l32r	a0, 41fc1048 <_iram_bss_end+0x1c3ec48>
42001049:	00          	.byte	00
4200104a:	0008      	l32i.n	a0, a0, 0
4200104c:	0078078f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a8, 112, q4, q0, q7, q0
42001050:	030000        	rsr.lbeg	a0
42001053:	00          	.byte	00
42001054:	3e08      	l32i.n	a0, a14, 12
42001056:	080000        	lsx	f0, a0, a0
42001059:	00          	.byte	00
4200105a:	600c      	movi.n	a0, 6
4200105c:	c04001        	l32r	a0, 41ff115c <_iram_bss_end+0x1c6ed5c>
4200105f:	601817        	beq	a8, a1, 420010c3 <_stext+0x10a3>
42001062:	0c6002        	s32i	a0, a0, 48
42001065:	00          	.byte	00
42001066:	600c      	movi.n	a0, 6
42001068:	2358      	l32i.n	a5, a3, 8
4200106a:	02          	.byte	0x2
4200106b:	243c      	movi.n	a4, 50
4200106d:	026c      	movi.n	a2, -32
4200106f:	943c      	movi.n	a4, 57
42001071:	3c0223        	lsi	f2, a2, 240
42001074:	c92454        	ee.vld.l.64.ip	q0, a5, 0xfffffd20
42001077:	c94f543f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a4, q5, q2, q4, q7
4200107b:	0224403f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 0, q5, q0, q2, q4
4200107f:	a03c      	movi.n	a0, 58
42001081:	026c      	movi.n	a2, -32
42001083:	813c      	movi.n	a1, 56
42001085:	24          	.byte	0x24
42001086:	02          	.byte	0x2
42001087:	003c      	movi.n	a0, 48
42001089:	600070        	neg	a0, a7
4200108c:	248c      	beqz.n	a4, 42001092 <_stext+0x1072>
4200108e:	02          	.byte	0x2
4200108f:	843c      	movi.n	a4, 56
42001091:	026c      	movi.n	a2, -32
42001093:	593c      	movi.n	a9, 53
42001095:	002a      	add.n	a0, a0, a2
42001097:	32c700        	orbc	b12, b7, b0
4200109a:	00          	.byte	00
4200109b:	00          	.byte	00
4200109c:	6c6c      	movi.n	a12, -26
4200109e:	02          	.byte	0x2
4200109f:	543c      	movi.n	a4, 53
420010a1:	026c      	movi.n	a2, -32
420010a3:	c53c      	movi.n	a5, 60
420010a5:	000027        	bnone	a0, a2, 420010a9 <_stext+0x1089>
420010a8:	2468      	l32i.n	a6, a4, 8
420010aa:	3fc9      	s32i.n	a12, a15, 12
420010ac:	60          	.byte	0x60
420010ad:	24          	.byte	0x24
420010ae:	3fc9      	s32i.n	a12, a15, 12
420010b0:	c92464        	ee.vld.l.64.ip	q0, a6, 0xfffffd20
420010b3:	c9245c3f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a12, q5, q2, q2, q4
420010b7:	0224a03f 	ee.vmulas.s16.accx.ld.ip.qup	q4, a3, 0, q6, q4, q2, q4
420010bb:	a83c      	movi.n	a8, 58
420010bd:	24          	.byte	0x24
420010be:	02          	.byte	0x2
420010bf:	543c      	movi.n	a4, 53
420010c1:	403781        	l32r	a8, 41fd11a0 <_iram_bss_end+0x1c4eda0>
420010c4:	378890        	ee.stf.64.xp	f8, f3, a9, a8
420010c7:	40          	.byte	0x40
420010c8:	924c      	movi.n	a2, 73
420010ca:	d44037        	ball	a0, a3, 420010a2 <_stext+0x1082>
420010cd:	92          	.byte	0x92
420010ce:	a04037        	ball	a0, a3, 42001072 <_stext+0x1052>
420010d1:	8d          	.byte	0x8d
420010d2:	7c4037        	ball	a0, a3, 42001152 <_stext+0x1132>
420010d5:	82          	.byte	0x82
420010d6:	904037        	ball	a0, a3, 4200106a <_stext+0x104a>
420010d9:	600080        	neg	a0, a8
420010dc:	ff          	.byte	0xff
420010dd:	94fffdff 	ee.stf.128.ip	f9, f15, f15, f15, a15, -48
420010e1:	600080        	neg	a0, a8
420010e4:	34          	.byte	0x34
420010e5:	600080        	neg	a0, a8
420010e8:	801c      	movi.n	a0, 24
420010ea:	00          	.byte	00
420010eb:	c03f60        	sub	a3, a15, a6
420010ee:	802cffff 	ee.ldf.128.ip	f1, f9, f15, f2, a15, -16
420010f2:	00          	.byte	00
420010f3:	60          	.byte	0x60
420010f4:	ff          	.byte	0xff
420010f5:	00          	.byte	00
420010f6:	6c44ffff 	ee.vmulas.u8.accx.ld.ip.qup	q0, a15, -16, q7, q6, q4, q4
420010fa:	02          	.byte	0x2
420010fb:	243c      	movi.n	a4, 50
420010fd:	600080        	neg	a0, a8
42001100:	ff          	.byte	0xff
42001101:	ffff01        	l32r	a0, 42001100 <_stext+0x10e0> (ffff01ff <_rtc_reserved_end+0x9fef01ff>)
42001104:	fe00ffff 	ee.vmulas.s16.accx.ld.ip	q4, a15, -16, q7, q6
42001108:	008030        	any4	b3, b0:b1:b2:b3
4200110b:	802860        	add	a2, a8, a6
4200110e:	206000        	or	a6, a0, a0
42001111:	600080        	neg	a0, a8
42001114:	ff007fff 	ee.vmulas.s16.accx.ld.ip	q6, a15, -16, q5, q6
42001118:	412c      	movi.n	a1, 36
4200111a:	600c      	movi.n	a0, 6
4200111c:	60a8      	l32i.n	a10, a0, 24
4200111e:	086002        	s32i	a0, a0, 32
42001121:	40          	.byte	0x40
42001122:	600c      	movi.n	a0, 6
42001124:	4068      	l32i.n	a6, a0, 16
42001126:	600c      	movi.n	a0, 6
42001128:	30e8      	l32i.n	a14, a0, 12
4200112a:	00          	.byte	00
4200112b:	20e860        	or	a14, a8, a6
4200112e:	006000        	rsil	a0, 0
42001131:	600080        	neg	a0, a8
42001134:	ff          	.byte	0xff
42001135:	ff          	.byte	0xff
42001136:	fffb      	addi.n	a15, a15, 15
42001138:	ff          	.byte	0xff
42001139:	fffff7        	bbsi	a15, 31, 4200113c <_stext+0x111c>
4200113c:	8088      	l32i.n	a8, a0, 32
4200113e:	00          	.byte	00
4200113f:	60          	.byte	0x60
42001140:	ff          	.byte	0xff
42001141:	84fff7ff 	ee.ldf.128.ip	f9, f15, f15, f15, a15, 112
42001145:	600080        	neg	a0, a8
42001148:	0c0014        	ee.st.qacc_l.l.128.ip	a1, 0
4200114b:	60          	.byte	0x60
4200114c:	ff          	.byte	0xff
4200114d:	ff          	.byte	0xff
4200114e:	ef          	.byte	0xef
4200114f:	ff          	.byte	0xff
42001150:	cfffffff 	ee.vmulas.u8.qacc.ld.xp.qup	q7, a15, a15, q7, q7, q7, q7
42001154:	ff          	.byte	0xff
42001155:	ff          	.byte	0xff
42001156:	3f          	.byte	0x3f
42001157:	ff          	.byte	0xff
42001158:	ff          	.byte	0xff
42001159:	ef          	.byte	0xef
4200115a:	ff          	.byte	0xff
4200115b:	ff          	.byte	0xff
4200115c:	ff          	.byte	0xff
4200115d:	ff          	.byte	0xff
4200115e:	ff          	.byte	0xff
4200115f:	f3          	.byte	0xf3
42001160:	ff          	.byte	0xff
42001161:	ff          	.byte	0xff
42001162:	bf          	.byte	0xbf
42001163:	ff          	.byte	0xff
42001164:	ff          	.byte	0xff
42001165:	acfcffff 	ee.fft.cmul.s16.st.xp	q7, q7, q4, a15, a15, 7, 1, 2
42001169:	8d          	.byte	0x8d
4200116a:	004037        	ball	a0, a3, 4200116e <_stext+0x114e>
4200116d:	0088      	l32i.n	a8, a0, 0
4200116f:	60          	.byte	0x60
42001170:	9fffffff 	ee.stf.128.xp	f15, f15, f15, f15, a15, a15
42001174:	c0          	.byte	0xc0
42001175:	24          	.byte	0x24
42001176:	3fc9      	s32i.n	a12, a15, 12
42001178:	00          	.byte	00
42001179:	e0          	.byte	0xe0
4200117a:	2e30600f 	ee.vmulas.s8.accx.ld.ip.qup	q4, a0, 0xffffff00, q5, q4, q3, q0
4200117e:	02          	.byte	0x2
4200117f:	283c      	movi.n	a8, 50
42001181:	3b3c026f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a6, 0xfffffe20, q4, q0, q3, q4
42001185:	0009      	s32i.n	a0, a0, 0
42001187:	00          	.byte	00
42001188:	022df4        	ee.st.accx.ip	a15, 0x168
4200118b:	d43c      	movi.n	a4, 61
4200118d:	3c0263        	lsi	f6, a2, 240
42001190:	e0          	.byte	0xe0
42001191:	c94c      	movi.n	a9, 76
42001193:	37e3183f 	ee.vmulas.s8.qacc.ld.ip.qup	q6, a3, 0x180, q4, q3, q6, q3
42001197:	e49c40        	extui	a9, a4, 12, 15
4200119a:	cc4037        	ball	a0, a3, 4200116a <_stext+0x114a>
4200119d:	4037e4        	ee.ld.qacc_l.l.128.ip	a14, 0xfffffb70
420011a0:	e45c      	movi.n	a4, 94
420011a2:	f04037        	ball	a0, a3, 42001196 <_stext+0x1176>
420011a5:	4037e4        	ee.ld.qacc_l.l.128.ip	a14, 0xfffffb70
420011a8:	14          	.byte	0x14
420011a9:	4037e5        	call8	42041528 <_etext+0x27df2>
420011ac:	4f9c      	beqz.n	a15, 420011c4 <_stext+0x11a4>
420011ae:	3fc9      	s32i.n	a12, a15, 12
420011b0:	2eac      	beqz.n	a14, 420011d6 <_stext+0x11b6>
420011b2:	02          	.byte	0x2
420011b3:	b83c      	movi.n	a8, 59
420011b5:	043c022e 	ee.vmulas.s16.accx.ld.ip.qup	q1, a2, 0x120, q0, q0, q3, q4
420011b9:	8842018e 	ee.ldf.128.xp	f0, f4, f0, f4, a8, a1
420011bd:	000013        	lsi	f1, a0, 0
420011c0:	2ed8      	l32i.n	a13, a14, 8
420011c2:	02          	.byte	0x2
420011c3:	883c      	movi.n	a8, 56
420011c5:	6f          	.byte	0x6f
420011c6:	02          	.byte	0x2
420011c7:	f83c      	movi.n	a8, 63
420011c9:	203c022e 	ee.vmulas.s8.accx.ld.ip.qup	q1, a2, 32, q0, q0, q3, q4
420011cd:	403c022f 	ee.vmulas.u16.accx.ld.ip.qup	q1, a2, 32, q4, q0, q3, q4
420011d1:	6c3c022f 	ee.vmulas.u8.accx.ld.ip.qup	q1, a2, -224, q4, q0, q3, q4
420011d5:	37b9      	s32i.n	a11, a7, 12
420011d7:	40          	.byte	0x40
420011d8:	2f68      	l32i.n	a6, a15, 8
420011da:	02          	.byte	0x2
420011db:	183c      	movi.n	a8, 49
420011dd:	9842018e 	ee.stf.128.xp	f0, f4, f0, f4, a8, a1
420011e1:	943c020f 	ee.stf.128.ip	f9, f9, f0, f3, a0, 32
420011e5:	8a3c026f 	ee.ldf.128.xp	f5, f9, f0, f3, a6, a2
420011e9:	003c022f 	ee.vmulas.s16.accx.ld.ip.qup	q1, a2, 32, q4, q0, q3, q4
420011ed:	000000        	ill
420011f0:	37c6b0        	ee.stf.64.xp	f12, f3, a11, a6
420011f3:	40          	.byte	0x40
420011f4:	5278      	l32i.n	a7, a2, 20
420011f6:	3fc9      	s32i.n	a12, a15, 12
420011f8:	9f2c      	movi.n	a15, 41
420011fa:	004037        	ball	a0, a3, 420011fe <_stext+0x11de>
420011fd:	00          	.byte	00
420011fe:	90ffc0        	addx2	a15, a15, a12
42001201:	3c0217        	bnone	a2, a1, 42001241 <_stext+0x1221>
42001204:	68ac      	beqz.n	a8, 4200122e <_stext+0x120e>
42001206:	02          	.byte	0x2
42001207:	b23c      	movi.n	a2, 59
42001209:	3c0217        	bnone	a2, a1, 42001249 <_stext+0x1229>
4200120c:	fb18      	l32i.n	a1, a11, 60
4200120e:	484037        	ball	a0, a3, 4200125a <_stext+0x123a>
42001211:	420191        	l32r	a9, 41fd1a18 <_iram_bss_end+0x1c4f618>
42001214:	37e6a0        	ee.stf.64.xp	f14, f3, a10, a6
42001217:	40          	.byte	0x40
42001218:	37ebb0        	ee.stf.64.xp	f14, f3, a11, a11
4200121b:	e7ac40        	ee.stf.64.xp	f10, f14, a4, a12
4200121e:	c44037        	ball	a0, a3, 420011e6 <_stext+0x11c6>
42001221:	4037e6        	bgei	a7, 3, 42001265 <_stext+0x1245>
42001224:	ff          	.byte	0xff
42001225:	c0          	.byte	0xc0
42001226:	ff          	.byte	0xff
42001227:	8fffffff 	ee.ldf.128.xp	f15, f15, f15, f15, a15, a15
4200122b:	300000ff 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a15, 0, q4, q0, q0, q0
4200122f:	000000        	ill
42001232:	40          	.byte	0x40
42001233:	000000        	ill
42001236:	50          	.byte	0x50
42001237:	00          	.byte	00
42001238:	ff          	.byte	0xff
42001239:	3f          	.byte	0x3f
4200123a:	f0          	.byte	0xf0
4200123b:	7fffffff 	ee.vmulas.u8.qacc.ld.ip.qup	q7, a15, -16, q7, q7, q7, q7
4200123f:	17d080        	ee.stf.64.xp	f13, f1, a8, a0
42001242:	02          	.byte	0x2
42001243:	9c3c      	movi.n	a12, 57
42001245:	0269      	s32i.n	a6, a2, 0
42001247:	4f3c      	movi.n	a15, 52
42001249:	0218      	l32i.n	a1, a2, 0
4200124b:	583c      	movi.n	a8, 53
4200124d:	0218      	l32i.n	a1, a2, 0
4200124f:	9c3c      	movi.n	a12, 57
42001251:	0218      	l32i.n	a1, a2, 0
42001253:	a43c      	movi.n	a4, 58
42001255:	0218      	l32i.n	a1, a2, 0
42001257:	ac3c      	movi.n	a12, 58
42001259:	0218      	l32i.n	a1, a2, 0
4200125b:	e03c      	movi.n	a0, 62
4200125d:	420192        	l8ui	a9, a1, 66
42001260:	0218c4        	ee.st.accx.ip	a12, 192
42001263:	f03c      	movi.n	a0, 63
42001265:	0269      	s32i.n	a6, a2, 0
42001267:	f73c      	movi.n	a7, 63
42001269:	0218      	l32i.n	a1, a2, 0
4200126b:	103c      	movi.n	a0, 49
4200126d:	0219      	s32i.n	a1, a2, 0
4200126f:	443c      	movi.n	a4, 52
42001271:	0219      	s32i.n	a1, a2, 0
42001273:	843c      	movi.n	a4, 56
42001275:	0219      	s32i.n	a1, a2, 0
42001277:	d03c      	movi.n	a0, 61
42001279:	0269      	s32i.n	a6, a2, 0
4200127b:	cf3c      	movi.n	a15, 60
4200127d:	0219      	s32i.n	a1, a2, 0
4200127f:	e83c      	movi.n	a8, 62
42001281:	0219      	s32i.n	a1, a2, 0
42001283:	243c      	movi.n	a4, 50
42001285:	021a      	add.n	a0, a2, a1
42001287:	a03c      	movi.n	a0, 58
42001289:	021b      	addi.n	a0, a2, 1
4200128b:	903c      	movi.n	a0, 57
4200128d:	37fb      	addi.n	a3, a7, 15
4200128f:	40          	.byte	0x40
42001290:	fb68      	l32i.n	a6, a11, 60
42001292:	c84037        	ball	a0, a3, 4200125e <_stext+0x123e>
42001295:	37fb      	addi.n	a3, a7, 15
42001297:	535840        	max	a5, a8, a4
4200129a:	3fc9      	s32i.n	a12, a15, 12
4200129c:	51cc      	bnez.n	a1, 420012a5 <_stext+0x1285>
4200129e:	b04037        	ball	a0, a3, 42001252 <_stext+0x1232>
420012a1:	377a      	add.n	a3, a7, a7
420012a3:	843c40        	extui	a3, a4, 12, 9
420012a6:	02          	.byte	0x2
420012a7:	103c      	movi.n	a0, 49
420012a9:	c93a      	add.n	a12, a9, a3
420012ab:	c939e83f 	ee.vmulas.u8.accx.ld.xp.qup	q3, a3, a8, q7, q4, q3, q1
420012af:	c925c03f 	ee.vmulas.u8.accx.ld.xp.qup	q2, a3, a0, q7, q0, q2, q5
420012b3:	376c083f 	ee.vmulas.s8.qacc.ld.ip.qup	q7, a3, 0x180, q4, q0, q6, q4
420012b7:	848840        	extui	a8, a4, 8, 9
420012ba:	02          	.byte	0x2
420012bb:	3c          	.byte	0x3c

420012bc <esp_app_format_init_elf_sha256>:
 * can lead to a complete lock-up of the CPU.
 * For this reason we do a reading of esp_app_desc.app_elf_sha256 and convert to string while start up in esp_system_init_app_elf_sha256()
 * and keep it in the static app_elf_sha256_str variable.
 */
static void esp_app_format_init_elf_sha256(void)
{
420012bc:	004136        	entry	a1, 32
    if (*((int *)&app_elf_sha256_str) != 0) {
420012bf:	fb5881        	l32r	a8, 42000020 <_stext> (3fc94cc8 <app_elf_sha256_str>)
420012c2:	0888      	l32i.n	a8, a8, 0
420012c4:	04e856        	bnez	a8, 42001316 <esp_app_format_init_elf_sha256+0x5a>
    }
    // At -O2 optimization level, GCC optimizes out the copying of the first byte of the app_elf_sha256,
    // because it is zero at compile time, and only modified afterwards by esptool.
    // Casting to volatile disables the optimization.
    const volatile char* src = (const volatile char*)esp_app_desc.app_elf_sha256;
    for (size_t i = 0; i < sizeof(app_elf_sha256_str) / 2; ++i) {
420012c7:	0c0c      	movi.n	a12, 0
420012c9:	000f86        	j	4200130b <esp_app_format_init_elf_sha256+0x4f>
        char c = src[i];
420012cc:	fb5681        	l32r	a8, 42000024 <_stext+0x4> (3c0200b0 <esp_app_desc+0x90>)
420012cf:	8c8a      	add.n	a8, a12, a8
420012d1:	0020c0        	memw
420012d4:	000882        	l8ui	a8, a8, 0
420012d7:	748080        	extui	a8, a8, 0, 8
        for (size_t s = 0; s < 2; ++s) {
420012da:	090c      	movi.n	a9, 0
420012dc:	000986        	j	42001306 <esp_app_format_init_elf_sha256+0x4a>
420012df:	a48000        	extui	a8, a0, 0, 11
            char val = (c >> 4) & 0xF;
420012e2:	9b0c41        	l32r	a4, 41fe7f14 <_iram_bss_end+0x1c65b14>
            app_elf_sha256_str[2 * i + s] = (val < 10) ? ('0' + val) : ('a' + val - 10);
420012e5:	073ba7        	bltu	a11, a10, 420012f0 <esp_app_format_init_elf_sha256+0x34>
420012e8:	30caa2        	addi	a10, a10, 48
420012eb:	000106        	j	420012f3 <esp_app_format_init_elf_sha256+0x37>
420012ee:	a20000        	muluh	a0, a0, a0
420012f1:	57ca      	add.n	a5, a7, a12
420012f3:	90dc90        	addx2	a13, a12, a9
420012f6:	fb4ab1        	l32r	a11, 42000020 <_stext> (3fc94cc8 <app_elf_sha256_str>)
420012f9:	bbda      	add.n	a11, a11, a13
420012fb:	004ba2        	s8i	a10, a11, 0
            c <<= 4;
420012fe:	1188c0        	slli	a8, a8, 4
42001301:	748080        	extui	a8, a8, 0, 8
        for (size_t s = 0; s < 2; ++s) {
42001304:	991b      	addi.n	a9, a9, 1
42001306:	d629b6        	bltui	a9, 2, 420012e0 <esp_app_format_init_elf_sha256+0x24>
    for (size_t i = 0; i < sizeof(app_elf_sha256_str) / 2; ++i) {
42001309:	cc1b      	addi.n	a12, a12, 1
4200130b:	bd5cb6        	bltui	a12, 5, 420012cc <esp_app_format_init_elf_sha256+0x10>
        }
    }
    app_elf_sha256_str[sizeof(app_elf_sha256_str) - 1] = 0;
4200130e:	fb4481        	l32r	a8, 42000020 <_stext> (3fc94cc8 <app_elf_sha256_str>)
42001311:	090c      	movi.n	a9, 0
42001313:	094892        	s8i	a9, a8, 9
}
42001316:	f01d      	retw.n

42001318 <esp_app_get_elf_sha256>:

int esp_app_get_elf_sha256(char* dst, size_t size)
{
42001318:	004136        	entry	a1, 32
4200131b:	027d      	mov.n	a7, a2
    if (dst == NULL || size < 2) {
4200131d:	40f290        	nsau	a9, a2
42001320:	419590        	srli	a9, a9, 5
42001323:	180c      	movi.n	a8, 1
42001325:	628830        	saltu	a8, a8, a3
42001328:	880b      	addi.n	a8, a8, -1
4200132a:	608080        	neg	a8, a8
4200132d:	748080        	extui	a8, a8, 0, 8
42001330:	209980        	or	a9, a9, a8
42001333:	f9dc      	bnez.n	a9, 42001356 <esp_app_get_elf_sha256+0x3e>
        return 0;
    }
    esp_app_format_init_elf_sha256();
42001335:	fff865        	call8	420012bc <esp_app_format_init_elf_sha256>
    size_t n = MIN(size, sizeof(app_elf_sha256_str));
42001338:	a80c      	movi.n	a8, 10
4200133a:	632380        	minu	a2, a3, a8
    memcpy(dst, app_elf_sha256_str, n);
4200133d:	02cd      	mov.n	a12, a2
4200133f:	fb38b1        	l32r	a11, 42000020 <_stext> (3fc94cc8 <app_elf_sha256_str>)
42001342:	07ad      	mov.n	a10, a7
42001344:	fb3981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42001347:	0008e0        	callx8	a8
    dst[n - 1] = 0;
4200134a:	820b      	addi.n	a8, a2, -1
4200134c:	778a      	add.n	a7, a7, a8
4200134e:	080c      	movi.n	a8, 0
42001350:	004782        	s8i	a8, a7, 0
    return n;
42001353:	000046        	j	42001358 <esp_app_get_elf_sha256+0x40>
        return 0;
42001356:	020c      	movi.n	a2, 0
}
42001358:	f01d      	retw.n
	...

4200135c <__esp_system_init_fn_init_show_app_info>:

// startup function definition and execution does not exist on the Linux target
// (TODO: IDF-9950)
#if !CONFIG_IDF_TARGET_LINUX && !ESP_TEE_BUILD
ESP_SYSTEM_INIT_FN(init_show_app_info, CORE, BIT(0), 20)
{
4200135c:	008136        	entry	a1, 64
    // Load the current ELF SHA256
    esp_app_format_init_elf_sha256();
4200135f:	fff5e5        	call8	420012bc <esp_app_format_init_elf_sha256>
42001362:	fb3281        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001365:	0888      	l32i.n	a8, a8, 0

    // Display information about the current running image.
    if (LOG_LOCAL_LEVEL >= ESP_LOG_INFO) {
        ESP_EARLY_LOGI(TAG, "Application information:");
42001367:	1338b6        	bltui	a8, 3, 4200137e <__esp_system_init_fn_init_show_app_info+0x22>
4200136a:	fb3d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200136d:	0008e0        	callx8	a8
42001370:	fb30c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001373:	0abd      	mov.n	a11, a10
42001375:	fb2fa1        	l32r	a10, 42000034 <_stext+0x14> (3c02012c <_flash_rodata_start+0xc>)
42001378:	fb3b81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200137b:	0008e0        	callx8	a8
4200137e:	fb2b81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001381:	0888      	l32i.n	a8, a8, 0
#ifndef CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR
        ESP_EARLY_LOGI(TAG, "Project name:     %s", esp_app_desc.project_name);
42001383:	1638b6        	bltui	a8, 3, 4200139d <__esp_system_init_fn_init_show_app_info+0x41>
42001386:	fb3681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001389:	0008e0        	callx8	a8
4200138c:	fb2bd1        	l32r	a13, 42000038 <_stext+0x18> (3c020050 <esp_app_desc+0x30>)
4200138f:	fb28c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
42001392:	0abd      	mov.n	a11, a10
42001394:	fb2aa1        	l32r	a10, 4200003c <_stext+0x1c> (3c020154 <_flash_rodata_start+0x34>)
42001397:	fb3381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200139a:	0008e0        	callx8	a8
4200139d:	fb2381        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420013a0:	002882        	l32i	a8, a8, 0
#endif
#ifndef CONFIG_APP_EXCLUDE_PROJECT_VER_VAR
        ESP_EARLY_LOGI(TAG, "App version:      %s", esp_app_desc.version);
420013a3:	1638b6        	bltui	a8, 3, 420013bd <__esp_system_init_fn_init_show_app_info+0x61>
420013a6:	fb2e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420013a9:	0008e0        	callx8	a8
420013ac:	fb25d1        	l32r	a13, 42000040 <_stext+0x20> (3c020030 <esp_app_desc+0x10>)
420013af:	fb20c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
420013b2:	0abd      	mov.n	a11, a10
420013b4:	fb24a1        	l32r	a10, 42000044 <_stext+0x24> (3c020178 <_flash_rodata_start+0x58>)
420013b7:	fb2b81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420013ba:	0008e0        	callx8	a8
420013bd:	fb1b81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420013c0:	002882        	l32i	a8, a8, 0
#endif
#ifdef CONFIG_BOOTLOADER_APP_SECURE_VERSION
        ESP_EARLY_LOGI(TAG, "Secure version:   %" PRIu32, esp_app_desc.secure_version);
#endif
#ifdef CONFIG_APP_COMPILE_TIME_DATE
        ESP_EARLY_LOGI(TAG, "Compile time:     %s %s", esp_app_desc.date, esp_app_desc.time);
420013c3:	1938b6        	bltui	a8, 3, 420013e0 <__esp_system_init_fn_init_show_app_info+0x84>
420013c6:	fb2681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420013c9:	0008e0        	callx8	a8
420013cc:	fb1fe1        	l32r	a14, 42000048 <_stext+0x28> (3c020070 <esp_app_desc+0x50>)
420013cf:	fb1fd1        	l32r	a13, 4200004c <_stext+0x2c> (3c020080 <esp_app_desc+0x60>)
420013d2:	fb17c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
420013d5:	0abd      	mov.n	a11, a10
420013d7:	fb1ea1        	l32r	a10, 42000050 <_stext+0x30> (3c02019c <_flash_rodata_start+0x7c>)
420013da:	fb2281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420013dd:	0008e0        	callx8	a8
#endif
        char buf[17];
        esp_app_get_elf_sha256(buf, sizeof(buf));
420013e0:	1b1c      	movi.n	a11, 17
420013e2:	01ad      	mov.n	a10, a1
420013e4:	fff325        	call8	42001318 <esp_app_get_elf_sha256>
420013e7:	fb1181        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420013ea:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "ELF file SHA256:  %s...", buf);
420013ec:	1538b6        	bltui	a8, 3, 42001405 <__esp_system_init_fn_init_show_app_info+0xa9>
420013ef:	fb1c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420013f2:	0008e0        	callx8	a8
420013f5:	01dd      	mov.n	a13, a1
420013f7:	fb0ec1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
420013fa:	0abd      	mov.n	a11, a10
420013fc:	fb16a1        	l32r	a10, 42000054 <_stext+0x34> (3c0201c4 <_flash_rodata_start+0xa4>)
420013ff:	fb1981        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001402:	0008e0        	callx8	a8
42001405:	fb0981        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001408:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "ESP-IDF:          %s", esp_app_desc.idf_ver);
4200140b:	1638b6        	bltui	a8, 3, 42001425 <__esp_system_init_fn_init_show_app_info+0xc9>
4200140e:	fb1481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001411:	0008e0        	callx8	a8
42001414:	fb11d1        	l32r	a13, 42000058 <_stext+0x38> (3c020090 <esp_app_desc+0x70>)
42001417:	fb06c1        	l32r	a12, 42000030 <_stext+0x10> (3c020120 <_flash_rodata_start>)
4200141a:	0abd      	mov.n	a11, a10
4200141c:	fb10a1        	l32r	a10, 4200005c <_stext+0x3c> (3c0201ec <_flash_rodata_start+0xcc>)
4200141f:	fb1181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001422:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
42001425:	020c      	movi.n	a2, 0
42001427:	f01d      	retw.n
42001429:	000000        	ill

4200142c <__esp_system_init_fn_init_efuse_check>:
#endif

static __attribute__((unused)) const char *TAG = "efuse_init";

ESP_SYSTEM_INIT_FN(init_efuse_check, CORE, BIT(0), 1)
{
4200142c:	004136        	entry	a1, 32
    // (Only for C3): We check if the efuse BLOCK0 has certain coding errors then reset the chip.
    if (esp_efuse_check_errors() != ESP_OK) {
4200142f:	000da5        	call8	42001508 <esp_efuse_check_errors>
42001432:	4a8c      	beqz.n	a10, 4200143a <__esp_system_init_fn_init_efuse_check+0xe>
        esp_restart();
42001434:	201110        	or	a1, a1, a1
42001437:	0018a5        	call8	420015c0 <esp_restart>
    }
    return ESP_OK;
}
4200143a:	020c      	movi.n	a2, 0
4200143c:	f01d      	retw.n
	...

42001440 <__esp_system_init_fn_init_efuse_show_app_info>:

// It comes after init_show_app_info to print the consistent application information.
ESP_SYSTEM_INIT_FN(init_efuse_show_app_info, CORE, BIT(0), 21)
{
42001440:	004136        	entry	a1, 32
42001443:	fafa81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001446:	002882        	l32i	a8, a8, 0
    if (LOG_LOCAL_LEVEL >= ESP_LOG_INFO) {
        ESP_EARLY_LOGI(TAG, "Min chip rev:     v%d.%d", CONFIG_ESP_REV_MIN_FULL / 100, CONFIG_ESP_REV_MIN_FULL % 100);
42001449:	1738b6        	bltui	a8, 3, 42001464 <__esp_system_init_fn_init_efuse_show_app_info+0x24>
4200144c:	fb0581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200144f:	0008e0        	callx8	a8
42001452:	0e0c      	movi.n	a14, 0
42001454:	0edd      	mov.n	a13, a14
42001456:	fb06c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
42001459:	0abd      	mov.n	a11, a10
4200145b:	fb06a1        	l32r	a10, 42000074 <_stext+0x54> (3c020234 <_flash_rodata_start+0x114>)
4200145e:	fb0181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001461:	0008e0        	callx8	a8
42001464:	faf281        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001467:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "Max chip rev:     v%d.%d %s", CONFIG_ESP_REV_MAX_FULL / 100, CONFIG_ESP_REV_MAX_FULL % 100,
42001469:	3038b6        	bltui	a8, 3, 4200149d <__esp_system_init_fn_init_efuse_show_app_info+0x5d>
4200146c:	fafd81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200146f:	0008e0        	callx8	a8
42001472:	0a7d      	mov.n	a7, a10
42001474:	fb0481        	l32r	a8, 42000084 <_stext+0x64> (40375db0 <efuse_hal_get_disable_wafer_version_major>)
42001477:	0008e0        	callx8	a8
4200147a:	7a8c      	beqz.n	a10, 42001485 <__esp_system_init_fn_init_efuse_show_app_info+0x45>
4200147c:	fafbf1        	l32r	a15, 42000068 <_stext+0x48> (3c020210 <_flash_rodata_start+0xf0>)
4200147f:	000146        	j	42001488 <__esp_system_init_fn_init_efuse_show_app_info+0x48>
42001482:	000000        	ill
42001485:	faf9f1        	l32r	a15, 4200006c <_stext+0x4c> (3c020ee4 <_flash_rodata_start+0xdc4>)
42001488:	63a0e2        	movi	a14, 99
4200148b:	00a0d2        	movi	a13, 0
4200148e:	faf8c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
42001491:	20b770        	or	a11, a7, a7
42001494:	faf9a1        	l32r	a10, 42000078 <_stext+0x58> (3c02025c <_flash_rodata_start+0x13c>)
42001497:	faf381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200149a:	0008e0        	callx8	a8
                        efuse_hal_get_disable_wafer_version_major() ? "(constraint ignored)" : "");
        unsigned revision = efuse_hal_chip_revision();
4200149d:	fafa81        	l32r	a8, 42000088 <_stext+0x68> (40375d98 <efuse_hal_chip_revision>)
420014a0:	0008e0        	callx8	a8
420014a3:	0a7d      	mov.n	a7, a10
420014a5:	fae181        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420014a8:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGI(TAG, "Chip rev:         v%d.%d", revision / 100, revision % 100);
420014ab:	2938b6        	bltui	a8, 3, 420014d8 <__esp_system_init_fn_init_efuse_show_app_info+0x98>
420014ae:	faec81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420014b1:	0008e0        	callx8	a8
420014b4:	faf2d1        	l32r	a13, 4200007c <_stext+0x5c> (51eb851f <_rtc_bss_end+0x1eb851f>)
420014b7:	a2d7d0        	muluh	a13, a7, a13
420014ba:	41d5d0        	srli	a13, a13, 5
420014bd:	a0edd0        	addx4	a14, a13, a13
420014c0:	a0eee0        	addx4	a14, a14, a14
420014c3:	11eee0        	slli	a14, a14, 2
420014c6:	c0e7e0        	sub	a14, a7, a14
420014c9:	fae9c1        	l32r	a12, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
420014cc:	20baa0        	or	a11, a10, a10
420014cf:	faeca1        	l32r	a10, 42000080 <_stext+0x60> (3c020288 <_flash_rodata_start+0x168>)
420014d2:	fae481        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420014d5:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
420014d8:	020c      	movi.n	a2, 0
420014da:	f01d      	retw.n

420014dc <__esp_system_init_fn_init_efuse>:
    return ESP_OK;
}
#endif // ROM_LOG_MODE

ESP_SYSTEM_INIT_FN(init_efuse, CORE, BIT(0), 140)
{
420014dc:	006136        	entry	a1, 48

#ifdef CONFIG_EFUSE_VIRTUAL
    init_efuse_virtual();
#endif

    error = init_efuse_secure();
420014df:	14ff25        	call8	420164d0 <init_efuse_secure>
420014e2:	0a2d      	mov.n	a2, a10
    ESP_RETURN_ON_ERROR(error, TAG, "Failed in secure eFuse init");
420014e4:	ea9c      	beqz.n	a10, 42001506 <__esp_system_init_fn_init_efuse+0x2a>
420014e6:	fade81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420014e9:	0008e0        	callx8	a8
420014ec:	fae1b1        	l32r	a11, 42000070 <_stext+0x50> (3c020228 <_flash_rodata_start+0x108>)
420014ef:	a6a082        	movi	a8, 166
420014f2:	0189      	s32i.n	a8, a1, 0
420014f4:	fae6f1        	l32r	a15, 4200008c <_stext+0x6c> (3c0263b4 <__FUNCTION__$0>)
420014f7:	0bed      	mov.n	a14, a11
420014f9:	0add      	mov.n	a13, a10
420014fb:	fae5c1        	l32r	a12, 42000090 <_stext+0x70> (3c0202b0 <_flash_rodata_start+0x190>)
420014fe:	1a0c      	movi.n	a10, 1
42001500:	fae581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42001503:	0008e0        	callx8	a8
#ifdef ROM_LOG_MODE
    error = init_efuse_rom_log();
#endif

    return error;
}
42001506:	f01d      	retw.n

42001508 <esp_efuse_check_errors>:
    }
    return ESP_OK;
}

esp_err_t esp_efuse_check_errors(void)
{
42001508:	004136        	entry	a1, 32
    return esp_efuse_utility_check_errors();
4200150b:	14fd65        	call8	420164e0 <esp_efuse_utility_check_errors>
}
4200150e:	0a2d      	mov.n	a2, a10
42001510:	f01d      	retw.n
	...

42001514 <esp_timer_early_init>:
#include "esp_private/startup_internal.h"
#include "esp_timer_impl.h"
#include "sdkconfig.h"

esp_err_t esp_timer_early_init(void)
{
42001514:	004136        	entry	a1, 32
    esp_timer_impl_early_init();
42001517:	178325        	call8	42018d48 <esp_timer_impl_early_init>
#if CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    esp_timer_impl_init_system_time();
4200151a:	000165        	call8	42001530 <esp_timer_impl_init_system_time>
#endif
    return ESP_OK;
}
4200151d:	00a022        	movi	a2, 0
42001520:	000090        	retw
	...

42001524 <__esp_system_init_fn_esp_timer_init_nonos>:
 *
 * Another initialization function, esp_timer_init_nonos (which initializes ISR and task),
 * is called only if other code calls the esp_timer API.
 */
ESP_SYSTEM_INIT_FN(esp_timer_init_nonos, CORE, BIT(0), 101)
{
42001524:	004136        	entry	a1, 32
    return esp_timer_early_init();
42001527:	fffee5        	call8	42001514 <esp_timer_early_init>
}
4200152a:	0a2d      	mov.n	a2, a10
4200152c:	f01d      	retw.n
	...

42001530 <esp_timer_impl_init_system_time>:
{
42001530:	004136        	entry	a1, 32
    s_correction_us = esp_rtc_get_time_us() - g_startup_time - esp_timer_impl_get_time();
42001533:	fade81        	l32r	a8, 420000ac <_stext+0x8c> (40377e30 <esp_rtc_get_time_us>)
42001536:	0008e0        	callx8	a8
42001539:	fad791        	l32r	a9, 42000098 <_stext+0x78> (3fc94d08 <g_startup_time>)
4200153c:	0988      	l32i.n	a8, a9, 0
4200153e:	1998      	l32i.n	a9, a9, 4
42001540:	c06b90        	sub	a6, a11, a9
42001543:	01ba87        	bgeu	a10, a8, 42001548 <esp_timer_impl_init_system_time+0x18>
42001546:	660b      	addi.n	a6, a6, -1
42001548:	c07a80        	sub	a7, a10, a8
4200154b:	fad981        	l32r	a8, 420000b0 <_stext+0x90> (403751e8 <esp_timer_get_time>)
4200154e:	0008e0        	callx8	a8
42001551:	c066b0        	sub	a6, a6, a11
42001554:	01b7a7        	bgeu	a7, a10, 42001559 <esp_timer_impl_init_system_time+0x29>
42001557:	660b      	addi.n	a6, a6, -1
42001559:	c077a0        	sub	a7, a7, a10
4200155c:	fad081        	l32r	a8, 4200009c <_stext+0x7c> (3fc94cd8 <s_correction_us>)
4200155f:	0879      	s32i.n	a7, a8, 0
42001561:	016862        	s32i	a6, a8, 4
    esp_err_t err = esp_register_shutdown_handler(esp_sync_timekeeping_timers);
42001564:	facfa1        	l32r	a10, 420000a0 <_stext+0x80> (42019628 <esp_sync_timekeeping_timers>)
42001567:	000265        	call8	4200158c <esp_register_shutdown_handler>
4200156a:	0a7d      	mov.n	a7, a10
    if (err != ESP_OK) {
4200156c:	8a9c      	beqz.n	a10, 42001588 <esp_timer_impl_init_system_time+0x58>
        ESP_LOGW(TAG, "Register shutdown handler failed, err = 0x%x", err);
4200156e:	fabc81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001571:	0008e0        	callx8	a8
42001574:	faccb1        	l32r	a11, 420000a4 <_stext+0x84> (3c0202e4 <_flash_rodata_start+0x1c4>)
42001577:	07fd      	mov.n	a15, a7
42001579:	0bed      	mov.n	a14, a11
4200157b:	0add      	mov.n	a13, a10
4200157d:	facac1        	l32r	a12, 420000a8 <_stext+0x88> (3c0202f0 <_flash_rodata_start+0x1d0>)
42001580:	2a0c      	movi.n	a10, 2
42001582:	fac481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42001585:	0008e0        	callx8	a8
}
42001588:	f01d      	retw.n
	...

4200158c <esp_register_shutdown_handler>:
#define SHUTDOWN_HANDLERS_NO 5

static shutdown_handler_t shutdown_handlers[SHUTDOWN_HANDLERS_NO];

esp_err_t esp_register_shutdown_handler(shutdown_handler_t handler)
{
4200158c:	004136        	entry	a1, 32
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
4200158f:	080c      	movi.n	a8, 0
42001591:	0006c6        	j	420015b0 <esp_register_shutdown_handler+0x24>
        if (shutdown_handlers[i] == handler) {
42001594:	fac891        	l32r	a9, 420000b4 <_stext+0x94> (3fc94cec <shutdown_handlers>)
42001597:	a09890        	addx4	a9, a8, a9
4200159a:	0998      	l32i.n	a9, a9, 0
4200159c:	191927        	beq	a9, a2, 420015b9 <esp_register_shutdown_handler+0x2d>
            return ESP_ERR_INVALID_STATE;
        } else if (shutdown_handlers[i] == NULL) {
4200159f:	b9cc      	bnez.n	a9, 420015ae <esp_register_shutdown_handler+0x22>
            shutdown_handlers[i] = handler;
420015a1:	fac491        	l32r	a9, 420000b4 <_stext+0x94> (3fc94cec <shutdown_handlers>)
420015a4:	a08890        	addx4	a8, a8, a9
420015a7:	0829      	s32i.n	a2, a8, 0
            return ESP_OK;
420015a9:	020c      	movi.n	a2, 0
420015ab:	000346        	j	420015bc <esp_register_shutdown_handler+0x30>
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
420015ae:	881b      	addi.n	a8, a8, 1
420015b0:	e058a6        	blti	a8, 5, 42001594 <esp_register_shutdown_handler+0x8>
        }
    }
    return ESP_ERR_NO_MEM;
420015b3:	01a122        	movi	a2, 0x101
420015b6:	000086        	j	420015bc <esp_register_shutdown_handler+0x30>
            return ESP_ERR_INVALID_STATE;
420015b9:	03a122        	movi	a2, 0x103
}
420015bc:	f01d      	retw.n
	...

420015c0 <esp_restart>:
    }
    return ESP_ERR_INVALID_STATE;
}

void esp_restart(void)
{
420015c0:	004136        	entry	a1, 32
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
420015c3:	470c      	movi.n	a7, 4
420015c5:	000386        	j	420015d7 <esp_restart+0x17>
        if (shutdown_handlers[i]) {
420015c8:	fabb81        	l32r	a8, 420000b4 <_stext+0x94> (3fc94cec <shutdown_handlers>)
420015cb:	a08780        	addx4	a8, a7, a8
420015ce:	0888      	l32i.n	a8, a8, 0
420015d0:	188c      	beqz.n	a8, 420015d5 <esp_restart+0x15>
            shutdown_handlers[i]();
420015d2:	0008e0        	callx8	a8
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
420015d5:	770b      	addi.n	a7, a7, -1
420015d7:	fed7d6        	bgez	a7, 420015c8 <esp_restart+0x8>
#if ( ( CONFIG_FREERTOS_SMP ) && ( !CONFIG_FREERTOS_UNICORE ) )
    //Note: Scheduler suspension behavior changed in FreeRTOS SMP
    vTaskPreemptionDisable(NULL);
#else
    // Disable scheduler on this core.
    vTaskSuspendAll();
420015da:	fab781        	l32r	a8, 420000b8 <_stext+0x98> (4037b090 <vTaskSuspendAll>)
420015dd:	0008e0        	callx8	a8
#endif // #if ( ( CONFIG_FREERTOS_SMP ) && ( !CONFIG_FREERTOS_UNICORE ) )

    esp_restart_noos();
420015e0:	fab781        	l32r	a8, 420000bc <_stext+0x9c> (403757b8 <esp_restart_noos>)
420015e3:	0008e0        	callx8	a8
	...

420015e8 <do_global_ctors>:
{
420015e8:	004136        	entry	a1, 32
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
420015eb:	fab571        	l32r	a7, 420000c0 <_stext+0xa0> (3c0291f0 <__XT_EXCEPTION_DESCS_+0x4>)
420015ee:	0001c6        	j	420015f9 <do_global_ctors+0x11>
        (*p)();
420015f1:	0788      	l32i.n	a8, a7, 0
420015f3:	0008e0        	callx8	a8
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
420015f6:	fcc772        	addi	a7, a7, -4
420015f9:	fab281        	l32r	a8, 420000c4 <_stext+0xa4> (3c0291ec <__XT_EXCEPTION_DESCS_>)
420015fc:	f1b787        	bgeu	a7, a8, 420015f1 <do_global_ctors+0x9>
}
420015ff:	f01d      	retw.n
42001601:	000000        	ill

42001604 <do_system_init_fn>:
{
42001604:	004136        	entry	a1, 32
42001607:	03eb60        	rsr.prid	a6
4200160a:	046d60        	extui	a6, a6, 13, 1
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
4200160d:	faae71        	l32r	a7, 420000c8 <_stext+0xa8> (3c02921c <esp_system_init_fn_init_efuse_check>)
42001610:	000f06        	j	42001650 <do_system_init_fn+0x4c>
42001613:	178200        	ee.stf.64.xp	f8, f1, a0, a2
        if (p->stage == stage_num && (p->cores & BIT(core_id)) != 0) {
42001616:	03          	.byte	0x3
42001617:	339827        	bne	a8, a2, 4200164e <do_system_init_fn+0x4a>
4200161a:	021782        	l16ui	a8, a7, 4
4200161d:	2d5867        	bbc	a8, a6, 4200164e <do_system_init_fn+0x4a>
            esp_err_t err = (*(p->fn))();
42001620:	07a8      	l32i.n	a10, a7, 0
42001622:	000ae0        	callx8	a10
42001625:	0a5d      	mov.n	a5, a10
            if (err != ESP_OK) {
42001627:	3aac      	beqz.n	a10, 4200164e <do_system_init_fn+0x4a>
42001629:	fa8081        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200162c:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, "init function %p has failed (0x%x), aborting", p->fn, err);
4200162e:	689c      	beqz.n	a8, 42001648 <do_system_init_fn+0x44>
42001630:	fa8c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001633:	0008e0        	callx8	a8
42001636:	05ed      	mov.n	a14, a5
42001638:	07d8      	l32i.n	a13, a7, 0
4200163a:	faa4c1        	l32r	a12, 420000cc <_stext+0xac> (3c02032c <_flash_rodata_start+0x20c>)
4200163d:	0abd      	mov.n	a11, a10
4200163f:	faa4a1        	l32r	a10, 420000d0 <_stext+0xb0> (3c020338 <_flash_rodata_start+0x218>)
42001642:	fa8881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001645:	0008e0        	callx8	a8
                abort();
42001648:	faa581        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200164b:	0008e0        	callx8	a8
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
4200164e:	778b      	addi.n	a7, a7, 8
42001650:	faa181        	l32r	a8, 420000d4 <_stext+0xb4> (3c0292a4 <_esp_system_init_fn_array_end>)
42001653:	bd3787        	bltu	a7, a8, 42001614 <do_system_init_fn+0x10>
    s_system_inited[core_id] = true;
42001656:	faa081        	l32r	a8, 420000d8 <_stext+0xb8> (3fc94d04 <s_system_inited>)
42001659:	886a      	add.n	a8, a8, a6
4200165b:	190c      	movi.n	a9, 1
4200165d:	0020c0        	memw
42001660:	004892        	s8i	a9, a8, 0
}
42001663:	f01d      	retw.n
42001665:	000000        	ill

42001668 <do_core_init>:
}
#endif

static void do_core_init(void)
{
42001668:	004136        	entry	a1, 32
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_CORE);
4200166b:	0a0c      	movi.n	a10, 0
4200166d:	fff965        	call8	42001604 <do_system_init_fn>
}
42001670:	f01d      	retw.n
	...

42001674 <do_secondary_init>:

static void do_secondary_init(void)
{
42001674:	006136        	entry	a1, 48
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // The port layer transferred control to this function with other cores 'paused',
    // resume execution so that cores might execute component initialization functions.
    startup_resume_other_cores();
42001677:	0024e5        	call8	420018c4 <startup_resume_other_cores>
#endif

    // Execute initialization functions esp_system_init_fn_t assigned to the main core. While
    // this is happening, all other cores are executing the initialization functions
    // assigned to them since they have been resumed already.
    do_system_init_fn(ESP_SYSTEM_INIT_STAGE_SECONDARY);
4200167a:	01a0a2        	movi	a10, 1
4200167d:	fff865        	call8	42001604 <do_system_init_fn>

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    // Wait for all cores to finish secondary init.
    volatile bool system_inited = false;
42001680:	00a082        	movi	a8, 0
42001683:	0020c0        	memw
42001686:	004182        	s8i	a8, a1, 0

    while (!system_inited) {
42001689:	000dc6        	j	420016c4 <do_secondary_init+0x50>
        system_inited = true;
4200168c:	180c      	movi.n	a8, 1
4200168e:	0020c0        	memw
42001691:	004182        	s8i	a8, a1, 0
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
42001694:	090c      	movi.n	a9, 0
42001696:	000786        	j	420016b8 <do_secondary_init+0x44>
            system_inited &= s_system_inited[i];
42001699:	fa8f81        	l32r	a8, 420000d8 <_stext+0xb8> (3fc94d04 <s_system_inited>)
4200169c:	889a      	add.n	a8, a8, a9
4200169e:	0020c0        	memw
420016a1:	0008a2        	l8ui	a10, a8, 0
420016a4:	0020c0        	memw
420016a7:	000182        	l8ui	a8, a1, 0
420016aa:	748080        	extui	a8, a8, 0, 8
420016ad:	1088a0        	and	a8, a8, a10
420016b0:	0020c0        	memw
420016b3:	004182        	s8i	a8, a1, 0
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420016b6:	991b      	addi.n	a9, a9, 1
420016b8:	dd29a6        	blti	a9, 2, 42001699 <do_secondary_init+0x25>
        }
        esp_rom_delay_us(100);
420016bb:	64a0a2        	movi	a10, 100
420016be:	fa8881        	l32r	a8, 420000e0 <_stext+0xc0> (40000600 <esp_rom_delay_us>)
420016c1:	0008e0        	callx8	a8
    while (!system_inited) {
420016c4:	0020c0        	memw
420016c7:	000182        	l8ui	a8, a1, 0
420016ca:	748080        	extui	a8, a8, 0, 8
420016cd:	fbb816        	beqz	a8, 4200168c <do_secondary_init+0x18>
    }
#endif
}
420016d0:	f01d      	retw.n
	...

420016d4 <start_cpu0>:

static void start_cpu0_default(void)
{
420016d4:	004136        	entry	a1, 32
    // Initialize core components and services.
    do_core_init();
420016d7:	fff925        	call8	42001668 <do_core_init>

    // Execute constructors.
    do_global_ctors();
420016da:	fff0e5        	call8	420015e8 <do_global_ctors>

    // Execute init functions of other components; blocks
    // until all cores finish (when !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE).
    do_secondary_init();
420016dd:	fff965        	call8	42001674 <do_secondary_init>

#if SOC_CPU_CORES_NUM > 1 && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_system_full_inited = true;
420016e0:	fa8181        	l32r	a8, 420000e4 <_stext+0xc4> (3fc94d00 <s_system_full_inited>)
420016e3:	190c      	movi.n	a9, 1
420016e5:	0020c0        	memw
420016e8:	004892        	s8i	a9, a8, 0
#endif

    esp_startup_start_app();
420016eb:	177fa5        	call8	42018ee4 <esp_startup_start_app>

    ESP_INFINITE_LOOP();
420016ee:	ffff06        	j	420016ee <start_cpu0+0x1a>
420016f1:	000000        	ill

420016f4 <__esp_system_init_fn_init_show_cpu_freq>:
}

// [refactor-todo] Most of these init functions should be moved to the respective components.

ESP_SYSTEM_INIT_FN(init_show_cpu_freq, CORE, BIT(0), 10)
{
420016f4:	004136        	entry	a1, 32
420016f7:	fa4d81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420016fa:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "Pro cpu start user code");
420016fc:	1438b6        	bltui	a8, 3, 42001714 <__esp_system_init_fn_init_show_cpu_freq+0x20>
420016ff:	fa5881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001702:	0008e0        	callx8	a8
42001705:	fa78c1        	l32r	a12, 420000e8 <_stext+0xc8> (3c02032c <_flash_rodata_start+0x20c>)
42001708:	20baa0        	or	a11, a10, a10
4200170b:	fa78a1        	l32r	a10, 420000ec <_stext+0xcc> (3c020374 <_flash_rodata_start+0x254>)
4200170e:	fa5581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001711:	0008e0        	callx8	a8
    int cpu_freq = esp_clk_cpu_freq();
42001714:	fa7881        	l32r	a8, 420000f4 <_stext+0xd4> (40376414 <esp_clk_cpu_freq>)
42001717:	0008e0        	callx8	a8
4200171a:	0a7d      	mov.n	a7, a10
4200171c:	fa4481        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200171f:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "cpu freq: %d Hz", cpu_freq);
42001721:	1538b6        	bltui	a8, 3, 4200173a <__esp_system_init_fn_init_show_cpu_freq+0x46>
42001724:	fa4f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001727:	0008e0        	callx8	a8
4200172a:	07dd      	mov.n	a13, a7
4200172c:	fa6fc1        	l32r	a12, 420000e8 <_stext+0xc8> (3c02032c <_flash_rodata_start+0x20c>)
4200172f:	0abd      	mov.n	a11, a10
42001731:	fa6fa1        	l32r	a10, 420000f0 <_stext+0xd0> (3c02039c <_flash_rodata_start+0x27c>)
42001734:	fa4c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001737:	0008e0        	callx8	a8

    return ESP_OK;
}
4200173a:	020c      	movi.n	a2, 0
4200173c:	f01d      	retw.n
	...

42001740 <__esp_system_init_fn_init_brownout>:
 * It is protected from all REE accesses through memory protection mechanisms,
 * as it is a critical module for device functioning.
 */
#if !CONFIG_SECURE_ENABLE_TEE
ESP_SYSTEM_INIT_FN(init_brownout, CORE, BIT(0), 104)
{
42001740:	004136        	entry	a1, 32
    // malloc (newlib) -> heap_caps_malloc (heap), so heap must be at least initialized
    esp_err_t ret = ESP_OK;
    // BOD and VBAT share the same interrupt number. To avoid blocking the system in an intermediate state
    // where an interrupt occurs and the interrupt number is enabled, but the ISR is not configured, enable
    // the interrupt after configuring both ISRs.
    portDISABLE_INTERRUPTS();
42001743:	006380        	rsil	a8, 3
#if CONFIG_ESP_BROWNOUT_DET
    esp_brownout_init();
42001746:	027425        	call8	42003e88 <esp_brownout_init>
#endif // CONFIG_ESP_BROWNOUT_DET

#if CONFIG_ESP_VBAT_INIT_AUTO
    ret = esp_vbat_init();
#endif
    portENABLE_INTERRUPTS();
42001749:	006080        	rsil	a8, 0
    return ret;
}
4200174c:	020c      	movi.n	a2, 0
4200174e:	f01d      	retw.n

42001750 <__esp_system_init_fn_init_newlib_time>:
#endif

ESP_SYSTEM_INIT_FN(init_newlib_time, CORE, BIT(0), 105)
{
42001750:	004136        	entry	a1, 32
    esp_libc_time_init();
42001753:	049da5        	call8	4200612c <esp_libc_time_init>
    return ESP_OK;
}
42001756:	020c      	movi.n	a2, 0
42001758:	f01d      	retw.n
	...

4200175c <__esp_system_init_fn_init_flash>:

#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
ESP_SYSTEM_INIT_FN(init_flash, CORE, BIT(0), 130)
{
4200175c:	004136        	entry	a1, 32
#if CONFIG_SPI_FLASH_ROM_IMPL
    spi_flash_rom_impl_init();
#endif

    esp_flash_app_init();
4200175f:	09afa5        	call8	4200b258 <esp_flash_app_init>
    esp_err_t flash_ret = esp_flash_init_default_chip();
42001762:	201110        	or	a1, a1, a1
42001765:	099c25        	call8	4200b128 <esp_flash_init_default_chip>
    assert(flash_ret == ESP_OK);
42001768:	011a16        	beqz	a10, 4200177d <__esp_system_init_fn_init_flash+0x21>
4200176b:	fa63d1        	l32r	a13, 420000f8 <_stext+0xd8> (3c0203bc <_flash_rodata_start+0x29c>)
4200176e:	fa63c1        	l32r	a12, 420000fc <_stext+0xdc> (3c0263e4 <__func__$0>)
42001771:	76a0b2        	movi	a11, 118
42001774:	fa63a1        	l32r	a10, 42000100 <_stext+0xe0> (3c0203ec <_flash_rodata_start+0x2cc>)
42001777:	fa6481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200177a:	0008e0        	callx8	a8
    (void)flash_ret;
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    spi_flash_needs_reset_check();
4200177d:	fa6381        	l32r	a8, 4200010c <_stext+0xec> (40380290 <spi_flash_needs_reset_check>)
42001780:	0008e0        	callx8	a8
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    // The log library will call the registered callback function to check if the cache is disabled.
    esp_log_util_set_cache_enabled_cb(spi_flash_cache_enabled);
42001783:	fa60a1        	l32r	a10, 42000104 <_stext+0xe4> (403779b4 <spi_flash_cache_enabled>)
42001786:	fa6281        	l32r	a8, 42000110 <_stext+0xf0> (4037fc60 <esp_log_util_set_cache_enabled_cb>)
42001789:	0008e0        	callx8	a8
    return ESP_OK;
}
4200178c:	020c      	movi.n	a2, 0
4200178e:	f01d      	retw.n

42001790 <__esp_system_init_fn_init_apb_dma>:
}
#endif // CONFIG_PM_ENABLE

#if SOC_APB_BACKUP_DMA
ESP_SYSTEM_INIT_FN(init_apb_dma, SECONDARY, BIT(0), 203)
{
42001790:	004136        	entry	a1, 32
    extern void esp_apb_backup_dma_lock_init(void);
    esp_apb_backup_dma_lock_init();
42001793:	006a65        	call8	42001e38 <esp_apb_backup_dma_lock_init>
    return ESP_OK;
}
42001796:	020c      	movi.n	a2, 0
42001798:	f01d      	retw.n
	...

4200179c <__esp_system_init_fn_init_disable_rtc_wdt>:
}
#endif // CONFIG_SW_COEXIST_ENABLE || CONFIG_EXTERNAL_COEX_ENABLE

#ifndef CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE
ESP_SYSTEM_INIT_FN(init_disable_rtc_wdt, SECONDARY, BIT(0), 999)
{
4200179c:	006136        	entry	a1, 48
    wdt_hal_context_t rtc_wdt_ctx = RWDT_HAL_CONTEXT_DEFAULT();
4200179f:	020c      	movi.n	a2, 0
420017a1:	0129      	s32i.n	a2, a1, 0
420017a3:	fa5c81        	l32r	a8, 42000114 <_stext+0xf4> (60008000 <RTCCNTL>)
420017a6:	1189      	s32i.n	a8, a1, 4
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
420017a8:	01ad      	mov.n	a10, a1
420017aa:	fa5b81        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
420017ad:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
420017b0:	01ad      	mov.n	a10, a1
420017b2:	fa5a81        	l32r	a8, 4200011c <_stext+0xfc> (40000e04 <wdt_hal_disable>)
420017b5:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420017b8:	01ad      	mov.n	a10, a1
420017ba:	fa5981        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
420017bd:	0008e0        	callx8	a8
    return ESP_OK;
}
420017c0:	f01d      	retw.n
	...

420017c4 <core_intr_matrix_clear>:
{
420017c4:	004136        	entry	a1, 32
420017c7:	03eb60        	rsr.prid	a6
420017ca:	046d60        	extui	a6, a6, 13, 1
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
420017cd:	070c      	movi.n	a7, 0
420017cf:	000346        	j	420017e0 <core_intr_matrix_clear+0x1c>
        esp_rom_route_intr_matrix(core_id, i, ETS_INVALID_INUM);
420017d2:	6c0c      	movi.n	a12, 6
420017d4:	07bd      	mov.n	a11, a7
420017d6:	06ad      	mov.n	a10, a6
420017d8:	fa5381        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
420017db:	0008e0        	callx8	a8
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
420017de:	771b      	addi.n	a7, a7, 1
420017e0:	62a082        	movi	a8, 98
420017e3:	eba877        	bge	a8, a7, 420017d2 <core_intr_matrix_clear+0xe>
}
420017e6:	f01d      	retw.n

420017e8 <start_other_core>:
{
420017e8:	006136        	entry	a1, 48
    esp_chip_info(&chip_info);
420017eb:	01ad      	mov.n	a10, a1
420017ed:	026e65        	call8	42003ed4 <esp_chip_info>
    if (!(chip_info.cores > 1)) {
420017f0:	0a0182        	l8ui	a8, a1, 10
420017f3:	3f28f6        	bgeui	a8, 2, 42001836 <start_other_core+0x4e>
420017f6:	fa0d81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420017f9:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Running on single core variant of a chip, but app is built with multi-core support.");
420017fc:	014816        	beqz	a8, 42001814 <start_other_core+0x2c>
420017ff:	fa1881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001802:	0008e0        	callx8	a8
42001805:	fa48c1        	l32r	a12, 42000128 <_stext+0x108> (3c02032c <_flash_rodata_start+0x20c>)
42001808:	20baa0        	or	a11, a10, a10
4200180b:	fa48a1        	l32r	a10, 4200012c <_stext+0x10c> (3c0203fc <_flash_rodata_start+0x2dc>)
4200180e:	fa1581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001811:	0008e0        	callx8	a8
42001814:	fa0681        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001817:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Check that CONFIG_FREERTOS_UNICORE is enabled in menuconfig");
42001819:	389c      	beqz.n	a8, 42001830 <start_other_core+0x48>
4200181b:	fa1181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200181e:	0008e0        	callx8	a8
42001821:	fa41c1        	l32r	a12, 42000128 <_stext+0x108> (3c02032c <_flash_rodata_start+0x20c>)
42001824:	20baa0        	or	a11, a10, a10
42001827:	fa42a1        	l32r	a10, 42000130 <_stext+0x110> (3c020460 <_flash_rodata_start+0x340>)
4200182a:	fa0e81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200182d:	0008e0        	callx8	a8
        abort();
42001830:	fa2b81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42001833:	0008e0        	callx8	a8
    esp_cpu_unstall(1);
42001836:	1a0c      	movi.n	a10, 1
42001838:	fa4281        	l32r	a8, 42000140 <_stext+0x120> (40377db0 <esp_cpu_unstall>)
4200183b:	0008e0        	callx8	a8
    }
}

FORCE_INLINE_ATTR void cpu_utility_ll_enable_clock_and_reset_app_cpu(void)
{
    if (!REG_GET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN)) {
4200183e:	fa3d81        	l32r	a8, 42000134 <_stext+0x114> (600c0000 <SYSTEM>)
42001841:	0020c0        	memw
42001844:	0888      	l32i.n	a8, a8, 0
42001846:	3ee817        	bbsi	a8, 1, 42001888 <start_other_core+0xa0>
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN);
42001849:	fa3a81        	l32r	a8, 42000134 <_stext+0x114> (600c0000 <SYSTEM>)
4200184c:	0020c0        	memw
4200184f:	0898      	l32i.n	a9, a8, 0
42001851:	2a0c      	movi.n	a10, 2
42001853:	2099a0        	or	a9, a9, a10
42001856:	0020c0        	memw
42001859:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RUNSTALL);
4200185b:	0020c0        	memw
4200185e:	0898      	l32i.n	a9, a8, 0
42001860:	ea7c      	movi.n	a10, -2
42001862:	1099a0        	and	a9, a9, a10
42001865:	0020c0        	memw
42001868:	0899      	s32i.n	a9, a8, 0
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
4200186a:	0020c0        	memw
4200186d:	0898      	l32i.n	a9, a8, 0
4200186f:	4a0c      	movi.n	a10, 4
42001871:	2099a0        	or	a9, a9, a10
42001874:	0020c0        	memw
42001877:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
42001879:	0020c0        	memw
4200187c:	0898      	l32i.n	a9, a8, 0
4200187e:	ba7c      	movi.n	a10, -5
42001880:	1099a0        	and	a9, a9, a10
42001883:	0020c0        	memw
42001886:	0899      	s32i.n	a9, a8, 0
    ets_set_appcpu_boot_addr((uint32_t)call_start_cpu1);
42001888:	fa2ca1        	l32r	a10, 42000138 <_stext+0x118> (40375230 <call_start_cpu1>)
4200188b:	fa2e81        	l32r	a8, 42000144 <_stext+0x124> (40000720 <ets_set_appcpu_boot_addr>)
4200188e:	0008e0        	callx8	a8
    bool cpus_up = false;
42001891:	070c      	movi.n	a7, 0
    while (!cpus_up) {
42001893:	000946        	j	420018bc <start_other_core+0xd4>
42001896:	910000        	srl	a0, a0
            cpus_up &= s_cpu_up[i];
42001899:	fa29      	s32i.n	a2, a10, 60
4200189b:	998a      	add.n	a9, a9, a8
4200189d:	0020c0        	memw
420018a0:	000992        	l8ui	a9, a9, 0
420018a3:	107790        	and	a7, a7, a9
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420018a6:	881b      	addi.n	a8, a8, 1
420018a8:	000106        	j	420018b0 <start_other_core+0xc8>
420018ab:	080c00        	lsx	f0, a12, a0
        cpus_up = true;
420018ae:	170c      	movi.n	a7, 1
        for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420018b0:	e428a6        	blti	a8, 2, 42001898 <start_other_core+0xb0>
        esp_rom_delay_us(100);
420018b3:	64a0a2        	movi	a10, 100
420018b6:	fa0a81        	l32r	a8, 420000e0 <_stext+0xc0> (40000600 <esp_rom_delay_us>)
420018b9:	0008e0        	callx8	a8
    while (!cpus_up) {
420018bc:	fec716        	beqz	a7, 420018ac <start_other_core+0xc4>
}
420018bf:	f01d      	retw.n
420018c1:	000000        	ill

420018c4 <startup_resume_other_cores>:
{
420018c4:	004136        	entry	a1, 32
    s_resume_cores = true;
420018c7:	fa2081        	l32r	a8, 42000148 <_stext+0x128> (3fc94d10 <s_resume_cores>)
420018ca:	190c      	movi.n	a9, 1
420018cc:	0020c0        	memw
420018cf:	004892        	s8i	a9, a8, 0
}
420018d2:	f01d      	retw.n

420018d4 <select_rtc_slow_clk>:
{
420018d4:	004136        	entry	a1, 32
    soc_rtc_slow_clk_src_t rtc_slow_clk_src = slow_clk & RTC_CNTL_ANA_CLK_RTC_SEL_V;
420018d7:	146020        	extui	a6, a2, 0, 2
    int retry_32k_xtal = RTC_XTAL_CAL_RETRY;
420018da:	150c      	movi.n	a5, 1
        if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
420018dc:	511666        	bnei	a6, 1, 42001931 <select_rtc_slow_clk+0x5d>
            if (slow_clk == SLOW_CLK_32K_XTAL) {
420018df:	0b1266        	bnei	a2, 1, 420018ee <select_rtc_slow_clk+0x1a>
                rtc_clk_32k_enable(true);
420018e2:	1a0c      	movi.n	a10, 1
420018e4:	fa1c81        	l32r	a8, 42000154 <_stext+0x134> (40378544 <rtc_clk_32k_enable>)
420018e7:	0008e0        	callx8	a8
420018ea:	0002c6        	j	420018f9 <select_rtc_slow_clk+0x25>
420018ed:	00          	.byte	00
            } else if (slow_clk == SLOW_CLK_32K_EXT_OSC) {
420018ee:	980c      	movi.n	a8, 9
420018f0:	059287        	bne	a2, a8, 420018f9 <select_rtc_slow_clk+0x25>
                rtc_clk_32k_enable_external();
420018f3:	fa1981        	l32r	a8, 42000158 <_stext+0x138> (40378634 <rtc_clk_32k_enable_external>)
420018f6:	0008e0        	callx8	a8
                cal_val = rtc_clk_cal(RTC_CAL_32K_XTAL, SLOW_CLK_CAL_CYCLES);
420018f9:	00a4b2        	movi	a11, 0x400
420018fc:	02a0a2        	movi	a10, 2
420018ff:	fa1781        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42001902:	0008e0        	callx8	a8
42001905:	0a7d      	mov.n	a7, a10
                if (cal_val == 0) {
42001907:	eafc      	bnez.n	a10, 42001949 <select_rtc_slow_clk+0x75>
                    if (retry_32k_xtal-- > 0) {
42001909:	450b      	addi.n	a4, a5, -1
4200190b:	6315e6        	bgei	a5, 1, 42001972 <select_rtc_slow_clk+0x9e>
4200190e:	f9c781        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42001911:	0888      	l32i.n	a8, a8, 0
                    ESP_EARLY_LOGW(TAG, "32 kHz XTAL not found, switching to internal 150 kHz oscillator");
42001913:	2e28b6        	bltui	a8, 2, 42001945 <select_rtc_slow_clk+0x71>
42001916:	f9d281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42001919:	0008e0        	callx8	a8
4200191c:	fa0cc1        	l32r	a12, 4200014c <_stext+0x12c> (3c020624 <_flash_rodata_start+0x504>)
4200191f:	0abd      	mov.n	a11, a10
42001921:	fa0ba1        	l32r	a10, 42000150 <_stext+0x130> (3c020628 <_flash_rodata_start+0x508>)
42001924:	f9d081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42001927:	0008e0        	callx8	a8
                    if (retry_32k_xtal-- > 0) {
4200192a:	045d      	mov.n	a5, a4
                    rtc_slow_clk_src = SOC_RTC_SLOW_CLK_SRC_RC_SLOW;
4200192c:	076d      	mov.n	a6, a7
4200192e:	0005c6        	j	42001949 <select_rtc_slow_clk+0x75>
        } else if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42001931:	142666        	bnei	a6, 2, 42001949 <select_rtc_slow_clk+0x75>
            rtc_clk_8m_enable(true, true);
42001934:	01a0b2        	movi	a11, 1
42001937:	20abb0        	or	a10, a11, a11
4200193a:	fa0981        	l32r	a8, 42000160 <_stext+0x140> (403786d8 <rtc_clk_8m_enable>)
4200193d:	0008e0        	callx8	a8
42001940:	000146        	j	42001949 <select_rtc_slow_clk+0x75>
42001943:	00          	.byte	00
42001944:	045d00        	extui	a5, a0, 13, 1
                    rtc_slow_clk_src = SOC_RTC_SLOW_CLK_SRC_RC_SLOW;
42001947:	0a6d      	mov.n	a6, a10
        rtc_clk_slow_src_set(rtc_slow_clk_src);
42001949:	06ad      	mov.n	a10, a6
4200194b:	fa0681        	l32r	a8, 42000164 <_stext+0x144> (40378794 <rtc_clk_slow_src_set>)
4200194e:	0008e0        	callx8	a8
        if (rtc_slow_clk_src != SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
42001951:	0d1626        	beqi	a6, 1, 42001962 <select_rtc_slow_clk+0x8e>
            rtc_clk_32k_enable(false);
42001954:	0a0c      	movi.n	a10, 0
42001956:	f9ff81        	l32r	a8, 42000154 <_stext+0x134> (40378544 <rtc_clk_32k_enable>)
42001959:	0008e0        	callx8	a8
            rtc_clk_32k_disable_external();
4200195c:	fa0381        	l32r	a8, 42000168 <_stext+0x148> (40378688 <rtc_clk_32k_disable_external>)
4200195f:	0008e0        	callx8	a8
            cal_val = rtc_clk_cal(RTC_CAL_RTC_MUX, SLOW_CLK_CAL_CYCLES);
42001962:	00a4b2        	movi	a11, 0x400
42001965:	0a0c      	movi.n	a10, 0
42001967:	f9fd81        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
4200196a:	0008e0        	callx8	a8
4200196d:	0a7d      	mov.n	a7, a10
4200196f:	000046        	j	42001974 <select_rtc_slow_clk+0xa0>
                    if (retry_32k_xtal-- > 0) {
42001972:	045d      	mov.n	a5, a4
    } while (cal_val == 0);
42001974:	f64716        	beqz	a7, 420018dc <select_rtc_slow_clk+0x8>
    esp_clk_slowclk_cal_set(cal_val);
42001977:	20a770        	or	a10, a7, a7
4200197a:	f9fc81        	l32r	a8, 4200016c <_stext+0x14c> (40377e20 <esp_clk_slowclk_cal_set>)
4200197d:	0008e0        	callx8	a8
}
42001980:	f01d      	retw.n
	...

42001984 <esp_rtc_init>:
{
42001984:	004136        	entry	a1, 32
    recalib_bbpll();
42001987:	f9fc81        	l32r	a8, 42000178 <_stext+0x158> (403756d4 <recalib_bbpll>)
4200198a:	0008e0        	callx8	a8
    rtc_config_t cfg = RTC_CONFIG_DEFAULT();
4200198d:	f9f881        	l32r	a8, 42000170 <_stext+0x150> (3c02641c <__func__$0+0x38>)
42001990:	002872        	l32i	a7, a8, 0
    rst_reas = esp_rom_get_reset_reason(0);
42001993:	00a0a2        	movi	a10, 0
42001996:	f9f981        	l32r	a8, 4200017c <_stext+0x15c> (4000057c <esp_rom_get_reset_reason>)
42001999:	0008e0        	callx8	a8
    if (rst_reas == RESET_REASON_CHIP_POWER_ON) {
4200199c:	051a66        	bnei	a10, 1, 420019a5 <esp_rtc_init+0x21>
        cfg.cali_ocode = 1;
4200199f:	f9f581        	l32r	a8, 42000174 <_stext+0x154> (40000000 <_heap_end>)
420019a2:	207780        	or	a7, a7, a8
    rtc_init(cfg);
420019a5:	07ad      	mov.n	a10, a7
420019a7:	16d365        	call8	420186dc <rtc_init>
}
420019aa:	f01d      	retw.n

420019ac <esp_clk_init>:
{
420019ac:	00a136        	entry	a1, 80
    assert(rtc_clk_xtal_freq_get() == SOC_XTAL_FREQ_40M);
420019af:	f9f981        	l32r	a8, 42000194 <_stext+0x174> (4037892c <rtc_clk_xtal_freq_get>)
420019b2:	0008e0        	callx8	a8
420019b5:	d8caa2        	addi	a10, a10, -40
420019b8:	010a16        	beqz	a10, 420019cc <esp_clk_init+0x20>
420019bb:	f9f1d1        	l32r	a13, 42000180 <_stext+0x160> (3c020678 <_flash_rodata_start+0x558>)
420019be:	f9f1c1        	l32r	a12, 42000184 <_stext+0x164> (3c026420 <__func__$0>)
420019c1:	fb4c      	movi.n	a11, 79
420019c3:	f9f1a1        	l32r	a10, 42000188 <_stext+0x168> (3c0206d5 <_flash_rodata_start+0x5b5>)
420019c6:	f9d081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420019c9:	0008e0        	callx8	a8
    bool rc_fast_d256_is_enabled = rtc_clk_8md256_enabled();
420019cc:	f9f381        	l32r	a8, 42000198 <_stext+0x178> (40378778 <rtc_clk_8md256_enabled>)
420019cf:	0008e0        	callx8	a8
    rtc_clk_8m_enable(true, rc_fast_d256_is_enabled);
420019d2:	0abd      	mov.n	a11, a10
420019d4:	1a0c      	movi.n	a10, 1
420019d6:	f9e281        	l32r	a8, 42000160 <_stext+0x140> (403786d8 <rtc_clk_8m_enable>)
420019d9:	0008e0        	callx8	a8
    rtc_clk_fast_src_set(SOC_RTC_FAST_CLK_SRC_RC_FAST);
420019dc:	1a0c      	movi.n	a10, 1
420019de:	f9ef81        	l32r	a8, 4200019c <_stext+0x17c> (403788e4 <rtc_clk_fast_src_set>)
420019e1:	0008e0        	callx8	a8
    wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
420019e4:	070c      	movi.n	a7, 0
420019e6:	0179      	s32i.n	a7, a1, 0
420019e8:	f9cb81        	l32r	a8, 42000114 <_stext+0xf4> (60008000 <RTCCNTL>)
420019eb:	1189      	s32i.n	a8, a1, 4
    uint32_t stage_timeout_ticks = (uint32_t)(1600ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
420019ed:	f9ec81        	l32r	a8, 420001a0 <_stext+0x180> (403788bc <rtc_clk_slow_freq_get_hz>)
420019f0:	0008e0        	callx8	a8
420019f3:	40a682        	movi	a8, 0x640
420019f6:	a2b8a0        	muluh	a11, a8, a10
420019f9:	e8a3c2        	movi	a12, 0x3e8
420019fc:	07dd      	mov.n	a13, a7
420019fe:	82a8a0        	mull	a10, a8, a10
42001a01:	f9e881        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42001a04:	0008e0        	callx8	a8
42001a07:	0a6d      	mov.n	a6, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001a09:	01ad      	mov.n	a10, a1
42001a0b:	f9c381        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
42001a0e:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
42001a11:	01ad      	mov.n	a10, a1
42001a13:	f9e581        	l32r	a8, 420001a8 <_stext+0x188> (40000e1c <wdt_hal_feed>)
42001a16:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
42001a19:	4d0c      	movi.n	a13, 4
42001a1b:	06cd      	mov.n	a12, a6
42001a1d:	07bd      	mov.n	a11, a7
42001a1f:	01ad      	mov.n	a10, a1
42001a21:	f9e281        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
42001a24:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001a27:	01ad      	mov.n	a10, a1
42001a29:	f9bd81        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
42001a2c:	0008e0        	callx8	a8
    select_rtc_slow_clk(SLOW_CLK_RTC);
42001a2f:	07ad      	mov.n	a10, a7
42001a31:	ffea25        	call8	420018d4 <select_rtc_slow_clk>
    stage_timeout_ticks = (uint32_t)((uint64_t)CONFIG_BOOTLOADER_WDT_TIME_MS * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001a34:	f9db81        	l32r	a8, 420001a0 <_stext+0x180> (403788bc <rtc_clk_slow_freq_get_hz>)
42001a37:	0008e0        	callx8	a8
42001a3a:	f9d481        	l32r	a8, 4200018c <_stext+0x16c> (2328 <UserFrameTotalSize+0x2228>)
42001a3d:	a2ba80        	muluh	a11, a10, a8
42001a40:	e8a3c2        	movi	a12, 0x3e8
42001a43:	07dd      	mov.n	a13, a7
42001a45:	82aa80        	mull	a10, a10, a8
42001a48:	f9d781        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42001a4b:	0008e0        	callx8	a8
42001a4e:	0a6d      	mov.n	a6, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001a50:	01ad      	mov.n	a10, a1
42001a52:	f9b181        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
42001a55:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
42001a58:	01ad      	mov.n	a10, a1
42001a5a:	f9d381        	l32r	a8, 420001a8 <_stext+0x188> (40000e1c <wdt_hal_feed>)
42001a5d:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
42001a60:	4d0c      	movi.n	a13, 4
42001a62:	06cd      	mov.n	a12, a6
42001a64:	07bd      	mov.n	a11, a7
42001a66:	01ad      	mov.n	a10, a1
42001a68:	f9d181        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
42001a6b:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001a6e:	01ad      	mov.n	a10, a1
42001a70:	f9ac81        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
42001a73:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_get_config(&old_config);
42001a76:	a18b      	addi.n	a10, a1, 8
42001a78:	f9ce81        	l32r	a8, 420001b0 <_stext+0x190> (403789d4 <rtc_clk_cpu_freq_get_config>)
42001a7b:	0008e0        	callx8	a8
    const uint32_t old_freq_mhz = old_config.freq_mhz;
42001a7e:	5168      	l32i.n	a6, a1, 20
    bool res = rtc_clk_cpu_freq_mhz_to_config(new_freq_mhz, &new_config);
42001a80:	18c1b2        	addi	a11, a1, 24
42001a83:	a0a0a2        	movi	a10, 160
42001a86:	f9cb81        	l32r	a8, 420001b4 <_stext+0x194> (4037896c <rtc_clk_cpu_freq_mhz_to_config>)
42001a89:	0008e0        	callx8	a8
42001a8c:	0a7d      	mov.n	a7, a10
    assert(res);
42001a8e:	0adc      	bnez.n	a10, 42001aa2 <esp_clk_init+0xf6>
42001a90:	f9c0d1        	l32r	a13, 42000190 <_stext+0x170> (3c0206dc <_flash_rodata_start+0x5bc>)
42001a93:	f9bcc1        	l32r	a12, 42000184 <_stext+0x164> (3c026420 <__func__$0>)
42001a96:	7da0b2        	movi	a11, 125
42001a99:	f9bba1        	l32r	a10, 42000188 <_stext+0x168> (3c0206d5 <_flash_rodata_start+0x5b5>)
42001a9c:	f99b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42001a9f:	0008e0        	callx8	a8
        esp_rom_output_tx_wait_idle(CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM);
42001aa2:	0a0c      	movi.n	a10, 0
42001aa4:	f9c581        	l32r	a8, 420001b8 <_stext+0x198> (4000069c <esp_rom_output_tx_wait_idle>)
42001aa7:	0008e0        	callx8	a8
    if (res) {
42001aaa:	778c      	beqz.n	a7, 42001ab5 <esp_clk_init+0x109>
        rtc_clk_cpu_freq_set_config(&new_config);
42001aac:	18c1a2        	addi	a10, a1, 24
42001aaf:	f9c381        	l32r	a8, 420001bc <_stext+0x19c> (40378d30 <rtc_clk_cpu_freq_set_config>)
42001ab2:	0008e0        	callx8	a8
    RSR(CCOUNT, ccount);
42001ab5:	03ea80        	rsr.ccount	a8
    esp_cpu_set_cycle_count((uint64_t)esp_cpu_get_cycle_count() * new_freq_mhz / old_freq_mhz);
42001ab8:	a0a0a2        	movi	a10, 160
42001abb:	a2ba80        	muluh	a11, a10, a8
42001abe:	06cd      	mov.n	a12, a6
42001ac0:	00a0d2        	movi	a13, 0
42001ac3:	82aa80        	mull	a10, a10, a8
42001ac6:	f9b781        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42001ac9:	0008e0        	callx8	a8
    WSR(CCOUNT, ccount);
42001acc:	13eaa0        	wsr.ccount	a10
}
42001acf:	f01d      	retw.n
42001ad1:	000000        	ill

42001ad4 <esp_perip_clk_init>:
{
42001ad4:	006136        	entry	a1, 48
    rst_reas[0] = esp_rom_get_reset_reason(0);
42001ad7:	00a0a2        	movi	a10, 0
42001ada:	f9a881        	l32r	a8, 4200017c <_stext+0x15c> (4000057c <esp_rom_get_reset_reason>)
42001add:	0008e0        	callx8	a8
42001ae0:	0a7d      	mov.n	a7, a10
42001ae2:	0061a2        	s32i	a10, a1, 0
    rst_reas[1] = esp_rom_get_reset_reason(1);
42001ae5:	01a0a2        	movi	a10, 1
42001ae8:	f9a581        	l32r	a8, 4200017c <_stext+0x15c> (4000057c <esp_rom_get_reset_reason>)
42001aeb:	0008e0        	callx8	a8
42001aee:	11a9      	s32i.n	a10, a1, 4
            rst_reas[0] == RESET_REASON_CPU0_RTC_WDT || rst_reas[0] == RESET_REASON_CPU0_MWDT1)
42001af0:	f5c792        	addi	a9, a7, -11
42001af3:	280c      	movi.n	a8, 2
42001af5:	628890        	saltu	a8, a8, a9
42001af8:	880b      	addi.n	a8, a8, -1
42001afa:	608080        	neg	a8, a8
42001afd:	efc772        	addi	a7, a7, -17
42001b00:	40f770        	nsau	a7, a7
42001b03:	417570        	srli	a7, a7, 5
42001b06:	208870        	or	a8, a8, a7
42001b09:	748080        	extui	a8, a8, 0, 8
    if ((rst_reas[0] == RESET_REASON_CPU0_MWDT0 || rst_reas[0] == RESET_REASON_CPU0_SW ||
42001b0c:	c8dc      	bnez.n	a8, 42001b2c <esp_perip_clk_init+0x58>
                rst_reas[1] == RESET_REASON_CPU1_RTC_WDT || rst_reas[1] == RESET_REASON_CPU1_MWDT1)
42001b0e:	f5ca92        	addi	a9, a10, -11
42001b11:	280c      	movi.n	a8, 2
42001b13:	628890        	saltu	a8, a8, a9
42001b16:	880b      	addi.n	a8, a8, -1
42001b18:	608080        	neg	a8, a8
42001b1b:	efcaa2        	addi	a10, a10, -17
42001b1e:	40faa0        	nsau	a10, a10
42001b21:	41a5a0        	srli	a10, a10, 5
42001b24:	2088a0        	or	a8, a8, a10
42001b27:	748080        	extui	a8, a8, 0, 8
            || (rst_reas[1] == RESET_REASON_CPU1_MWDT0 || rst_reas[1] == RESET_REASON_CPU1_SW ||
42001b2a:	a8ac      	beqz.n	a8, 42001b58 <esp_perip_clk_init+0x84>
        common_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN0_REG);
42001b2c:	f9a781        	l32r	a8, 420001c8 <_stext+0x1a8> (600c0018 <SYSTEM+0x18>)
42001b2f:	0020c0        	memw
42001b32:	0888      	l32i.n	a8, a8, 0
42001b34:	f97c      	movi.n	a9, -1
42001b36:	308890        	xor	a8, a8, a9
        hwcrypto_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN1_REG);
42001b39:	f9a491        	l32r	a9, 420001cc <_stext+0x1ac> (600c001c <SYSTEM+0x1c>)
42001b3c:	0020c0        	memw
42001b3f:	09b8      	l32i.n	a11, a9, 0
42001b41:	f97c      	movi.n	a9, -1
42001b43:	30bb90        	xor	a11, a11, a9
        wifi_bt_sdio_clk = ~READ_PERI_REG(SYSTEM_WIFI_CLK_EN_REG);
42001b46:	f9a291        	l32r	a9, 420001d0 <_stext+0x1b0> (60026014 <SYSCON+0x14>)
42001b49:	0020c0        	memw
42001b4c:	0998      	l32i.n	a9, a9, 0
42001b4e:	fa7c      	movi.n	a10, -1
42001b50:	3099a0        	xor	a9, a9, a10
42001b53:	000286        	j	42001b61 <esp_perip_clk_init+0x8d>
42001b56:	910000        	srl	a0, a0
        wifi_bt_sdio_clk = SYSTEM_WIFI_CLK_WIFI_EN |
42001b59:	f99a      	add.n	a15, a9, a9
        hwcrypto_perip_clk = SYSTEM_CRYPTO_AES_CLK_EN |
42001b5b:	0ea0b2        	movi	a11, 14
        common_perip_clk = SYSTEM_WDG_CLK_EN |
42001b5e:	f99981        	l32r	a8, 420001c4 <_stext+0x1a4> (8efb8ff8 <_rtc_reserved_end+0x2eeb8ff8>)
    common_perip_clk |= SYSTEM_I2S0_CLK_EN |
42001b61:	f99ca1        	l32r	a10, 420001d4 <_stext+0x1b4> (88e513f0 <_rtc_reserved_end+0x28d513f0>)
42001b64:	2088a0        	or	a8, a8, a10
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN0_REG, common_perip_clk);
42001b67:	f998c1        	l32r	a12, 420001c8 <_stext+0x1a8> (600c0018 <SYSTEM+0x18>)
42001b6a:	0020c0        	memw
42001b6d:	002cd2        	l32i	a13, a12, 0
42001b70:	10a8d0        	and	a10, a8, a13
42001b73:	30aad0        	xor	a10, a10, a13
42001b76:	0020c0        	memw
42001b79:	006ca2        	s32i	a10, a12, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG, common_perip_clk);
42001b7c:	f997c1        	l32r	a12, 420001d8 <_stext+0x1b8> (600c0020 <SYSTEM+0x20>)
42001b7f:	0020c0        	memw
42001b82:	0ca8      	l32i.n	a10, a12, 0
42001b84:	208a80        	or	a8, a10, a8
42001b87:	0020c0        	memw
42001b8a:	0c89      	s32i.n	a8, a12, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, common_perip_clk1);
42001b8c:	f990a1        	l32r	a10, 420001cc <_stext+0x1ac> (600c001c <SYSTEM+0x1c>)
42001b8f:	0020c0        	memw
42001b92:	0a88      	l32i.n	a8, a10, 0
42001b94:	0020c0        	memw
42001b97:	0a89      	s32i.n	a8, a10, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, common_perip_clk1);
42001b99:	f99081        	l32r	a8, 420001dc <_stext+0x1bc> (600c0024 <SYSTEM+0x24>)
42001b9c:	0020c0        	memw
42001b9f:	08c8      	l32i.n	a12, a8, 0
42001ba1:	0020c0        	memw
42001ba4:	08c9      	s32i.n	a12, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, hwcrypto_perip_clk);
42001ba6:	0020c0        	memw
42001ba9:	0ad8      	l32i.n	a13, a10, 0
42001bab:	10cbd0        	and	a12, a11, a13
42001bae:	30ccd0        	xor	a12, a12, a13
42001bb1:	0020c0        	memw
42001bb4:	0ac9      	s32i.n	a12, a10, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, hwcrypto_perip_clk);
42001bb6:	0020c0        	memw
42001bb9:	08a8      	l32i.n	a10, a8, 0
42001bbb:	20aab0        	or	a10, a10, a11
42001bbe:	0020c0        	memw
42001bc1:	08a9      	s32i.n	a10, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_PERI_BACKUP_RST);
42001bc3:	0020c0        	memw
42001bc6:	08a8      	l32i.n	a10, a8, 0
42001bc8:	eb7c      	movi.n	a11, -2
42001bca:	10aab0        	and	a10, a10, a11
42001bcd:	0020c0        	memw
42001bd0:	08a9      	s32i.n	a10, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, wifi_bt_sdio_clk);
42001bd2:	f97fa1        	l32r	a10, 420001d0 <_stext+0x1b0> (60026014 <SYSCON+0x14>)
42001bd5:	0020c0        	memw
42001bd8:	0ab8      	l32i.n	a11, a10, 0
42001bda:	1089b0        	and	a8, a9, a11
42001bdd:	3088b0        	xor	a8, a8, a11
42001be0:	0020c0        	memw
42001be3:	0a89      	s32i.n	a8, a10, 0
    SET_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, SYSTEM_WIFI_CLK_EN);
42001be5:	0020c0        	memw
42001be8:	0a88      	l32i.n	a8, a10, 0
42001bea:	f97d91        	l32r	a9, 420001e0 <_stext+0x1c0> (fb9fcf <UserFrameTotalSize+0xfb9ecf>)
42001bed:	208890        	or	a8, a8, a9
42001bf0:	0020c0        	memw
42001bf3:	0a89      	s32i.n	a8, a10, 0
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
42001bf5:	f97b91        	l32r	a9, 420001e4 <_stext+0x1c4> (600c0028 <SYSTEM+0x28>)
42001bf8:	0020c0        	memw
42001bfb:	0988      	l32i.n	a8, a9, 0
42001bfd:	418c80        	srli	a8, a8, 12
42001c00:	118840        	slli	a8, a8, 12
42001c03:	0020c0        	memw
42001c06:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_XTAL32K | SYSTEM_LPCLK_SEL_XTAL | SYSTEM_LPCLK_SEL_8M | SYSTEM_LPCLK_SEL_RTC_SLOW);
42001c08:	f97881        	l32r	a8, 420001e8 <_stext+0x1c8> (600c002c <SYSTEM+0x2c>)
42001c0b:	0020c0        	memw
42001c0e:	0898      	l32i.n	a9, a8, 0
42001c10:	f977a1        	l32r	a10, 420001ec <_stext+0x1cc> (f0ffffff <_rtc_reserved_end+0x90efffff>)
42001c13:	1099a0        	and	a9, a9, a10
42001c16:	0020c0        	memw
42001c19:	0899      	s32i.n	a9, a8, 0
    SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_RTC_SLOW);
42001c1b:	0020c0        	memw
42001c1e:	0898      	l32i.n	a9, a8, 0
42001c20:	f974a1        	l32r	a10, 420001f0 <_stext+0x1d0> (1000000 <UserFrameTotalSize+0xffff00>)
42001c23:	2099a0        	or	a9, a9, a10
42001c26:	0020c0        	memw
42001c29:	0899      	s32i.n	a9, a8, 0
    periph_module_enable(PERIPH_RNG_MODULE);
42001c2b:	9a1c      	movi.n	a10, 25
42001c2d:	1671e5        	call8	4201834c <periph_module_enable>
}
42001c30:	f01d      	retw.n
	...

42001c34 <esp_cache_err_get_panic_info>:
        }
    }
}

void esp_cache_err_get_panic_info(esp_cache_err_info_t *err_info)
{
42001c34:	004136        	entry	a1, 32
    if (err_info == NULL) {
42001c37:	029216        	beqz	a2, 42001c64 <esp_cache_err_get_panic_info+0x30>
 *
 * @return            Status mask
 */
static inline uint32_t cache_ll_l1_get_illegal_error_intr_status(uint32_t cache_id, uint32_t mask)
{
    return GET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ST_REG, mask);
42001c3a:	f96e81        	l32r	a8, 420001f4 <_stext+0x1d4> (600c40e4 <SYSTEM+0x40e4>)
42001c3d:	0020c0        	memw
42001c40:	0028a2        	l32i	a10, a8, 0
    }
    /* Read the status register EXTMEM_CACHE_ILG_INT_ST_REG. This status
     * register is not equal to 0 when a cache access error occurred. */
    const uint32_t illegal_intr_status = cache_ll_l1_get_illegal_error_intr_status(0, CACHE_LL_L1_ILG_EVENT_MASK);

    get_cache_error(illegal_intr_status, ilg_int_st_bits, DIM(ilg_int_st_bits), err_info);
42001c43:	02dd      	mov.n	a13, a2
42001c45:	06a0c2        	movi	a12, 6
42001c48:	f96cb1        	l32r	a11, 420001f8 <_stext+0x1d8> (3c026450 <ilg_int_st_bits>)
42001c4b:	54a0a0        	extui	a10, a10, 0, 6
42001c4e:	148aa5        	call8	420164f8 <get_cache_error>

    // If no error reported above we check if the error came from ACS
    if (err_info->err_str == NULL) {
42001c51:	0288      	l32i.n	a8, a2, 0
42001c53:	d8cc      	bnez.n	a8, 42001c64 <esp_cache_err_get_panic_info+0x30>
        uint32_t st = access_error_intr_status;
        get_cache_error(st, acs_int_st_bits, DIM(acs_int_st_bits), err_info);
42001c55:	02dd      	mov.n	a13, a2
42001c57:	1c0c      	movi.n	a12, 1
42001c59:	f969b1        	l32r	a11, 42000200 <_stext+0x1e0> (3c026440 <acs_int_st_bits>)
42001c5c:	f96881        	l32r	a8, 420001fc <_stext+0x1dc> (3fc94d24 <access_error_intr_status>)
42001c5f:	08a8      	l32i.n	a10, a8, 0
42001c61:	148965        	call8	420164f8 <get_cache_error>
    }
}
42001c64:	f01d      	retw.n
	...

42001c68 <esp_cache_err_acs_save_and_clr>:

void esp_cache_err_acs_save_and_clr(void)
{
42001c68:	004136        	entry	a1, 32
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
42001c6b:	f96681        	l32r	a8, 42000204 <_stext+0x1e4> (600c40f0 <SYSTEM+0x40f0>)
42001c6e:	0020c0        	memw
42001c71:	0888      	l32i.n	a8, a8, 0
42001c73:	448080        	extui	a8, a8, 0, 5
    if (cache_ll_l1_get_access_error_intr_status(0, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
42001c76:	a88c      	beqz.n	a8, 42001c84 <esp_cache_err_acs_save_and_clr+0x1c>
        cache_err_cpu_id = PRO_CPU_NUM;
42001c78:	f96481        	l32r	a8, 42000208 <_stext+0x1e8> (3fc94d1c <cache_err_cpu_id>)
42001c7b:	090c      	movi.n	a9, 0
42001c7d:	0899      	s32i.n	a9, a8, 0
42001c7f:	000906        	j	42001ca7 <esp_cache_err_acs_save_and_clr+0x3f>
42001c82:	810000        	src	a0, a0, a0
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
42001c85:	c0f962        	s32ri	a6, a9, 0x300
42001c88:	20          	.byte	0x20
42001c89:	088800        	lsx	f8, a8, a0
42001c8c:	448080        	extui	a8, a8, 0, 5
    } else if (cache_ll_l1_get_access_error_intr_status(1, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
42001c8f:	988c      	beqz.n	a8, 42001c9c <esp_cache_err_acs_save_and_clr+0x34>
        cache_err_cpu_id = APP_CPU_NUM;
42001c91:	f95d81        	l32r	a8, 42000208 <_stext+0x1e8> (3fc94d1c <cache_err_cpu_id>)
42001c94:	190c      	movi.n	a9, 1
42001c96:	0899      	s32i.n	a9, a8, 0
42001c98:	0002c6        	j	42001ca7 <esp_cache_err_acs_save_and_clr+0x3f>
42001c9b:	5b8100        	ult.s	b8, f1, f0
    } else {
        cache_err_cpu_id = -1;
42001c9e:	7cf9      	s32i.n	a15, a12, 28
42001ca0:	99f9      	s32i.n	a15, a9, 36
42001ca2:	c608      	l32i.n	a0, a6, 48
        return;
42001ca4:	001b      	addi.n	a0, a0, 1
42001ca6:	588100        	ssxp	f8, a1, a0

    // Certain errors needs to be cleared if the cache is to continue functioning properly.
    // E.g. for CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT errors the cache will sometimes end up in an invalid state
    // where the panic handler will then be unable to access rodata from flash
    // Store the error information before clearing, as it will be used later when reporting
    access_error_intr_status = cache_ll_l1_get_access_error_intr_status(cache_err_cpu_id, CACHE_LL_L1_ACCESS_EVENT_MASK);
42001ca9:	98f9      	s32i.n	a15, a8, 36
42001cab:	cc08      	l32i.n	a0, a12, 48
    if (cache_id == 0) {
42001cad:	81c9      	s32i.n	a12, a1, 32
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
42001caf:	c0f955        	call4	41fc2c44 <_iram_bss_end+0x1c40844>
42001cb2:	20          	.byte	0x20
42001cb3:	088800        	lsx	f8, a8, a0
42001cb6:	448080        	extui	a8, a8, 0, 5
42001cb9:	000286        	j	42001cc7 <esp_cache_err_acs_save_and_clr+0x5f>
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
42001cbc:	f95481        	l32r	a8, 4200020c <_stext+0x1ec> (600c40fc <SYSTEM+0x40fc>)
42001cbf:	0020c0        	memw
42001cc2:	0888      	l32i.n	a8, a8, 0
42001cc4:	448080        	extui	a8, a8, 0, 5
42001cc7:	f94da1        	l32r	a10, 420001fc <_stext+0x1dc> (3fc94d24 <access_error_intr_status>)
42001cca:	0a89      	s32i.n	a8, a10, 0
    if (access_error_intr_status & CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT) {
42001ccc:	0a1c      	movi.n	a10, 16
42001cce:	4408a7        	bnone	a8, a10, 42001d16 <esp_cache_err_acs_save_and_clr+0xae>
 * @return vaddr that cause the acs dbus reject error
 */
__attribute__((always_inline))
static inline uint32_t cache_ll_get_acs_dbus_reject_vaddr(uint32_t cache_id)
{
    if (cache_id == 0) {
42001cd1:	b9cc      	bnez.n	a9, 42001ce0 <esp_cache_err_acs_save_and_clr+0x78>
        return REG_READ(EXTMEM_CORE0_DBUS_REJECT_VADDR_REG);
42001cd3:	f94f81        	l32r	a8, 42000210 <_stext+0x1f0> (600c4104 <SYSTEM+0x4104>)
42001cd6:	0020c0        	memw
42001cd9:	08a8      	l32i.n	a10, a8, 0
42001cdb:	000246        	j	42001ce8 <esp_cache_err_acs_save_and_clr+0x80>
42001cde:	810000        	src	a0, a0, a0
    } else {
        return REG_READ(EXTMEM_CORE1_DBUS_REJECT_VADDR_REG);
42001ce1:	4d          	.byte	0x4d
42001ce2:	c0f9      	s32i.n	a15, a0, 48
42001ce4:	20          	.byte	0x20
42001ce5:	08a800        	lsx	f10, a8, a0
        acs_fault_addr = cache_ll_get_acs_dbus_reject_vaddr(cache_err_cpu_id);
42001ce8:	f94c81        	l32r	a8, 42000218 <_stext+0x1f8> (3fc94d20 <acs_fault_addr>)
42001ceb:	08a9      	s32i.n	a10, a8, 0
    if (cache_id == 0) {
42001ced:	39dc      	bnez.n	a9, 42001d04 <esp_cache_err_acs_save_and_clr+0x9c>
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
42001cef:	f94b91        	l32r	a9, 4200021c <_stext+0x1fc> (600c40ec <SYSTEM+0x40ec>)
42001cf2:	0020c0        	memw
42001cf5:	0988      	l32i.n	a8, a9, 0
42001cf7:	0a1c      	movi.n	a10, 16
42001cf9:	2088a0        	or	a8, a8, a10
42001cfc:	0020c0        	memw
42001cff:	0989      	s32i.n	a8, a9, 0
42001d01:	000446        	j	42001d16 <esp_cache_err_acs_save_and_clr+0xae>
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
42001d04:	f94791        	l32r	a9, 42000220 <_stext+0x200> (600c40f8 <SYSTEM+0x40f8>)
42001d07:	0020c0        	memw
42001d0a:	0988      	l32i.n	a8, a9, 0
42001d0c:	0a1c      	movi.n	a10, 16
42001d0e:	2088a0        	or	a8, a8, a10
42001d11:	0020c0        	memw
42001d14:	0989      	s32i.n	a8, a9, 0
        cache_ll_l1_clear_access_error_intr(cache_err_cpu_id, CACHE_LL_L1_ACCESS_EVENT_DBUS_REJECT);
    }
}
42001d16:	f01d      	retw.n

42001d18 <esp_cache_err_int_init>:

void esp_cache_err_int_init(void)
{
42001d18:	004136        	entry	a1, 32
    asm volatile (
42001d1b:	03eb70        	rsr.prid	a7
42001d1e:	047d70        	extui	a7, a7, 13, 1
    uint32_t core_id = esp_cpu_get_core_id();
    ESP_INTR_DISABLE(ETS_CACHEERR_INUM);
42001d21:	9a1c      	movi.n	a10, 25
42001d23:	f94781        	l32r	a8, 42000240 <_stext+0x220> (40376644 <esp_intr_disable_source>)
42001d26:	0008e0        	callx8	a8

    // We do not register a handler for the interrupt because it is interrupt
    // level 4 which is not serviceable from C. Instead, xtensa_vectors.S has
    // a call to the panic handler for this interrupt.
    esp_rom_route_intr_matrix(core_id, ETS_CACHE_IA_INTR_SOURCE, ETS_CACHEERR_INUM);
42001d29:	9c1c      	movi.n	a12, 25
42001d2b:	8b3c      	movi.n	a11, 56
42001d2d:	07ad      	mov.n	a10, a7
42001d2f:	f8fd81        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42001d32:	0008e0        	callx8	a8
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_CLR_REG, mask);
42001d35:	f93b91        	l32r	a9, 42000224 <_stext+0x204> (600c40e0 <SYSTEM+0x40e0>)
42001d38:	0020c0        	memw
42001d3b:	0988      	l32i.n	a8, a9, 0
42001d3d:	fa3c      	movi.n	a10, 63
42001d3f:	2088a0        	or	a8, a8, a10
42001d42:	0020c0        	memw
42001d45:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ENA_REG, mask);
42001d47:	f93891        	l32r	a9, 42000228 <_stext+0x208> (600c40dc <SYSTEM+0x40dc>)
42001d4a:	0020c0        	memw
42001d4d:	0988      	l32i.n	a8, a9, 0
42001d4f:	2088a0        	or	a8, a8, a10
42001d52:	0020c0        	memw
42001d55:	0989      	s32i.n	a8, a9, 0
    ESP_DRAM_LOGV(TAG, "illegal error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ILG_EVENT_MASK);
    //illegal error intr doesn't depend on cache_id
    cache_ll_l1_clear_illegal_error_intr(0, CACHE_LL_L1_ILG_EVENT_MASK);
    cache_ll_l1_enable_illegal_error_intr(0, CACHE_LL_L1_ILG_EVENT_MASK);

    if (core_id == PRO_CPU_NUM) {
42001d57:	f7ec      	bnez.n	a7, 42001d8a <esp_cache_err_int_init+0x72>
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE0_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
42001d59:	9c1c      	movi.n	a12, 25
42001d5b:	eb5c      	movi.n	a11, 94
42001d5d:	07ad      	mov.n	a10, a7
42001d5f:	f8f181        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42001d62:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
42001d65:	f92d91        	l32r	a9, 4200021c <_stext+0x1fc> (600c40ec <SYSTEM+0x40ec>)
42001d68:	0020c0        	memw
42001d6b:	0988      	l32i.n	a8, a9, 0
42001d6d:	fa1c      	movi.n	a10, 31
42001d6f:	2088a0        	or	a8, a8, a10
42001d72:	0020c0        	memw
42001d75:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ENA_REG, mask);
42001d77:	f92d91        	l32r	a9, 4200022c <_stext+0x20c> (600c40e8 <SYSTEM+0x40e8>)
42001d7a:	0020c0        	memw
42001d7d:	0988      	l32i.n	a8, a9, 0
42001d7f:	2088a0        	or	a8, a8, a10
42001d82:	0020c0        	memw
42001d85:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001d87:	000bc6        	j	42001dba <esp_cache_err_int_init+0xa2>
         * enabling cache access error interrupts.  */
        ESP_DRAM_LOGV(TAG, "core 0 access error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_clear_access_error_intr(0, CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_enable_access_error_intr(0, CACHE_LL_L1_ACCESS_EVENT_MASK);
    } else {
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE1_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
42001d8a:	9c1c      	movi.n	a12, 25
42001d8c:	5fa0b2        	movi	a11, 95
42001d8f:	20a770        	or	a10, a7, a7
42001d92:	f8e481        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42001d95:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
42001d98:	f92291        	l32r	a9, 42000220 <_stext+0x200> (600c40f8 <SYSTEM+0x40f8>)
42001d9b:	0020c0        	memw
42001d9e:	0988      	l32i.n	a8, a9, 0
42001da0:	fa1c      	movi.n	a10, 31
42001da2:	2088a0        	or	a8, a8, a10
42001da5:	0020c0        	memw
42001da8:	0989      	s32i.n	a8, a9, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001daa:	f92191        	l32r	a9, 42000230 <_stext+0x210> (600c40f4 <SYSTEM+0x40f4>)
42001dad:	0020c0        	memw
42001db0:	0988      	l32i.n	a8, a9, 0
42001db2:	2088a0        	or	a8, a8, a10
42001db5:	0020c0        	memw
42001db8:	0989      	s32i.n	a8, a9, 0
        ESP_DRAM_LOGV(TAG, "core 1 access error intr clr & ena mask is: 0x%x", CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_clear_access_error_intr(1, CACHE_LL_L1_ACCESS_EVENT_MASK);
        cache_ll_l1_enable_access_error_intr(1, CACHE_LL_L1_ACCESS_EVENT_MASK);
    }

    if (core_id == 0) {
42001dba:	064756        	bnez	a7, 42001e22 <esp_cache_err_int_init+0x10a>
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_addr(uint8_t spi_num, uint32_t region, uint32_t address)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_addr = address;
42001dbd:	f91d81        	l32r	a8, 42000234 <_stext+0x214> (60026000 <SYSCON>)
42001dc0:	090c      	movi.n	a9, 0
42001dc2:	0020c0        	memw
42001dc5:	e899      	s32i.n	a9, a8, 56
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_size(uint8_t spi_num, uint32_t region, uint32_t size)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_size.flash_ace0_size = size;
42001dc7:	0020c0        	memw
42001dca:	1228b2        	l32i	a11, a8, 72
42001dcd:	f91a91        	l32r	a9, 42000238 <_stext+0x218> (ffff0000 <_rtc_reserved_end+0x9fef0000>)
42001dd0:	10bb90        	and	a11, a11, a9
42001dd3:	f91aa1        	l32r	a10, 4200023c <_stext+0x21c> (4000 <UserFrameTotalSize+0x3f00>)
42001dd6:	20aba0        	or	a10, a11, a10
42001dd9:	0020c0        	memw
42001ddc:	1268a2        	s32i	a10, a8, 72
            break;
        case 1:
            SYSCON.flash_ace1_size.flash_ace1_size = size;
42001ddf:	0020c0        	memw
42001de2:	1328b2        	l32i	a11, a8, 76
42001de5:	10ab90        	and	a10, a11, a9
42001de8:	0020c0        	memw
42001deb:	1368a2        	s32i	a10, a8, 76
            break;
        case 2:
            SYSCON.flash_ace2_size.flash_ace2_size = size;
42001dee:	0020c0        	memw
42001df1:	1428b2        	l32i	a11, a8, 80
42001df4:	10ab90        	and	a10, a11, a9
42001df7:	0020c0        	memw
42001dfa:	1468a2        	s32i	a10, a8, 80
            break;
        case 3:
            SYSCON.flash_ace3_size.flash_ace3_size = size;
42001dfd:	0020c0        	memw
42001e00:	1528a2        	l32i	a10, a8, 84
42001e03:	109a90        	and	a9, a10, a9
42001e06:	0020c0        	memw
42001e09:	156892        	s32i	a9, a8, 84
__attribute__((always_inline))
static inline void mspi_ll_set_flash_protection_access(uint8_t spi_num, uint32_t region, mspi_ll_flash_ace_ctrl_t ctrl)
{
    switch(region){
        case 0:
            SYSCON.flash_ace0_attr.flash_ace0_attr = ctrl.val;
42001e0c:	0020c0        	memw
42001e0f:	a8a8      	l32i.n	a10, a8, 40
42001e11:	00ae92        	movi	a9, 0xfffffe00
42001e14:	10aa90        	and	a10, a10, a9
42001e17:	dba092        	movi	a9, 219
42001e1a:	209a90        	or	a9, a10, a9
42001e1d:	0020c0        	memw
42001e20:	a899      	s32i.n	a9, a8, 40

        mspi_ll_set_flash_protection_access(0, 0, ctrl);

    }

    ESP_INTR_ENABLE(ETS_CACHEERR_INUM);
42001e22:	9a1c      	movi.n	a10, 25
42001e24:	f90881        	l32r	a8, 42000244 <_stext+0x224> (40376578 <esp_intr_enable_source>)
42001e27:	0008e0        	callx8	a8
}
42001e2a:	f01d      	retw.n

42001e2c <esp_cache_err_get_cpuid>:

int esp_cache_err_get_cpuid(void)
{
42001e2c:	004136        	entry	a1, 32
    return cache_err_cpu_id;
}
42001e2f:	f8f681        	l32r	a8, 42000208 <_stext+0x1e8> (3fc94d1c <cache_err_cpu_id>)
42001e32:	0828      	l32i.n	a2, a8, 0
42001e34:	f01d      	retw.n
	...

42001e38 <esp_apb_backup_dma_lock_init>:

void esp_apb_backup_dma_lock_init(void)
{
42001e38:	004136        	entry	a1, 32
    ets_apb_backup_init_lock_func(apb_backup_dma_lock, apb_backup_dma_unlock);
42001e3b:	f903b1        	l32r	a11, 42000248 <_stext+0x228> (40375900 <apb_backup_dma_unlock>)
42001e3e:	f903a1        	l32r	a10, 4200024c <_stext+0x22c> (4037591c <apb_backup_dma_lock>)
42001e41:	f90381        	l32r	a8, 42000250 <_stext+0x230> (40000630 <ets_apb_backup_init_lock_func>)
42001e44:	0008e0        	callx8	a8
}
42001e47:	f01d      	retw.n
42001e49:	000000        	ill

42001e4c <esp_int_wdt_init>:

void esp_int_wdt_init(void)
{
42001e4c:	004136        	entry	a1, 32
    PERIPH_RCC_ACQUIRE_ATOMIC(IWDT_PERIPH, ref_count) {
42001e4f:	170c      	movi.n	a7, 1
42001e51:	001446        	j	42001ea6 <esp_int_wdt_init+0x5a>
        SYSTEM.perip_clk_en0.timergroup1_clk_en = enable;
42001e54:	f90081        	l32r	a8, 42000254 <_stext+0x234> (600c0000 <SYSTEM>)
42001e57:	0020c0        	memw
42001e5a:	6898      	l32i.n	a9, a8, 24
42001e5c:	f8ffa1        	l32r	a10, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
42001e5f:	2099a0        	or	a9, a9, a10
42001e62:	0020c0        	memw
42001e65:	6899      	s32i.n	a9, a8, 24
        SYSTEM.perip_rst_en0.timergroup1_rst = 1;
42001e67:	0020c0        	memw
42001e6a:	8898      	l32i.n	a9, a8, 32
42001e6c:	2099a0        	or	a9, a9, a10
42001e6f:	0020c0        	memw
42001e72:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup1_rst = 0;
42001e74:	0020c0        	memw
42001e77:	8898      	l32i.n	a9, a8, 32
42001e79:	f8f8a1        	l32r	a10, 4200025c <_stext+0x23c> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42001e7c:	1099a0        	and	a9, a9, a10
42001e7f:	0020c0        	memw
42001e82:	8899      	s32i.n	a9, a8, 32
        TIMERG1.wdtconfig0.wdt_flashboot_mod_en = 0;
42001e84:	f8f791        	l32r	a9, 42000260 <_stext+0x240> (60020000 <TIMERG1>)
42001e87:	0020c0        	memw
42001e8a:	122982        	l32i	a8, a9, 72
42001e8d:	f8f5a1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42001e90:	1088a0        	and	a8, a8, a10
42001e93:	0020c0        	memw
42001e96:	126982        	s32i	a8, a9, 72
42001e99:	ba0c      	movi.n	a10, 11
42001e9b:	f8f681        	l32r	a8, 42000274 <_stext+0x254> (40378200 <periph_rcc_acquire_exit>)
42001e9e:	0008e0        	callx8	a8
42001ea1:	770b      	addi.n	a7, a7, -1
42001ea3:	747070        	extui	a7, a7, 0, 8
42001ea6:	e78c      	beqz.n	a7, 42001eb8 <esp_int_wdt_init+0x6c>
42001ea8:	ba0c      	movi.n	a10, 11
42001eaa:	f8f381        	l32r	a8, 42000278 <_stext+0x258> (403781f0 <periph_rcc_acquire_enter>)
42001ead:	0008e0        	callx8	a8
42001eb0:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
42001eb2:	f9ea16        	beqz	a10, 42001e54 <esp_int_wdt_init+0x8>
42001eb5:	fff806        	j	42001e99 <esp_int_wdt_init+0x4d>
    /*
     * Initialize the WDT timeout stages. Note that the initial timeout is set to 5 seconds as variable startup times of
     * each CPU can lead to a timeout. The tick hooks will set the WDT timers to the actual timeout.
     * Todo: Fix this
     */
    wdt_hal_init(&iwdt_context, IWDT_INSTANCE, IWDT_PRESCALER, true);
42001eb8:	f8ed71        	l32r	a7, 4200026c <_stext+0x24c> (3fc94d2c <iwdt_context>)
42001ebb:	1d0c      	movi.n	a13, 1
42001ebd:	f8eac1        	l32r	a12, 42000268 <_stext+0x248> (9c40 <UserFrameTotalSize+0x9b40>)
42001ec0:	2b0c      	movi.n	a11, 2
42001ec2:	07ad      	mov.n	a10, a7
42001ec4:	f8ee81        	l32r	a8, 4200027c <_stext+0x25c> (40000dbc <wdt_hal_init>)
42001ec7:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&iwdt_context);
42001eca:	07ad      	mov.n	a10, a7
42001ecc:	f89381        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
42001ecf:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);
42001ed2:	f8e761        	l32r	a6, 42000270 <_stext+0x250> (2710 <UserFrameTotalSize+0x2610>)
42001ed5:	1d0c      	movi.n	a13, 1
42001ed7:	06cd      	mov.n	a12, a6
42001ed9:	00a0b2        	movi	a11, 0
42001edc:	07ad      	mov.n	a10, a7
42001ede:	f8b381        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
42001ee1:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM);
42001ee4:	3d0c      	movi.n	a13, 3
42001ee6:	06cd      	mov.n	a12, a6
42001ee8:	1b0c      	movi.n	a11, 1
42001eea:	07ad      	mov.n	a10, a7
42001eec:	f8b081        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
42001eef:	0008e0        	callx8	a8
    wdt_hal_enable(&iwdt_context);
42001ef2:	07ad      	mov.n	a10, a7
42001ef4:	f8e381        	l32r	a8, 42000280 <_stext+0x260> (40000df8 <wdt_hal_enable>)
42001ef7:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&iwdt_context);
42001efa:	07ad      	mov.n	a10, a7
42001efc:	f88981        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
42001eff:	0008e0        	callx8	a8
                : [ERI] "=r"(eriadrs), [REG] "+r"(scratch), [IMM] "+r"(immediate)
            );
        }
    }
#endif // (CONFIG_ESP32_ECO3_CACHE_LOCK_FIX && CONFIG_BTDM_CTRL_HLI)
}
42001f02:	f01d      	retw.n

42001f04 <esp_int_wdt_cpu_init>:

void esp_int_wdt_cpu_init(void)
{
42001f04:	004136        	entry	a1, 32
42001f07:	03ebb0        	rsr.prid	a11
42001f0a:	04bdb0        	extui	a11, a11, 13, 1
    assert((CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (portTICK_PERIOD_MS << 1)) && "Interrupt watchdog timeout needs to be at least twice the RTOS tick period!");
    // Register tick hook for current CPU to feed the INT WDT
    esp_register_freertos_tick_hook_for_cpu(tick_hook, esp_cpu_get_core_id());
42001f0d:	f8dda1        	l32r	a10, 42000284 <_stext+0x264> (4037593c <tick_hook>)
42001f10:	00b765        	call8	42002a88 <esp_register_freertos_tick_hook_for_cpu>
    /*
     * Register INT WDT interrupt for current CPU. We do this manually as the timeout interrupt should call an assembly
     * panic handler (see riscv/vector.S and xtensa_vectors.S).
     */
    esp_intr_disable_source(ETS_INT_WDT_INUM);
42001f13:	18a0a2        	movi	a10, 24
42001f16:	f8ca81        	l32r	a8, 42000240 <_stext+0x220> (40376644 <esp_intr_disable_source>)
42001f19:	0008e0        	callx8	a8
42001f1c:	03eba0        	rsr.prid	a10
42001f1f:	04ada0        	extui	a10, a10, 13, 1
    esp_rom_route_intr_matrix(esp_cpu_get_core_id(), WDT_LEVEL_INTR_SOURCE, ETS_INT_WDT_INUM);
42001f22:	18a0c2        	movi	a12, 24
42001f25:	37a0b2        	movi	a11, 55
42001f28:	f87f81        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42001f2b:	0008e0        	callx8	a8
        assert((portTICK_PERIOD_MS << 1) <= IWDT_LIVELOCK_TIMEOUT_MS);
        assert(CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (IWDT_LIVELOCK_TIMEOUT_MS * 3));
        _lx_intr_livelock_max = CONFIG_ESP_INT_WDT_TIMEOUT_MS / IWDT_LIVELOCK_TIMEOUT_MS - 1;
    }
#endif
    esp_intr_enable_source(ETS_INT_WDT_INUM);
42001f2e:	8a1c      	movi.n	a10, 24
42001f30:	f8c581        	l32r	a8, 42000244 <_stext+0x224> (40376578 <esp_intr_enable_source>)
42001f33:	0008e0        	callx8	a8
}
42001f36:	f01d      	retw.n

42001f38 <panic_print_char_uart>:
{
42001f38:	008136        	entry	a1, 64
42001f3b:	104122        	s8i	a2, a1, 16
    uint32_t sz = 0;
42001f3e:	00a082        	movi	a8, 0
42001f41:	006182        	s32i	a8, a1, 0
    while (!uart_hal_get_txfifo_len(&s_panic_uart));
42001f44:	f8d181        	l32r	a8, 42000288 <_stext+0x268> (3fc92408 <s_panic_uart>)
42001f47:	002882        	l32i	a8, a8, 0
 *
 * @return The data length of txfifo can be written.
 */
FORCE_INLINE_ATTR uint32_t uart_ll_get_txfifo_len(uart_dev_t *hw)
{
    return UART_LL_FIFO_DEF_LEN - hw->status.txfifo_cnt;
42001f4a:	0020c0        	memw
42001f4d:	072882        	l32i	a8, a8, 28
42001f50:	958080        	extui	a8, a8, 16, 10
42001f53:	ede826        	beqi	a8, 128, 42001f44 <panic_print_char_uart+0xc>
    uart_hal_write_txfifo(&s_panic_uart, (uint8_t *) &c, 1, &sz);
42001f56:	20d110        	or	a13, a1, a1
42001f59:	1c0c      	movi.n	a12, 1
42001f5b:	10c1b2        	addi	a11, a1, 16
42001f5e:	f8caa1        	l32r	a10, 42000288 <_stext+0x268> (3fc92408 <s_panic_uart>)
42001f61:	145ee5        	call8	42016550 <uart_hal_write_txfifo>
}
42001f64:	f01d      	retw.n
	...

42001f68 <panic_print_char_usb_serial_jtag>:
{
42001f68:	006136        	entry	a1, 48
42001f6b:	004122        	s8i	a2, a1, 0
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001f6e:	000446        	j	42001f83 <panic_print_char_usb_serial_jtag+0x1b>
        esp_rom_delay_us(100);
42001f71:	64a0a2        	movi	a10, 100
42001f74:	f85b81        	l32r	a8, 420000e0 <_stext+0xc0> (40000600 <esp_rom_delay_us>)
42001f77:	0008e0        	callx8	a8
        s_usbserial_timeout++;
42001f7a:	f8c491        	l32r	a9, 4200028c <_stext+0x26c> (3fc94d34 <s_usbserial_timeout>)
42001f7d:	0988      	l32i.n	a8, a9, 0
42001f7f:	881b      	addi.n	a8, a8, 1
42001f81:	0989      	s32i.n	a8, a9, 0
 *
 * @return 0 if no data available, 1 if data available
 */
static inline int usb_serial_jtag_ll_txfifo_writable(void)
{
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
42001f83:	f8c381        	l32r	a8, 42000290 <_stext+0x270> (60038000 <USB_SERIAL_JTAG>)
42001f86:	0020c0        	memw
42001f89:	1888      	l32i.n	a8, a8, 4
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001f8b:	0ae817        	bbsi	a8, 1, 42001f99 <panic_print_char_usb_serial_jtag+0x31>
42001f8e:	f8bf81        	l32r	a8, 4200028c <_stext+0x26c> (3fc94d34 <s_usbserial_timeout>)
42001f91:	0888      	l32i.n	a8, a8, 0
42001f93:	f3a192        	movi	a9, 0x1f3
42001f96:	d7a987        	bge	a9, a8, 42001f71 <panic_print_char_usb_serial_jtag+0x9>
42001f99:	f8bd81        	l32r	a8, 42000290 <_stext+0x270> (60038000 <USB_SERIAL_JTAG>)
42001f9c:	0020c0        	memw
42001f9f:	1888      	l32i.n	a8, a8, 4
    if (usb_serial_jtag_ll_txfifo_writable()) {
42001fa1:	20e817        	bbsi	a8, 1, 42001fc5 <panic_print_char_usb_serial_jtag+0x5d>
42001fa4:	000a46        	j	42001fd1 <panic_print_char_usb_serial_jtag+0x69>
42001fa7:	ba9100        	ceil.s	a9, f1, 0
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
42001faa:	c0f8      	l32i.n	a15, a0, 48
42001fac:	20          	.byte	0x20
42001fad:	00          	.byte	00
42001fae:	1998      	l32i.n	a9, a9, 4
42001fb0:	166917        	bbci	a9, 1, 42001fca <panic_print_char_usb_serial_jtag+0x62>
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
42001fb3:	918a      	add.n	a9, a1, a8
42001fb5:	0009a2        	l8ui	a10, a9, 0
42001fb8:	f8b691        	l32r	a9, 42000290 <_stext+0x270> (60038000 <USB_SERIAL_JTAG>)
42001fbb:	0020c0        	memw
42001fbe:	09a9      	s32i.n	a10, a9, 0
    for (i = 0; i < wr_len; i++) {
42001fc0:	881b      	addi.n	a8, a8, 1
42001fc2:	000046        	j	42001fc7 <panic_print_char_usb_serial_jtag+0x5f>
42001fc5:	080c      	movi.n	a8, 0
42001fc7:	fdd816        	beqz	a8, 42001fa8 <panic_print_char_usb_serial_jtag+0x40>
        s_usbserial_timeout = 0;
42001fca:	f8b081        	l32r	a8, 4200028c <_stext+0x26c> (3fc94d34 <s_usbserial_timeout>)
42001fcd:	090c      	movi.n	a9, 0
42001fcf:	0899      	s32i.n	a9, a8, 0
}
42001fd1:	f01d      	retw.n
	...

42001fd4 <panic_print_char>:
{
42001fd4:	004136        	entry	a1, 32
42001fd7:	742020        	extui	a2, a2, 0, 8
    panic_print_char_uart(c);
42001fda:	20a220        	or	a10, a2, a2
42001fdd:	fff5a5        	call8	42001f38 <panic_print_char_uart>
    panic_print_char_usb_serial_jtag(c);
42001fe0:	20a220        	or	a10, a2, a2
42001fe3:	fff865        	call8	42001f68 <panic_print_char_usb_serial_jtag>
}
42001fe6:	f01d      	retw.n

42001fe8 <panic_print_str>:
{
42001fe8:	004136        	entry	a1, 32
    for (int i = 0; str[i] != 0; i++) {
42001feb:	070c      	movi.n	a7, 0
42001fed:	000146        	j	42001ff6 <panic_print_str+0xe>
        panic_print_char(str[i]);
42001ff0:	fffe25        	call8	42001fd4 <panic_print_char>
    for (int i = 0; str[i] != 0; i++) {
42001ff3:	01c772        	addi	a7, a7, 1
42001ff6:	808270        	add	a8, a2, a7
42001ff9:	0008a2        	l8ui	a10, a8, 0
42001ffc:	ff0a56        	bnez	a10, 42001ff0 <panic_print_str+0x8>
}
42001fff:	000090        	retw
	...

42002004 <print_abort_details>:
{
42002004:	004136        	entry	a1, 32
    panic_print_str(g_panic_abort_details);
42002007:	f8a381        	l32r	a8, 42000294 <_stext+0x274> (3fc94d38 <g_panic_abort_details>)
4200200a:	08a8      	l32i.n	a10, a8, 0
4200200c:	fffda5        	call8	42001fe8 <panic_print_str>
}
4200200f:	f01d      	retw.n
42002011:	000000        	ill

42002014 <panic_print_hex>:
{
42002014:	004136        	entry	a1, 32
    for (x = 0; x < 8; x++) {
42002017:	070c      	movi.n	a7, 0
42002019:	000786        	j	4200203b <panic_print_hex+0x27>
        c = (h >> 28) & 0xf; // extract the leftmost byte
4200201c:	35ac20        	extui	a10, a2, 28, 4
        if (c < 10) {
4200201f:	980c      	movi.n	a8, 9
42002021:	0b28a7        	blt	a8, a10, 42002030 <panic_print_hex+0x1c>
            panic_print_char('0' + c);
42002024:	30caa2        	addi	a10, a10, 48
42002027:	fffae5        	call8	42001fd4 <panic_print_char>
4200202a:	000206        	j	42002036 <panic_print_hex+0x22>
4200202d:	000000        	ill
            panic_print_char('a' + c - 10);
42002030:	57caa2        	addi	a10, a10, 87
42002033:	fffa25        	call8	42001fd4 <panic_print_char>
        h <<= 4; // move the 2nd leftmost byte to the left, to be extracted next
42002036:	1122c0        	slli	a2, a2, 4
    for (x = 0; x < 8; x++) {
42002039:	771b      	addi.n	a7, a7, 1
4200203b:	dd87a6        	blti	a7, 8, 4200201c <panic_print_hex+0x8>
}
4200203e:	f01d      	retw.n

42002040 <panic_print_dec>:
{
42002040:	004136        	entry	a1, 32
    n1 = d % 10; // extract ones digit
42002043:	f89571        	l32r	a7, 42000298 <_stext+0x278> (66666667 <_rtc_reserved_end+0x6566667>)
42002046:	b27270        	mulsh	a7, a2, a7
42002049:	217270        	srai	a7, a7, 2
4200204c:	318f20        	srai	a8, a2, 31
4200204f:	c07780        	sub	a7, a7, a8
42002052:	07ad      	mov.n	a10, a7
42002054:	a07770        	addx4	a7, a7, a7
42002057:	777a      	add.n	a7, a7, a7
42002059:	c07270        	sub	a7, a2, a7
    if (n2 == 0) {
4200205c:	008a56        	bnez	a10, 42002068 <panic_print_dec+0x28>
        panic_print_char(' ');
4200205f:	0a2c      	movi.n	a10, 32
42002061:	fff725        	call8	42001fd4 <panic_print_char>
42002064:	000246        	j	42002071 <panic_print_dec+0x31>
42002067:	caa200        	float.s	f10, a2, 0
        panic_print_char(n2 + '0');
4200206a:	a0a030        	addx4	a10, a0, a3
4200206d:	f66574        	ee.srcxxp.2q	q6, q6, a7, a5
42002070:	30c7a2ff 	ee.vmulas.s8.qacc.ld.ip.qup	q0, a15, 32, q6, q5, q4, q7
    panic_print_char(n1 + '0');
42002074:	74a0a0        	extui	a10, a10, 0, 8
42002077:	fff5e5        	call8	42001fd4 <panic_print_char>
}
4200207a:	f01d      	retw.n

4200207c <esp_panic_handler_disable_timg_wdts>:
{
4200207c:	006136        	entry	a1, 48
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
4200207f:	f88781        	l32r	a8, 4200029c <_stext+0x27c> (3c0264b0 <ilg_int_st_bits+0x60>)
42002082:	0898      	l32i.n	a9, a8, 0
42002084:	1888      	l32i.n	a8, a8, 4
42002086:	0199      	s32i.n	a9, a1, 0
42002088:	1189      	s32i.n	a8, a1, 4
    wdt_hal_write_protect_disable(&wdt0_context);
4200208a:	01ad      	mov.n	a10, a1
4200208c:	f82381        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
4200208f:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
42002092:	01ad      	mov.n	a10, a1
42002094:	f82281        	l32r	a8, 4200011c <_stext+0xfc> (40000e04 <wdt_hal_disable>)
42002097:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
4200209a:	01ad      	mov.n	a10, a1
4200209c:	f82181        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
4200209f:	0008e0        	callx8	a8
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
420020a2:	f87f81        	l32r	a8, 420002a0 <_stext+0x280> (3c0264b8 <ilg_int_st_bits+0x68>)
420020a5:	718b      	addi.n	a7, a1, 8
420020a7:	0898      	l32i.n	a9, a8, 0
420020a9:	1888      	l32i.n	a8, a8, 4
420020ab:	2199      	s32i.n	a9, a1, 8
420020ad:	3189      	s32i.n	a8, a1, 12
    wdt_hal_write_protect_disable(&wdt1_context);
420020af:	20a770        	or	a10, a7, a7
420020b2:	f81981        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
420020b5:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
420020b8:	07ad      	mov.n	a10, a7
420020ba:	f81881        	l32r	a8, 4200011c <_stext+0xfc> (40000e04 <wdt_hal_disable>)
420020bd:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
420020c0:	07ad      	mov.n	a10, a7
420020c2:	f81781        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
420020c5:	0008e0        	callx8	a8
}
420020c8:	f01d      	retw.n
	...

420020cc <disable_all_wdts>:
{
420020cc:	004136        	entry	a1, 32
    esp_panic_handler_disable_timg_wdts();
420020cf:	fffae5        	call8	4200207c <esp_panic_handler_disable_timg_wdts>
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
420020d2:	f87471        	l32r	a7, 420002a4 <_stext+0x284> (3fc9240c <rtc_wdt_ctx>)
420020d5:	20a770        	or	a10, a7, a7
420020d8:	f81081        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
420020db:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
420020de:	20a770        	or	a10, a7, a7
420020e1:	f80e81        	l32r	a8, 4200011c <_stext+0xfc> (40000e04 <wdt_hal_disable>)
420020e4:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420020e7:	20a770        	or	a10, a7, a7
420020ea:	f80d81        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
420020ed:	0008e0        	callx8	a8
}
420020f0:	f01d      	retw.n
	...

420020f4 <esp_panic_handler_enable_rtc_wdt>:
{
420020f4:	006136        	entry	a1, 48
    wdt_hal_context_t rtc_wdt_ctx = RWDT_HAL_CONTEXT_DEFAULT(); // Use a local context variable to avoid race conditions when both cores enter the panic handler
420020f7:	060c      	movi.n	a6, 0
420020f9:	0169      	s32i.n	a6, a1, 0
420020fb:	f80681        	l32r	a8, 42000114 <_stext+0xf4> (60008000 <RTCCNTL>)
420020fe:	1189      	s32i.n	a8, a1, 4
    wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
42002100:	06dd      	mov.n	a13, a6
42002102:	06cd      	mov.n	a12, a6
42002104:	20b660        	or	a11, a6, a6
42002107:	20a110        	or	a10, a1, a1
4200210a:	f85c81        	l32r	a8, 4200027c <_stext+0x25c> (40000dbc <wdt_hal_init>)
4200210d:	0008e0        	callx8	a8
    uint32_t stage_timeout_ticks = (uint32_t)(timeout_ms * rtc_clk_slow_freq_get_hz() / 1000ULL);
42002110:	f82481        	l32r	a8, 420001a0 <_stext+0x180> (403788bc <rtc_clk_slow_freq_get_hz>)
42002113:	0008e0        	callx8	a8
42002116:	827a20        	mull	a7, a10, a2
42002119:	f86381        	l32r	a8, 420002a8 <_stext+0x288> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4200211c:	a27780        	muluh	a7, a7, a8
4200211f:	417670        	srli	a7, a7, 6
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42002122:	01ad      	mov.n	a10, a1
42002124:	f7fd81        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
42002127:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
4200212a:	4d0c      	movi.n	a13, 4
4200212c:	07cd      	mov.n	a12, a7
4200212e:	06bd      	mov.n	a11, a6
42002130:	01ad      	mov.n	a10, a1
42002132:	f81e81        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
42002135:	0008e0        	callx8	a8
    wdt_hal_enable(&rtc_wdt_ctx);
42002138:	01ad      	mov.n	a10, a1
4200213a:	f85181        	l32r	a8, 42000280 <_stext+0x260> (40000df8 <wdt_hal_enable>)
4200213d:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42002140:	01ad      	mov.n	a10, a1
42002142:	f7f781        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
42002145:	0008e0        	callx8	a8
}
42002148:	f01d      	retw.n
	...

4200214c <esp_panic_handler_feed_wdts>:
{
4200214c:	006136        	entry	a1, 48
4200214f:	03eb80        	rsr.prid	a8
42002152:	048d80        	extui	a8, a8, 13, 1
    if (g_panic_entry_count[esp_cpu_get_core_id()] > PANIC_ENTRY_COUNT_MAX) {
42002155:	f85591        	l32r	a9, 420002ac <_stext+0x28c> (3fc92ba8 <g_panic_entry_count>)
42002158:	a08890        	addx4	a8, a8, a9
4200215b:	0888      	l32i.n	a8, a8, 0
4200215d:	0238b6        	bltui	a8, 3, 42002163 <esp_panic_handler_feed_wdts+0x17>
42002160:	002086        	j	420021e6 <esp_panic_handler_feed_wdts+0x9a>
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42002163:	f84e81        	l32r	a8, 4200029c <_stext+0x27c> (3c0264b0 <ilg_int_st_bits+0x60>)
42002166:	0898      	l32i.n	a9, a8, 0
42002168:	1888      	l32i.n	a8, a8, 4
4200216a:	0199      	s32i.n	a9, a1, 0
4200216c:	1189      	s32i.n	a8, a1, 4
    if (wdt_hal_is_enabled(&wdt0_context)) {
4200216e:	01ad      	mov.n	a10, a1
42002170:	f85081        	l32r	a8, 420002b0 <_stext+0x290> (40000e34 <wdt_hal_is_enabled>)
42002173:	0008e0        	callx8	a8
42002176:	7a9c      	beqz.n	a10, 42002191 <esp_panic_handler_feed_wdts+0x45>
        wdt_hal_write_protect_disable(&wdt0_context);
42002178:	20a110        	or	a10, a1, a1
4200217b:	f7e781        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
4200217e:	0008e0        	callx8	a8
        wdt_hal_feed(&wdt0_context);
42002181:	01ad      	mov.n	a10, a1
42002183:	f80981        	l32r	a8, 420001a8 <_stext+0x188> (40000e1c <wdt_hal_feed>)
42002186:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&wdt0_context);
42002189:	01ad      	mov.n	a10, a1
4200218b:	f7e581        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
4200218e:	0008e0        	callx8	a8
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42002191:	f84381        	l32r	a8, 420002a0 <_stext+0x280> (3c0264b8 <ilg_int_st_bits+0x68>)
42002194:	a18b      	addi.n	a10, a1, 8
42002196:	0898      	l32i.n	a9, a8, 0
42002198:	1888      	l32i.n	a8, a8, 4
4200219a:	2199      	s32i.n	a9, a1, 8
4200219c:	1a89      	s32i.n	a8, a10, 4
    if (wdt_hal_is_enabled(&wdt1_context)) {
4200219e:	f84481        	l32r	a8, 420002b0 <_stext+0x290> (40000e34 <wdt_hal_is_enabled>)
420021a1:	0008e0        	callx8	a8
420021a4:	8a9c      	beqz.n	a10, 420021c0 <esp_panic_handler_feed_wdts+0x74>
        wdt_hal_write_protect_disable(&wdt1_context);
420021a6:	718b      	addi.n	a7, a1, 8
420021a8:	07ad      	mov.n	a10, a7
420021aa:	f7db81        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
420021ad:	0008e0        	callx8	a8
        wdt_hal_feed(&wdt1_context);
420021b0:	07ad      	mov.n	a10, a7
420021b2:	f7fd81        	l32r	a8, 420001a8 <_stext+0x188> (40000e1c <wdt_hal_feed>)
420021b5:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&wdt1_context);
420021b8:	07ad      	mov.n	a10, a7
420021ba:	f7d981        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
420021bd:	0008e0        	callx8	a8
    if (wdt_hal_is_enabled(&rtc_wdt_ctx)) {
420021c0:	f839a1        	l32r	a10, 420002a4 <_stext+0x284> (3fc9240c <rtc_wdt_ctx>)
420021c3:	f83b81        	l32r	a8, 420002b0 <_stext+0x290> (40000e34 <wdt_hal_is_enabled>)
420021c6:	0008e0        	callx8	a8
420021c9:	9a9c      	beqz.n	a10, 420021e6 <esp_panic_handler_feed_wdts+0x9a>
        wdt_hal_write_protect_disable(&rtc_wdt_ctx);
420021cb:	f83671        	l32r	a7, 420002a4 <_stext+0x284> (3fc9240c <rtc_wdt_ctx>)
420021ce:	07ad      	mov.n	a10, a7
420021d0:	f7d281        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
420021d3:	0008e0        	callx8	a8
        wdt_hal_feed(&rtc_wdt_ctx);
420021d6:	07ad      	mov.n	a10, a7
420021d8:	f7f481        	l32r	a8, 420001a8 <_stext+0x188> (40000e1c <wdt_hal_feed>)
420021db:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420021de:	07ad      	mov.n	a10, a7
420021e0:	f7d081        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
420021e3:	0008e0        	callx8	a8
}
420021e6:	f01d      	retw.n

420021e8 <esp_panic_handler_increment_entry_count>:
{
420021e8:	004136        	entry	a1, 32
420021eb:	03eb90        	rsr.prid	a9
420021ee:	049d90        	extui	a9, a9, 13, 1
    g_panic_entry_count[core_id]++;
420021f1:	f82e81        	l32r	a8, 420002ac <_stext+0x28c> (3fc92ba8 <g_panic_entry_count>)
420021f4:	a09980        	addx4	a9, a9, a8
420021f7:	002982        	l32i	a8, a9, 0
420021fa:	01c882        	addi	a8, a8, 1
420021fd:	0989      	s32i.n	a8, a9, 0
    if (g_panic_entry_count[core_id] > PANIC_ENTRY_COUNT_MAX) {
420021ff:	0838b6        	bltui	a8, 3, 4200220b <esp_panic_handler_increment_entry_count+0x23>
        panic_print_str("Panic handler entered multiple times. Abort panic handling. Rebooting ...\r\n");
42002202:	f82ca1        	l32r	a10, 420002b4 <_stext+0x294> (3c020868 <_flash_rodata_start+0x748>)
42002205:	ffde25        	call8	42001fe8 <panic_print_str>
        panic_restart();
42002208:	002da5        	call8	420024e4 <panic_restart>
}
4200220b:	f01d      	retw.n
4200220d:	000000        	ill

42002210 <esp_panic_handler>:
{
42002210:	006136        	entry	a1, 48
42002213:	027d      	mov.n	a7, a2
    esp_panic_handler_feed_wdts();
42002215:	fff365        	call8	4200214c <esp_panic_handler_feed_wdts>
    if (g_panic_abort) {
42002218:	f82981        	l32r	a8, 420002bc <_stext+0x29c> (3fc94d3c <g_panic_abort>)
4200221b:	000882        	l8ui	a8, a8, 0
4200221e:	b89c      	beqz.n	a8, 4200223d <esp_panic_handler+0x2d>
        info->description = NULL;
42002220:	080c      	movi.n	a8, 0
42002222:	3289      	s32i.n	a8, a2, 12
        info->details = g_panic_abort_details ? print_abort_details : NULL;
42002224:	f81c81        	l32r	a8, 42000294 <_stext+0x274> (3fc94d38 <g_panic_abort_details>)
42002227:	0888      	l32i.n	a8, a8, 0
42002229:	488c      	beqz.n	a8, 42002231 <esp_panic_handler+0x21>
4200222b:	f82381        	l32r	a8, 420002b8 <_stext+0x298> (42002004 <print_abort_details>)
4200222e:	000046        	j	42002233 <esp_panic_handler+0x23>
42002231:	080c      	movi.n	a8, 0
42002233:	4789      	s32i.n	a8, a7, 16
        info->reason = NULL;
42002235:	080c      	movi.n	a8, 0
42002237:	2789      	s32i.n	a8, a7, 8
        info->exception = PANIC_EXCEPTION_ABORT;
42002239:	380c      	movi.n	a8, 3
4200223b:	1789      	s32i.n	a8, a7, 4
    if (info->reason) {
4200223d:	2788      	l32i.n	a8, a7, 8
4200223f:	a89c      	beqz.n	a8, 4200225d <esp_panic_handler+0x4d>
        panic_print_str("Guru Meditation Error: Core ");
42002241:	f81fa1        	l32r	a10, 420002c0 <_stext+0x2a0> (3c0208b4 <_flash_rodata_start+0x794>)
42002244:	ffda25        	call8	42001fe8 <panic_print_str>
        panic_print_dec(info->core);
42002247:	07a8      	l32i.n	a10, a7, 0
42002249:	ffdf65        	call8	42002040 <panic_print_dec>
        panic_print_str(" panic'ed (");
4200224c:	f81ea1        	l32r	a10, 420002c4 <_stext+0x2a4> (3c0208d4 <_flash_rodata_start+0x7b4>)
4200224f:	ffd9a5        	call8	42001fe8 <panic_print_str>
        panic_print_str(info->reason);
42002252:	27a8      	l32i.n	a10, a7, 8
42002254:	ffd925        	call8	42001fe8 <panic_print_str>
        panic_print_str("). ");
42002257:	f81ca1        	l32r	a10, 420002c8 <_stext+0x2a8> (3c0208e0 <_flash_rodata_start+0x7c0>)
4200225a:	ffd8e5        	call8	42001fe8 <panic_print_str>
    if (info->description) {
4200225d:	37a8      	l32i.n	a10, a7, 12
4200225f:	002a16        	beqz	a10, 42002265 <esp_panic_handler+0x55>
        panic_print_str(info->description);
42002262:	ffd865        	call8	42001fe8 <panic_print_str>
    panic_print_str("\r\n");
42002265:	f819a1        	l32r	a10, 420002cc <_stext+0x2ac> (3c020934 <_flash_rodata_start+0x814>)
42002268:	ffd7e5        	call8	42001fe8 <panic_print_str>
    PANIC_INFO_DUMP(info, details);
4200226b:	4788      	l32i.n	a8, a7, 16
4200226d:	388c      	beqz.n	a8, 42002274 <esp_panic_handler+0x64>
4200226f:	77a8      	l32i.n	a10, a7, 28
42002271:	0008e0        	callx8	a8
    panic_print_str("\r\n");
42002274:	f816a1        	l32r	a10, 420002cc <_stext+0x2ac> (3c020934 <_flash_rodata_start+0x814>)
42002277:	ffd725        	call8	42001fe8 <panic_print_str>
    RER(reg, dcr);
4200227a:	f81581        	l32r	a8, 420002d0 <_stext+0x2b0> (10200c <UserFrameTotalSize+0x101f0c>)
4200227d:	406880        	rer	a8, a8
    if (esp_cpu_dbgr_is_attached()) {
42002280:	486807        	bbci	a8, 0, 420022cc <esp_panic_handler+0xbc>
        if (info->pseudo_excause) {
42002283:	200782        	l8ui	a8, a7, 32
42002286:	388c      	beqz.n	a8, 4200228d <esp_panic_handler+0x7d>
            panic_reason_str = (char *)info->reason;
42002288:	27a8      	l32i.n	a10, a7, 8
4200228a:	000306        	j	4200229a <esp_panic_handler+0x8a>
        } else if (g_panic_abort) {
4200228d:	f80b81        	l32r	a8, 420002bc <_stext+0x29c> (3fc94d3c <g_panic_abort>)
42002290:	000882        	l8ui	a8, a8, 0
42002293:	889c      	beqz.n	a8, 420022af <esp_panic_handler+0x9f>
            panic_reason_str = g_panic_abort_details;
42002295:	f7ff81        	l32r	a8, 42000294 <_stext+0x274> (3fc94d38 <g_panic_abort_details>)
42002298:	08a8      	l32i.n	a10, a8, 0
        if (panic_reason_str) {
4200229a:	011a16        	beqz	a10, 420022af <esp_panic_handler+0x9f>
            long args[] = {(long)panic_reason_str, strlen(panic_reason_str)};
4200229d:	01a9      	s32i.n	a10, a1, 0
4200229f:	f81181        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
420022a2:	0008e0        	callx8	a8
420022a5:	11a9      	s32i.n	a10, a1, 4
 *
 * @return  return value from the host
 */
static inline long semihosting_call_noerrno(long id, long *data)
{
    register long a2 asm ("a2") = id;
420022a7:	16a122        	movi	a2, 0x116
    register long a3 asm ("a3") = (long)data;
420022aa:	013d      	mov.n	a3, a1

    __asm__ __volatile__ (
420022ac:	0041e0        	break	1, 14
        panic_print_str("Setting breakpoint at 0x");
420022af:	f809a1        	l32r	a10, 420002d4 <_stext+0x2b4> (3c0208e4 <_flash_rodata_start+0x7c4>)
420022b2:	ffd365        	call8	42001fe8 <panic_print_str>
        panic_print_hex((uint32_t)info->addr);
420022b5:	67a8      	l32i.n	a10, a7, 24
420022b7:	ffd5e5        	call8	42002014 <panic_print_hex>
        panic_print_str(" and returning...\r\n");
420022ba:	f807a1        	l32r	a10, 420002d8 <_stext+0x2b8> (3c020900 <_flash_rodata_start+0x7e0>)
420022bd:	ffd2a5        	call8	42001fe8 <panic_print_str>
        disable_all_wdts();
420022c0:	ffe0a5        	call8	420020cc <disable_all_wdts>
        esp_cpu_set_breakpoint(0, info->addr); // use breakpoint 0
420022c3:	67b8      	l32i.n	a11, a7, 24
420022c5:	0a0c      	movi.n	a10, 0
420022c7:	15a8e5        	call8	42017d54 <esp_cpu_set_breakpoint>
}
420022ca:	f01d      	retw.n
    esp_panic_handler_feed_wdts();
420022cc:	ffe7e5        	call8	4200214c <esp_panic_handler_feed_wdts>
    PANIC_INFO_DUMP(info, state);
420022cf:	5788      	l32i.n	a8, a7, 20
420022d1:	004816        	beqz	a8, 420022d9 <esp_panic_handler+0xc9>
420022d4:	77a8      	l32i.n	a10, a7, 28
420022d6:	0008e0        	callx8	a8
    panic_print_str("\r\n");
420022d9:	f7fc21        	l32r	a2, 420002cc <_stext+0x2ac> (3c020934 <_flash_rodata_start+0x814>)
420022dc:	20a220        	or	a10, a2, a2
420022df:	ffd0a5        	call8	42001fe8 <panic_print_str>
    g_panic_abort = false;
420022e2:	f7f681        	l32r	a8, 420002bc <_stext+0x29c> (3fc94d3c <g_panic_abort>)
420022e5:	00a092        	movi	a9, 0
420022e8:	004892        	s8i	a9, a8, 0
    panic_print_str("\r\nELF file SHA256: ");
420022eb:	f7fca1        	l32r	a10, 420002dc <_stext+0x2bc> (3c020914 <_flash_rodata_start+0x7f4>)
420022ee:	ffcfa5        	call8	42001fe8 <panic_print_str>
    panic_print_str(esp_app_get_elf_sha256_str());
420022f1:	f74ba1        	l32r	a10, 42000020 <_stext> (3fc94cc8 <app_elf_sha256_str>)
420022f4:	ffcf25        	call8	42001fe8 <panic_print_str>
    panic_print_str("\r\n");
420022f7:	02ad      	mov.n	a10, a2
420022f9:	ffcee5        	call8	42001fe8 <panic_print_str>
    panic_print_str("\r\n");
420022fc:	02ad      	mov.n	a10, a2
420022fe:	ffcea5        	call8	42001fe8 <panic_print_str>
    esp_panic_handler_feed_wdts();
42002301:	ffe4a5        	call8	4200214c <esp_panic_handler_feed_wdts>
    if (esp_reset_reason_get_hint() == ESP_RST_UNKNOWN) {
42002304:	f7f981        	l32r	a8, 420002e8 <_stext+0x2c8> (40377cf8 <esp_reset_reason_get_hint>)
42002307:	0008e0        	callx8	a8
4200230a:	aaec      	bnez.n	a10, 42002338 <esp_panic_handler+0x128>
        switch (info->exception) {
4200230c:	1788      	l32i.n	a8, a7, 4
4200230e:	061826        	beqi	a8, 1, 42002318 <esp_panic_handler+0x108>
42002311:	0f2826        	beqi	a8, 2, 42002324 <esp_panic_handler+0x114>
42002314:	000606        	j	42002330 <esp_panic_handler+0x120>
42002317:	5a0c00        	msub.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_INT_WDT);
4200231a:	f7f481        	l32r	a8, 420002ec <_stext+0x2cc> (40377cf0 <esp_reset_reason_set_hint>)
4200231d:	0008e0        	callx8	a8
            break;
42002320:	000506        	j	42002338 <esp_panic_handler+0x128>
42002323:	6a0c00        	maddn.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_TASK_WDT);
42002326:	f7f181        	l32r	a8, 420002ec <_stext+0x2cc> (40377cf0 <esp_reset_reason_set_hint>)
42002329:	0008e0        	callx8	a8
            break;
4200232c:	000206        	j	42002338 <esp_panic_handler+0x128>
4200232f:	4a0c00        	madd.s	f0, f12, f0
            esp_reset_reason_set_hint(ESP_RST_PANIC);
42002332:	f7ee81        	l32r	a8, 420002ec <_stext+0x2cc> (40377cf0 <esp_reset_reason_set_hint>)
42002335:	0008e0        	callx8	a8
    panic_print_str("Rebooting...\r\n");
42002338:	f7eaa1        	l32r	a10, 420002e0 <_stext+0x2c0> (3c020928 <_flash_rodata_start+0x808>)
4200233b:	ffcae5        	call8	42001fe8 <panic_print_str>
    panic_restart();
4200233e:	001a65        	call8	420024e4 <panic_restart>
42002341:	000000        	ill

42002344 <frame_to_panic_info>:
{
42002344:	004136        	entry	a1, 32
    asm volatile (
42002347:	03eb80        	rsr.prid	a8
4200234a:	048d80        	extui	a8, a8, 13, 1
    info->core = esp_cpu_get_core_id();
4200234d:	0389      	s32i.n	a8, a3, 0
    info->exception = PANIC_EXCEPTION_FAULT;
4200234f:	480c      	movi.n	a8, 4
42002351:	1389      	s32i.n	a8, a3, 4
    info->details = NULL;
42002353:	080c      	movi.n	a8, 0
42002355:	4389      	s32i.n	a8, a3, 16
    info->reason = "Unknown";
42002357:	f7e681        	l32r	a8, 420002f0 <_stext+0x2d0> (3c020938 <_flash_rodata_start+0x818>)
4200235a:	2389      	s32i.n	a8, a3, 8
    info->pseudo_excause = panic_soc_check_pseudo_cause(frame, info) | pseudo_excause;
4200235c:	03bd      	mov.n	a11, a3
4200235e:	02ad      	mov.n	a10, a2
42002360:	141ce5        	call8	42016530 <panic_soc_check_pseudo_cause>
42002363:	208a40        	or	a8, a10, a4
42002366:	748080        	extui	a8, a8, 0, 8
42002369:	204382        	s8i	a8, a3, 32
    if (info->pseudo_excause) {
4200236c:	a88c      	beqz.n	a8, 4200237a <frame_to_panic_info+0x36>
        panic_soc_fill_info(frame, info);
4200236e:	03bd      	mov.n	a11, a3
42002370:	02ad      	mov.n	a10, a2
42002372:	003c65        	call8	42002738 <panic_soc_fill_info>
42002375:	000286        	j	42002383 <frame_to_panic_info+0x3f>
42002378:	300000        	xor	a0, a0, a0
        panic_arch_fill_info(frame, info);
4200237b:	b3          	.byte	0xb3
4200237c:	a22020        	muluh	a2, a0, a2
4200237f:	20          	.byte	0x20
42002380:	003825        	call8	42002704 <panic_arch_fill_info>
    info->state = print_state;
42002383:	f7dc81        	l32r	a8, 420002f4 <_stext+0x2d4> (420024a0 <print_state>)
42002386:	056382        	s32i	a8, a3, 20
    info->frame = frame;
42002389:	7329      	s32i.n	a2, a3, 28
}
4200238b:	f01d      	retw.n
4200238d:	000000        	ill

42002390 <panic_handler>:
{
42002390:	00a136        	entry	a1, 80
    esp_panic_handler_increment_entry_count();
42002393:	ffe565        	call8	420021e8 <esp_panic_handler_increment_entry_count>
    panic_info_t info = { 0 };
42002396:	24a0c2        	movi	a12, 36
42002399:	00a0b2        	movi	a11, 0
4200239c:	01ad      	mov.n	a10, a1
4200239e:	f7d981        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420023a1:	0008e0        	callx8	a8
420023a4:	03eb60        	rsr.prid	a6
420023a7:	046d60        	extui	a6, a6, 13, 1
420023aa:	067d      	mov.n	a7, a6
    g_exc_frames[core_id] = frame;
420023ac:	f7d381        	l32r	a8, 420002f8 <_stext+0x2d8> (3fc94d40 <g_exc_frames>)
420023af:	a08680        	addx4	a8, a6, a8
420023b2:	0829      	s32i.n	a2, a8, 0
    if (pseudo_excause) {
420023b4:	048316        	beqz	a3, 42002400 <panic_handler+0x70>
        if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0 && core_id == 1) {
420023b7:	02ad      	mov.n	a10, a2
420023b9:	141865        	call8	42016540 <panic_get_cause>
420023bc:	055a66        	bnei	a10, 5, 420023c5 <panic_handler+0x35>
420023bf:	021666        	bnei	a6, 1, 420023c5 <panic_handler+0x35>
420023c2:	ffff06        	j	420023c2 <panic_handler+0x32>
        } else if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1 && core_id == 0) {
420023c5:	02ad      	mov.n	a10, a2
420023c7:	1417a5        	call8	42016540 <panic_get_cause>
420023ca:	076a66        	bnei	a10, 6, 420023d5 <panic_handler+0x45>
420023cd:	47cc      	bnez.n	a7, 420023d5 <panic_handler+0x45>
420023cf:	ffff06        	j	420023cf <panic_handler+0x3f>
420023d2:	000000        	ill
        } else if (panic_get_cause(frame) == PANIC_RSN_CACHEERR) {
420023d5:	20a220        	or	a10, a2, a2
420023d8:	141665        	call8	42016540 <panic_get_cause>
420023db:	217a66        	bnei	a10, 7, 42002400 <panic_handler+0x70>
            if (esp_cache_err_get_cpuid() == -1) {
420023de:	ffa4e5        	call8	42001e2c <esp_cache_err_get_cpuid>
420023e1:	070a66        	bnei	a10, -1, 420023ec <panic_handler+0x5c>
                if (core_id != 0) {
420023e4:	018716        	beqz	a7, 42002400 <panic_handler+0x70>
420023e7:	ffff06        	j	420023e7 <panic_handler+0x57>
420023ea:	e50000        	extui	a0, a0, 16, 15
            } else if (core_id != esp_cache_err_get_cpuid()) {
420023ed:	a3          	.byte	0xa3
420023ee:	0d1a77ff 	ee.vmulas.s16.accx.ld.ip.qup	q3, a15, -144, q5, q6, q1, q2
                g_exc_frames[core_id] = NULL; // Only print the backtrace for the offending core
420023f2:	f7c181        	l32r	a8, 420002f8 <_stext+0x2d8> (3fc94d40 <g_exc_frames>)
420023f5:	a08680        	addx4	a8, a6, a8
420023f8:	090c      	movi.n	a9, 0
420023fa:	0899      	s32i.n	a9, a8, 0
                busy_wait();
420023fc:	ffff06        	j	420023fc <panic_handler+0x6c>
420023ff:	00          	.byte	00
    esp_panic_handler_enable_rtc_wdt(10000);
42002400:	f79ca1        	l32r	a10, 42000270 <_stext+0x250> (2710 <UserFrameTotalSize+0x2610>)
42002403:	ffcf25        	call8	420020f4 <esp_panic_handler_enable_rtc_wdt>
    esp_panic_handler_disable_timg_wdts();
42002406:	ffc765        	call8	4200207c <esp_panic_handler_disable_timg_wdts>
    esp_rom_delay_us(1);
42002409:	1a0c      	movi.n	a10, 1
4200240b:	f73581        	l32r	a8, 420000e0 <_stext+0xc0> (40000600 <esp_rom_delay_us>)
4200240e:	0008e0        	callx8	a8
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002411:	070c      	movi.n	a7, 0
42002413:	000446        	j	42002428 <panic_handler+0x98>
42002416:	000000        	ill
        if (i != core_id) {
42002419:	081767        	beq	a7, a6, 42002425 <panic_handler+0x95>
            esp_cpu_stall(i);
4200241c:	20a770        	or	a10, a7, a7
4200241f:	f7ba81        	l32r	a8, 42000308 <_stext+0x2e8> (40377d2c <esp_cpu_stall>)
42002422:	0008e0        	callx8	a8
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
42002425:	01c772        	addi	a7, a7, 1
42002428:	ed27b6        	bltui	a7, 2, 42002419 <panic_handler+0x89>
    esp_ipc_isr_stall_abort();
4200242b:	f7b881        	l32r	a8, 4200030c <_stext+0x2ec> (40375a10 <esp_ipc_isr_stall_abort>)
4200242e:	0008e0        	callx8	a8
    RER(reg, dcr);
42002431:	f7a781        	l32r	a8, 420002d0 <_stext+0x2b0> (10200c <UserFrameTotalSize+0x101f0c>)
42002434:	406880        	rer	a8, a8
    if (esp_cpu_dbgr_is_attached()) {
42002437:	2d6807        	bbci	a8, 0, 42002468 <panic_handler+0xd8>
        if (!(esp_ptr_executable(esp_cpu_pc_to_addr(panic_get_address(frame))) && (panic_get_address(frame) & 0xC0000000U))) {
4200243a:	20a220        	or	a10, a2, a2
4200243d:	140fa5        	call8	42016538 <panic_get_address>
    return (void *)((pc & 0x3fffffffU) | 0x40000000U);
42002440:	11aae0        	slli	a10, a10, 2
42002443:	41a2a0        	srli	a10, a10, 2
42002446:	f74b81        	l32r	a8, 42000174 <_stext+0x154> (40000000 <_heap_end>)
42002449:	20aa80        	or	a10, a10, a8
4200244c:	f7b181        	l32r	a8, 42000310 <_stext+0x2f0> (40377ef8 <esp_ptr_executable>)
4200244f:	0008e0        	callx8	a8
42002452:	00aa16        	beqz	a10, 42002460 <panic_handler+0xd0>
42002455:	02ad      	mov.n	a10, a2
42002457:	140e25        	call8	42016538 <panic_get_address>
4200245a:	f7a881        	l32r	a8, 420002fc <_stext+0x2dc> (3fffffff <ets_rom_layout_p+0xe0003>)
4200245d:	0738a7        	bltu	a8, a10, 42002468 <panic_handler+0xd8>
            panic_set_address(frame, (uint32_t)&_invalid_pc_placeholder);
42002460:	f7a8b1        	l32r	a11, 42000300 <_stext+0x2e0> (40374400 <_invalid_pc_placeholder>)
42002463:	02ad      	mov.n	a10, a2
42002465:	140e25        	call8	42016548 <panic_set_address>
    frame_to_panic_info(frame, &info, pseudo_excause);
42002468:	03cd      	mov.n	a12, a3
4200246a:	01bd      	mov.n	a11, a1
4200246c:	02ad      	mov.n	a10, a2
4200246e:	ffed65        	call8	42002344 <frame_to_panic_info>
    esp_panic_handler(&info);
42002471:	01ad      	mov.n	a10, a1
42002473:	ffd9e5        	call8	42002210 <esp_panic_handler>
}
42002476:	f01d      	retw.n

42002478 <print_state_for_core>:
{
42002478:	004136        	entry	a1, 32
    if (!g_panic_abort) {
4200247b:	f79081        	l32r	a8, 420002bc <_stext+0x29c> (3fc94d3c <g_panic_abort>)
4200247e:	000882        	l8ui	a8, a8, 0
42002481:	00d856        	bnez	a8, 42002492 <print_state_for_core+0x1a>
        panic_print_registers(f, core);
42002484:	20b330        	or	a11, a3, a3
42002487:	02ad      	mov.n	a10, a2
42002489:	001a25        	call8	4200262c <panic_print_registers>
        panic_print_str("\r\n");
4200248c:	f7a2a1        	l32r	a10, 42000314 <_stext+0x2f4> (3c020934 <_flash_rodata_start+0x814>)
4200248f:	ffb5a5        	call8	42001fe8 <panic_print_str>
    panic_print_backtrace(f, core);
42002492:	20b330        	or	a11, a3, a3
42002495:	20a220        	or	a10, a2, a2
42002498:	003025        	call8	4200279c <panic_print_backtrace>
}
4200249b:	000090        	retw
	...

420024a0 <print_state>:
{
420024a0:	004136        	entry	a1, 32
420024a3:	02ad      	mov.n	a10, a2
    int err_core = f == g_exc_frames[0] ? 0 : 1;
420024a5:	f79481        	l32r	a8, 420002f8 <_stext+0x2d8> (3fc94d40 <g_exc_frames>)
420024a8:	0888      	l32i.n	a8, a8, 0
420024aa:	c08820        	sub	a8, a8, a2
420024ad:	120c      	movi.n	a2, 1
420024af:	832880        	moveqz	a2, a8, a8
    print_state_for_core(f, err_core);
420024b2:	02bd      	mov.n	a11, a2
420024b4:	fffc25        	call8	42002478 <print_state_for_core>
    panic_print_str("\r\n");
420024b7:	f797a1        	l32r	a10, 42000314 <_stext+0x2f4> (3c020934 <_flash_rodata_start+0x814>)
420024ba:	ffb2e5        	call8	42001fe8 <panic_print_str>
    for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420024bd:	070c      	movi.n	a7, 0
420024bf:	000706        	j	420024df <print_state+0x3f>
        if (err_core != i && g_exc_frames[i] != NULL) {
420024c2:	171727        	beq	a7, a2, 420024dd <print_state+0x3d>
420024c5:	f78c81        	l32r	a8, 420002f8 <_stext+0x2d8> (3fc94d40 <g_exc_frames>)
420024c8:	a08780        	addx4	a8, a7, a8
420024cb:	0028a2        	l32i	a10, a8, 0
420024ce:	00ba16        	beqz	a10, 420024dd <print_state+0x3d>
            print_state_for_core(g_exc_frames[i], i);
420024d1:	20b770        	or	a11, a7, a7
420024d4:	fffa25        	call8	42002478 <print_state_for_core>
            panic_print_str("\r\n");
420024d7:	f78fa1        	l32r	a10, 42000314 <_stext+0x2f4> (3c020934 <_flash_rodata_start+0x814>)
420024da:	ffb0e5        	call8	42001fe8 <panic_print_str>
    for (int i = 0; i < SOC_CPU_CORES_NUM; i++) {
420024dd:	771b      	addi.n	a7, a7, 1
420024df:	df27a6        	blti	a7, 2, 420024c2 <print_state+0x22>
}
420024e2:	f01d      	retw.n

420024e4 <panic_restart>:

void __attribute__((noreturn)) panic_restart(void)
{
420024e4:	004136        	entry	a1, 32
    // On the ESP32, cache error status can only be cleared by system reset
    if (esp_cache_err_get_cpuid() != -1) {
        esp_restart_noos_dig();
    }
#endif
    esp_restart_noos();
420024e7:	f6f581        	l32r	a8, 420000bc <_stext+0x9c> (403757b8 <esp_restart_noos>)
420024ea:	0008e0        	callx8	a8
420024ed:	000000        	ill

420024f0 <esp_ipc_isr_init>:
{
420024f0:	004136        	entry	a1, 32
    asm volatile (
420024f3:	03eb70        	rsr.prid	a7
420024f6:	047d70        	extui	a7, a7, 13, 1
    esp_ipc_isr_port_init(cpuid);
420024f9:	20a770        	or	a10, a7, a7
420024fc:	000125        	call8	42002510 <esp_ipc_isr_port_init>
    if (cpuid != 0) {
420024ff:	00a716        	beqz	a7, 4200250d <esp_ipc_isr_init+0x1d>
        s_stall_state = STALL_STATE_RUNNING;
42002502:	f78581        	l32r	a8, 42000318 <_stext+0x2f8> (3fc94d48 <s_stall_state>)
42002505:	01a092        	movi	a9, 1
42002508:	0020c0        	memw
4200250b:	0899      	s32i.n	a9, a8, 0
}
4200250d:	f01d      	retw.n
	...

42002510 <esp_ipc_isr_port_init>:
#include "esp_intr_alloc.h"
#include "esp_attr.h"
#include "sdkconfig.h"

void esp_ipc_isr_port_init(const int cpuid)
{
42002510:	004136        	entry	a1, 32
    uint32_t intr_source = SYS_CPU_INTR_FROM_CPU_2_SOURCE + cpuid; // ETS_FROM_CPU_INTR2_SOURCE and ETS_FROM_CPU_INTR3_SOURCE
42002513:	51c272        	addi	a7, a2, 81
    ESP_INTR_DISABLE(ETS_IPC_ISR_INUM);
42002516:	ca1c      	movi.n	a10, 28
42002518:	f74a81        	l32r	a8, 42000240 <_stext+0x220> (40376644 <esp_intr_disable_source>)
4200251b:	0008e0        	callx8	a8
    esp_rom_route_intr_matrix(cpuid, intr_source, ETS_IPC_ISR_INUM);
4200251e:	cc1c      	movi.n	a12, 28
42002520:	07bd      	mov.n	a11, a7
42002522:	02ad      	mov.n	a10, a2
42002524:	f70081        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42002527:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_IPC_ISR_INUM);
4200252a:	ca1c      	movi.n	a10, 28
4200252c:	f74681        	l32r	a8, 42000244 <_stext+0x224> (40376578 <esp_intr_enable_source>)
4200252f:	0008e0        	callx8	a8
}
42002532:	f01d      	retw.n

42002534 <print_debug_exception_details>:
    panic_print_str(" ");
    panic_print_hex(*(pepc + 2));
}

static void print_debug_exception_details(const void *f)
{
42002534:	004136        	entry	a1, 32
    int debug_rsn;
    asm("rsr.debugcause %0":"=r"(debug_rsn));
42002537:	03e970        	rsr.debugcause	a7
    panic_print_str("Debug exception reason: ");
4200253a:	f778a1        	l32r	a10, 4200031c <_stext+0x2fc> (3c020940 <_flash_rodata_start+0x820>)
4200253d:	ffaaa5        	call8	42001fe8 <panic_print_str>
    if (debug_rsn & XCHAL_DEBUGCAUSE_ICOUNT_MASK) {
42002540:	056707        	bbci	a7, 0, 42002549 <print_debug_exception_details+0x15>
        panic_print_str("SingleStep ");
42002543:	f777a1        	l32r	a10, 42000320 <_stext+0x300> (3c02095c <_flash_rodata_start+0x83c>)
42002546:	ffaa25        	call8	42001fe8 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_IBREAK_MASK) {
42002549:	056717        	bbci	a7, 1, 42002552 <print_debug_exception_details+0x1e>
        panic_print_str("HwBreakpoint ");
4200254c:	f776a1        	l32r	a10, 42000324 <_stext+0x304> (3c020968 <_flash_rodata_start+0x848>)
4200254f:	ffa9a5        	call8	42001fe8 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DBREAK_MASK) {
42002552:	116727        	bbci	a7, 2, 42002567 <print_debug_exception_details+0x33>
        //Unlike what the ISA manual says, this core seemingly distinguishes from a DBREAK
        //reason caused by watchdog 0 and one caused by watchdog 1 by setting bit 8 of the
        //debugcause if the cause is watchpoint 1 and clearing it if it's watchpoint 0.
        if (debug_rsn & (1 << 8)) {
42002555:	086787        	bbci	a7, 8, 42002561 <print_debug_exception_details+0x2d>
            const char *name = pcTaskGetName(xTaskGetCurrentTaskHandleForCore(core));
            panic_print_str("Stack canary watchpoint triggered (");
            panic_print_str(name);
            panic_print_str(") ");
#else
            panic_print_str("Watchpoint 1 triggered ");
42002558:	f774a1        	l32r	a10, 42000328 <_stext+0x308> (3c020978 <_flash_rodata_start+0x858>)
4200255b:	ffa8e5        	call8	42001fe8 <panic_print_str>
4200255e:	000146        	j	42002567 <print_debug_exception_details+0x33>
#endif
        } else {
            panic_print_str("Watchpoint 0 triggered ");
42002561:	f772a1        	l32r	a10, 4200032c <_stext+0x30c> (3c020990 <_flash_rodata_start+0x870>)
42002564:	ffa825        	call8	42001fe8 <panic_print_str>
        }
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAK_MASK) {
42002567:	056737        	bbci	a7, 3, 42002570 <print_debug_exception_details+0x3c>
        panic_print_str("BREAK instr ");
4200256a:	f771a1        	l32r	a10, 42000330 <_stext+0x310> (3c0209a8 <_flash_rodata_start+0x888>)
4200256d:	ffa7a5        	call8	42001fe8 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAKN_MASK) {
42002570:	056747        	bbci	a7, 4, 42002579 <print_debug_exception_details+0x45>
        panic_print_str("BREAKN instr ");
42002573:	f770a1        	l32r	a10, 42000334 <_stext+0x314> (3c0209b8 <_flash_rodata_start+0x898>)
42002576:	ffa725        	call8	42001fe8 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DEBUGINT_MASK) {
42002579:	056757        	bbci	a7, 5, 42002582 <print_debug_exception_details+0x4e>
        panic_print_str("DebugIntr ");
4200257c:	f76fa1        	l32r	a10, 42000338 <_stext+0x318> (3c0209c8 <_flash_rodata_start+0x8a8>)
4200257f:	ffa6a5        	call8	42001fe8 <panic_print_str>
    }
}
42002582:	f01d      	retw.n

42002584 <print_illegal_instruction_details>:
{
42002584:	004136        	entry	a1, 32
    uint32_t epc = frame->pc;
42002587:	1288      	l32i.n	a8, a2, 4
    epc = (epc & ~0x3) - 4;
42002589:	c97c      	movi.n	a9, -4
4200258b:	108890        	and	a8, a8, a9
4200258e:	789a      	add.n	a7, a8, a9
    if (epc < SOC_IROM_MASK_LOW || epc >= SOC_IROM_HIGH) {
42002590:	f76b91        	l32r	a9, 4200033c <_stext+0x31c> (bffffffc <_rtc_reserved_end+0x5feffffc>)
42002593:	889a      	add.n	a8, a8, a9
42002595:	f76a91        	l32r	a9, 42000340 <_stext+0x320> (3ffffff <UserFrameTotalSize+0x3fffeff>)
42002598:	383987        	bltu	a9, a8, 420025d4 <print_illegal_instruction_details+0x50>
    panic_print_str("Memory dump at 0x");
4200259b:	f76aa1        	l32r	a10, 42000344 <_stext+0x324> (3c0209d4 <_flash_rodata_start+0x8b4>)
4200259e:	ffa4a5        	call8	42001fe8 <panic_print_str>
    panic_print_hex(epc);
420025a1:	07ad      	mov.n	a10, a7
420025a3:	ffa725        	call8	42002014 <panic_print_hex>
    panic_print_str(": ");
420025a6:	f768a1        	l32r	a10, 42000348 <_stext+0x328> (3c0209e8 <_flash_rodata_start+0x8c8>)
420025a9:	ffa3e5        	call8	42001fe8 <panic_print_str>
    panic_print_hex(*pepc);
420025ac:	0020c0        	memw
420025af:	0027a2        	l32i	a10, a7, 0
420025b2:	ffa625        	call8	42002014 <panic_print_hex>
    panic_print_str(" ");
420025b5:	f76521        	l32r	a2, 4200034c <_stext+0x32c> (3c020a4c <_flash_rodata_start+0x92c>)
420025b8:	20a220        	or	a10, a2, a2
420025bb:	ffa2e5        	call8	42001fe8 <panic_print_str>
    panic_print_hex(*(pepc + 1));
420025be:	0020c0        	memw
420025c1:	0127a2        	l32i	a10, a7, 4
420025c4:	ffa4e5        	call8	42002014 <panic_print_hex>
    panic_print_str(" ");
420025c7:	02ad      	mov.n	a10, a2
420025c9:	ffa1e5        	call8	42001fe8 <panic_print_str>
    panic_print_hex(*(pepc + 2));
420025cc:	0020c0        	memw
420025cf:	27a8      	l32i.n	a10, a7, 8
420025d1:	ffa425        	call8	42002014 <panic_print_hex>
}
420025d4:	f01d      	retw.n
	...

420025d8 <print_cache_err_details>:
    panic_print_str(")\r\n");
}
#endif

static inline void print_cache_err_details(const void *f)
{
420025d8:	006136        	entry	a1, 48
    esp_cache_err_info_t err = {};
420025db:	cc0c      	movi.n	a12, 12
420025dd:	00a0b2        	movi	a11, 0
420025e0:	01ad      	mov.n	a10, a1
420025e2:	f74881        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420025e5:	0008e0        	callx8	a8
    esp_cache_err_get_panic_info(&err);
420025e8:	01ad      	mov.n	a10, a1
420025ea:	ff64a5        	call8	42001c34 <esp_cache_err_get_panic_info>

    if (err.err_str) {
420025ed:	01a8      	l32i.n	a10, a1, 0
420025ef:	5aac      	beqz.n	a10, 42002618 <print_cache_err_details+0x40>
        panic_print_str(err.err_str);
420025f1:	ff9f65        	call8	42001fe8 <panic_print_str>
        if (err.vaddr) {
420025f4:	1188      	l32i.n	a8, a1, 4
420025f6:	00a816        	beqz	a8, 42002604 <print_cache_err_details+0x2c>
            panic_print_str(", error address: 0x");
420025f9:	f755a1        	l32r	a10, 42000350 <_stext+0x330> (3c0209ec <_flash_rodata_start+0x8cc>)
420025fc:	ff9ea5        	call8	42001fe8 <panic_print_str>
            panic_print_hex(err.vaddr);
420025ff:	11a8      	l32i.n	a10, a1, 4
42002601:	ffa125        	call8	42002014 <panic_print_hex>
        }
        if (err.size) {
42002604:	022182        	l32i	a8, a1, 8
42002607:	016816        	beqz	a8, 42002621 <print_cache_err_details+0x49>
            panic_print_str(", error size: 0x");
4200260a:	f752a1        	l32r	a10, 42000354 <_stext+0x334> (3c020a00 <_flash_rodata_start+0x8e0>)
4200260d:	ff9da5        	call8	42001fe8 <panic_print_str>
            panic_print_hex(err.size);
42002610:	21a8      	l32i.n	a10, a1, 8
42002612:	ffa025        	call8	42002014 <panic_print_hex>
42002615:	000206        	j	42002621 <print_cache_err_details+0x49>
        }
    } else {
        // Default to cache disabled message if no specific error is found
        panic_print_str("Cache disabled but cached memory region accessed");
42002618:	f750a1        	l32r	a10, 42000358 <_stext+0x338> (3c020a14 <_flash_rodata_start+0x8f4>)
4200261b:	201110        	or	a1, a1, a1
4200261e:	ff9ca5        	call8	42001fe8 <panic_print_str>
    }
    panic_print_str("\r\n");
42002621:	f74ea1        	l32r	a10, 4200035c <_stext+0x33c> (3c020934 <_flash_rodata_start+0x814>)
42002624:	ff9c25        	call8	42001fe8 <panic_print_str>
}
42002627:	f01d      	retw.n
42002629:	000000        	ill

4200262c <panic_print_registers>:
{
4200262c:	010136        	entry	a1, 128
    const char *sdesc[] = {
4200262f:	60a0c2        	movi	a12, 96
42002632:	f74bb1        	l32r	a11, 42000360 <_stext+0x340> (3c0264c0 <ilg_int_st_bits+0x70>)
42002635:	20a110        	or	a10, a1, a1
42002638:	f67c81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200263b:	0008e0        	callx8	a8
    panic_print_str("Core ");
4200263e:	f749a1        	l32r	a10, 42000364 <_stext+0x344> (3c020a48 <_flash_rodata_start+0x928>)
42002641:	ff9a65        	call8	42001fe8 <panic_print_str>
    panic_print_dec(core);
42002644:	03ad      	mov.n	a10, a3
42002646:	ff9fa5        	call8	42002040 <panic_print_dec>
    panic_print_str(" register dump:");
42002649:	f747a1        	l32r	a10, 42000368 <_stext+0x348> (3c020a50 <_flash_rodata_start+0x930>)
4200264c:	ff99a5        	call8	42001fe8 <panic_print_str>
    for (int x = 0; x < 24; x += 4) {
4200264f:	050c      	movi.n	a5, 0
42002651:	000f06        	j	42002691 <panic_print_registers+0x65>
        panic_print_str("\r\n");
42002654:	f742a1        	l32r	a10, 4200035c <_stext+0x33c> (3c020934 <_flash_rodata_start+0x814>)
42002657:	ff9925        	call8	42001fe8 <panic_print_str>
        for (int y = 0; y < 4; y++) {
4200265a:	070c      	movi.n	a7, 0
4200265c:	000b06        	j	4200268c <panic_print_registers+0x60>
4200265f:	000000        	ill
            if (sdesc[x + y][0] != 0) {
42002662:	657a      	add.n	a6, a5, a7
42002664:	a08610        	addx4	a8, a6, a1
42002667:	08a8      	l32i.n	a10, a8, 0
42002669:	000a82        	l8ui	a8, a10, 0
4200266c:	01a816        	beqz	a8, 4200268a <panic_print_registers+0x5e>
                panic_print_str(sdesc[x + y]);
4200266f:	ff97a5        	call8	42001fe8 <panic_print_str>
                panic_print_str(": 0x");
42002672:	f73ea1        	l32r	a10, 4200036c <_stext+0x34c> (3c020a8c <_flash_rodata_start+0x96c>)
42002675:	ff9725        	call8	42001fe8 <panic_print_str>
                panic_print_hex(regs[x + y + 1]);
42002678:	01c662        	addi	a6, a6, 1
4200267b:	a06620        	addx4	a6, a6, a2
4200267e:	0026a2        	l32i	a10, a6, 0
42002681:	ff9925        	call8	42002014 <panic_print_hex>
                panic_print_str("  ");
42002684:	f73ba1        	l32r	a10, 42000370 <_stext+0x350> (3c020a60 <_flash_rodata_start+0x940>)
42002687:	ff9625        	call8	42001fe8 <panic_print_str>
        for (int y = 0; y < 4; y++) {
4200268a:	771b      	addi.n	a7, a7, 1
4200268c:	d247a6        	blti	a7, 4, 42002662 <panic_print_registers+0x36>
    for (int x = 0; x < 24; x += 4) {
4200268f:	554b      	addi.n	a5, a5, 4
42002691:	17a082        	movi	a8, 23
42002694:	bca857        	bge	a8, a5, 42002654 <panic_print_registers+0x28>
    if (xPortInterruptedFromISRContext()
42002697:	f73c81        	l32r	a8, 42000388 <_stext+0x368> (403768a8 <xPortInterruptedFromISRContext>)
4200269a:	0008e0        	callx8	a8
4200269d:	060a16        	beqz	a10, 42002701 <panic_print_registers+0xd5>
            && ((core == 0 && frame->exccause == PANIC_RSN_INTWDT_CPU0) ||
420026a0:	43cc      	bnez.n	a3, 420026a8 <panic_print_registers+0x7c>
420026a2:	142282        	l32i	a8, a2, 80
420026a5:	085826        	beqi	a8, 5, 420026b1 <panic_print_registers+0x85>
420026a8:	551366        	bnei	a3, 1, 42002701 <panic_print_registers+0xd5>
                (core == 1 && frame->exccause == PANIC_RSN_INTWDT_CPU1))
420026ab:	142282        	l32i	a8, a2, 80
420026ae:	4f6866        	bnei	a8, 6, 42002701 <panic_print_registers+0xd5>
        panic_print_str("\r\n");
420026b1:	f72aa1        	l32r	a10, 4200035c <_stext+0x33c> (3c020934 <_flash_rodata_start+0x814>)
420026b4:	ff9325        	call8	42001fe8 <panic_print_str>
        panic_print_str("Core ");
420026b7:	f72ba1        	l32r	a10, 42000364 <_stext+0x344> (3c020a48 <_flash_rodata_start+0x928>)
420026ba:	ff92e5        	call8	42001fe8 <panic_print_str>
        panic_print_dec(core);
420026bd:	20a330        	or	a10, a3, a3
420026c0:	ff97e5        	call8	42002040 <panic_print_dec>
        panic_print_str(" was running in ISR context:\r\n");
420026c3:	f72ca1        	l32r	a10, 42000374 <_stext+0x354> (3c020a64 <_flash_rodata_start+0x944>)
420026c6:	ff9225        	call8	42001fe8 <panic_print_str>
        __asm__("rsr.epc1 %0" : "=a"(__value));
420026c9:	03b170        	rsr.epc1	a7
        panic_print_str("EPC1    : 0x");
420026cc:	f72ba1        	l32r	a10, 42000378 <_stext+0x358> (3c020a84 <_flash_rodata_start+0x964>)
420026cf:	ff91a5        	call8	42001fe8 <panic_print_str>
        panic_print_hex(__value);
420026d2:	07ad      	mov.n	a10, a7
420026d4:	ff93e5        	call8	42002014 <panic_print_hex>
        __asm__("rsr.epc2 %0" : "=a"(__value));
420026d7:	03b270        	rsr.epc2	a7
        panic_print_str("  EPC2    : 0x");
420026da:	f728a1        	l32r	a10, 4200037c <_stext+0x35c> (3c020a94 <_flash_rodata_start+0x974>)
420026dd:	ff90a5        	call8	42001fe8 <panic_print_str>
        panic_print_hex(__value);
420026e0:	07ad      	mov.n	a10, a7
420026e2:	ff9325        	call8	42002014 <panic_print_hex>
        __asm__("rsr.epc3 %0" : "=a"(__value));
420026e5:	03b370        	rsr.epc3	a7
        panic_print_str("  EPC3    : 0x");
420026e8:	f726a1        	l32r	a10, 42000380 <_stext+0x360> (3c020aa4 <_flash_rodata_start+0x984>)
420026eb:	ff8fe5        	call8	42001fe8 <panic_print_str>
        panic_print_hex(__value);
420026ee:	07ad      	mov.n	a10, a7
420026f0:	ff9225        	call8	42002014 <panic_print_hex>
        __asm__("rsr.epc4 %0" : "=a"(__value));
420026f3:	03b470        	rsr.epc4	a7
        panic_print_str("  EPC4    : 0x");
420026f6:	f723a1        	l32r	a10, 42000384 <_stext+0x364> (3c020ab4 <_flash_rodata_start+0x994>)
420026f9:	ff8ee5        	call8	42001fe8 <panic_print_str>
        panic_print_hex(__value);
420026fc:	07ad      	mov.n	a10, a7
420026fe:	ff9165        	call8	42002014 <panic_print_hex>
}
42002701:	f01d      	retw.n
	...

42002704 <panic_arch_fill_info>:

void panic_arch_fill_info(void *f, panic_info_t *info)
{
42002704:	004136        	entry	a1, 32
        "LoadProhibited", "StoreProhibited", "res", "res",
        "Cp0Dis", "Cp1Dis", "Cp2Dis", "Cp3Dis",
        "Cp4Dis", "Cp5Dis", "Cp6Dis", "Cp7Dis"
    };

    if (frame->exccause < (sizeof(reason) / sizeof(char *))) {
42002707:	142282        	l32i	a8, a2, 80
4200270a:	792c      	movi.n	a9, 39
4200270c:	0c3987        	bltu	a9, a8, 4200271c <panic_arch_fill_info+0x18>
        info->reason = (reason[frame->exccause]);
4200270f:	f71f91        	l32r	a9, 4200038c <_stext+0x36c> (3c026540 <reason$1>)
42002712:	a08890        	addx4	a8, a8, a9
42002715:	0888      	l32i.n	a8, a8, 0
42002717:	2389      	s32i.n	a8, a3, 8
42002719:	000106        	j	42002721 <panic_arch_fill_info+0x1d>
    } else {
        info->reason = "Unknown";
4200271c:	f71d81        	l32r	a8, 42000390 <_stext+0x370> (3c020938 <_flash_rodata_start+0x818>)
4200271f:	2389      	s32i.n	a8, a3, 8
    }

    info->description = "Exception was unhandled.";
42002721:	f71c81        	l32r	a8, 42000394 <_stext+0x374> (3c020be4 <_flash_rodata_start+0xac4>)
42002724:	3389      	s32i.n	a8, a3, 12
    if (frame->exccause == EXCCAUSE_ILLEGAL) {
42002726:	142282        	l32i	a8, a2, 80
42002729:	38cc      	bnez.n	a8, 42002730 <panic_arch_fill_info+0x2c>
        info->details = print_illegal_instruction_details;
4200272b:	f71b81        	l32r	a8, 42000398 <_stext+0x378> (42002584 <print_illegal_instruction_details>)
4200272e:	4389      	s32i.n	a8, a3, 16
    }

    info->addr = ((void *)((XtExcFrame *) frame)->pc);
42002730:	1288      	l32i.n	a8, a2, 4
42002732:	6389      	s32i.n	a8, a3, 24
}
42002734:	f01d      	retw.n
	...

42002738 <panic_soc_fill_info>:
    // Currently only needed on riscv targets
    return false;
}

void panic_soc_fill_info(void *f, panic_info_t *info)
{
42002738:	004136        	entry	a1, 32
    // [refactor-todo] this should be in the common port panic_handler.c, once
    // these special exceptions are supported in there.
    XtExcFrame *frame = (XtExcFrame *) f;
    if (frame->exccause == PANIC_RSN_INTWDT_CPU0) {
4200273b:	142282        	l32i	a8, a2, 80
4200273e:	0a5866        	bnei	a8, 5, 4200274c <panic_soc_fill_info+0x14>
        info->core = 0;
42002741:	080c      	movi.n	a8, 0
42002743:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
42002745:	180c      	movi.n	a8, 1
42002747:	1389      	s32i.n	a8, a3, 4
42002749:	0005c6        	j	42002764 <panic_soc_fill_info+0x2c>
    } else if (frame->exccause == PANIC_RSN_INTWDT_CPU1) {
4200274c:	096866        	bnei	a8, 6, 42002759 <panic_soc_fill_info+0x21>
        info->core = 1;
4200274f:	180c      	movi.n	a8, 1
42002751:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
42002753:	1389      	s32i.n	a8, a3, 4
42002755:	0002c6        	j	42002764 <panic_soc_fill_info+0x2c>
42002758:	00          	.byte	00
    } else if (frame->exccause == PANIC_RSN_CACHEERR) {
42002759:	077866        	bnei	a8, 7, 42002764 <panic_soc_fill_info+0x2c>
        info->core =  esp_cache_err_get_cpuid();
4200275c:	201110        	or	a1, a1, a1
4200275f:	ff6ce5        	call8	42001e2c <esp_cache_err_get_cpuid>
42002762:	03a9      	s32i.n	a10, a3, 0
        "Interrupt wdt timeout on CPU0",
        "Interrupt wdt timeout on CPU1",
        "Cache error",
    };

    info->reason = pseudo_reason[0];
42002764:	f70e81        	l32r	a8, 4200039c <_stext+0x37c> (3c020c00 <_flash_rodata_start+0xae0>)
42002767:	2389      	s32i.n	a8, a3, 8
    info->description = NULL;
42002769:	080c      	movi.n	a8, 0
4200276b:	3389      	s32i.n	a8, a3, 12

    if (frame->exccause <= PANIC_RSN_MAX) {
4200276d:	142282        	l32i	a8, a2, 80
42002770:	0988e6        	bgei	a8, 8, 4200277d <panic_soc_fill_info+0x45>
        info->reason = pseudo_reason[frame->exccause];
42002773:	f70b91        	l32r	a9, 420003a0 <_stext+0x380> (3c026520 <pseudo_reason$0>)
42002776:	a08890        	addx4	a8, a8, a9
42002779:	0888      	l32i.n	a8, a8, 0
4200277b:	2389      	s32i.n	a8, a3, 8
    }

    if (frame->exccause == PANIC_RSN_DEBUGEXCEPTION) {
4200277d:	142282        	l32i	a8, a2, 80
42002780:	091866        	bnei	a8, 1, 4200278d <panic_soc_fill_info+0x55>
        info->details = print_debug_exception_details;
42002783:	f70881        	l32r	a8, 420003a4 <_stext+0x384> (42002534 <print_debug_exception_details>)
42002786:	4389      	s32i.n	a8, a3, 16
        info->exception = PANIC_EXCEPTION_DEBUG;
42002788:	080c      	movi.n	a8, 0
4200278a:	016382        	s32i	a8, a3, 4
    }

    //MV note: ESP32S3 PMS handling?
    if (frame->exccause == PANIC_RSN_CACHEERR) {
4200278d:	142282        	l32i	a8, a2, 80
42002790:	047866        	bnei	a8, 7, 42002798 <panic_soc_fill_info+0x60>
            info->details = print_memprot_err_details;
            info->reason = "Memory protection fault";
        } else
#endif
        {
            info->details = print_cache_err_details;
42002793:	f70581        	l32r	a8, 420003a8 <_stext+0x388> (420025d8 <print_cache_err_details>)
42002796:	4389      	s32i.n	a8, a3, 16
        }
    }
}
42002798:	f01d      	retw.n
	...

4200279c <panic_print_backtrace>:
{
    ((XtExcFrame *)f)->pc = addr;
}

void panic_print_backtrace(const void *f, int core)
{
4200279c:	006136        	entry	a1, 48
    XtExcFrame *xt_frame = (XtExcFrame *) f;
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
4200279f:	1288      	l32i.n	a8, a2, 4
420027a1:	0189      	s32i.n	a8, a1, 0
420027a3:	4288      	l32i.n	a8, a2, 16
420027a5:	1189      	s32i.n	a8, a1, 4
420027a7:	3288      	l32i.n	a8, a2, 12
420027a9:	2189      	s32i.n	a8, a1, 8
420027ab:	3129      	s32i.n	a2, a1, 12
    esp_backtrace_print_from_frame(100, &frame, true);
420027ad:	1c0c      	movi.n	a12, 1
420027af:	01bd      	mov.n	a11, a1
420027b1:	64a0a2        	movi	a10, 100
420027b4:	f6fe81        	l32r	a8, 420003ac <_stext+0x38c> (40375b34 <esp_backtrace_print_from_frame>)
420027b7:	0008e0        	callx8	a8
}
420027ba:	f01d      	retw.n

420027bc <esp_ipc_call_and_wait>:
        (void)res;
    }
}

static esp_err_t esp_ipc_call_and_wait(uint32_t cpu_id, esp_ipc_func_t func, void* arg, esp_ipc_wait_t wait_for)
{
420027bc:	004136        	entry	a1, 32
    if (cpu_id >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
420027bf:	0222b6        	bltui	a2, 2, 420027c5 <esp_ipc_call_and_wait+0x9>
420027c2:	002f86        	j	42002884 <esp_ipc_call_and_wait+0xc8>
        return ESP_ERR_INVALID_ARG;
    }
    if (s_ipc_task_handle[cpu_id] == NULL) {
420027c5:	f6fa81        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
420027c8:	a08280        	addx4	a8, a2, a8
420027cb:	0888      	l32i.n	a8, a8, 0
420027cd:	0bb816        	beqz	a8, 4200288c <esp_ipc_call_and_wait+0xd0>
        return ESP_ERR_INVALID_STATE;
    }
    if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
420027d0:	f6fe81        	l32r	a8, 420003c8 <_stext+0x3a8> (4037b934 <xTaskGetSchedulerState>)
420027d3:	0008e0        	callx8	a8
420027d6:	022a26        	beqi	a10, 2, 420027dc <esp_ipc_call_and_wait+0x20>
420027d9:	002dc6        	j	42002894 <esp_ipc_call_and_wait+0xd8>
        return ESP_ERR_INVALID_STATE;
    }

#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
    TaskHandle_t task_handler = xTaskGetCurrentTaskHandle();
420027dc:	f6fc81        	l32r	a8, 420003cc <_stext+0x3ac> (4037b778 <xTaskGetCurrentTaskHandle>)
420027df:	0008e0        	callx8	a8
    UBaseType_t priority_of_current_task = uxTaskPriorityGet(task_handler);
420027e2:	f6fb81        	l32r	a8, 420003d0 <_stext+0x3b0> (4037b798 <uxTaskPriorityGet>)
420027e5:	0008e0        	callx8	a8
420027e8:	0a6d      	mov.n	a6, a10
    UBaseType_t priority_of_running_ipc_task = uxTaskPriorityGet(s_ipc_task_handle[cpu_id]);
420027ea:	f6f181        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
420027ed:	a08280        	addx4	a8, a2, a8
420027f0:	0028a2        	l32i	a10, a8, 0
420027f3:	f6f781        	l32r	a8, 420003d0 <_stext+0x3b0> (4037b798 <uxTaskPriorityGet>)
420027f6:	0008e0        	callx8	a8
    if (priority_of_running_ipc_task < priority_of_current_task) {
420027f9:	10ba67        	bgeu	a10, a6, 4200280d <esp_ipc_call_and_wait+0x51>
        vTaskPrioritySet(s_ipc_task_handle[cpu_id], priority_of_current_task);
420027fc:	f6ed81        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
420027ff:	a08280        	addx4	a8, a2, a8
42002802:	06bd      	mov.n	a11, a6
42002804:	0028a2        	l32i	a10, a8, 0
42002807:	f6f381        	l32r	a8, 420003d4 <_stext+0x3b4> (4037b7b8 <vTaskPrioritySet>)
4200280a:	0008e0        	callx8	a8
    }

    xSemaphoreTake(s_ipc_mutex[cpu_id], portMAX_DELAY);
4200280d:	1172e0        	slli	a7, a2, 2
42002810:	f6e981        	l32r	a8, 420003b4 <_stext+0x394> (3fc94d8c <s_ipc_mutex>)
42002813:	a02280        	addx4	a2, a2, a8
42002816:	fb7c      	movi.n	a11, -1
42002818:	02a8      	l32i.n	a10, a2, 0
4200281a:	f6ef81        	l32r	a8, 420003d8 <_stext+0x3b8> (40379c9c <xQueueSemaphoreTake>)
4200281d:	0008e0        	callx8	a8
    vTaskPrioritySet(s_ipc_task_handle[cpu_id], priority_of_current_task);
42002820:	f6e481        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
42002823:	887a      	add.n	a8, a8, a7
42002825:	06bd      	mov.n	a11, a6
42002827:	086d      	mov.n	a6, a8
42002829:	08a8      	l32i.n	a10, a8, 0
4200282b:	f6ea81        	l32r	a8, 420003d4 <_stext+0x3b4> (4037b7b8 <vTaskPrioritySet>)
4200282e:	0008e0        	callx8	a8
#else
    xSemaphoreTake(s_ipc_mutex[0], portMAX_DELAY);
#endif

    s_func_arg[cpu_id] = arg;
42002831:	f6e181        	l32r	a8, 420003b8 <_stext+0x398> (3fc94d74 <s_func_arg>)
42002834:	887a      	add.n	a8, a8, a7
42002836:	0020c0        	memw
42002839:	0849      	s32i.n	a4, a8, 0
    s_wait_for[cpu_id] = wait_for;
4200283b:	f6e081        	l32r	a8, 420003bc <_stext+0x39c> (3fc94d6c <s_wait_for>)
4200283e:	887a      	add.n	a8, a8, a7
42002840:	0020c0        	memw
42002843:	0859      	s32i.n	a5, a8, 0
    // s_func must be set after all other parameters. The ipc_task use this as indicator of the IPC is prepared.
    s_func[cpu_id] = func;
42002845:	f6de81        	l32r	a8, 420003c0 <_stext+0x3a0> (3fc94d7c <s_func>)
42002848:	887a      	add.n	a8, a8, a7
4200284a:	0020c0        	memw
4200284d:	0839      	s32i.n	a3, a8, 0
    xTaskNotifyGive(s_ipc_task_handle[cpu_id]);
4200284f:	0e0c      	movi.n	a14, 0
42002851:	2d0c      	movi.n	a13, 2
42002853:	0ecd      	mov.n	a12, a14
42002855:	20bee0        	or	a11, a14, a14
42002858:	0026a2        	l32i	a10, a6, 0
4200285b:	f6e081        	l32r	a8, 420003dc <_stext+0x3bc> (4037c0b8 <xTaskGenericNotify>)
4200285e:	0008e0        	callx8	a8
    xSemaphoreTake(s_ipc_ack[cpu_id], portMAX_DELAY);
42002861:	f6d881        	l32r	a8, 420003c4 <_stext+0x3a4> (3fc94d84 <s_ipc_ack>)
42002864:	887a      	add.n	a8, a8, a7
42002866:	fb7c      	movi.n	a11, -1
42002868:	08a8      	l32i.n	a10, a8, 0
4200286a:	f6db81        	l32r	a8, 420003d8 <_stext+0x3b8> (40379c9c <xQueueSemaphoreTake>)
4200286d:	0008e0        	callx8	a8

#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
    xSemaphoreGive(s_ipc_mutex[cpu_id]);
42002870:	0d0c      	movi.n	a13, 0
42002872:	0dcd      	mov.n	a12, a13
42002874:	0dbd      	mov.n	a11, a13
42002876:	02a8      	l32i.n	a10, a2, 0
42002878:	f6da81        	l32r	a8, 420003e0 <_stext+0x3c0> (403799f4 <xQueueGenericSend>)
4200287b:	0008e0        	callx8	a8
#else
    xSemaphoreGive(s_ipc_mutex[0]);
#endif
    return ESP_OK;
4200287e:	020c      	movi.n	a2, 0
42002880:	0004c6        	j	42002897 <esp_ipc_call_and_wait+0xdb>
42002883:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42002886:	030602        	l8ui	a0, a6, 3
42002889:	000000        	ill
        return ESP_ERR_INVALID_STATE;
4200288c:	03a122        	movi	a2, 0x103
4200288f:	000106        	j	42002897 <esp_ipc_call_and_wait+0xdb>
42002892:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_STATE;
42002895:	1d03a1        	l32r	a10, 41fc9ca4 <_iram_bss_end+0x1c478a4>
}
42002898:	0000f0        	callx12	a0
	...

4200289c <esp_ipc_init>:
{
4200289c:	008136        	entry	a1, 64
    char task_name[] = "ipcX"; // up to 10 ipc tasks/cores (0-9)
4200289f:	f6d181        	l32r	a8, 420003e4 <_stext+0x3c4> (3c020fa8 <_flash_rodata_start+0xe88>)
420028a2:	0898      	l32i.n	a9, a8, 0
420028a4:	040882        	l8ui	a8, a8, 4
420028a7:	4199      	s32i.n	a9, a1, 16
420028a9:	144182        	s8i	a8, a1, 20
    for (int i = 0; i < CONFIG_FREERTOS_NUMBER_OF_CORES; ++i) {
420028ac:	070c      	movi.n	a7, 0
420028ae:	001d86        	j	42002928 <esp_ipc_init+0x8c>
        task_name[3] = i + (char)'0';
420028b1:	30c782        	addi	a8, a7, 48
420028b4:	134182        	s8i	a8, a1, 19
        s_ipc_mutex[i] = xSemaphoreCreateMutexStatic(&s_ipc_mutex_buffer[i]);
420028b7:	905770        	addx2	a5, a7, a7
420028ba:	1145d0        	slli	a4, a5, 3
420028bd:	f0b550        	subx8	a11, a5, a5
420028c0:	f6ca81        	l32r	a8, 420003e8 <_stext+0x3c8> (3fc92c58 <s_ipc_mutex_buffer>)
420028c3:	a0bb80        	addx4	a11, a11, a8
420028c6:	1a0c      	movi.n	a10, 1
420028c8:	f6ce81        	l32r	a8, 42000400 <_stext+0x3e0> (40379b84 <xQueueCreateMutexStatic>)
420028cb:	0008e0        	callx8	a8
420028ce:	1167e0        	slli	a6, a7, 2
420028d1:	f6b881        	l32r	a8, 420003b4 <_stext+0x394> (3fc94d8c <s_ipc_mutex>)
420028d4:	a08780        	addx4	a8, a7, a8
420028d7:	08a9      	s32i.n	a10, a8, 0
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
420028d9:	c04450        	sub	a4, a4, a5
420028dc:	3e0c      	movi.n	a14, 3
420028de:	f6c3d1        	l32r	a13, 420003ec <_stext+0x3cc> (3fc92bb0 <s_ipc_ack_buffer>)
420028e1:	a0d4d0        	addx4	a13, a4, a13
420028e4:	0c0c      	movi.n	a12, 0
420028e6:	0cbd      	mov.n	a11, a12
420028e8:	1a0c      	movi.n	a10, 1
420028ea:	f6c681        	l32r	a8, 42000404 <_stext+0x3e4> (403798d8 <xQueueGenericCreateStatic>)
420028ed:	0008e0        	callx8	a8
420028f0:	f6b581        	l32r	a8, 420003c4 <_stext+0x3a4> (3fc94d84 <s_ipc_ack>)
420028f3:	886a      	add.n	a8, a8, a6
420028f5:	08a9      	s32i.n	a10, a8, 0
        BaseType_t res = xTaskCreatePinnedToCore(ipc_task, task_name, IPC_STACK_SIZE, (void*) i,
420028f7:	0179      	s32i.n	a7, a1, 0
420028f9:	f6adf1        	l32r	a15, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
420028fc:	ff6a      	add.n	a15, a15, a6
420028fe:	8e1c      	movi.n	a14, 24
42002900:	07dd      	mov.n	a13, a7
42002902:	00a5c2        	movi	a12, 0x500
42002905:	10c1b2        	addi	a11, a1, 16
42002908:	f6baa1        	l32r	a10, 420003f0 <_stext+0x3d0> (40375c88 <ipc_task>)
4200290b:	f6bf81        	l32r	a8, 42000408 <_stext+0x3e8> (4037c4ac <xTaskCreatePinnedToCore>)
4200290e:	0008e0        	callx8	a8
        assert(res == pdTRUE);
42002911:	111a26        	beqi	a10, 1, 42002926 <esp_ipc_init+0x8a>
42002914:	f6b8d1        	l32r	a13, 420003f4 <_stext+0x3d4> (3c020f98 <_flash_rodata_start+0xe78>)
42002917:	f6b8c1        	l32r	a12, 420003f8 <_stext+0x3d8> (3c0265ec <__func__$1>)
4200291a:	74a0b2        	movi	a11, 116
4200291d:	f6b7a1        	l32r	a10, 420003fc <_stext+0x3dc> (3c020f8c <_flash_rodata_start+0xe6c>)
42002920:	f5fa81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42002923:	0008e0        	callx8	a8
    for (int i = 0; i < CONFIG_FREERTOS_NUMBER_OF_CORES; ++i) {
42002926:	771b      	addi.n	a7, a7, 1
42002928:	8527a6        	blti	a7, 2, 420028b1 <esp_ipc_init+0x15>
}
4200292b:	f01d      	retw.n
4200292d:	000000        	ill

42002930 <esp_ipc_call_blocking>:
{
    return esp_ipc_call_and_wait(cpu_id, func, arg, IPC_WAIT_FOR_START);
}

esp_err_t esp_ipc_call_blocking(uint32_t cpu_id, esp_ipc_func_t func, void* arg)
{
42002930:	004136        	entry	a1, 32
42002933:	20a220        	or	a10, a2, a2
42002936:	20b330        	or	a11, a3, a3
42002939:	20c440        	or	a12, a4, a4
    return esp_ipc_call_and_wait(cpu_id, func, arg, IPC_WAIT_FOR_END);
4200293c:	2d0c      	movi.n	a13, 2
4200293e:	ffe7e5        	call8	420027bc <esp_ipc_call_and_wait>
}
42002941:	0a2d      	mov.n	a2, a10
42002943:	f01d      	retw.n
42002945:	000000        	ill

42002948 <esp_ipc_call_nonblocking>:

esp_err_t esp_ipc_call_nonblocking(uint32_t cpu_id, esp_ipc_func_t func, void* arg)
{
42002948:	004136        	entry	a1, 32
    if (cpu_id >= portNUM_PROCESSORS || s_ipc_task_handle[cpu_id] == NULL) {
4200294b:	0222b6        	bltui	a2, 2, 42002951 <esp_ipc_call_nonblocking+0x9>
4200294e:	0022c6        	j	420029dd <esp_ipc_call_nonblocking+0x95>
42002951:	f69781        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
42002954:	a08280        	addx4	a8, a2, a8
42002957:	002882        	l32i	a8, a8, 0
4200295a:	086816        	beqz	a8, 420029e4 <esp_ipc_call_nonblocking+0x9c>
4200295d:	03eb80        	rsr.prid	a8
42002960:	048d80        	extui	a8, a8, 13, 1
        return ESP_ERR_INVALID_ARG;
    }
    if (cpu_id == xPortGetCoreID() && xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
42002963:	089287        	bne	a2, a8, 4200296f <esp_ipc_call_nonblocking+0x27>
42002966:	f69881        	l32r	a8, 420003c8 <_stext+0x3a8> (4037b934 <xTaskGetSchedulerState>)
42002969:	0008e0        	callx8	a8
4200296c:	7c2a66        	bnei	a10, 2, 420029ec <esp_ipc_call_nonblocking+0xa4>
        return ESP_ERR_INVALID_STATE;
    }

    // Since it can be called from an interrupt or Scheduler is Suspened, it can not wait for a mutex to be released.
    if (esp_cpu_compare_and_set((volatile uint32_t *)&s_no_block_func[cpu_id], 0, (uint32_t)func)) {
4200296f:	03cd      	mov.n	a12, a3
42002971:	00a0b2        	movi	a11, 0
42002974:	f6a6a1        	l32r	a10, 4200040c <_stext+0x3ec> (3fc94d64 <s_no_block_func>)
42002977:	a0a2a0        	addx4	a10, a2, a10
4200297a:	f6a781        	l32r	a8, 42000418 <_stext+0x3f8> (40377d18 <esp_cpu_compare_and_set>)
4200297d:	0008e0        	callx8	a8
42002980:	06ea16        	beqz	a10, 420029f2 <esp_ipc_call_nonblocking+0xaa>
        s_no_block_func_arg[cpu_id] = arg;
42002983:	f6a381        	l32r	a8, 42000410 <_stext+0x3f0> (3fc94d58 <s_no_block_func_arg>)
42002986:	a08280        	addx4	a8, a2, a8
42002989:	0020c0        	memw
4200298c:	0849      	s32i.n	a4, a8, 0
        s_no_block_func_and_arg_are_ready[cpu_id] = true;
4200298e:	f6a181        	l32r	a8, 42000414 <_stext+0x3f4> (3fc94d60 <s_no_block_func_and_arg_are_ready>)
42002991:	882a      	add.n	a8, a8, a2
42002993:	190c      	movi.n	a9, 1
42002995:	0020c0        	memw
42002998:	004892        	s8i	a9, a8, 0

        if (xPortInIsrContext()) {
4200299b:	f6a081        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
4200299e:	0008e0        	callx8	a8
420029a1:	3a9c      	beqz.n	a10, 420029b8 <esp_ipc_call_nonblocking+0x70>
            vTaskNotifyGiveFromISR(s_ipc_task_handle[cpu_id], NULL);
420029a3:	f68381        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
420029a6:	a08280        	addx4	a8, a2, a8
420029a9:	0c0c      	movi.n	a12, 0
420029ab:	0cbd      	mov.n	a11, a12
420029ad:	08a8      	l32i.n	a10, a8, 0
420029af:	f69c81        	l32r	a8, 42000420 <_stext+0x400> (4037c28c <vTaskGenericNotifyGiveFromISR>)
420029b2:	0008e0        	callx8	a8
420029b5:	0007c6        	j	420029d8 <esp_ipc_call_nonblocking+0x90>
        } else {
#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
            vTaskPrioritySet(s_ipc_task_handle[cpu_id], IPC_MAX_PRIORITY);
420029b8:	f67e81        	l32r	a8, 420003b0 <_stext+0x390> (3fc94d94 <s_ipc_task_handle>)
420029bb:	a02280        	addx4	a2, a2, a8
420029be:	8b1c      	movi.n	a11, 24
420029c0:	02a8      	l32i.n	a10, a2, 0
420029c2:	f68481        	l32r	a8, 420003d4 <_stext+0x3b4> (4037b7b8 <vTaskPrioritySet>)
420029c5:	0008e0        	callx8	a8
#endif
            xTaskNotifyGive(s_ipc_task_handle[cpu_id]);
420029c8:	0e0c      	movi.n	a14, 0
420029ca:	2d0c      	movi.n	a13, 2
420029cc:	0ecd      	mov.n	a12, a14
420029ce:	0ebd      	mov.n	a11, a14
420029d0:	02a8      	l32i.n	a10, a2, 0
420029d2:	f68281        	l32r	a8, 420003dc <_stext+0x3bc> (4037c0b8 <xTaskGenericNotify>)
420029d5:	0008e0        	callx8	a8
        }
        return ESP_OK;
420029d8:	020c      	movi.n	a2, 0
420029da:	000586        	j	420029f4 <esp_ipc_call_nonblocking+0xac>
        return ESP_ERR_INVALID_ARG;
420029dd:	02a122        	movi	a2, 0x102
420029e0:	000406        	j	420029f4 <esp_ipc_call_nonblocking+0xac>
420029e3:	a12200        	sll	a2, a2
420029e6:	024602        	s8i	a0, a6, 2
420029e9:	000000        	ill
        return ESP_ERR_INVALID_STATE;
420029ec:	03a122        	movi	a2, 0x103
420029ef:	000046        	j	420029f4 <esp_ipc_call_nonblocking+0xac>
    }

    // the previous call was not completed
    return ESP_FAIL;
420029f2:	f27c      	movi.n	a2, -1
}
420029f4:	f01d      	retw.n
	...

420029f8 <esp_vApplicationIdleHook>:

void esp_vApplicationIdleHook(void)
{
420029f8:	004136        	entry	a1, 32
420029fb:	03eb60        	rsr.prid	a6
420029fe:	046d60        	extui	a6, a6, 13, 1
    bool can_go_idle = true;
    int core = xPortGetCoreID();
    for (int n = 0; n < MAX_HOOKS; n++) {
42002a01:	070c      	movi.n	a7, 0
    bool can_go_idle = true;
42002a03:	150c      	movi.n	a5, 1
    for (int n = 0; n < MAX_HOOKS; n++) {
42002a05:	000546        	j	42002a1e <esp_vApplicationIdleHook+0x26>
        if (idle_cb[core][n] != NULL && !idle_cb[core][n]()) {
42002a08:	b08670        	addx8	a8, a6, a7
42002a0b:	f68691        	l32r	a9, 42000424 <_stext+0x404> (3fc94ddc <idle_cb>)
42002a0e:	a08890        	addx4	a8, a8, a9
42002a11:	08a8      	l32i.n	a10, a8, 0
42002a13:	5a8c      	beqz.n	a10, 42002a1c <esp_vApplicationIdleHook+0x24>
42002a15:	000ae0        	callx8	a10
42002a18:	0acc      	bnez.n	a10, 42002a1c <esp_vApplicationIdleHook+0x24>
            can_go_idle = false;
42002a1a:	0a5d      	mov.n	a5, a10
    for (int n = 0; n < MAX_HOOKS; n++) {
42002a1c:	771b      	addi.n	a7, a7, 1
42002a1e:	e687a6        	blti	a7, 8, 42002a08 <esp_vApplicationIdleHook+0x10>
        }
    }
    if (!can_go_idle) {
42002a21:	458c      	beqz.n	a5, 42002a29 <esp_vApplicationIdleHook+0x31>

#ifdef CONFIG_PM_ENABLE
    esp_pm_impl_idle_hook();
    esp_pm_impl_waiti();
#else
    esp_cpu_wait_for_intr();
42002a23:	f68181        	l32r	a8, 42000428 <_stext+0x408> (40377e08 <esp_cpu_wait_for_intr>)
42002a26:	0008e0        	callx8	a8
#endif

}
42002a29:	f01d      	retw.n
	...

42002a2c <esp_register_freertos_idle_hook_for_cpu>:

esp_err_t esp_register_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t new_idle_cb, UBaseType_t cpuid)
{
42002a2c:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
42002a2f:	4d23f6        	bgeui	a3, 2, 42002a80 <esp_register_freertos_idle_hook_for_cpu+0x54>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
42002a32:	fb7c      	movi.n	a11, -1
42002a34:	f67ea1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002a37:	f67e81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42002a3a:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
42002a3d:	090c      	movi.n	a9, 0
42002a3f:	000a46        	j	42002a6c <esp_register_freertos_idle_hook_for_cpu+0x40>
42002a42:	900000        	addx2	a0, a0, a0
        if (idle_cb[cpuid][n] == NULL) {
42002a45:	83          	.byte	0x83
42002a46:	77a1b0        	ee.stf.64.xp	f10, f7, a11, a1
42002a49:	88a0f6        	bgeui	a0, 12, 420029d5 <esp_ipc_call_nonblocking+0x8d>
42002a4c:	0888a0        	lsx	f8, a8, a10
42002a4f:	78dc      	bnez.n	a8, 42002a6a <esp_register_freertos_idle_hook_for_cpu+0x3e>
            idle_cb[cpuid][n] = new_idle_cb;
42002a51:	b03390        	addx8	a3, a3, a9
42002a54:	a033a0        	addx4	a3, a3, a10
42002a57:	0329      	s32i.n	a2, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
42002a59:	f674a1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002a5c:	f67681        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42002a5f:	0008e0        	callx8	a8
            return ESP_OK;
42002a62:	020c      	movi.n	a2, 0
42002a64:	0006c6        	j	42002a83 <esp_register_freertos_idle_hook_for_cpu+0x57>
42002a67:	000000        	ill
    for (int n = 0; n < MAX_HOOKS; n++) {
42002a6a:	991b      	addi.n	a9, a9, 1
42002a6c:	d489a6        	blti	a9, 8, 42002a44 <esp_register_freertos_idle_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
42002a6f:	f66fa1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002a72:	f67081        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42002a75:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
42002a78:	01a122        	movi	a2, 0x101
42002a7b:	000106        	j	42002a83 <esp_register_freertos_idle_hook_for_cpu+0x57>
42002a7e:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
42002a81:	1d02a1        	l32r	a10, 41fc9e8c <_iram_bss_end+0x1c47a8c>
}
42002a84:	0000f0        	callx12	a0
	...

42002a88 <esp_register_freertos_tick_hook_for_cpu>:
{
    return esp_register_freertos_idle_hook_for_cpu(new_idle_cb, xPortGetCoreID());
}

esp_err_t esp_register_freertos_tick_hook_for_cpu(esp_freertos_tick_cb_t new_tick_cb, UBaseType_t cpuid)
{
42002a88:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
42002a8b:	4923f6        	bgeui	a3, 2, 42002ad8 <esp_register_freertos_tick_hook_for_cpu+0x50>
42002a8e:	fb7c      	movi.n	a11, -1
42002a90:	f667a1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002a93:	f66781        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42002a96:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
42002a99:	090c      	movi.n	a9, 0
42002a9b:	000986        	j	42002ac5 <esp_register_freertos_tick_hook_for_cpu+0x3d>
42002a9e:	900000        	addx2	a0, a0, a0
        if (tick_cb[cpuid][n] == NULL) {
42002aa1:	83          	.byte	0x83
42002aa2:	65a1b0        	extui	a10, a11, 17, 7
42002aa5:	88a0f6        	bgeui	a0, 12, 42002a31 <esp_register_freertos_idle_hook_for_cpu+0x5>
42002aa8:	0888a0        	lsx	f8, a8, a10
42002aab:	48dc      	bnez.n	a8, 42002ac3 <esp_register_freertos_tick_hook_for_cpu+0x3b>
            tick_cb[cpuid][n] = new_tick_cb;
42002aad:	b03390        	addx8	a3, a3, a9
42002ab0:	a033a0        	addx4	a3, a3, a10
42002ab3:	0329      	s32i.n	a2, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
42002ab5:	f65da1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002ab8:	f65f81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42002abb:	0008e0        	callx8	a8
            return ESP_OK;
42002abe:	020c      	movi.n	a2, 0
42002ac0:	0005c6        	j	42002adb <esp_register_freertos_tick_hook_for_cpu+0x53>
    for (int n = 0; n < MAX_HOOKS; n++) {
42002ac3:	991b      	addi.n	a9, a9, 1
42002ac5:	d789a6        	blti	a9, 8, 42002aa0 <esp_register_freertos_tick_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
42002ac8:	f659a1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002acb:	f65a81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42002ace:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
42002ad1:	01a122        	movi	a2, 0x101
42002ad4:	0000c6        	j	42002adb <esp_register_freertos_tick_hook_for_cpu+0x53>
42002ad7:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42002ada:	f01d02        	l16ui	a0, a13, 0x1e0
42002add:	000000        	ill

42002ae0 <esp_register_freertos_tick_hook>:
}

esp_err_t esp_register_freertos_tick_hook(esp_freertos_tick_cb_t new_tick_cb)
{
42002ae0:	004136        	entry	a1, 32
42002ae3:	20a220        	or	a10, a2, a2
42002ae6:	03ebb0        	rsr.prid	a11
42002ae9:	04bdb0        	extui	a11, a11, 13, 1
    return esp_register_freertos_tick_hook_for_cpu(new_tick_cb, xPortGetCoreID());
42002aec:	fff9a5        	call8	42002a88 <esp_register_freertos_tick_hook_for_cpu>
}
42002aef:	202aa0        	or	a2, a10, a10
42002af2:	000090        	retw
42002af5:	000000        	ill

42002af8 <esp_deregister_freertos_idle_hook_for_cpu>:

void esp_deregister_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t old_idle_cb, UBaseType_t cpuid)
{
42002af8:	004136        	entry	a1, 32
    if (cpuid >= CONFIG_FREERTOS_NUMBER_OF_CORES) {
42002afb:	3723f6        	bgeui	a3, 2, 42002b36 <esp_deregister_freertos_idle_hook_for_cpu+0x3e>
42002afe:	fb7c      	movi.n	a11, -1
42002b00:	f64ba1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002b03:	f64b81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42002b06:	0008e0        	callx8	a8
        return;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for (int n = 0; n < MAX_HOOKS; n++) {
42002b09:	090c      	movi.n	a9, 0
42002b0b:	0006c6        	j	42002b2a <esp_deregister_freertos_idle_hook_for_cpu+0x32>
42002b0e:	900000        	addx2	a0, a0, a0
        if (idle_cb[cpuid][n] == old_idle_cb) {
42002b11:	83          	.byte	0x83
42002b12:	44a1b0        	extui	a10, a11, 1, 5
42002b15:	88a0f6        	bgeui	a0, 12, 42002aa1 <esp_register_freertos_tick_hook_for_cpu+0x19>
42002b18:	0888a0        	lsx	f8, a8, a10
42002b1b:	099827        	bne	a8, a2, 42002b28 <esp_deregister_freertos_idle_hook_for_cpu+0x30>
            idle_cb[cpuid][n] = NULL;
42002b1e:	b08390        	addx8	a8, a3, a9
42002b21:	a088a0        	addx4	a8, a8, a10
42002b24:	0a0c      	movi.n	a10, 0
42002b26:	08a9      	s32i.n	a10, a8, 0
    for (int n = 0; n < MAX_HOOKS; n++) {
42002b28:	991b      	addi.n	a9, a9, 1
42002b2a:	e289a6        	blti	a9, 8, 42002b10 <esp_deregister_freertos_idle_hook_for_cpu+0x18>
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
42002b2d:	f63fa1        	l32r	a10, 4200042c <_stext+0x40c> (3fc92428 <hooks_spinlock>)
42002b30:	f64181        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42002b33:	0008e0        	callx8	a8
}
42002b36:	f01d      	retw.n

42002b38 <esp_err_to_name>:
#else
    "UNKNOWN ERROR";
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

const char *esp_err_to_name(esp_err_t code)
{
42002b38:	004136        	entry	a1, 32
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    size_t i;

    for (i = 0; i < sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {
42002b3b:	080c      	movi.n	a8, 0
42002b3d:	0005c6        	j	42002b58 <esp_err_to_name+0x20>
        if (esp_err_msg_table[i].code == code) {
42002b40:	f64091        	l32r	a9, 42000440 <_stext+0x420> (3c026604 <esp_err_msg_table>)
42002b43:	b09890        	addx8	a9, a8, a9
42002b46:	0998      	l32i.n	a9, a9, 0
42002b48:	0a9927        	bne	a9, a2, 42002b56 <esp_err_to_name+0x1e>
            return esp_err_msg_table[i].msg;
42002b4b:	f63d91        	l32r	a9, 42000440 <_stext+0x420> (3c026604 <esp_err_msg_table>)
42002b4e:	b08890        	addx8	a8, a8, a9
42002b51:	1828      	l32i.n	a2, a8, 4
42002b53:	000246        	j	42002b60 <esp_err_to_name+0x28>
    for (i = 0; i < sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {
42002b56:	881b      	addi.n	a8, a8, 1
42002b58:	693c      	movi.n	a9, 54
42002b5a:	e2b987        	bgeu	a9, a8, 42002b40 <esp_err_to_name+0x8>
        }
    }
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

    return esp_unknown_msg;
42002b5d:	f63721        	l32r	a2, 4200043c <_stext+0x41c> (3c0265fc <esp_unknown_msg>)
}
42002b60:	f01d      	retw.n
	...

42002b64 <esp_log_is_tag_loggable>:
    s_master_log_level = level;
}
#endif // CONFIG_LOG_MASTER_LEVEL

bool esp_log_is_tag_loggable(esp_log_level_t level, const char *tag)
{
42002b64:	004136        	entry	a1, 32
42002b67:	20a330        	or	a10, a3, a3
#else
    (void)level;
    return true;
#endif
#else // !CONFIG_LOG_TAG_LEVEL_IMPL_NONE
    return esp_log_level_get_timeout(tag) >= level && level > ESP_LOG_NONE;
42002b6a:	f63681        	l32r	a8, 42000444 <_stext+0x424> (4037fc4c <esp_log_level_get_timeout>)
42002b6d:	0008e0        	callx8	a8
42002b70:	043a27        	bltu	a10, a2, 42002b78 <esp_log_is_tag_loggable+0x14>
42002b73:	62cc      	bnez.n	a2, 42002b7d <esp_log_is_tag_loggable+0x19>
42002b75:	000186        	j	42002b7f <esp_log_is_tag_loggable+0x1b>
42002b78:	020c      	movi.n	a2, 0
42002b7a:	000046        	j	42002b7f <esp_log_is_tag_loggable+0x1b>
42002b7d:	120c      	movi.n	a2, 1
#endif // !CONFIG_LOG_TAG_LEVEL_IMPL_NONE
}
42002b7f:	f01d      	retw.n
42002b81:	000000        	ill

42002b84 <esp_log_linked_list_get_level>:
}

// Getting the log level from linked list
// if tag is not found then returns false.
bool esp_log_linked_list_get_level(const char *tag, esp_log_level_t *level)
{
42002b84:	004136        	entry	a1, 32
    // Walk the linked list of all tags and see if given tag is present in the list.
    // This is slow because tags are compared as strings.
    uncached_tag_entry_t *it;
    SLIST_FOREACH(it, &s_log_tags, entries) {
42002b87:	f63081        	l32r	a8, 42000448 <_stext+0x428> (3fc94e28 <s_log_tags>)
42002b8a:	0878      	l32i.n	a7, a8, 0
42002b8c:	000606        	j	42002ba8 <esp_log_linked_list_get_level+0x24>
42002b8f:	b75b00        	ee.stf.64.xp	f5, f11, a0, a11
        if (strcmp(tag, it->tag) == 0) {
42002b92:	02ad      	mov.n	a10, a2
42002b94:	f62e81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
42002b97:	0008e0        	callx8	a8
42002b9a:	8acc      	bnez.n	a10, 42002ba6 <esp_log_linked_list_get_level+0x22>
            *level = it->level;
42002b9c:	040782        	l8ui	a8, a7, 4
42002b9f:	0389      	s32i.n	a8, a3, 0
            return true;
42002ba1:	120c      	movi.n	a2, 1
42002ba3:	000186        	j	42002bad <esp_log_linked_list_get_level+0x29>
    SLIST_FOREACH(it, &s_log_tags, entries) {
42002ba6:	0778      	l32i.n	a7, a7, 0
42002ba8:	fe4756        	bnez	a7, 42002b90 <esp_log_linked_list_get_level+0xc>
        }
    }
    return false;
42002bab:	020c      	movi.n	a2, 0
}
42002bad:	f01d      	retw.n
	...

42002bb0 <fix_cache_generation_overflow>:
        fix_cache_generation_overflow();
    }
}

static void fix_cache_generation_overflow(void)
{
42002bb0:	004136        	entry	a1, 32
    // Fix generation count wrap
    for (uint32_t i = 0; i < s_log_cache_entry_count; ++i) {
42002bb3:	090c      	movi.n	a9, 0
42002bb5:	000506        	j	42002bcd <fix_cache_generation_overflow+0x1d>
        s_log_cache[i].generation = i;
42002bb8:	11b9d0        	slli	a11, a9, 3
42002bbb:	f625a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002bbe:	b0a9a0        	addx8	a10, a9, a10
42002bc1:	1a88      	l32i.n	a8, a10, 4
42002bc3:	248080        	extui	a8, a8, 0, 3
42002bc6:	2088b0        	or	a8, a8, a11
42002bc9:	1a89      	s32i.n	a8, a10, 4
    for (uint32_t i = 0; i < s_log_cache_entry_count; ++i) {
42002bcb:	991b      	addi.n	a9, a9, 1
42002bcd:	f62181        	l32r	a8, 42000454 <_stext+0x434> (3fc94e30 <s_log_cache_entry_count>)
42002bd0:	0888      	l32i.n	a8, a8, 0
42002bd2:	e23987        	bltu	a9, a8, 42002bb8 <fix_cache_generation_overflow+0x8>
    }
    s_log_cache_max_generation = s_log_cache_entry_count;
42002bd5:	f62091        	l32r	a9, 42000458 <_stext+0x438> (3fc94e34 <s_log_cache_max_generation>)
42002bd8:	0989      	s32i.n	a8, a9, 0
}
42002bda:	f01d      	retw.n

42002bdc <heap_swap>:
        index = next;
    }
}

static inline void heap_swap(int i, int j)
{
42002bdc:	006136        	entry	a1, 48
    cached_tag_entry_t tmp = s_log_cache[i];
42002bdf:	f61ca1        	l32r	a10, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002be2:	b022a0        	addx8	a2, a2, a10
42002be5:	0298      	l32i.n	a9, a2, 0
42002be7:	1288      	l32i.n	a8, a2, 4
42002be9:	0199      	s32i.n	a9, a1, 0
42002beb:	1189      	s32i.n	a8, a1, 4
    s_log_cache[i] = s_log_cache[j];
42002bed:	b033a0        	addx8	a3, a3, a10
42002bf0:	03b8      	l32i.n	a11, a3, 0
42002bf2:	13a8      	l32i.n	a10, a3, 4
42002bf4:	02b9      	s32i.n	a11, a2, 0
42002bf6:	12a9      	s32i.n	a10, a2, 4
    s_log_cache[j] = tmp;
42002bf8:	0399      	s32i.n	a9, a3, 0
42002bfa:	1389      	s32i.n	a8, a3, 4
}
42002bfc:	f01d      	retw.n
	...

42002c00 <heap_bubble_down>:
{
42002c00:	004136        	entry	a1, 32
42002c03:	02ad      	mov.n	a10, a2
    while (index < TAG_CACHE_SIZE / 2) {
42002c05:	000a86        	j	42002c33 <heap_bubble_down+0x33>
        int left_index = index * 2 + 1;
42002c08:	baaa      	add.n	a11, a10, a10
42002c0a:	bb1b      	addi.n	a11, a11, 1
        int right_index = left_index + 1;
42002c0c:	8a1b      	addi.n	a8, a10, 1
42002c0e:	788a      	add.n	a7, a8, a8
        int next = (s_log_cache[left_index].generation < s_log_cache[right_index].generation) ? left_index : right_index;
42002c10:	f61091        	l32r	a9, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002c13:	b0cb90        	addx8	a12, a11, a9
42002c16:	1cc8      	l32i.n	a12, a12, 4
42002c18:	41c3c0        	srli	a12, a12, 3
42002c1b:	1188c0        	slli	a8, a8, 4
42002c1e:	998a      	add.n	a9, a9, a8
42002c20:	1988      	l32i.n	a8, a9, 4
42002c22:	418380        	srli	a8, a8, 3
42002c25:	01bc87        	bgeu	a12, a8, 42002c2a <heap_bubble_down+0x2a>
42002c28:	0b7d      	mov.n	a7, a11
        heap_swap(index, next);
42002c2a:	20b770        	or	a11, a7, a7
42002c2d:	fffae5        	call8	42002bdc <heap_swap>
        index = next;
42002c30:	20a770        	or	a10, a7, a7
    while (index < TAG_CACHE_SIZE / 2) {
42002c33:	0ea082        	movi	a8, 14
42002c36:	cea8a7        	bge	a8, a10, 42002c08 <heap_bubble_down+0x8>
}
42002c39:	f01d      	retw.n
	...

42002c3c <esp_log_cache_get_level>:
{
42002c3c:	004136        	entry	a1, 32
    for (i = 0; i < s_log_cache_entry_count; ++i) {
42002c3f:	0a0c      	movi.n	a10, 0
42002c41:	000f06        	j	42002c81 <esp_log_cache_get_level+0x45>
42002c44:	baac00        	ceil.s	a10, f12, 0
        assert(i == 0 || s_log_cache[(i - 1) / 2].generation < s_log_cache[i].generation);
42002c47:	8a0b      	addi.n	a8, a10, -1
42002c49:	418180        	srli	a8, a8, 1
42002c4c:	f601b1        	l32r	a11, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002c4f:	b088b0        	addx8	a8, a8, a11
42002c52:	18c8      	l32i.n	a12, a8, 4
42002c54:	41c3c0        	srli	a12, a12, 3
42002c57:	b0bab0        	addx8	a11, a10, a11
42002c5a:	1b88      	l32i.n	a8, a11, 4
42002c5c:	418380        	srli	a8, a8, 3
42002c5f:	113c87        	bltu	a12, a8, 42002c74 <esp_log_cache_get_level+0x38>
42002c62:	f5fed1        	l32r	a13, 4200045c <_stext+0x43c> (3c021564 <_flash_rodata_start+0x1444>)
42002c65:	f5fec1        	l32r	a12, 42000460 <_stext+0x440> (3c0267bc <__func__$0>)
42002c68:	63a0b2        	movi	a11, 99
42002c6b:	f5fea1        	l32r	a10, 42000464 <_stext+0x444> (3c0215e7 <_flash_rodata_start+0x14c7>)
42002c6e:	f52681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42002c71:	0008e0        	callx8	a8
        if (s_log_cache[i].tag == tag) {
42002c74:	f5f781        	l32r	a8, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002c77:	b08a80        	addx8	a8, a10, a8
42002c7a:	0888      	l32i.n	a8, a8, 0
42002c7c:	091827        	beq	a8, a2, 42002c89 <esp_log_cache_get_level+0x4d>
    for (i = 0; i < s_log_cache_entry_count; ++i) {
42002c7f:	aa1b      	addi.n	a10, a10, 1
42002c81:	f5f481        	l32r	a8, 42000454 <_stext+0x434> (3fc94e30 <s_log_cache_entry_count>)
42002c84:	0898      	l32i.n	a9, a8, 0
42002c86:	bb3a97        	bltu	a10, a9, 42002c45 <esp_log_cache_get_level+0x9>
    if (i == s_log_cache_entry_count) { // Not found in cache
42002c89:	0f99a7        	bne	a9, a10, 42002c9c <esp_log_cache_get_level+0x60>
        ++s_log_cache_misses;
42002c8c:	f5f791        	l32r	a9, 42000468 <_stext+0x448> (3fc94e2c <s_log_cache_misses>)
42002c8f:	0988      	l32i.n	a8, a9, 0
42002c91:	881b      	addi.n	a8, a8, 1
42002c93:	0989      	s32i.n	a8, a9, 0
        return false;
42002c95:	020c      	movi.n	a2, 0
42002c97:	0013c6        	j	42002cea <esp_log_cache_get_level+0xae>
42002c9a:	810000        	src	a0, a0, a0
    *level = (esp_log_level_t) s_log_cache[i].level;
42002c9d:	ed          	.byte	0xed
42002c9e:	8a80f5        	call12	41f8d4ac <_iram_bss_end+0x1c0b0ac>
42002ca1:	b0          	.byte	0xb0
42002ca2:	012882        	l32i	a8, a8, 4
42002ca5:	248080        	extui	a8, a8, 0, 3
42002ca8:	006382        	s32i	a8, a3, 0
    if (s_log_cache_entry_count == TAG_CACHE_SIZE) {
42002cab:	f81c      	movi.n	a8, 31
42002cad:	319987        	bne	a9, a8, 42002ce2 <esp_log_cache_get_level+0xa6>
        s_log_cache[i].generation = s_log_cache_max_generation++;
42002cb0:	f5ea31        	l32r	a3, 42000458 <_stext+0x438> (3fc94e34 <s_log_cache_max_generation>)
42002cb3:	0388      	l32i.n	a8, a3, 0
42002cb5:	981b      	addi.n	a9, a8, 1
42002cb7:	0399      	s32i.n	a9, a3, 0
42002cb9:	f5ec21        	l32r	a2, 4200046c <_stext+0x44c> (1fffffff <UserFrameTotalSize+0x1ffffeff>)
42002cbc:	108820        	and	a8, a8, a2
42002cbf:	f5e4b1        	l32r	a11, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002cc2:	b0bab0        	addx8	a11, a10, a11
42002cc5:	1188d0        	slli	a8, a8, 3
42002cc8:	1b98      	l32i.n	a9, a11, 4
42002cca:	249090        	extui	a9, a9, 0, 3
42002ccd:	208980        	or	a8, a9, a8
42002cd0:	1b89      	s32i.n	a8, a11, 4
        heap_bubble_down(i);
42002cd2:	fff2e5        	call8	42002c00 <heap_bubble_down>
        if (s_log_cache_max_generation == MAX_GENERATION) {
42002cd5:	0388      	l32i.n	a8, a3, 0
42002cd7:	0d9827        	bne	a8, a2, 42002ce8 <esp_log_cache_get_level+0xac>
            fix_cache_generation_overflow();
42002cda:	ffed65        	call8	42002bb0 <fix_cache_generation_overflow>
    return true;
42002cdd:	120c      	movi.n	a2, 1
42002cdf:	0001c6        	j	42002cea <esp_log_cache_get_level+0xae>
42002ce2:	120c      	movi.n	a2, 1
42002ce4:	000086        	j	42002cea <esp_log_cache_get_level+0xae>
42002ce7:	120c00        	andbc	b0, b12, b0
}
42002cea:	f01d      	retw.n

42002cec <esp_log_cache_add>:
{
42002cec:	004136        	entry	a1, 32
    uint32_t generation = s_log_cache_max_generation++;
42002cef:	f5da81        	l32r	a8, 42000458 <_stext+0x438> (3fc94e34 <s_log_cache_max_generation>)
42002cf2:	0898      	l32i.n	a9, a8, 0
42002cf4:	a91b      	addi.n	a10, a9, 1
42002cf6:	08a9      	s32i.n	a10, a8, 0
    if (s_log_cache_entry_count < TAG_CACHE_SIZE) {
42002cf8:	f5d781        	l32r	a8, 42000454 <_stext+0x434> (3fc94e30 <s_log_cache_entry_count>)
42002cfb:	08b8      	l32i.n	a11, a8, 0
42002cfd:	e81c      	movi.n	a8, 30
42002cff:	2e38b7        	bltu	a8, a11, 42002d31 <esp_log_cache_add+0x45>
        s_log_cache[s_log_cache_entry_count] = (cached_tag_entry_t) {
42002d02:	f5d3a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002d05:	b0aba0        	addx8	a10, a11, a10
42002d08:	0a29      	s32i.n	a2, a10, 0
42002d0a:	243030        	extui	a3, a3, 0, 3
42002d0d:	1a88      	l32i.n	a8, a10, 4
42002d0f:	8c7c      	movi.n	a12, -8
42002d11:	1088c0        	and	a8, a8, a12
42002d14:	208830        	or	a8, a8, a3
42002d17:	1a89      	s32i.n	a8, a10, 4
42002d19:	1199d0        	slli	a9, a9, 3
42002d1c:	248080        	extui	a8, a8, 0, 3
42002d1f:	208890        	or	a8, a8, a9
42002d22:	1a89      	s32i.n	a8, a10, 4
        ++s_log_cache_entry_count;
42002d24:	bb1b      	addi.n	a11, a11, 1
42002d26:	f5cb81        	l32r	a8, 42000454 <_stext+0x434> (3fc94e30 <s_log_cache_entry_count>)
42002d29:	08b9      	s32i.n	a11, a8, 0
42002d2b:	000a06        	j	42002d57 <esp_log_cache_add+0x6b>
42002d2e:	000000        	ill
        s_log_cache[0] = (cached_tag_entry_t) {
42002d31:	f5c7a1        	l32r	a10, 42000450 <_stext+0x430> (3fc94e38 <s_log_cache>)
42002d34:	006a22        	s32i	a2, a10, 0
42002d37:	243030        	extui	a3, a3, 0, 3
42002d3a:	012a82        	l32i	a8, a10, 4
42002d3d:	8b7c      	movi.n	a11, -8
42002d3f:	1088b0        	and	a8, a8, a11
42002d42:	208830        	or	a8, a8, a3
42002d45:	1a89      	s32i.n	a8, a10, 4
42002d47:	1199d0        	slli	a9, a9, 3
42002d4a:	248080        	extui	a8, a8, 0, 3
42002d4d:	208890        	or	a8, a8, a9
42002d50:	1a89      	s32i.n	a8, a10, 4
        heap_bubble_down(0);
42002d52:	0a0c      	movi.n	a10, 0
42002d54:	ffeaa5        	call8	42002c00 <heap_bubble_down>
    if (s_log_cache_max_generation == MAX_GENERATION) {
42002d57:	f5c081        	l32r	a8, 42000458 <_stext+0x438> (3fc94e34 <s_log_cache_max_generation>)
42002d5a:	0898      	l32i.n	a9, a8, 0
42002d5c:	f5c481        	l32r	a8, 4200046c <_stext+0x44c> (1fffffff <UserFrameTotalSize+0x1ffffeff>)
42002d5f:	029987        	bne	a9, a8, 42002d65 <esp_log_cache_add+0x79>
        fix_cache_generation_overflow();
42002d62:	ffe4e5        	call8	42002bb0 <fix_cache_generation_overflow>
}
42002d65:	f01d      	retw.n
	...

42002d68 <heap_caps_get_info>:
{
42002d68:	008136        	entry	a1, 64
    memset(info, 0, sizeof(multi_heap_info_t));
42002d6b:	cc1c      	movi.n	a12, 28
42002d6d:	0b0c      	movi.n	a11, 0
42002d6f:	20a220        	or	a10, a2, a2
42002d72:	f56481        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
42002d75:	0008e0        	callx8	a8
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002d78:	f5be81        	l32r	a8, 42000470 <_stext+0x450> (3fc94f38 <registered_heaps>)
42002d7b:	0878      	l32i.n	a7, a8, 0
42002d7d:	001346        	j	42002dce <heap_caps_get_info+0x66>
42002d80:	00          	.byte	00
42002d81:	00          	.byte	00
        if (heap_caps_match(heap, caps)) {
42002d82:	03bd      	mov.n	a11, a3
42002d84:	07ad      	mov.n	a10, a7
42002d86:	138065        	call8	4201658c <heap_caps_match>
42002d89:	03fa16        	beqz	a10, 42002dcc <heap_caps_get_info+0x64>
            multi_heap_get_info(heap->heap, &hinfo);
42002d8c:	01bd      	mov.n	a11, a1
42002d8e:	77a8      	l32i.n	a10, a7, 28
42002d90:	1634e5        	call8	420190e0 <multi_heap_get_info>
            info->total_free_bytes += hinfo.total_free_bytes - MULTI_HEAP_BLOCK_OWNER_SIZE();
42002d93:	0288      	l32i.n	a8, a2, 0
42002d95:	0198      	l32i.n	a9, a1, 0
42002d97:	889a      	add.n	a8, a8, a9
42002d99:	0289      	s32i.n	a8, a2, 0
            info->total_allocated_bytes += (hinfo.total_allocated_bytes -
42002d9b:	1288      	l32i.n	a8, a2, 4
42002d9d:	1198      	l32i.n	a9, a1, 4
42002d9f:	889a      	add.n	a8, a8, a9
42002da1:	1289      	s32i.n	a8, a2, 4
            info->largest_free_block = MAX(info->largest_free_block,
42002da3:	2298      	l32i.n	a9, a2, 8
42002da5:	2188      	l32i.n	a8, a1, 8
42002da7:	738890        	maxu	a8, a8, a9
42002daa:	2289      	s32i.n	a8, a2, 8
            info->minimum_free_bytes += hinfo.minimum_free_bytes - MULTI_HEAP_BLOCK_OWNER_SIZE();
42002dac:	3288      	l32i.n	a8, a2, 12
42002dae:	3198      	l32i.n	a9, a1, 12
42002db0:	889a      	add.n	a8, a8, a9
42002db2:	3289      	s32i.n	a8, a2, 12
            info->allocated_blocks += hinfo.allocated_blocks;
42002db4:	4288      	l32i.n	a8, a2, 16
42002db6:	4198      	l32i.n	a9, a1, 16
42002db8:	889a      	add.n	a8, a8, a9
42002dba:	4289      	s32i.n	a8, a2, 16
            info->free_blocks += hinfo.free_blocks;
42002dbc:	5288      	l32i.n	a8, a2, 20
42002dbe:	5198      	l32i.n	a9, a1, 20
42002dc0:	889a      	add.n	a8, a8, a9
42002dc2:	5289      	s32i.n	a8, a2, 20
            info->total_blocks += hinfo.total_blocks;
42002dc4:	6288      	l32i.n	a8, a2, 24
42002dc6:	6198      	l32i.n	a9, a1, 24
42002dc8:	889a      	add.n	a8, a8, a9
42002dca:	6289      	s32i.n	a8, a2, 24
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002dcc:	8778      	l32i.n	a7, a7, 32
42002dce:	fb0756        	bnez	a7, 42002d82 <heap_caps_get_info+0x1a>
}
42002dd1:	f01d      	retw.n
	...

42002dd4 <heap_caps_get_largest_free_block>:
{
42002dd4:	008136        	entry	a1, 64
42002dd7:	20b220        	or	a11, a2, a2
    heap_caps_get_info(&info, caps);
42002dda:	20a110        	or	a10, a1, a1
42002ddd:	fff8a5        	call8	42002d68 <heap_caps_get_info>
}
42002de0:	022122        	l32i	a2, a1, 8
42002de3:	f01d      	retw.n
42002de5:	000000        	ill

42002de8 <sorted_add_to_registered_heaps>:
 *
 * @param new_heap heap to be inserted in the list of registered
 * heaps
 */
static void sorted_add_to_registered_heaps(heap_t *new_heap)
{
42002de8:	004136        	entry	a1, 32
    // if list empty, insert head and return
    if (SLIST_EMPTY(&registered_heaps)) {
42002deb:	f5a181        	l32r	a8, 42000470 <_stext+0x450> (3fc94f38 <registered_heaps>)
42002dee:	08d8      	l32i.n	a13, a8, 0
42002df0:	5dcc      	bnez.n	a13, 42002df9 <sorted_add_to_registered_heaps+0x11>
        SLIST_INSERT_HEAD(&registered_heaps, new_heap, next);
42002df2:	82d9      	s32i.n	a13, a2, 32
42002df4:	0829      	s32i.n	a2, a8, 0
        return;
42002df6:	000ec6        	j	42002e35 <sorted_add_to_registered_heaps+0x4d>

    // else, go through the registered heaps and add the new one
    // so the registered heaps are sorted by increasing heap size.
    heap_t *cur_heap = NULL;
    heap_t *prev_heap = NULL;
    const size_t new_heap_size = new_heap->end - new_heap->start;
42002df9:	42b8      	l32i.n	a11, a2, 16
42002dfb:	3288      	l32i.n	a8, a2, 12
42002dfd:	c0bb80        	sub	a11, a11, a8
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002e00:	0d8d      	mov.n	a8, a13
    heap_t *prev_heap = NULL;
42002e02:	0c0c      	movi.n	a12, 0
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002e04:	000906        	j	42002e2c <sorted_add_to_registered_heaps+0x44>
42002e07:	489800        	ssx	f9, a8, a0
        const size_t cur_heap_size = cur_heap->end - cur_heap->start;
42002e0a:	38a8      	l32i.n	a10, a8, 12
42002e0c:	c099a0        	sub	a9, a9, a10
        if (cur_heap_size >= new_heap_size) {
42002e0f:	1539b7        	bltu	a9, a11, 42002e28 <sorted_add_to_registered_heaps+0x40>
            if (prev_heap != NULL) {
42002e12:	7c8c      	beqz.n	a12, 42002e1d <sorted_add_to_registered_heaps+0x35>
                SLIST_INSERT_AFTER(prev_heap, new_heap, next);
42002e14:	8c88      	l32i.n	a8, a12, 32
42002e16:	8289      	s32i.n	a8, a2, 32
42002e18:	8c29      	s32i.n	a2, a12, 32
42002e1a:	0005c6        	j	42002e35 <sorted_add_to_registered_heaps+0x4d>
            } else {
                SLIST_INSERT_HEAD(&registered_heaps, new_heap, next);
42002e1d:	82d9      	s32i.n	a13, a2, 32
42002e1f:	f59481        	l32r	a8, 42000470 <_stext+0x450> (3fc94f38 <registered_heaps>)
42002e22:	0829      	s32i.n	a2, a8, 0
            }
            return;
42002e24:	000346        	j	42002e35 <sorted_add_to_registered_heaps+0x4d>
42002e27:	08cd00        	lsx	f12, a13, a0
    SLIST_FOREACH(cur_heap, &registered_heaps, next) {
42002e2a:	8888      	l32i.n	a8, a8, 32
42002e2c:	fd8856        	bnez	a8, 42002e08 <sorted_add_to_registered_heaps+0x20>
        }
        prev_heap = cur_heap;
    }

    // new heap size if the biggest so far, insert it at the end
    SLIST_INSERT_AFTER(prev_heap, new_heap, next);
42002e2f:	8c88      	l32i.n	a8, a12, 32
42002e31:	8289      	s32i.n	a8, a2, 32
42002e33:	8c29      	s32i.n	a2, a12, 32
}
42002e35:	f01d      	retw.n
	...

42002e38 <register_heap>:

static void register_heap(heap_t *region)
{
42002e38:	004136        	entry	a1, 32
    size_t heap_size = region->end - region->start;
42002e3b:	42b8      	l32i.n	a11, a2, 16
42002e3d:	32a8      	l32i.n	a10, a2, 12
42002e3f:	c0bba0        	sub	a11, a11, a10
    assert(heap_size <= HEAP_SIZE_MAX);
42002e42:	f58c81        	l32r	a8, 42000474 <_stext+0x454> (2000000 <UserFrameTotalSize+0x1ffff00>)
42002e45:	10b8b7        	bgeu	a8, a11, 42002e59 <register_heap+0x21>
42002e48:	f58cd1        	l32r	a13, 42000478 <_stext+0x458> (3c0215fc <_flash_rodata_start+0x14dc>)
42002e4b:	f58cc1        	l32r	a12, 4200047c <_stext+0x45c> (3c026884 <__func__$3>)
42002e4e:	7b4c      	movi.n	a11, 71
42002e50:	f58ca1        	l32r	a10, 42000480 <_stext+0x460> (3c02162e <_flash_rodata_start+0x150e>)
42002e53:	f4ad81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42002e56:	0008e0        	callx8	a8
    region->heap = multi_heap_register((void *)region->start, heap_size);
42002e59:	162365        	call8	42019090 <multi_heap_register>
42002e5c:	72a9      	s32i.n	a10, a2, 28
    if (region->heap != NULL) {
        ESP_EARLY_LOGD(TAG, "New heap initialised at %p", region->heap);
    }
}
42002e5e:	f01d      	retw.n

42002e60 <heap_caps_enable_nonos_stack_heaps>:

void heap_caps_enable_nonos_stack_heaps(void)
{
42002e60:	004136        	entry	a1, 32
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002e63:	f58381        	l32r	a8, 42000470 <_stext+0x450> (3fc94f38 <registered_heaps>)
42002e66:	0878      	l32i.n	a7, a8, 0
42002e68:	0006c6        	j	42002e87 <heap_caps_enable_nonos_stack_heaps+0x27>
42002e6b:	278200        	ee.stf.64.xp	f8, f2, a0, a2
        // Assume any not-yet-registered heap is
        // a nonos-stack heap
        if (heap->heap == NULL) {
42002e6e:	285607        	bbc	a6, a0, 42002e9a <heap_caps_init+0xe>
42002e71:	a77001        	l32r	a0, 41fecc34 <_iram_bss_end+0x1c6a834>
            register_heap(heap);
42002e74:	20          	.byte	0x20
42002e75:	fffc25        	call8	42002e38 <register_heap>
            if (heap->heap != NULL) {
42002e78:	77a8      	l32i.n	a10, a7, 28
42002e7a:	7a8c      	beqz.n	a10, 42002e85 <heap_caps_enable_nonos_stack_heaps+0x25>
                multi_heap_set_lock(heap->heap, &heap->heap_mux);
42002e7c:	14c7b2        	addi	a11, a7, 20
42002e7f:	f58181        	l32r	a8, 42000484 <_stext+0x464> (4037e7a4 <multi_heap_set_lock>)
42002e82:	0008e0        	callx8	a8
    SLIST_FOREACH(heap, &registered_heaps, next) {
42002e85:	8778      	l32i.n	a7, a7, 32
42002e87:	fe1756        	bnez	a7, 42002e6c <heap_caps_enable_nonos_stack_heaps+0xc>
            }
        }
    }
}
42002e8a:	f01d      	retw.n

42002e8c <heap_caps_init>:

/* Initialize the heap allocator to use all of the memory not
   used by static data or reserved for other purposes
 */
void heap_caps_init(void)
{
42002e8c:	00a136        	entry	a1, 80
42002e8f:	207110        	or	a7, a1, a1
    multi_heap_in_rom_init();
#endif
    /* Get the array of regions that we can use for heaps
       (with reserved memory removed already.)
     */
    size_t num_regions = soc_get_available_memory_region_max_count();
42002e92:	003725        	call8	42003204 <soc_get_available_memory_region_max_count>
    soc_memory_region_t regions[num_regions];
42002e95:	a08aa0        	addx4	a8, a10, a10
42002e98:	1188e0        	slli	a8, a8, 2
42002e9b:	0fc882        	addi	a8, a8, 15
42002e9e:	418480        	srli	a8, a8, 4
42002ea1:	1188c0        	slli	a8, a8, 4
42002ea4:	c08180        	sub	a8, a1, a8
42002ea7:	001810        	movsp	a1, a8
42002eaa:	13c152        	addi	a5, a1, 19
42002ead:	415250        	srli	a5, a5, 2
42002eb0:	1155e0        	slli	a5, a5, 2
    num_regions = soc_get_available_memory_regions(regions);
42002eb3:	20a550        	or	a10, a5, a5
42002eb6:	003625        	call8	42003218 <soc_get_available_memory_regions>
42002eb9:	0acd      	mov.n	a12, a10
42002ebb:	87a9      	s32i.n	a10, a7, 32

    // the following for loop will calculate the number of possible heaps
    // based on how many regions were coalesced.
    size_t num_heaps = num_regions;
42002ebd:	67a9      	s32i.n	a10, a7, 24

    //The heap allocator will treat every region given to it as separate. In order to get bigger ranges of contiguous memory,
    //it's useful to coalesce adjacent regions that have the same type.
    for (size_t i = 1; i < num_regions; i++) {
42002ebf:	180c      	movi.n	a8, 1
42002ec1:	001886        	j	42002f27 <heap_caps_init+0x9b>
42002ec4:	00          	.byte	00
        soc_memory_region_t *a = &regions[i - 1];
42002ec5:	a80b      	addi.n	a10, a8, -1
        soc_memory_region_t *b = &regions[i];
        if (b->start == (intptr_t)(a->start + a->size) && b->type == a->type && b->startup_stack == a->startup_stack ) {
42002ec7:	a09880        	addx4	a9, a8, a8
42002eca:	a09950        	addx4	a9, a9, a5
42002ecd:	09e8      	l32i.n	a14, a9, 0
42002ecf:	a09aa0        	addx4	a9, a10, a10
42002ed2:	a09950        	addx4	a9, a9, a5
42002ed5:	09b8      	l32i.n	a11, a9, 0
42002ed7:	1998      	l32i.n	a9, a9, 4
42002ed9:	db9a      	add.n	a13, a11, a9
42002edb:	469ed7        	bne	a14, a13, 42002f25 <heap_caps_init+0x99>
42002ede:	a0d880        	addx4	a13, a8, a8
42002ee1:	a0dd50        	addx4	a13, a13, a5
42002ee4:	2de8      	l32i.n	a14, a13, 8
42002ee6:	a0daa0        	addx4	a13, a10, a10
42002ee9:	a0dd50        	addx4	a13, a13, a5
42002eec:	2dd8      	l32i.n	a13, a13, 8
42002eee:	339ed7        	bne	a14, a13, 42002f25 <heap_caps_init+0x99>
42002ef1:	a0d880        	addx4	a13, a8, a8
42002ef4:	a0dd50        	addx4	a13, a13, a5
42002ef7:	100de2        	l8ui	a14, a13, 16
42002efa:	a0daa0        	addx4	a13, a10, a10
42002efd:	a0dd50        	addx4	a13, a13, a5
42002f00:	100dd2        	l8ui	a13, a13, 16
42002f03:	1e9ed7        	bne	a14, a13, 42002f25 <heap_caps_init+0x99>
            a->type = -1;
42002f06:	a0aaa0        	addx4	a10, a10, a10
42002f09:	a0aa50        	addx4	a10, a10, a5
42002f0c:	fd7c      	movi.n	a13, -1
42002f0e:	2ad9      	s32i.n	a13, a10, 8
            b->start = a->start;
42002f10:	a0a880        	addx4	a10, a8, a8
42002f13:	a0aa50        	addx4	a10, a10, a5
42002f16:	0ab9      	s32i.n	a11, a10, 0
            b->size += a->size;
42002f18:	1ab8      	l32i.n	a11, a10, 4
42002f1a:	99ba      	add.n	a9, a9, a11
42002f1c:	1a99      	s32i.n	a9, a10, 4

            // remove one heap from the number of heaps as
            // 2 regions just got coalesced.
            num_heaps--;
42002f1e:	6798      	l32i.n	a9, a7, 24
42002f20:	8099d0        	add	a9, a9, a13
42002f23:	6799      	s32i.n	a9, a7, 24
    for (size_t i = 1; i < num_regions; i++) {
42002f25:	881b      	addi.n	a8, a8, 1
42002f27:	9a38c7        	bltu	a8, a12, 42002ec5 <heap_caps_init+0x39>

    /* Start by allocating the registered heap data on the stack.

       Once we have a heap to copy it to, we will copy it to a heap buffer.
    */
    heap_t temp_heaps[num_heaps];
42002f2a:	6788      	l32i.n	a8, a7, 24
42002f2c:	b08880        	addx8	a8, a8, a8
42002f2f:	1128e0        	slli	a2, a8, 2
42002f32:	0fc282        	addi	a8, a2, 15
42002f35:	418480        	srli	a8, a8, 4
42002f38:	1188c0        	slli	a8, a8, 4
42002f3b:	c08180        	sub	a8, a1, a8
42002f3e:	001810        	movsp	a1, a8
42002f41:	13c182        	addi	a8, a1, 19
42002f44:	418280        	srli	a8, a8, 2
42002f47:	1138e0        	slli	a3, a8, 2
42002f4a:	f43881        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42002f4d:	002882        	l32i	a8, a8, 0
    size_t heap_idx = 0;

    ESP_EARLY_LOGI(TAG, "Initializing. RAM available for dynamic allocation:");
42002f50:	0238f6        	bgeui	a8, 3, 42002f56 <heap_caps_init+0xca>
42002f53:	0046c6        	j	42003072 <heap_caps_init+0x1e6>
42002f56:	f44281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42002f59:	0008e0        	callx8	a8
42002f5c:	f54bc1        	l32r	a12, 42000488 <_stext+0x468> (3c021640 <_flash_rodata_start+0x1520>)
42002f5f:	0abd      	mov.n	a11, a10
42002f61:	f54aa1        	l32r	a10, 4200048c <_stext+0x46c> (3c02164c <_flash_rodata_start+0x152c>)
42002f64:	f44081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42002f67:	0008e0        	callx8	a8
42002f6a:	004106        	j	42003072 <heap_caps_init+0x1e6>
    for (size_t i = 0; i < num_regions; i++) {
        soc_memory_region_t *region = &regions[i];
        const soc_memory_type_desc_t *type = &soc_memory_types[region->type];
42002f6d:	a08440        	addx4	a8, a4, a4
42002f70:	a08850        	addx4	a8, a8, a5
42002f73:	2828      	l32i.n	a2, a8, 8
        heap_t *heap = &temp_heaps[heap_idx];
42002f75:	b08660        	addx8	a8, a6, a6
42002f78:	a08830        	addx4	a8, a8, a3
42002f7b:	7789      	s32i.n	a8, a7, 28
        if (region->type == -1) {
42002f7d:	100266        	bnei	a2, -1, 42002f91 <heap_caps_init+0x105>
            memset(heap, 0, sizeof(*heap));
42002f80:	4c2c      	movi.n	a12, 36
42002f82:	0b0c      	movi.n	a11, 0
42002f84:	08ad      	mov.n	a10, a8
42002f86:	f4df81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
42002f89:	0008e0        	callx8	a8
            continue;
42002f8c:	5769      	s32i.n	a6, a7, 20
42002f8e:	003586        	j	42003068 <heap_caps_init+0x1dc>
        }
        heap_idx++;
42002f91:	861b      	addi.n	a8, a6, 1
42002f93:	5789      	s32i.n	a8, a7, 20
        assert(heap_idx <= num_heaps);
42002f95:	6798      	l32i.n	a9, a7, 24
42002f97:	11b987        	bgeu	a9, a8, 42002fac <heap_caps_init+0x120>
42002f9a:	f53dd1        	l32r	a13, 42000490 <_stext+0x470> (3c021690 <_flash_rodata_start+0x1570>)
42002f9d:	f53dc1        	l32r	a12, 42000494 <_stext+0x474> (3c026874 <__func__$2>)
42002fa0:	92a0b2        	movi	a11, 146
42002fa3:	f537a1        	l32r	a10, 42000480 <_stext+0x460> (3c02162e <_flash_rodata_start+0x150e>)
42002fa6:	f45881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42002fa9:	0008e0        	callx8	a8

        // add the name of the newly created heap to match the region name in which it will be created
#if CONFIG_HEAP_TASK_TRACKING
        heap->name = type->name;
#endif // CONFIG_HEAP_TASK_TRACKING
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
42002fac:	b08660        	addx8	a8, a6, a6
42002faf:	a0a830        	addx4	a10, a8, a3
42002fb2:	11b2c0        	slli	a11, a2, 4
42002fb5:	f53881        	l32r	a8, 42000498 <_stext+0x478> (3c026ae4 <soc_memory_types>)
42002fb8:	bb8a      	add.n	a11, a11, a8
42002fba:	cc0c      	movi.n	a12, 12
42002fbc:	04cbb2        	addi	a11, a11, 4
42002fbf:	0467a2        	s32i	a10, a7, 16
42002fc2:	f41981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42002fc5:	0008e0        	callx8	a8
        heap->start = region->start;
42002fc8:	a09440        	addx4	a9, a4, a4
42002fcb:	a09950        	addx4	a9, a9, a5
42002fce:	0988      	l32i.n	a8, a9, 0
42002fd0:	47a8      	l32i.n	a10, a7, 16
42002fd2:	3a89      	s32i.n	a8, a10, 12
        heap->end = region->start + region->size;
42002fd4:	1998      	l32i.n	a9, a9, 4
42002fd6:	889a      	add.n	a8, a8, a9
42002fd8:	4a89      	s32i.n	a8, a10, 16
        MULTI_HEAP_LOCK_INIT(&heap->heap_mux);
42002fda:	1186d0        	slli	a8, a6, 3
42002fdd:	886a      	add.n	a8, a8, a6
42002fdf:	1188e0        	slli	a8, a8, 2
42002fe2:	10c882        	addi	a8, a8, 16
42002fe5:	838a      	add.n	a8, a3, a8
42002fe7:	884b      	addi.n	a8, a8, 4
    assert(lock);
42002fe9:	f8cc      	bnez.n	a8, 42002ffc <heap_caps_init+0x170>
42002feb:	f52cd1        	l32r	a13, 4200049c <_stext+0x47c> (3c0216a8 <_flash_rodata_start+0x1588>)
42002fee:	f52cc1        	l32r	a12, 420004a0 <_stext+0x480> (3c026860 <__func__$1>)
42002ff1:	5b3c      	movi.n	a11, 53
42002ff3:	f52ca1        	l32r	a10, 420004a4 <_stext+0x484> (3c0216d8 <_flash_rodata_start+0x15b8>)
42002ff6:	f44481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42002ff9:	0008e0        	callx8	a8
    lock->owner = SPINLOCK_FREE;
42002ffc:	b08660        	addx8	a8, a6, a6
42002fff:	a08830        	addx4	a8, a8, a3
42003002:	f52991        	l32r	a9, 420004a8 <_stext+0x488> (b33fffff <_rtc_reserved_end+0x532fffff>)
42003005:	5899      	s32i.n	a9, a8, 20
    lock->count = 0;
42003007:	090c      	movi.n	a9, 0
42003009:	6899      	s32i.n	a9, a8, 24
        if (region->startup_stack) {
4200300b:	a08440        	addx4	a8, a4, a4
4200300e:	a08850        	addx4	a8, a8, a5
42003011:	100882        	l8ui	a8, a8, 16
42003014:	988c      	beqz.n	a8, 42003021 <heap_caps_init+0x195>
            /* Will be registered when OS scheduler starts */
            heap->heap = NULL;
42003016:	b08660        	addx8	a8, a6, a6
42003019:	a08830        	addx4	a8, a8, a3
4200301c:	7899      	s32i.n	a9, a8, 28
4200301e:	000146        	j	42003027 <heap_caps_init+0x19b>
        } else {
            register_heap(heap);
42003021:	0727a2        	l32i	a10, a7, 28
42003024:	ffe125        	call8	42002e38 <register_heap>
        }
        SLIST_NEXT(heap, next) = NULL;
42003027:	b06660        	addx8	a6, a6, a6
4200302a:	a06630        	addx4	a6, a6, a3
4200302d:	00a082        	movi	a8, 0
42003030:	086682        	s32i	a8, a6, 32
42003033:	f3fe81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42003036:	0888      	l32i.n	a8, a8, 0

        ESP_EARLY_LOGI(TAG, "At %08X len %08X (%d KiB): %s",
42003038:	2c38b6        	bltui	a8, 3, 42003068 <heap_caps_init+0x1dc>
4200303b:	f40981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200303e:	0008e0        	callx8	a8
42003041:	a08440        	addx4	a8, a4, a4
42003044:	a08850        	addx4	a8, a8, a5
42003047:	18e8      	l32i.n	a14, a8, 4
42003049:	1122c0        	slli	a2, a2, 4
4200304c:	f51391        	l32r	a9, 42000498 <_stext+0x478> (3c026ae4 <soc_memory_types>)
4200304f:	992a      	add.n	a9, a9, a2
42003051:	0998      	l32i.n	a9, a9, 0
42003053:	0199      	s32i.n	a9, a1, 0
42003055:	41fae0        	srli	a15, a14, 10
42003058:	08d8      	l32i.n	a13, a8, 0
4200305a:	f50bc1        	l32r	a12, 42000488 <_stext+0x468> (3c021640 <_flash_rodata_start+0x1520>)
4200305d:	0abd      	mov.n	a11, a10
4200305f:	f513a1        	l32r	a10, 420004ac <_stext+0x48c> (3c0216e4 <_flash_rodata_start+0x15c4>)
42003062:	f40081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003065:	0008e0        	callx8	a8
    for (size_t i = 0; i < num_regions; i++) {
42003068:	441b      	addi.n	a4, a4, 1
4200306a:	5768      	l32i.n	a6, a7, 20
4200306c:	000206        	j	42003078 <heap_caps_init+0x1ec>
4200306f:	000000        	ill
            continue;
42003072:	040c      	movi.n	a4, 0
42003074:	046d      	mov.n	a6, a4
42003076:	9729      	s32i.n	a2, a7, 36
    for (size_t i = 0; i < num_regions; i++) {
42003078:	8788      	l32i.n	a8, a7, 32
4200307a:	02b487        	bgeu	a4, a8, 42003080 <heap_caps_init+0x1f4>
4200307d:	ffbb06        	j	42002f6d <heap_caps_init+0xe1>
                       region->start, region->size, region->size / 1024, type->name);
    }

    assert(heap_idx == num_heaps);
42003080:	9728      	l32i.n	a2, a7, 36
42003082:	6788      	l32i.n	a8, a7, 24
42003084:	111867        	beq	a8, a6, 42003099 <heap_caps_init+0x20d>
42003087:	f50ad1        	l32r	a13, 420004b0 <_stext+0x490> (3c021710 <_flash_rodata_start+0x15f0>)
4200308a:	f502c1        	l32r	a12, 42000494 <_stext+0x474> (3c026874 <__func__$2>)
4200308d:	a8a0b2        	movi	a11, 168
42003090:	f4fca1        	l32r	a10, 42000480 <_stext+0x460> (3c02162e <_flash_rodata_start+0x150e>)
42003093:	f41d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42003096:	0008e0        	callx8	a8

    /* Allocate the permanent heap data that we'll use as a linked list at runtime.

       Allocate this part of data contiguously, even though it's a linked list... */
    assert(SLIST_EMPTY(&registered_heaps));
42003099:	f4f581        	l32r	a8, 42000470 <_stext+0x450> (3fc94f38 <registered_heaps>)
4200309c:	0888      	l32i.n	a8, a8, 0
4200309e:	38bc      	beqz.n	a8, 420030d5 <heap_caps_init+0x249>
420030a0:	f505d1        	l32r	a13, 420004b4 <_stext+0x494> (3c021728 <_flash_rodata_start+0x1608>)
420030a3:	f4fcc1        	l32r	a12, 42000494 <_stext+0x474> (3c026874 <__func__$2>)
420030a6:	ada0b2        	movi	a11, 173
420030a9:	f4f5a1        	l32r	a10, 42000480 <_stext+0x460> (3c02162e <_flash_rodata_start+0x150e>)
420030ac:	f41781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420030af:	0008e0        	callx8	a8

    heap_t *heaps_array = NULL;
    heap_t *used_heap = NULL;
    for (size_t i = 0; i < num_heaps; i++) {
        used_heap = temp_heaps + i;
420030b2:	b05660        	addx8	a5, a6, a6
420030b5:	a05530        	addx4	a5, a5, a3
        if (heap_caps_match(used_heap, MALLOC_CAP_8BIT|MALLOC_CAP_INTERNAL)) {
420030b8:	f500b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
420030bb:	05ad      	mov.n	a10, a5
420030bd:	134ce5        	call8	4201658c <heap_caps_match>
420030c0:	ca8c      	beqz.n	a10, 420030d0 <heap_caps_init+0x244>
            /* use the first DRAM heap which can fit the data.
             * the allocated block won't include the block owner bytes since this operation
             * is done by the top level API heap_caps_malloc(). So we need to add it manually
             * after successful allocation. Allocate extra 4 bytes for that purpose. */
            heaps_array = multi_heap_malloc(used_heap->heap, MULTI_HEAP_ADD_BLOCK_OWNER_SIZE(sizeof(heap_t) * num_heaps));
420030c2:	47b8      	l32i.n	a11, a7, 16
420030c4:	75a8      	l32i.n	a10, a5, 28
420030c6:	f4fe81        	l32r	a8, 420004c0 <_stext+0x4a0> (4037e6e4 <multi_heap_malloc>)
420030c9:	0008e0        	callx8	a8
420030cc:	0a4d      	mov.n	a4, a10
            if (heaps_array != NULL) {
420030ce:	eacc      	bnez.n	a10, 420030e0 <heap_caps_init+0x254>
    for (size_t i = 0; i < num_heaps; i++) {
420030d0:	661b      	addi.n	a6, a6, 1
420030d2:	0001c6        	j	420030dd <heap_caps_init+0x251>
420030d5:	060c      	movi.n	a6, 0
    heap_t *heaps_array = NULL;
420030d7:	064d      	mov.n	a4, a6
420030d9:	4729      	s32i.n	a2, a7, 16
420030db:	6728      	l32i.n	a2, a7, 24
    for (size_t i = 0; i < num_heaps; i++) {
420030dd:	d13627        	bltu	a6, a2, 420030b2 <heap_caps_init+0x226>
                break;
            }
        }
    }
    assert(heaps_array != NULL); /* if NULL, there's not enough free startup heap space */
420030e0:	4728      	l32i.n	a2, a7, 16
420030e2:	04dc      	bnez.n	a4, 420030f6 <heap_caps_init+0x26a>
420030e4:	f4f6d1        	l32r	a13, 420004bc <_stext+0x49c> (3c021748 <_flash_rodata_start+0x1628>)
420030e7:	f4ebc1        	l32r	a12, 42000494 <_stext+0x474> (3c026874 <__func__$2>)
420030ea:	bea0b2        	movi	a11, 190
420030ed:	f4e4a1        	l32r	a10, 42000480 <_stext+0x460> (3c02162e <_flash_rodata_start+0x150e>)
420030f0:	f40681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420030f3:	0008e0        	callx8	a8
    MULTI_HEAP_SET_BLOCK_OWNER(heaps_array);
    heaps_array = (heap_t *)MULTI_HEAP_ADD_BLOCK_OWNER_OFFSET(heaps_array);

    memcpy(heaps_array, temp_heaps, sizeof(heap_t)*num_heaps);
420030f6:	02cd      	mov.n	a12, a2
420030f8:	03bd      	mov.n	a11, a3
420030fa:	04ad      	mov.n	a10, a4
420030fc:	f3cb81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420030ff:	0008e0        	callx8	a8

    /* Iterate the heaps and set their locks, also add them to the linked list. */
    for (size_t i = 0; i < num_heaps; i++) {
42003102:	050c      	movi.n	a5, 0
42003104:	6738      	l32i.n	a3, a7, 24
42003106:	0006c6        	j	42003125 <heap_caps_init+0x299>
        if (heaps_array[i].heap != NULL) {
42003109:	b06550        	addx8	a6, a5, a5
4200310c:	a06640        	addx4	a6, a6, a4
4200310f:	76a8      	l32i.n	a10, a6, 28
42003111:	7a8c      	beqz.n	a10, 4200311c <heap_caps_init+0x290>
            multi_heap_set_lock(heaps_array[i].heap, &heaps_array[i].heap_mux);
42003113:	14c6b2        	addi	a11, a6, 20
42003116:	f4db81        	l32r	a8, 42000484 <_stext+0x464> (4037e7a4 <multi_heap_set_lock>)
42003119:	0008e0        	callx8	a8
         * to tail when looking for a suitable heap when allocating memory, it is
         * best to place smaller heap first. In that way, if several heaps share
         * the same set of capabilities, the smallest heaps will be used first when
         * processing small allocation requests, leaving the bigger heaps untouched
         * until the smaller heaps are full. */
        sorted_add_to_registered_heaps(&heaps_array[i]);
4200311c:	20a660        	or	a10, a6, a6
4200311f:	ffcca5        	call8	42002de8 <sorted_add_to_registered_heaps>
    for (size_t i = 0; i < num_heaps; i++) {
42003122:	01c552        	addi	a5, a5, 1
42003125:	e03537        	bltu	a5, a3, 42003109 <heap_caps_init+0x27d>
    heap_caps_update_per_task_info_alloc(used_heap,
                                         MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(heaps_array),
                                         multi_heap_get_full_block_size(used_heap->heap, MULTI_HEAP_REMOVE_BLOCK_OWNER_OFFSET(heaps_array)),
                                         get_all_caps(used_heap));
#endif
}
42003128:	000090        	retw
	...

4200312c <__esp_system_init_fn_init_heap>:
{
4200312c:	004136        	entry	a1, 32
    heap_caps_init();
4200312f:	ffd5e5        	call8	42002e8c <heap_caps_init>
}
42003132:	020c      	movi.n	a2, 0
42003134:	f01d      	retw.n
	...

42003138 <s_get_num_reserved_regions>:
*/
extern soc_reserved_region_t soc_reserved_memory_region_start;
extern soc_reserved_region_t soc_reserved_memory_region_end;

static size_t s_get_num_reserved_regions(void)
{
42003138:	004136        	entry	a1, 32
    size_t result = ( &soc_reserved_memory_region_end
             - &soc_reserved_memory_region_start );
4200313b:	f4e221        	l32r	a2, 420004c4 <_stext+0x4a4> (3c02921c <esp_system_init_fn_init_efuse_check>)
4200313e:	f4e281        	l32r	a8, 420004c8 <_stext+0x4a8> (3c0291f4 <reserved_region_rtc_reserved_data>)
42003141:	c02280        	sub	a2, a2, a8
42003144:	212320        	srai	a2, a2, 3
#if ESP_ROM_HAS_LAYOUT_TABLE
    return result + 1; // ROM table means one entry needs to be added at runtime
#else
    return result;
#endif
}
42003147:	221b      	addi.n	a2, a2, 1
42003149:	f01d      	retw.n
	...

4200314c <s_prepare_reserved_regions>:
/* Initialize a mutable array of reserved regions in 'reserved',
   then sort it by start address and check for overlapping
   reserved regions (illegal).
*/
static void s_prepare_reserved_regions(soc_reserved_region_t *reserved, size_t count)
{
4200314c:	006136        	entry	a1, 48
#if ESP_ROM_HAS_LAYOUT_TABLE
    /* Get the ROM layout to find which part of DRAM is reserved */
    const ets_rom_layout_t *layout = ets_rom_layout_p;
4200314f:	f4df81        	l32r	a8, 420004cc <_stext+0x4ac> (3ff1fffc <ets_rom_layout_p>)
42003152:	0888      	l32i.n	a8, a8, 0
    reserved[0].start = (intptr_t)layout->dram0_rtos_reserved_start;
42003154:	1888      	l32i.n	a8, a8, 4
42003156:	0289      	s32i.n	a8, a2, 0
#ifdef SOC_DIRAM_ROM_RESERVE_HIGH
    reserved[0].end = SOC_DIRAM_ROM_RESERVE_HIGH;
#else
    reserved[0].end = SOC_DIRAM_DRAM_HIGH;
42003158:	f4de81        	l32r	a8, 420004d0 <_stext+0x4b0> (3fcf0000 <ets_ops_table_ptr+0x4>)
4200315b:	1289      	s32i.n	a8, a2, 4
#endif

    memcpy(reserved + 1, &soc_reserved_memory_region_start, (count - 1) * sizeof(soc_reserved_region_t));
4200315d:	630b      	addi.n	a6, a3, -1
4200315f:	11c6d0        	slli	a12, a6, 3
42003162:	f4d9b1        	l32r	a11, 420004c8 <_stext+0x4a8> (3c0291f4 <reserved_region_rtc_reserved_data>)
42003165:	a28b      	addi.n	a10, a2, 8
42003167:	f3b081        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200316a:	0008e0        	callx8	a8
#else
    memcpy(reserved, &soc_reserved_memory_region_start, count * sizeof(soc_reserved_region_t));
#endif

    /* Sort by starting address */
    qsort(reserved, count, sizeof(soc_reserved_region_t), s_compare_reserved_regions);
4200316d:	f4d9d1        	l32r	a13, 420004d4 <_stext+0x4b4> (420165bc <s_compare_reserved_regions>)
42003170:	8c0c      	movi.n	a12, 8
42003172:	03bd      	mov.n	a11, a3
42003174:	02ad      	mov.n	a10, a2
42003176:	f4de81        	l32r	a8, 420004f0 <_stext+0x4d0> (40001488 <qsort>)
42003179:	0008e0        	callx8	a8
    /* Validity checks */
    ESP_EARLY_LOGV(TAG, "reserved range is %p - %p",
                   &soc_reserved_memory_region_start,
                   &soc_reserved_memory_region_end);
    ESP_EARLY_LOGD(TAG, "Checking %d reserved memory ranges:", count);
    for (size_t i = 0; i < count; i++) {
4200317c:	0a0c      	movi.n	a10, 0
4200317e:	001e86        	j	420031fc <s_prepare_reserved_regions+0xb0>
        ESP_EARLY_LOGD(TAG, "Reserved memory range 0x%08x - 0x%08x",
                       reserved[i].start, reserved[i].end);
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
42003181:	b07a20        	addx8	a7, a10, a2
42003184:	0798      	l32i.n	a9, a7, 0
42003186:	cb7c      	movi.n	a11, -4
42003188:	1099b0        	and	a9, a9, a11
4200318b:	0799      	s32i.n	a9, a7, 0
        reserved[i].end = (reserved[i].end + 3) & ~3;
4200318d:	1788      	l32i.n	a8, a7, 4
4200318f:	883b      	addi.n	a8, a8, 3
42003191:	1088b0        	and	a8, a8, a11
42003194:	016782        	s32i	a8, a7, 4
        assert(reserved[i].start <= reserved[i].end);
42003197:	11a897        	bge	a8, a9, 420031ac <s_prepare_reserved_regions+0x60>
4200319a:	f4cfd1        	l32r	a13, 420004d8 <_stext+0x4b8> (3c021f28 <_flash_rodata_start+0x1e08>)
4200319d:	f4cfc1        	l32r	a12, 420004dc <_stext+0x4bc> (3c0269fc <__func__$0>)
420031a0:	56a0b2        	movi	a11, 86
420031a3:	f4cfa1        	l32r	a10, 420004e0 <_stext+0x4c0> (3c021f6b <_flash_rodata_start+0x1e4b>)
420031a6:	f3d881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420031a9:	0008e0        	callx8	a8
        if (i < count - 1) {
420031ac:	4aba67        	bgeu	a10, a6, 420031fa <s_prepare_reserved_regions+0xae>
            assert(reserved[i + 1].start > reserved[i].start);
420031af:	5a1b      	addi.n	a5, a10, 1
420031b1:	b05520        	addx8	a5, a5, a2
420031b4:	0025b2        	l32i	a11, a5, 0
420031b7:	1129b7        	blt	a9, a11, 420031cc <s_prepare_reserved_regions+0x80>
420031ba:	f4cad1        	l32r	a13, 420004e4 <_stext+0x4c4> (3c021f84 <_flash_rodata_start+0x1e64>)
420031bd:	f4c7c1        	l32r	a12, 420004dc <_stext+0x4bc> (3c0269fc <__func__$0>)
420031c0:	58a0b2        	movi	a11, 88
420031c3:	f4c7a1        	l32r	a10, 420004e0 <_stext+0x4c0> (3c021f6b <_flash_rodata_start+0x1e4b>)
420031c6:	f3d081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420031c9:	0008e0        	callx8	a8
            if (reserved[i].end > reserved[i + 1].start) {
420031cc:	2aab87        	bge	a11, a8, 420031fa <s_prepare_reserved_regions+0xae>
420031cf:	f39781        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420031d2:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, "SOC_RESERVE_MEMORY_REGION region range " \
420031d4:	c89c      	beqz.n	a8, 420031f4 <s_prepare_reserved_regions+0xa8>
420031d6:	f3a281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420031d9:	0008e0        	callx8	a8
420031dc:	1588      	l32i.n	a8, a5, 4
420031de:	0189      	s32i.n	a8, a1, 0
420031e0:	05f8      	l32i.n	a15, a5, 0
420031e2:	17e8      	l32i.n	a14, a7, 4
420031e4:	07d8      	l32i.n	a13, a7, 0
420031e6:	f4c0c1        	l32r	a12, 420004e8 <_stext+0x4c8> (3c021fb0 <_flash_rodata_start+0x1e90>)
420031e9:	0abd      	mov.n	a11, a10
420031eb:	f4c0a1        	l32r	a10, 420004ec <_stext+0x4cc> (3c021fc0 <_flash_rodata_start+0x1ea0>)
420031ee:	f39d81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420031f1:	0008e0        	callx8	a8
                               "0x%08x - 0x%08x overlaps with 0x%08x - 0x%08x",
                               reserved[i].start, reserved[i].end, reserved[i + 1].start,
                               reserved[i + 1].end);
                abort();
420031f4:	f3ba81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
420031f7:	0008e0        	callx8	a8
    for (size_t i = 0; i < count; i++) {
420031fa:	aa1b      	addi.n	a10, a10, 1
420031fc:	813a37        	bltu	a10, a3, 42003181 <s_prepare_reserved_regions+0x35>
            }
        }
    }
}
420031ff:	f01d      	retw.n
42003201:	000000        	ill

42003204 <soc_get_available_memory_region_max_count>:
{
42003204:	004136        	entry	a1, 32
    return soc_memory_region_count + s_get_num_reserved_regions();
42003207:	fff325        	call8	42003138 <s_get_num_reserved_regions>
4200320a:	f4ba81        	l32r	a8, 420004f4 <_stext+0x4d4> (3c026a18 <soc_memory_region_count>)
4200320d:	002882        	l32i	a8, a8, 0
}
42003210:	802a80        	add	a2, a10, a8
42003213:	000090        	retw
	...

42003218 <soc_get_available_memory_regions>:

size_t soc_get_available_memory_regions(soc_memory_region_t *regions)
{
42003218:	00a136        	entry	a1, 80
4200321b:	207110        	or	a7, a1, a1
4200321e:	203220        	or	a3, a2, a2
42003221:	a729      	s32i.n	a2, a7, 40
    soc_memory_region_t *out_region = regions;
    /* make a local copy of the "input" regions so we can modify them */
    soc_memory_region_t in_regions[soc_memory_region_count];
42003223:	f4b481        	l32r	a8, 420004f4 <_stext+0x4d4> (3c026a18 <soc_memory_region_count>)
42003226:	0888      	l32i.n	a8, a8, 0
42003228:	a08880        	addx4	a8, a8, a8
4200322b:	1128e0        	slli	a2, a8, 2
4200322e:	82fb      	addi.n	a8, a2, 15
42003230:	418480        	srli	a8, a8, 4
42003233:	1188c0        	slli	a8, a8, 4
42003236:	c08180        	sub	a8, a1, a8
42003239:	001810        	movsp	a1, a8
4200323c:	014d      	mov.n	a4, a1
4200323e:	8719      	s32i.n	a1, a7, 32
    memcpy(in_regions, soc_memory_regions, sizeof(in_regions));
42003240:	20c220        	or	a12, a2, a2
42003243:	f4adb1        	l32r	a11, 420004f8 <_stext+0x4d8> (3c026a1c <soc_memory_regions>)
42003246:	01ad      	mov.n	a10, a1
42003248:	f37881        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200324b:	0008e0        	callx8	a8
    soc_memory_region_t *in_region = in_regions;

    size_t num_reserved = s_get_num_reserved_regions();
4200324e:	ffeea5        	call8	42003138 <s_get_num_reserved_regions>
42003251:	0a5d      	mov.n	a5, a10
    soc_reserved_region_t reserved[num_reserved];
42003253:	118ad0        	slli	a8, a10, 3
42003256:	88fb      	addi.n	a8, a8, 15
42003258:	418480        	srli	a8, a8, 4
4200325b:	1188c0        	slli	a8, a8, 4
4200325e:	c08180        	sub	a8, a1, a8
42003261:	001810        	movsp	a1, a8
42003264:	016d      	mov.n	a6, a1

    s_prepare_reserved_regions(reserved, num_reserved);
42003266:	0abd      	mov.n	a11, a10
42003268:	01ad      	mov.n	a10, a1
4200326a:	ffee25        	call8	4200314c <s_prepare_reserved_regions>
    soc_memory_region_t *out_region = regions;
4200326d:	9739      	s32i.n	a3, a7, 36
4200326f:	0026c6        	j	4200330e <soc_get_available_memory_regions+0xf6>
       sections removed from them) one at a time, trim off each reserved
       region, and then copy them to an out_region once trimmed
    */
    ESP_EARLY_LOGD(TAG, "Building list of available memory regions:");
    while (in_region != in_regions + soc_memory_region_count) {
        soc_memory_region_t in = *in_region;
42003272:	4c1c      	movi.n	a12, 20
42003274:	04bd      	mov.n	a11, a4
42003276:	07ad      	mov.n	a10, a7
42003278:	f36c81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200327b:	0008e0        	callx8	a8
        ESP_EARLY_LOGV(TAG, "Examining memory region 0x%08x - 0x%08x", in.start, in.start + in.size);
        intptr_t in_start = in.start;
4200327e:	07a8      	l32i.n	a10, a7, 0
        intptr_t in_end = in_start + in.size;
42003280:	17c8      	l32i.n	a12, a7, 4
42003282:	caca      	add.n	a12, a10, a12
        bool copy_in_to_out = true;
        bool move_to_next = true;

        for (size_t i = 0; i < num_reserved; i++) {
42003284:	080c      	movi.n	a8, 0
42003286:	001406        	j	420032da <soc_get_available_memory_regions+0xc2>
            if (reserved[i].end <= in_start) {
42003289:	b09860        	addx8	a9, a8, a6
4200328c:	19b8      	l32i.n	a11, a9, 4
4200328e:	46aab7        	bge	a10, a11, 420032d8 <soc_get_available_memory_regions+0xc0>
                /* reserved region ends before 'in' starts */
                continue;
            } else if (reserved[i].start >= in_end) {
42003291:	0998      	l32i.n	a9, a9, 0
42003293:	4da9c7        	bge	a9, a12, 420032e4 <soc_get_available_memory_regions+0xcc>
                /* reserved region starts after 'in' ends */
                break;
            } else if (reserved[i].start <= in_start &&
42003296:	022a97        	blt	a10, a9, 4200329c <soc_get_available_memory_regions+0x84>
42003299:	4eabc7        	bge	a11, a12, 420032eb <soc_get_available_memory_regions+0xd3>
                ESP_EARLY_LOGV(TAG, "Region 0x%08x - 0x%08x inside of reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                /* skip 'in' entirely */
                copy_in_to_out = false;
                break;
            } else if (in_start < reserved[i].start &&
4200329c:	21aa97        	bge	a10, a9, 420032c1 <soc_get_available_memory_regions+0xa9>
4200329f:	1eabc7        	bge	a11, a12, 420032c1 <soc_get_available_memory_regions+0xa9>
                assert(in_start < reserved[i].start);
                assert(in_end > reserved[i].end);

                /* shrink this region to end where the reserved section starts */
                in_end = reserved[i].start;
                in.size = in_end - in_start;
420032a2:	c099a0        	sub	a9, a9, a10
420032a5:	1799      	s32i.n	a9, a7, 4

                /* update in_region so the 'next' iteration uses the region
                   after the reserved section */
                in_region->size -= (reserved[i].end - in_region->start);
420032a7:	1498      	l32i.n	a9, a4, 4
420032a9:	04a8      	l32i.n	a10, a4, 0
420032ab:	c0bba0        	sub	a11, a11, a10
420032ae:	c099b0        	sub	a9, a9, a11
420032b1:	1499      	s32i.n	a9, a4, 4
                in_region->start = reserved[i].end;
420032b3:	b08860        	addx8	a8, a8, a6
420032b6:	1888      	l32i.n	a8, a8, 4
420032b8:	0489      	s32i.n	a8, a4, 0

                /* add first region, then re-run while loop with the updated in_region */
                move_to_next = false;
420032ba:	030c      	movi.n	a3, 0
        bool copy_in_to_out = true;
420032bc:	1a0c      	movi.n	a10, 1
                break;
420032be:	000b46        	j	420032ef <soc_get_available_memory_regions+0xd7>
            } else if (reserved[i].start <= in_start) { /* reserved overlaps start of 'in' */
420032c1:	0c2a97        	blt	a10, a9, 420032d1 <soc_get_available_memory_regions+0xb9>
                ESP_EARLY_LOGV(TAG, "Start of region 0x%08x - 0x%08x overlaps reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                in.start = reserved[i].end;
420032c4:	07b9      	s32i.n	a11, a7, 0
                in_start = in.start;
                in.size = in_end - in_start;
420032c6:	c09cb0        	sub	a9, a12, a11
420032c9:	1799      	s32i.n	a9, a7, 4
                in_start = in.start;
420032cb:	0bad      	mov.n	a10, a11
420032cd:	0001c6        	j	420032d8 <soc_get_available_memory_regions+0xc0>
420032d0:	00          	.byte	00
            } else { /* reserved overlaps end of 'in' */
                ESP_EARLY_LOGV(TAG, "End of region 0x%08x - 0x%08x overlaps reserved 0x%08x - 0x%08x",
                               in_start, in_end, reserved[i].start, reserved[i].end);
                in_end = reserved[i].start;
                in.size = in_end - in_start;
420032d1:	c0b9a0        	sub	a11, a9, a10
420032d4:	17b9      	s32i.n	a11, a7, 4
                in_end = reserved[i].start;
420032d6:	09cd      	mov.n	a12, a9
        for (size_t i = 0; i < num_reserved; i++) {
420032d8:	881b      	addi.n	a8, a8, 1
420032da:	ab3857        	bltu	a8, a5, 42003289 <soc_get_available_memory_regions+0x71>
        bool move_to_next = true;
420032dd:	130c      	movi.n	a3, 1
        bool copy_in_to_out = true;
420032df:	03ad      	mov.n	a10, a3
420032e1:	000286        	j	420032ef <soc_get_available_memory_regions+0xd7>
        bool move_to_next = true;
420032e4:	130c      	movi.n	a3, 1
        bool copy_in_to_out = true;
420032e6:	03ad      	mov.n	a10, a3
420032e8:	0000c6        	j	420032ef <soc_get_available_memory_regions+0xd7>
        bool move_to_next = true;
420032eb:	130c      	movi.n	a3, 1
                copy_in_to_out = false;
420032ed:	0a0c      	movi.n	a10, 0
            }
        }

        /* ignore regions smaller than 16B */
        if (in.size <= 16) {
420032ef:	1788      	l32i.n	a8, a7, 4
420032f1:	091c      	movi.n	a9, 16
420032f3:	12b987        	bgeu	a9, a8, 42003309 <soc_get_available_memory_regions+0xf1>
            copy_in_to_out = false;
        }

        if (copy_in_to_out) {
420032f6:	fa8c      	beqz.n	a10, 42003309 <soc_get_available_memory_regions+0xf1>
            ESP_EARLY_LOGD(TAG, "Available memory region 0x%08x - 0x%08x", in.start, in.start + in.size);
            *out_region++ = in;
420032f8:	97a8      	l32i.n	a10, a7, 36
420032fa:	14ca82        	addi	a8, a10, 20
420032fd:	9789      	s32i.n	a8, a7, 36
420032ff:	4c1c      	movi.n	a12, 20
42003301:	07bd      	mov.n	a11, a7
42003303:	f34981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003306:	0008e0        	callx8	a8
        }
        if (move_to_next) {
42003309:	138c      	beqz.n	a3, 4200330e <soc_get_available_memory_regions+0xf6>
            in_region++;
4200330b:	14c442        	addi	a4, a4, 20
    while (in_region != in_regions + soc_memory_region_count) {
4200330e:	8788      	l32i.n	a8, a7, 32
42003310:	882a      	add.n	a8, a8, a2
42003312:	021487        	beq	a4, a8, 42003318 <soc_get_available_memory_regions+0x100>
42003315:	ffd646        	j	42003272 <soc_get_available_memory_regions+0x5a>
        }
    }

    return (out_region - regions); /* return number of regions */
42003318:	9788      	l32i.n	a8, a7, 36
4200331a:	a798      	l32i.n	a9, a7, 40
4200331c:	c08890        	sub	a8, a8, a9
4200331f:	218280        	srai	a8, a8, 2
}
42003322:	f47621        	l32r	a2, 420004fc <_stext+0x4dc> (cccccccd <_rtc_reserved_end+0x6cbccccd>)
42003325:	822820        	mull	a2, a8, a2
42003328:	f01d      	retw.n
	...

4200332c <insert_vector_desc>:
{
4200332c:	004136        	entry	a1, 32
    vector_desc_t *vd = vector_desc_head;
4200332f:	f47481        	l32r	a8, 42000500 <_stext+0x4e0> (3fc94f50 <vector_desc_head>)
42003332:	08c8      	l32i.n	a12, a8, 0
42003334:	0c8d      	mov.n	a8, a12
    vector_desc_t *prev = NULL;
42003336:	0b0c      	movi.n	a11, 0
    while(vd != NULL) {
42003338:	000a46        	j	42003365 <insert_vector_desc+0x39>
4200333b:	089800        	lsx	f9, a8, a0
        if (vd->cpu > to_insert->cpu) break;
4200333e:	059090        	extui	a9, a9, 16, 1
42003341:	02a8      	l32i.n	a10, a2, 0
42003343:	05a0a0        	extui	a10, a10, 16, 1
42003346:	1e3a97        	bltu	a10, a9, 42003368 <insert_vector_desc+0x3c>
        if (vd->cpu == to_insert->cpu && vd->intno >= to_insert->intno) break;
42003349:	0898      	l32i.n	a9, a8, 0
4200334b:	02a8      	l32i.n	a10, a2, 0
4200334d:	3099a0        	xor	a9, a9, a10
42003350:	0df907        	bbsi	a9, 16, 42003361 <insert_vector_desc+0x35>
42003353:	08a8      	l32i.n	a10, a8, 0
42003355:	45a1a0        	extui	a10, a10, 17, 5
42003358:	002292        	l32i	a9, a2, 0
4200335b:	459190        	extui	a9, a9, 17, 5
4200335e:	06ba97        	bgeu	a10, a9, 42003368 <insert_vector_desc+0x3c>
        prev = vd;
42003361:	08bd      	mov.n	a11, a8
        vd = vd->next;
42003363:	2888      	l32i.n	a8, a8, 8
    while(vd != NULL) {
42003365:	fd3856        	bnez	a8, 4200333c <insert_vector_desc+0x10>
    if ((vector_desc_head == NULL) || (prev == NULL)) {
42003368:	0c8c      	beqz.n	a12, 4200336c <insert_vector_desc+0x40>
4200336a:	8bcc      	bnez.n	a11, 42003376 <insert_vector_desc+0x4a>
        to_insert->next = vd;
4200336c:	2289      	s32i.n	a8, a2, 8
        vector_desc_head = to_insert;
4200336e:	f46481        	l32r	a8, 42000500 <_stext+0x4e0> (3fc94f50 <vector_desc_head>)
42003371:	0829      	s32i.n	a2, a8, 0
42003373:	0000c6        	j	4200337a <insert_vector_desc+0x4e>
        prev->next = to_insert;
42003376:	2b29      	s32i.n	a2, a11, 8
        to_insert->next = vd;
42003378:	2289      	s32i.n	a8, a2, 8
}
4200337a:	f01d      	retw.n

4200337c <find_desc_for_int>:
{
4200337c:	004136        	entry	a1, 32
4200337f:	029d      	mov.n	a9, a2
    vector_desc_t *vd = vector_desc_head;
42003381:	f45f81        	l32r	a8, 42000500 <_stext+0x4e0> (3fc94f50 <vector_desc_head>)
42003384:	0828      	l32i.n	a2, a8, 0
    while(vd != NULL) {
42003386:	000446        	j	4200339b <find_desc_for_int+0x1f>
        if (vd->cpu == cpu && vd->intno == intno) {
42003389:	0288      	l32i.n	a8, a2, 0
4200338b:	058080        	extui	a8, a8, 16, 1
4200338e:	079837        	bne	a8, a3, 42003399 <find_desc_for_int+0x1d>
42003391:	0288      	l32i.n	a8, a2, 0
42003393:	458180        	extui	a8, a8, 17, 5
42003396:	041897        	beq	a8, a9, 4200339e <find_desc_for_int+0x22>
        vd = vd->next;
42003399:	2228      	l32i.n	a2, a2, 8
    while(vd != NULL) {
4200339b:	fea256        	bnez	a2, 42003389 <find_desc_for_int+0xd>
}
4200339e:	f01d      	retw.n

420033a0 <get_desc_for_int>:
{
420033a0:	004136        	entry	a1, 32
420033a3:	027d      	mov.n	a7, a2
    vector_desc_t *vd = find_desc_for_int(intno, cpu);
420033a5:	03bd      	mov.n	a11, a3
420033a7:	02ad      	mov.n	a10, a2
420033a9:	fffd25        	call8	4200337c <find_desc_for_int>
420033ac:	202aa0        	or	a2, a10, a10
    if (vd == NULL) {
420033af:	041a56        	bnez	a10, 420033f4 <get_desc_for_int+0x54>
        vector_desc_t *newvd = heap_caps_malloc(sizeof(vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
420033b2:	f441b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
420033b5:	ca0c      	movi.n	a10, 12
420033b7:	f45581        	l32r	a8, 4200050c <_stext+0x4ec> (40375ec4 <heap_caps_malloc>)
420033ba:	0008e0        	callx8	a8
420033bd:	0a2d      	mov.n	a2, a10
        if (newvd == NULL) {
420033bf:	1abc      	beqz.n	a10, 420033f4 <get_desc_for_int+0x54>
        memset(newvd, 0, sizeof(vector_desc_t));
420033c1:	cc0c      	movi.n	a12, 12
420033c3:	0b0c      	movi.n	a11, 0
420033c5:	f3cf81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420033c8:	0008e0        	callx8	a8
        newvd->intno = intno;
420033cb:	447070        	extui	a7, a7, 0, 5
420033ce:	0177f0        	slli	a7, a7, 17
420033d1:	0288      	l32i.n	a8, a2, 0
420033d3:	f44c91        	l32r	a9, 42000504 <_stext+0x4e4> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
420033d6:	108890        	and	a8, a8, a9
420033d9:	208870        	or	a8, a8, a7
420033dc:	0289      	s32i.n	a8, a2, 0
        newvd->cpu = cpu;
420033de:	043030        	extui	a3, a3, 0, 1
420033e1:	113300        	slli	a3, a3, 16
420033e4:	f44991        	l32r	a9, 42000508 <_stext+0x4e8> (fffeffff <_rtc_reserved_end+0x9feeffff>)
420033e7:	108890        	and	a8, a8, a9
420033ea:	208830        	or	a8, a8, a3
420033ed:	0289      	s32i.n	a8, a2, 0
        insert_vector_desc(newvd);
420033ef:	02ad      	mov.n	a10, a2
420033f1:	fff3a5        	call8	4200332c <insert_vector_desc>
}
420033f4:	f01d      	retw.n
	...

420033f8 <find_desc_for_source>:
{
420033f8:	004136        	entry	a1, 32
420033fb:	02ad      	mov.n	a10, a2
    vector_desc_t *vd = vector_desc_head;
420033fd:	f44081        	l32r	a8, 42000500 <_stext+0x4e0> (3fc94f50 <vector_desc_head>)
42003400:	0828      	l32i.n	a2, a8, 0
    while(vd != NULL) {
42003402:	0017c6        	j	42003465 <find_desc_for_source+0x6d>
        if (!(vd->flags & VECDESC_FL_SHARED)) {
42003405:	009282        	l16si	a8, a2, 0
42003408:	490c      	movi.n	a9, 4
4200340a:	108890        	and	a8, a8, a9
4200340d:	238880        	sext	a8, a8, 15
42003410:	48dc      	bnez.n	a8, 42003428 <find_desc_for_source+0x30>
            if (vd->source == source && cpu == vd->cpu) {
42003412:	0288      	l32i.n	a8, a2, 0
42003414:	1188e0        	slli	a8, a8, 2
42003417:	318880        	srai	a8, a8, 24
4200341a:	4498a7        	bne	a8, a10, 42003462 <find_desc_for_source+0x6a>
4200341d:	0288      	l32i.n	a8, a2, 0
4200341f:	058080        	extui	a8, a8, 16, 1
42003422:	3c9837        	bne	a8, a3, 42003462 <find_desc_for_source+0x6a>
42003425:	000fc6        	j	42003468 <find_desc_for_source+0x70>
        } else if (vd->cpu == cpu) {
42003428:	0288      	l32i.n	a8, a2, 0
4200342a:	058080        	extui	a8, a8, 16, 1
4200342d:	319837        	bne	a8, a3, 42003462 <find_desc_for_source+0x6a>
            shared_vector_desc_t *svd = vd->shared_vec_info;
42003430:	1298      	l32i.n	a9, a2, 4
            assert(svd != NULL);
42003432:	09ec      	bnez.n	a9, 42003456 <find_desc_for_source+0x5e>
42003434:	f437d1        	l32r	a13, 42000510 <_stext+0x4f0> (3c022218 <_flash_rodata_start+0x20f8>)
42003437:	f437c1        	l32r	a12, 42000514 <_stext+0x4f4> (3c026c0c <__func__$6>)
4200343a:	c7a0b2        	movi	a11, 199
4200343d:	f436a1        	l32r	a10, 42000518 <_stext+0x4f8> (3c022244 <_flash_rodata_start+0x2124>)
42003440:	f33281        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42003443:	0008e0        	callx8	a8
                if (svd->source == source) {
42003446:	0988      	l32i.n	a8, a9, 0
42003448:	118890        	slli	a8, a8, 7
4200344b:	238880        	sext	a8, a8, 15
4200344e:	218880        	srai	a8, a8, 8
42003451:	0918a7        	beq	a8, a10, 4200345e <find_desc_for_source+0x66>
                svd = svd->next;
42003454:	5998      	l32i.n	a9, a9, 20
            while(svd) {
42003456:	fec956        	bnez	a9, 42003446 <find_desc_for_source+0x4e>
            bool found = false;
42003459:	080c      	movi.n	a8, 0
4200345b:	000046        	j	42003460 <find_desc_for_source+0x68>
                    found = true;
4200345e:	180c      	movi.n	a8, 1
            if (found) {
42003460:	48cc      	bnez.n	a8, 42003468 <find_desc_for_source+0x70>
        vd = vd->next;
42003462:	022222        	l32i	a2, a2, 8
    while(vd != NULL) {
42003465:	f9c256        	bnez	a2, 42003405 <find_desc_for_source+0xd>
}
42003468:	f01d      	retw.n
	...

4200346c <is_vect_desc_usable>:
{
4200346c:	006136        	entry	a1, 48
4200346f:	04ad      	mov.n	a10, a4
    int x = vd->intno;
42003471:	0278      	l32i.n	a7, a2, 0
42003473:	457170        	extui	a7, a7, 17, 5
    esp_cpu_intr_get_desc(cpu, x, &intr_desc);
42003476:	01cd      	mov.n	a12, a1
42003478:	07bd      	mov.n	a11, a7
4200347a:	028165        	call8	42005c90 <esp_cpu_intr_get_desc>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_RESVD) {
4200347d:	2188      	l32i.n	a8, a1, 8
4200347f:	7ae817        	bbsi	a8, 1, 420034fd <is_vect_desc_usable+0x91>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_SPECIAL && force == -1) {
42003482:	026807        	bbci	a8, 0, 42003488 <is_vect_desc_usable+0x1c>
42003485:	790526        	beqi	a5, -1, 42003502 <is_vect_desc_usable+0x96>
    if (!(flags & (1 << intr_desc.priority))) {
42003488:	0188      	l32i.n	a8, a1, 0
4200348a:	7a5387        	bbc	a3, a8, 42003508 <is_vect_desc_usable+0x9c>
    if (((flags & ESP_INTR_FLAG_EDGE) && (intr_desc.type == ESP_CPU_INTR_TYPE_LEVEL)) ||
4200348d:	076397        	bbci	a3, 9, 42003498 <is_vect_desc_usable+0x2c>
42003490:	1188      	l32i.n	a8, a1, 4
42003492:	78cc      	bnez.n	a8, 4200349d <is_vect_desc_usable+0x31>
42003494:	001d46        	j	4200350d <is_vect_desc_usable+0xa1>
42003497:	118800        	slli	a8, a8, 16
            (((!(flags & ESP_INTR_FLAG_EDGE)) && (intr_desc.type == ESP_CPU_INTR_TYPE_EDGE)))) {
4200349a:	741826        	beqi	a8, 1, 42003512 <is_vect_desc_usable+0xa6>
    if (vd->flags & VECDESC_FL_RESERVED)  {
4200349d:	009282        	l16si	a8, a2, 0
420034a0:	74e807        	bbsi	a8, 0, 42003518 <is_vect_desc_usable+0xac>
    assert(!((vd->flags & VECDESC_FL_SHARED) && (vd->flags & VECDESC_FL_NONSHARED)));
420034a3:	c90c      	movi.n	a9, 12
420034a5:	109890        	and	a9, a8, a9
420034a8:	239980        	sext	a9, a9, 15
420034ab:	11a966        	bnei	a9, 12, 420034c0 <is_vect_desc_usable+0x54>
420034ae:	f41bd1        	l32r	a13, 4200051c <_stext+0x4fc> (3c022254 <_flash_rodata_start+0x2134>)
420034b1:	f41bc1        	l32r	a12, 42000520 <_stext+0x500> (3c026bf8 <__func__$5>)
420034b4:	34a1b2        	movi	a11, 0x134
420034b7:	f418a1        	l32r	a10, 42000518 <_stext+0x4f8> (3c022244 <_flash_rodata_start+0x2124>)
420034ba:	f31381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420034bd:	0008e0        	callx8	a8
    if (vd->flags & VECDESC_FL_NONSHARED) {
420034c0:	890c      	movi.n	a9, 8
420034c2:	109890        	and	a9, a8, a9
420034c5:	239980        	sext	a9, a9, 15
420034c8:	051956        	bnez	a9, 4200351d <is_vect_desc_usable+0xb1>
    if (vd->flags & VECDESC_FL_SHARED) {
420034cb:	490c      	movi.n	a9, 4
420034cd:	109890        	and	a9, a8, a9
420034d0:	239980        	sext	a9, a9, 15
420034d3:	199c      	beqz.n	a9, 420034e8 <is_vect_desc_usable+0x7c>
        if (flags & ESP_INTR_FLAG_SHARED) {
420034d5:	496387        	bbci	a3, 8, 42003522 <is_vect_desc_usable+0xb6>
            bool in_iram_flag = ((flags & ESP_INTR_FLAG_IRAM) != 0);
420034d8:	043a30        	extui	a3, a3, 10, 1
            bool desc_in_iram_flag = ((vd->flags & VECDESC_FL_INIRAM) != 0);
420034db:	048180        	extui	a8, a8, 1, 1
            if ((vd->flags & VECDESC_FL_SHARED) && (desc_in_iram_flag != in_iram_flag))  {
420034de:	469387        	bne	a3, a8, 42003528 <is_vect_desc_usable+0xbc>
    return true;
420034e1:	120c      	movi.n	a2, 1
420034e3:	001206        	j	4200352f <is_vect_desc_usable+0xc3>
420034e6:	b00000        	addx8	a0, a0, a0
420034e9:	03eb      	addi.n	a0, a3, 14
420034eb:	04bdb0        	extui	a11, a11, 13, 1
    has_handler = xt_int_has_handler(intr_num, esp_cpu_get_core_id());
420034ee:	20a770        	or	a10, a7, a7
420034f1:	161ca5        	call8	420196bc <xt_int_has_handler>
    } else if (esp_cpu_intr_has_handler(x)) {
420034f4:	035a56        	bnez	a10, 4200352d <is_vect_desc_usable+0xc1>
    return true;
420034f7:	01a022        	movi	a2, 1
420034fa:	000c46        	j	4200352f <is_vect_desc_usable+0xc3>
        return false;
420034fd:	020c      	movi.n	a2, 0
420034ff:	000b06        	j	4200352f <is_vect_desc_usable+0xc3>
        return false;
42003502:	020c      	movi.n	a2, 0
42003504:	0009c6        	j	4200352f <is_vect_desc_usable+0xc3>
42003507:	020c00        	andb	b0, b12, b0
        return false;
4200350a:	000846        	j	4200352f <is_vect_desc_usable+0xc3>
        return false;
4200350d:	020c      	movi.n	a2, 0
4200350f:	000706        	j	4200352f <is_vect_desc_usable+0xc3>
42003512:	020c      	movi.n	a2, 0
42003514:	0005c6        	j	4200352f <is_vect_desc_usable+0xc3>
42003517:	020c00        	andb	b0, b12, b0
        return false;
4200351a:	000446        	j	4200352f <is_vect_desc_usable+0xc3>
        return false;
4200351d:	020c      	movi.n	a2, 0
4200351f:	000306        	j	4200352f <is_vect_desc_usable+0xc3>
            return false;
42003522:	020c      	movi.n	a2, 0
42003524:	0001c6        	j	4200352f <is_vect_desc_usable+0xc3>
42003527:	020c00        	andb	b0, b12, b0
                return false;
4200352a:	000046        	j	4200352f <is_vect_desc_usable+0xc3>
        return false;
4200352d:	020c      	movi.n	a2, 0
}
4200352f:	f01d      	retw.n
42003531:	000000        	ill

42003534 <get_available_int>:
{
42003534:	00a136        	entry	a1, 80
    memset(&empty_vect_desc, 0, sizeof(vector_desc_t));
42003537:	cc0c      	movi.n	a12, 12
42003539:	00a0b2        	movi	a11, 0
4200353c:	01ad      	mov.n	a10, a1
4200353e:	f37181        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
42003541:	0008e0        	callx8	a8
    if (!(flags & ESP_INTR_FLAG_LEVELMASK)) {
42003544:	648120        	extui	a8, a2, 1, 7
42003547:	38cc      	bnez.n	a8, 4200354e <get_available_int+0x1a>
        flags |= ESP_INTR_FLAG_LOWMED;
42003549:	e80c      	movi.n	a8, 14
4200354b:	202280        	or	a2, a2, a8
    vector_desc_t *vd = find_desc_for_source(source, cpu);
4200354e:	03bd      	mov.n	a11, a3
42003550:	05ad      	mov.n	a10, a5
42003552:	ffea65        	call8	420033f8 <find_desc_for_source>
42003555:	0a7d      	mov.n	a7, a10
    if (vd) {
42003557:	1abc      	beqz.n	a10, 4200358c <get_available_int+0x58>
        if ( force != -1 && force != vd->intno ) {
42003559:	070426        	beqi	a4, -1, 42003564 <get_available_int+0x30>
4200355c:	0a88      	l32i.n	a8, a10, 0
4200355e:	458180        	extui	a8, a8, 17, 5
42003561:	199847        	bne	a8, a4, 4200357e <get_available_int+0x4a>
        } else if (!is_vect_desc_usable(vd, flags, cpu, force)) {
42003564:	20d440        	or	a13, a4, a4
42003567:	20c330        	or	a12, a3, a3
4200356a:	20b220        	or	a11, a2, a2
4200356d:	07ad      	mov.n	a10, a7
4200356f:	ffefe5        	call8	4200346c <is_vect_desc_usable>
42003572:	fa8c      	beqz.n	a10, 42003585 <get_available_int+0x51>
            best = vd->intno;
42003574:	0788      	l32i.n	a8, a7, 0
42003576:	458180        	extui	a8, a8, 17, 5
42003579:	8189      	s32i.n	a8, a1, 32
4200357b:	003d86        	j	42003675 <get_available_int+0x141>
    int best=-1;
4200357e:	f87c      	movi.n	a8, -1
42003580:	8189      	s32i.n	a8, a1, 32
42003582:	003bc6        	j	42003675 <get_available_int+0x141>
42003585:	f87c      	movi.n	a8, -1
42003587:	8189      	s32i.n	a8, a1, 32
        return best;
42003589:	003a06        	j	42003675 <get_available_int+0x141>
    if (force != -1) {
4200358c:	020466        	bnei	a4, -1, 42003592 <get_available_int+0x5e>
4200358f:	0033c6        	j	42003662 <get_available_int+0x12e>
        vd = find_desc_for_int(force, cpu);
42003592:	03bd      	mov.n	a11, a3
42003594:	04ad      	mov.n	a10, a4
42003596:	ffde65        	call8	4200337c <find_desc_for_int>
42003599:	0a7d      	mov.n	a7, a10
        if (vd == NULL) {
4200359b:	3adc      	bnez.n	a10, 420035b2 <get_available_int+0x7e>
            empty_vect_desc.intno = force;
4200359d:	449040        	extui	a9, a4, 0, 5
420035a0:	0199f0        	slli	a9, a9, 17
420035a3:	0188      	l32i.n	a8, a1, 0
420035a5:	f3d7a1        	l32r	a10, 42000504 <_stext+0x4e4> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
420035a8:	1088a0        	and	a8, a8, a10
420035ab:	208890        	or	a8, a8, a9
420035ae:	0189      	s32i.n	a8, a1, 0
            vd = &empty_vect_desc;
420035b0:	017d      	mov.n	a7, a1
        if (is_vect_desc_usable(vd, flags, cpu, force)) {
420035b2:	20d440        	or	a13, a4, a4
420035b5:	20c330        	or	a12, a3, a3
420035b8:	20b220        	or	a11, a2, a2
420035bb:	07ad      	mov.n	a10, a7
420035bd:	ffeae5        	call8	4200346c <is_vect_desc_usable>
420035c0:	8a8c      	beqz.n	a10, 420035cc <get_available_int+0x98>
            best = vd->intno;
420035c2:	0788      	l32i.n	a8, a7, 0
420035c4:	458180        	extui	a8, a8, 17, 5
420035c7:	8189      	s32i.n	a8, a1, 32
420035c9:	002a06        	j	42003675 <get_available_int+0x141>
    int best=-1;
420035cc:	f87c      	movi.n	a8, -1
420035ce:	8189      	s32i.n	a8, a1, 32
        return best;
420035d0:	002846        	j	42003675 <get_available_int+0x141>
420035d3:	00          	.byte	00
        vd = find_desc_for_int(x, cpu);
420035d4:	03bd      	mov.n	a11, a3
420035d6:	06ad      	mov.n	a10, a6
420035d8:	ffda25        	call8	4200337c <find_desc_for_int>
420035db:	0a7d      	mov.n	a7, a10
        if (vd == NULL) {
420035dd:	3adc      	bnez.n	a10, 420035f4 <get_available_int+0xc0>
            empty_vect_desc.intno = x;
420035df:	449060        	extui	a9, a6, 0, 5
420035e2:	0199f0        	slli	a9, a9, 17
420035e5:	0188      	l32i.n	a8, a1, 0
420035e7:	f3c7a1        	l32r	a10, 42000504 <_stext+0x4e4> (ffc1ffff <_rtc_reserved_end+0x9fb1ffff>)
420035ea:	1088a0        	and	a8, a8, a10
420035ed:	208890        	or	a8, a8, a9
420035f0:	0189      	s32i.n	a8, a1, 0
            vd = &empty_vect_desc;
420035f2:	017d      	mov.n	a7, a1
        esp_cpu_intr_get_desc(cpu, x, &intr_desc);
420035f4:	c1cb      	addi.n	a12, a1, 12
420035f6:	06bd      	mov.n	a11, a6
420035f8:	03ad      	mov.n	a10, a3
420035fa:	026965        	call8	42005c90 <esp_cpu_intr_get_desc>
        if (!is_vect_desc_usable(vd, flags, cpu, force)) {
420035fd:	04dd      	mov.n	a13, a4
420035ff:	03cd      	mov.n	a12, a3
42003601:	02bd      	mov.n	a11, a2
42003603:	07ad      	mov.n	a10, a7
42003605:	ffe665        	call8	4200346c <is_vect_desc_usable>
42003608:	051a16        	beqz	a10, 4200365d <get_available_int+0x129>
        if (flags & ESP_INTR_FLAG_SHARED) {
4200360b:	3b6287        	bbci	a2, 8, 4200364a <get_available_int+0x116>
            if (vd->flags & VECDESC_FL_SHARED) {
4200360e:	009782        	l16si	a8, a7, 0
42003611:	490c      	movi.n	a9, 4
42003613:	108890        	and	a8, a8, a9
42003616:	238880        	sext	a8, a8, 15
42003619:	08ac      	beqz.n	a8, 4200363d <get_available_int+0x109>
                shared_vector_desc_t *svdesc = vd->shared_vec_info;
4200361b:	1788      	l32i.n	a8, a7, 4
                int no = 0;
4200361d:	090c      	movi.n	a9, 0
                while (svdesc != NULL) {
4200361f:	0000c6        	j	42003626 <get_available_int+0xf2>
                    no++;
42003622:	991b      	addi.n	a9, a9, 1
                    svdesc = svdesc->next;
42003624:	5888      	l32i.n	a8, a8, 20
                while (svdesc != NULL) {
42003626:	ff8856        	bnez	a8, 42003622 <get_available_int+0xee>
                if (no<bestSharedCt || bestPriority > intr_desc.priority) {
42003629:	9188      	l32i.n	a8, a1, 36
4200362b:	052987        	blt	a9, a8, 42003634 <get_available_int+0x100>
4200362e:	032182        	l32i	a8, a1, 12
42003631:	28a857        	bge	a8, a5, 4200365d <get_available_int+0x129>
                    bestPriority = intr_desc.priority;
42003634:	3158      	l32i.n	a5, a1, 12
                    bestSharedCt = no;
42003636:	9199      	s32i.n	a9, a1, 36
                    best = x;
42003638:	8169      	s32i.n	a6, a1, 32
4200363a:	0007c6        	j	4200365d <get_available_int+0x129>
                if (best == -1) {
4200363d:	8188      	l32i.n	a8, a1, 32
4200363f:	1a0866        	bnei	a8, -1, 4200365d <get_available_int+0x129>
                    if (bestPriority > intr_desc.priority) {
42003642:	3188      	l32i.n	a8, a1, 12
42003644:	0a2857        	blt	a8, a5, 42003652 <get_available_int+0x11e>
42003647:	000486        	j	4200365d <get_available_int+0x129>
            if (bestPriority > intr_desc.priority) {
4200364a:	3188      	l32i.n	a8, a1, 12
4200364c:	092857        	blt	a8, a5, 42003659 <get_available_int+0x125>
4200364f:	000286        	j	4200365d <get_available_int+0x129>
                        bestPriority = intr_desc.priority;
42003652:	085d      	mov.n	a5, a8
                        best = x;
42003654:	8169      	s32i.n	a6, a1, 32
42003656:	0000c6        	j	4200365d <get_available_int+0x129>
                bestPriority = intr_desc.priority;
42003659:	085d      	mov.n	a5, a8
                best = x;
4200365b:	8169      	s32i.n	a6, a1, 32
    for (x = 0; x < CPU_INT_LINES_COUNT; x++) {
4200365d:	661b      	addi.n	a6, a6, 1
4200365f:	000286        	j	4200366d <get_available_int+0x139>
    int best=-1;
42003662:	8149      	s32i.n	a4, a1, 32
    int bestSharedCt=INT_MAX;
42003664:	f3b081        	l32r	a8, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42003667:	9189      	s32i.n	a8, a1, 36
    int bestPriority=9;
42003669:	950c      	movi.n	a5, 9
    for (x = 0; x < CPU_INT_LINES_COUNT; x++) {
4200366b:	060c      	movi.n	a6, 0
4200366d:	f81c      	movi.n	a8, 31
4200366f:	022867        	blt	a8, a6, 42003675 <get_available_int+0x141>
42003672:	ffd786        	j	420035d4 <get_available_int+0xa0>
}
42003675:	8128      	l32i.n	a2, a1, 32
42003677:	f01d      	retw.n
42003679:	000000        	ill

4200367c <esp_intr_ptr_in_isr_region>:
{
4200367c:	004136        	entry	a1, 32
    return ((intptr_t)p >= SOC_IRAM_LOW && (intptr_t)p < SOC_IRAM_HIGH);
4200367f:	f3aa81        	l32r	a8, 42000528 <_stext+0x508> (bfc90000 <_rtc_reserved_end+0x5fb90000>)
42003682:	828a      	add.n	a8, a2, a8
    return esp_ptr_in_iram(ptr) || esp_ptr_in_rtc_iram_fast(ptr) || esp_ptr_in_rom(ptr);
42003684:	f3aa91        	l32r	a9, 4200052c <_stext+0x50c> (6ffff <UserFrameTotalSize+0x6feff>)
42003687:	1ab987        	bgeu	a9, a8, 420036a5 <esp_intr_ptr_in_isr_region+0x29>
    return ((intptr_t)p >= SOC_RTC_IRAM_LOW && (intptr_t)p < SOC_RTC_IRAM_HIGH);
4200368a:	f3a981        	l32r	a8, 42000530 <_stext+0x510> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
4200368d:	828a      	add.n	a8, a2, a8
4200368f:	f3a991        	l32r	a9, 42000534 <_stext+0x514> (1fff <UserFrameTotalSize+0x1eff>)
42003692:	14b987        	bgeu	a9, a8, 420036aa <esp_intr_ptr_in_isr_region+0x2e>
        (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH);
42003695:	f3a881        	l32r	a8, 42000538 <_stext+0x518> (c0000000 <_rtc_reserved_end+0x5ff00000>)
42003698:	228a      	add.n	a2, a2, a8
4200369a:	f3a881        	l32r	a8, 4200053c <_stext+0x51c> (5ffff <UserFrameTotalSize+0x5feff>)
4200369d:	0fb827        	bgeu	a8, a2, 420036b0 <esp_intr_ptr_in_isr_region+0x34>
420036a0:	020c      	movi.n	a2, 0
420036a2:	000306        	j	420036b2 <esp_intr_ptr_in_isr_region+0x36>
420036a5:	120c      	movi.n	a2, 1
420036a7:	0001c6        	j	420036b2 <esp_intr_ptr_in_isr_region+0x36>
420036aa:	120c      	movi.n	a2, 1
420036ac:	000086        	j	420036b2 <esp_intr_ptr_in_isr_region+0x36>
420036af:	120c00        	andbc	b0, b12, b0
}
420036b2:	f01d      	retw.n

420036b4 <esp_intr_alloc_intrstatus_bind>:
{
420036b4:	00a136        	entry	a1, 80
420036b7:	066172        	s32i	a7, a1, 24
    if ((flags & ESP_INTR_FLAG_SHARED) && (flags & ESP_INTR_FLAG_EDGE)) {
420036ba:	00a382        	movi	a8, 0x300
420036bd:	02c387        	bnall	a3, a8, 420036c3 <esp_intr_alloc_intrstatus_bind+0xf>
420036c0:	00be46        	j	420039bd <esp_intr_alloc_intrstatus_bind+0x309>
    if ((flags & ESP_INTR_FLAG_HIGH) && (handler)) {
420036c3:	348430        	extui	a8, a3, 4, 4
420036c6:	002816        	beqz	a8, 420036cc <esp_intr_alloc_intrstatus_bind+0x18>
420036c9:	2f7656        	bnez	a6, 420039c4 <esp_intr_alloc_intrstatus_bind+0x310>
    if ((flags & ESP_INTR_FLAG_SHARED) && (!handler || source<0)) {
420036cc:	00a182        	movi	a8, 0x100
420036cf:	107380        	and	a7, a3, a8
420036d2:	0e0387        	bnone	a3, a8, 420036e4 <esp_intr_alloc_intrstatus_bind+0x30>
420036d5:	40f680        	nsau	a8, a6
420036d8:	418580        	srli	a8, a8, 5
420036db:	059f20        	extui	a9, a2, 31, 1
420036de:	208890        	or	a8, a8, a9
420036e1:	2e7856        	bnez	a8, 420039cc <esp_intr_alloc_intrstatus_bind+0x318>
    if (intrstatusreg && !intrstatusmask) {
420036e4:	190c      	movi.n	a9, 1
420036e6:	839440        	moveqz	a9, a4, a4
420036e9:	40f580        	nsau	a8, a5
420036ec:	418580        	srli	a8, a8, 5
420036ef:	020987        	bnone	a9, a8, 420036f5 <esp_intr_alloc_intrstatus_bind+0x41>
420036f2:	00b786        	j	420039d4 <esp_intr_alloc_intrstatus_bind+0x320>
    if ((flags & ESP_INTR_FLAG_IRAM) && handler && !esp_intr_ptr_in_isr_region(handler)) {
420036f5:	0a63a7        	bbci	a3, 10, 42003703 <esp_intr_alloc_intrstatus_bind+0x4f>
420036f8:	007616        	beqz	a6, 42003703 <esp_intr_alloc_intrstatus_bind+0x4f>
420036fb:	06ad      	mov.n	a10, a6
420036fd:	fff7e5        	call8	4200367c <esp_intr_ptr_in_isr_region>
42003700:	2d8a16        	beqz	a10, 420039dc <esp_intr_alloc_intrstatus_bind+0x328>
    if (shared_handle != NULL && (flags & ESP_INTR_FLAG_SHARED) == 0) {
42003703:	142182        	l32i	a8, a1, 80
42003706:	002816        	beqz	a8, 4200370c <esp_intr_alloc_intrstatus_bind+0x58>
42003709:	2d7716        	beqz	a7, 420039e4 <esp_intr_alloc_intrstatus_bind+0x330>
    if ((flags & ESP_INTR_FLAG_LEVELMASK) == 0) {
4200370c:	648130        	extui	a8, a3, 1, 7
4200370f:	e8cc      	bnez.n	a8, 42003721 <esp_intr_alloc_intrstatus_bind+0x6d>
        if (flags & ESP_INTR_FLAG_SHARED) {
42003711:	778c      	beqz.n	a7, 4200371c <esp_intr_alloc_intrstatus_bind+0x68>
            flags |= ESP_INTR_FLAG_LEVEL1;
42003713:	280c      	movi.n	a8, 2
42003715:	203380        	or	a3, a3, a8
42003718:	000146        	j	42003721 <esp_intr_alloc_intrstatus_bind+0x6d>
4200371b:	00          	.byte	00
            flags |= ESP_INTR_FLAG_LOWMED;
4200371c:	e80c      	movi.n	a8, 14
4200371e:	203380        	or	a3, a3, a8
    if (source == ETS_INTERNAL_TIMER0_INTR_SOURCE) {
42003721:	090226        	beqi	a2, -1, 4200372e <esp_intr_alloc_intrstatus_bind+0x7a>
    if (source == ETS_INTERNAL_TIMER1_INTR_SOURCE) {
42003724:	e87c      	movi.n	a8, -2
42003726:	0e1287        	beq	a2, a8, 42003738 <esp_intr_alloc_intrstatus_bind+0x84>
42003729:	f77c      	movi.n	a7, -1
4200372b:	000046        	j	42003730 <esp_intr_alloc_intrstatus_bind+0x7c>
        force = ETS_INTERNAL_TIMER0_INTR_NO;
4200372e:	670c      	movi.n	a7, 6
    if (source == ETS_INTERNAL_TIMER2_INTR_SOURCE) {
42003730:	d87c      	movi.n	a8, -3
42003732:	049287        	bne	a2, a8, 4200373a <esp_intr_alloc_intrstatus_bind+0x86>
42003735:	000246        	j	42003742 <esp_intr_alloc_intrstatus_bind+0x8e>
        force = ETS_INTERNAL_TIMER1_INTR_NO;
42003738:	f70c      	movi.n	a7, 15
    if (source == ETS_INTERNAL_SW0_INTR_SOURCE) {
4200373a:	c87c      	movi.n	a8, -4
4200373c:	049287        	bne	a2, a8, 42003744 <esp_intr_alloc_intrstatus_bind+0x90>
4200373f:	000246        	j	4200374c <esp_intr_alloc_intrstatus_bind+0x98>
        force = ETS_INTERNAL_TIMER2_INTR_NO;
42003742:	071c      	movi.n	a7, 16
    if (source == ETS_INTERNAL_SW1_INTR_SOURCE) {
42003744:	b87c      	movi.n	a8, -5
42003746:	049287        	bne	a2, a8, 4200374e <esp_intr_alloc_intrstatus_bind+0x9a>
42003749:	000246        	j	42003756 <esp_intr_alloc_intrstatus_bind+0xa2>
        force = ETS_INTERNAL_SW0_INTR_NO;
4200374c:	770c      	movi.n	a7, 7
    if (source == ETS_INTERNAL_PROFILING_INTR_SOURCE) {
4200374e:	a87c      	movi.n	a8, -6
42003750:	099287        	bne	a2, a8, 4200375d <esp_intr_alloc_intrstatus_bind+0xa9>
42003753:	000106        	j	4200375b <esp_intr_alloc_intrstatus_bind+0xa7>
        force = ETS_INTERNAL_SW1_INTR_NO;
42003756:	d71c      	movi.n	a7, 29
42003758:	000046        	j	4200375d <esp_intr_alloc_intrstatus_bind+0xa9>
        force = ETS_INTERNAL_PROFILING_INTR_NO;
4200375b:	b70c      	movi.n	a7, 11
    ret = heap_caps_malloc(sizeof(intr_handle_data_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200375d:	f356b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42003760:	8a0c      	movi.n	a10, 8
42003762:	f36a81        	l32r	a8, 4200050c <_stext+0x4ec> (40375ec4 <heap_caps_malloc>)
42003765:	0008e0        	callx8	a8
42003768:	71a9      	s32i.n	a10, a1, 28
    if (ret == NULL) {
4200376a:	27ea16        	beqz	a10, 420039ec <esp_intr_alloc_intrstatus_bind+0x338>
4200376d:	fb7c      	movi.n	a11, -1
4200376f:	f374a1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
42003772:	f32f81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42003775:	0008e0        	callx8	a8
42003778:	03eb80        	rsr.prid	a8
4200377b:	048d80        	extui	a8, a8, 13, 1
4200377e:	5189      	s32i.n	a8, a1, 20
    if (shared_handle != NULL) {
42003780:	142182        	l32i	a8, a1, 80
42003783:	d89c      	beqz.n	a8, 420037a4 <esp_intr_alloc_intrstatus_bind+0xf0>
        if (shared_handle->vector_desc == NULL) {
42003785:	002882        	l32i	a8, a8, 0
42003788:	00e856        	bnez	a8, 4200379a <esp_intr_alloc_intrstatus_bind+0xe6>
            portEXIT_CRITICAL(&spinlock);
4200378b:	f36da1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
4200378e:	f32981        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42003791:	0008e0        	callx8	a8
            return ESP_ERR_INVALID_ARG;
42003794:	02a122        	movi	a2, 0x102
42003797:	009506        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
        force = shared_handle->vector_desc->intno;
4200379a:	0888      	l32i.n	a8, a8, 0
4200379c:	457180        	extui	a7, a8, 17, 5
        cpu = shared_handle->vector_desc->cpu;
4200379f:	058080        	extui	a8, a8, 16, 1
420037a2:	5189      	s32i.n	a8, a1, 20
    int intr = get_available_int(flags, cpu, force, source);
420037a4:	0521b2        	l32i	a11, a1, 20
420037a7:	0861b2        	s32i	a11, a1, 32
420037aa:	20d220        	or	a13, a2, a2
420037ad:	07cd      	mov.n	a12, a7
420037af:	03ad      	mov.n	a10, a3
420037b1:	ffd825        	call8	42003534 <get_available_int>
420037b4:	41a9      	s32i.n	a10, a1, 16
    if (intr == -1) {
420037b6:	380a66        	bnei	a10, -1, 420037f2 <esp_intr_alloc_intrstatus_bind+0x13e>
        portEXIT_CRITICAL(&spinlock);
420037b9:	f361a1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
420037bc:	f31e81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
420037bf:	0008e0        	callx8	a8
        free(ret);
420037c2:	71a8      	l32i.n	a10, a1, 28
420037c4:	f36a81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
420037c7:	0008e0        	callx8	a8
        ESP_LOGE(TAG, "No free interrupt inputs for %s interrupt (flags 0x%X)", esp_isr_names[source], flags);
420037ca:	f22581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420037cd:	0008e0        	callx8	a8
420037d0:	f35d81        	l32r	a8, 42000544 <_stext+0x524> (3c027c0c <esp_isr_names>)
420037d3:	a08280        	addx4	a8, a2, a8
420037d6:	f35cb1        	l32r	a11, 42000548 <_stext+0x528> (3c0222a0 <_flash_rodata_start+0x2180>)
420037d9:	0139      	s32i.n	a3, a1, 0
420037db:	08f8      	l32i.n	a15, a8, 0
420037dd:	0bed      	mov.n	a14, a11
420037df:	0add      	mov.n	a13, a10
420037e1:	f35ac1        	l32r	a12, 4200054c <_stext+0x52c> (3c0222ac <_flash_rodata_start+0x218c>)
420037e4:	1a0c      	movi.n	a10, 1
420037e6:	f22b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420037e9:	0008e0        	callx8	a8
        return ESP_ERR_NOT_FOUND;
420037ec:	05a122        	movi	a2, 0x105
420037ef:	007f06        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
    vector_desc_t *vd = get_desc_for_int(intr, cpu);
420037f2:	0521b2        	l32i	a11, a1, 20
420037f5:	0421a2        	l32i	a10, a1, 16
420037f8:	ffba65        	call8	420033a0 <get_desc_for_int>
420037fb:	207aa0        	or	a7, a10, a10
    if (vd == NULL) {
420037fe:	6adc      	bnez.n	a10, 42003818 <esp_intr_alloc_intrstatus_bind+0x164>
        portEXIT_CRITICAL(&spinlock);
42003800:	f350a1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
42003803:	f30c81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42003806:	0008e0        	callx8	a8
        free(ret);
42003809:	71a8      	l32i.n	a10, a1, 28
4200380b:	f35881        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200380e:	0008e0        	callx8	a8
        return ESP_ERR_NO_MEM;
42003811:	01a122        	movi	a2, 0x101
42003814:	0075c6        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
42003817:	00          	.byte	00
    if (flags & ESP_INTR_FLAG_SHARED) {
42003818:	02e387        	bbsi	a3, 8, 4200381e <esp_intr_alloc_intrstatus_bind+0x16a>
4200381b:	002446        	j	420038b0 <esp_intr_alloc_intrstatus_bind+0x1fc>
        shared_vector_desc_t *sh_vec = heap_caps_malloc(sizeof(shared_vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200381e:	f326b1        	l32r	a11, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42003821:	8a1c      	movi.n	a10, 24
42003823:	f33a81        	l32r	a8, 4200050c <_stext+0x4ec> (40375ec4 <heap_caps_malloc>)
42003826:	0008e0        	callx8	a8
42003829:	91a9      	s32i.n	a10, a1, 36
        if (sh_vec == NULL) {
4200382b:	5adc      	bnez.n	a10, 42003844 <esp_intr_alloc_intrstatus_bind+0x190>
            portEXIT_CRITICAL(&spinlock);
4200382d:	f344a1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
42003830:	f30181        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42003833:	0008e0        	callx8	a8
            free(ret);
42003836:	71a8      	l32i.n	a10, a1, 28
42003838:	f34d81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200383b:	0008e0        	callx8	a8
            return ESP_ERR_NO_MEM;
4200383e:	01a122        	movi	a2, 0x101
42003841:	006a86        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
        memset(sh_vec, 0, sizeof(shared_vector_desc_t));
42003844:	8c1c      	movi.n	a12, 24
42003846:	0b0c      	movi.n	a11, 0
42003848:	91a8      	l32i.n	a10, a1, 36
4200384a:	f2ae81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200384d:	0008e0        	callx8	a8
        sh_vec->statusreg = (uint32_t*)intrstatusreg;
42003850:	91b8      	l32i.n	a11, a1, 36
42003852:	1b49      	s32i.n	a4, a11, 4
        sh_vec->statusmask = intrstatusmask;
42003854:	2b59      	s32i.n	a5, a11, 8
        sh_vec->isr = handler;
42003856:	3b69      	s32i.n	a6, a11, 12
        sh_vec->arg = arg;
42003858:	6188      	l32i.n	a8, a1, 24
4200385a:	4b89      	s32i.n	a8, a11, 16
        sh_vec->next = vd->shared_vec_info;
4200385c:	1788      	l32i.n	a8, a7, 4
4200385e:	5b89      	s32i.n	a8, a11, 20
        sh_vec->source = source;
42003860:	748020        	extui	a8, a2, 0, 8
42003863:	988a      	add.n	a9, a8, a8
42003865:	001b82        	l16ui	a8, a11, 0
42003868:	01aea2        	movi	a10, 0xfffffe01
4200386b:	1088a0        	and	a8, a8, a10
4200386e:	208890        	or	a8, a8, a9
42003871:	005b82        	s16i	a8, a11, 0
        sh_vec->disabled = 0;
42003874:	e97c      	movi.n	a9, -2
42003876:	108890        	and	a8, a8, a9
42003879:	005b82        	s16i	a8, a11, 0
        vd->shared_vec_info = sh_vec;
4200387c:	17b9      	s32i.n	a11, a7, 4
        vd->flags |= VECDESC_FL_SHARED;
4200387e:	009782        	l16si	a8, a7, 0
42003881:	490c      	movi.n	a9, 4
42003883:	208890        	or	a8, a8, a9
42003886:	005782        	s16i	a8, a7, 0
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
42003889:	f81c      	movi.n	a8, 31
4200388b:	4198      	l32i.n	a9, a1, 16
4200388d:	11b897        	bgeu	a8, a9, 420038a2 <esp_intr_alloc_intrstatus_bind+0x1ee>
42003890:	f330d1        	l32r	a13, 42000550 <_stext+0x530> (3c0222f0 <_flash_rodata_start+0x21d0>)
42003893:	f330c1        	l32r	a12, 42000554 <_stext+0x534> (3c026bdc <__func__$3>)
42003896:	82a1b2        	movi	a11, 0x182
42003899:	f32fa1        	l32r	a10, 42000558 <_stext+0x538> (3c022348 <_flash_rodata_start+0x2228>)
4200389c:	f21b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200389f:	0008e0        	callx8	a8
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
420038a2:	07cd      	mov.n	a12, a7
420038a4:	f32eb1        	l32r	a11, 4200055c <_stext+0x53c> (40376464 <shared_intr_isr>)
420038a7:	41a8      	l32i.n	a10, a1, 16
420038a9:	15e2e5        	call8	420196d8 <xt_set_interrupt_handler>
}
420038ac:	001ac6        	j	4200391b <esp_intr_alloc_intrstatus_bind+0x267>
420038af:	00          	.byte	00
        vd->flags = VECDESC_FL_NONSHARED;
420038b0:	880c      	movi.n	a8, 8
420038b2:	005a82        	s16i	a8, a10, 0
        if (handler) {
420038b5:	36ac      	beqz.n	a6, 420038dc <esp_intr_alloc_intrstatus_bind+0x228>
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
420038b7:	f81c      	movi.n	a8, 31
420038b9:	4198      	l32i.n	a9, a1, 16
420038bb:	11b897        	bgeu	a8, a9, 420038d0 <esp_intr_alloc_intrstatus_bind+0x21c>
420038be:	f324d1        	l32r	a13, 42000550 <_stext+0x530> (3c0222f0 <_flash_rodata_start+0x21d0>)
420038c1:	f324c1        	l32r	a12, 42000554 <_stext+0x534> (3c026bdc <__func__$3>)
420038c4:	82a1b2        	movi	a11, 0x182
420038c7:	f324a1        	l32r	a10, 42000558 <_stext+0x538> (3c022348 <_flash_rodata_start+0x2228>)
420038ca:	f20f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420038cd:	0008e0        	callx8	a8
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
420038d0:	0621c2        	l32i	a12, a1, 24
420038d3:	20b660        	or	a11, a6, a6
420038d6:	0421a2        	l32i	a10, a1, 16
420038d9:	15dfe5        	call8	420196d8 <xt_set_interrupt_handler>
        if (flags & ESP_INTR_FLAG_EDGE) {
420038dc:	286397        	bbci	a3, 9, 42003908 <esp_intr_alloc_intrstatus_bind+0x254>
 *
 * @param intr_num Interrupt number (from 0 to 31)
 */
FORCE_INLINE_ATTR void esp_cpu_intr_edge_ack(int intr_num)
{
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
420038df:	f81c      	movi.n	a8, 31
420038e1:	4198      	l32i.n	a9, a1, 16
420038e3:	11b897        	bgeu	a8, a9, 420038f8 <esp_intr_alloc_intrstatus_bind+0x244>
420038e6:	f31ad1        	l32r	a13, 42000550 <_stext+0x530> (3c0222f0 <_flash_rodata_start+0x21d0>)
420038e9:	f31dc1        	l32r	a12, 42000560 <_stext+0x540> (3c026bc4 <__func__$2>)
420038ec:	d1a1b2        	movi	a11, 0x1d1
420038ef:	f31aa1        	l32r	a10, 42000558 <_stext+0x538> (3c022348 <_flash_rodata_start+0x2228>)
420038f2:	f20581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420038f5:	0008e0        	callx8	a8
#ifdef __XTENSA__
    xthal_set_intclear((unsigned) (1 << intr_num));
420038f8:	1a0c      	movi.n	a10, 1
420038fa:	4188      	l32i.n	a8, a1, 16
420038fc:	401800        	ssl	a8
420038ff:	a1aa00        	sll	a10, a10
42003902:	f31b81        	l32r	a8, 42000570 <_stext+0x550> (40001be4 <xthal_set_intclear>)
42003905:	0008e0        	callx8	a8
        vd->source = source;
42003908:	749020        	extui	a9, a2, 0, 8
4200390b:	0199a0        	slli	a9, a9, 22
4200390e:	0788      	l32i.n	a8, a7, 0
42003910:	f315a1        	l32r	a10, 42000564 <_stext+0x544> (c03fffff <_rtc_reserved_end+0x602fffff>)
42003913:	1088a0        	and	a8, a8, a10
42003916:	208890        	or	a8, a8, a9
42003919:	0789      	s32i.n	a8, a7, 0
    if (flags & ESP_INTR_FLAG_IRAM) {
4200391b:	2963a7        	bbci	a3, 10, 42003948 <esp_intr_alloc_intrstatus_bind+0x294>
        vd->flags |= VECDESC_FL_INIRAM;
4200391e:	009782        	l16si	a8, a7, 0
42003921:	290c      	movi.n	a9, 2
42003923:	208890        	or	a8, a8, a9
42003926:	005782        	s16i	a8, a7, 0
        non_iram_int_mask[cpu] &= ~(1<<intr);
42003929:	f30f91        	l32r	a9, 42000568 <_stext+0x548> (3fc94f48 <non_iram_int_mask>)
4200392c:	5188      	l32i.n	a8, a1, 20
4200392e:	a09890        	addx4	a9, a8, a9
42003931:	09a8      	l32i.n	a10, a9, 0
42003933:	180c      	movi.n	a8, 1
42003935:	41b8      	l32i.n	a11, a1, 16
42003937:	401b00        	ssl	a11
4200393a:	a18800        	sll	a8, a8
4200393d:	1088a0        	and	a8, a8, a10
42003940:	3088a0        	xor	a8, a8, a10
42003943:	0989      	s32i.n	a8, a9, 0
42003945:	0008c6        	j	4200396c <esp_intr_alloc_intrstatus_bind+0x2b8>
        vd->flags &= ~VECDESC_FL_INIRAM;
42003948:	009782        	l16si	a8, a7, 0
4200394b:	d97c      	movi.n	a9, -3
4200394d:	108890        	and	a8, a8, a9
42003950:	005782        	s16i	a8, a7, 0
        non_iram_int_mask[cpu] |= (1<<intr);
42003953:	f30581        	l32r	a8, 42000568 <_stext+0x548> (3fc94f48 <non_iram_int_mask>)
42003956:	5198      	l32i.n	a9, a1, 20
42003958:	a08980        	addx4	a8, a9, a8
4200395b:	0898      	l32i.n	a9, a8, 0
4200395d:	1a0c      	movi.n	a10, 1
4200395f:	41b8      	l32i.n	a11, a1, 16
42003961:	401b00        	ssl	a11
42003964:	a1aa00        	sll	a10, a10
42003967:	2099a0        	or	a9, a9, a10
4200396a:	0899      	s32i.n	a9, a8, 0
    if (source>=0) {
4200396c:	00c296        	bltz	a2, 4200397c <esp_intr_alloc_intrstatus_bind+0x2c8>
        esp_rom_route_intr_matrix(cpu, source, intr);
4200396f:	41c8      	l32i.n	a12, a1, 16
42003971:	02bd      	mov.n	a11, a2
42003973:	0821a2        	l32i	a10, a1, 32
42003976:	f1eb81        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42003979:	0008e0        	callx8	a8
    ret->vector_desc = vd;
4200397c:	7198      	l32i.n	a9, a1, 28
4200397e:	0979      	s32i.n	a7, a9, 0
    ret->shared_vector_desc = vd->shared_vec_info;
42003980:	1788      	l32i.n	a8, a7, 4
42003982:	1989      	s32i.n	a8, a9, 4
    ESP_INTR_ENABLE(intr);
42003984:	0421a2        	l32i	a10, a1, 16
42003987:	f22f81        	l32r	a8, 42000244 <_stext+0x224> (40376578 <esp_intr_enable_source>)
4200398a:	0008e0        	callx8	a8
    if (flags & ESP_INTR_FLAG_INTRDISABLED) {
4200398d:	0763b7        	bbci	a3, 11, 42003998 <esp_intr_alloc_intrstatus_bind+0x2e4>
        esp_intr_disable(ret);
42003990:	71a8      	l32i.n	a10, a1, 28
42003992:	f2f881        	l32r	a8, 42000574 <_stext+0x554> (40376654 <esp_intr_disable>)
42003995:	0008e0        	callx8	a8
    portEXIT_CRITICAL(&spinlock);
42003998:	f2eaa1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
4200399b:	f2a681        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200399e:	0008e0        	callx8	a8
    if (ret_handle != NULL) {
420039a1:	152182        	l32i	a8, a1, 84
420039a4:	888c      	beqz.n	a8, 420039b0 <esp_intr_alloc_intrstatus_bind+0x2fc>
        *ret_handle = ret;
420039a6:	7198      	l32i.n	a9, a1, 28
420039a8:	0899      	s32i.n	a9, a8, 0
    return ESP_OK;
420039aa:	020c      	movi.n	a2, 0
420039ac:	000fc6        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
420039af:	00          	.byte	00
        free(ret);
420039b0:	71a8      	l32i.n	a10, a1, 28
420039b2:	f2ee81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
420039b5:	0008e0        	callx8	a8
    return ESP_OK;
420039b8:	020c      	movi.n	a2, 0
420039ba:	000c46        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
        return ESP_ERR_INVALID_ARG;
420039bd:	02a122        	movi	a2, 0x102
420039c0:	000ac6        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
420039c3:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
420039c6:	090602        	l8ui	a0, a6, 9
420039c9:	000000        	ill
        return ESP_ERR_INVALID_ARG;
420039cc:	02a122        	movi	a2, 0x102
420039cf:	000706        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
420039d2:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
420039d5:	0602a1        	l32r	a10, 41fc51e0 <_iram_bss_end+0x1c42de0>
420039d8:	000005        	call0	420039dc <esp_intr_alloc_intrstatus_bind+0x328>
420039db:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
420039de:	030602        	l8ui	a0, a6, 3
420039e1:	000000        	ill
        return ESP_ERR_INVALID_ARG;
420039e4:	02a122        	movi	a2, 0x102
420039e7:	000106        	j	420039ef <esp_intr_alloc_intrstatus_bind+0x33b>
420039ea:	220000        	orb	b0, b0, b0
        return ESP_ERR_NO_MEM;
420039ed:	1d01a1        	l32r	a10, 41fcadf4 <_iram_bss_end+0x1c489f4>
}
420039f0:	0000f0        	callx12	a0
	...

420039f4 <esp_intr_alloc_intrstatus>:
{
420039f4:	006136        	entry	a1, 48
420039f7:	20f770        	or	a15, a7, a7
420039fa:	20a220        	or	a10, a2, a2
420039fd:	20b330        	or	a11, a3, a3
42003a00:	04cd      	mov.n	a12, a4
42003a02:	05dd      	mov.n	a13, a5
42003a04:	06ed      	mov.n	a14, a6
    return esp_intr_alloc_intrstatus_bind(source, flags, intrstatusreg, intrstatusmask, handler, arg, NULL, ret_handle);
42003a06:	c188      	l32i.n	a8, a1, 48
42003a08:	1189      	s32i.n	a8, a1, 4
42003a0a:	080c      	movi.n	a8, 0
42003a0c:	0189      	s32i.n	a8, a1, 0
42003a0e:	ffca65        	call8	420036b4 <esp_intr_alloc_intrstatus_bind>
}
42003a11:	0a2d      	mov.n	a2, a10
42003a13:	f01d      	retw.n
42003a15:	000000        	ill

42003a18 <esp_intr_alloc>:
{
42003a18:	006136        	entry	a1, 48
42003a1b:	02ad      	mov.n	a10, a2
42003a1d:	03bd      	mov.n	a11, a3
42003a1f:	04ed      	mov.n	a14, a4
42003a21:	05fd      	mov.n	a15, a5
    return esp_intr_alloc_intrstatus(source, flags, 0, 0, handler, arg, ret_handle);
42003a23:	0169      	s32i.n	a6, a1, 0
42003a25:	0d0c      	movi.n	a13, 0
42003a27:	0dcd      	mov.n	a12, a13
42003a29:	fffca5        	call8	420039f4 <esp_intr_alloc_intrstatus>
}
42003a2c:	0a2d      	mov.n	a2, a10
42003a2e:	f01d      	retw.n

42003a30 <intr_free_for_current_cpu>:
{
42003a30:	004136        	entry	a1, 32
42003a33:	fb7c      	movi.n	a11, -1
42003a35:	f2c2a1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
42003a38:	f27e81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42003a3b:	0008e0        	callx8	a8
    esp_intr_disable(handle);
42003a3e:	02ad      	mov.n	a10, a2
42003a40:	f2cd81        	l32r	a8, 42000574 <_stext+0x554> (40376654 <esp_intr_disable>)
42003a43:	0008e0        	callx8	a8
    if (handle->vector_desc->flags & VECDESC_FL_SHARED) {
42003a46:	02b8      	l32i.n	a11, a2, 0
42003a48:	009b82        	l16si	a8, a11, 0
42003a4b:	490c      	movi.n	a9, 4
42003a4d:	108890        	and	a8, a8, a9
42003a50:	238880        	sext	a8, a8, 15
42003a53:	049816        	beqz	a8, 42003aa0 <intr_free_for_current_cpu+0x70>
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
42003a56:	1ba8      	l32i.n	a10, a11, 4
        assert(svd); //should be something in there for a shared int
42003a58:	4afc      	bnez.n	a10, 42003a90 <intr_free_for_current_cpu+0x60>
42003a5a:	f2c7d1        	l32r	a13, 42000578 <_stext+0x558> (3c022354 <_flash_rodata_start+0x2234>)
42003a5d:	f2c7c1        	l32r	a12, 4200057c <_stext+0x55c> (3c026ba8 <__func__$1>)
42003a60:	26a3b2        	movi	a11, 0x326
42003a63:	f2ada1        	l32r	a10, 42000518 <_stext+0x4f8> (3c022244 <_flash_rodata_start+0x2124>)
42003a66:	f1a881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42003a69:	0008e0        	callx8	a8
            if (svd == handle->shared_vector_desc) {
42003a6c:	1288      	l32i.n	a8, a2, 4
42003a6e:	1698a7        	bne	a8, a10, 42003a88 <intr_free_for_current_cpu+0x58>
                if (prevsvd) {
42003a71:	598c      	beqz.n	a9, 42003a7a <intr_free_for_current_cpu+0x4a>
                    prevsvd->next = svd->next;
42003a73:	5a88      	l32i.n	a8, a10, 20
42003a75:	5989      	s32i.n	a8, a9, 20
42003a77:	0000c6        	j	42003a7e <intr_free_for_current_cpu+0x4e>
                    handle->vector_desc->shared_vec_info = svd->next;
42003a7a:	5a88      	l32i.n	a8, a10, 20
42003a7c:	1b89      	s32i.n	a8, a11, 4
                free(svd);
42003a7e:	f2bb81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
42003a81:	0008e0        	callx8	a8
                break;
42003a84:	000346        	j	42003a95 <intr_free_for_current_cpu+0x65>
42003a87:	0a9d00        	add.s	f9, f13, f0
            svd = svd->next;
42003a8a:	5aa8      	l32i.n	a10, a10, 20
42003a8c:	000086        	j	42003a92 <intr_free_for_current_cpu+0x62>
42003a8f:	090c00        	l32e	a0, a12, -64
        while (svd != NULL) {
42003a92:	fd6a56        	bnez	a10, 42003a6c <intr_free_for_current_cpu+0x3c>
        if (handle->vector_desc->shared_vec_info == NULL) {
42003a95:	0288      	l32i.n	a8, a2, 0
42003a97:	1888      	l32i.n	a8, a8, 4
42003a99:	888c      	beqz.n	a8, 42003aa5 <intr_free_for_current_cpu+0x75>
    bool free_shared_vector = false;
42003a9b:	0b0c      	movi.n	a11, 0
42003a9d:	000186        	j	42003aa7 <intr_free_for_current_cpu+0x77>
42003aa0:	0b0c      	movi.n	a11, 0
42003aa2:	000046        	j	42003aa7 <intr_free_for_current_cpu+0x77>
            free_shared_vector = true;
42003aa5:	1b0c      	movi.n	a11, 1
    if ((handle->vector_desc->flags & VECDESC_FL_NONSHARED) || free_shared_vector) {
42003aa7:	0298      	l32i.n	a9, a2, 0
42003aa9:	009982        	l16si	a8, a9, 0
42003aac:	8a0c      	movi.n	a10, 8
42003aae:	1088a0        	and	a8, a8, a10
42003ab1:	238880        	sext	a8, a8, 15
42003ab4:	18cc      	bnez.n	a8, 42003ab9 <intr_free_for_current_cpu+0x89>
42003ab6:	04fb16        	beqz	a11, 42003b09 <intr_free_for_current_cpu+0xd9>
        esp_cpu_intr_set_handler(handle->vector_desc->intno, NULL, (void*)((int)handle->vector_desc->intno));
42003ab9:	0029a2        	l32i	a10, a9, 0
42003abc:	45a1a0        	extui	a10, a10, 17, 5
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
42003abf:	20caa0        	or	a12, a10, a10
42003ac2:	00a0b2        	movi	a11, 0
42003ac5:	15c125        	call8	420196d8 <xt_set_interrupt_handler>
        handle->vector_desc->flags &= ~(VECDESC_FL_NONSHARED|VECDESC_FL_RESERVED|VECDESC_FL_SHARED);
42003ac8:	0298      	l32i.n	a9, a2, 0
42003aca:	009982        	l16si	a8, a9, 0
42003acd:	2a7c      	movi.n	a10, -14
42003acf:	1088a0        	and	a8, a8, a10
42003ad2:	005982        	s16i	a8, a9, 0
        handle->vector_desc->source = ETS_INTERNAL_UNUSED_INTR_SOURCE;
42003ad5:	0298      	l32i.n	a9, a2, 0
42003ad7:	0988      	l32i.n	a8, a9, 0
42003ad9:	f2a2a1        	l32r	a10, 42000564 <_stext+0x544> (c03fffff <_rtc_reserved_end+0x602fffff>)
42003adc:	1088a0        	and	a8, a8, a10
42003adf:	f2a8a1        	l32r	a10, 42000580 <_stext+0x560> (27400000 <UserFrameTotalSize+0x273fff00>)
42003ae2:	2088a0        	or	a8, a8, a10
42003ae5:	0989      	s32i.n	a8, a9, 0
        non_iram_int_mask[handle->vector_desc->cpu] &= ~(1<<(handle->vector_desc->intno));
42003ae7:	0288      	l32i.n	a8, a2, 0
42003ae9:	0888      	l32i.n	a8, a8, 0
42003aeb:	f29f91        	l32r	a9, 42000568 <_stext+0x548> (3fc94f48 <non_iram_int_mask>)
42003aee:	05a080        	extui	a10, a8, 16, 1
42003af1:	a0aa90        	addx4	a10, a10, a9
42003af4:	0ab8      	l32i.n	a11, a10, 0
42003af6:	459180        	extui	a9, a8, 17, 5
42003af9:	180c      	movi.n	a8, 1
42003afb:	401900        	ssl	a9
42003afe:	a18800        	sll	a8, a8
42003b01:	1088b0        	and	a8, a8, a11
42003b04:	3088b0        	xor	a8, a8, a11
42003b07:	0a89      	s32i.n	a8, a10, 0
    portEXIT_CRITICAL(&spinlock);
42003b09:	f28da1        	l32r	a10, 42000540 <_stext+0x520> (3fc9244c <spinlock>)
42003b0c:	f24a81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42003b0f:	0008e0        	callx8	a8
    free(handle);
42003b12:	02ad      	mov.n	a10, a2
42003b14:	f29681        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
42003b17:	0008e0        	callx8	a8
}
42003b1a:	020c      	movi.n	a2, 0
42003b1c:	f01d      	retw.n
	...

42003b20 <esp_intr_free>:
{
42003b20:	004136        	entry	a1, 32
    if (!handle) {
42003b23:	046216        	beqz	a2, 42003b6d <esp_intr_free+0x4d>
    UBaseType_t core_affinity = xTaskGetCoreID(NULL);
42003b26:	00a0a2        	movi	a10, 0
42003b29:	f29781        	l32r	a8, 42000588 <_stext+0x568> (4037c714 <xTaskGetCoreID>)
42003b2c:	0008e0        	callx8	a8
    if (task_can_be_run_on_any_core || handle->vector_desc->cpu != esp_cpu_get_core_id()) {
42003b2f:	f27d81        	l32r	a8, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42003b32:	111a87        	beq	a10, a8, 42003b47 <esp_intr_free+0x27>
42003b35:	002282        	l32i	a8, a2, 0
42003b38:	002882        	l32i	a8, a8, 0
42003b3b:	058080        	extui	a8, a8, 16, 1
42003b3e:	03eb90        	rsr.prid	a9
42003b41:	049d90        	extui	a9, a9, 13, 1
42003b44:	181897        	beq	a8, a9, 42003b60 <esp_intr_free+0x40>
        esp_err_t ret = esp_ipc_call_blocking(handle->vector_desc->cpu, &intr_free_for_other_cpu, (void *)handle);
42003b47:	0288      	l32i.n	a8, a2, 0
42003b49:	08a8      	l32i.n	a10, a8, 0
42003b4b:	02cd      	mov.n	a12, a2
42003b4d:	f28db1        	l32r	a11, 42000584 <_stext+0x564> (42003b74 <intr_free_for_other_cpu>)
42003b50:	05a0a0        	extui	a10, a10, 16, 1
42003b53:	fedde5        	call8	42002930 <esp_ipc_call_blocking>
42003b56:	0a2d      	mov.n	a2, a10
        return ret == ESP_OK ? ESP_OK : ESP_FAIL;
42003b58:	4a9c      	beqz.n	a10, 42003b70 <esp_intr_free+0x50>
42003b5a:	f27c      	movi.n	a2, -1
42003b5c:	000406        	j	42003b70 <esp_intr_free+0x50>
42003b5f:	02ad00        	andb	b10, b13, b0
    return intr_free_for_current_cpu(handle);
42003b62:	ffece5        	call8	42003a30 <intr_free_for_current_cpu>
42003b65:	0a2d      	mov.n	a2, a10
42003b67:	000146        	j	42003b70 <esp_intr_free+0x50>
42003b6a:	000000        	ill
        return ESP_ERR_INVALID_ARG;
42003b6d:	02a122        	movi	a2, 0x102
}
42003b70:	f01d      	retw.n
	...

42003b74 <intr_free_for_other_cpu>:
{
42003b74:	004136        	entry	a1, 32
42003b77:	02ad      	mov.n	a10, a2
    (void)intr_free_for_current_cpu((intr_handle_t)arg);
42003b79:	ffeb65        	call8	42003a30 <intr_free_for_current_cpu>
}
42003b7c:	f01d      	retw.n
	...

42003b80 <s_rtc_isr_noniram_hook>:
{
42003b80:	004136        	entry	a1, 32
    rtc_intr_cache |= rtc_intr_mask;
42003b83:	f28291        	l32r	a9, 4200058c <_stext+0x56c> (3fc92d14 <rtc_intr_cache>)
42003b86:	0988      	l32i.n	a8, a9, 0
42003b88:	208820        	or	a8, a8, a2
42003b8b:	0989      	s32i.n	a8, a9, 0
}
42003b8d:	f01d      	retw.n
	...

42003b90 <s_rtc_isr_noniram_hook_relieve>:
{
42003b90:	004136        	entry	a1, 32
    rtc_intr_cache &= ~rtc_intr_mask;
42003b93:	f27e81        	l32r	a8, 4200058c <_stext+0x56c> (3fc92d14 <rtc_intr_cache>)
42003b96:	0898      	l32i.n	a9, a8, 0
42003b98:	102290        	and	a2, a2, a9
42003b9b:	302290        	xor	a2, a2, a9
42003b9e:	0829      	s32i.n	a2, a8, 0
}
42003ba0:	f01d      	retw.n
	...

42003ba4 <rtc_isr_ensure_installed>:
{
42003ba4:	004136        	entry	a1, 32
42003ba7:	ffafb2        	movi	a11, -1
42003baa:	f279a1        	l32r	a10, 42000590 <_stext+0x570> (3fc92d00 <s_rtc_isr_handler_list_lock>)
42003bad:	f22081        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42003bb0:	0008e0        	callx8	a8
    if (s_rtc_isr_handle) {
42003bb3:	f27881        	l32r	a8, 42000594 <_stext+0x574> (3fc94f80 <s_rtc_isr_handle>)
42003bb6:	002882        	l32i	a8, a8, 0
42003bb9:	58fc      	bnez.n	a8, 42003bf2 <rtc_isr_ensure_installed+0x4e>
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
42003bbb:	0d0c      	movi.n	a13, 0
42003bbd:	f27681        	l32r	a8, 42000598 <_stext+0x578> (60008040 <RTCCNTL+0x40>)
42003bc0:	0020c0        	memw
42003bc3:	08d9      	s32i.n	a13, a8, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
42003bc5:	f27581        	l32r	a8, 4200059c <_stext+0x57c> (6000804c <RTCCNTL+0x4c>)
42003bc8:	f97c      	movi.n	a9, -1
42003bca:	0020c0        	memw
42003bcd:	0899      	s32i.n	a9, a8, 0
    err = esp_intr_alloc(ETS_RTC_CORE_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_isr, NULL, &s_rtc_isr_handle);
42003bcf:	f271e1        	l32r	a14, 42000594 <_stext+0x574> (3fc94f80 <s_rtc_isr_handle>)
42003bd2:	f273c1        	l32r	a12, 420005a0 <_stext+0x580> (4037674c <rtc_isr>)
42003bd5:	00a4b2        	movi	a11, 0x400
42003bd8:	7a2c      	movi.n	a10, 39
42003bda:	ffe3e5        	call8	42003a18 <esp_intr_alloc>
42003bdd:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
42003bdf:	1adc      	bnez.n	a10, 42003bf4 <rtc_isr_ensure_installed+0x50>
    rtc_isr_cpu = esp_intr_get_cpu(s_rtc_isr_handle);
42003be1:	f26c81        	l32r	a8, 42000594 <_stext+0x574> (3fc94f80 <s_rtc_isr_handle>)
42003be4:	08a8      	l32i.n	a10, a8, 0
42003be6:	129f25        	call8	420165d8 <esp_intr_get_cpu>
42003be9:	f26e81        	l32r	a8, 420005a4 <_stext+0x584> (3fc92d0c <rtc_isr_cpu>)
42003bec:	08a9      	s32i.n	a10, a8, 0
42003bee:	000086        	j	42003bf4 <rtc_isr_ensure_installed+0x50>
42003bf1:	020c00        	andb	b0, b12, b0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
42003bf4:	f267a1        	l32r	a10, 42000590 <_stext+0x570> (3fc92d00 <s_rtc_isr_handler_list_lock>)
42003bf7:	f20f81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42003bfa:	0008e0        	callx8	a8
}
42003bfd:	f01d      	retw.n
	...

42003c00 <rtc_isr_register>:
{
42003c00:	004136        	entry	a1, 32
42003c03:	027d      	mov.n	a7, a2
    esp_err_t err = rtc_isr_ensure_installed();
42003c05:	fff9e5        	call8	42003ba4 <rtc_isr_ensure_installed>
42003c08:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
42003c0a:	04ea56        	bnez	a10, 42003c5c <rtc_isr_register+0x5c>
    rtc_isr_handler_t* item = heap_caps_malloc(sizeof(*item), MALLOC_CAP_INTERNAL);
42003c0d:	f266b1        	l32r	a11, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
42003c10:	4a1c      	movi.n	a10, 20
42003c12:	f23e81        	l32r	a8, 4200050c <_stext+0x4ec> (40375ec4 <heap_caps_malloc>)
42003c15:	0008e0        	callx8	a8
42003c18:	0a6d      	mov.n	a6, a10
    if (item == NULL) {
42003c1a:	03ba16        	beqz	a10, 42003c59 <rtc_isr_register+0x59>
    item->handler = handler;
42003c1d:	1a79      	s32i.n	a7, a10, 4
    item->handler_arg = handler_arg;
42003c1f:	2a39      	s32i.n	a3, a10, 8
    item->mask = rtc_intr_mask;
42003c21:	0a49      	s32i.n	a4, a10, 0
    item->flags = flags;
42003c23:	3a59      	s32i.n	a5, a10, 12
42003c25:	fb7c      	movi.n	a11, -1
42003c27:	f25aa1        	l32r	a10, 42000590 <_stext+0x570> (3fc92d00 <s_rtc_isr_handler_list_lock>)
42003c2a:	f20181        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42003c2d:	0008e0        	callx8	a8
    if (flags & RTC_INTR_FLAG_IRAM) {
42003c30:	086507        	bbci	a5, 0, 42003c3c <rtc_isr_register+0x3c>
        s_rtc_isr_noniram_hook(rtc_intr_mask);
42003c33:	04ad      	mov.n	a10, a4
42003c35:	fff4a5        	call8	42003b80 <s_rtc_isr_noniram_hook>
42003c38:	000146        	j	42003c41 <rtc_isr_register+0x41>
42003c3b:	04ad00        	extui	a10, a0, 13, 1
        s_rtc_isr_noniram_hook_relieve(rtc_intr_mask);
42003c3e:	fff525        	call8	42003b90 <s_rtc_isr_noniram_hook_relieve>
    SLIST_INSERT_HEAD(&s_rtc_isr_handler_list, item, next);
42003c41:	f25a81        	l32r	a8, 420005ac <_stext+0x58c> (3fc92d08 <s_rtc_isr_handler_list>)
42003c44:	0898      	l32i.n	a9, a8, 0
42003c46:	4699      	s32i.n	a9, a6, 16
42003c48:	006862        	s32i	a6, a8, 0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
42003c4b:	f251a1        	l32r	a10, 42000590 <_stext+0x570> (3fc92d00 <s_rtc_isr_handler_list_lock>)
42003c4e:	f1f981        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42003c51:	0008e0        	callx8	a8
    return ESP_OK;
42003c54:	000106        	j	42003c5c <rtc_isr_register+0x5c>
42003c57:	220000        	orb	b0, b0, b0
        return ESP_ERR_NO_MEM;
42003c5a:	1d01a1        	l32r	a10, 41fcb060 <_iram_bss_end+0x1c48c60>
}
42003c5d:	0000f0        	callx12	a0

42003c60 <esp_sleep_config_gpio_isolate>:
    }
}
#endif

void esp_sleep_config_gpio_isolate(void)
{
42003c60:	004136        	entry	a1, 32
42003c63:	f0f281        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42003c66:	0888      	l32i.n	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "Configure to isolate all GPIO pins in sleep state");
42003c68:	6138b6        	bltui	a8, 3, 42003ccd <esp_sleep_config_gpio_isolate+0x6d>
42003c6b:	f0fd81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42003c6e:	0008e0        	callx8	a8
42003c71:	f24fc1        	l32r	a12, 420005b0 <_stext+0x590> (3c0223a4 <_flash_rodata_start+0x2284>)
42003c74:	20baa0        	or	a11, a10, a10
42003c77:	f24fa1        	l32r	a10, 420005b4 <_stext+0x594> (3c0223b0 <_flash_rodata_start+0x2290>)
42003c7a:	f0fa81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003c7d:	0008e0        	callx8	a8
42003c80:	001246        	j	42003ccd <esp_sleep_config_gpio_isolate+0x6d>
42003c83:	960000        	ee.ldf.64.xp	f0, f9, a0, a0
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
        if (GPIO_IS_VALID_GPIO(gpio_num)) {
42003c86:	a203d7        	bnone	a3, a13, 42003c2c <rtc_isr_register+0x2c>
42003c89:	a020a0        	addx4	a2, a0, a10
42003c8c:	8210a7        	beq	a0, a10, 42003c12 <rtc_isr_register+0x12>
42003c8f:	8780ffaf 	ee.ldf.128.ip	f14, f1, f15, f8, a10, -16
42003c93:	499130        	s32e	a3, a1, -28
42003c96:	1800f2        	l8ui	a15, a0, 24
42003c99:	40          	.byte	0x40
42003c9a:	a19900        	sll	a9, a9
42003c9d:	f24781        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003ca0:	400700        	ssr	a7
42003ca3:	918080        	srl	a8, a8
42003ca6:	208980        	or	a8, a9, a8
42003ca9:	f24591        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
42003cac:	400700        	ssr	a7
42003caf:	919090        	srl	a9, a9
42003cb2:	9389a0        	movnez	a8, a9, a10
42003cb5:	0d6807        	bbci	a8, 0, 42003cc6 <esp_sleep_config_gpio_isolate+0x66>
            gpio_sleep_set_direction(gpio_num, GPIO_MODE_DISABLE);
42003cb8:	0b0c      	movi.n	a11, 0
42003cba:	07ad      	mov.n	a10, a7
42003cbc:	06f0e5        	call8	4200abcc <gpio_sleep_set_direction>
            gpio_sleep_set_pull_mode(gpio_num, GPIO_FLOATING);
42003cbf:	3b0c      	movi.n	a11, 3
42003cc1:	07ad      	mov.n	a10, a7
42003cc3:	06f9a5        	call8	4200ac5c <gpio_sleep_set_pull_mode>
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003cc6:	771b      	addi.n	a7, a7, 1
42003cc8:	0000c6        	j	42003ccf <esp_sleep_config_gpio_isolate+0x6f>
42003ccb:	00          	.byte	00
42003ccc:	070c00        	ee.stf.64.xp	f0, f0, a0, a12
42003ccf:	083c      	movi.n	a8, 48
42003cd1:	b0a877        	bge	a8, a7, 42003c85 <esp_sleep_config_gpio_isolate+0x25>
        }
    }

#if CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU && !SOC_MSPI_HAS_INDEPENT_IOMUX
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_CLK), GPIO_PULLUP_ONLY);
42003cd4:	0a0c      	movi.n	a10, 0
42003cd6:	072fe5        	call8	4200afd4 <esp_mspi_get_io>
42003cd9:	0b0c      	movi.n	a11, 0
42003cdb:	06f825        	call8	4200ac5c <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_Q),   GPIO_PULLUP_ONLY);
42003cde:	1a0c      	movi.n	a10, 1
42003ce0:	072f25        	call8	4200afd4 <esp_mspi_get_io>
42003ce3:	0b0c      	movi.n	a11, 0
42003ce5:	06f765        	call8	4200ac5c <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D),   GPIO_PULLUP_ONLY);
42003ce8:	2a0c      	movi.n	a10, 2
42003cea:	072ea5        	call8	4200afd4 <esp_mspi_get_io>
42003ced:	0b0c      	movi.n	a11, 0
42003cef:	06f6e5        	call8	4200ac5c <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_HD),  GPIO_PULLUP_ONLY);
42003cf2:	4a0c      	movi.n	a10, 4
42003cf4:	072de5        	call8	4200afd4 <esp_mspi_get_io>
42003cf7:	0b0c      	movi.n	a11, 0
42003cf9:	06f625        	call8	4200ac5c <gpio_sleep_set_pull_mode>
    gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_WP),  GPIO_PULLUP_ONLY);
42003cfc:	5a0c      	movi.n	a10, 5
42003cfe:	072d65        	call8	4200afd4 <esp_mspi_get_io>
42003d01:	0b0c      	movi.n	a11, 0
42003d03:	06f5a5        	call8	4200ac5c <gpio_sleep_set_pull_mode>
#if SOC_SPI_MEM_SUPPORT_FLASH_OPI_MODE
    bool octal_mspi_required = bootloader_flash_is_octal_mode_enabled();
42003d06:	f22f81        	l32r	a8, 420005c4 <_stext+0x5a4> (403775bc <bootloader_flash_is_octal_mode_enabled>)
42003d09:	0008e0        	callx8	a8
#if CONFIG_SPIRAM_MODE_OCT
    octal_mspi_required |= true;
#endif // CONFIG_SPIRAM_MODE_OCT
    if (octal_mspi_required) {
42003d0c:	031a16        	beqz	a10, 42003d41 <esp_sleep_config_gpio_isolate+0xe1>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_DQS), GPIO_PULLUP_ONLY);
42003d0f:	6a0c      	movi.n	a10, 6
42003d11:	072c25        	call8	4200afd4 <esp_mspi_get_io>
42003d14:	0b0c      	movi.n	a11, 0
42003d16:	06f465        	call8	4200ac5c <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D4),  GPIO_PULLUP_ONLY);
42003d19:	7a0c      	movi.n	a10, 7
42003d1b:	072ba5        	call8	4200afd4 <esp_mspi_get_io>
42003d1e:	0b0c      	movi.n	a11, 0
42003d20:	06f3a5        	call8	4200ac5c <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D5),  GPIO_PULLUP_ONLY);
42003d23:	8a0c      	movi.n	a10, 8
42003d25:	072ae5        	call8	4200afd4 <esp_mspi_get_io>
42003d28:	0b0c      	movi.n	a11, 0
42003d2a:	06f325        	call8	4200ac5c <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D6),  GPIO_PULLUP_ONLY);
42003d2d:	9a0c      	movi.n	a10, 9
42003d2f:	072a65        	call8	4200afd4 <esp_mspi_get_io>
42003d32:	0b0c      	movi.n	a11, 0
42003d34:	06f265        	call8	4200ac5c <gpio_sleep_set_pull_mode>
        gpio_sleep_set_pull_mode(esp_mspi_get_io(ESP_MSPI_IO_D7),  GPIO_PULLUP_ONLY);
42003d37:	aa0c      	movi.n	a10, 10
42003d39:	0729a5        	call8	4200afd4 <esp_mspi_get_io>
42003d3c:	0b0c      	movi.n	a11, 0
42003d3e:	06f1e5        	call8	4200ac5c <gpio_sleep_set_pull_mode>
    }
#endif // SOC_SPI_MEM_SUPPORT_FLASH_OPI_MODE
#endif // CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU
}
42003d41:	f01d      	retw.n
	...

42003d44 <esp_sleep_enable_gpio_switch>:

void esp_sleep_enable_gpio_switch(bool enable)
{
42003d44:	004136        	entry	a1, 32
42003d47:	742020        	extui	a2, a2, 0, 8
42003d4a:	f0b881        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
42003d4d:	002882        	l32i	a8, a8, 0
    ESP_EARLY_LOGI(TAG, "%s automatic switching of GPIO sleep configuration", enable ? "Enable" : "Disable");
42003d50:	0238f6        	bgeui	a8, 3, 42003d56 <esp_sleep_enable_gpio_switch+0x12>
42003d53:	002586        	j	42003ded <esp_sleep_enable_gpio_switch+0xa9>
42003d56:	f0c281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42003d59:	0008e0        	callx8	a8
42003d5c:	0abd      	mov.n	a11, a10
42003d5e:	728c      	beqz.n	a2, 42003d69 <esp_sleep_enable_gpio_switch+0x25>
42003d60:	f21ad1        	l32r	a13, 420005c8 <_stext+0x5a8> (3c0223f0 <_flash_rodata_start+0x22d0>)
42003d63:	000146        	j	42003d6c <esp_sleep_enable_gpio_switch+0x28>
42003d66:	000000        	ill
42003d69:	f218d1        	l32r	a13, 420005cc <_stext+0x5ac> (3c0223f8 <_flash_rodata_start+0x22d8>)
42003d6c:	f211c1        	l32r	a12, 420005b0 <_stext+0x590> (3c0223a4 <_flash_rodata_start+0x2284>)
42003d6f:	f218a1        	l32r	a10, 420005d0 <_stext+0x5b0> (3c022400 <_flash_rodata_start+0x22e0>)
42003d72:	f0bc81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42003d75:	0008e0        	callx8	a8
42003d78:	001c46        	j	42003ded <esp_sleep_enable_gpio_switch+0xa9>
42003d7b:	960000        	ee.ldf.64.xp	f0, f9, a0, a0
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
        if (GPIO_IS_VALID_GPIO(gpio_num)) {
42003d7e:	a20647        	bnone	a6, a4, 42003d24 <esp_sleep_config_gpio_isolate+0xc4>
42003d81:	a020a0        	addx4	a2, a0, a10
42003d84:	8210a7        	beq	a0, a10, 42003d0a <esp_sleep_config_gpio_isolate+0xaa>
42003d87:	8780ffaf 	ee.ldf.128.ip	f14, f1, f15, f8, a10, -16
42003d8b:	30          	.byte	0x30
42003d8c:	f20b91        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
42003d8f:	401800        	ssl	a8
42003d92:	a19900        	sll	a9, a9
42003d95:	f20981        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
42003d98:	400700        	ssr	a7
42003d9b:	918080        	srl	a8, a8
42003d9e:	208980        	or	a8, a9, a8
42003da1:	f20791        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
42003da4:	400700        	ssr	a7
42003da7:	919090        	srl	a9, a9
42003daa:	9389a0        	movnez	a8, a9, a10
42003dad:	346807        	bbci	a8, 0, 42003de5 <esp_sleep_enable_gpio_switch+0xa1>
#if CONFIG_ESP_CONSOLE_UART_CUSTOM
            const int uart_tx_gpio = (CONFIG_ESP_CONSOLE_UART_TX_GPIO >= 0) ? CONFIG_ESP_CONSOLE_UART_TX_GPIO : UART_NUM_0_TXD_DIRECT_GPIO_NUM;
            const int uart_rx_gpio = (CONFIG_ESP_CONSOLE_UART_RX_GPIO >= 0) ? CONFIG_ESP_CONSOLE_UART_RX_GPIO : UART_NUM_0_RXD_DIRECT_GPIO_NUM;
            if ((gpio_num == uart_tx_gpio) || (gpio_num == uart_rx_gpio)) {
#else
            if ((gpio_num == UART_NUM_0_TXD_DIRECT_GPIO_NUM) || (gpio_num == UART_NUM_0_RXD_DIRECT_GPIO_NUM)) {
42003db0:	d5c782        	addi	a8, a7, -43
42003db3:	0a28f6        	bgeui	a8, 2, 42003dc1 <esp_sleep_enable_gpio_switch+0x7d>
#endif
                gpio_sleep_sel_dis(gpio_num);
42003db6:	20a770        	or	a10, a7, a7
42003db9:	070425        	call8	4200adfc <gpio_sleep_sel_dis>
                continue;
42003dbc:	000946        	j	42003de5 <esp_sleep_enable_gpio_switch+0xa1>
42003dbf:	a20000        	muluh	a0, a0, a0
                continue;
            }
#endif // CONFIG_ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND && CONFIG_SPIRAM

#if CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND & !SOC_MSPI_HAS_INDEPENT_IOMUX
            if (gpio_num == esp_mspi_get_io(ESP_MSPI_IO_CS0)) {
42003dc2:	e503a0        	extui	a0, a10, 19, 15
42003dc5:	a70720        	ee.stf.64.xp	f0, f10, a2, a7
42003dc8:	700b97        	bnone	a11, a9, 42003e3c <esp_deep_sleep_wakeup_io_reset+0x30>
                gpio_sleep_sel_dis(gpio_num);
42003dcb:	e520a7        	blt	a0, a10, 42003db4 <esp_sleep_enable_gpio_switch+0x70>
42003dce:	460702        	l8ui	a0, a7, 70
                continue;
42003dd1:	000004        	ee.ld.qacc_l.l.128.ip	a0, 0
42003dd4:	00          	.byte	00
42003dd5:	628c00        	saltu	a8, a12, a0
            }
#endif // CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND

            if (enable) {
                gpio_sleep_sel_en(gpio_num);
42003dd8:	07ad      	mov.n	a10, a7
42003dda:	06f925        	call8	4200ad6c <gpio_sleep_sel_en>
42003ddd:	000106        	j	42003de5 <esp_sleep_enable_gpio_switch+0xa1>
            } else {
                gpio_sleep_sel_dis(gpio_num);
42003de0:	07ad      	mov.n	a10, a7
42003de2:	0701a5        	call8	4200adfc <gpio_sleep_sel_dis>
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003de5:	771b      	addi.n	a7, a7, 1
42003de7:	000106        	j	42003def <esp_sleep_enable_gpio_switch+0xab>
42003dea:	000000        	ill
    ESP_EARLY_LOGI(TAG, "%s automatic switching of GPIO sleep configuration", enable ? "Enable" : "Disable");
42003ded:	070c      	movi.n	a7, 0
    for (gpio_num_t gpio_num = GPIO_NUM_0; gpio_num < GPIO_NUM_MAX; gpio_num++) {
42003def:	083c      	movi.n	a8, 48
42003df1:	88a877        	bge	a8, a7, 42003d7d <esp_sleep_enable_gpio_switch+0x39>
            }
        }
    }
}
42003df4:	f01d      	retw.n
	...

42003df8 <__esp_system_init_fn_esp_sleep_startup_init>:
}
#endif

#if CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND || CONFIG_PM_SLP_DISABLE_GPIO
ESP_SYSTEM_INIT_FN(esp_sleep_startup_init, SECONDARY, BIT(0), 105)
{
42003df8:	004136        	entry	a1, 32
    // Configure to isolate (disable the Input/Output/Pullup/Pulldown
    // function of the pin) all GPIO pins in sleep state
    esp_sleep_config_gpio_isolate();
42003dfb:	ffe665        	call8	42003c60 <esp_sleep_config_gpio_isolate>
    // Enable automatic switching of GPIO configuration
    esp_sleep_enable_gpio_switch(true);
42003dfe:	01a0a2        	movi	a10, 1
42003e01:	fff425        	call8	42003d44 <esp_sleep_enable_gpio_switch>
    return ESP_OK;
}
42003e04:	00a022        	movi	a2, 0
42003e07:	f01d      	retw.n
42003e09:	000000        	ill

42003e0c <esp_deep_sleep_wakeup_io_reset>:
{
42003e0c:	004136        	entry	a1, 32
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003e0f:	f1f1a1        	l32r	a10, 420005d4 <_stext+0x5b4> (600080e0 <RTCCNTL+0xe0>)
42003e12:	0020c0        	memw
42003e15:	0a98      	l32i.n	a9, a10, 0
42003e17:	119960        	slli	a9, a9, 10
42003e1a:	419a90        	srli	a9, a9, 10
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
42003e1d:	0020c0        	memw
42003e20:	0a88      	l32i.n	a8, a10, 0
42003e22:	958680        	extui	a8, a8, 22, 10
42003e25:	0188a0        	slli	a8, a8, 22
42003e28:	0020c0        	memw
42003e2b:	0a89      	s32i.n	a8, a10, 0
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003e2d:	0a0c      	movi.n	a10, 0
42003e2f:	000f06        	j	42003e6f <esp_deep_sleep_wakeup_io_reset+0x63>
42003e32:	810000        	src	a0, a0, a0
        int rtcio_num = rtc_io_num_map[gpio_num];
42003e35:	f1e9      	s32i.n	a14, a1, 60
42003e37:	a08a80        	addx4	a8, a10, a8
42003e3a:	08b8      	l32i.n	a11, a8, 0
        if ((rtc_io_mask & BIT(rtcio_num)) == 0) {
42003e3c:	2d59b7        	bbc	a9, a11, 42003e6d <esp_deep_sleep_wakeup_io_reset+0x61>
 * @note If disable the pad hold, the status of pad maybe changed in sleep mode.
 * @param rtcio_num The index of rtcio. 0 ~ MAX(rtcio).
 */
static inline void rtcio_ll_force_hold_disable(int rtcio_num)
{
    CLEAR_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, rtc_io_desc[rtcio_num].hold_force);
42003e3f:	f1e7c1        	l32r	a12, 420005dc <_stext+0x5bc> (600080d8 <RTCCNTL+0xd8>)
42003e42:	0020c0        	memw
42003e45:	0cd8      	l32i.n	a13, a12, 0
42003e47:	f08bb0        	subx8	a8, a11, a11
42003e4a:	11e8d0        	slli	a14, a8, 3
42003e4d:	f1e481        	l32r	a8, 420005e0 <_stext+0x5c0> (3c027e74 <rtc_io_desc>)
42003e50:	88ea      	add.n	a8, a8, a14
42003e52:	a888      	l32i.n	a8, a8, 40
42003e54:	1088d0        	and	a8, a8, a13
42003e57:	3088d0        	xor	a8, a8, a13
42003e5a:	0020c0        	memw
42003e5d:	0c89      	s32i.n	a8, a12, 0
        rtc_io_mask &= ~BIT(rtcio_num);
42003e5f:	180c      	movi.n	a8, 1
42003e61:	401b00        	ssl	a11
42003e64:	a18800        	sll	a8, a8
42003e67:	108890        	and	a8, a8, a9
42003e6a:	309890        	xor	a9, a8, a9
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003e6d:	aa1b      	addi.n	a10, a10, 1
42003e6f:	083c      	movi.n	a8, 48
42003e71:	7288a0        	salt	a8, a8, a10
42003e74:	880b      	addi.n	a8, a8, -1
42003e76:	608080        	neg	a8, a8
42003e79:	748080        	extui	a8, a8, 0, 8
42003e7c:	1b0c      	movi.n	a11, 1
42003e7e:	83b990        	moveqz	a11, a9, a9
42003e81:	188c      	beqz.n	a8, 42003e86 <esp_deep_sleep_wakeup_io_reset+0x7a>
42003e83:	fadb56        	bnez	a11, 42003e34 <esp_deep_sleep_wakeup_io_reset+0x28>
}
42003e86:	f01d      	retw.n

42003e88 <esp_brownout_init>:
}
#endif // CONFIG_ESP_BROWNOUT_USE_INTR

void esp_brownout_init(void)
{
42003e88:	006136        	entry	a1, 48
#if CONFIG_ESP_BROWNOUT_USE_INTR
    brownout_hal_config_t cfg = {
42003e8b:	f1d681        	l32r	a8, 420005e4 <_stext+0x5c4> (3c026c3c <__func__$2+0x18>)
42003e8e:	002892        	l32i	a9, a8, 0
42003e91:	040882        	l8ui	a8, a8, 4
42003e94:	006192        	s32i	a9, a1, 0
42003e97:	044182        	s8i	a8, a1, 4
        .reset_enabled = false,
        .flash_power_down = true,
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
42003e9a:	01ad      	mov.n	a10, a1
42003e9c:	084325        	call8	4200c2d0 <brownout_hal_config>
42003e9f:	f09d61        	l32r	a6, 42000114 <_stext+0xf4> (60008000 <RTCCNTL>)
42003ea2:	0020c0        	memw
42003ea5:	132692        	l32i	a9, a6, 76
42003ea8:	00a272        	movi	a7, 0x200
42003eab:	208970        	or	a8, a9, a7
42003eae:	0020c0        	memw
42003eb1:	136682        	s32i	a8, a6, 76
    brownout_ll_intr_clear();

#if CONFIG_IDF_TARGET_ESP32 || CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C2
    rtc_isr_register(rtc_brownout_isr_handler, NULL, RTC_CNTL_BROWN_OUT_INT_ENA_M, RTC_INTR_FLAG_IRAM);
42003eb4:	1d0c      	movi.n	a13, 1
42003eb6:	07cd      	mov.n	a12, a7
42003eb8:	0b0c      	movi.n	a11, 0
42003eba:	f1cba1        	l32r	a10, 420005e8 <_stext+0x5c8> (403767ec <rtc_brownout_isr_handler>)
42003ebd:	ffd425        	call8	42003c00 <rtc_isr_register>
    RTCCNTL.int_ena.rtc_brown_out = enable;
42003ec0:	0020c0        	memw
42003ec3:	102682        	l32i	a8, a6, 64
42003ec6:	207870        	or	a7, a8, a7
42003ec9:	0020c0        	memw
42003ecc:	106672        	s32i	a7, a6, 64
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
#endif
}
42003ecf:	f01d      	retw.n
42003ed1:	000000        	ill

42003ed4 <esp_chip_info>:
#include <string.h>
#include "esp_chip_info.h"
#include "hal/efuse_hal.h"

void esp_chip_info(esp_chip_info_t *out_info)
{
42003ed4:	004136        	entry	a1, 32
    memset(out_info, 0, sizeof(*out_info));
42003ed7:	0ca0c2        	movi	a12, 12
42003eda:	00a0b2        	movi	a11, 0
42003edd:	20a220        	or	a10, a2, a2
42003ee0:	f10981        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
42003ee3:	0008e0        	callx8	a8
    out_info->model = CHIP_ESP32S3;
42003ee6:	980c      	movi.n	a8, 9
42003ee8:	0289      	s32i.n	a8, a2, 0
    out_info->revision = efuse_hal_chip_revision();
42003eea:	f06781        	l32r	a8, 42000088 <_stext+0x68> (40375d98 <efuse_hal_chip_revision>)
42003eed:	0008e0        	callx8	a8
42003ef0:	0452a2        	s16i	a10, a2, 8
    out_info->cores = 2;
42003ef3:	280c      	movi.n	a8, 2
42003ef5:	0a4282        	s8i	a8, a2, 10
    out_info->features = CHIP_FEATURE_WIFI_BGN | CHIP_FEATURE_BLE;
42003ef8:	281c      	movi.n	a8, 18
42003efa:	1289      	s32i.n	a8, a2, 4
}
42003efc:	f01d      	retw.n
	...

42003f00 <memprot_ll_icache_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_icache_set_pms_area_0(const bool r, const bool w, const bool x)
{
42003f00:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003f03:	f1ba81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42003f06:	0020c0        	memw
42003f09:	0898      	l32i.n	a9, a8, 0
42003f0b:	f1b981        	l32r	a8, 420005f0 <_stext+0x5d0> (ffff8fff <_rtc_reserved_end+0x9fef8fff>)
42003f0e:	109980        	and	a9, a9, a8
    if (r) {
42003f11:	32cc      	bnez.n	a2, 42003f18 <memprot_ll_icache_set_pms_area_0+0x18>
    uint32_t permissions = 0;
42003f13:	080c      	movi.n	a8, 0
42003f15:	000046        	j	42003f1a <memprot_ll_icache_set_pms_area_0+0x1a>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003f18:	180c      	movi.n	a8, 1
    if (w) {
42003f1a:	338c      	beqz.n	a3, 42003f21 <memprot_ll_icache_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003f1c:	2a0c      	movi.n	a10, 2
42003f1e:	2088a0        	or	a8, a8, a10
    if (x) {
42003f21:	348c      	beqz.n	a4, 42003f28 <memprot_ll_icache_set_pms_area_0+0x28>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003f23:	4a0c      	movi.n	a10, 4
42003f25:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003f28:	118840        	slli	a8, a8, 12
42003f2b:	248c80        	extui	a8, a8, 12, 3
42003f2e:	118840        	slli	a8, a8, 12
42003f31:	209980        	or	a9, a9, a8
42003f34:	f1ae81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42003f37:	0020c0        	memw
42003f3a:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
    HAL_ASSERT((expected == memprot_ll_icache_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003f3c:	f01d      	retw.n
	...

42003f40 <memprot_ll_icache_set_pms_area_1>:

static inline void memprot_ll_icache_set_pms_area_1(const bool r, const bool w, const bool x)
{
42003f40:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003f43:	f1aa81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42003f46:	0020c0        	memw
42003f49:	0898      	l32i.n	a9, a8, 0
42003f4b:	f1aa81        	l32r	a8, 420005f4 <_stext+0x5d4> (fffc7fff <_rtc_reserved_end+0x9fec7fff>)
42003f4e:	109980        	and	a9, a9, a8
    if (r) {
42003f51:	32cc      	bnez.n	a2, 42003f58 <memprot_ll_icache_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42003f53:	080c      	movi.n	a8, 0
42003f55:	000046        	j	42003f5a <memprot_ll_icache_set_pms_area_1+0x1a>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003f58:	180c      	movi.n	a8, 1
    if (w) {
42003f5a:	338c      	beqz.n	a3, 42003f61 <memprot_ll_icache_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003f5c:	2a0c      	movi.n	a10, 2
42003f5e:	2088a0        	or	a8, a8, a10
    if (x) {
42003f61:	348c      	beqz.n	a4, 42003f68 <memprot_ll_icache_set_pms_area_1+0x28>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003f63:	4a0c      	movi.n	a10, 4
42003f65:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003f68:	118810        	slli	a8, a8, 15
42003f6b:	248f80        	extui	a8, a8, 15, 3
42003f6e:	118810        	slli	a8, a8, 15
42003f71:	209980        	or	a9, a9, a8
42003f74:	f19e81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42003f77:	0020c0        	memw
42003f7a:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
    HAL_ASSERT((expected == memprot_ll_icache_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
42003f7c:	f01d      	retw.n
	...

42003f80 <memprot_ll_prepare_iram0_split_line_regval>:
{
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
}

static inline void memprot_ll_prepare_iram0_split_line_regval(const uint32_t addr, uint32_t* regval)
{
42003f80:	00c136        	entry	a1, 96
    //set category bits for given split line
    uint32_t cat[7] = { MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
42003f83:	cc1c      	movi.n	a12, 28
42003f85:	f19cb1        	l32r	a11, 420005f8 <_stext+0x5d8> (3c026cd8 <__func__$1+0xc>)
42003f88:	a1ca      	add.n	a10, a1, a12
42003f8a:	f02781        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003f8d:	0008e0        	callx8	a8
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA };
    for (size_t x=0; x<7; x++) {
42003f90:	070c      	movi.n	a7, 0
42003f92:	0009c6        	j	42003fbd <memprot_ll_prepare_iram0_split_line_regval+0x3d>
        if (addr <= SRAM_RG3_LEVEL_HLIMITS(x)) {
42003f95:	cc1c      	movi.n	a12, 28
42003f97:	f199b1        	l32r	a11, 420005fc <_stext+0x5dc> (3c026cf4 <__func__$1+0x28>)
42003f9a:	01ad      	mov.n	a10, a1
42003f9c:	f02381        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42003f9f:	0008e0        	callx8	a8
42003fa2:	a08710        	addx4	a8, a7, a1
42003fa5:	0888      	l32i.n	a8, a8, 0
42003fa7:	093827        	bltu	a8, a2, 42003fb4 <memprot_ll_prepare_iram0_split_line_regval+0x34>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
42003faa:	a07710        	addx4	a7, a7, a1
42003fad:	280c      	movi.n	a8, 2
42003faf:	7789      	s32i.n	a8, a7, 28
            break;
42003fb1:	0002c6        	j	42003fc0 <memprot_ll_prepare_iram0_split_line_regval+0x40>
        } else {
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42003fb4:	a08710        	addx4	a8, a7, a1
42003fb7:	090c      	movi.n	a9, 0
42003fb9:	7899      	s32i.n	a9, a8, 28
    for (size_t x=0; x<7; x++) {
42003fbb:	771b      	addi.n	a7, a7, 1
42003fbd:	d477b6        	bltui	a7, 7, 42003f95 <memprot_ll_prepare_iram0_split_line_regval+0x15>

    //resolve split address' significant bits
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR_V);

    //write values to required configuration-register
    constrain_reg_fields_t cfg_reg_val = {
42003fc0:	81a8      	l32i.n	a10, a1, 32
42003fc2:	14a0a0        	extui	a10, a10, 0, 2
42003fc5:	11aae0        	slli	a10, a10, 2
42003fc8:	7188      	l32i.n	a8, a1, 28
42003fca:	148080        	extui	a8, a8, 0, 2
42003fcd:	9198      	l32i.n	a9, a1, 36
42003fcf:	149090        	extui	a9, a9, 0, 2
42003fd2:	1199c0        	slli	a9, a9, 4
42003fd5:	2088a0        	or	a8, a8, a10
42003fd8:	a1a8      	l32i.n	a10, a1, 40
42003fda:	14a0a0        	extui	a10, a10, 0, 2
42003fdd:	11aaa0        	slli	a10, a10, 6
42003fe0:	208890        	or	a8, a8, a9
42003fe3:	b198      	l32i.n	a9, a1, 44
42003fe5:	149090        	extui	a9, a9, 0, 2
42003fe8:	119980        	slli	a9, a9, 8
42003feb:	2088a0        	or	a8, a8, a10
42003fee:	c1a8      	l32i.n	a10, a1, 48
42003ff0:	14a0a0        	extui	a10, a10, 0, 2
42003ff3:	11aa60        	slli	a10, a10, 10
42003ff6:	208890        	or	a8, a8, a9
42003ff9:	d198      	l32i.n	a9, a1, 52
42003ffb:	149090        	extui	a9, a9, 0, 2
42003ffe:	119940        	slli	a9, a9, 12
42004001:	2088a0        	or	a8, a8, a10
42004004:	742820        	extui	a2, a2, 8, 8
42004007:	112220        	slli	a2, a2, 14
4200400a:	208890        	or	a8, a8, a9
4200400d:	208820        	or	a8, a8, a2
            .cat6 = cat[6],
            .splitaddr = conf_add,
            .reserved = 0
    };

    *regval = cfg_reg_val.val;
42004010:	0389      	s32i.n	a8, a3, 0
}
42004012:	f01d      	retw.n

42004014 <memprot_ll_set_iram0_split_line>:

// all the split lines registers have the same layout
static inline memprot_hal_err_t memprot_ll_set_iram0_split_line(const void *line_addr, const uint32_t sensitive_reg)
{
42004014:	006136        	entry	a1, 48
42004017:	20a220        	or	a10, a2, a2
    uint32_t addr = (uint32_t)line_addr;

    //sanity check
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
4200401a:	f17981        	l32r	a8, 42000600 <_stext+0x5e0> (bfc88000 <_rtc_reserved_end+0x5fb88000>)
4200401d:	808280        	add	a8, a2, a8
42004020:	f17991        	l32r	a9, 42000604 <_stext+0x5e4> (67fff <UserFrameTotalSize+0x67eff>)
42004023:	163987        	bltu	a9, a8, 4200403d <memprot_ll_set_iram0_split_line+0x29>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42004026:	748020        	extui	a8, a2, 0, 8
42004029:	015856        	bnez	a8, 42004042 <memprot_ll_set_iram0_split_line+0x2e>

    uint32_t regval;
    memprot_ll_prepare_iram0_split_line_regval(addr, &regval);
4200402c:	01bd      	mov.n	a11, a1
4200402e:	fff525        	call8	42003f80 <memprot_ll_prepare_iram0_split_line_regval>

    REG_WRITE(sensitive_reg, regval);
42004031:	0188      	l32i.n	a8, a1, 0
42004033:	0020c0        	memw
42004036:	0389      	s32i.n	a8, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((REG_READ(sensitive_reg) == regval) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
42004038:	020c      	movi.n	a2, 0
4200403a:	000186        	j	42004044 <memprot_ll_set_iram0_split_line+0x30>
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
4200403d:	220c      	movi.n	a2, 2
4200403f:	000046        	j	42004044 <memprot_ll_set_iram0_split_line+0x30>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42004042:	320c      	movi.n	a2, 3
}
42004044:	f01d      	retw.n
	...

42004048 <memprot_ll_iram0_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_iram0_set_pms_area_0(const bool r, const bool w, const bool x)
{
42004048:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
4200404b:	f16881        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
4200404e:	0020c0        	memw
42004051:	0888      	l32i.n	a8, a8, 0
42004053:	897c      	movi.n	a9, -8
42004055:	108890        	and	a8, a8, a9
    if (r) {
42004058:	42cc      	bnez.n	a2, 42004060 <memprot_ll_iram0_set_pms_area_0+0x18>
    uint32_t permissions = 0;
4200405a:	090c      	movi.n	a9, 0
4200405c:	000086        	j	42004062 <memprot_ll_iram0_set_pms_area_0+0x1a>
4200405f:	00          	.byte	00
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004060:	190c      	movi.n	a9, 1
    if (w) {
42004062:	338c      	beqz.n	a3, 42004069 <memprot_ll_iram0_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004064:	2a0c      	movi.n	a10, 2
42004066:	2099a0        	or	a9, a9, a10
    if (x) {
42004069:	348c      	beqz.n	a4, 42004070 <memprot_ll_iram0_set_pms_area_0+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
4200406b:	4a0c      	movi.n	a10, 4
4200406d:	2099a0        	or	a9, a9, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42004070:	249090        	extui	a9, a9, 0, 3
42004073:	208890        	or	a8, a8, a9
42004076:	f15d91        	l32r	a9, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004079:	0020c0        	memw
4200407c:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
4200407e:	f01d      	retw.n

42004080 <memprot_ll_iram0_set_pms_area_1>:

static inline void memprot_ll_iram0_set_pms_area_1(const bool r, const bool w, const bool x)
{
42004080:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
42004083:	f15a81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004086:	0020c0        	memw
42004089:	0898      	l32i.n	a9, a8, 0
4200408b:	c7af82        	movi	a8, -57
4200408e:	109980        	and	a9, a9, a8
    if (r) {
42004091:	32cc      	bnez.n	a2, 42004098 <memprot_ll_iram0_set_pms_area_1+0x18>
    uint32_t permissions = 0;
42004093:	080c      	movi.n	a8, 0
42004095:	000046        	j	4200409a <memprot_ll_iram0_set_pms_area_1+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004098:	180c      	movi.n	a8, 1
    if (w) {
4200409a:	338c      	beqz.n	a3, 420040a1 <memprot_ll_iram0_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
4200409c:	2a0c      	movi.n	a10, 2
4200409e:	2088a0        	or	a8, a8, a10
    if (x) {
420040a1:	348c      	beqz.n	a4, 420040a8 <memprot_ll_iram0_set_pms_area_1+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
420040a3:	4a0c      	movi.n	a10, 4
420040a5:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
420040a8:	1188d0        	slli	a8, a8, 3
420040ab:	8a3c      	movi.n	a10, 56
420040ad:	1088a0        	and	a8, a8, a10
420040b0:	209980        	or	a9, a9, a8
420040b3:	f14e81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
420040b6:	0020c0        	memw
420040b9:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
420040bb:	f01d      	retw.n
420040bd:	000000        	ill

420040c0 <memprot_ll_iram0_set_pms_area_2>:

static inline void memprot_ll_iram0_set_pms_area_2(const bool r, const bool w, const bool x)
{
420040c0:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
420040c3:	f14a81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
420040c6:	0020c0        	memw
420040c9:	0898      	l32i.n	a9, a8, 0
420040cb:	3fae82        	movi	a8, 0xfffffe3f
420040ce:	109980        	and	a9, a9, a8
    if (r) {
420040d1:	32cc      	bnez.n	a2, 420040d8 <memprot_ll_iram0_set_pms_area_2+0x18>
    uint32_t permissions = 0;
420040d3:	080c      	movi.n	a8, 0
420040d5:	000046        	j	420040da <memprot_ll_iram0_set_pms_area_2+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420040d8:	180c      	movi.n	a8, 1
    if (w) {
420040da:	338c      	beqz.n	a3, 420040e1 <memprot_ll_iram0_set_pms_area_2+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420040dc:	2a0c      	movi.n	a10, 2
420040de:	2088a0        	or	a8, a8, a10
    if (x) {
420040e1:	348c      	beqz.n	a4, 420040e8 <memprot_ll_iram0_set_pms_area_2+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
420040e3:	4a0c      	movi.n	a10, 4
420040e5:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
420040e8:	1188a0        	slli	a8, a8, 6
420040eb:	c0a1a2        	movi	a10, 0x1c0
420040ee:	1088a0        	and	a8, a8, a10
420040f1:	209980        	or	a9, a9, a8
420040f4:	f13e81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
420040f7:	0020c0        	memw
420040fa:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
420040fc:	f01d      	retw.n
	...

42004100 <memprot_ll_iram0_set_pms_area_3>:

static inline void memprot_ll_iram0_set_pms_area_3(const bool r, const bool w, const bool x)
{
42004100:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42004103:	f13a81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004106:	0020c0        	memw
42004109:	0898      	l32i.n	a9, a8, 0
4200410b:	f13f81        	l32r	a8, 42000608 <_stext+0x5e8> (fffff1ff <_rtc_reserved_end+0x9feff1ff>)
4200410e:	109980        	and	a9, a9, a8
    if (r) {
42004111:	32cc      	bnez.n	a2, 42004118 <memprot_ll_iram0_set_pms_area_3+0x18>
    uint32_t permissions = 0;
42004113:	080c      	movi.n	a8, 0
42004115:	000046        	j	4200411a <memprot_ll_iram0_set_pms_area_3+0x1a>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004118:	180c      	movi.n	a8, 1
    if (w) {
4200411a:	338c      	beqz.n	a3, 42004121 <memprot_ll_iram0_set_pms_area_3+0x21>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
4200411c:	2a0c      	movi.n	a10, 2
4200411e:	2088a0        	or	a8, a8, a10
    if (x) {
42004121:	348c      	beqz.n	a4, 42004128 <memprot_ll_iram0_set_pms_area_3+0x28>
        permissions |= SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004123:	4a0c      	movi.n	a10, 4
42004125:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42004128:	118870        	slli	a8, a8, 9
4200412b:	248980        	extui	a8, a8, 9, 3
4200412e:	118870        	slli	a8, a8, 9
42004131:	209980        	or	a9, a9, a8
42004134:	f12e81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004137:	0020c0        	memw
4200413a:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
    HAL_ASSERT((expected == memprot_ll_iram0_set_permissions(r, w, x)) && "Value not stored to required register");
#endif
}
4200413c:	f01d      	retw.n
	...

42004140 <memprot_ll_iram0_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_iram0_get_monitor_lock(const int core, bool* locked)
{
42004140:	004136        	entry	a1, 32
    switch (core) {
42004143:	628c      	beqz.n	a2, 4200414d <memprot_ll_iram0_get_monitor_lock+0xd>
42004145:	1b1226        	beqi	a2, 1, 42004164 <memprot_ll_iram0_get_monitor_lock+0x24>
42004148:	720c      	movi.n	a2, 7
4200414a:	000ac6        	j	42004179 <memprot_ll_iram0_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG) == 1;
4200414d:	f12f81        	l32r	a8, 4200060c <_stext+0x5ec> (600c10e4 <SYSTEM+0x10e4>)
42004150:	0020c0        	memw
42004153:	0888      	l32i.n	a8, a8, 0
42004155:	880b      	addi.n	a8, a8, -1
42004157:	40f880        	nsau	a8, a8
4200415a:	418580        	srli	a8, a8, 5
4200415d:	004382        	s8i	a8, a3, 0
            break;
42004160:	000546        	j	42004179 <memprot_ll_iram0_get_monitor_lock+0x39>
42004163:	2b8100        	oeq.s	b8, f1, f0
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG) == 1;
42004166:	20c0f1        	l32r	a15, 41fcc468 <_iram_bss_end+0x1c4a068>
42004169:	088800        	lsx	f8, a8, a0
4200416c:	880b      	addi.n	a8, a8, -1
4200416e:	40f880        	nsau	a8, a8
42004171:	418580        	srli	a8, a8, 5
42004174:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004177:	020c      	movi.n	a2, 0
}
42004179:	f01d      	retw.n
	...

4200417c <memprot_ll_iram0_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_en(const int core, const bool enable)
{
4200417c:	004136        	entry	a1, 32
    switch (core) {
4200417f:	628c      	beqz.n	a2, 42004189 <memprot_ll_iram0_set_monitor_en+0xd>
42004181:	301226        	beqi	a2, 1, 420041b5 <memprot_ll_iram0_set_monitor_en+0x39>
42004184:	720c      	movi.n	a2, 7
42004186:	001606        	j	420041e2 <memprot_ll_iram0_set_monitor_en+0x66>
        case PRO_CPU_NUM:
            if (enable) {
42004189:	339c      	beqz.n	a3, 420041a0 <memprot_ll_iram0_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN);
4200418b:	f12291        	l32r	a9, 42000614 <_stext+0x5f4> (600c10e8 <SYSTEM+0x10e8>)
4200418e:	0020c0        	memw
42004191:	0988      	l32i.n	a8, a9, 0
42004193:	2a0c      	movi.n	a10, 2
42004195:	2088a0        	or	a8, a8, a10
42004198:	0020c0        	memw
4200419b:	0989      	s32i.n	a8, a9, 0
4200419d:	001046        	j	420041e2 <memprot_ll_iram0_set_monitor_en+0x66>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN);
420041a0:	f11d91        	l32r	a9, 42000614 <_stext+0x5f4> (600c10e8 <SYSTEM+0x10e8>)
420041a3:	0020c0        	memw
420041a6:	0988      	l32i.n	a8, a9, 0
420041a8:	da7c      	movi.n	a10, -3
420041aa:	1088a0        	and	a8, a8, a10
420041ad:	0020c0        	memw
420041b0:	0989      	s32i.n	a8, a9, 0
420041b2:	000b06        	j	420041e2 <memprot_ll_iram0_set_monitor_en+0x66>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
420041b5:	539c      	beqz.n	a3, 420041ce <memprot_ll_iram0_set_monitor_en+0x52>
                REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN);
420041b7:	f11891        	l32r	a9, 42000618 <_stext+0x5f8> (600c10f4 <SYSTEM+0x10f4>)
420041ba:	0020c0        	memw
420041bd:	0988      	l32i.n	a8, a9, 0
420041bf:	2a0c      	movi.n	a10, 2
420041c1:	2088a0        	or	a8, a8, a10
420041c4:	0020c0        	memw
420041c7:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420041c9:	020c      	movi.n	a2, 0
420041cb:	0004c6        	j	420041e2 <memprot_ll_iram0_set_monitor_en+0x66>
                REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN);
420041ce:	f11291        	l32r	a9, 42000618 <_stext+0x5f8> (600c10f4 <SYSTEM+0x10f4>)
420041d1:	0020c0        	memw
420041d4:	0988      	l32i.n	a8, a9, 0
420041d6:	da7c      	movi.n	a10, -3
420041d8:	1088a0        	and	a8, a8, a10
420041db:	0020c0        	memw
420041de:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
420041e0:	020c      	movi.n	a2, 0
}
420041e2:	f01d      	retw.n

420041e4 <memprot_ll_iram0_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_iram0_get_monitor_en(const int core, bool* enabled)
{
420041e4:	004136        	entry	a1, 32
    switch (core) {
420041e7:	628c      	beqz.n	a2, 420041f1 <memprot_ll_iram0_get_monitor_en+0xd>
420041e9:	171226        	beqi	a2, 1, 42004204 <memprot_ll_iram0_get_monitor_en+0x20>
420041ec:	720c      	movi.n	a2, 7
420041ee:	000886        	j	42004214 <memprot_ll_iram0_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
420041f1:	f10881        	l32r	a8, 42000614 <_stext+0x5f4> (600c10e8 <SYSTEM+0x10e8>)
420041f4:	0020c0        	memw
420041f7:	0888      	l32i.n	a8, a8, 0
420041f9:	048180        	extui	a8, a8, 1, 1
420041fc:	004382        	s8i	a8, a3, 0
            break;
420041ff:	000446        	j	42004214 <memprot_ll_iram0_get_monitor_en+0x30>
42004202:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42004205:	c0f105        	call0	41fc5118 <_iram_bss_end+0x1c42d18>
42004208:	20          	.byte	0x20
42004209:	088800        	lsx	f8, a8, a0
4200420c:	048180        	extui	a8, a8, 1, 1
4200420f:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004212:	020c      	movi.n	a2, 0
}
42004214:	f01d      	retw.n
	...

42004218 <memprot_ll_iram0_set_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_intrclr(const int core)
{
42004218:	004136        	entry	a1, 32
    switch (core) {
4200421b:	628c      	beqz.n	a2, 42004225 <memprot_ll_iram0_set_monitor_intrclr+0xd>
4200421d:	1b1226        	beqi	a2, 1, 4200423c <memprot_ll_iram0_set_monitor_intrclr+0x24>
42004220:	720c      	movi.n	a2, 7
42004222:	000a86        	j	42004250 <memprot_ll_iram0_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42004225:	f0fb91        	l32r	a9, 42000614 <_stext+0x5f4> (600c10e8 <SYSTEM+0x10e8>)
42004228:	0020c0        	memw
4200422b:	0988      	l32i.n	a8, a9, 0
4200422d:	1a0c      	movi.n	a10, 1
4200422f:	2088a0        	or	a8, a8, a10
42004232:	0020c0        	memw
42004235:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
42004237:	000546        	j	42004250 <memprot_ll_iram0_set_monitor_intrclr+0x38>
4200423a:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
4200423d:	c0f0f7        	bbsi	a0, 31, 42004201 <memprot_ll_iram0_get_monitor_en+0x1d>
42004240:	20          	.byte	0x20
42004241:	098800        	l32e	a0, a8, -32
42004244:	1a0c      	movi.n	a10, 1
42004246:	2088a0        	or	a8, a8, a10
42004249:	0020c0        	memw
4200424c:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200424e:	020c      	movi.n	a2, 0
}
42004250:	f01d      	retw.n
	...

42004254 <memprot_ll_iram0_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_iram0_reset_monitor_intrclr(const int core)
{
42004254:	004136        	entry	a1, 32
    switch (core) {
42004257:	628c      	beqz.n	a2, 42004261 <memprot_ll_iram0_reset_monitor_intrclr+0xd>
42004259:	1b1226        	beqi	a2, 1, 42004278 <memprot_ll_iram0_reset_monitor_intrclr+0x24>
4200425c:	720c      	movi.n	a2, 7
4200425e:	000a86        	j	4200428c <memprot_ll_iram0_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42004261:	f0ec91        	l32r	a9, 42000614 <_stext+0x5f4> (600c10e8 <SYSTEM+0x10e8>)
42004264:	0020c0        	memw
42004267:	0988      	l32i.n	a8, a9, 0
42004269:	ea7c      	movi.n	a10, -2
4200426b:	1088a0        	and	a8, a8, a10
4200426e:	0020c0        	memw
42004271:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
42004273:	000546        	j	4200428c <memprot_ll_iram0_reset_monitor_intrclr+0x38>
42004276:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
42004279:	f0e8      	l32i.n	a14, a0, 60
4200427b:	0020c0        	memw
4200427e:	0988      	l32i.n	a8, a9, 0
42004280:	ea7c      	movi.n	a10, -2
42004282:	1088a0        	and	a8, a8, a10
42004285:	0020c0        	memw
42004288:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200428a:	020c      	movi.n	a2, 0
}
4200428c:	f01d      	retw.n
	...

42004290 <memprot_ll_get_pif_constraint_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_get_pif_constraint_lock(const int core, bool* locked)
{
42004290:	004136        	entry	a1, 32
    switch (core) {
42004293:	628c      	beqz.n	a2, 4200429d <memprot_ll_get_pif_constraint_lock+0xd>
42004295:	1b1226        	beqi	a2, 1, 420042b4 <memprot_ll_get_pif_constraint_lock+0x24>
42004298:	720c      	movi.n	a2, 7
4200429a:	000ac6        	j	420042c9 <memprot_ll_get_pif_constraint_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG) == 1;
4200429d:	f0df81        	l32r	a8, 4200061c <_stext+0x5fc> (600c1124 <SYSTEM+0x1124>)
420042a0:	0020c0        	memw
420042a3:	0888      	l32i.n	a8, a8, 0
420042a5:	880b      	addi.n	a8, a8, -1
420042a7:	40f880        	nsau	a8, a8
420042aa:	418580        	srli	a8, a8, 5
420042ad:	004382        	s8i	a8, a3, 0
            break;
420042b0:	000546        	j	420042c9 <memprot_ll_get_pif_constraint_lock+0x39>
420042b3:	db8100        	movt.s	f8, f1, b0
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG) == 1;
420042b6:	20c0f0        	or	a12, a0, a15
420042b9:	088800        	lsx	f8, a8, a0
420042bc:	880b      	addi.n	a8, a8, -1
420042be:	40f880        	nsau	a8, a8
420042c1:	418580        	srli	a8, a8, 5
420042c4:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420042c7:	020c      	movi.n	a2, 0
}
420042c9:	f01d      	retw.n
	...

420042cc <memprot_ll_set_rtcfast_split_line>:
/* ********************************
 * IRAM0 RTCFAST - SPLIT LINES
 */

static inline memprot_hal_err_t memprot_ll_set_rtcfast_split_line(const int core, const void *line_addr, const memprot_hal_world_t world)
{
420042cc:	004136        	entry	a1, 32
    uint32_t addr = (uint32_t)line_addr;

    if (addr < SOC_RTC_IRAM_LOW || addr >= SOC_RTC_IRAM_HIGH) {
420042cf:	f09881        	l32r	a8, 42000530 <_stext+0x510> (9ff02000 <_rtc_reserved_end+0x3fe02000>)
420042d2:	838a      	add.n	a8, a3, a8
420042d4:	f09891        	l32r	a9, 42000534 <_stext+0x514> (1fff <UserFrameTotalSize+0x1eff>)
420042d7:	523987        	bltu	a9, a8, 4200432d <memprot_ll_set_rtcfast_split_line+0x61>
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
    }

    if (addr % 0x4 != 0) {
420042da:	148030        	extui	a8, a3, 0, 2
420042dd:	051856        	bnez	a8, 42004332 <memprot_ll_set_rtcfast_split_line+0x66>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
    }

    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
420042e0:	5422f6        	bgeui	a2, 2, 42004338 <memprot_ll_set_rtcfast_split_line+0x6c>
    }

    uint32_t mask;
    uint32_t val;

    switch (world) {
420042e3:	091426        	beqi	a4, 1, 420042f0 <memprot_ll_set_rtcfast_split_line+0x24>
420042e6:	53b466        	bnei	a4, 16, 4200433d <memprot_ll_set_rtcfast_split_line+0x71>
    case MEMP_HAL_WORLD_0:
        mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_M;
        val = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_V : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0_V;
        break;
    case MEMP_HAL_WORLD_1:
        mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1_M;
420042e9:	f0cea1        	l32r	a10, 42000624 <_stext+0x604> (3ff800 <UserFrameTotalSize+0x3ff700>)
420042ec:	0000c6        	j	420042f3 <memprot_ll_set_rtcfast_split_line+0x27>
420042ef:	a7a200        	ee.stf.64.xp	f10, f10, a0, a2
    switch (world) {
420042f2:	9152ccff 	ee.stf.128.ip	f2, f5, f12, f5, a15, -64
        break;
    default:
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_9_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_9_REG;
420042f6:	f0cc      	bnez.n	a0, 42004309 <memprot_ll_set_rtcfast_split_line+0x3d>
420042f8:	0000c6        	j	420042ff <memprot_ll_set_rtcfast_split_line+0x33>
420042fb:	00          	.byte	00
420042fc:	f0cc91        	l32r	a9, 4200062c <_stext+0x60c> (600c11f4 <SYSTEM+0x11f4>)

    CLEAR_PERI_REG_MASK(reg, mask);
420042ff:	0020c0        	memw
42004302:	09b8      	l32i.n	a11, a9, 0
42004304:	108ab0        	and	a8, a10, a11
42004307:	3088b0        	xor	a8, a8, a11
4200430a:	0020c0        	memw
4200430d:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((GET_PERI_REG_MASK(reg, mask) == 0) && "Value not stored to required register");
#endif
    REG_SET_BITS(reg, mask, (addr >> 2) & val);
4200430f:	0020c0        	memw
42004312:	09b8      	l32i.n	a11, a9, 0
42004314:	a43230        	extui	a3, a3, 2, 11
42004317:	1083b0        	and	a8, a3, a11
4200431a:	3088b0        	xor	a8, a8, a11
4200431d:	1033a0        	and	a3, a3, a10
42004320:	208830        	or	a8, a8, a3
42004323:	0020c0        	memw
42004326:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_READ(reg) & mask;
    HAL_ASSERT((expected == ((addr >> 2) & val)) && "Value not stored to required register");
#endif
    return MEMP_HAL_OK;
42004328:	020c      	movi.n	a2, 0
4200432a:	000446        	j	4200433f <memprot_ll_set_rtcfast_split_line+0x73>
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
4200432d:	220c      	movi.n	a2, 2
4200432f:	000306        	j	4200433f <memprot_ll_set_rtcfast_split_line+0x73>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
42004332:	320c      	movi.n	a2, 3
42004334:	0001c6        	j	4200433f <memprot_ll_set_rtcfast_split_line+0x73>
42004337:	720c00        	salt	a0, a12, a0
        return MEMP_HAL_ERR_CORE_INVALID;
4200433a:	000046        	j	4200433f <memprot_ll_set_rtcfast_split_line+0x73>
    switch (world) {
4200433d:	620c      	movi.n	a2, 6
}
4200433f:	f01d      	retw.n
42004341:	000000        	ill

42004344 <memprot_ll_rtcfast_set_pms_area>:

    return permissions;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_set_pms_area(const int core, const bool r, const bool w, const bool x, const memprot_hal_world_t world, const memprot_hal_area_t area)
{
42004344:	004136        	entry	a1, 32
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42004347:	0222b6        	bltui	a2, 2, 4200434d <memprot_ll_rtcfast_set_pms_area+0x9>
4200434a:	003386        	j	4200441c <memprot_ll_rtcfast_set_pms_area+0xd8>
    }

    uint32_t bits;
    uint32_t mask;

    switch (world) {
4200434d:	071626        	beqi	a6, 1, 42004358 <memprot_ll_rtcfast_set_pms_area+0x14>
42004350:	48b626        	beqi	a6, 16, 4200439c <memprot_ll_rtcfast_set_pms_area+0x58>
42004353:	620c      	movi.n	a2, 6
42004355:	003146        	j	4200441e <memprot_ll_rtcfast_set_pms_area+0xda>
    case MEMP_HAL_WORLD_0: {
        switch (area) {
42004358:	081726        	beqi	a7, 1, 42004364 <memprot_ll_rtcfast_set_pms_area+0x20>
4200435b:	232726        	beqi	a7, 2, 42004382 <memprot_ll_rtcfast_set_pms_area+0x3e>
4200435e:	520c      	movi.n	a2, 5
42004360:	002e86        	j	4200441e <memprot_ll_rtcfast_set_pms_area+0xda>
42004363:	43cc00        	min	a12, a12, a0
    uint32_t permissions = 0;
42004366:	070c      	movi.n	a7, 0
42004368:	000086        	j	4200436e <memprot_ll_rtcfast_set_pms_area+0x2a>
4200436b:	270c00        	ee.stf.64.xp	f0, f2, a0, a12
    if (w) {
4200436e:	348c      	beqz.n	a4, 42004375 <memprot_ll_rtcfast_set_pms_area+0x31>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004370:	180c      	movi.n	a8, 1
42004372:	207780        	or	a7, a7, a8
    if (x) {
42004375:	06c516        	beqz	a5, 420043e5 <memprot_ll_rtcfast_set_pms_area+0xa1>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42004378:	480c      	movi.n	a8, 4
4200437a:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_LOW:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_S);
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M;
4200437d:	7b0c      	movi.n	a11, 7
4200437f:	001906        	j	420043e7 <memprot_ll_rtcfast_set_pms_area+0xa3>
    if (r) {
42004382:	03cc      	bnez.n	a3, 42004386 <memprot_ll_rtcfast_set_pms_area+0x42>
    uint32_t permissions = 0;
42004384:	070c      	movi.n	a7, 0
    if (w) {
42004386:	348c      	beqz.n	a4, 4200438d <memprot_ll_rtcfast_set_pms_area+0x49>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42004388:	180c      	movi.n	a8, 1
4200438a:	207780        	or	a7, a7, a8
    if (x) {
4200438d:	358c      	beqz.n	a5, 42004394 <memprot_ll_rtcfast_set_pms_area+0x50>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
4200438f:	480c      	movi.n	a8, 4
42004391:	207780        	or	a7, a7, a8
            break;
        case MEMP_HAL_AREA_HIGH:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S);
42004394:	1177d0        	slli	a7, a7, 3
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_M;
42004397:	8b3c      	movi.n	a11, 56
            break;
42004399:	001286        	j	420043e7 <memprot_ll_rtcfast_set_pms_area+0xa3>
        default:
            return MEMP_HAL_ERR_AREA_INVALID;
        }
    } break;
    case MEMP_HAL_WORLD_1: {
        switch (area) {
4200439c:	081726        	beqi	a7, 1, 420043a8 <memprot_ll_rtcfast_set_pms_area+0x64>
4200439f:	262726        	beqi	a7, 2, 420043c9 <memprot_ll_rtcfast_set_pms_area+0x85>
420043a2:	520c      	movi.n	a2, 5
420043a4:	001d86        	j	4200441e <memprot_ll_rtcfast_set_pms_area+0xda>
420043a7:	43cc00        	min	a12, a12, a0
    uint32_t permissions = 0;
420043aa:	070c      	movi.n	a7, 0
420043ac:	000086        	j	420043b2 <memprot_ll_rtcfast_set_pms_area+0x6e>
420043af:	270c00        	ee.stf.64.xp	f0, f2, a0, a12
    if (w) {
420043b2:	348c      	beqz.n	a4, 420043b9 <memprot_ll_rtcfast_set_pms_area+0x75>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
420043b4:	180c      	movi.n	a8, 1
420043b6:	207780        	or	a7, a7, a8
    if (x) {
420043b9:	358c      	beqz.n	a5, 420043c0 <memprot_ll_rtcfast_set_pms_area+0x7c>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
420043bb:	480c      	movi.n	a8, 4
420043bd:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_LOW:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_S);
420043c0:	1177a0        	slli	a7, a7, 6
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L_M;
420043c3:	c0a1b2        	movi	a11, 0x1c0
            break;
420043c6:	000746        	j	420043e7 <memprot_ll_rtcfast_set_pms_area+0xa3>
    if (r) {
420043c9:	13cc      	bnez.n	a3, 420043ce <memprot_ll_rtcfast_set_pms_area+0x8a>
    uint32_t permissions = 0;
420043cb:	00a072        	movi	a7, 0
    if (w) {
420043ce:	348c      	beqz.n	a4, 420043d5 <memprot_ll_rtcfast_set_pms_area+0x91>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
420043d0:	180c      	movi.n	a8, 1
420043d2:	207780        	or	a7, a7, a8
    if (x) {
420043d5:	358c      	beqz.n	a5, 420043dc <memprot_ll_rtcfast_set_pms_area+0x98>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
420043d7:	480c      	movi.n	a8, 4
420043d9:	207780        	or	a7, a7, a8
        case MEMP_HAL_AREA_HIGH:
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_S);
420043dc:	117770        	slli	a7, a7, 9
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H_M;
420043df:	f094b1        	l32r	a11, 42000630 <_stext+0x610> (e00 <UserFrameTotalSize+0xd00>)
            break;
420043e2:	000046        	j	420043e7 <memprot_ll_rtcfast_set_pms_area+0xa3>
            mask = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L_M;
420043e5:	7b0c      	movi.n	a11, 7
    } break;
    default:
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG;
420043e7:	52cc      	bnez.n	a2, 420043f0 <memprot_ll_rtcfast_set_pms_area+0xac>
420043e9:	f09281        	l32r	a8, 42000634 <_stext+0x614> (600c114c <SYSTEM+0x114c>)
420043ec:	0000c6        	j	420043f3 <memprot_ll_rtcfast_set_pms_area+0xaf>
420043ef:	00          	.byte	00
420043f0:	f09281        	l32r	a8, 42000638 <_stext+0x618> (600c11f8 <SYSTEM+0x11f8>)

    CLEAR_PERI_REG_MASK(reg, mask);
420043f3:	0020c0        	memw
420043f6:	08a8      	l32i.n	a10, a8, 0
420043f8:	109ba0        	and	a9, a11, a10
420043fb:	3099a0        	xor	a9, a9, a10
420043fe:	0020c0        	memw
42004401:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((GET_PERI_REG_MASK(reg, mask) == 0) && "Value not stored to required register");
#endif
    REG_SET_BITS(reg, bits, mask);
42004403:	0020c0        	memw
42004406:	0898      	l32i.n	a9, a8, 0
42004408:	307970        	xor	a7, a9, a7
4200440b:	1077b0        	and	a7, a7, a11
4200440e:	307790        	xor	a7, a7, a9
42004411:	0020c0        	memw
42004414:	0879      	s32i.n	a7, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_READ(reg) & mask;
    HAL_ASSERT((expected == bits) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
42004416:	020c      	movi.n	a2, 0
42004418:	000086        	j	4200441e <memprot_ll_rtcfast_set_pms_area+0xda>
4200441b:	720c00        	salt	a0, a12, a0
}
4200441e:	f01d      	retw.n

42004420 <memprot_ll_rtcfast_get_pms_area>:
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_get_pms_area(const int core, bool *r, bool *w, bool *x, const memprot_hal_world_t world, const memprot_hal_area_t area)
{
42004420:	004136        	entry	a1, 32
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42004423:	0222b6        	bltui	a2, 2, 42004429 <memprot_ll_rtcfast_get_pms_area+0x9>
42004426:	002d06        	j	420044de <memprot_ll_rtcfast_get_pms_area+0xbe>
        return MEMP_HAL_ERR_CORE_INVALID;
    }

    uint32_t permissions = 0;

    switch (world) {
42004429:	071626        	beqi	a6, 1, 42004434 <memprot_ll_rtcfast_get_pms_area+0x14>
4200442c:	50b626        	beqi	a6, 16, 42004480 <memprot_ll_rtcfast_get_pms_area+0x60>
4200442f:	620c      	movi.n	a2, 6
42004431:	002ac6        	j	420044e0 <memprot_ll_rtcfast_get_pms_area+0xc0>
    case MEMP_HAL_WORLD_0: {
        switch (area) {
42004434:	081726        	beqi	a7, 1, 42004440 <memprot_ll_rtcfast_get_pms_area+0x20>
42004437:	232726        	beqi	a7, 2, 4200445e <memprot_ll_rtcfast_get_pms_area+0x3e>
4200443a:	520c      	movi.n	a2, 5
4200443c:	002806        	j	420044e0 <memprot_ll_rtcfast_get_pms_area+0xc0>
4200443f:	c2cc00        	quou	a12, a12, a0
        case MEMP_HAL_AREA_LOW:
            if (core == PRO_CPU_NUM) {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L);
42004442:	f07c81        	l32r	a8, 42000634 <_stext+0x614> (600c114c <SYSTEM+0x114c>)
42004445:	0020c0        	memw
42004448:	0888      	l32i.n	a8, a8, 0
4200444a:	248080        	extui	a8, a8, 0, 3
4200444d:	001d86        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
42004450:	f07a81        	l32r	a8, 42000638 <_stext+0x618> (600c11f8 <SYSTEM+0x11f8>)
42004453:	0020c0        	memw
42004456:	0888      	l32i.n	a8, a8, 0
42004458:	248680        	extui	a8, a8, 6, 3
4200445b:	001a06        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
            }
            break;
        case MEMP_HAL_AREA_HIGH:
            if (core == PRO_CPU_NUM) {
4200445e:	e2cc      	bnez.n	a2, 42004470 <memprot_ll_rtcfast_get_pms_area+0x50>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42004460:	f07581        	l32r	a8, 42000634 <_stext+0x614> (600c114c <SYSTEM+0x114c>)
42004463:	0020c0        	memw
42004466:	0888      	l32i.n	a8, a8, 0
42004468:	248380        	extui	a8, a8, 3, 3
4200446b:	001606        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200446e:	810000        	src	a0, a0, a0
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42004471:	c0f072        	s32ri	a7, a0, 0x300
42004474:	20          	.byte	0x20
42004475:	088800        	lsx	f8, a8, a0
42004478:	248380        	extui	a8, a8, 3, 3
4200447b:	001206        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200447e:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
        default:
            return MEMP_HAL_ERR_AREA_INVALID;
        }
    } break;
    case MEMP_HAL_WORLD_1: {
        switch (area) {
42004481:	260717        	bnone	a7, a1, 420044ab <memprot_ll_rtcfast_get_pms_area+0x8b>
42004484:	0c2327        	blt	a3, a2, 42004494 <memprot_ll_rtcfast_get_pms_area+0x74>
42004487:	150652        	l8ui	a5, a6, 21
4200448a:	d2cc00        	quos	a12, a12, a0
        case MEMP_HAL_AREA_LOW:
            if (core == PRO_CPU_NUM) {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
4200448d:	f06981        	l32r	a8, 42000634 <_stext+0x614> (600c114c <SYSTEM+0x114c>)
42004490:	0020c0        	memw
42004493:	0888      	l32i.n	a8, a8, 0
42004495:	248680        	extui	a8, a8, 6, 3
42004498:	000ac6        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
4200449b:	678100        	ee.stf.64.xp	f8, f6, a0, a1
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
4200449e:	20c0f0        	or	a12, a0, a15
420044a1:	088800        	lsx	f8, a8, a0
420044a4:	248680        	extui	a8, a8, 6, 3
420044a7:	000706        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
            }
            break;
        case MEMP_HAL_AREA_HIGH:
            if (core == PRO_CPU_NUM) {
420044aa:	e2cc      	bnez.n	a2, 420044bc <memprot_ll_rtcfast_get_pms_area+0x9c>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H);
420044ac:	f06281        	l32r	a8, 42000634 <_stext+0x614> (600c114c <SYSTEM+0x114c>)
420044af:	0020c0        	memw
420044b2:	0888      	l32i.n	a8, a8, 0
420044b4:	248980        	extui	a8, a8, 9, 3
420044b7:	000306        	j	420044c7 <memprot_ll_rtcfast_get_pms_area+0xa7>
420044ba:	810000        	src	a0, a0, a0
            } else {
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H);
420044bd:	20c0f05f 	ee.vmulas.s8.accx.ld.ip.qup	q0, a5, 0, q7, q7, q4, q0
420044c1:	088800        	lsx	f8, a8, a0
420044c4:	248980        	extui	a8, a8, 9, 3
    *r = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_R;
420044c7:	049180        	extui	a9, a8, 1, 1
420044ca:	004392        	s8i	a9, a3, 0
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
420044cd:	049080        	extui	a9, a8, 0, 1
420044d0:	004492        	s8i	a9, a4, 0
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
420044d3:	418280        	srli	a8, a8, 2
420044d6:	004582        	s8i	a8, a5, 0
        return MEMP_HAL_ERR_WORLD_INVALID;
    }

    memprot_ll_rtcfast_get_permissions(permissions, r, w, x);

    return MEMP_HAL_OK;
420044d9:	020c      	movi.n	a2, 0
420044db:	000046        	j	420044e0 <memprot_ll_rtcfast_get_pms_area+0xc0>
        return MEMP_HAL_ERR_CORE_INVALID;
420044de:	720c      	movi.n	a2, 7
}
420044e0:	f01d      	retw.n
	...

420044e4 <memprot_ll_rtcfast_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_get_monitor_lock(const int core, bool* locked)
{
420044e4:	004136        	entry	a1, 32
    switch (core) {
420044e7:	628c      	beqz.n	a2, 420044f1 <memprot_ll_rtcfast_get_monitor_lock+0xd>
420044e9:	1b1226        	beqi	a2, 1, 42004508 <memprot_ll_rtcfast_get_monitor_lock+0x24>
420044ec:	720c      	movi.n	a2, 7
420044ee:	000ac6        	j	4200451d <memprot_ll_rtcfast_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG) == 1;
420044f1:	f05281        	l32r	a8, 4200063c <_stext+0x61c> (600c119c <SYSTEM+0x119c>)
420044f4:	0020c0        	memw
420044f7:	0888      	l32i.n	a8, a8, 0
420044f9:	880b      	addi.n	a8, a8, -1
420044fb:	40f880        	nsau	a8, a8
420044fe:	418580        	srli	a8, a8, 5
42004501:	004382        	s8i	a8, a3, 0
            break;
42004504:	000546        	j	4200451d <memprot_ll_rtcfast_get_monitor_lock+0x39>
42004507:	00          	.byte	00
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG) == 1;
42004508:	f04e81        	l32r	a8, 42000640 <_stext+0x620> (600c1248 <SYSTEM+0x1248>)
4200450b:	0020c0        	memw
4200450e:	0888      	l32i.n	a8, a8, 0
42004510:	880b      	addi.n	a8, a8, -1
42004512:	40f880        	nsau	a8, a8
42004515:	418580        	srli	a8, a8, 5
42004518:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200451b:	020c      	movi.n	a2, 0
}
4200451d:	f01d      	retw.n
	...

42004520 <memprot_ll_rtcfast_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_rtcfast_set_monitor_en(const int core, const bool enable)
{
42004520:	004136        	entry	a1, 32
    switch (core) {
42004523:	628c      	beqz.n	a2, 4200452d <memprot_ll_rtcfast_set_monitor_en+0xd>
42004525:	301226        	beqi	a2, 1, 42004559 <memprot_ll_rtcfast_set_monitor_en+0x39>
42004528:	720c      	movi.n	a2, 7
4200452a:	001686        	j	42004588 <memprot_ll_rtcfast_set_monitor_en+0x68>
        case PRO_CPU_NUM:
            if (enable) {
4200452d:	339c      	beqz.n	a3, 42004544 <memprot_ll_rtcfast_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN);
4200452f:	f04591        	l32r	a9, 42000644 <_stext+0x624> (600c11a0 <SYSTEM+0x11a0>)
42004532:	0020c0        	memw
42004535:	0988      	l32i.n	a8, a9, 0
42004537:	2a0c      	movi.n	a10, 2
42004539:	2088a0        	or	a8, a8, a10
4200453c:	0020c0        	memw
4200453f:	0989      	s32i.n	a8, a9, 0
42004541:	0010c6        	j	42004588 <memprot_ll_rtcfast_set_monitor_en+0x68>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN);
42004544:	f04091        	l32r	a9, 42000644 <_stext+0x624> (600c11a0 <SYSTEM+0x11a0>)
42004547:	0020c0        	memw
4200454a:	0988      	l32i.n	a8, a9, 0
4200454c:	da7c      	movi.n	a10, -3
4200454e:	1088a0        	and	a8, a8, a10
42004551:	0020c0        	memw
42004554:	0989      	s32i.n	a8, a9, 0
42004556:	000b86        	j	42004588 <memprot_ll_rtcfast_set_monitor_en+0x68>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42004559:	739c      	beqz.n	a3, 42004574 <memprot_ll_rtcfast_set_monitor_en+0x54>
                REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
4200455b:	f03b91        	l32r	a9, 42000648 <_stext+0x628> (600c124c <SYSTEM+0x124c>)
4200455e:	0020c0        	memw
42004561:	0988      	l32i.n	a8, a9, 0
42004563:	2a0c      	movi.n	a10, 2
42004565:	2088a0        	or	a8, a8, a10
42004568:	0020c0        	memw
4200456b:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200456d:	020c      	movi.n	a2, 0
4200456f:	000546        	j	42004588 <memprot_ll_rtcfast_set_monitor_en+0x68>
42004572:	910000        	srl	a0, a0
                REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
42004575:	c0f035        	call12	41fc5478 <_iram_bss_end+0x1c43078>
42004578:	20          	.byte	0x20
42004579:	098800        	l32e	a0, a8, -32
4200457c:	da7c      	movi.n	a10, -3
4200457e:	1088a0        	and	a8, a8, a10
42004581:	0020c0        	memw
42004584:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42004586:	020c      	movi.n	a2, 0
}
42004588:	f01d      	retw.n
	...

4200458c <memprot_ll_rtcfast_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_rtcfast_get_monitor_en(const int core, bool* enabled)
{
4200458c:	004136        	entry	a1, 32
    switch (core) {
4200458f:	628c      	beqz.n	a2, 42004599 <memprot_ll_rtcfast_get_monitor_en+0xd>
42004591:	171226        	beqi	a2, 1, 420045ac <memprot_ll_rtcfast_get_monitor_en+0x20>
42004594:	720c      	movi.n	a2, 7
42004596:	000886        	j	420045bc <memprot_ll_rtcfast_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42004599:	f02a81        	l32r	a8, 42000644 <_stext+0x624> (600c11a0 <SYSTEM+0x11a0>)
4200459c:	0020c0        	memw
4200459f:	0888      	l32i.n	a8, a8, 0
420045a1:	048180        	extui	a8, a8, 1, 1
420045a4:	004382        	s8i	a8, a3, 0
            break;
420045a7:	000446        	j	420045bc <memprot_ll_rtcfast_get_monitor_en+0x30>
420045aa:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
420045ad:	c0f027        	bbsi	a0, 18, 42004571 <memprot_ll_rtcfast_set_monitor_en+0x51>
420045b0:	20          	.byte	0x20
420045b1:	088800        	lsx	f8, a8, a0
420045b4:	048180        	extui	a8, a8, 1, 1
420045b7:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420045ba:	020c      	movi.n	a2, 0
}
420045bc:	f01d      	retw.n
	...

420045c0 <memprot_ll_rtcfast_set_monitor_intrclr>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_set_monitor_intrclr(const int core)
{
420045c0:	004136        	entry	a1, 32
    switch (core) {
420045c3:	628c      	beqz.n	a2, 420045cd <memprot_ll_rtcfast_set_monitor_intrclr+0xd>
420045c5:	1b1226        	beqi	a2, 1, 420045e4 <memprot_ll_rtcfast_set_monitor_intrclr+0x24>
420045c8:	720c      	movi.n	a2, 7
420045ca:	000a86        	j	420045f8 <memprot_ll_rtcfast_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
420045cd:	f01d91        	l32r	a9, 42000644 <_stext+0x624> (600c11a0 <SYSTEM+0x11a0>)
420045d0:	0020c0        	memw
420045d3:	0988      	l32i.n	a8, a9, 0
420045d5:	1a0c      	movi.n	a10, 1
420045d7:	2088a0        	or	a8, a8, a10
420045da:	0020c0        	memw
420045dd:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
420045df:	000546        	j	420045f8 <memprot_ll_rtcfast_set_monitor_intrclr+0x38>
420045e2:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
420045e5:	f019      	s32i.n	a1, a0, 60
420045e7:	0020c0        	memw
420045ea:	0988      	l32i.n	a8, a9, 0
420045ec:	1a0c      	movi.n	a10, 1
420045ee:	2088a0        	or	a8, a8, a10
420045f1:	0020c0        	memw
420045f4:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420045f6:	020c      	movi.n	a2, 0
}
420045f8:	f01d      	retw.n
	...

420045fc <memprot_ll_rtcfast_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_rtcfast_reset_monitor_intrclr(const int core)
{
420045fc:	004136        	entry	a1, 32
    switch (core) {
420045ff:	628c      	beqz.n	a2, 42004609 <memprot_ll_rtcfast_reset_monitor_intrclr+0xd>
42004601:	1b1226        	beqi	a2, 1, 42004620 <memprot_ll_rtcfast_reset_monitor_intrclr+0x24>
42004604:	720c      	movi.n	a2, 7
42004606:	000a86        	j	42004634 <memprot_ll_rtcfast_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
42004609:	f00e91        	l32r	a9, 42000644 <_stext+0x624> (600c11a0 <SYSTEM+0x11a0>)
4200460c:	0020c0        	memw
4200460f:	0988      	l32i.n	a8, a9, 0
42004611:	ea7c      	movi.n	a10, -2
42004613:	1088a0        	and	a8, a8, a10
42004616:	0020c0        	memw
42004619:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
4200461b:	000546        	j	42004634 <memprot_ll_rtcfast_reset_monitor_intrclr+0x38>
4200461e:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
42004621:	f00a      	add.n	a15, a0, a0
42004623:	0020c0        	memw
42004626:	0988      	l32i.n	a8, a9, 0
42004628:	ea7c      	movi.n	a10, -2
4200462a:	1088a0        	and	a8, a8, a10
4200462d:	0020c0        	memw
42004630:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004632:	020c      	movi.n	a2, 0
}
42004634:	f01d      	retw.n
	...

42004638 <memprot_ll_prepare_dram0_split_line_regval>:
{
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
}

static inline void memprot_ll_prepare_dram0_split_line_regval(const uint32_t addr, uint32_t* regval)
{
42004638:	00c136        	entry	a1, 96
    //set category bits for given split line
    uint32_t cat[7] = { MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
4200463b:	cc1c      	movi.n	a12, 28
4200463d:	efeeb1        	l32r	a11, 420005f8 <_stext+0x5d8> (3c026cd8 <__func__$1+0xc>)
42004640:	a1ca      	add.n	a10, a1, a12
42004642:	ee7981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42004645:	0008e0        	callx8	a8
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA,
                        MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA };

    for (size_t x=0; x<7; x++) {
42004648:	070c      	movi.n	a7, 0
4200464a:	000b06        	j	4200467a <memprot_ll_prepare_dram0_split_line_regval+0x42>
        if (addr <= MAP_IRAM_TO_DRAM(SRAM_RG3_LEVEL_HLIMITS(x))) {
4200464d:	cc1c      	movi.n	a12, 28
4200464f:	efebb1        	l32r	a11, 420005fc <_stext+0x5dc> (3c026cf4 <__func__$1+0x28>)
42004652:	01ad      	mov.n	a10, a1
42004654:	ee7581        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42004657:	0008e0        	callx8	a8
4200465a:	a08710        	addx4	a8, a7, a1
4200465d:	0888      	l32i.n	a8, a8, 0
4200465f:	effb91        	l32r	a9, 4200064c <_stext+0x62c> (ff910000 <_rtc_reserved_end+0x9f810000>)
42004662:	889a      	add.n	a8, a8, a9
42004664:	093827        	bltu	a8, a2, 42004671 <memprot_ll_prepare_dram0_split_line_regval+0x39>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
42004667:	a07710        	addx4	a7, a7, a1
4200466a:	280c      	movi.n	a8, 2
4200466c:	7789      	s32i.n	a8, a7, 28
            break;
4200466e:	0002c6        	j	4200467d <memprot_ll_prepare_dram0_split_line_regval+0x45>
        } else {
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42004671:	a08710        	addx4	a8, a7, a1
42004674:	090c      	movi.n	a9, 0
42004676:	7899      	s32i.n	a9, a8, 28
    for (size_t x=0; x<7; x++) {
42004678:	771b      	addi.n	a7, a7, 1
4200467a:	cf77b6        	bltui	a7, 7, 4200464d <memprot_ll_prepare_dram0_split_line_regval+0x15>

    //resolve split address' significant bits
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR_V);

    //write values to required configuration-register
    constrain_reg_fields_t cfg_reg_val = {
4200467d:	81a8      	l32i.n	a10, a1, 32
4200467f:	14a0a0        	extui	a10, a10, 0, 2
42004682:	11aae0        	slli	a10, a10, 2
42004685:	7188      	l32i.n	a8, a1, 28
42004687:	148080        	extui	a8, a8, 0, 2
4200468a:	9198      	l32i.n	a9, a1, 36
4200468c:	149090        	extui	a9, a9, 0, 2
4200468f:	1199c0        	slli	a9, a9, 4
42004692:	2088a0        	or	a8, a8, a10
42004695:	a1a8      	l32i.n	a10, a1, 40
42004697:	14a0a0        	extui	a10, a10, 0, 2
4200469a:	11aaa0        	slli	a10, a10, 6
4200469d:	208890        	or	a8, a8, a9
420046a0:	b198      	l32i.n	a9, a1, 44
420046a2:	149090        	extui	a9, a9, 0, 2
420046a5:	119980        	slli	a9, a9, 8
420046a8:	2088a0        	or	a8, a8, a10
420046ab:	c1a8      	l32i.n	a10, a1, 48
420046ad:	14a0a0        	extui	a10, a10, 0, 2
420046b0:	11aa60        	slli	a10, a10, 10
420046b3:	208890        	or	a8, a8, a9
420046b6:	d198      	l32i.n	a9, a1, 52
420046b8:	149090        	extui	a9, a9, 0, 2
420046bb:	119940        	slli	a9, a9, 12
420046be:	2088a0        	or	a8, a8, a10
420046c1:	742820        	extui	a2, a2, 8, 8
420046c4:	112220        	slli	a2, a2, 14
420046c7:	208890        	or	a8, a8, a9
420046ca:	208820        	or	a8, a8, a2
            .splitaddr = conf_add,
            .reserved = 0
    };


    *regval = cfg_reg_val.val;
420046cd:	0389      	s32i.n	a8, a3, 0
}
420046cf:	f01d      	retw.n
420046d1:	000000        	ill

420046d4 <memprot_ll_set_dram0_split_line>:

static inline memprot_hal_err_t memprot_ll_set_dram0_split_line(const void *line_addr, const uint32_t sensitive_reg)
{
420046d4:	006136        	entry	a1, 48
420046d7:	20a220        	or	a10, a2, a2
    uint32_t addr = (uint32_t)line_addr;

    //sanity check
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
420046da:	efdd81        	l32r	a8, 42000650 <_stext+0x630> (c0378000 <_rtc_reserved_end+0x60278000>)
420046dd:	808280        	add	a8, a2, a8
420046e0:	efc991        	l32r	a9, 42000604 <_stext+0x5e4> (67fff <UserFrameTotalSize+0x67eff>)
420046e3:	163987        	bltu	a9, a8, 420046fd <memprot_ll_set_dram0_split_line+0x29>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
420046e6:	748020        	extui	a8, a2, 0, 8
420046e9:	015856        	bnez	a8, 42004702 <memprot_ll_set_dram0_split_line+0x2e>

    uint32_t regval;
    memprot_ll_prepare_dram0_split_line_regval(addr, &regval);
420046ec:	01bd      	mov.n	a11, a1
420046ee:	fff4a5        	call8	42004638 <memprot_ll_prepare_dram0_split_line_regval>

    REG_WRITE(sensitive_reg, regval);
420046f1:	0188      	l32i.n	a8, a1, 0
420046f3:	0020c0        	memw
420046f6:	0389      	s32i.n	a8, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
    HAL_ASSERT((REG_READ(sensitive_reg) == regval) && "Value not stored to required register");
#endif

    return MEMP_HAL_OK;
420046f8:	020c      	movi.n	a2, 0
420046fa:	000186        	j	42004704 <memprot_ll_set_dram0_split_line+0x30>
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
420046fd:	220c      	movi.n	a2, 2
420046ff:	000046        	j	42004704 <memprot_ll_set_dram0_split_line+0x30>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42004702:	320c      	movi.n	a2, 3
}
42004704:	f01d      	retw.n
	...

42004708 <memprot_ll_dram0_set_pms_area_0>:

    return permissions;
}

static inline void memprot_ll_dram0_set_pms_area_0(const bool r, const bool w)
{
42004708:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
4200470b:	efd281        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
4200470e:	0020c0        	memw
42004711:	0888      	l32i.n	a8, a8, 0
42004713:	c97c      	movi.n	a9, -4
42004715:	108890        	and	a8, a8, a9
    if (r) {
42004718:	42cc      	bnez.n	a2, 42004720 <memprot_ll_dram0_set_pms_area_0+0x18>
    uint32_t permissions = 0;
4200471a:	090c      	movi.n	a9, 0
4200471c:	000086        	j	42004722 <memprot_ll_dram0_set_pms_area_0+0x1a>
4200471f:	00          	.byte	00
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004720:	190c      	movi.n	a9, 1
    if (w) {
42004722:	338c      	beqz.n	a3, 42004729 <memprot_ll_dram0_set_pms_area_0+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004724:	2a0c      	movi.n	a10, 2
42004726:	2099a0        	or	a9, a9, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
42004729:	149090        	extui	a9, a9, 0, 2
4200472c:	208890        	or	a8, a8, a9
4200472f:	efc991        	l32r	a9, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
42004732:	0020c0        	memw
42004735:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004737:	f01d      	retw.n
42004739:	000000        	ill

4200473c <memprot_ll_dram0_set_pms_area_1>:

static inline void memprot_ll_dram0_set_pms_area_1(const bool r, const bool w)
{
4200473c:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
4200473f:	efc581        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
42004742:	0020c0        	memw
42004745:	0898      	l32i.n	a9, a8, 0
42004747:	387c      	movi.n	a8, -13
42004749:	109980        	and	a9, a9, a8
    if (r) {
4200474c:	42cc      	bnez.n	a2, 42004754 <memprot_ll_dram0_set_pms_area_1+0x18>
    uint32_t permissions = 0;
4200474e:	080c      	movi.n	a8, 0
42004750:	000086        	j	42004756 <memprot_ll_dram0_set_pms_area_1+0x1a>
42004753:	180c00        	lsxp	f0, a12, a0
    if (w) {
42004756:	338c      	beqz.n	a3, 4200475d <memprot_ll_dram0_set_pms_area_1+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004758:	2a0c      	movi.n	a10, 2
4200475a:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
4200475d:	1188e0        	slli	a8, a8, 2
42004760:	ca0c      	movi.n	a10, 12
42004762:	1088a0        	and	a8, a8, a10
42004765:	209980        	or	a9, a9, a8
42004768:	efbb81        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
4200476b:	0020c0        	memw
4200476e:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
42004770:	f01d      	retw.n
	...

42004774 <memprot_ll_dram0_set_pms_area_2>:

static inline void memprot_ll_dram0_set_pms_area_2(const bool r, const bool w)
{
42004774:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
42004777:	efb781        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
4200477a:	0020c0        	memw
4200477d:	0898      	l32i.n	a9, a8, 0
4200477f:	cfaf82        	movi	a8, -49
42004782:	109980        	and	a9, a9, a8
    if (r) {
42004785:	32cc      	bnez.n	a2, 4200478c <memprot_ll_dram0_set_pms_area_2+0x18>
    uint32_t permissions = 0;
42004787:	080c      	movi.n	a8, 0
42004789:	000046        	j	4200478e <memprot_ll_dram0_set_pms_area_2+0x1a>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
4200478c:	180c      	movi.n	a8, 1
    if (w) {
4200478e:	338c      	beqz.n	a3, 42004795 <memprot_ll_dram0_set_pms_area_2+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004790:	2a0c      	movi.n	a10, 2
42004792:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
42004795:	1188c0        	slli	a8, a8, 4
42004798:	0a3c      	movi.n	a10, 48
4200479a:	1088a0        	and	a8, a8, a10
4200479d:	209980        	or	a9, a9, a8
420047a0:	efad81        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
420047a3:	0020c0        	memw
420047a6:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
420047a8:	f01d      	retw.n
	...

420047ac <memprot_ll_dram0_set_pms_area_3>:

static inline void memprot_ll_dram0_set_pms_area_3(const bool r, const bool w)
{
420047ac:	004136        	entry	a1, 32
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
420047af:	efa981        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
420047b2:	0020c0        	memw
420047b5:	0898      	l32i.n	a9, a8, 0
420047b7:	3faf82        	movi	a8, -193
420047ba:	109980        	and	a9, a9, a8
    if (r) {
420047bd:	32cc      	bnez.n	a2, 420047c4 <memprot_ll_dram0_set_pms_area_3+0x18>
    uint32_t permissions = 0;
420047bf:	080c      	movi.n	a8, 0
420047c1:	000046        	j	420047c6 <memprot_ll_dram0_set_pms_area_3+0x1a>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420047c4:	180c      	movi.n	a8, 1
    if (w) {
420047c6:	338c      	beqz.n	a3, 420047cd <memprot_ll_dram0_set_pms_area_3+0x21>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420047c8:	2a0c      	movi.n	a10, 2
420047ca:	2088a0        	or	a8, a8, a10
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
420047cd:	1188a0        	slli	a8, a8, 6
420047d0:	748080        	extui	a8, a8, 0, 8
420047d3:	209980        	or	a9, a9, a8
420047d6:	ef9f81        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
420047d9:	0020c0        	memw
420047dc:	0899      	s32i.n	a9, a8, 0
#ifdef PMS_DEBUG_ASSERTIONS
    uint32_t expected = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
    HAL_ASSERT((expected == memprot_ll_dram0_set_permissions(r, w)) && "Value not stored to required register");
#endif
}
420047de:	f01d      	retw.n

420047e0 <memprot_ll_dram0_get_monitor_lock>:

    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_dram0_get_monitor_lock(const int core, bool* locked)
{
420047e0:	004136        	entry	a1, 32
    switch (core) {
420047e3:	628c      	beqz.n	a2, 420047ed <memprot_ll_dram0_get_monitor_lock+0xd>
420047e5:	1b1226        	beqi	a2, 1, 42004804 <memprot_ll_dram0_get_monitor_lock+0x24>
420047e8:	720c      	movi.n	a2, 7
420047ea:	000ac6        	j	42004819 <memprot_ll_dram0_get_monitor_lock+0x39>
        case PRO_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG) == 1;
420047ed:	ef9a81        	l32r	a8, 42000658 <_stext+0x638> (600c1104 <SYSTEM+0x1104>)
420047f0:	0020c0        	memw
420047f3:	0888      	l32i.n	a8, a8, 0
420047f5:	880b      	addi.n	a8, a8, -1
420047f7:	40f880        	nsau	a8, a8
420047fa:	418580        	srli	a8, a8, 5
420047fd:	004382        	s8i	a8, a3, 0
            break;
42004800:	000546        	j	42004819 <memprot_ll_dram0_get_monitor_lock+0x39>
42004803:	968100        	ee.ldf.64.xp	f8, f9, a0, a1
        case APP_CPU_NUM:
            *locked = REG_READ(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG) == 1;
42004806:	0020c0ef 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 0, q7, q0, q2, q0
4200480a:	0888      	l32i.n	a8, a8, 0
4200480c:	880b      	addi.n	a8, a8, -1
4200480e:	40f880        	nsau	a8, a8
42004811:	418580        	srli	a8, a8, 5
42004814:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004817:	020c      	movi.n	a2, 0
}
42004819:	f01d      	retw.n
	...

4200481c <memprot_ll_dram0_set_monitor_en>:

// interrupt enable/clear
static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_en(const int core, const bool enable)
{
4200481c:	004136        	entry	a1, 32
    switch (core) {
4200481f:	628c      	beqz.n	a2, 42004829 <memprot_ll_dram0_set_monitor_en+0xd>
42004821:	301226        	beqi	a2, 1, 42004855 <memprot_ll_dram0_set_monitor_en+0x39>
42004824:	720c      	movi.n	a2, 7
42004826:	001606        	j	42004882 <memprot_ll_dram0_set_monitor_en+0x66>
        case PRO_CPU_NUM:
            if (enable) {
42004829:	339c      	beqz.n	a3, 42004840 <memprot_ll_dram0_set_monitor_en+0x24>
                REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN);
4200482b:	ef8d91        	l32r	a9, 42000660 <_stext+0x640> (600c1108 <SYSTEM+0x1108>)
4200482e:	0020c0        	memw
42004831:	0988      	l32i.n	a8, a9, 0
42004833:	2a0c      	movi.n	a10, 2
42004835:	2088a0        	or	a8, a8, a10
42004838:	0020c0        	memw
4200483b:	0989      	s32i.n	a8, a9, 0
4200483d:	001046        	j	42004882 <memprot_ll_dram0_set_monitor_en+0x66>
#ifdef PMS_DEBUG_ASSERTIONS
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0) && "Value not stored to required register");
#endif
            } else {
                REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN);
42004840:	ef8891        	l32r	a9, 42000660 <_stext+0x640> (600c1108 <SYSTEM+0x1108>)
42004843:	0020c0        	memw
42004846:	0988      	l32i.n	a8, a9, 0
42004848:	da7c      	movi.n	a10, -3
4200484a:	1088a0        	and	a8, a8, a10
4200484d:	0020c0        	memw
42004850:	0989      	s32i.n	a8, a9, 0
42004852:	000b06        	j	42004882 <memprot_ll_dram0_set_monitor_en+0x66>
                HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) == 0) && "Value not stored to required register");
#endif
            }
            break;
        case APP_CPU_NUM:
            if (enable) {
42004855:	539c      	beqz.n	a3, 4200486e <memprot_ll_dram0_set_monitor_en+0x52>
                REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
42004857:	ef8391        	l32r	a9, 42000664 <_stext+0x644> (600c1118 <SYSTEM+0x1118>)
4200485a:	0020c0        	memw
4200485d:	0988      	l32i.n	a8, a9, 0
4200485f:	2a0c      	movi.n	a10, 2
42004861:	2088a0        	or	a8, a8, a10
42004864:	0020c0        	memw
42004867:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
42004869:	020c      	movi.n	a2, 0
4200486b:	0004c6        	j	42004882 <memprot_ll_dram0_set_monitor_en+0x66>
                REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
4200486e:	ef7d91        	l32r	a9, 42000664 <_stext+0x644> (600c1118 <SYSTEM+0x1118>)
42004871:	0020c0        	memw
42004874:	0988      	l32i.n	a8, a9, 0
42004876:	da7c      	movi.n	a10, -3
42004878:	1088a0        	and	a8, a8, a10
4200487b:	0020c0        	memw
4200487e:	0989      	s32i.n	a8, a9, 0
    return MEMP_HAL_OK;
42004880:	020c      	movi.n	a2, 0
}
42004882:	f01d      	retw.n

42004884 <memprot_ll_dram0_get_monitor_en>:

static inline memprot_hal_err_t memprot_ll_dram0_get_monitor_en(const int core, bool* enabled)
{
42004884:	004136        	entry	a1, 32
    switch (core) {
42004887:	628c      	beqz.n	a2, 42004891 <memprot_ll_dram0_get_monitor_en+0xd>
42004889:	171226        	beqi	a2, 1, 420048a4 <memprot_ll_dram0_get_monitor_en+0x20>
4200488c:	720c      	movi.n	a2, 7
4200488e:	000886        	j	420048b4 <memprot_ll_dram0_get_monitor_en+0x30>
        case PRO_CPU_NUM:
            *enabled = REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
42004891:	ef7381        	l32r	a8, 42000660 <_stext+0x640> (600c1108 <SYSTEM+0x1108>)
42004894:	0020c0        	memw
42004897:	0888      	l32i.n	a8, a8, 0
42004899:	048180        	extui	a8, a8, 1, 1
4200489c:	004382        	s8i	a8, a3, 0
            break;
4200489f:	000446        	j	420048b4 <memprot_ll_dram0_get_monitor_en+0x30>
420048a2:	810000        	src	a0, a0, a0
        case APP_CPU_NUM:
            *enabled = REG_GET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
420048a5:	c0ef70        	sub	a14, a15, a7
420048a8:	20          	.byte	0x20
420048a9:	088800        	lsx	f8, a8, a0
420048ac:	048180        	extui	a8, a8, 1, 1
420048af:	004382        	s8i	a8, a3, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420048b2:	020c      	movi.n	a2, 0
}
420048b4:	f01d      	retw.n
	...

420048b8 <memprot_ll_dram0_set_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_intrclr(const int core)
{
420048b8:	004136        	entry	a1, 32
    switch (core) {
420048bb:	628c      	beqz.n	a2, 420048c5 <memprot_ll_dram0_set_monitor_intrclr+0xd>
420048bd:	1b1226        	beqi	a2, 1, 420048dc <memprot_ll_dram0_set_monitor_intrclr+0x24>
420048c0:	720c      	movi.n	a2, 7
420048c2:	000a86        	j	420048f0 <memprot_ll_dram0_set_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
420048c5:	ef6691        	l32r	a9, 42000660 <_stext+0x640> (600c1108 <SYSTEM+0x1108>)
420048c8:	0020c0        	memw
420048cb:	0988      	l32i.n	a8, a9, 0
420048cd:	1a0c      	movi.n	a10, 1
420048cf:	2088a0        	or	a8, a8, a10
420048d2:	0020c0        	memw
420048d5:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) > 0) && "Value not stored to required register");
#endif
            break;
420048d7:	000546        	j	420048f0 <memprot_ll_dram0_set_monitor_intrclr+0x38>
420048da:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
420048dd:	c0ef62        	s32c1i	a6, a15, 0x300
420048e0:	20          	.byte	0x20
420048e1:	098800        	l32e	a0, a8, -32
420048e4:	1a0c      	movi.n	a10, 1
420048e6:	2088a0        	or	a8, a8, a10
420048e9:	0020c0        	memw
420048ec:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
420048ee:	020c      	movi.n	a2, 0
}
420048f0:	f01d      	retw.n
	...

420048f4 <memprot_ll_dram0_reset_monitor_intrclr>:

static inline memprot_hal_err_t memprot_ll_dram0_reset_monitor_intrclr(const int core)
{
420048f4:	004136        	entry	a1, 32
    switch (core) {
420048f7:	628c      	beqz.n	a2, 42004901 <memprot_ll_dram0_reset_monitor_intrclr+0xd>
420048f9:	1b1226        	beqi	a2, 1, 42004918 <memprot_ll_dram0_reset_monitor_intrclr+0x24>
420048fc:	720c      	movi.n	a2, 7
420048fe:	000a86        	j	4200492c <memprot_ll_dram0_reset_monitor_intrclr+0x38>
        case PRO_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
42004901:	ef5791        	l32r	a9, 42000660 <_stext+0x640> (600c1108 <SYSTEM+0x1108>)
42004904:	0020c0        	memw
42004907:	0988      	l32i.n	a8, a9, 0
42004909:	ea7c      	movi.n	a10, -2
4200490b:	1088a0        	and	a8, a8, a10
4200490e:	0020c0        	memw
42004911:	0989      	s32i.n	a8, a9, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
42004913:	000546        	j	4200492c <memprot_ll_dram0_reset_monitor_intrclr+0x38>
42004916:	910000        	srl	a0, a0
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
42004919:	53          	.byte	0x53
4200491a:	0020c0ef 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 0, q7, q0, q2, q0
4200491e:	0988      	l32i.n	a8, a9, 0
42004920:	ea7c      	movi.n	a10, -2
42004922:	1088a0        	and	a8, a8, a10
42004925:	0020c0        	memw
42004928:	0989      	s32i.n	a8, a9, 0
            break;
        default:
            return MEMP_HAL_ERR_CORE_INVALID;
    }

    return MEMP_HAL_OK;
4200492a:	020c      	movi.n	a2, 0
}
4200492c:	f01d      	retw.n
	...

42004930 <esp_mprot_cpuid_valid>:

//////////////////////////////////////////////////////////////////////////////
// internal helpers

static esp_err_t esp_mprot_cpuid_valid(const int core)
{
42004930:	004136        	entry	a1, 32
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
42004933:	090c      	movi.n	a9, 0
42004935:	000386        	j	42004947 <esp_mprot_cpuid_valid+0x17>
        if (core == s_memp_cfg.target_cpu[x]) {
42004938:	894b      	addi.n	a8, a9, 4
4200493a:	ef4ca1        	l32r	a10, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
4200493d:	a088a0        	addx4	a8, a8, a10
42004940:	0888      	l32i.n	a8, a8, 0
42004942:	0f1827        	beq	a8, a2, 42004955 <esp_mprot_cpuid_valid+0x25>
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
42004945:	991b      	addi.n	a9, a9, 1
42004947:	ef4981        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
4200494a:	3888      	l32i.n	a8, a8, 12
4200494c:	e83987        	bltu	a9, a8, 42004938 <esp_mprot_cpuid_valid+0x8>
            return ESP_OK;
        }
    }

    return ESP_ERR_MEMPROT_CPUID_INVALID;
4200494f:	ef4621        	l32r	a2, 42000668 <_stext+0x648> (d008 <UserFrameTotalSize+0xcf08>)
42004952:	000046        	j	42004957 <esp_mprot_cpuid_valid+0x27>
            return ESP_OK;
42004955:	020c      	movi.n	a2, 0
}
42004957:	f01d      	retw.n
42004959:	000000        	ill

4200495c <esp_memprot_iram0_get_def_split_addr>:

static void *esp_memprot_iram0_get_def_split_addr(void)
{
4200495c:	004136        	entry	a1, 32
    return (void *)(uint32_t)&_iram_text_end;
}
4200495f:	ef4421        	l32r	a2, 42000670 <_stext+0x650> (40382400 <_iram_bss_end>)
42004962:	f01d      	retw.n

42004964 <esp_memprot_dram0_get_def_split_addr>:

static void *esp_memprot_dram0_get_def_split_addr(void)
{
42004964:	004136        	entry	a1, 32
    return (void *)MAP_IRAM_TO_DRAM((uint32_t)&_iram_text_end);
}
42004967:	ef4221        	l32r	a2, 42000670 <_stext+0x650> (40382400 <_iram_bss_end>)
4200496a:	ef3881        	l32r	a8, 4200064c <_stext+0x62c> (ff910000 <_rtc_reserved_end+0x9f810000>)
4200496d:	228a      	add.n	a2, a2, a8
4200496f:	f01d      	retw.n
42004971:	000000        	ill

42004974 <esp_memprot_rtcfast_get_min_split_addr>:

static void *esp_memprot_rtcfast_get_min_split_addr(void)
{
42004974:	004136        	entry	a1, 32
    return (void *)(uint32_t)&_rtc_text_end;
}
42004977:	ef3f21        	l32r	a2, 42000674 <_stext+0x654> (600fe000 <s_sleep_sub_mode_ref_cnt>)
4200497a:	f01d      	retw.n

4200497c <esp_mprot_set_intr_matrix>:

//register MEMPROT-relevant interrupts in the global matrix (to deploy panic handling)
//mapped to ETS_MEMACCESS_ERR_INUM (shared with cache-access interrupts)
static esp_err_t esp_mprot_set_intr_matrix(const esp_mprot_mem_t mem_type, const int core)
{
4200497c:	004136        	entry	a1, 32
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
4200497f:	19a0a2        	movi	a10, 25
42004982:	ee2f81        	l32r	a8, 42000240 <_stext+0x220> (40376644 <esp_intr_disable_source>)
42004985:	0008e0        	callx8	a8

    esp_err_t err;
    uint32_t intr_src_num = ETS_MAX_INTR_SOURCE;

    switch (mem_type) {
42004988:	3c2226        	beqi	a2, 2, 420049c8 <esp_mprot_set_intr_matrix+0x4c>
4200498b:	6d4226        	beqi	a2, 4, 420049fc <esp_mprot_set_intr_matrix+0x80>
4200498e:	021226        	beqi	a2, 1, 42004994 <esp_mprot_set_intr_matrix+0x18>
42004991:	002906        	j	42004a39 <esp_mprot_set_intr_matrix+0xbd>
    switch (core) {
42004994:	838c      	beqz.n	a3, 420049a0 <esp_mprot_set_intr_matrix+0x24>
42004996:	0f1366        	bnei	a3, 1, 420049a9 <esp_mprot_set_intr_matrix+0x2d>
            *src_num = ETS_CORE1_IRAM0_PMS_INTR_SOURCE;
42004999:	975c      	movi.n	a7, 89
    return MEMP_HAL_OK;
4200499b:	0a0c      	movi.n	a10, 0
4200499d:	000386        	j	420049af <esp_mprot_set_intr_matrix+0x33>
420049a0:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_IRAM0_PMS_INTR_SOURCE;
420049a2:	575c      	movi.n	a7, 85
420049a4:	0001c6        	j	420049af <esp_mprot_set_intr_matrix+0x33>
420049a7:	720000        	salt	a0, a0, a0
    switch (core) {
420049aa:	a263a0        	muluh	a6, a3, a10
420049ad:	29a5ffaf 	ee.vmulas.s8.accx.ld.ip.qup	q2, a10, 0xfffffef0, q7, q7, q2, q5
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_intr_source_num(core, &intr_src_num)))
420049b1:	2aa001        	l32r	a0, 41fcf434 <_iram_bss_end+0x1c4d034>
420049b4:	20          	.byte	0x20
420049b5:	083a56        	bnez	a10, 42004a3c <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
420049b8:	19a0c2        	movi	a12, 25
420049bb:	07bd      	mov.n	a11, a7
420049bd:	03ad      	mov.n	a10, a3
420049bf:	edd981        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
420049c2:	0008e0        	callx8	a8
        break;
420049c5:	0018c6        	j	42004a2c <esp_mprot_set_intr_matrix+0xb0>
    switch (core) {
420049c8:	838c      	beqz.n	a3, 420049d4 <esp_mprot_set_intr_matrix+0x58>
420049ca:	0f1366        	bnei	a3, 1, 420049dd <esp_mprot_set_intr_matrix+0x61>
            *src_num = ETS_CORE1_DRAM0_PMS_INTR_SOURCE;
420049cd:	a75c      	movi.n	a7, 90
    return MEMP_HAL_OK;
420049cf:	0a0c      	movi.n	a10, 0
420049d1:	000386        	j	420049e3 <esp_mprot_set_intr_matrix+0x67>
420049d4:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_DRAM0_PMS_INTR_SOURCE;
420049d6:	675c      	movi.n	a7, 86
420049d8:	0001c6        	j	420049e3 <esp_mprot_set_intr_matrix+0x67>
420049db:	720000        	salt	a0, a0, a0
    switch (core) {
420049de:	a263a0        	muluh	a6, a3, a10
420049e1:	6507a0        	extui	a0, a10, 23, 7
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_intr_source_num(core, &intr_src_num)))
420049e4:	a00126        	beqi	a1, -1, 42004988 <esp_mprot_set_intr_matrix+0xc>
420049e7:	202a      	add.n	a2, a0, a2
420049e9:	04fa56        	bnez	a10, 42004a3c <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
420049ec:	19a0c2        	movi	a12, 25
420049ef:	07bd      	mov.n	a11, a7
420049f1:	03ad      	mov.n	a10, a3
420049f3:	edcc81        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
420049f6:	0008e0        	callx8	a8
        break;
420049f9:	000bc6        	j	42004a2c <esp_mprot_set_intr_matrix+0xb0>
    switch (core) {
420049fc:	838c      	beqz.n	a3, 42004a08 <esp_mprot_set_intr_matrix+0x8c>
420049fe:	0f1366        	bnei	a3, 1, 42004a11 <esp_mprot_set_intr_matrix+0x95>
            *src_num = ETS_CORE1_PIF_PMS_INTR_SOURCE;
42004a01:	b75c      	movi.n	a7, 91
    return MEMP_HAL_OK;
42004a03:	0a0c      	movi.n	a10, 0
42004a05:	000386        	j	42004a17 <esp_mprot_set_intr_matrix+0x9b>
42004a08:	03ad      	mov.n	a10, a3
            *src_num = ETS_CORE0_PIF_PMS_INTR_SOURCE;
42004a0a:	775c      	movi.n	a7, 87
42004a0c:	0001c6        	j	42004a17 <esp_mprot_set_intr_matrix+0x9b>
42004a0f:	720000        	salt	a0, a0, a0
    switch (core) {
42004a12:	a263a0        	muluh	a6, a3, a10
42004a15:	2507a0        	extui	a0, a10, 23, 3
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_intr_source_num(core, &intr_src_num)))
42004a18:	a00123        	lsi	f2, a1, 0x280
42004a1b:	202a      	add.n	a2, a0, a2
42004a1d:	01ba56        	bnez	a10, 42004a3c <esp_mprot_set_intr_matrix+0xc0>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
42004a20:	9c1c      	movi.n	a12, 25
42004a22:	07bd      	mov.n	a11, a7
42004a24:	03ad      	mov.n	a10, a3
42004a26:	edbf81        	l32r	a8, 42000124 <_stext+0x104> (40001b54 <esp_rom_route_intr_matrix>)
42004a29:	0008e0        	callx8	a8
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    ESP_INTR_ENABLE(ETS_MEMACCESS_ERR_INUM);
42004a2c:	9a1c      	movi.n	a10, 25
42004a2e:	ee0581        	l32r	a8, 42000244 <_stext+0x224> (40376578 <esp_intr_enable_source>)
42004a31:	0008e0        	callx8	a8

    return ESP_OK;
42004a34:	020c      	movi.n	a2, 0
42004a36:	000086        	j	42004a3c <esp_mprot_set_intr_matrix+0xc0>
    switch (mem_type) {
42004a39:	ef0f21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
}
42004a3c:	f01d      	retw.n
	...

42004a40 <esp_mprot_set_split_addr>:
//////////////////////////////////////////////////////////////////////////////
// PMS configuration APIs (set/get/lock)
// IRAM/DRAM settings are shared by both CPUs, RTCFAST settings are separate for each core

esp_err_t esp_mprot_set_split_addr(const esp_mprot_mem_t mem_type, const esp_mprot_split_addr_t line_type, const void *line_addr, const int core __attribute__((unused)))
{
42004a40:	004136        	entry	a1, 32
    switch (mem_type) {
42004a43:	4e2226        	beqi	a2, 2, 42004a95 <esp_mprot_set_split_addr+0x55>
42004a46:	024266        	bnei	a2, 4, 42004a4c <esp_mprot_set_split_addr+0xc>
42004a49:	001f06        	j	42004ac9 <esp_mprot_set_split_addr+0x89>
42004a4c:	021226        	beqi	a2, 1, 42004a52 <esp_mprot_set_split_addr+0x12>
42004a4f:	002546        	j	42004ae8 <esp_mprot_set_split_addr+0xa8>
    case MEMPROT_TYPE_IRAM0_SRAM:
        switch (line_type) {
42004a52:	1b2326        	beqi	a3, 2, 42004a71 <esp_mprot_set_split_addr+0x31>
42004a55:	2a4326        	beqi	a3, 4, 42004a83 <esp_mprot_set_split_addr+0x43>
42004a58:	021326        	beqi	a3, 1, 42004a5e <esp_mprot_set_split_addr+0x1e>
42004a5b:	002446        	j	42004af0 <esp_mprot_set_split_addr+0xb0>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
42004a5e:	ef08b1        	l32r	a11, 42000680 <_stext+0x660> (600c10c4 <SYSTEM+0x10c4>)
42004a61:	20a440        	or	a10, a4, a4
42004a64:	ff5ae5        	call8	42004014 <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_DRAM0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_main_I_D(line_addr));
42004a67:	011e25        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004a6a:	202aa0        	or	a2, a10, a10
42004a6d:	0022c6        	j	42004afc <esp_mprot_set_split_addr+0xbc>
42004a70:	04b100        	extui	a11, a0, 1, 1
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
42004a73:	20a440ef 	ee.vmulas.s8.accx.ld.ip.qup	q0, a14, 0, q5, q1, q2, q4
42004a77:	ff59e5        	call8	42004014 <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_LINE_0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_0(line_addr));
42004a7a:	011ce5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004a7d:	202aa0        	or	a2, a10, a10
42004a80:	001e06        	j	42004afc <esp_mprot_set_split_addr+0xbc>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
42004a83:	ef01b1        	l32r	a11, 42000688 <_stext+0x668> (600c10cc <SYSTEM+0x10cc>)
42004a86:	20a440        	or	a10, a4, a4
42004a89:	ff58a5        	call8	42004014 <memprot_ll_set_iram0_split_line>
        case MEMPROT_SPLIT_ADDR_IRAM0_LINE_1:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_1(line_addr));
42004a8c:	011ba5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004a8f:	202aa0        	or	a2, a10, a10
42004a92:	001986        	j	42004afc <esp_mprot_set_split_addr+0xbc>
        default:
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
        } break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        switch (line_type) {
42004a95:	088326        	beqi	a3, 8, 42004aa1 <esp_mprot_set_split_addr+0x61>
42004a98:	19b326        	beqi	a3, 16, 42004ab5 <esp_mprot_set_split_addr+0x75>
42004a9b:	eef821        	l32r	a2, 4200067c <_stext+0x65c> (d002 <UserFrameTotalSize+0xcf02>)
42004a9e:	001686        	j	42004afc <esp_mprot_set_split_addr+0xbc>
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42004aa1:	eefab1        	l32r	a11, 4200068c <_stext+0x66c> (600c10d0 <SYSTEM+0x10d0>)
42004aa4:	20a440        	or	a10, a4, a4
42004aa7:	ffc2e5        	call8	420046d4 <memprot_ll_set_dram0_split_line>
        case MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_0(line_addr));
42004aaa:	0119e5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004aad:	202aa0        	or	a2, a10, a10
42004ab0:	001206        	j	42004afc <esp_mprot_set_split_addr+0xbc>
42004ab3:	b10000        	sra	a0, a0
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
42004ab6:	40eef6        	bgeui	a14, 128, 42004afa <esp_mprot_set_split_addr+0xba>
42004ab9:	a520a4        	ee.vldbc.16.ip	q4, a10, 64
42004abc:	a5ffc1        	l32r	a12, 41fee2b8 <_iram_bss_end+0x1c6beb8>
        case MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1:
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_1(line_addr));
42004abf:	0118      	l32i.n	a1, a1, 0
42004ac1:	202aa0        	or	a2, a10, a10
42004ac4:	000d06        	j	42004afc <esp_mprot_set_split_addr+0xbc>
42004ac7:	660000        	ee.ldf.64.xp	f0, f6, a0, a0
        default:
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
        } break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        if (line_type == MEMPROT_SPLIT_ADDR_MAIN) { /* so far only WORLD_0 is supported */
42004aca:	13          	.byte	0x13
42004acb:	502c      	movi.n	a0, 37
            esp_err_t err;
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004acd:	2520a5        	call8	42029cd8 <_etext+0x105a2>
42004ad0:	2dffe6        	bgei	a15, 0x100, 42004b01 <esp_mprot_get_default_main_split_addr+0x1>
42004ad3:	ec0a      	add.n	a14, a12, a0
42004ad5:	0c4a      	add.n	a0, a12, a4
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_rtcfast_split_line(core, line_addr, MEMP_HAL_WORLD_0)))
42004ad7:	bd1c      	movi.n	a13, 27
42004ad9:	04          	.byte	0x4
42004ada:	05ad      	mov.n	a10, a5
42004adc:	ff7ee5        	call8	420042cc <memprot_ll_set_rtcfast_split_line>
42004adf:	0116a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004ae2:	0a2d      	mov.n	a2, a10
42004ae4:	000506        	j	42004afc <esp_mprot_set_split_addr+0xbc>
42004ae7:	e42100        	extui	a2, a0, 1, 15
    switch (mem_type) {
42004aea:	000346ee 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 96, q1, q0, q0, q3
42004aee:	210000        	srai	a0, a0, 0
        switch (line_type) {
42004af1:	e3          	.byte	0xe3
42004af2:	000146ee 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 96, q1, q0, q0, q1
42004af6:	000000        	ill
            return ESP_OK;
        } else {
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
42004af9:	eee021        	l32r	a2, 4200067c <_stext+0x65c> (d002 <UserFrameTotalSize+0xcf02>)
        }
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }
}
42004afc:	f01d      	retw.n
	...

42004b00 <esp_mprot_get_default_main_split_addr>:

    return ESP_OK;
}

esp_err_t esp_mprot_get_default_main_split_addr(const esp_mprot_mem_t mem_type, void **def_split_addr)
{
42004b00:	004136        	entry	a1, 32
    if (def_split_addr == NULL) {
42004b03:	02e316        	beqz	a3, 42004b35 <esp_mprot_get_default_main_split_addr+0x35>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
42004b06:	112226        	beqi	a2, 2, 42004b1b <esp_mprot_get_default_main_split_addr+0x1b>
42004b09:	1b4226        	beqi	a2, 4, 42004b28 <esp_mprot_get_default_main_split_addr+0x28>
42004b0c:	2c1266        	bnei	a2, 1, 42004b3c <esp_mprot_get_default_main_split_addr+0x3c>
    case MEMPROT_TYPE_IRAM0_SRAM:
        *def_split_addr = esp_memprot_iram0_get_def_split_addr();
42004b0f:	ffe4e5        	call8	4200495c <esp_memprot_iram0_get_def_split_addr>
42004b12:	0063a2        	s32i	a10, a3, 0
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004b15:	00a022        	movi	a2, 0
        break;
42004b18:	0008c6        	j	42004b3f <esp_mprot_get_default_main_split_addr+0x3f>
        *def_split_addr = esp_memprot_dram0_get_def_split_addr();
42004b1b:	ffe4a5        	call8	42004964 <esp_memprot_dram0_get_def_split_addr>
42004b1e:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
42004b20:	020c      	movi.n	a2, 0
        break;
42004b22:	000646        	j	42004b3f <esp_mprot_get_default_main_split_addr+0x3f>
42004b25:	000000        	ill
        *def_split_addr = esp_memprot_rtcfast_get_min_split_addr();
42004b28:	ffe4a5        	call8	42004974 <esp_memprot_rtcfast_get_min_split_addr>
42004b2b:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
42004b2d:	020c      	movi.n	a2, 0
        break;
42004b2f:	000306        	j	42004b3f <esp_mprot_get_default_main_split_addr+0x3f>
42004b32:	000000        	ill
        return ESP_ERR_INVALID_ARG;
42004b35:	02a122        	movi	a2, 0x102
42004b38:	0000c6        	j	42004b3f <esp_mprot_get_default_main_split_addr+0x3f>
42004b3b:	00          	.byte	00
    switch (mem_type) {
42004b3c:	eecf21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
}
42004b3f:	f01d      	retw.n
42004b41:	000000        	ill

42004b44 <esp_mprot_set_split_addr_lock>:

esp_err_t esp_mprot_set_split_addr_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
{
42004b44:	004136        	entry	a1, 32
    switch (mem_type) {
42004b47:	0932f6        	bgeui	a2, 3, 42004b54 <esp_mprot_set_split_addr_lock+0x10>
42004b4a:	f2cc      	bnez.n	a2, 42004b5d <esp_mprot_set_split_addr_lock+0x19>
42004b4c:	eecb21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004b4f:	001446        	j	42004ba4 <esp_mprot_set_split_addr_lock+0x60>
42004b52:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
42004b55:	211442        	l16ui	a4, a4, 66
42004b58:	eec8      	l32i.n	a12, a14, 56
42004b5a:	001186        	j	42004ba4 <esp_mprot_set_split_addr_lock+0x60>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG, 1);
42004b5d:	eecd81        	l32r	a8, 42000694 <_stext+0x674> (600c10c0 <SYSTEM+0x10c0>)
42004b60:	190c      	movi.n	a9, 1
42004b62:	0020c0        	memw
42004b65:	0899      	s32i.n	a9, a8, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004b67:	020c      	movi.n	a2, 0
}
42004b69:	000dc6        	j	42004ba4 <esp_mprot_set_split_addr_lock+0x60>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004b6c:	20a330        	or	a10, a3, a3
42004b6f:	ffdc25        	call8	42004930 <esp_mprot_cpuid_valid>
42004b72:	202aa0        	or	a2, a10, a10
42004b75:	02ba56        	bnez	a10, 42004ba4 <esp_mprot_set_split_addr_lock+0x60>
    switch (core) {
42004b78:	838c      	beqz.n	a3, 42004b84 <esp_mprot_set_split_addr_lock+0x40>
42004b7a:	131326        	beqi	a3, 1, 42004b91 <esp_mprot_set_split_addr_lock+0x4d>
42004b7d:	730c      	movi.n	a3, 7
42004b7f:	000686        	j	42004b9d <esp_mprot_set_split_addr_lock+0x59>
42004b82:	810000        	src	a0, a0, a0
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
42004b85:	0ceea6        	blti	a14, 128, 42004b95 <esp_mprot_set_split_addr_lock+0x51>
42004b88:	c019      	s32i.n	a1, a0, 48
42004b8a:	20          	.byte	0x20
42004b8b:	089900        	lsx	f9, a9, a0
            break;
42004b8e:	0002c6        	j	42004b9d <esp_mprot_set_split_addr_lock+0x59>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
42004b91:	eea381        	l32r	a8, 42000620 <_stext+0x600> (600c11d0 <SYSTEM+0x11d0>)
42004b94:	190c      	movi.n	a9, 1
42004b96:	0020c0        	memw
42004b99:	0899      	s32i.n	a9, a8, 0
    return MEMP_HAL_OK;
42004b9b:	0a3d      	mov.n	a3, a10
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
42004b9d:	03ad      	mov.n	a10, a3
42004b9f:	010aa5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004ba2:	0a2d      	mov.n	a2, a10
}
42004ba4:	f01d      	retw.n
	...

42004ba8 <esp_mprot_get_split_addr_lock>:

esp_err_t esp_mprot_get_split_addr_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
{
42004ba8:	004136        	entry	a1, 32
    if (locked == NULL) {
42004bab:	04a316        	beqz	a3, 42004bf9 <esp_mprot_get_split_addr_lock+0x51>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
42004bae:	0732f6        	bgeui	a2, 3, 42004bb9 <esp_mprot_get_split_addr_lock+0x11>
42004bb1:	f2cc      	bnez.n	a2, 42004bc4 <esp_mprot_get_split_addr_lock+0x1c>
42004bb3:	eeb121        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004bb6:	001086        	j	42004bfc <esp_mprot_get_split_addr_lock+0x54>
42004bb9:	214226        	beqi	a2, 4, 42004bde <esp_mprot_get_split_addr_lock+0x36>
42004bbc:	eeaf21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004bbf:	000e46        	j	42004bfc <esp_mprot_get_split_addr_lock+0x54>
42004bc2:	810000        	src	a0, a0, a0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
42004bc5:	b4          	.byte	0xb4
42004bc6:	0020c0ee 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 0, q3, q0, q2, q0
42004bca:	0888      	l32i.n	a8, a8, 0
42004bcc:	880b      	addi.n	a8, a8, -1
42004bce:	40f880        	nsau	a8, a8
42004bd1:	418580        	srli	a8, a8, 5
    case MEMPROT_TYPE_IRAM0_SRAM:
    case MEMPROT_TYPE_DRAM0_SRAM:
        *locked = memprot_ll_get_iram0_dram0_split_line_lock();
42004bd4:	004382        	s8i	a8, a3, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004bd7:	020c      	movi.n	a2, 0
        break;
42004bd9:	0007c6        	j	42004bfc <esp_mprot_get_split_addr_lock+0x54>
42004bdc:	400000        	ssr	a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004bdf:	e520a4        	ee.vldbc.8.ip	q4, a10, 32
42004be2:	d4          	.byte	0xd4
42004be3:	dc0a2dff 	ee.fft.cmul.s16.ld.xp	q4, a15, a13, q2, q4, q0, 1
42004be7:	bd2a      	add.n	a11, a13, a2
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
42004be9:	03          	.byte	0x3
42004bea:	04ad      	mov.n	a10, a4
42004bec:	ff6a25        	call8	42004290 <memprot_ll_get_pif_constraint_lock>
42004bef:	0105a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004bf2:	0a2d      	mov.n	a2, a10
42004bf4:	000106        	j	42004bfc <esp_mprot_get_split_addr_lock+0x54>
42004bf7:	220000        	orb	b0, b0, b0
        return ESP_ERR_INVALID_ARG;
42004bfa:	1d02a1        	l32r	a10, 41fcc004 <_iram_bss_end+0x1c49c04>
}
42004bfd:	0000f0        	callx12	a0

42004c00 <esp_mprot_set_pms_lock>:

esp_err_t esp_mprot_set_pms_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
{
42004c00:	004136        	entry	a1, 32
    switch (mem_type) {
42004c03:	152226        	beqi	a2, 2, 42004c1c <esp_mprot_set_pms_lock+0x1c>
42004c06:	224226        	beqi	a2, 4, 42004c2c <esp_mprot_set_pms_lock+0x2c>
42004c09:	601266        	bnei	a2, 1, 42004c6d <esp_mprot_set_pms_lock+0x6d>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG, 1);
42004c0c:	eea381        	l32r	a8, 42000698 <_stext+0x678> (600c10d8 <SYSTEM+0x10d8>)
42004c0f:	190c      	movi.n	a9, 1
42004c11:	0020c0        	memw
42004c14:	0899      	s32i.n	a9, a8, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004c16:	020c      	movi.n	a2, 0
}
42004c18:	001506        	j	42004c70 <esp_mprot_set_pms_lock+0x70>
42004c1b:	a08100        	addx4	a8, a1, a0
    REG_WRITE(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG, 1);
42004c1e:	c0190cee 	ee.vmulas.u16.accx.ld.xp.qup	q1, a14, a12, q0, q0, q1, q1
42004c22:	20          	.byte	0x20
42004c23:	089900        	lsx	f9, a9, a0
42004c26:	020c      	movi.n	a2, 0
}
42004c28:	001106        	j	42004c70 <esp_mprot_set_pms_lock+0x70>
42004c2b:	a33000        	movltz	a3, a0, a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004c2e:	d02520        	subx2	a2, a5, a2
42004c31:	202aa0ff 	ee.vmulas.s8.accx.ld.ip.qup	q1, a15, 0, q6, q4, q2, q2
42004c35:	037a56        	bnez	a10, 42004c70 <esp_mprot_set_pms_lock+0x70>
    switch (core) {
42004c38:	838c      	beqz.n	a3, 42004c44 <esp_mprot_set_pms_lock+0x44>
42004c3a:	131326        	beqi	a3, 1, 42004c51 <esp_mprot_set_pms_lock+0x51>
42004c3d:	730c      	movi.n	a3, 7
42004c3f:	000746        	j	42004c60 <esp_mprot_set_pms_lock+0x60>
42004c42:	810000        	src	a0, a0, a0
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
42004c45:	76          	.byte	0x76
42004c46:	c0190cee 	ee.vmulas.u16.accx.ld.xp.qup	q1, a14, a12, q0, q0, q1, q1
42004c4a:	20          	.byte	0x20
42004c4b:	089900        	lsx	f9, a9, a0
            break;
42004c4e:	000386        	j	42004c60 <esp_mprot_set_pms_lock+0x60>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
42004c51:	ee7381        	l32r	a8, 42000620 <_stext+0x600> (600c11d0 <SYSTEM+0x11d0>)
42004c54:	01a092        	movi	a9, 1
42004c57:	0020c0        	memw
42004c5a:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42004c5d:	203aa0        	or	a3, a10, a10
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
42004c60:	03ad      	mov.n	a10, a3
42004c62:	00fe65        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004c65:	0a2d      	mov.n	a2, a10
42004c67:	000146        	j	42004c70 <esp_mprot_set_pms_lock+0x70>
42004c6a:	000000        	ill
    switch (mem_type) {
42004c6d:	ee8221        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
}
42004c70:	f01d      	retw.n
	...

42004c74 <esp_mprot_get_pms_lock>:

esp_err_t esp_mprot_get_pms_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
{
42004c74:	004136        	entry	a1, 32
    if (locked == NULL) {
42004c77:	055316        	beqz	a3, 42004cd0 <esp_mprot_get_pms_lock+0x5c>
        return ESP_ERR_INVALID_ARG;
    }

    switch (mem_type) {
42004c7a:	1d2226        	beqi	a2, 2, 42004c9b <esp_mprot_get_pms_lock+0x27>
42004c7d:	354226        	beqi	a2, 4, 42004cb6 <esp_mprot_get_pms_lock+0x42>
42004c80:	551266        	bnei	a2, 1, 42004cd9 <esp_mprot_get_pms_lock+0x65>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004c83:	ee8581        	l32r	a8, 42000698 <_stext+0x678> (600c10d8 <SYSTEM+0x10d8>)
42004c86:	0020c0        	memw
42004c89:	0888      	l32i.n	a8, a8, 0
42004c8b:	880b      	addi.n	a8, a8, -1
42004c8d:	40f880        	nsau	a8, a8
42004c90:	418580        	srli	a8, a8, 5
    case MEMPROT_TYPE_IRAM0_SRAM:
        *locked = memprot_ll_iram0_get_pms_lock();
42004c93:	004382        	s8i	a8, a3, 0
    } break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
42004c96:	020c      	movi.n	a2, 0
        break;
42004c98:	001006        	j	42004cdc <esp_mprot_get_pms_lock+0x68>
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004c9b:	ee8081        	l32r	a8, 4200069c <_stext+0x67c> (600c10fc <SYSTEM+0x10fc>)
42004c9e:	0020c0        	memw
42004ca1:	0888      	l32i.n	a8, a8, 0
42004ca3:	880b      	addi.n	a8, a8, -1
42004ca5:	40f880        	nsau	a8, a8
42004ca8:	418580        	srli	a8, a8, 5
        *locked = memprot_ll_dram0_get_pms_lock();
42004cab:	004382        	s8i	a8, a3, 0
    return ESP_OK;
42004cae:	020c      	movi.n	a2, 0
        break;
42004cb0:	000a06        	j	42004cdc <esp_mprot_get_pms_lock+0x68>
42004cb3:	000000        	ill
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004cb6:	20a440        	or	a10, a4, a4
42004cb9:	ffc765        	call8	42004930 <esp_mprot_cpuid_valid>
42004cbc:	0a2d      	mov.n	a2, a10
42004cbe:	aadc      	bnez.n	a10, 42004cdc <esp_mprot_get_pms_lock+0x68>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
42004cc0:	03bd      	mov.n	a11, a3
42004cc2:	04ad      	mov.n	a10, a4
42004cc4:	ff5ca5        	call8	42004290 <memprot_ll_get_pif_constraint_lock>
42004cc7:	00f825        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004cca:	0a2d      	mov.n	a2, a10
42004ccc:	000306        	j	42004cdc <esp_mprot_get_pms_lock+0x68>
42004ccf:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42004cd2:	014602        	s8i	a0, a6, 1
42004cd5:	000000        	ill
42004cd8:	672100        	ee.stf.64.xp	f2, f6, a0, a1
    switch (mem_type) {
42004cdb:	00f01dee 	ee.vmulas.s16.accx.ld.ip.qup	q0, a14, 208, q0, q3, q7, q0
	...

42004ce0 <esp_mprot_set_pms_area>:
}

esp_err_t esp_mprot_set_pms_area(const esp_mprot_pms_area_t area_type, const uint32_t flags, const int core __attribute__((unused)))
{
42004ce0:	004136        	entry	a1, 32
    esp_err_t err;
    bool r = flags & MEMPROT_OP_READ;
    bool w = flags & MEMPROT_OP_WRITE;
42004ce3:	047130        	extui	a7, a3, 1, 1
    bool x = flags & MEMPROT_OP_EXEC;
42004ce6:	046230        	extui	a6, a3, 2, 1

    switch (area_type) {
42004ce9:	02d266        	bnei	a2, 64, 42004cef <esp_mprot_set_pms_area+0xf>
42004cec:	003446        	j	42004dc1 <esp_mprot_set_pms_area+0xe1>
42004cef:	084c      	movi.n	a8, 64
42004cf1:	2f3827        	bltu	a8, a2, 42004d24 <esp_mprot_set_pms_area+0x44>
42004cf4:	028266        	bnei	a2, 8, 42004cfa <esp_mprot_set_pms_area+0x1a>
42004cf7:	002506        	j	42004d8f <esp_mprot_set_pms_area+0xaf>
42004cfa:	880c      	movi.n	a8, 8
42004cfc:	103827        	bltu	a8, a2, 42004d10 <esp_mprot_set_pms_area+0x30>
42004cff:	6b2226        	beqi	a2, 2, 42004d6e <esp_mprot_set_pms_area+0x8e>
42004d02:	774226        	beqi	a2, 4, 42004d7d <esp_mprot_set_pms_area+0x9d>
42004d05:	531226        	beqi	a2, 1, 42004d5c <esp_mprot_set_pms_area+0x7c>
42004d08:	06a122        	movi	a2, 0x106
42004d0b:	004ec6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004d0e:	660000        	ee.ldf.64.xp	f0, f6, a0, a0
42004d11:	8602b2        	l8ui	a11, a2, 134
42004d14:	660022        	l8ui	a2, a0, 102
42004d17:	0602c2        	l8ui	a12, a2, 6
42004d1a:	220025        	call8	42026d1c <_etext+0xd5e6>
42004d1d:	c606a1        	l32r	a10, 41ff6538 <_iram_bss_end+0x1c74138>
42004d20:	0049      	s32i.n	a4, a0, 0
42004d22:	820000        	mull	a0, a0, a0
42004d25:	8700a2        	l8ui	a10, a0, 135
42004d28:	060292        	l8ui	a9, a2, 6
42004d2b:	270036        	entry	a0, 0x1380
42004d2e:	1338      	l32i.n	a3, a3, 4
42004d30:	02e266        	bnei	a2, 128, 42004d36 <esp_mprot_set_pms_area+0x56>
42004d33:	002686        	j	42004dd1 <esp_mprot_set_pms_area+0xf1>
42004d36:	02f266        	bnei	a2, 0x100, 42004d3c <esp_mprot_set_pms_area+0x5c>
42004d39:	002906        	j	42004de1 <esp_mprot_set_pms_area+0x101>
42004d3c:	06a122        	movi	a2, 0x106
42004d3f:	0041c6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004d42:	820000        	mull	a0, a0, a0
42004d45:	8700a4        	ee.vmulas.s16.qacc.ldbc.incp	q0, a10, q0, q0
42004d48:	860292        	l8ui	a9, a2, 134
42004d4b:	810037        	bnone	a0, a3, 42004cd0 <esp_mprot_get_pms_lock+0x5c>
42004d4e:	87ee16        	beqz	a14, 420045d0 <memprot_ll_rtcfast_set_monitor_intrclr+0x10>
42004d51:	c60292        	l8ui	a9, a2, 198
42004d54:	0039      	s32i.n	a3, a0, 0
42004d56:	06a122        	movi	a2, 0x106
42004d59:	003b46        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
    case MEMPROT_PMS_AREA_IRAM0_0:
        memprot_ll_iram0_set_pms_area_0(r, w, x);
42004d5c:	20c660        	or	a12, a6, a6
42004d5f:	20b770        	or	a11, a7, a7
42004d62:	04a030        	extui	a10, a3, 0, 1
42004d65:	ff2e25        	call8	42004048 <memprot_ll_iram0_set_pms_area_0>
        break;
    default:
        return ESP_ERR_NOT_SUPPORTED;
    }

    return ESP_OK;
42004d68:	00a022        	movi	a2, 0
        break;
42004d6b:	0036c6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_1(r, w, x);
42004d6e:	06cd      	mov.n	a12, a6
42004d70:	07bd      	mov.n	a11, a7
42004d72:	04a030        	extui	a10, a3, 0, 1
42004d75:	ff30a5        	call8	42004080 <memprot_ll_iram0_set_pms_area_1>
    return ESP_OK;
42004d78:	020c      	movi.n	a2, 0
        break;
42004d7a:	003306        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_2(r, w, x);
42004d7d:	20c660        	or	a12, a6, a6
42004d80:	20b770        	or	a11, a7, a7
42004d83:	04a030        	extui	a10, a3, 0, 1
42004d86:	ff33a5        	call8	420040c0 <memprot_ll_iram0_set_pms_area_2>
    return ESP_OK;
42004d89:	00a022        	movi	a2, 0
        break;
42004d8c:	002e86        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
        memprot_ll_iram0_set_pms_area_3(r, w, x);
42004d8f:	20c660        	or	a12, a6, a6
42004d92:	20b770        	or	a11, a7, a7
42004d95:	04a030        	extui	a10, a3, 0, 1
42004d98:	ff3665        	call8	42004100 <memprot_ll_iram0_set_pms_area_3>
    return ESP_OK;
42004d9b:	00a022        	movi	a2, 0
        break;
42004d9e:	002a06        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
        memprot_ll_dram0_set_pms_area_0(r, w);
42004da1:	07bd      	mov.n	a11, a7
42004da3:	04a030        	extui	a10, a3, 0, 1
42004da6:	ff9625        	call8	42004708 <memprot_ll_dram0_set_pms_area_0>
    return ESP_OK;
42004da9:	020c      	movi.n	a2, 0
        break;
42004dab:	0026c6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004dae:	000000        	ill
        memprot_ll_dram0_set_pms_area_1(r, w);
42004db1:	07bd      	mov.n	a11, a7
42004db3:	04a030        	extui	a10, a3, 0, 1
42004db6:	ff9865        	call8	4200473c <memprot_ll_dram0_set_pms_area_1>
    return ESP_OK;
42004db9:	020c      	movi.n	a2, 0
        break;
42004dbb:	0022c6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004dbe:	000000        	ill
        memprot_ll_dram0_set_pms_area_2(r, w);
42004dc1:	07bd      	mov.n	a11, a7
42004dc3:	04a030        	extui	a10, a3, 0, 1
42004dc6:	ff9ae5        	call8	42004774 <memprot_ll_dram0_set_pms_area_2>
    return ESP_OK;
42004dc9:	020c      	movi.n	a2, 0
        break;
42004dcb:	001ec6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004dce:	000000        	ill
        memprot_ll_dram0_set_pms_area_3(r, w);
42004dd1:	07bd      	mov.n	a11, a7
42004dd3:	04a030        	extui	a10, a3, 0, 1
42004dd6:	ff9d65        	call8	420047ac <memprot_ll_dram0_set_pms_area_3>
    return ESP_OK;
42004dd9:	020c      	movi.n	a2, 0
        break;
42004ddb:	001ac6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004dde:	000000        	ill
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004de1:	20a440        	or	a10, a4, a4
42004de4:	ffb4a5        	call8	42004930 <esp_mprot_cpuid_valid>
42004de7:	0a2d      	mov.n	a2, a10
42004de9:	05da56        	bnez	a10, 42004e4a <esp_mprot_set_pms_area+0x16a>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_LOW)))
42004dec:	1f0c      	movi.n	a15, 1
42004dee:	0fed      	mov.n	a14, a15
42004df0:	06dd      	mov.n	a13, a6
42004df2:	07cd      	mov.n	a12, a7
42004df4:	10b3f0        	and	a11, a3, a15
42004df7:	04ad      	mov.n	a10, a4
42004df9:	ff54a5        	call8	42004344 <memprot_ll_rtcfast_set_pms_area>
42004dfc:	00e4a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004dff:	0a2d      	mov.n	a2, a10
42004e01:	001146        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004e04:	400000        	ssr	a0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004e07:	a4          	.byte	0xa4
42004e08:	b26520        	mulsh	a6, a5, a2
42004e0b:	560a2dff 	ee.vmulas.u16.qacc.ld.ip.qup	q5, a15, 0x1d0, q4, q4, q0, q2
42004e0f:	038a      	add.n	a0, a3, a8
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
42004e11:	2f0c      	movi.n	a15, 2
42004e13:	1e0c      	movi.n	a14, 1
42004e15:	20d660        	or	a13, a6, a6
42004e18:	20c770        	or	a12, a7, a7
42004e1b:	10b3e0        	and	a11, a3, a14
42004e1e:	04ad      	mov.n	a10, a4
42004e20:	ff5225        	call8	42004344 <memprot_ll_rtcfast_set_pms_area>
42004e23:	00e265        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004e26:	0a2d      	mov.n	a2, a10
42004e28:	000786        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
42004e2b:	c66000        	ee.ldf.64.xp	f6, f12, a0, a0
        memprot_ll_icache_set_pms_area_0(r, w, x);
42004e2e:	b77020        	ee.stf.64.xp	f7, f11, a2, a0
42004e31:	a03020        	addx4	a3, a0, a2
42004e34:	04          	.byte	0x4
42004e35:	ff0ca5        	call8	42003f00 <memprot_ll_icache_set_pms_area_0>
    return ESP_OK;
42004e38:	00a022        	movi	a2, 0
        break;
42004e3b:	0002c6        	j	42004e4a <esp_mprot_set_pms_area+0x16a>
        memprot_ll_icache_set_pms_area_1(r, w, x);
42004e3e:	06cd      	mov.n	a12, a6
42004e40:	07bd      	mov.n	a11, a7
42004e42:	04a030        	extui	a10, a3, 0, 1
42004e45:	ff0fa5        	call8	42003f40 <memprot_ll_icache_set_pms_area_1>
    return ESP_OK;
42004e48:	020c      	movi.n	a2, 0
}
42004e4a:	f01d      	retw.n

42004e4c <esp_mprot_get_pms_area>:

esp_err_t esp_mprot_get_pms_area(const esp_mprot_pms_area_t area_type, uint32_t *flags, const int core __attribute__((unused)))
{
42004e4c:	006136        	entry	a1, 48
    if (flags == NULL) {
42004e4f:	209316        	beqz	a3, 4200505c <esp_mprot_get_pms_area+0x210>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    bool r = false;
42004e52:	080c      	movi.n	a8, 0
42004e54:	004182        	s8i	a8, a1, 0
    bool w = false;
42004e57:	014182        	s8i	a8, a1, 1
    bool x = false;
42004e5a:	024182        	s8i	a8, a1, 2

    switch (area_type) {
42004e5d:	02d266        	bnei	a2, 64, 42004e63 <esp_mprot_get_pms_area+0x17>
42004e60:	004406        	j	42004f74 <esp_mprot_get_pms_area+0x128>
42004e63:	084c      	movi.n	a8, 64
42004e65:	2e3827        	bltu	a8, a2, 42004e97 <esp_mprot_get_pms_area+0x4b>
42004e68:	028266        	bnei	a2, 8, 42004e6e <esp_mprot_get_pms_area+0x22>
42004e6b:	002e46        	j	42004f28 <esp_mprot_get_pms_area+0xdc>
42004e6e:	880c      	movi.n	a8, 8
42004e70:	113827        	bltu	a8, a2, 42004e85 <esp_mprot_get_pms_area+0x39>
42004e73:	752226        	beqi	a2, 2, 42004eec <esp_mprot_get_pms_area+0xa0>
42004e76:	024266        	bnei	a2, 4, 42004e7c <esp_mprot_get_pms_area+0x30>
42004e79:	002306        	j	42004f09 <esp_mprot_get_pms_area+0xbd>
42004e7c:	4d1226        	beqi	a2, 1, 42004ecd <esp_mprot_get_pms_area+0x81>
42004e7f:	edfe21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004e82:	007786        	j	42005064 <esp_mprot_get_pms_area+0x218>
42004e85:	02b266        	bnei	a2, 16, 42004e8b <esp_mprot_get_pms_area+0x3f>
42004e88:	002e46        	j	42004f45 <esp_mprot_get_pms_area+0xf9>
42004e8b:	02c266        	bnei	a2, 32, 42004e91 <esp_mprot_get_pms_area+0x45>
42004e8e:	003286        	j	42004f5c <esp_mprot_get_pms_area+0x110>
42004e91:	edf921        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004e94:	007306        	j	42005064 <esp_mprot_get_pms_area+0x218>
42004e97:	00a282        	movi	a8, 0x200
42004e9a:	029287        	bne	a2, a8, 42004ea0 <esp_mprot_get_pms_area+0x54>
42004e9d:	004a86        	j	42004fcb <esp_mprot_get_pms_area+0x17f>
42004ea0:	113827        	bltu	a8, a2, 42004eb5 <esp_mprot_get_pms_area+0x69>
42004ea3:	02e266        	bnei	a2, 128, 42004ea9 <esp_mprot_get_pms_area+0x5d>
42004ea6:	003886        	j	42004f8c <esp_mprot_get_pms_area+0x140>
42004ea9:	02f266        	bnei	a2, 0x100, 42004eaf <esp_mprot_get_pms_area+0x63>
42004eac:	003d86        	j	42004fa6 <esp_mprot_get_pms_area+0x15a>
42004eaf:	edf221        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004eb2:	006b86        	j	42005064 <esp_mprot_get_pms_area+0x218>
42004eb5:	00a482        	movi	a8, 0x400
42004eb8:	029287        	bne	a2, a8, 42004ebe <esp_mprot_get_pms_area+0x72>
42004ebb:	004c86        	j	42004ff1 <esp_mprot_get_pms_area+0x1a5>
42004ebe:	edba81        	l32r	a8, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
42004ec1:	029287        	bne	a2, a8, 42004ec7 <esp_mprot_get_pms_area+0x7b>
42004ec4:	005206        	j	42005010 <esp_mprot_get_pms_area+0x1c4>
42004ec7:	edec21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
42004eca:	006586        	j	42005064 <esp_mprot_get_pms_area+0x218>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
42004ecd:	edc781        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004ed0:	0020c0        	memw
42004ed3:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004ed5:	049080        	extui	a9, a8, 0, 1
42004ed8:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004edb:	049180        	extui	a9, a8, 1, 1
42004ede:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004ee1:	048280        	extui	a8, a8, 2, 1
42004ee4:	024182        	s8i	a8, a1, 2
}
42004ee7:	004fc6        	j	4200502a <esp_mprot_get_pms_area+0x1de>
42004eea:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42004eed:	c0edc0        	sub	a14, a13, a12
42004ef0:	20          	.byte	0x20
42004ef1:	088800        	lsx	f8, a8, a0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004ef4:	049380        	extui	a9, a8, 3, 1
42004ef7:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004efa:	049480        	extui	a9, a8, 4, 1
42004efd:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004f00:	048580        	extui	a8, a8, 5, 1
42004f03:	024182        	s8i	a8, a1, 2
}
42004f06:	004806        	j	4200502a <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
42004f09:	edb881        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004f0c:	0020c0        	memw
42004f0f:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004f11:	049680        	extui	a9, a8, 6, 1
42004f14:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004f17:	049780        	extui	a9, a8, 7, 1
42004f1a:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004f1d:	048880        	extui	a8, a8, 8, 1
42004f20:	024182        	s8i	a8, a1, 2
}
42004f23:	0040c6        	j	4200502a <esp_mprot_get_pms_area+0x1de>
42004f26:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
42004f29:	c0edb1        	l32r	a11, 41ff52e0 <_iram_bss_end+0x1c72ee0>
42004f2c:	20          	.byte	0x20
42004f2d:	088800        	lsx	f8, a8, a0
    *r = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004f30:	049980        	extui	a9, a8, 9, 1
42004f33:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004f36:	049a80        	extui	a9, a8, 10, 1
42004f39:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42004f3c:	048b80        	extui	a8, a8, 11, 1
42004f3f:	024182        	s8i	a8, a1, 2
}
42004f42:	003906        	j	4200502a <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
42004f45:	edc381        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
42004f48:	0020c0        	memw
42004f4b:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004f4d:	049080        	extui	a9, a8, 0, 1
42004f50:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004f53:	048180        	extui	a8, a8, 1, 1
42004f56:	014182        	s8i	a8, a1, 1
}
42004f59:	003346        	j	4200502a <esp_mprot_get_pms_area+0x1de>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42004f5c:	edbe81        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
42004f5f:	0020c0        	memw
42004f62:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004f64:	049280        	extui	a9, a8, 2, 1
42004f67:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004f6a:	048380        	extui	a8, a8, 3, 1
42004f6d:	014182        	s8i	a8, a1, 1
}
42004f70:	002d86        	j	4200502a <esp_mprot_get_pms_area+0x1de>
42004f73:	00          	.byte	00
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
42004f74:	edb881        	l32r	a8, 42000654 <_stext+0x634> (600c1100 <SYSTEM+0x1100>)
42004f77:	0020c0        	memw
42004f7a:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004f7c:	049480        	extui	a9, a8, 4, 1
42004f7f:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004f82:	048580        	extui	a8, a8, 5, 1
42004f85:	014182        	s8i	a8, a1, 1
}
42004f88:	002786        	j	4200502a <esp_mprot_get_pms_area+0x1de>
42004f8b:	b28100        	mulsh	a8, a1, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
42004f8e:	ed          	.byte	0xed
42004f8f:	0020c0        	memw
42004f92:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004f94:	049680        	extui	a9, a8, 6, 1
42004f97:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004f9a:	048780        	extui	a8, a8, 7, 1
42004f9d:	014182        	s8i	a8, a1, 1
}
42004fa0:	002186        	j	4200502a <esp_mprot_get_pms_area+0x1de>
42004fa3:	000000        	ill
        break;
    case MEMPROT_PMS_AREA_DRAM0_3:
        memprot_ll_dram0_get_pms_area_3(&r, &w);
        break;
    case MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004fa6:	20a440        	or	a10, a4, a4
42004fa9:	ff9865        	call8	42004930 <esp_mprot_cpuid_valid>
42004fac:	0a2d      	mov.n	a2, a10
42004fae:	0b2a56        	bnez	a10, 42005064 <esp_mprot_get_pms_area+0x218>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_LOW)))
42004fb1:	1f0c      	movi.n	a15, 1
42004fb3:	0fed      	mov.n	a14, a15
42004fb5:	d12b      	addi.n	a13, a1, 2
42004fb7:	c1fa      	add.n	a12, a1, a15
42004fb9:	01bd      	mov.n	a11, a1
42004fbb:	04ad      	mov.n	a10, a4
42004fbd:	ff4625        	call8	42004420 <memprot_ll_rtcfast_get_pms_area>
42004fc0:	00c865        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004fc3:	0a2d      	mov.n	a2, a10
42004fc5:	061a16        	beqz	a10, 4200502a <esp_mprot_get_pms_area+0x1de>
42004fc8:	002606        	j	42005064 <esp_mprot_get_pms_area+0x218>
        break;
    case MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42004fcb:	20a440        	or	a10, a4, a4
42004fce:	ff9625        	call8	42004930 <esp_mprot_cpuid_valid>
42004fd1:	0a2d      	mov.n	a2, a10
42004fd3:	08da56        	bnez	a10, 42005064 <esp_mprot_get_pms_area+0x218>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
42004fd6:	2f0c      	movi.n	a15, 2
42004fd8:	1e0c      	movi.n	a14, 1
42004fda:	d1fa      	add.n	a13, a1, a15
42004fdc:	c1ea      	add.n	a12, a1, a14
42004fde:	20b110        	or	a11, a1, a1
42004fe1:	20a440        	or	a10, a4, a4
42004fe4:	ff43a5        	call8	42004420 <memprot_ll_rtcfast_get_pms_area>
42004fe7:	00c625        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42004fea:	0a2d      	mov.n	a2, a10
42004fec:	aabc      	beqz.n	a10, 4200502a <esp_mprot_get_pms_area+0x1de>
42004fee:	001c86        	j	42005064 <esp_mprot_get_pms_area+0x218>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
42004ff1:	ed7e81        	l32r	a8, 420005ec <_stext+0x5cc> (600c10e0 <SYSTEM+0x10e0>)
42004ff4:	0020c0        	memw
42004ff7:	0888      	l32i.n	a8, a8, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42004ff9:	049c80        	extui	a9, a8, 12, 1
42004ffc:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42004fff:	049d80        	extui	a9, a8, 13, 1
42005002:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42005005:	048e80        	extui	a8, a8, 14, 1
42005008:	024182        	s8i	a8, a1, 2
}
4200500b:	0006c6        	j	4200502a <esp_mprot_get_pms_area+0x1de>
4200500e:	810000        	src	a0, a0, a0
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
42005011:	c0ed77        	bbsi	a13, 7, 42004fd5 <esp_mprot_get_pms_area+0x189>
42005014:	20          	.byte	0x20
42005015:	088800        	lsx	f8, a8, a0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42005018:	049f80        	extui	a9, a8, 15, 1
4200501b:	004192        	s8i	a9, a1, 0
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
4200501e:	059080        	extui	a9, a8, 16, 1
42005021:	014192        	s8i	a9, a1, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42005024:	058180        	extui	a8, a8, 17, 1
42005027:	024182        	s8i	a8, a1, 2
        break;
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    *flags = 0;
4200502a:	080c      	movi.n	a8, 0
4200502c:	0389      	s32i.n	a8, a3, 0
    if (r) {
4200502e:	000182        	l8ui	a8, a1, 0
42005031:	388c      	beqz.n	a8, 42005038 <esp_mprot_get_pms_area+0x1ec>
        *flags |= MEMPROT_OP_READ;
42005033:	01a082        	movi	a8, 1
42005036:	0389      	s32i.n	a8, a3, 0
    }
    if (w) {
42005038:	010182        	l8ui	a8, a1, 1
4200503b:	988c      	beqz.n	a8, 42005048 <esp_mprot_get_pms_area+0x1fc>
        *flags |= MEMPROT_OP_WRITE;
4200503d:	0388      	l32i.n	a8, a3, 0
4200503f:	02a092        	movi	a9, 2
42005042:	208890        	or	a8, a8, a9
42005045:	006382        	s32i	a8, a3, 0
    }
    if (x) {
42005048:	020182        	l8ui	a8, a1, 2
4200504b:	389c      	beqz.n	a8, 42005062 <esp_mprot_get_pms_area+0x216>
        *flags |= MEMPROT_OP_EXEC;
4200504d:	0388      	l32i.n	a8, a3, 0
4200504f:	490c      	movi.n	a9, 4
42005051:	208890        	or	a8, a8, a9
42005054:	0389      	s32i.n	a8, a3, 0
    }

    return ESP_OK;
42005056:	020c      	movi.n	a2, 0
42005058:	000206        	j	42005064 <esp_mprot_get_pms_area+0x218>
4200505b:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4200505e:	004602        	s8i	a0, a6, 0
42005061:	020c00        	andb	b0, b12, b0
}
42005064:	f01d      	retw.n
	...

42005068 <esp_mprot_set_monitor_lock>:

esp_err_t esp_mprot_set_monitor_lock(const esp_mprot_mem_t mem_type, const int core)
{
42005068:	004136        	entry	a1, 32
4200506b:	207220        	or	a7, a2, a2
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
4200506e:	20a330        	or	a10, a3, a3
42005071:	ff8be5        	call8	42004930 <esp_mprot_cpuid_valid>
42005074:	202aa0        	or	a2, a10, a10
42005077:	0a1a56        	bnez	a10, 4200511c <esp_mprot_set_monitor_lock+0xb4>

    switch (mem_type) {
4200507a:	382726        	beqi	a7, 2, 420050b6 <esp_mprot_set_monitor_lock+0x4e>
4200507d:	654726        	beqi	a7, 4, 420050e6 <esp_mprot_set_monitor_lock+0x7e>
42005080:	021726        	beqi	a7, 1, 42005086 <esp_mprot_set_monitor_lock+0x1e>
42005083:	002486        	j	42005119 <esp_mprot_set_monitor_lock+0xb1>
    switch (core) {
42005086:	638c      	beqz.n	a3, 42005090 <esp_mprot_set_monitor_lock+0x28>
42005088:	111326        	beqi	a3, 1, 4200509d <esp_mprot_set_monitor_lock+0x35>
4200508b:	730c      	movi.n	a3, 7
4200508d:	0006c6        	j	420050ac <esp_mprot_set_monitor_lock+0x44>
            REG_WRITE(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG, 1);
42005090:	ed5f81        	l32r	a8, 4200060c <_stext+0x5ec> (600c10e4 <SYSTEM+0x10e4>)
42005093:	190c      	movi.n	a9, 1
42005095:	0020c0        	memw
42005098:	0899      	s32i.n	a9, a8, 0
            break;
4200509a:	000386        	j	420050ac <esp_mprot_set_monitor_lock+0x44>
            REG_WRITE(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG, 1);
4200509d:	ed5c81        	l32r	a8, 42000610 <_stext+0x5f0> (600c10f0 <SYSTEM+0x10f0>)
420050a0:	01a092        	movi	a9, 1
420050a3:	0020c0        	memw
420050a6:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
420050a9:	203aa0        	or	a3, a10, a10
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_lock(core)))
420050ac:	03ad      	mov.n	a10, a3
420050ae:	00b9a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
420050b1:	0a2d      	mov.n	a2, a10
420050b3:	001946        	j	4200511c <esp_mprot_set_monitor_lock+0xb4>
    switch (core) {
420050b6:	638c      	beqz.n	a3, 420050c0 <esp_mprot_set_monitor_lock+0x58>
420050b8:	111326        	beqi	a3, 1, 420050cd <esp_mprot_set_monitor_lock+0x65>
420050bb:	730c      	movi.n	a3, 7
420050bd:	0006c6        	j	420050dc <esp_mprot_set_monitor_lock+0x74>
            REG_WRITE(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG, 1);
420050c0:	ed6681        	l32r	a8, 42000658 <_stext+0x638> (600c1104 <SYSTEM+0x1104>)
420050c3:	190c      	movi.n	a9, 1
420050c5:	0020c0        	memw
420050c8:	0899      	s32i.n	a9, a8, 0
            break;
420050ca:	000386        	j	420050dc <esp_mprot_set_monitor_lock+0x74>
            REG_WRITE(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG, 1);
420050cd:	ed6381        	l32r	a8, 4200065c <_stext+0x63c> (600c1114 <SYSTEM+0x1114>)
420050d0:	01a092        	movi	a9, 1
420050d3:	0020c0        	memw
420050d6:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
420050d9:	203aa0        	or	a3, a10, a10
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_lock(core)))
420050dc:	03ad      	mov.n	a10, a3
420050de:	00b6a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
420050e1:	0a2d      	mov.n	a2, a10
420050e3:	000d46        	j	4200511c <esp_mprot_set_monitor_lock+0xb4>
    switch (core) {
420050e6:	638c      	beqz.n	a3, 420050f0 <esp_mprot_set_monitor_lock+0x88>
420050e8:	111326        	beqi	a3, 1, 420050fd <esp_mprot_set_monitor_lock+0x95>
420050eb:	730c      	movi.n	a3, 7
420050ed:	0006c6        	j	4200510c <esp_mprot_set_monitor_lock+0xa4>
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG, 1);
420050f0:	ed5381        	l32r	a8, 4200063c <_stext+0x61c> (600c119c <SYSTEM+0x119c>)
420050f3:	190c      	movi.n	a9, 1
420050f5:	0020c0        	memw
420050f8:	0899      	s32i.n	a9, a8, 0
            break;
420050fa:	000386        	j	4200510c <esp_mprot_set_monitor_lock+0xa4>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG, 1);
420050fd:	ed5081        	l32r	a8, 42000640 <_stext+0x620> (600c1248 <SYSTEM+0x1248>)
42005100:	01a092        	movi	a9, 1
42005103:	0020c0        	memw
42005106:	006892        	s32i	a9, a8, 0
    return MEMP_HAL_OK;
42005109:	203aa0        	or	a3, a10, a10
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_lock(core)))
4200510c:	03ad      	mov.n	a10, a3
4200510e:	00b3a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42005111:	0a2d      	mov.n	a2, a10
42005113:	000146        	j	4200511c <esp_mprot_set_monitor_lock+0xb4>
42005116:	000000        	ill
    switch (mem_type) {
42005119:	ed5721        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
4200511c:	f01d      	retw.n
	...

42005120 <esp_mprot_get_monitor_lock>:

esp_err_t esp_mprot_get_monitor_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core)
{
42005120:	004136        	entry	a1, 32
42005123:	207220        	or	a7, a2, a2
    if (locked == NULL) {
42005126:	04a316        	beqz	a3, 42005174 <esp_mprot_get_monitor_lock+0x54>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42005129:	20a440        	or	a10, a4, a4
4200512c:	ff8025        	call8	42004930 <esp_mprot_cpuid_valid>
4200512f:	0a2d      	mov.n	a2, a10
42005131:	04ba56        	bnez	a10, 42005180 <esp_mprot_get_monitor_lock+0x60>

    switch (mem_type) {
42005134:	162726        	beqi	a7, 2, 4200514e <esp_mprot_get_monitor_lock+0x2e>
42005137:	274726        	beqi	a7, 4, 42005162 <esp_mprot_get_monitor_lock+0x42>
4200513a:	3f1766        	bnei	a7, 1, 4200517d <esp_mprot_get_monitor_lock+0x5d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_monitor_lock(core, locked)))
4200513d:	03bd      	mov.n	a11, a3
4200513f:	04ad      	mov.n	a10, a4
42005141:	feffe5        	call8	42004140 <memprot_ll_iram0_get_monitor_lock>
42005144:	00b025        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42005147:	0a2d      	mov.n	a2, a10
42005149:	000cc6        	j	42005180 <esp_mprot_get_monitor_lock+0x60>
4200514c:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_monitor_lock(core, locked)))
4200514f:	b3          	.byte	0xb3
42005150:	a44020        	extui	a4, a2, 0, 11
42005153:	20          	.byte	0x20
42005154:	ff68a5        	call8	420047e0 <memprot_ll_dram0_get_monitor_lock>
42005157:	00af25        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
4200515a:	0a2d      	mov.n	a2, a10
4200515c:	000806        	j	42005180 <esp_mprot_get_monitor_lock+0x60>
4200515f:	000000        	ill
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_lock(core, locked)))
42005162:	20b330        	or	a11, a3, a3
42005165:	20a440        	or	a10, a4, a4
42005168:	ff37a5        	call8	420044e4 <memprot_ll_rtcfast_get_monitor_lock>
4200516b:	00ade5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
4200516e:	0a2d      	mov.n	a2, a10
42005170:	000306        	j	42005180 <esp_mprot_get_monitor_lock+0x60>
42005173:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42005176:	014602        	s8i	a0, a6, 1
42005179:	000000        	ill
4200517c:	00          	.byte	00
    switch (mem_type) {
4200517d:	ed3e21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
42005180:	f01d      	retw.n
	...

42005184 <esp_mprot_set_monitor_en>:

esp_err_t esp_mprot_set_monitor_en(const esp_mprot_mem_t mem_type, const bool enable, const int core)
{
42005184:	004136        	entry	a1, 32
42005187:	207220        	or	a7, a2, a2
4200518a:	743030        	extui	a3, a3, 0, 8
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
4200518d:	20a440        	or	a10, a4, a4
42005190:	ff79e5        	call8	42004930 <esp_mprot_cpuid_valid>
42005193:	0a2d      	mov.n	a2, a10
42005195:	03fa56        	bnez	a10, 420051d8 <esp_mprot_set_monitor_en+0x54>

    switch (mem_type) {
42005198:	162726        	beqi	a7, 2, 420051b2 <esp_mprot_set_monitor_en+0x2e>
4200519b:	244726        	beqi	a7, 4, 420051c3 <esp_mprot_set_monitor_en+0x3f>
4200519e:	331766        	bnei	a7, 1, 420051d5 <esp_mprot_set_monitor_en+0x51>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_en(core, enable)))
420051a1:	03bd      	mov.n	a11, a3
420051a3:	04ad      	mov.n	a10, a4
420051a5:	fefd65        	call8	4200417c <memprot_ll_iram0_set_monitor_en>
420051a8:	00a9e5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
420051ab:	0a2d      	mov.n	a2, a10
420051ad:	0009c6        	j	420051d8 <esp_mprot_set_monitor_en+0x54>
420051b0:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_en(core, enable)))
420051b3:	b3          	.byte	0xb3
420051b4:	a44020        	extui	a4, a2, 0, 11
420051b7:	662520        	ee.ldf.64.xp	f2, f6, a2, a5
420051ba:	00a8e5ff 	ee.vmulas.s16.accx.ld.ip.qup	q1, a15, 80, q7, q5, q2, q0
420051be:	0a2d      	mov.n	a2, a10
420051c0:	000506        	j	420051d8 <esp_mprot_set_monitor_en+0x54>
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_en(core, enable)))
420051c3:	20b330        	or	a11, a3, a3
420051c6:	20a440        	or	a10, a4, a4
420051c9:	ff3565        	call8	42004520 <memprot_ll_rtcfast_set_monitor_en>
420051cc:	00a7a5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
420051cf:	0a2d      	mov.n	a2, a10
420051d1:	0000c6        	j	420051d8 <esp_mprot_set_monitor_en+0x54>
420051d4:	00          	.byte	00
    switch (mem_type) {
420051d5:	ed2821        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
420051d8:	f01d      	retw.n
	...

420051dc <esp_mprot_get_monitor_en>:

esp_err_t esp_mprot_get_monitor_en(esp_mprot_mem_t mem_type, bool *enabled, const int core)
{
420051dc:	004136        	entry	a1, 32
420051df:	207220        	or	a7, a2, a2
    if (enabled == NULL) {
420051e2:	04a316        	beqz	a3, 42005230 <esp_mprot_get_monitor_en+0x54>
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420051e5:	20a440        	or	a10, a4, a4
420051e8:	ff7465        	call8	42004930 <esp_mprot_cpuid_valid>
420051eb:	0a2d      	mov.n	a2, a10
420051ed:	04ba56        	bnez	a10, 4200523c <esp_mprot_get_monitor_en+0x60>

    switch (mem_type) {
420051f0:	162726        	beqi	a7, 2, 4200520a <esp_mprot_get_monitor_en+0x2e>
420051f3:	274726        	beqi	a7, 4, 4200521e <esp_mprot_get_monitor_en+0x42>
420051f6:	3f1766        	bnei	a7, 1, 42005239 <esp_mprot_get_monitor_en+0x5d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_monitor_en(core, enabled)))
420051f9:	03bd      	mov.n	a11, a3
420051fb:	04ad      	mov.n	a10, a4
420051fd:	fefe65        	call8	420041e4 <memprot_ll_iram0_get_monitor_en>
42005200:	00a465        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42005203:	0a2d      	mov.n	a2, a10
42005205:	000cc6        	j	4200523c <esp_mprot_get_monitor_en+0x60>
42005208:	300000        	xor	a0, a0, a0
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_monitor_en(core, enabled)))
4200520b:	b3          	.byte	0xb3
4200520c:	a44020        	extui	a4, a2, 0, 11
4200520f:	672520        	ee.stf.64.xp	f2, f6, a2, a5
42005212:	00a365ff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 80, q5, q5, q2, q3
42005216:	0a2d      	mov.n	a2, a10
42005218:	000806        	j	4200523c <esp_mprot_get_monitor_en+0x60>
4200521b:	000000        	ill
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_en(core, enabled)))
4200521e:	20b330        	or	a11, a3, a3
42005221:	20a440        	or	a10, a4, a4
42005224:	ff3665        	call8	4200458c <memprot_ll_rtcfast_get_monitor_en>
42005227:	00a225        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
4200522a:	0a2d      	mov.n	a2, a10
4200522c:	000306        	j	4200523c <esp_mprot_get_monitor_en+0x60>
4200522f:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42005232:	014602        	s8i	a0, a6, 1
42005235:	000000        	ill
42005238:	00          	.byte	00
    switch (mem_type) {
42005239:	ed0f21        	l32r	a2, 42000678 <_stext+0x658> (d001 <UserFrameTotalSize+0xcf01>)
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
4200523c:	f01d      	retw.n
	...

42005240 <esp_mprot_monitor_clear_intr>:

    return ESP_OK;
}

esp_err_t esp_mprot_monitor_clear_intr(esp_mprot_mem_t mem_type, const int core)
{
42005240:	004136        	entry	a1, 32
42005243:	027d      	mov.n	a7, a2
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42005245:	03ad      	mov.n	a10, a3
42005247:	ff6ea5        	call8	42004930 <esp_mprot_cpuid_valid>
4200524a:	0a2d      	mov.n	a2, a10
4200524c:	060a56        	bnez	a10, 420052b0 <esp_mprot_monitor_clear_intr+0x70>

    switch (mem_type) {
4200524f:	212726        	beqi	a7, 2, 42005274 <esp_mprot_monitor_clear_intr+0x34>
42005252:	3a4726        	beqi	a7, 4, 42005290 <esp_mprot_monitor_clear_intr+0x50>
42005255:	541766        	bnei	a7, 1, 420052ad <esp_mprot_monitor_clear_intr+0x6d>
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_intrclr(core)))
42005258:	20a330        	or	a10, a3, a3
4200525b:	fefbe5        	call8	42004218 <memprot_ll_iram0_set_monitor_intrclr>
4200525e:	009ea5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42005261:	0a2d      	mov.n	a2, a10
42005263:	049a56        	bnez	a10, 420052b0 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_reset_monitor_intrclr(core)))
42005266:	03ad      	mov.n	a10, a3
42005268:	fefea5        	call8	42004254 <memprot_ll_iram0_reset_monitor_intrclr>
4200526b:	009de5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
4200526e:	0a2d      	mov.n	a2, a10
42005270:	000f06        	j	420052b0 <esp_mprot_monitor_clear_intr+0x70>
42005273:	00          	.byte	00
        break;
    case MEMPROT_TYPE_DRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_intrclr(core)))
42005274:	03ad      	mov.n	a10, a3
42005276:	ff6425        	call8	420048b8 <memprot_ll_dram0_set_monitor_intrclr>
42005279:	009ce5        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
4200527c:	202aa0        	or	a2, a10, a10
4200527f:	daec      	bnez.n	a10, 420052b0 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_reset_monitor_intrclr(core)))
42005281:	20a330        	or	a10, a3, a3
42005284:	ff66e5        	call8	420048f4 <memprot_ll_dram0_reset_monitor_intrclr>
42005287:	009c25        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
4200528a:	0a2d      	mov.n	a2, a10
4200528c:	000806        	j	420052b0 <esp_mprot_monitor_clear_intr+0x70>
4200528f:	00          	.byte	00
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_intrclr(core)))
42005290:	03ad      	mov.n	a10, a3
42005292:	ff32e5        	call8	420045c0 <memprot_ll_rtcfast_set_monitor_intrclr>
42005295:	009b25        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
42005298:	0a2d      	mov.n	a2, a10
4200529a:	012a56        	bnez	a10, 420052b0 <esp_mprot_monitor_clear_intr+0x70>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_reset_monitor_intrclr(core)))
4200529d:	20a330        	or	a10, a3, a3
420052a0:	ff35a5        	call8	420045fc <memprot_ll_rtcfast_reset_monitor_intrclr>
420052a3:	009a65        	call8	42005c48 <esp_mprot_ll_err_to_esp_err>
420052a6:	0a2d      	mov.n	a2, a10
420052a8:	000106        	j	420052b0 <esp_mprot_monitor_clear_intr+0x70>
420052ab:	210000        	srai	a0, a0, 0
    switch (mem_type) {
420052ae:	1decf2        	s32c1i	a15, a12, 116
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
420052b1:	0000f0        	callx12	a0

420052b4 <esp_mprot_is_conf_locked_any>:

esp_err_t esp_mprot_is_conf_locked_any(bool *locked)
{
420052b4:	006136        	entry	a1, 48
420052b7:	027d      	mov.n	a7, a2
    if (locked == NULL) {
420052b9:	173216        	beqz	a2, 42005430 <esp_mprot_is_conf_locked_any+0x17c>
        return ESP_ERR_INVALID_ARG;
    }

    bool lock_on = false;
420052bc:	080c      	movi.n	a8, 0
420052be:	004182        	s8i	a8, a1, 0
    esp_err_t err;

    //IRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM) {
420052c1:	ecea81        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
420052c4:	2888      	l32i.n	a8, a8, 8
420052c6:	6f6807        	bbci	a8, 0, 42005339 <esp_mprot_is_conf_locked_any+0x85>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
420052c9:	fc7c      	movi.n	a12, -1
420052cb:	01bd      	mov.n	a11, a1
420052cd:	1a0c      	movi.n	a10, 1
420052cf:	ff8da5        	call8	42004ba8 <esp_mprot_get_split_addr_lock>
420052d2:	0a2d      	mov.n	a2, a10
420052d4:	160a56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
420052d7:	000782        	l8ui	a8, a7, 0
420052da:	000192        	l8ui	a9, a1, 0
420052dd:	208890        	or	a8, a8, a9
420052e0:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
420052e3:	fc7c      	movi.n	a12, -1
420052e5:	01bd      	mov.n	a11, a1
420052e7:	1a0c      	movi.n	a10, 1
420052e9:	ff98a5        	call8	42004c74 <esp_mprot_get_pms_lock>
420052ec:	0a2d      	mov.n	a2, a10
420052ee:	146a56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
420052f1:	000782        	l8ui	a8, a7, 0
420052f4:	000192        	l8ui	a9, a1, 0
420052f7:	208890        	or	a8, a8, a9
420052fa:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, PRO_CPU_NUM))
420052fd:	0c0c      	movi.n	a12, 0
420052ff:	01bd      	mov.n	a11, a1
42005301:	1a0c      	movi.n	a10, 1
42005303:	ffe1e5        	call8	42005120 <esp_mprot_get_monitor_lock>
42005306:	0a2d      	mov.n	a2, a10
42005308:	12ca56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
4200530b:	000782        	l8ui	a8, a7, 0
4200530e:	000192        	l8ui	a9, a1, 0
42005311:	208890        	or	a8, a8, a9
42005314:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
42005317:	ecd581        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
4200531a:	3888      	l32i.n	a8, a8, 12
4200531c:	1928b6        	bltui	a8, 2, 42005339 <esp_mprot_is_conf_locked_any+0x85>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, APP_CPU_NUM))
4200531f:	1c0c      	movi.n	a12, 1
42005321:	01bd      	mov.n	a11, a1
42005323:	0cad      	mov.n	a10, a12
42005325:	ffdfa5        	call8	42005120 <esp_mprot_get_monitor_lock>
42005328:	0a2d      	mov.n	a2, a10
4200532a:	10aa56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
4200532d:	000782        	l8ui	a8, a7, 0
42005330:	000192        	l8ui	a9, a1, 0
42005333:	208890        	or	a8, a8, a9
42005336:	004782        	s8i	a8, a7, 0
        }
    }

    //DRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM) {
42005339:	eccc81        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
4200533c:	2888      	l32i.n	a8, a8, 8
4200533e:	706817        	bbci	a8, 1, 420053b2 <esp_mprot_is_conf_locked_any+0xfe>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
42005341:	fc7c      	movi.n	a12, -1
42005343:	01bd      	mov.n	a11, a1
42005345:	2a0c      	movi.n	a10, 2
42005347:	ff8625        	call8	42004ba8 <esp_mprot_get_split_addr_lock>
4200534a:	0a2d      	mov.n	a2, a10
4200534c:	0e8a56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
4200534f:	000782        	l8ui	a8, a7, 0
42005352:	000192        	l8ui	a9, a1, 0
42005355:	208890        	or	a8, a8, a9
42005358:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
4200535b:	fc7c      	movi.n	a12, -1
4200535d:	01bd      	mov.n	a11, a1
4200535f:	2a0c      	movi.n	a10, 2
42005361:	ff9125        	call8	42004c74 <esp_mprot_get_pms_lock>
42005364:	0a2d      	mov.n	a2, a10
42005366:	0cea56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005369:	000782        	l8ui	a8, a7, 0
4200536c:	000192        	l8ui	a9, a1, 0
4200536f:	208890        	or	a8, a8, a9
42005372:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, PRO_CPU_NUM));
42005375:	0c0c      	movi.n	a12, 0
42005377:	01bd      	mov.n	a11, a1
42005379:	2a0c      	movi.n	a10, 2
4200537b:	ffda65        	call8	42005120 <esp_mprot_get_monitor_lock>
4200537e:	0a2d      	mov.n	a2, a10
42005380:	0b4a56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
42005383:	000782        	l8ui	a8, a7, 0
42005386:	000192        	l8ui	a9, a1, 0
42005389:	208890        	or	a8, a8, a9
4200538c:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
4200538f:	ecb781        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
42005392:	3888      	l32i.n	a8, a8, 12
42005394:	1a28b6        	bltui	a8, 2, 420053b2 <esp_mprot_is_conf_locked_any+0xfe>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, APP_CPU_NUM));
42005397:	1c0c      	movi.n	a12, 1
42005399:	20b110        	or	a11, a1, a1
4200539c:	2a0c      	movi.n	a10, 2
4200539e:	ffd825        	call8	42005120 <esp_mprot_get_monitor_lock>
420053a1:	0a2d      	mov.n	a2, a10
420053a3:	091a56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
420053a6:	000782        	l8ui	a8, a7, 0
420053a9:	000192        	l8ui	a9, a1, 0
420053ac:	208890        	or	a8, a8, a9
420053af:	004782        	s8i	a8, a7, 0
        }
    }

    //RTCFAST
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST) {
420053b2:	ecae81        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
420053b5:	2888      	l32i.n	a8, a8, 8
420053b7:	02e827        	bbsi	a8, 2, 420053bd <esp_mprot_is_conf_locked_any+0x109>
420053ba:	001e06        	j	42005436 <esp_mprot_is_conf_locked_any+0x182>

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM))
420053bd:	0c0c      	movi.n	a12, 0
420053bf:	01bd      	mov.n	a11, a1
420053c1:	4a0c      	movi.n	a10, 4
420053c3:	ff8b25        	call8	42004c74 <esp_mprot_get_pms_lock>
420053c6:	0a2d      	mov.n	a2, a10
420053c8:	06ca56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
420053cb:	000782        	l8ui	a8, a7, 0
420053ce:	000192        	l8ui	a9, a1, 0
420053d1:	208890        	or	a8, a8, a9
420053d4:	004782        	s8i	a8, a7, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM));
420053d7:	0c0c      	movi.n	a12, 0
420053d9:	01bd      	mov.n	a11, a1
420053db:	4a0c      	movi.n	a10, 4
420053dd:	ffd425        	call8	42005120 <esp_mprot_get_monitor_lock>
420053e0:	0a2d      	mov.n	a2, a10
420053e2:	052a56        	bnez	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
        *locked |= lock_on;
420053e5:	000782        	l8ui	a8, a7, 0
420053e8:	000192        	l8ui	a9, a1, 0
420053eb:	208890        	or	a8, a8, a9
420053ee:	004782        	s8i	a8, a7, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
420053f1:	ec9e81        	l32r	a8, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
420053f4:	3888      	l32i.n	a8, a8, 12
420053f6:	3e28b6        	bltui	a8, 2, 42005438 <esp_mprot_is_conf_locked_any+0x184>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM))
420053f9:	1c0c      	movi.n	a12, 1
420053fb:	01bd      	mov.n	a11, a1
420053fd:	04a0a2        	movi	a10, 4
42005400:	ff8725        	call8	42004c74 <esp_mprot_get_pms_lock>
42005403:	0a2d      	mov.n	a2, a10
42005405:	faec      	bnez.n	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
42005407:	000782        	l8ui	a8, a7, 0
4200540a:	000192        	l8ui	a9, a1, 0
4200540d:	208890        	or	a8, a8, a9
42005410:	004782        	s8i	a8, a7, 0

            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM));
42005413:	1c0c      	movi.n	a12, 1
42005415:	01bd      	mov.n	a11, a1
42005417:	4a0c      	movi.n	a10, 4
42005419:	ffd065        	call8	42005120 <esp_mprot_get_monitor_lock>
4200541c:	0a2d      	mov.n	a2, a10
4200541e:	6adc      	bnez.n	a10, 42005438 <esp_mprot_is_conf_locked_any+0x184>
            *locked |= lock_on;
42005420:	000782        	l8ui	a8, a7, 0
42005423:	000192        	l8ui	a9, a1, 0
42005426:	208890        	or	a8, a8, a9
42005429:	004782        	s8i	a8, a7, 0
4200542c:	000206        	j	42005438 <esp_mprot_is_conf_locked_any+0x184>
4200542f:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42005432:	004602        	s8i	a0, a6, 0
42005435:	020c00        	andb	b0, b12, b0
        }
    }

    return ESP_OK;
}
42005438:	f01d      	retw.n
	...

4200543c <esp_mprot_set_prot>:
}

//////////////////////////////////////////////////////////////////////////////
// convenient "public" APIs
esp_err_t esp_mprot_set_prot(const esp_memp_config_t *memp_config)
{
4200543c:	008136        	entry	a1, 64
4200543f:	027d      	mov.n	a7, a2
    RER(reg, dcr);
42005441:	eba381        	l32r	a8, 420002d0 <_stext+0x2b0> (10200c <UserFrameTotalSize+0x101f0c>)
42005444:	406880        	rer	a8, a8
    return (bool)(dcr & 0x1);
42005447:	044080        	extui	a4, a8, 0, 1
    //debugger connected:
    // 1.check the signal repeatedly to avoid possible glitching attempt
    // 2.leave the Memprot unset to allow debug operations

    if (esp_cpu_dbgr_is_attached()) {
4200544a:	5b6807        	bbci	a8, 0, 420054a9 <esp_mprot_set_prot+0x6d>
    RER(reg, dcr);
4200544d:	eba081        	l32r	a8, 420002d0 <_stext+0x2b0> (10200c <UserFrameTotalSize+0x101f0c>)
42005450:	406880        	rer	a8, a8
        ESP_FAULT_ASSERT(esp_cpu_dbgr_is_attached());
42005453:	13e807        	bbsi	a8, 0, 4200546a <esp_mprot_set_prot+0x2e>
42005456:	eca781        	l32r	a8, 420006f4 <_stext+0x6d4> (400006d8 <esp_rom_software_reset_system>)
42005459:	0008e0        	callx8	a8
4200545c:	f06d      	ill.n
4200545e:	f06d      	ill.n
42005460:	f06d      	ill.n
42005462:	f06d      	ill.n
42005464:	f06d      	ill.n
42005466:	f06d      	ill.n
42005468:	f06d      	ill.n
4200546a:	eb9981        	l32r	a8, 420002d0 <_stext+0x2b0> (10200c <UserFrameTotalSize+0x101f0c>)
4200546d:	406880        	rer	a8, a8
42005470:	13e807        	bbsi	a8, 0, 42005487 <esp_mprot_set_prot+0x4b>
42005473:	eca081        	l32r	a8, 420006f4 <_stext+0x6d4> (400006d8 <esp_rom_software_reset_system>)
42005476:	0008e0        	callx8	a8
42005479:	f06d      	ill.n
4200547b:	f06d      	ill.n
4200547d:	f06d      	ill.n
4200547f:	f06d      	ill.n
42005481:	f06d      	ill.n
42005483:	f06d      	ill.n
42005485:	f06d      	ill.n
42005487:	eb9281        	l32r	a8, 420002d0 <_stext+0x2b0> (10200c <UserFrameTotalSize+0x101f0c>)
4200548a:	406880        	rer	a8, a8
4200548d:	13e807        	bbsi	a8, 0, 420054a4 <esp_mprot_set_prot+0x68>
42005490:	ec9981        	l32r	a8, 420006f4 <_stext+0x6d4> (400006d8 <esp_rom_software_reset_system>)
42005493:	0008e0        	callx8	a8
42005496:	f06d      	ill.n
42005498:	f06d      	ill.n
4200549a:	f06d      	ill.n
4200549c:	f06d      	ill.n
4200549e:	f06d      	ill.n
420054a0:	f06d      	ill.n
420054a2:	f06d      	ill.n
        return ESP_OK;
420054a4:	020c      	movi.n	a2, 0
420054a6:	01e686        	j	42005c44 <esp_mprot_set_prot+0x808>
    }

    //sanity checks
    if (memp_config == NULL) {
420054a9:	12cc      	bnez.n	a2, 420054ae <esp_mprot_set_prot+0x72>
420054ab:	01e046        	j	42005c30 <esp_mprot_set_prot+0x7f4>
        return ESP_ERR_INVALID_ARG;
    }
    if (memp_config->mem_type_mask == MEMPROT_TYPE_NONE) {
420054ae:	2258      	l32i.n	a5, a2, 8
420054b0:	15cc      	bnez.n	a5, 420054b5 <esp_mprot_set_prot+0x79>
420054b2:	01e086        	j	42005c38 <esp_mprot_set_prot+0x7fc>
        return ESP_ERR_NO_MEM;
    }
    if (memp_config->target_cpu_count < 1 || memp_config->target_cpu_count > CONFIG_FREERTOS_NUMBER_OF_CORES) {
420054b5:	3268      	l32i.n	a6, a2, 12
420054b7:	860b      	addi.n	a8, a6, -1
420054b9:	0228b6        	bltui	a8, 2, 420054bf <esp_mprot_set_prot+0x83>
420054bc:	01e046        	j	42005c41 <esp_mprot_set_prot+0x805>
        return ESP_ERR_MEMPROT_CPUID_INVALID;
    }

    esp_err_t ret = ESP_OK;
    size_t core_count = memp_config->target_cpu_count;
    for (size_t x = 0; x < core_count; x++) {
420054bf:	043d      	mov.n	a3, a4
    esp_err_t ret = ESP_OK;
420054c1:	020c      	movi.n	a2, 0
420054c3:	000486        	j	420054d9 <esp_mprot_set_prot+0x9d>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_cpuid_valid(memp_config->target_cpu[x]))
420054c6:	834b      	addi.n	a8, a3, 4
420054c8:	a08870        	addx4	a8, a8, a7
420054cb:	08a8      	l32i.n	a10, a8, 0
420054cd:	ff4625        	call8	42004930 <esp_mprot_cpuid_valid>
420054d0:	0a2d      	mov.n	a2, a10
420054d2:	1a8c      	beqz.n	a10, 420054d7 <esp_mprot_set_prot+0x9b>
420054d4:	01db06        	j	42005c44 <esp_mprot_set_prot+0x808>
    for (size_t x = 0; x < core_count; x++) {
420054d7:	331b      	addi.n	a3, a3, 1
420054d9:	e93367        	bltu	a3, a6, 420054c6 <esp_mprot_set_prot+0x8a>
    }

    bool use_iram0 = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM;
420054dc:	048050        	extui	a8, a5, 0, 1
420054df:	5189      	s32i.n	a8, a1, 20
    bool use_dram0 = memp_config->mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM;
420054e1:	230c      	movi.n	a3, 2
420054e3:	103530        	and	a3, a5, a3
420054e6:	180c      	movi.n	a8, 1
420054e8:	838330        	moveqz	a8, a3, a3
420054eb:	6189      	s32i.n	a8, a1, 24
    bool use_rtcfast = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST;
420054ed:	480c      	movi.n	a8, 4
420054ef:	108580        	and	a8, a5, a8
420054f2:	4189      	s32i.n	a8, a1, 16

    //disable protection (must be unlocked)
    if (use_iram0) {
420054f4:	1ae507        	bbsi	a5, 0, 42005512 <esp_mprot_set_prot+0xd6>
420054f7:	000706        	j	42005517 <esp_mprot_set_prot+0xdb>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, false, memp_config->target_cpu[x]))
420054fa:	854b      	addi.n	a8, a5, 4
420054fc:	a08870        	addx4	a8, a8, a7
420054ff:	08c8      	l32i.n	a12, a8, 0
42005501:	0b0c      	movi.n	a11, 0
42005503:	1a0c      	movi.n	a10, 1
42005505:	ffc7e5        	call8	42005184 <esp_mprot_set_monitor_en>
42005508:	0a2d      	mov.n	a2, a10
4200550a:	736a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200550d:	551b      	addi.n	a5, a5, 1
4200550f:	000046        	j	42005514 <esp_mprot_set_prot+0xd8>
42005512:	045d      	mov.n	a5, a4
42005514:	e23567        	bltu	a5, a6, 420054fa <esp_mprot_set_prot+0xbe>
        }
    }
    if (use_dram0) {
42005517:	d3dc      	bnez.n	a3, 42005538 <esp_mprot_set_prot+0xfc>
42005519:	000806        	j	4200553d <esp_mprot_set_prot+0x101>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, false, memp_config->target_cpu[x]))
4200551c:	04c582        	addi	a8, a5, 4
4200551f:	a08870        	addx4	a8, a8, a7
42005522:	0028c2        	l32i	a12, a8, 0
42005525:	00a0b2        	movi	a11, 0
42005528:	2a0c      	movi.n	a10, 2
4200552a:	ffc5a5        	call8	42005184 <esp_mprot_set_monitor_en>
4200552d:	0a2d      	mov.n	a2, a10
4200552f:	711a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
42005532:	551b      	addi.n	a5, a5, 1
42005534:	000086        	j	4200553a <esp_mprot_set_prot+0xfe>
42005537:	045d00        	extui	a5, a0, 13, 1
4200553a:	de3567        	bltu	a5, a6, 4200551c <esp_mprot_set_prot+0xe0>
        }
    }
    if (use_rtcfast) {
4200553d:	4188      	l32i.n	a8, a1, 16
4200553f:	d8dc      	bnez.n	a8, 42005560 <esp_mprot_set_prot+0x124>
42005541:	000806        	j	42005565 <esp_mprot_set_prot+0x129>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, false, memp_config->target_cpu[x]))
42005544:	04c582        	addi	a8, a5, 4
42005547:	a08870        	addx4	a8, a8, a7
4200554a:	0028c2        	l32i	a12, a8, 0
4200554d:	00a0b2        	movi	a11, 0
42005550:	4a0c      	movi.n	a10, 4
42005552:	ffc325        	call8	42005184 <esp_mprot_set_monitor_en>
42005555:	0a2d      	mov.n	a2, a10
42005557:	6e9a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200555a:	551b      	addi.n	a5, a5, 1
4200555c:	000086        	j	42005562 <esp_mprot_set_prot+0x126>
4200555f:	045d00        	extui	a5, a0, 13, 1
42005562:	de3567        	bltu	a5, a6, 42005544 <esp_mprot_set_prot+0x108>
        }
    }

    //panic handling
    if (memp_config->invoke_panic_handler) {
42005565:	000782        	l8ui	a8, a7, 0
42005568:	06f816        	beqz	a8, 420055db <esp_mprot_set_prot+0x19f>
        if (use_iram0) {
4200556b:	5188      	l32i.n	a8, a1, 20
4200556d:	b8dc      	bnez.n	a8, 4200558c <esp_mprot_set_prot+0x150>
4200556f:	000786        	j	42005591 <esp_mprot_set_prot+0x155>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42005572:	04c582        	addi	a8, a5, 4
42005575:	a08870        	addx4	a8, a8, a7
42005578:	0028b2        	l32i	a11, a8, 0
4200557b:	01a0a2        	movi	a10, 1
4200557e:	ff3fe5        	call8	4200497c <esp_mprot_set_intr_matrix>
42005581:	0a2d      	mov.n	a2, a10
42005583:	6bda56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005586:	551b      	addi.n	a5, a5, 1
42005588:	000086        	j	4200558e <esp_mprot_set_prot+0x152>
4200558b:	045d00        	extui	a5, a0, 13, 1
4200558e:	e03567        	bltu	a5, a6, 42005572 <esp_mprot_set_prot+0x136>
            }
        }
        if (use_dram0) {
42005591:	b3dc      	bnez.n	a3, 420055b0 <esp_mprot_set_prot+0x174>
42005593:	000786        	j	420055b5 <esp_mprot_set_prot+0x179>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42005596:	04c582        	addi	a8, a5, 4
42005599:	a08870        	addx4	a8, a8, a7
4200559c:	0028b2        	l32i	a11, a8, 0
4200559f:	02a0a2        	movi	a10, 2
420055a2:	ff3da5        	call8	4200497c <esp_mprot_set_intr_matrix>
420055a5:	0a2d      	mov.n	a2, a10
420055a7:	699a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
420055aa:	551b      	addi.n	a5, a5, 1
420055ac:	000086        	j	420055b2 <esp_mprot_set_prot+0x176>
420055af:	045d00        	extui	a5, a0, 13, 1
420055b2:	e03567        	bltu	a5, a6, 42005596 <esp_mprot_set_prot+0x15a>
            }
        }
        if (use_rtcfast) {
420055b5:	4188      	l32i.n	a8, a1, 16
420055b7:	b8dc      	bnez.n	a8, 420055d6 <esp_mprot_set_prot+0x19a>
420055b9:	000786        	j	420055db <esp_mprot_set_prot+0x19f>
420055bc:	c58200        	extui	a8, a0, 18, 13
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
420055bf:	887004        	ee.vld.h.64.ip	q0, a0, 0x380
420055c2:	a0          	.byte	0xa0
420055c3:	0028b2        	l32i	a11, a8, 0
420055c6:	04a0a2        	movi	a10, 4
420055c9:	ff3b25        	call8	4200497c <esp_mprot_set_intr_matrix>
420055cc:	0a2d      	mov.n	a2, a10
420055ce:	672a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
420055d1:	551b      	addi.n	a5, a5, 1
420055d3:	000046        	j	420055d8 <esp_mprot_set_prot+0x19c>
420055d6:	045d      	mov.n	a5, a4
420055d8:	e13567        	bltu	a5, a6, 420055bd <esp_mprot_set_prot+0x181>
            }
        }
    }

    //set split lines (must-have for all mem_types). This version sets only the main I/D which is then shared for all PMS regions
    void *line_addr __attribute__((unused)) = NULL;
420055db:	080c      	movi.n	a8, 0
420055dd:	0189      	s32i.n	a8, a1, 0
    if (use_iram0 || use_dram0) {
420055df:	5188      	l32i.n	a8, a1, 20
420055e1:	6198      	l32i.n	a9, a1, 24
420055e3:	208890        	or	a8, a8, a9
420055e6:	6189      	s32i.n	a8, a1, 24
420055e8:	0c7816        	beqz	a8, 420056b3 <esp_mprot_set_prot+0x277>
        line_addr = memp_config->split_addr;
420055eb:	1788      	l32i.n	a8, a7, 4
420055ed:	0189      	s32i.n	a8, a1, 0
        if (line_addr == NULL) {
420055ef:	b8cc      	bnez.n	a8, 420055fe <esp_mprot_set_prot+0x1c2>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_default_main_split_addr(MEMPROT_TYPE_IRAM0_SRAM, &line_addr))
420055f1:	01bd      	mov.n	a11, a1
420055f3:	1a0c      	movi.n	a10, 1
420055f5:	ff50a5        	call8	42004b00 <esp_mprot_get_default_main_split_addr>
420055f8:	202aa0        	or	a2, a10, a10
420055fb:	645a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_1, line_addr, DEFAULT_CPU_NUM))
420055fe:	fd7c      	movi.n	a13, -1
42005600:	01c8      	l32i.n	a12, a1, 0
42005602:	4b0c      	movi.n	a11, 4
42005604:	1a0c      	movi.n	a10, 1
42005606:	ff43a5        	call8	42004a40 <esp_mprot_set_split_addr>
42005609:	0a2d      	mov.n	a2, a10
4200560b:	635a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_0, line_addr, DEFAULT_CPU_NUM))
4200560e:	fd7c      	movi.n	a13, -1
42005610:	01c8      	l32i.n	a12, a1, 0
42005612:	2b0c      	movi.n	a11, 2
42005614:	1a0c      	movi.n	a10, 1
42005616:	ff42a5        	call8	42004a40 <esp_mprot_set_split_addr>
42005619:	0a2d      	mov.n	a2, a10
4200561b:	625a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_DRAM0, line_addr, DEFAULT_CPU_NUM))
4200561e:	fd7c      	movi.n	a13, -1
42005620:	01c8      	l32i.n	a12, a1, 0
42005622:	1b0c      	movi.n	a11, 1
42005624:	0bad      	mov.n	a10, a11
42005626:	ff41a5        	call8	42004a40 <esp_mprot_set_split_addr>
42005629:	0a2d      	mov.n	a2, a10
4200562b:	615a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
4200562e:	fd7c      	movi.n	a13, -1
42005630:	01c8      	l32i.n	a12, a1, 0
42005632:	ec0681        	l32r	a8, 4200064c <_stext+0x62c> (ff910000 <_rtc_reserved_end+0x9f810000>)
42005635:	cc8a      	add.n	a12, a12, a8
42005637:	8b0c      	movi.n	a11, 8
42005639:	2a0c      	movi.n	a10, 2
4200563b:	ff4065        	call8	42004a40 <esp_mprot_set_split_addr>
4200563e:	0a2d      	mov.n	a2, a10
42005640:	600a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
42005643:	fd7c      	movi.n	a13, -1
42005645:	01c8      	l32i.n	a12, a1, 0
42005647:	ec0181        	l32r	a8, 4200064c <_stext+0x62c> (ff910000 <_rtc_reserved_end+0x9f810000>)
4200564a:	cc8a      	add.n	a12, a12, a8
4200564c:	0b1c      	movi.n	a11, 16
4200564e:	2a0c      	movi.n	a10, 2
42005650:	ff3ee5        	call8	42004a40 <esp_mprot_set_split_addr>
42005653:	0a2d      	mov.n	a2, a10
42005655:	5eba56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
    }

    //set permissions
    if (use_iram0) {
42005658:	5188      	l32i.n	a8, a1, 20
4200565a:	055816        	beqz	a8, 420056b3 <esp_mprot_set_prot+0x277>
        ret = ESP_OK;
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_0, MEMPROT_OP_NONE, DEFAULT_CPU_NUM));
4200565d:	fc7c      	movi.n	a12, -1
4200565f:	0b0c      	movi.n	a11, 0
42005661:	00a4a2        	movi	a10, 0x400
42005664:	ff67a5        	call8	42004ce0 <esp_mprot_set_pms_area>
42005667:	0a2d      	mov.n	a2, a10
42005669:	5d7a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
#if CONFIG_ESP32S3_INSTRUCTION_CACHE_16KB
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_1, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM));
4200566c:	fc7c      	movi.n	a12, -1
4200566e:	5b0c      	movi.n	a11, 5
42005670:	ebcea1        	l32r	a10, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
42005673:	ff66e5        	call8	42004ce0 <esp_mprot_set_pms_area>
42005676:	0a2d      	mov.n	a2, a10
42005678:	5c8a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
#else
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_ICACHE_1, MEMPROT_OP_NONE, DEFAULT_CPU_NUM));
#endif
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_0, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
4200567b:	fc7c      	movi.n	a12, -1
4200567d:	5b0c      	movi.n	a11, 5
4200567f:	1a0c      	movi.n	a10, 1
42005681:	ff65e5        	call8	42004ce0 <esp_mprot_set_pms_area>
42005684:	0a2d      	mov.n	a2, a10
42005686:	5baa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_1, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
42005689:	fc7c      	movi.n	a12, -1
4200568b:	5b0c      	movi.n	a11, 5
4200568d:	2a0c      	movi.n	a10, 2
4200568f:	ff6525        	call8	42004ce0 <esp_mprot_set_pms_area>
42005692:	0a2d      	mov.n	a2, a10
42005694:	5aca56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_2, MEMPROT_OP_READ | MEMPROT_OP_EXEC, DEFAULT_CPU_NUM))
42005697:	fc7c      	movi.n	a12, -1
42005699:	5b0c      	movi.n	a11, 5
4200569b:	4a0c      	movi.n	a10, 4
4200569d:	ff6425        	call8	42004ce0 <esp_mprot_set_pms_area>
420056a0:	0a2d      	mov.n	a2, a10
420056a2:	59ea56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_3, MEMPROT_OP_NONE, DEFAULT_CPU_NUM))
420056a5:	fc7c      	movi.n	a12, -1
420056a7:	0b0c      	movi.n	a11, 0
420056a9:	8a0c      	movi.n	a10, 8
420056ab:	ff6365        	call8	42004ce0 <esp_mprot_set_pms_area>
420056ae:	0a2d      	mov.n	a2, a10
420056b0:	590a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
    }
    if (use_dram0) {
420056b3:	03a316        	beqz	a3, 420056f1 <esp_mprot_set_prot+0x2b5>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_0, MEMPROT_OP_READ, DEFAULT_CPU_NUM))
420056b6:	fc7c      	movi.n	a12, -1
420056b8:	1b0c      	movi.n	a11, 1
420056ba:	0a1c      	movi.n	a10, 16
420056bc:	ff6225        	call8	42004ce0 <esp_mprot_set_pms_area>
420056bf:	0a2d      	mov.n	a2, a10
420056c1:	57fa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_1, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
420056c4:	fc7c      	movi.n	a12, -1
420056c6:	3b0c      	movi.n	a11, 3
420056c8:	0a2c      	movi.n	a10, 32
420056ca:	ff6165        	call8	42004ce0 <esp_mprot_set_pms_area>
420056cd:	0a2d      	mov.n	a2, a10
420056cf:	571a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_2, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
420056d2:	fc7c      	movi.n	a12, -1
420056d4:	3b0c      	movi.n	a11, 3
420056d6:	0a4c      	movi.n	a10, 64
420056d8:	ff6065        	call8	42004ce0 <esp_mprot_set_pms_area>
420056db:	0a2d      	mov.n	a2, a10
420056dd:	563a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_DRAM0_3, MEMPROT_OP_READ | MEMPROT_OP_WRITE, DEFAULT_CPU_NUM))
420056e0:	ffafc2        	movi	a12, -1
420056e3:	03a0b2        	movi	a11, 3
420056e6:	80a0a2        	movi	a10, 128
420056e9:	ff5f65        	call8	42004ce0 <esp_mprot_set_pms_area>
420056ec:	0a2d      	mov.n	a2, a10
420056ee:	552a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
    }

    void *rtc_fast_line __attribute__((unused)) = NULL;
420056f1:	00a082        	movi	a8, 0
420056f4:	016182        	s32i	a8, a1, 4
    if (use_rtcfast) {
420056f7:	042182        	l32i	a8, a1, 16
420056fa:	052816        	beqz	a8, 42005750 <esp_mprot_set_prot+0x314>
        //RTCFAST split-line cannot be set manually - always use default
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_default_main_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, &rtc_fast_line));
420056fd:	b14b      	addi.n	a11, a1, 4
420056ff:	4a0c      	movi.n	a10, 4
42005701:	ff3fe5        	call8	42004b00 <esp_mprot_get_default_main_split_addr>
42005704:	0a2d      	mov.n	a2, a10
42005706:	53aa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
42005709:	045d      	mov.n	a5, a4
4200570b:	000f86        	j	4200574d <esp_mprot_set_prot+0x311>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, MEMPROT_SPLIT_ADDR_MAIN, rtc_fast_line, memp_config->target_cpu[x]))
4200570e:	854b      	addi.n	a8, a5, 4
42005710:	a08870        	addx4	a8, a8, a7
42005713:	08d8      	l32i.n	a13, a8, 0
42005715:	11c8      	l32i.n	a12, a1, 4
42005717:	1b0c      	movi.n	a11, 1
42005719:	4a0c      	movi.n	a10, 4
4200571b:	ff3265        	call8	42004a40 <esp_mprot_set_split_addr>
4200571e:	0a2d      	mov.n	a2, a10
42005720:	520a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO, MEMPROT_OP_READ | MEMPROT_OP_EXEC, memp_config->target_cpu[x]))
42005723:	854b      	addi.n	a8, a5, 4
42005725:	a08870        	addx4	a8, a8, a7
42005728:	08c8      	l32i.n	a12, a8, 0
4200572a:	5b0c      	movi.n	a11, 5
4200572c:	00a1a2        	movi	a10, 0x100
4200572f:	ff5b25        	call8	42004ce0 <esp_mprot_set_pms_area>
42005732:	0a2d      	mov.n	a2, a10
42005734:	50ca56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI, MEMPROT_OP_READ | MEMPROT_OP_WRITE, memp_config->target_cpu[x]))
42005737:	854b      	addi.n	a8, a5, 4
42005739:	a08870        	addx4	a8, a8, a7
4200573c:	08c8      	l32i.n	a12, a8, 0
4200573e:	3b0c      	movi.n	a11, 3
42005740:	00a2a2        	movi	a10, 0x200
42005743:	ff59e5        	call8	42004ce0 <esp_mprot_set_pms_area>
42005746:	0a2d      	mov.n	a2, a10
42005748:	4f8a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200574b:	551b      	addi.n	a5, a5, 1
4200574d:	bd3567        	bltu	a5, a6, 4200570e <esp_mprot_set_prot+0x2d2>
        }
    }

    //reenable the protection
    if (use_iram0) {
42005750:	5188      	l32i.n	a8, a1, 20
42005752:	e8ec      	bnez.n	a8, 42005784 <esp_mprot_set_prot+0x348>
42005754:	000c46        	j	42005789 <esp_mprot_set_prot+0x34d>
42005757:	820000        	mull	a0, a0, a0
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
4200575a:	7004c5        	call0	420757a8 <_etext+0x5c072>
4200575d:	a088      	l32i.n	a8, a0, 40
4200575f:	0028b2        	l32i	a11, a8, 0
42005762:	1a0c      	movi.n	a10, 1
42005764:	ffada5        	call8	42005240 <esp_mprot_monitor_clear_intr>
42005767:	0a2d      	mov.n	a2, a10
42005769:	4d7a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, true, memp_config->target_cpu[x]))
4200576c:	854b      	addi.n	a8, a5, 4
4200576e:	a08870        	addx4	a8, a8, a7
42005771:	08c8      	l32i.n	a12, a8, 0
42005773:	1b0c      	movi.n	a11, 1
42005775:	0bad      	mov.n	a10, a11
42005777:	ffa0e5        	call8	42005184 <esp_mprot_set_monitor_en>
4200577a:	0a2d      	mov.n	a2, a10
4200577c:	4c4a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
4200577f:	551b      	addi.n	a5, a5, 1
42005781:	000046        	j	42005786 <esp_mprot_set_prot+0x34a>
42005784:	045d      	mov.n	a5, a4
42005786:	cf3567        	bltu	a5, a6, 42005759 <esp_mprot_set_prot+0x31d>
        }
    }

    if (use_dram0) {
42005789:	d3ec      	bnez.n	a3, 420057ba <esp_mprot_set_prot+0x37e>
4200578b:	000c06        	j	420057bf <esp_mprot_set_prot+0x383>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
4200578e:	04c582        	addi	a8, a5, 4
42005791:	a08870        	addx4	a8, a8, a7
42005794:	0028b2        	l32i	a11, a8, 0
42005797:	02a0a2        	movi	a10, 2
4200579a:	ffaa65        	call8	42005240 <esp_mprot_monitor_clear_intr>
4200579d:	0a2d      	mov.n	a2, a10
4200579f:	4a1a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, true, memp_config->target_cpu[x]))
420057a2:	854b      	addi.n	a8, a5, 4
420057a4:	a08870        	addx4	a8, a8, a7
420057a7:	08c8      	l32i.n	a12, a8, 0
420057a9:	1b0c      	movi.n	a11, 1
420057ab:	2a0c      	movi.n	a10, 2
420057ad:	ff9d65        	call8	42005184 <esp_mprot_set_monitor_en>
420057b0:	0a2d      	mov.n	a2, a10
420057b2:	48ea56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420057b5:	551b      	addi.n	a5, a5, 1
420057b7:	000046        	j	420057bc <esp_mprot_set_prot+0x380>
420057ba:	045d      	mov.n	a5, a4
420057bc:	ce3567        	bltu	a5, a6, 4200578e <esp_mprot_set_prot+0x352>
        }
    }
    if (use_rtcfast) {
420057bf:	4188      	l32i.n	a8, a1, 16
420057c1:	d8ec      	bnez.n	a8, 420057f2 <esp_mprot_set_prot+0x3b6>
420057c3:	000c06        	j	420057f7 <esp_mprot_set_prot+0x3bb>
        for (size_t x = 0; x < core_count; x++) {
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
420057c6:	04c582        	addi	a8, a5, 4
420057c9:	a08870        	addx4	a8, a8, a7
420057cc:	0028b2        	l32i	a11, a8, 0
420057cf:	04a0a2        	movi	a10, 4
420057d2:	ffa6e5        	call8	42005240 <esp_mprot_monitor_clear_intr>
420057d5:	0a2d      	mov.n	a2, a10
420057d7:	469a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, true, memp_config->target_cpu[x]))
420057da:	854b      	addi.n	a8, a5, 4
420057dc:	a08870        	addx4	a8, a8, a7
420057df:	08c8      	l32i.n	a12, a8, 0
420057e1:	1b0c      	movi.n	a11, 1
420057e3:	4a0c      	movi.n	a10, 4
420057e5:	ff99e5        	call8	42005184 <esp_mprot_set_monitor_en>
420057e8:	0a2d      	mov.n	a2, a10
420057ea:	456a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        for (size_t x = 0; x < core_count; x++) {
420057ed:	551b      	addi.n	a5, a5, 1
420057ef:	000046        	j	420057f4 <esp_mprot_set_prot+0x3b8>
420057f2:	045d      	mov.n	a5, a4
420057f4:	ce3567        	bltu	a5, a6, 420057c6 <esp_mprot_set_prot+0x38a>
        }
    }

    //lock if required
    if (memp_config->lock_feature) {
420057f7:	010782        	l8ui	a8, a7, 1
420057fa:	0a2816        	beqz	a8, 420058a0 <esp_mprot_set_prot+0x464>
        if (use_iram0) {
420057fd:	5188      	l32i.n	a8, a1, 20
420057ff:	48bc      	beqz.n	a8, 42005837 <esp_mprot_set_prot+0x3fb>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, DEFAULT_CPU_NUM))
42005801:	fb7c      	movi.n	a11, -1
42005803:	1a0c      	movi.n	a10, 1
42005805:	ff33e5        	call8	42004b44 <esp_mprot_set_split_addr_lock>
42005808:	0a2d      	mov.n	a2, a10
4200580a:	436a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, DEFAULT_CPU_NUM))
4200580d:	fb7c      	movi.n	a11, -1
4200580f:	1a0c      	movi.n	a10, 1
42005811:	ff3ee5        	call8	42004c00 <esp_mprot_set_pms_lock>
42005814:	0a2d      	mov.n	a2, a10
42005816:	42aa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005819:	045d      	mov.n	a5, a4
4200581b:	000546        	j	42005834 <esp_mprot_set_prot+0x3f8>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
4200581e:	04c582        	addi	a8, a5, 4
42005821:	a08870        	addx4	a8, a8, a7
42005824:	08b8      	l32i.n	a11, a8, 0
42005826:	01a0a2        	movi	a10, 1
42005829:	ff83e5        	call8	42005068 <esp_mprot_set_monitor_lock>
4200582c:	0a2d      	mov.n	a2, a10
4200582e:	412a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005831:	01c552        	addi	a5, a5, 1
42005834:	e63567        	bltu	a5, a6, 4200581e <esp_mprot_set_prot+0x3e2>
            }
        }
        if (use_dram0) {
42005837:	13bc      	beqz.n	a3, 4200586c <esp_mprot_set_prot+0x430>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, DEFAULT_CPU_NUM))
42005839:	fb7c      	movi.n	a11, -1
4200583b:	2a0c      	movi.n	a10, 2
4200583d:	ff3065        	call8	42004b44 <esp_mprot_set_split_addr_lock>
42005840:	0a2d      	mov.n	a2, a10
42005842:	3fea56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, DEFAULT_CPU_NUM))
42005845:	fb7c      	movi.n	a11, -1
42005847:	2a0c      	movi.n	a10, 2
42005849:	ff3b65        	call8	42004c00 <esp_mprot_set_pms_lock>
4200584c:	0a2d      	mov.n	a2, a10
4200584e:	3f2a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005851:	045d      	mov.n	a5, a4
42005853:	000486        	j	42005869 <esp_mprot_set_prot+0x42d>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42005856:	854b      	addi.n	a8, a5, 4
42005858:	a08870        	addx4	a8, a8, a7
4200585b:	08b8      	l32i.n	a11, a8, 0
4200585d:	2a0c      	movi.n	a10, 2
4200585f:	ff80a5        	call8	42005068 <esp_mprot_set_monitor_lock>
42005862:	0a2d      	mov.n	a2, a10
42005864:	3dca56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
42005867:	551b      	addi.n	a5, a5, 1
42005869:	e93567        	bltu	a5, a6, 42005856 <esp_mprot_set_prot+0x41a>
            }
        }
        if (use_rtcfast) {
4200586c:	4188      	l32i.n	a8, a1, 16
4200586e:	b8ec      	bnez.n	a8, 4200589d <esp_mprot_set_prot+0x461>
42005870:	000b06        	j	420058a0 <esp_mprot_set_prot+0x464>
42005873:	000000        	ill
            //split address and area permissions are locked by the same PMS register
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42005876:	04c482        	addi	a8, a4, 4
42005879:	a08870        	addx4	a8, a8, a7
4200587c:	0028b2        	l32i	a11, a8, 0
4200587f:	04a0a2        	movi	a10, 4
42005882:	ff37e5        	call8	42004c00 <esp_mprot_set_pms_lock>
42005885:	0a2d      	mov.n	a2, a10
42005887:	3b9a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
4200588a:	844b      	addi.n	a8, a4, 4
4200588c:	a08870        	addx4	a8, a8, a7
4200588f:	08b8      	l32i.n	a11, a8, 0
42005891:	4a0c      	movi.n	a10, 4
42005893:	ff7d65        	call8	42005068 <esp_mprot_set_monitor_lock>
42005896:	0a2d      	mov.n	a2, a10
42005898:	3a8a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
            for (size_t x = 0; x < core_count; x++) {
4200589b:	441b      	addi.n	a4, a4, 1
4200589d:	d53467        	bltu	a4, a6, 42005876 <esp_mprot_set_prot+0x43a>
            }
        }
    }

    //sanity check (RTC FAST tbd within IDF-5208)
    if (use_iram0 || use_dram0) {
420058a0:	6188      	l32i.n	a8, a1, 24
420058a2:	375816        	beqz	a8, 42005c1b <esp_mprot_set_prot+0x7df>

        uint32_t check_val;

        //IRAM0 split lines
        memprot_ll_prepare_iram0_split_line_regval((const uint32_t) line_addr, &check_val);
420058a5:	b18b      	addi.n	a11, a1, 8
420058a7:	01a8      	l32i.n	a10, a1, 0
420058a9:	fe6d65        	call8	42003f80 <memprot_ll_prepare_iram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
420058ac:	eb7581        	l32r	a8, 42000680 <_stext+0x660> (600c10c4 <SYSTEM+0x10c4>)
420058af:	0020c0        	memw
420058b2:	0888      	l32i.n	a8, a8, 0

        if (memprot_ll_get_iram0_split_line_main_I_D_regval() != check_val) {
420058b4:	21b8      	l32i.n	a11, a1, 8
420058b6:	161b87        	beq	a11, a8, 420058d0 <esp_mprot_set_prot+0x494>
420058b9:	eb7181        	l32r	a8, 42000680 <_stext+0x660> (600c10c4 <SYSTEM+0x10c4>)
420058bc:	0020c0        	memw
420058bf:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
420058c1:	eb77a1        	l32r	a10, 420006a0 <_stext+0x680> (3c022520 <_flash_rodata_start+0x2400>)
420058c4:	e9e881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420058c7:	0008e0        	callx8	a8
                "Fatal error: Main I/D split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_D_regval());
            abort();
420058ca:	ea0481        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
420058cd:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
420058d0:	eb6d81        	l32r	a8, 42000684 <_stext+0x664> (600c10c8 <SYSTEM+0x10c8>)
420058d3:	0020c0        	memw
420058d6:	0888      	l32i.n	a8, a8, 0
        }
        if (memprot_ll_get_iram0_split_line_main_I_0_regval() != check_val) {
420058d8:	161b87        	beq	a11, a8, 420058f2 <esp_mprot_set_prot+0x4b6>
420058db:	eb6a81        	l32r	a8, 42000684 <_stext+0x664> (600c10c8 <SYSTEM+0x10c8>)
420058de:	0020c0        	memw
420058e1:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
420058e3:	eb70a1        	l32r	a10, 420006a4 <_stext+0x684> (3c022580 <_flash_rodata_start+0x2460>)
420058e6:	e9df81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420058e9:	0008e0        	callx8	a8
                "Fatal error: IRAM0 I_0 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_0_regval());
            abort();
420058ec:	e9fc81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
420058ef:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
420058f2:	eb6581        	l32r	a8, 42000688 <_stext+0x668> (600c10cc <SYSTEM+0x10cc>)
420058f5:	0020c0        	memw
420058f8:	002882        	l32i	a8, a8, 0
        }
        if (memprot_ll_get_iram0_split_line_main_I_1_regval() != check_val) {
420058fb:	171b87        	beq	a11, a8, 42005916 <esp_mprot_set_prot+0x4da>
420058fe:	eb6281        	l32r	a8, 42000688 <_stext+0x668> (600c10cc <SYSTEM+0x10cc>)
42005901:	0020c0        	memw
42005904:	0028c2        	l32i	a12, a8, 0
            esp_rom_printf(
42005907:	eb68a1        	l32r	a10, 420006a8 <_stext+0x688> (3c0225e0 <_flash_rodata_start+0x24c0>)
4200590a:	e9d681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200590d:	0008e0        	callx8	a8
                "Fatal error: IRAM0 I_1 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_iram0_split_line_main_I_1_regval());
            abort();
42005910:	e9f381        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005913:	0008e0        	callx8	a8
        }

        //DRAM0 split lines
        memprot_ll_prepare_dram0_split_line_regval(MAP_IRAM_TO_DRAM((const uint32_t) line_addr), &check_val);
42005916:	b18b      	addi.n	a11, a1, 8
42005918:	01a8      	l32i.n	a10, a1, 0
4200591a:	eb4c81        	l32r	a8, 4200064c <_stext+0x62c> (ff910000 <_rtc_reserved_end+0x9f810000>)
4200591d:	aa8a      	add.n	a10, a10, a8
4200591f:	fed1a5        	call8	42004638 <memprot_ll_prepare_dram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42005922:	eb5a81        	l32r	a8, 4200068c <_stext+0x66c> (600c10d0 <SYSTEM+0x10d0>)
42005925:	0020c0        	memw
42005928:	0888      	l32i.n	a8, a8, 0

        if (memprot_ll_get_dram0_split_line_main_D_0_regval() != check_val) {
4200592a:	21b8      	l32i.n	a11, a1, 8
4200592c:	161b87        	beq	a11, a8, 42005946 <esp_mprot_set_prot+0x50a>
4200592f:	eb5781        	l32r	a8, 4200068c <_stext+0x66c> (600c10d0 <SYSTEM+0x10d0>)
42005932:	0020c0        	memw
42005935:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
42005937:	eb5da1        	l32r	a10, 420006ac <_stext+0x68c> (3c022640 <_flash_rodata_start+0x2520>)
4200593a:	e9ca81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200593d:	0008e0        	callx8	a8
                "Fatal error: DRAM0 D_0 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_dram0_split_line_main_D_0_regval());
            abort();
42005940:	e9e781        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005943:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
42005946:	eb5281        	l32r	a8, 42000690 <_stext+0x670> (600c10d4 <SYSTEM+0x10d4>)
42005949:	0020c0        	memw
4200594c:	002882        	l32i	a8, a8, 0
        }
        if (memprot_ll_get_dram0_split_line_main_D_1_regval() != check_val) {
4200594f:	171b87        	beq	a11, a8, 4200596a <esp_mprot_set_prot+0x52e>
42005952:	eb4f81        	l32r	a8, 42000690 <_stext+0x670> (600c10d4 <SYSTEM+0x10d4>)
42005955:	0020c0        	memw
42005958:	0028c2        	l32i	a12, a8, 0
            esp_rom_printf(
4200595b:	eb55a1        	l32r	a10, 420006b0 <_stext+0x690> (3c0226a0 <_flash_rodata_start+0x2580>)
4200595e:	e9c181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005961:	0008e0        	callx8	a8
                "Fatal error: DRAM0 D_1 split line configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
                check_val, memprot_ll_get_dram0_split_line_main_D_1_regval());
            abort();
42005964:	e9de81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005967:	0008e0        	callx8	a8
        }

        //IRAM0 perms
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_0, &check_val, DEFAULT_CPU_NUM))
4200596a:	fc7c      	movi.n	a12, -1
4200596c:	b18b      	addi.n	a11, a1, 8
4200596e:	1a0c      	movi.n	a10, 1
42005970:	ff4da5        	call8	42004e4c <esp_mprot_get_pms_area>
42005973:	0a2d      	mov.n	a2, a10
42005975:	2cba56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42005978:	21c8      	l32i.n	a12, a1, 8
4200597a:	105c26        	beqi	a12, 5, 4200598e <esp_mprot_set_prot+0x552>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_0 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
4200597d:	5b0c      	movi.n	a11, 5
4200597f:	eb4da1        	l32r	a10, 420006b4 <_stext+0x694> (3c022700 <_flash_rodata_start+0x25e0>)
42005982:	e9b881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005985:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
42005988:	e9d581        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200598b:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_1, &check_val, DEFAULT_CPU_NUM))
4200598e:	fc7c      	movi.n	a12, -1
42005990:	b18b      	addi.n	a11, a1, 8
42005992:	2a0c      	movi.n	a10, 2
42005994:	ff4b65        	call8	42004e4c <esp_mprot_get_pms_area>
42005997:	0a2d      	mov.n	a2, a10
42005999:	2a7a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
4200599c:	21c8      	l32i.n	a12, a1, 8
4200599e:	105c26        	beqi	a12, 5, 420059b2 <esp_mprot_set_prot+0x576>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_1 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420059a1:	5b0c      	movi.n	a11, 5
420059a3:	eb45a1        	l32r	a10, 420006b8 <_stext+0x698> (3c02275c <_flash_rodata_start+0x263c>)
420059a6:	e9af81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420059a9:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
420059ac:	e9cc81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
420059af:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_2, &check_val, DEFAULT_CPU_NUM))
420059b2:	fc7c      	movi.n	a12, -1
420059b4:	b18b      	addi.n	a11, a1, 8
420059b6:	4a0c      	movi.n	a10, 4
420059b8:	ff4925        	call8	42004e4c <esp_mprot_get_pms_area>
420059bb:	0a2d      	mov.n	a2, a10
420059bd:	283a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
420059c0:	21c8      	l32i.n	a12, a1, 8
420059c2:	105c26        	beqi	a12, 5, 420059d6 <esp_mprot_set_prot+0x59a>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_2 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420059c5:	5b0c      	movi.n	a11, 5
420059c7:	eb3da1        	l32r	a10, 420006bc <_stext+0x69c> (3c0227b8 <_flash_rodata_start+0x2698>)
420059ca:	e9a681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420059cd:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_EXEC, check_val);
            abort();
420059d0:	e9c381        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
420059d3:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_3, &check_val, DEFAULT_CPU_NUM))
420059d6:	ffafc2        	movi	a12, -1
420059d9:	08c1b2        	addi	a11, a1, 8
420059dc:	08a0a2        	movi	a10, 8
420059df:	ff46e5        	call8	42004e4c <esp_mprot_get_pms_area>
420059e2:	0a2d      	mov.n	a2, a10
420059e4:	25ca56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != MEMPROT_OP_NONE) {
420059e7:	2158      	l32i.n	a5, a1, 8
420059e9:	159c      	beqz.n	a5, 420059fe <esp_mprot_set_prot+0x5c2>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_3 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
420059eb:	05cd      	mov.n	a12, a5
420059ed:	0b0c      	movi.n	a11, 0
420059ef:	eb34a1        	l32r	a10, 420006c0 <_stext+0x6a0> (3c022814 <_flash_rodata_start+0x26f4>)
420059f2:	e99c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420059f5:	0008e0        	callx8	a8
                          (uint32_t) MEMPROT_OP_NONE, check_val);
            abort();
420059f8:	e9b981        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
420059fb:	0008e0        	callx8	a8
        }

        //DRAM0 perms
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_0, &check_val, DEFAULT_CPU_NUM))
420059fe:	fc7c      	movi.n	a12, -1
42005a00:	b18b      	addi.n	a11, a1, 8
42005a02:	0a1c      	movi.n	a10, 16
42005a04:	ff4465        	call8	42004e4c <esp_mprot_get_pms_area>
42005a07:	0a2d      	mov.n	a2, a10
42005a09:	237a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != MEMPROT_OP_READ) {
42005a0c:	21c8      	l32i.n	a12, a1, 8
42005a0e:	101c26        	beqi	a12, 1, 42005a22 <esp_mprot_set_prot+0x5e6>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_0 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005a11:	1b0c      	movi.n	a11, 1
42005a13:	eb2ca1        	l32r	a10, 420006c4 <_stext+0x6a4> (3c022870 <_flash_rodata_start+0x2750>)
42005a16:	e99381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005a19:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ, check_val);
            abort();
42005a1c:	e9b081        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005a1f:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_1, &check_val, DEFAULT_CPU_NUM))
42005a22:	fc7c      	movi.n	a12, -1
42005a24:	b18b      	addi.n	a11, a1, 8
42005a26:	0a2c      	movi.n	a10, 32
42005a28:	ff4225        	call8	42004e4c <esp_mprot_get_pms_area>
42005a2b:	0a2d      	mov.n	a2, a10
42005a2d:	213a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42005a30:	21c8      	l32i.n	a12, a1, 8
42005a32:	103c26        	beqi	a12, 3, 42005a46 <esp_mprot_set_prot+0x60a>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_1 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005a35:	3b0c      	movi.n	a11, 3
42005a37:	eb24a1        	l32r	a10, 420006c8 <_stext+0x6a8> (3c0228cc <_flash_rodata_start+0x27ac>)
42005a3a:	e98a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005a3d:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
42005a40:	e9a781        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005a43:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_2, &check_val, DEFAULT_CPU_NUM))
42005a46:	fc7c      	movi.n	a12, -1
42005a48:	b18b      	addi.n	a11, a1, 8
42005a4a:	0a4c      	movi.n	a10, 64
42005a4c:	ff3fe5        	call8	42004e4c <esp_mprot_get_pms_area>
42005a4f:	0a2d      	mov.n	a2, a10
42005a51:	1efa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42005a54:	21c8      	l32i.n	a12, a1, 8
42005a56:	103c26        	beqi	a12, 3, 42005a6a <esp_mprot_set_prot+0x62e>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_2 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005a59:	3b0c      	movi.n	a11, 3
42005a5b:	eb1ca1        	l32r	a10, 420006cc <_stext+0x6ac> (3c022928 <_flash_rodata_start+0x2808>)
42005a5e:	e98181        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005a61:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
42005a64:	e99e81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005a67:	0008e0        	callx8	a8
        }

        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_3, &check_val, DEFAULT_CPU_NUM))
42005a6a:	fc7c      	movi.n	a12, -1
42005a6c:	b18b      	addi.n	a11, a1, 8
42005a6e:	80a0a2        	movi	a10, 128
42005a71:	ff3da5        	call8	42004e4c <esp_mprot_get_pms_area>
42005a74:	0a2d      	mov.n	a2, a10
42005a76:	1caa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42005a79:	21c8      	l32i.n	a12, a1, 8
42005a7b:	103c26        	beqi	a12, 3, 42005a8f <esp_mprot_set_prot+0x653>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_3 configuration corrupted (expected 0x%08" PRIX32 ", stored 0x%08" PRIX32 ")\n",
42005a7e:	3b0c      	movi.n	a11, 3
42005a80:	eb14a1        	l32r	a10, 420006d0 <_stext+0x6b0> (3c022984 <_flash_rodata_start+0x2864>)
42005a83:	e97881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005a86:	0008e0        	callx8	a8
                           (uint32_t)MEMPROT_OP_READ | MEMPROT_OP_WRITE, check_val);
            abort();
42005a89:	e99481        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005a8c:	0008e0        	callx8	a8
        }

        //memory protection enabled
        bool enabled;
        if (use_iram0) {
42005a8f:	5188      	l32i.n	a8, a1, 20
42005a91:	68fc      	bnez.n	a8, 42005acb <esp_mprot_set_prot+0x68f>
42005a93:	000e46        	j	42005ad0 <esp_mprot_set_prot+0x694>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, &enabled,
42005a96:	844b      	addi.n	a8, a4, 4
42005a98:	a08870        	addx4	a8, a8, a7
42005a9b:	08c8      	l32i.n	a12, a8, 0
42005a9d:	b1db      	addi.n	a11, a1, 13
42005a9f:	1a0c      	movi.n	a10, 1
42005aa1:	ff73a5        	call8	420051dc <esp_mprot_get_monitor_en>
42005aa4:	0a2d      	mov.n	a2, a10
42005aa6:	19aa56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                                      memp_config->target_cpu[x]))
                if (!enabled) {
42005aa9:	0d0182        	l8ui	a8, a1, 13
42005aac:	68dc      	bnez.n	a8, 42005ac6 <esp_mprot_set_prot+0x68a>
                    esp_rom_printf(
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not enabled on core %d)\n",
                        memp_config->target_cpu[x]);
42005aae:	04c482        	addi	a8, a4, 4
42005ab1:	a08870        	addx4	a8, a8, a7
                    esp_rom_printf(
42005ab4:	0028b2        	l32i	a11, a8, 0
42005ab7:	eb07a1        	l32r	a10, 420006d4 <_stext+0x6b4> (3c0229e0 <_flash_rodata_start+0x28c0>)
42005aba:	e96a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005abd:	0008e0        	callx8	a8
                    abort();
42005ac0:	e98781        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005ac3:	0008e0        	callx8	a8
            for (size_t x = 0; x < core_count; x++) {
42005ac6:	441b      	addi.n	a4, a4, 1
42005ac8:	000046        	j	42005acd <esp_mprot_set_prot+0x691>
42005acb:	054d      	mov.n	a4, a5
42005acd:	c53467        	bltu	a4, a6, 42005a96 <esp_mprot_set_prot+0x65a>
                }
            }
        }
        if (use_dram0) {
42005ad0:	83fc      	bnez.n	a3, 42005b0c <esp_mprot_set_prot+0x6d0>
42005ad2:	000ec6        	j	42005b11 <esp_mprot_set_prot+0x6d5>
            for (size_t x = 0; x < core_count; x++) {
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, &enabled,
42005ad5:	04c482        	addi	a8, a4, 4
42005ad8:	a08870        	addx4	a8, a8, a7
42005adb:	0028c2        	l32i	a12, a8, 0
42005ade:	0dc1b2        	addi	a11, a1, 13
42005ae1:	2a0c      	movi.n	a10, 2
42005ae3:	ff6fa5        	call8	420051dc <esp_mprot_get_monitor_en>
42005ae6:	0a2d      	mov.n	a2, a10
42005ae8:	158a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                                      memp_config->target_cpu[x]))
                if (!enabled) {
42005aeb:	0d0182        	l8ui	a8, a1, 13
42005aee:	48dc      	bnez.n	a8, 42005b06 <esp_mprot_set_prot+0x6ca>
                    esp_rom_printf(
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not enabled on core %d)\n",
                        memp_config->target_cpu[x]);
42005af0:	844b      	addi.n	a8, a4, 4
42005af2:	a08870        	addx4	a8, a8, a7
                    esp_rom_printf(
42005af5:	08b8      	l32i.n	a11, a8, 0
42005af7:	eaf8a1        	l32r	a10, 420006d8 <_stext+0x6b8> (3c022a3c <_flash_rodata_start+0x291c>)
42005afa:	e95a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005afd:	0008e0        	callx8	a8
                    abort();
42005b00:	e97781        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005b03:	0008e0        	callx8	a8
            for (size_t x = 0; x < core_count; x++) {
42005b06:	441b      	addi.n	a4, a4, 1
42005b08:	000086        	j	42005b0e <esp_mprot_set_prot+0x6d2>
42005b0b:	054d00        	extui	a4, a0, 29, 1
42005b0e:	c33467        	bltu	a4, a6, 42005ad5 <esp_mprot_set_prot+0x699>
                }
            }
        }

        //locks
        if (memp_config->lock_feature) {
42005b11:	010782        	l8ui	a8, a7, 1
42005b14:	103816        	beqz	a8, 42005c1b <esp_mprot_set_prot+0x7df>

            bool locked;

            if (use_iram0) {
42005b17:	5188      	l32i.n	a8, a1, 20
42005b19:	080816        	beqz	a8, 42005b9d <esp_mprot_set_prot+0x761>
                ESP_MEMPROT_ERR_CHECK(ret,
42005b1c:	fc7c      	movi.n	a12, -1
42005b1e:	b1cb      	addi.n	a11, a1, 12
42005b20:	1a0c      	movi.n	a10, 1
42005b22:	ff0865        	call8	42004ba8 <esp_mprot_get_split_addr_lock>
42005b25:	0a2d      	mov.n	a2, a10
42005b27:	119a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                                      esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
                if (!locked) {
42005b2a:	0c0182        	l8ui	a8, a1, 12
42005b2d:	d8cc      	bnez.n	a8, 42005b3e <esp_mprot_set_prot+0x702>
                    esp_rom_printf(
42005b2f:	eaeba1        	l32r	a10, 420006dc <_stext+0x6bc> (3c022a98 <_flash_rodata_start+0x2978>)
42005b32:	e94c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005b35:	0008e0        	callx8	a8
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - split address lock)\n");
                    abort();
42005b38:	e96981        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005b3b:	0008e0        	callx8	a8
                }
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
42005b3e:	ffafc2        	movi	a12, -1
42005b41:	0cc1b2        	addi	a11, a1, 12
42005b44:	01a0a2        	movi	a10, 1
42005b47:	ff12e5        	call8	42004c74 <esp_mprot_get_pms_lock>
42005b4a:	0a2d      	mov.n	a2, a10
42005b4c:	0f4a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                if (!locked) {
42005b4f:	0c0182        	l8ui	a8, a1, 12
42005b52:	042856        	bnez	a8, 42005b98 <esp_mprot_set_prot+0x75c>
                    esp_rom_printf(
42005b55:	eae2a1        	l32r	a10, 420006e0 <_stext+0x6c0> (3c022afc <_flash_rodata_start+0x29dc>)
42005b58:	e94381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005b5b:	0008e0        	callx8	a8
                        "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - global PMS lock)\n");
                    abort();
42005b5e:	e95f81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005b61:	0008e0        	callx8	a8
                }
                for (size_t x = 0; x < core_count; x++) {
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked,
42005b64:	844b      	addi.n	a8, a4, 4
42005b66:	a08870        	addx4	a8, a8, a7
42005b69:	08c8      	l32i.n	a12, a8, 0
42005b6b:	b1cb      	addi.n	a11, a1, 12
42005b6d:	1a0c      	movi.n	a10, 1
42005b6f:	ff5b25        	call8	42005120 <esp_mprot_get_monitor_lock>
42005b72:	0a2d      	mov.n	a2, a10
42005b74:	0cca56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                                          memp_config->target_cpu[x]))
                    if (!locked) {
42005b77:	0c0182        	l8ui	a8, a1, 12
42005b7a:	48dc      	bnez.n	a8, 42005b92 <esp_mprot_set_prot+0x756>
                        esp_rom_printf(
                            "Fatal error: IRAM0 PMS configuration corrupted (memory protection not locked - monitor lock on core %d)\n",
                            memp_config->target_cpu[x]);
42005b7c:	844b      	addi.n	a8, a4, 4
42005b7e:	a08870        	addx4	a8, a8, a7
                        esp_rom_printf(
42005b81:	08b8      	l32i.n	a11, a8, 0
42005b83:	ead8a1        	l32r	a10, 420006e4 <_stext+0x6c4> (3c022b60 <_flash_rodata_start+0x2a40>)
42005b86:	e93781        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005b89:	0008e0        	callx8	a8
                        abort();
42005b8c:	e95481        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005b8f:	0008e0        	callx8	a8
                for (size_t x = 0; x < core_count; x++) {
42005b92:	441b      	addi.n	a4, a4, 1
42005b94:	000086        	j	42005b9a <esp_mprot_set_prot+0x75e>
42005b97:	054d00        	extui	a4, a0, 29, 1
42005b9a:	c63467        	bltu	a4, a6, 42005b64 <esp_mprot_set_prot+0x728>
                    }
                }
            }

            if (use_dram0) {
42005b9d:	07a316        	beqz	a3, 42005c1b <esp_mprot_set_prot+0x7df>
                ESP_MEMPROT_ERR_CHECK(ret,
42005ba0:	fc7c      	movi.n	a12, -1
42005ba2:	b1cb      	addi.n	a11, a1, 12
42005ba4:	2a0c      	movi.n	a10, 2
42005ba6:	ff0025        	call8	42004ba8 <esp_mprot_get_split_addr_lock>
42005ba9:	0a2d      	mov.n	a2, a10
42005bab:	095a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                                      esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
                if (!locked) {
42005bae:	0c0182        	l8ui	a8, a1, 12
42005bb1:	d8cc      	bnez.n	a8, 42005bc2 <esp_mprot_set_prot+0x786>
                    esp_rom_printf(
42005bb3:	eacda1        	l32r	a10, 420006e8 <_stext+0x6c8> (3c022bcc <_flash_rodata_start+0x2aac>)
42005bb6:	e92b81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005bb9:	0008e0        	callx8	a8
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - split address lock)\n");
                    abort();
42005bbc:	e94881        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005bbf:	0008e0        	callx8	a8
                }
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked, DEFAULT_CPU_NUM))
42005bc2:	ffafc2        	movi	a12, -1
42005bc5:	0cc1b2        	addi	a11, a1, 12
42005bc8:	02a0a2        	movi	a10, 2
42005bcb:	ff0aa5        	call8	42004c74 <esp_mprot_get_pms_lock>
42005bce:	0a2d      	mov.n	a2, a10
42005bd0:	070a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                if (!locked) {
42005bd3:	0c0182        	l8ui	a8, a1, 12
42005bd6:	03e856        	bnez	a8, 42005c18 <esp_mprot_set_prot+0x7dc>
                    esp_rom_printf(
42005bd9:	eac4a1        	l32r	a10, 420006ec <_stext+0x6cc> (3c022c30 <_flash_rodata_start+0x2b10>)
42005bdc:	e92281        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005bdf:	0008e0        	callx8	a8
                        "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - global PMS lock)\n");
                    abort();
42005be2:	e93e81        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005be5:	0008e0        	callx8	a8
                }
                for (size_t x = 0; x < core_count; x++) {
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked,
42005be8:	854b      	addi.n	a8, a5, 4
42005bea:	a08870        	addx4	a8, a8, a7
42005bed:	08c8      	l32i.n	a12, a8, 0
42005bef:	b1cb      	addi.n	a11, a1, 12
42005bf1:	2a0c      	movi.n	a10, 2
42005bf3:	ff52e5        	call8	42005120 <esp_mprot_get_monitor_lock>
42005bf6:	0a2d      	mov.n	a2, a10
42005bf8:	048a56        	bnez	a10, 42005c44 <esp_mprot_set_prot+0x808>
                                          memp_config->target_cpu[x]))
                    if (!locked) {
42005bfb:	0c0182        	l8ui	a8, a1, 12
42005bfe:	48dc      	bnez.n	a8, 42005c16 <esp_mprot_set_prot+0x7da>
                        esp_rom_printf(
                            "Fatal error: DRAM0 PMS configuration corrupted (memory protection not locked - monitor lock on core %d)\n",
                            memp_config->target_cpu[x]);
42005c00:	854b      	addi.n	a8, a5, 4
42005c02:	a08870        	addx4	a8, a8, a7
                        esp_rom_printf(
42005c05:	08b8      	l32i.n	a11, a8, 0
42005c07:	eabaa1        	l32r	a10, 420006f0 <_stext+0x6d0> (3c022c94 <_flash_rodata_start+0x2b74>)
42005c0a:	e91681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
42005c0d:	0008e0        	callx8	a8
                        abort();
42005c10:	e93381        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42005c13:	0008e0        	callx8	a8
                for (size_t x = 0; x < core_count; x++) {
42005c16:	551b      	addi.n	a5, a5, 1
42005c18:	cc3567        	bltu	a5, a6, 42005be8 <esp_mprot_set_prot+0x7ac>
            }
        }
    }

    //keep current configuration copy if all went well
    if (ret == ESP_OK) {
42005c1b:	52ec      	bnez.n	a2, 42005c44 <esp_mprot_set_prot+0x808>
        s_memp_cfg = *memp_config;
42005c1d:	18a0c2        	movi	a12, 24
42005c20:	20b770        	or	a11, a7, a7
42005c23:	ea92a1        	l32r	a10, 4200066c <_stext+0x64c> (3fc9246c <s_memp_cfg>)
42005c26:	e90081        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42005c29:	0008e0        	callx8	a8
42005c2c:	000506        	j	42005c44 <esp_mprot_set_prot+0x808>
42005c2f:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
42005c32:	034602        	s8i	a0, a6, 3
42005c35:	000000        	ill
        return ESP_ERR_NO_MEM;
42005c38:	01a122        	movi	a2, 0x101
42005c3b:	000146        	j	42005c44 <esp_mprot_set_prot+0x808>
42005c3e:	000000        	ill
        return ESP_ERR_MEMPROT_CPUID_INVALID;
42005c41:	ea8921        	l32r	a2, 42000668 <_stext+0x648> (d008 <UserFrameTotalSize+0xcf08>)
    }

    return ret;
}
42005c44:	f01d      	retw.n
	...

42005c48 <esp_mprot_ll_err_to_esp_err>:
#include "esp_memprot_err.h"
#include "hal/memprot_types.h"
#include "esp_memprot_types.h"

esp_err_t esp_mprot_ll_err_to_esp_err(const memprot_hal_err_t err)
{
42005c48:	004136        	entry	a1, 32
    switch (err) {
42005c4b:	194226        	beqi	a2, 4, 42005c68 <esp_mprot_ll_err_to_esp_err+0x20>
42005c4e:	0a52e6        	bgei	a2, 5, 42005c5c <esp_mprot_ll_err_to_esp_err+0x14>
42005c51:	1b2226        	beqi	a2, 2, 42005c70 <esp_mprot_ll_err_to_esp_err+0x28>
42005c54:	203226        	beqi	a2, 3, 42005c78 <esp_mprot_ll_err_to_esp_err+0x30>
42005c57:	32ec      	bnez.n	a2, 42005c7e <esp_mprot_ll_err_to_esp_err+0x36>
42005c59:	000bc6        	j	42005c8c <esp_mprot_ll_err_to_esp_err+0x44>
42005c5c:	245226        	beqi	a2, 5, 42005c84 <esp_mprot_ll_err_to_esp_err+0x3c>
42005c5f:	276266        	bnei	a2, 6, 42005c8a <esp_mprot_ll_err_to_esp_err+0x42>
    case MEMP_HAL_OK: return ESP_OK;
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
    case MEMP_HAL_ERR_WORLD_INVALID: return ESP_ERR_MEMPROT_WORLD_INVALID;
42005c62:	eaa821        	l32r	a2, 42000704 <_stext+0x6e4> (d006 <UserFrameTotalSize+0xcf06>)
42005c65:	0008c6        	j	42005c8c <esp_mprot_ll_err_to_esp_err+0x44>
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
42005c68:	eaa621        	l32r	a2, 42000700 <_stext+0x6e0> (d005 <UserFrameTotalSize+0xcf05>)
42005c6b:	000746        	j	42005c8c <esp_mprot_ll_err_to_esp_err+0x44>
42005c6e:	210000        	srai	a0, a0, 0
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
42005c71:	46eaa2        	s32c1i	a10, a10, 0x118
42005c74:	000005        	call0	42005c78 <esp_mprot_ll_err_to_esp_err+0x30>
42005c77:	a12100        	sll	a2, a1
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
42005c7a:	46ea      	add.n	a4, a6, a14
42005c7c:	7c0003        	lsi	f0, a0, 0x1f0
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
    default:
        return ESP_FAIL;
42005c7f:	0206f2        	l8ui	a15, a6, 2
42005c82:	210000        	srai	a0, a0, 0
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
42005c85:	46eaa1        	l32r	a10, 41fd7830 <_iram_bss_end+0x1c55430>
42005c88:	00          	.byte	00
42005c89:	f27c00        	rems	a7, a12, a0
    }
}
42005c8c:	f01d      	retw.n
	...

42005c90 <esp_cpu_intr_get_desc>:
    [31] = { 5, ESP_CPU_INTR_TYPE_LEVEL, { 0,                              0                               } },
};


void esp_cpu_intr_get_desc(int core_id, int intr_num, esp_cpu_intr_desc_t *intr_desc_ret)
{
42005c90:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM && intr_desc_ret != NULL);
42005c93:	180c      	movi.n	a8, 1
42005c95:	628820        	saltu	a8, a8, a2
42005c98:	880b      	addi.n	a8, a8, -1
42005c9a:	608080        	neg	a8, a8
42005c9d:	01a092        	movi	a9, 1
42005ca0:	839440        	moveqz	a9, a4, a4
42005ca3:	118897        	bany	a8, a9, 42005cb8 <esp_cpu_intr_get_desc+0x28>
42005ca6:	ea99d1        	l32r	a13, 4200070c <_stext+0x6ec> (3c022d00 <_flash_rodata_start+0x2be0>)
42005ca9:	ea99c1        	l32r	a12, 42000710 <_stext+0x6f0> (3c026d10 <__func__$0>)
42005cac:	47a0b2        	movi	a11, 71
42005caf:	ea99a1        	l32r	a10, 42000714 <_stext+0x6f4> (3c022d75 <_flash_rodata_start+0x2c55>)
42005cb2:	e91581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42005cb5:	0008e0        	callx8	a8
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
42005cb8:	ea9891        	l32r	a9, 42000718 <_stext+0x6f8> (3c026d28 <intr_desc_table>)
42005cbb:	1183c0        	slli	a8, a3, 4
42005cbe:	898a      	add.n	a8, a9, a8
42005cc0:	08a8      	l32i.n	a10, a8, 0
42005cc2:	04a9      	s32i.n	a10, a4, 0
    intr_desc_ret->type = intr_desc_table[intr_num].type;
42005cc4:	1888      	l32i.n	a8, a8, 4
42005cc6:	1489      	s32i.n	a8, a4, 4
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
42005cc8:	a03320        	addx4	a3, a3, a2
42005ccb:	a03390        	addx4	a3, a3, a9
42005cce:	2388      	l32i.n	a8, a3, 8
42005cd0:	2489      	s32i.n	a8, a4, 8
}
42005cd2:	f01d      	retw.n

42005cd4 <clk_tree_rtc_slow_calibration>:
 *
 * Returns the number of XTAL clock cycles within the given number of slow clock cycles
 * It returns 0 if calibration failed, i.e. clock is not running
 */
static uint32_t clk_tree_rtc_slow_calibration(uint32_t slowclk_cycles)
{
42005cd4:	004136        	entry	a1, 32
42005cd7:	02bd      	mov.n	a11, a2
    uint32_t cal_val = 0;
    if (slowclk_cycles > 0) {
42005cd9:	c28c      	beqz.n	a2, 42005ce9 <clk_tree_rtc_slow_calibration+0x15>
        cal_val = rtc_clk_cal(RTC_CAL_RTC_MUX, slowclk_cycles);
42005cdb:	00a0a2        	movi	a10, 0
42005cde:	e91f81        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42005ce1:	0008e0        	callx8	a8
42005ce4:	0a2d      	mov.n	a2, a10
42005ce6:	000a86        	j	42005d14 <clk_tree_rtc_slow_calibration+0x40>
    } else {
        const uint64_t cal_dividend = (1ULL << RTC_CLK_CAL_FRACT) * 1000000ULL;
        uint32_t source_approx_freq = clk_hal_lp_slow_get_freq_hz();
42005ce9:	0640a5        	call8	4200c0f4 <clk_hal_lp_slow_get_freq_hz>
42005cec:	20caa0        	or	a12, a10, a10
        assert(source_approx_freq);
42005cef:	011a56        	bnez	a10, 42005d04 <clk_tree_rtc_slow_calibration+0x30>
42005cf2:	ea8ad1        	l32r	a13, 4200071c <_stext+0x6fc> (3c022e54 <_flash_rodata_start+0x2d34>)
42005cf5:	ea8ac1        	l32r	a12, 42000720 <_stext+0x700> (3c026f68 <__func__$1>)
42005cf8:	42a0b2        	movi	a11, 66
42005cfb:	ea8aa1        	l32r	a10, 42000724 <_stext+0x704> (3c022e8d <_flash_rodata_start+0x2d6d>)
42005cfe:	e90281        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42005d01:	0008e0        	callx8	a8
        cal_val = (uint32_t)(cal_dividend / source_approx_freq);
42005d04:	0d0c      	movi.n	a13, 0
42005d06:	ea88a1        	l32r	a10, 42000728 <_stext+0x708> (12000000 <UserFrameTotalSize+0x11ffff00>)
42005d09:	7aa0b2        	movi	a11, 122
42005d0c:	e92681        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42005d0f:	0008e0        	callx8	a8
42005d12:	0a2d      	mov.n	a2, a10
    }
    if (cal_val) {
42005d14:	628c      	beqz.n	a2, 42005d1e <clk_tree_rtc_slow_calibration+0x4a>
        ESP_EARLY_LOGD(TAG, "RTC_SLOW_CLK calibration value: %" PRIu32, cal_val);
        // Update the calibration value of RTC_SLOW_CLK
        esp_clk_slowclk_cal_set(cal_val);
42005d16:	02ad      	mov.n	a10, a2
42005d18:	e91581        	l32r	a8, 4200016c <_stext+0x14c> (40377e20 <esp_clk_slowclk_cal_set>)
42005d1b:	0008e0        	callx8	a8
    }
    return cal_val;
}
42005d1e:	f01d      	retw.n

42005d20 <esp_clk_tree_rc_fast_d256_get_freq_hz>:

#if SOC_CLK_RC_FAST_D256_SUPPORTED
uint32_t esp_clk_tree_rc_fast_d256_get_freq_hz(esp_clk_tree_src_freq_precision_t precision)
{
42005d20:	004136        	entry	a1, 32
    switch (precision) {
42005d23:	491226        	beqi	a2, 1, 42005d70 <esp_clk_tree_rc_fast_d256_get_freq_hz+0x50>
42005d26:	2b2226        	beqi	a2, 2, 42005d55 <esp_clk_tree_rc_fast_d256_get_freq_hz+0x35>
42005d29:	049256        	bnez	a2, 42005d76 <esp_clk_tree_rc_fast_d256_get_freq_hz+0x56>
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_APPROX:
        return SOC_CLK_RC_FAST_D256_FREQ_APPROX;
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_CACHED:
        if (!s_calibrated_freq.rc_fast_d256) {
42005d2c:	ea8181        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005d2f:	002882        	l32i	a8, a8, 0
42005d32:	016856        	bnez	a8, 42005d4c <esp_clk_tree_rc_fast_d256_get_freq_hz+0x2c>
            s_calibrated_freq.rc_fast_d256 = rtc_clk_freq_cal(rtc_clk_cal(RTC_CAL_8MD256, DEFAULT_32K_CLK_CAL_CYCLES));
42005d35:	64a0b2        	movi	a11, 100
42005d38:	01a0a2        	movi	a10, 1
42005d3b:	e90881        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42005d3e:	0008e0        	callx8	a8
42005d41:	ea7c81        	l32r	a8, 42000734 <_stext+0x714> (403792fc <rtc_clk_freq_cal>)
42005d44:	0008e0        	callx8	a8
42005d47:	ea7a81        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005d4a:	08a9      	s32i.n	a10, a8, 0
        }
        return s_calibrated_freq.rc_fast_d256;
42005d4c:	ea7981        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005d4f:	0828      	l32i.n	a2, a8, 0
42005d51:	0008c6        	j	42005d78 <esp_clk_tree_rc_fast_d256_get_freq_hz+0x58>
42005d54:	a0b200        	addx4	a11, a2, a0
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_EXACT:
        s_calibrated_freq.rc_fast_d256 = rtc_clk_freq_cal(rtc_clk_cal(RTC_CAL_8MD256, DEFAULT_32K_CLK_CAL_CYCLES));
42005d57:	64          	.byte	0x64
42005d58:	1a0c      	movi.n	a10, 1
42005d5a:	e90081        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42005d5d:	0008e0        	callx8	a8
42005d60:	ea7581        	l32r	a8, 42000734 <_stext+0x714> (403792fc <rtc_clk_freq_cal>)
42005d63:	0008e0        	callx8	a8
42005d66:	0a2d      	mov.n	a2, a10
42005d68:	ea7281        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005d6b:	08a9      	s32i.n	a10, a8, 0
        return s_calibrated_freq.rc_fast_d256;
42005d6d:	0001c6        	j	42005d78 <esp_clk_tree_rc_fast_d256_get_freq_hz+0x58>
    switch (precision) {
42005d70:	ea6f21        	l32r	a2, 4200072c <_stext+0x70c> (10b07 <UserFrameTotalSize+0x10a07>)
42005d73:	000046        	j	42005d78 <esp_clk_tree_rc_fast_d256_get_freq_hz+0x58>
    default:
        return 0;
42005d76:	020c      	movi.n	a2, 0
    }
}
42005d78:	f01d      	retw.n
	...

42005d7c <esp_clk_tree_xtal32k_get_freq_hz>:
#endif

#if SOC_CLK_XTAL32K_SUPPORTED
uint32_t esp_clk_tree_xtal32k_get_freq_hz(esp_clk_tree_src_freq_precision_t precision)
{
42005d7c:	004136        	entry	a1, 32
    switch (precision) {
42005d7f:	491226        	beqi	a2, 1, 42005dcc <esp_clk_tree_xtal32k_get_freq_hz+0x50>
42005d82:	2b2226        	beqi	a2, 2, 42005db1 <esp_clk_tree_xtal32k_get_freq_hz+0x35>
42005d85:	049256        	bnez	a2, 42005dd2 <esp_clk_tree_xtal32k_get_freq_hz+0x56>
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_APPROX:
        return SOC_CLK_XTAL32K_FREQ_APPROX;
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_CACHED:
        if (!s_calibrated_freq.xtal32k) {
42005d88:	ea6a81        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005d8b:	012882        	l32i	a8, a8, 4
42005d8e:	016856        	bnez	a8, 42005da8 <esp_clk_tree_xtal32k_get_freq_hz+0x2c>
            s_calibrated_freq.xtal32k = rtc_clk_freq_cal(rtc_clk_cal(RTC_CAL_32K_XTAL, DEFAULT_32K_CLK_CAL_CYCLES));
42005d91:	64a0b2        	movi	a11, 100
42005d94:	02a0a2        	movi	a10, 2
42005d97:	e8f181        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42005d9a:	0008e0        	callx8	a8
42005d9d:	ea6581        	l32r	a8, 42000734 <_stext+0x714> (403792fc <rtc_clk_freq_cal>)
42005da0:	0008e0        	callx8	a8
42005da3:	ea6381        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005da6:	18a9      	s32i.n	a10, a8, 4
        }
        return s_calibrated_freq.xtal32k;
42005da8:	ea6281        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005dab:	1828      	l32i.n	a2, a8, 4
42005dad:	0008c6        	j	42005dd4 <esp_clk_tree_xtal32k_get_freq_hz+0x58>
42005db0:	a0b200        	addx4	a11, a2, a0
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_EXACT:
        s_calibrated_freq.xtal32k = rtc_clk_freq_cal(rtc_clk_cal(RTC_CAL_32K_XTAL, DEFAULT_32K_CLK_CAL_CYCLES));
42005db3:	64          	.byte	0x64
42005db4:	2a0c      	movi.n	a10, 2
42005db6:	e8e981        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42005db9:	0008e0        	callx8	a8
42005dbc:	ea5e81        	l32r	a8, 42000734 <_stext+0x714> (403792fc <rtc_clk_freq_cal>)
42005dbf:	0008e0        	callx8	a8
42005dc2:	0a2d      	mov.n	a2, a10
42005dc4:	ea5b81        	l32r	a8, 42000730 <_stext+0x710> (3fc94f94 <s_calibrated_freq>)
42005dc7:	18a9      	s32i.n	a10, a8, 4
        return s_calibrated_freq.xtal32k;
42005dc9:	0001c6        	j	42005dd4 <esp_clk_tree_xtal32k_get_freq_hz+0x58>
    switch (precision) {
42005dcc:	e92321        	l32r	a2, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
42005dcf:	000046        	j	42005dd4 <esp_clk_tree_xtal32k_get_freq_hz+0x58>
    default:
        return 0;
42005dd2:	020c      	movi.n	a2, 0
    }
}
42005dd4:	f01d      	retw.n
	...

42005dd8 <esp_clk_tree_lp_slow_get_freq_hz>:
    }
}
#endif

uint32_t esp_clk_tree_lp_slow_get_freq_hz(esp_clk_tree_src_freq_precision_t precision)
{
42005dd8:	004136        	entry	a1, 32
    switch (precision) {
42005ddb:	171226        	beqi	a2, 1, 42005df6 <esp_clk_tree_lp_slow_get_freq_hz+0x1e>
42005dde:	1f2226        	beqi	a2, 2, 42005e01 <esp_clk_tree_lp_slow_get_freq_hz+0x29>
42005de1:	02fc      	bnez.n	a2, 42005e15 <esp_clk_tree_lp_slow_get_freq_hz+0x3d>
    return REG_READ(RTC_SLOW_CLK_CAL_REG);
42005de3:	ea5581        	l32r	a8, 42000738 <_stext+0x718> (60008054 <RTCCNTL+0x54>)
42005de6:	0020c0        	memw
42005de9:	08a8      	l32i.n	a10, a8, 0
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_CACHED:
        // This returns calibrated (if CONFIG_xxx_RTC_CLK_CAL_CYCLES) value stored in RTC storage register
        return rtc_clk_freq_cal(clk_ll_rtc_slow_load_cal());
42005deb:	ea5281        	l32r	a8, 42000734 <_stext+0x714> (403792fc <rtc_clk_freq_cal>)
42005dee:	0008e0        	callx8	a8
42005df1:	0a2d      	mov.n	a2, a10
42005df3:	000806        	j	42005e17 <esp_clk_tree_lp_slow_get_freq_hz+0x3f>
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_APPROX:
        return clk_hal_lp_slow_get_freq_hz();
42005df6:	062fe5        	call8	4200c0f4 <clk_hal_lp_slow_get_freq_hz>
42005df9:	0a2d      	mov.n	a2, a10
42005dfb:	000606        	j	42005e17 <esp_clk_tree_lp_slow_get_freq_hz+0x3f>
42005dfe:	000000        	ill
    case ESP_CLK_TREE_SRC_FREQ_PRECISION_EXACT:
        return rtc_clk_freq_cal(clk_tree_rtc_slow_calibration(RTC_SLOW_CLK_CAL_CYCLES));
42005e01:	00a4a2        	movi	a10, 0x400
42005e04:	ffece5        	call8	42005cd4 <clk_tree_rtc_slow_calibration>
42005e07:	ea4b81        	l32r	a8, 42000734 <_stext+0x714> (403792fc <rtc_clk_freq_cal>)
42005e0a:	0008e0        	callx8	a8
42005e0d:	0a2d      	mov.n	a2, a10
42005e0f:	000106        	j	42005e17 <esp_clk_tree_lp_slow_get_freq_hz+0x3f>
42005e12:	000000        	ill
    switch (precision) {
42005e15:	020c      	movi.n	a2, 0
    default:
        return 0;
    }
}
42005e17:	f01d      	retw.n
42005e19:	000000        	ill

42005e1c <esp_clk_tree_rc_fast_get_freq_hz>:

uint32_t esp_clk_tree_rc_fast_get_freq_hz(esp_clk_tree_src_freq_precision_t precision)
{
42005e1c:	004136        	entry	a1, 32
42005e1f:	02ad      	mov.n	a10, a2
#if SOC_CLK_RC_FAST_SUPPORT_CALIBRATION
    if (precision == ESP_CLK_TREE_SRC_FREQ_PRECISION_APPROX) {
42005e21:	0b1226        	beqi	a2, 1, 42005e30 <esp_clk_tree_rc_fast_get_freq_hz+0x14>
        return SOC_CLK_RC_FAST_FREQ_APPROX;
    }
#if SOC_CLK_RC_FAST_D256_SUPPORTED
    // If RC_FAST_D256 clock exists, calibration on a slow freq clock is much faster (less slow clock cycles need to wait)
    return esp_clk_tree_rc_fast_d256_get_freq_hz(precision) << 8;
42005e24:	ffefa5        	call8	42005d20 <esp_clk_tree_rc_fast_d256_get_freq_hz>
42005e27:	112a80        	slli	a2, a10, 8
42005e2a:	000146        	j	42005e33 <esp_clk_tree_rc_fast_get_freq_hz+0x17>
42005e2d:	000000        	ill
        return SOC_CLK_RC_FAST_FREQ_APPROX;
42005e30:	ea4321        	l32r	a2, 4200073c <_stext+0x71c> (10b0760 <UserFrameTotalSize+0x10b0660>)
        // No way of getting exact rc_fast freq
        ESP_HW_LOGW(TAG, "unable to get the exact freq of rc_fast_clk, returning its approx. freq value");
    }
    return SOC_CLK_RC_FAST_FREQ_APPROX;
#endif //SOC_CLK_RC_FAST_SUPPORT_CALIBRATION
}
42005e33:	f01d      	retw.n
42005e35:	000000        	ill

42005e38 <esp_clk_tree_lp_fast_get_freq_hz>:

uint32_t esp_clk_tree_lp_fast_get_freq_hz(esp_clk_tree_src_freq_precision_t precision)
{
42005e38:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL);
42005e3b:	ea4181        	l32r	a8, 42000740 <_stext+0x720> (60008074 <RTCCNTL+0x74>)
42005e3e:	0020c0        	memw
42005e41:	0888      	l32i.n	a8, a8, 0
42005e43:	059d80        	extui	a9, a8, 29, 1
    switch (clk_sel) {
42005e46:	0678d7        	bbci	a8, 29, 42005e50 <esp_clk_tree_lp_fast_get_freq_hz+0x18>
42005e49:	271926        	beqi	a9, 1, 42005e74 <esp_clk_tree_lp_fast_get_freq_hz+0x3c>
42005e4c:	000486        	j	42005e62 <esp_clk_tree_lp_fast_get_freq_hz+0x2a>
42005e4f:	00          	.byte	00
    case SOC_RTC_FAST_CLK_SRC_XTAL:
        return clk_hal_xtal_get_freq_mhz() * MHZ;
#endif
#if SOC_CLK_LP_FAST_SUPPORT_XTAL_D2
    case SOC_RTC_FAST_CLK_SRC_XTAL_D2:
        return clk_hal_xtal_get_freq_mhz() * MHZ >> 1;
42005e50:	062e25        	call8	4200c134 <clk_hal_xtal_get_freq_mhz>
42005e53:	ea3c81        	l32r	a8, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
42005e56:	822a80        	mull	a2, a10, a8
42005e59:	412120        	srli	a2, a2, 1
42005e5c:	000b06        	j	42005e8c <esp_clk_tree_lp_fast_get_freq_hz+0x54>
42005e5f:	000000        	ill
    case SOC_RTC_FAST_CLK_SRC_XTAL_D4:
        return clk_hal_xtal_get_freq_mhz() * MHZ >> 2;
#endif
    default:
        // Invalid clock source
        assert(false);
42005e62:	ea39d1        	l32r	a13, 42000748 <_stext+0x728> (3c022ea4 <_flash_rodata_start+0x2d84>)
42005e65:	ea39c1        	l32r	a12, 4200074c <_stext+0x72c> (3c026f44 <__func__$0>)
42005e68:	c8a0b2        	movi	a11, 200
42005e6b:	ea2ea1        	l32r	a10, 42000724 <_stext+0x704> (3c022e8d <_flash_rodata_start+0x2d6d>)
42005e6e:	e8a681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42005e71:	0008e0        	callx8	a8
        return esp_clk_tree_rc_fast_get_freq_hz(precision) / clk_ll_rc_fast_get_divider();
42005e74:	20a220        	or	a10, a2, a2
42005e77:	fffa65        	call8	42005e1c <esp_clk_tree_rc_fast_get_freq_hz>
    return REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_CK8M_DIV_SEL) + 1;
42005e7a:	ea3181        	l32r	a8, 42000740 <_stext+0x720> (60008074 <RTCCNTL+0x74>)
42005e7d:	0020c0        	memw
42005e80:	002882        	l32i	a8, a8, 0
42005e83:	248c80        	extui	a8, a8, 12, 3
42005e86:	01c882        	addi	a8, a8, 1
42005e89:	c22a80        	quou	a2, a10, a8
        return 0;
    }
}
42005e8c:	f01d      	retw.n
	...

42005e90 <__esp_system_init_fn_init_libc>:
#include "esp_newlib.h"
#include "esp_private/startup_internal.h"
#include "esp_bit_defs.h"

ESP_SYSTEM_INIT_FN(init_libc, CORE, BIT(0), 102)
{
42005e90:	004136        	entry	a1, 32
    esp_libc_init();
42005e93:	003ca5        	call8	4200625c <esp_libc_init>
    return ESP_OK;
}
42005e96:	020c      	movi.n	a2, 0
42005e98:	f01d      	retw.n
	...

42005e9c <__esp_system_init_fn_init_libc_stdio>:

ESP_SYSTEM_INIT_FN(init_libc_stdio, CORE, BIT(0), 115)
{
42005e9c:	004136        	entry	a1, 32
#if CONFIG_VFS_SUPPORT_IO
    esp_libc_init_global_stdio("/dev/console");
#else
    esp_libc_init_global_stdio();
42005e9f:	0040a5        	call8	420062a8 <esp_libc_init_global_stdio>
#endif
    return ESP_OK;
}
42005ea2:	020c      	movi.n	a2, 0
42005ea4:	f01d      	retw.n
	...

42005ea8 <esp_libc_newlib_locks_init>:
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___dd_hash_mutex;
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___arc4random_mutex;

#if CONFIG_LIBC_NEWLIB
static void esp_libc_newlib_locks_init(void)
{
42005ea8:	006136        	entry	a1, 48
     * No access to lock variables for the purpose of ECO forward compatibility,
     * however we have an API to initialize lock variables used in the ROM.
     */
    extern void esp_rom_newlib_init_common_mutexes(_LOCK_T, _LOCK_T);
    /* See notes about ROM_NEEDS_MUTEX_OVERRIDE above */
    int magic_val = ROM_MUTEX_MAGIC;
42005eab:	ea2981        	l32r	a8, 42000750 <_stext+0x730> (bb10c433 <_rtc_reserved_end+0x5b00c433>)
42005eae:	0189      	s32i.n	a8, a1, 0
    _LOCK_T magic_mutex = (_LOCK_T) &magic_val;
    esp_rom_newlib_init_common_mutexes(magic_mutex, magic_mutex);
42005eb0:	01bd      	mov.n	a11, a1
42005eb2:	01ad      	mov.n	a10, a1
42005eb4:	ea2881        	l32r	a8, 42000754 <_stext+0x734> (400011dc <esp_rom_newlib_init_common_mutexes>)
42005eb7:	0008e0        	callx8	a8
#else // other target
#error Unsupported target
#endif
}
42005eba:	f01d      	retw.n

42005ebc <esp_libc_locks_init>:
#endif // CONFIG_LIBC_NEWLIB

/* TODO IDF-11226 */
void esp_newlib_locks_init(void) __attribute__((alias("esp_libc_locks_init")));
void esp_libc_locks_init(void)
{
42005ebc:	004136        	entry	a1, 32
    /* Initialize the two mutexes used for the locks above.
     * Asserts below check our assumption that SemaphoreHandle_t will always
     * point to the corresponding StaticSemaphore_t structure.
     */
    SemaphoreHandle_t handle;
    handle = xSemaphoreCreateMutexStatic(&s_common_mutex);
42005ebf:	ea2671        	l32r	a7, 42000758 <_stext+0x738> (3fc952e8 <__lock___arc4random_mutex>)
42005ec2:	07bd      	mov.n	a11, a7
42005ec4:	1a0c      	movi.n	a10, 1
42005ec6:	e94e81        	l32r	a8, 42000400 <_stext+0x3e0> (40379b84 <xQueueCreateMutexStatic>)
42005ec9:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_mutex);
42005ecc:	1117a7        	beq	a7, a10, 42005ee1 <esp_libc_locks_init+0x25>
42005ecf:	ea23d1        	l32r	a13, 4200075c <_stext+0x73c> (3c023d00 <_flash_rodata_start+0x3be0>)
42005ed2:	ea23c1        	l32r	a12, 42000760 <_stext+0x740> (3c0273a8 <__func__$4>)
42005ed5:	a6a1b2        	movi	a11, 0x1a6
42005ed8:	ea23a1        	l32r	a10, 42000764 <_stext+0x744> (3c023cb4 <_flash_rodata_start+0x3b94>)
42005edb:	e88b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42005ede:	0008e0        	callx8	a8
    handle = xSemaphoreCreateRecursiveMutexStatic(&s_common_recursive_mutex);
42005ee1:	ea2171        	l32r	a7, 42000768 <_stext+0x748> (3fc95294 <__lock___atexit_recursive_mutex>)
42005ee4:	20b770        	or	a11, a7, a7
42005ee7:	04a0a2        	movi	a10, 4
42005eea:	e94581        	l32r	a8, 42000400 <_stext+0x3e0> (40379b84 <xQueueCreateMutexStatic>)
42005eed:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_recursive_mutex);
42005ef0:	1117a7        	beq	a7, a10, 42005f05 <esp_libc_locks_init+0x49>
42005ef3:	ea1ed1        	l32r	a13, 4200076c <_stext+0x74c> (3c023d30 <_flash_rodata_start+0x3c10>)
42005ef6:	ea1ac1        	l32r	a12, 42000760 <_stext+0x740> (3c0273a8 <__func__$4>)
42005ef9:	a8a1b2        	movi	a11, 0x1a8
42005efc:	ea1aa1        	l32r	a10, 42000764 <_stext+0x744> (3c023cb4 <_flash_rodata_start+0x3b94>)
42005eff:	e88281        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42005f02:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &__lock___libc_recursive_mutex);
#endif
    (void) handle;

#if CONFIG_LIBC_NEWLIB
    esp_libc_newlib_locks_init();
42005f05:	fffa25        	call8	42005ea8 <esp_libc_newlib_locks_init>
#endif
}
42005f08:	f01d      	retw.n
	...

42005f0c <adjust_boot_time>:

static _lock_t s_time_lock;

// This function gradually changes boot_time to the correction value and immediately updates it.
static uint64_t adjust_boot_time(void)
{
42005f0c:	004136        	entry	a1, 32
#define ADJTIME_CORRECTION_FACTOR 6

    uint64_t boot_time = esp_time_impl_get_boot_time();
42005f0f:	ea1a81        	l32r	a8, 42000778 <_stext+0x758> (4037fe3c <esp_time_impl_get_boot_time>)
42005f12:	0008e0        	callx8	a8
42005f15:	202aa0        	or	a2, a10, a10
42005f18:	203bb0        	or	a3, a11, a11
    if ((boot_time == 0) || (esp_time_impl_get_time_since_boot() < s_adjtime_start_us)) {
42005f1b:	208ab0        	or	a8, a10, a11
42005f1e:	012816        	beqz	a8, 42005f34 <adjust_boot_time+0x28>
42005f21:	136ea5        	call8	4201960c <esp_time_impl_get_time_since_boot>
42005f24:	ea1381        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005f27:	0898      	l32i.n	a9, a8, 0
42005f29:	1888      	l32i.n	a8, a8, 4
42005f2b:	053b87        	bltu	a11, a8, 42005f34 <adjust_boot_time+0x28>
42005f2e:	0b98b7        	bne	a8, a11, 42005f3d <adjust_boot_time+0x31>
42005f31:	08ba97        	bgeu	a10, a9, 42005f3d <adjust_boot_time+0x31>
        s_adjtime_start_us = 0;
42005f34:	ea0f81        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005f37:	090c      	movi.n	a9, 0
42005f39:	0899      	s32i.n	a9, a8, 0
42005f3b:	1899      	s32i.n	a9, a8, 4
    }
    if (s_adjtime_start_us > 0) {
42005f3d:	ea0c91        	l32r	a9, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005f40:	0988      	l32i.n	a8, a9, 0
42005f42:	1998      	l32i.n	a9, a9, 4
42005f44:	208890        	or	a8, a8, a9
42005f47:	0d9816        	beqz	a8, 42006024 <adjust_boot_time+0x118>
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
42005f4a:	136c25        	call8	4201960c <esp_time_impl_get_time_since_boot>
        // If to call this function once per second, then (since_boot - s_adjtime_start_us) will be 1_000_000 (1 second),
        // and the correction will be equal to (1_000_000us >> 6) = 15_625 us.
        // The minimum possible correction step can be (64us >> 6) = 1us.
        // Example: if the time error is 1 second, then it will be compensate for 1 sec / 0,015625 = 64 seconds.
        int64_t correction = (since_boot >> ADJTIME_CORRECTION_FACTOR) - (s_adjtime_start_us >> ADJTIME_CORRECTION_FACTOR);
42005f4d:	018b60        	slli	a8, a11, 26
42005f50:	41d6a0        	srli	a13, a10, 6
42005f53:	20d8d0        	or	a13, a8, a13
42005f56:	4176b0        	srli	a7, a11, 6
42005f59:	ea0581        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005f5c:	1898      	l32i.n	a9, a8, 4
42005f5e:	01c960        	slli	a12, a9, 26
42005f61:	0888      	l32i.n	a8, a8, 0
42005f63:	418680        	srli	a8, a8, 6
42005f66:	208c80        	or	a8, a12, a8
42005f69:	41c690        	srli	a12, a9, 6
42005f6c:	c0e7c0        	sub	a14, a7, a12
42005f6f:	01bd87        	bgeu	a13, a8, 42005f74 <adjust_boot_time+0x68>
42005f72:	ee0b      	addi.n	a14, a14, -1
42005f74:	c0fd80        	sub	a15, a13, a8
42005f77:	0f6d      	mov.n	a6, a15
42005f79:	0e9d      	mov.n	a9, a14
        if (correction > 0) {
42005f7b:	051ee6        	bgei	a14, 1, 42005f84 <adjust_boot_time+0x78>
42005f7e:	0a2e56        	bnez	a14, 42006024 <adjust_boot_time+0x118>
42005f81:	09ff16        	beqz	a15, 42006024 <adjust_boot_time+0x118>
            s_adjtime_start_us = since_boot;
42005f84:	e9fb51        	l32r	a5, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005f87:	05a9      	s32i.n	a10, a5, 0
42005f89:	15b9      	s32i.n	a11, a5, 4
            if (s_adjtime_total_correction_us < 0) {
42005f8b:	e9fab1        	l32r	a11, 42000774 <_stext+0x754> (3fc95340 <s_adjtime_total_correction_us>)
42005f8e:	0ba8      	l32i.n	a10, a11, 0
42005f90:	1bb8      	l32i.n	a11, a11, 4
42005f92:	047bd6        	bgez	a11, 42005fdd <adjust_boot_time+0xd1>
                if ((s_adjtime_total_correction_us + correction) >= 0) {
42005f95:	eb9a      	add.n	a14, a11, a9
42005f97:	809af0        	add	a9, a10, a15
42005f9a:	02b967        	bgeu	a9, a6, 42005fa0 <adjust_boot_time+0x94>
42005f9d:	01cee2        	addi	a14, a14, 1
42005fa0:	019e96        	bltz	a14, 42005fbd <adjust_boot_time+0xb1>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42005fa3:	a2aa      	add.n	a10, a2, a10
42005fa5:	628a20        	saltu	a8, a10, a2
42005fa8:	b3ba      	add.n	a11, a3, a11
42005faa:	0a2d      	mov.n	a2, a10
42005fac:	38ba      	add.n	a3, a8, a11
                    s_adjtime_start_us = 0;
42005fae:	e9f081        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005fb1:	090c      	movi.n	a9, 0
42005fb3:	0899      	s32i.n	a9, a8, 0
42005fb5:	1899      	s32i.n	a9, a8, 4
42005fb7:	0017c6        	j	4200601a <adjust_boot_time+0x10e>
42005fba:	000000        	ill
                } else {
                    s_adjtime_total_correction_us += correction;
42005fbd:	e9eda1        	l32r	a10, 42000774 <_stext+0x754> (3fc95340 <s_adjtime_total_correction_us>)
42005fc0:	0a99      	s32i.n	a9, a10, 0
42005fc2:	1ae9      	s32i.n	a14, a10, 4
                    boot_time -= correction;
42005fc4:	c09c70        	sub	a9, a12, a7
42005fc7:	01b8d7        	bgeu	a8, a13, 42005fcc <adjust_boot_time+0xc0>
42005fca:	990b      	addi.n	a9, a9, -1
42005fcc:	c088d0        	sub	a8, a8, a13
42005fcf:	828a      	add.n	a8, a2, a8
42005fd1:	62a820        	saltu	a10, a8, a2
42005fd4:	939a      	add.n	a9, a3, a9
42005fd6:	082d      	mov.n	a2, a8
42005fd8:	3a9a      	add.n	a3, a10, a9
42005fda:	000f06        	j	4200601a <adjust_boot_time+0x10e>
                }
            } else {
                if ((s_adjtime_total_correction_us - correction) <= 0) {
42005fdd:	c09b90        	sub	a9, a11, a9
42005fe0:	01ba67        	bgeu	a10, a6, 42005fe5 <adjust_boot_time+0xd9>
42005fe3:	990b      	addi.n	a9, a9, -1
42005fe5:	c08af0        	sub	a8, a10, a15
42005fe8:	1c19e6        	bgei	a9, 1, 42006008 <adjust_boot_time+0xfc>
42005feb:	19cc      	bnez.n	a9, 42005ff0 <adjust_boot_time+0xe4>
42005fed:	017856        	bnez	a8, 42006008 <adjust_boot_time+0xfc>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42005ff0:	a2aa      	add.n	a10, a2, a10
42005ff2:	628a20        	saltu	a8, a10, a2
42005ff5:	b3ba      	add.n	a11, a3, a11
42005ff7:	0a2d      	mov.n	a2, a10
42005ff9:	38ba      	add.n	a3, a8, a11
                    s_adjtime_start_us = 0;
42005ffb:	e9dd81        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42005ffe:	090c      	movi.n	a9, 0
42006000:	0899      	s32i.n	a9, a8, 0
42006002:	1899      	s32i.n	a9, a8, 4
42006004:	000486        	j	4200601a <adjust_boot_time+0x10e>
42006007:	dba100        	movt.s	f10, f1, b0
                } else {
                    s_adjtime_total_correction_us -= correction;
4200600a:	89e9      	s32i.n	a14, a9, 32
4200600c:	990a      	add.n	a9, a9, a0
4200600e:	fa1a      	add.n	a15, a10, a1
                    boot_time += correction;
42006010:	a92092        	l32i	a9, a0, 0x2a4
42006013:	83ea62        	s32c1i	a6, a10, 0x20c
42006016:	092d      	mov.n	a2, a9
42006018:	3a8a      	add.n	a3, a10, a8
                }
            }
            esp_time_impl_set_boot_time(boot_time);
4200601a:	02ad      	mov.n	a10, a2
4200601c:	03bd      	mov.n	a11, a3
4200601e:	e9d781        	l32r	a8, 4200077c <_stext+0x75c> (4037fe60 <esp_time_impl_set_boot_time>)
42006021:	0008e0        	callx8	a8
        }
    }
    return boot_time;
}
42006024:	f01d      	retw.n
	...

42006028 <get_adjusted_boot_time>:

// Get the adjusted boot time.
static uint64_t get_adjusted_boot_time(void)
{
42006028:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
4200602b:	e9d5a1        	l32r	a10, 42000780 <_stext+0x760> (3fc9533c <s_time_lock>)
4200602e:	e9d581        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
42006031:	0008e0        	callx8	a8
    uint64_t adjust_time = adjust_boot_time();
42006034:	ffed65        	call8	42005f0c <adjust_boot_time>
42006037:	0a2d      	mov.n	a2, a10
42006039:	0b3d      	mov.n	a3, a11
    _lock_release(&s_time_lock);
4200603b:	e9d1a1        	l32r	a10, 42000780 <_stext+0x760> (3fc9533c <s_time_lock>)
4200603e:	e9d281        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
42006041:	0008e0        	callx8	a8
    return adjust_time;
}
42006044:	f01d      	retw.n
	...

42006048 <adjtime_corr_stop>:

// Applying the accumulated correction to base_time and stopping the smooth time adjustment.
static void adjtime_corr_stop(void)
{
42006048:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
4200604b:	e9cda1        	l32r	a10, 42000780 <_stext+0x760> (3fc9533c <s_time_lock>)
4200604e:	e9cd81        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
42006051:	0008e0        	callx8	a8
    if (s_adjtime_start_us != 0) {
42006054:	e9c781        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42006057:	0898      	l32i.n	a9, a8, 0
42006059:	0128a2        	l32i	a10, a8, 4
4200605c:	2089a0        	or	a8, a9, a10
4200605f:	a88c      	beqz.n	a8, 4200606d <adjtime_corr_stop+0x25>
        adjust_boot_time();
42006061:	ffeaa5        	call8	42005f0c <adjust_boot_time>
        s_adjtime_start_us = 0;
42006064:	e9c381        	l32r	a8, 42000770 <_stext+0x750> (3fc95348 <s_adjtime_start_us>)
42006067:	090c      	movi.n	a9, 0
42006069:	0899      	s32i.n	a9, a8, 0
4200606b:	1899      	s32i.n	a9, a8, 4
    }
    _lock_release(&s_time_lock);
4200606d:	e9c4a1        	l32r	a10, 42000780 <_stext+0x760> (3fc9533c <s_time_lock>)
42006070:	e9c681        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
42006073:	0008e0        	callx8	a8
}
42006076:	f01d      	retw.n

42006078 <_gettimeofday_r>:
    _gettimeofday_r(r, &tv, NULL);
    return (clock_t) tv.tv_sec;
}

WEAK_UNLESS_TIMEFUNC_IMPL int _gettimeofday_r(struct _reent *r, struct timeval *tv, void *tz)
{
42006078:	004136        	entry	a1, 32
    (void) tz;

#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
4200607b:	039316        	beqz	a3, 420060b8 <_gettimeofday_r+0x40>
        uint64_t microseconds = get_adjusted_boot_time() + esp_time_impl_get_time_since_boot();
4200607e:	fffaa5        	call8	42006028 <get_adjusted_boot_time>
42006081:	0a6d      	mov.n	a6, a10
42006083:	0b7d      	mov.n	a7, a11
42006085:	135865        	call8	4201960c <esp_time_impl_get_time_since_boot>
42006088:	77ba      	add.n	a7, a7, a11
4200608a:	66aa      	add.n	a6, a6, a10
4200608c:	01b6a7        	bgeu	a6, a10, 42006091 <_gettimeofday_r+0x19>
4200608f:	771b      	addi.n	a7, a7, 1
        tv->tv_sec = microseconds / 1000000;
42006091:	e9acc1        	l32r	a12, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
42006094:	0d0c      	movi.n	a13, 0
42006096:	20a660        	or	a10, a6, a6
42006099:	20b770        	or	a11, a7, a7
4200609c:	e84281        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
4200609f:	0008e0        	callx8	a8
420060a2:	03a9      	s32i.n	a10, a3, 0
420060a4:	13b9      	s32i.n	a11, a3, 4
        tv->tv_usec = microseconds % 1000000;
420060a6:	e9a7c1        	l32r	a12, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
420060a9:	0d0c      	movi.n	a13, 0
420060ab:	06ad      	mov.n	a10, a6
420060ad:	20b770        	or	a11, a7, a7
420060b0:	e9b781        	l32r	a8, 4200078c <_stext+0x76c> (40002574 <__umoddi3>)
420060b3:	0008e0        	callx8	a8
420060b6:	23a9      	s32i.n	a10, a3, 8
    return 0;
#else
    __errno_r(r) = ENOSYS;
    return -1;
#endif
}
420060b8:	020c      	movi.n	a2, 0
420060ba:	f01d      	retw.n

420060bc <_times_r>:
{
420060bc:	006136        	entry	a1, 48
    clock_t t = xTaskGetTickCount() * (portTICK_PERIOD_MS * CLK_TCK / 1000);
420060bf:	e9b481        	l32r	a8, 42000790 <_stext+0x770> (4037b0c0 <xTaskGetTickCount>)
420060c2:	0008e0        	callx8	a8
420060c5:	a0aaa0        	addx4	a10, a10, a10
420060c8:	80aaa0        	add	a10, a10, a10
    ptms->tms_cstime = 0;
420060cb:	00a0c2        	movi	a12, 0
420060ce:	0363c2        	s32i	a12, a3, 12
    ptms->tms_cutime = 0;
420060d1:	23c9      	s32i.n	a12, a3, 8
    ptms->tms_stime = t;
420060d3:	13a9      	s32i.n	a10, a3, 4
    ptms->tms_utime = 0;
420060d5:	03c9      	s32i.n	a12, a3, 0
    struct timeval tv = {0, 0};
420060d7:	01c9      	s32i.n	a12, a1, 0
420060d9:	11c9      	s32i.n	a12, a1, 4
420060db:	21c9      	s32i.n	a12, a1, 8
    _gettimeofday_r(r, &tv, NULL);
420060dd:	01bd      	mov.n	a11, a1
420060df:	02ad      	mov.n	a10, a2
420060e1:	fff965        	call8	42006078 <_gettimeofday_r>
}
420060e4:	0128      	l32i.n	a2, a1, 0
420060e6:	f01d      	retw.n

420060e8 <settimeofday>:

WEAK_UNLESS_TIMEFUNC_IMPL int settimeofday(const struct timeval *tv, const struct timezone *tz)
{
420060e8:	004136        	entry	a1, 32
    (void) tz;
#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
420060eb:	62bc      	beqz.n	a2, 42006125 <settimeofday+0x3d>
        adjtime_corr_stop();
420060ed:	fff5a5        	call8	42006048 <adjtime_corr_stop>
        uint64_t now = ((uint64_t) tv->tv_sec) * 1000000LL + tv->tv_usec;
420060f0:	0288      	l32i.n	a8, a2, 0
420060f2:	1278      	l32i.n	a7, a2, 4
420060f4:	e99491        	l32r	a9, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
420060f7:	827970        	mull	a7, a9, a7
420060fa:	82a980        	mull	a10, a9, a8
420060fd:	a28890        	muluh	a8, a8, a9
42006100:	778a      	add.n	a7, a7, a8
42006102:	2288      	l32i.n	a8, a2, 8
42006104:	319f80        	srai	a9, a8, 31
42006107:	779a      	add.n	a7, a7, a9
42006109:	2a8a      	add.n	a2, a10, a8
4200610b:	01b287        	bgeu	a2, a8, 42006110 <settimeofday+0x28>
4200610e:	771b      	addi.n	a7, a7, 1
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
42006110:	134fa5        	call8	4201960c <esp_time_impl_get_time_since_boot>
        esp_time_impl_set_boot_time(now - since_boot);
42006113:	c0b7b0        	sub	a11, a7, a11
42006116:	02b2a7        	bgeu	a2, a10, 4200611c <settimeofday+0x34>
42006119:	ffcbb2        	addi	a11, a11, -1
4200611c:	c0a2a0        	sub	a10, a2, a10
4200611f:	e99781        	l32r	a8, 4200077c <_stext+0x75c> (4037fe60 <esp_time_impl_set_boot_time>)
42006122:	0008e0        	callx8	a8
    return 0;
#else
    errno = ENOSYS;
    return -1;
#endif
}
42006125:	020c      	movi.n	a2, 0
42006127:	f01d      	retw.n
42006129:	000000        	ill

4200612c <esp_libc_time_init>:
}

/* TODO IDF-11226 */
void esp_newlib_time_init(void) __attribute__((alias("esp_libc_time_init")));
void esp_libc_time_init(void)
{
4200612c:	004136        	entry	a1, 32
    esp_set_time_from_rtc();
4200612f:	e99981        	l32r	a8, 42000794 <_stext+0x774> (4037fe18 <esp_set_time_from_rtc>)
42006132:	0008e0        	callx8	a8
}
42006135:	f01d      	retw.n
	...

42006138 <_raise_r>:
    __errno_r(r) = ENOSYS;
    return -1;
}

static int syscall_not_implemented_aborts(void)
{
42006138:	004136        	entry	a1, 32
    abort();
4200613b:	e7e881        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200613e:	0008e0        	callx8	a8
42006141:	000000        	ill

42006144 <_write_r_console>:
}

ssize_t _write_r_console(struct _reent *r, int fd, const void * data, size_t size)
{
42006144:	004136        	entry	a1, 32
#if !CONFIG_ESP_CONSOLE_NONE
    const char* cdata = (const char*) data;
    if (fd == STDOUT_FILENO || fd == STDERR_FILENO) {
42006147:	330b      	addi.n	a3, a3, -1
42006149:	1d23b6        	bltui	a3, 2, 4200616a <_write_r_console+0x26>
4200614c:	000906        	j	42006174 <_write_r_console+0x30>
4200614f:	647a00        	extui	a7, a0, 10, 7
        for (size_t i = 0; i < size; ++i) {
            if (cdata[i] == '\n') {
42006152:	000682        	l8ui	a8, a6, 0
42006155:	049866        	bnei	a8, 10, 4200615d <_write_r_console+0x19>
                esp_system_console_put_char('\r');
42006158:	da0c      	movi.n	a10, 13
4200615a:	0518e5        	call8	4200b2e8 <esp_system_console_put_char>
            }
            esp_system_console_put_char(cdata[i]);
4200615d:	0006a2        	l8ui	a10, a6, 0
42006160:	051865        	call8	4200b2e8 <esp_system_console_put_char>
        for (size_t i = 0; i < size; ++i) {
42006163:	771b      	addi.n	a7, a7, 1
42006165:	0000c6        	j	4200616c <_write_r_console+0x28>
42006168:	00          	.byte	00
42006169:	070c00        	ee.stf.64.xp	f0, f0, a0, a12
4200616c:	e03757        	bltu	a7, a5, 42006150 <_write_r_console+0xc>
        }
        return size;
4200616f:	052d      	mov.n	a2, a5
42006171:	000146        	j	4200617a <_write_r_console+0x36>
    }
#endif //!CONFIG_ESP_CONSOLE_NONE
    __errno_r(r) = EBADF;
42006174:	980c      	movi.n	a8, 9
42006176:	0289      	s32i.n	a8, a2, 0
    return -1;
42006178:	f27c      	movi.n	a2, -1
}
4200617a:	f01d      	retw.n

4200617c <_read_r_console>:

ssize_t _read_r_console(struct _reent *r, int fd, void * data, size_t size)
{
4200617c:	004136        	entry	a1, 32
4200617f:	026d      	mov.n	a6, a2
#if !CONFIG_ESP_CONSOLE_NONE
    char* cdata = (char*) data;
    if (fd == STDIN_FILENO) {
42006181:	03ac      	beqz.n	a3, 420061a5 <_read_r_console+0x29>
42006183:	000bc6        	j	420061b6 <_read_r_console+0x3a>
        size_t received;
        for (received = 0; received < size; ++received) {
            int status = esp_rom_output_rx_one_char((uint8_t*) &cdata[received]);
42006186:	742a      	add.n	a7, a4, a2
42006188:	20a770        	or	a10, a7, a7
4200618b:	e98381        	l32r	a8, 42000798 <_stext+0x778> (40000660 <esp_rom_output_rx_one_char>)
4200618e:	0008e0        	callx8	a8
            if (status != 0) {
42006191:	5adc      	bnez.n	a10, 420061aa <_read_r_console+0x2e>
                break;
            }
            if (cdata[received] == '\r') {
42006193:	000792        	l8ui	a9, a7, 0
42006196:	d80c      	movi.n	a8, 13
42006198:	049987        	bne	a9, a8, 420061a0 <_read_r_console+0x24>
                cdata[received] = '\n';
4200619b:	a80c      	movi.n	a8, 10
4200619d:	004782        	s8i	a8, a7, 0
        for (received = 0; received < size; ++received) {
420061a0:	221b      	addi.n	a2, a2, 1
420061a2:	000046        	j	420061a7 <_read_r_console+0x2b>
420061a5:	020c      	movi.n	a2, 0
420061a7:	db3257        	bltu	a2, a5, 42006186 <_read_r_console+0xa>
            }
        }
        if (received == 0) {
420061aa:	e2cc      	bnez.n	a2, 420061bc <_read_r_console+0x40>
            __errno_r(r) = EWOULDBLOCK;
420061ac:	b80c      	movi.n	a8, 11
420061ae:	0689      	s32i.n	a8, a6, 0
            return -1;
420061b0:	f27c      	movi.n	a2, -1
420061b2:	000186        	j	420061bc <_read_r_console+0x40>
420061b5:	00          	.byte	00
        }
        return received;
    }
#endif //!CONFIG_ESP_CONSOLE_NONE
    __errno_r(r) = EBADF;
420061b6:	980c      	movi.n	a8, 9
420061b8:	0289      	s32i.n	a8, a2, 0
    return -1;
420061ba:	f27c      	movi.n	a2, -1
}
420061bc:	f01d      	retw.n
	...

420061c0 <_fstat_r>:

static ssize_t _fstat_r_console(struct _reent *r, int fd, struct stat * st)
{
420061c0:	004136        	entry	a1, 32
    if (fd == STDOUT_FILENO || fd == STDERR_FILENO) {
420061c3:	330b      	addi.n	a3, a3, -1
420061c5:	1523f6        	bgeui	a3, 2, 420061de <_fstat_r+0x1e>
        memset(st, 0, sizeof(*st));
420061c8:	8c5c      	movi.n	a12, 88
420061ca:	0b0c      	movi.n	a11, 0
420061cc:	04ad      	mov.n	a10, a4
420061ce:	e84d81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420061d1:	0008e0        	callx8	a8
        /* This needs to be set so that stdout and stderr are line buffered. */
        st->st_mode = S_IFCHR;
420061d4:	e97281        	l32r	a8, 4200079c <_stext+0x77c> (2000 <UserFrameTotalSize+0x1f00>)
420061d7:	1489      	s32i.n	a8, a4, 4
        return 0;
420061d9:	020c      	movi.n	a2, 0
420061db:	000146        	j	420061e4 <_fstat_r+0x24>
    }
    __errno_r(r) = EBADF;
420061de:	980c      	movi.n	a8, 9
420061e0:	0289      	s32i.n	a8, a2, 0
    return -1;
420061e2:	f27c      	movi.n	a2, -1
}
420061e4:	f01d      	retw.n
	...

420061e8 <esp_reent_init>:
 * is a bit too much on a small embedded system. So we point streams
 * to the streams of the global struct _reent, which are initialized in
 * startup code.
 */
void esp_reent_init(struct _reent* r)
{
420061e8:	004136        	entry	a1, 32
    memset(r, 0, sizeof(*r));
420061eb:	f0a0c2        	movi	a12, 240
420061ee:	0b0c      	movi.n	a11, 0
420061f0:	02ad      	mov.n	a10, a2
420061f2:	e84481        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420061f5:	0008e0        	callx8	a8
    _REENT_STDIN(r) = _REENT_STDIN(_GLOBAL_REENT);
420061f8:	e96a81        	l32r	a8, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
420061fb:	1898      	l32i.n	a9, a8, 4
420061fd:	1299      	s32i.n	a9, a2, 4
    _REENT_STDOUT(r) = _REENT_STDOUT(_GLOBAL_REENT);
420061ff:	2898      	l32i.n	a9, a8, 8
42006201:	2299      	s32i.n	a9, a2, 8
    _REENT_STDERR(r) = _REENT_STDERR(_GLOBAL_REENT);
42006203:	3898      	l32i.n	a9, a8, 12
42006205:	3299      	s32i.n	a9, a2, 12
    _REENT_CLEANUP(r) = _REENT_CLEANUP(_GLOBAL_REENT);
42006207:	a898      	l32i.n	a9, a8, 40
42006209:	a299      	s32i.n	a9, a2, 40
    _REENT_SDIDINIT(r) = _REENT_SDIDINIT(_GLOBAL_REENT);
4200620b:	6888      	l32i.n	a8, a8, 24
4200620d:	6289      	s32i.n	a8, a2, 24
}
4200620f:	f01d      	retw.n
42006211:	000000        	ill

42006214 <esp_cleanup_r>:
{
    _raise_r(rptr, 0);
}

static void esp_cleanup_r(struct _reent *rptr)
{
42006214:	004136        	entry	a1, 32
    if (_REENT_STDIN(rptr) != _REENT_STDIN(_GLOBAL_REENT)) {
42006217:	12b8      	l32i.n	a11, a2, 4
42006219:	e96181        	l32r	a8, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
4200621c:	1888      	l32i.n	a8, a8, 4
4200621e:	041b87        	beq	a11, a8, 42006226 <esp_cleanup_r+0x12>
        _fclose_r(rptr, _REENT_STDIN(rptr));
42006221:	02ad      	mov.n	a10, a2
42006223:	067c25        	call8	4200c9e4 <_fclose_r>
    }

    if (_REENT_STDOUT(rptr) != _REENT_STDOUT(_GLOBAL_REENT)) {
42006226:	0222b2        	l32i	a11, a2, 8
42006229:	e95d81        	l32r	a8, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
4200622c:	022882        	l32i	a8, a8, 8
4200622f:	051b87        	beq	a11, a8, 42006238 <esp_cleanup_r+0x24>
        _fclose_r(rptr, _REENT_STDOUT(rptr));
42006232:	20a220        	or	a10, a2, a2
42006235:	067ae5        	call8	4200c9e4 <_fclose_r>
    }

    if (_REENT_STDERR(rptr) != _REENT_STDERR(_GLOBAL_REENT)) {
42006238:	0322b2        	l32i	a11, a2, 12
4200623b:	e95981        	l32r	a8, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
4200623e:	032882        	l32i	a8, a8, 12
42006241:	051b87        	beq	a11, a8, 4200624a <esp_cleanup_r+0x36>
        _fclose_r(rptr, _REENT_STDERR(rptr));
42006244:	20a220        	or	a10, a2, a2
42006247:	0679e5        	call8	4200c9e4 <_fclose_r>
    }
}
4200624a:	f01d      	retw.n

4200624c <raise_r_stub>:
{
4200624c:	004136        	entry	a1, 32
4200624f:	20a220        	or	a10, a2, a2
    _raise_r(rptr, 0);
42006252:	00a0b2        	movi	a11, 0
42006255:	ffee25        	call8	42006138 <_raise_r>
}
42006258:	000090        	retw
	...

4200625c <esp_libc_init>:
};

/* TODO IDF-11226 */
void esp_newlib_init(void) __attribute__((alias("esp_libc_init")));
void esp_libc_init(void)
{
4200625c:	004136        	entry	a1, 32
#if CONFIG_IDF_TARGET_ESP32
    syscall_table_ptr_pro = syscall_table_ptr_app = &s_stub_table;
#elif CONFIG_IDF_TARGET_ESP32S2
    syscall_table_ptr_pro = &s_stub_table;
#else
    syscall_table_ptr = &s_stub_table;
4200625f:	e95181        	l32r	a8, 420007a4 <_stext+0x784> (3fceffd4 <syscall_table_ptr>)
42006262:	e95191        	l32r	a9, 420007a8 <_stext+0x788> (3fc92510 <s_stub_table>)
42006265:	0899      	s32i.n	a9, a8, 0
#endif

    memset(&__sglue, 0, sizeof(__sglue));
42006267:	cc0c      	movi.n	a12, 12
42006269:	0b0c      	movi.n	a11, 0
4200626b:	e950a1        	l32r	a10, 420007ac <_stext+0x78c> (3fc92aa4 <__sglue>)
4200626e:	e82581        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
42006271:	0008e0        	callx8	a8
    _global_impure_ptr = _GLOBAL_REENT;
42006274:	e94b81        	l32r	a8, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
42006277:	e94e91        	l32r	a9, 420007b0 <_stext+0x790> (3fceffd0 <_global_impure_ptr>)
4200627a:	0989      	s32i.n	a8, a9, 0

    /* Ensure that the initialization of sfp is prevented until esp_newlib_init_global_stdio() is explicitly invoked. */
    _GLOBAL_REENT->__cleanup = esp_cleanup_r;
4200627c:	e94e91        	l32r	a9, 420007b4 <_stext+0x794> (42006214 <esp_cleanup_r>)
4200627f:	a899      	s32i.n	a9, a8, 40
    _REENT_SDIDINIT(_GLOBAL_REENT) = 1;
42006281:	190c      	movi.n	a9, 1
42006283:	6899      	s32i.n	a9, a8, 24

    environ = malloc(sizeof(char*));
42006285:	4a0c      	movi.n	a10, 4
42006287:	e94d81        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
4200628a:	0008e0        	callx8	a8
4200628d:	e94a81        	l32r	a8, 420007b8 <_stext+0x798> (3fc92aa0 <environ>)
42006290:	08a9      	s32i.n	a10, a8, 0
    if (environ == 0) {
42006292:	4acc      	bnez.n	a10, 4200629a <esp_libc_init+0x3e>
        // if allocation fails this early in startup process, there's nothing else other than to panic.
        abort();
42006294:	e79281        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42006297:	0008e0        	callx8	a8
    }
    environ[0] = NULL;
4200629a:	00a082        	movi	a8, 0
4200629d:	006a82        	s32i	a8, a10, 0

    esp_libc_locks_init();
420062a0:	ffc1a5        	call8	42005ebc <esp_libc_locks_init>
}
420062a3:	000090        	retw
	...

420062a8 <esp_libc_init_global_stdio>:
    __swsetup_r(_GLOBAL_REENT, _REENT_STDERR(_GLOBAL_REENT));
#endif /* ESP_ROM_NEEDS_SWSETUP_WORKAROUND */
}
#else /* CONFIG_VFS_SUPPORT_IO */
void esp_libc_init_global_stdio(void)
{
420062a8:	004136        	entry	a1, 32
    _GLOBAL_REENT->__cleanup = NULL;
420062ab:	e93d71        	l32r	a7, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
420062ae:	00a082        	movi	a8, 0
420062b1:	0a6782        	s32i	a8, a7, 40
    _REENT_SDIDINIT(_GLOBAL_REENT) = 0;
420062b4:	066782        	s32i	a8, a7, 24
    __sinit(_GLOBAL_REENT);
420062b7:	07ad      	mov.n	a10, a7
420062b9:	06ba25        	call8	4200ce5c <__sinit>
    _GLOBAL_REENT->__cleanup = esp_cleanup_r;
420062bc:	e93e81        	l32r	a8, 420007b4 <_stext+0x794> (42006214 <esp_cleanup_r>)
420062bf:	a789      	s32i.n	a8, a7, 40
    _REENT_SDIDINIT(_GLOBAL_REENT) = 1;
420062c1:	180c      	movi.n	a8, 1
420062c3:	6789      	s32i.n	a8, a7, 24
}
420062c5:	f01d      	retw.n
	...

420062c8 <__esp_system_init_fn_usb_serial_jtag_conn_status_init>:

ESP_SYSTEM_INIT_FN(usb_serial_jtag_conn_status_init, SECONDARY, BIT(0), 230)
{
420062c8:	004136        	entry	a1, 32
    // We always assume it is connected at first, so acquires the lock to avoid auto light sleep
    esp_pm_lock_acquire(s_usb_serial_jtag_pm_lock);
#endif
#if USB_SERIAL_JTAG_LL_PHY_DEPENDS_ON_BBPLL
// TODO: esp32p4 USJ rely on SPLL, if it will also be disabled during sleep, we need to call spll_add_consumer? IDF-9947
    rtc_clk_bbpll_add_consumer();
420062cb:	e94081        	l32r	a8, 420007cc <_stext+0x7ac> (40378524 <rtc_clk_bbpll_add_consumer>)
420062ce:	0008e0        	callx8	a8
#endif
    s_usb_serial_jtag_conn_status = true;
420062d1:	e93b81        	l32r	a8, 420007c0 <_stext+0x7a0> (3fc95364 <s_usb_serial_jtag_conn_status>)
420062d4:	01a092        	movi	a9, 1
420062d7:	0020c0        	memw
420062da:	004892        	s8i	a9, a8, 0
    remaining_allowed_no_sof_ticks = ALLOWED_NO_SOF_TICKS;
420062dd:	e93981        	l32r	a8, 420007c4 <_stext+0x7a4> (3fc95360 <remaining_allowed_no_sof_ticks>)
420062e0:	00a092        	movi	a9, 0
420062e3:	006892        	s32i	a9, a8, 0

    return esp_register_freertos_tick_hook(usb_serial_jtag_sof_tick_hook);
420062e6:	e938a1        	l32r	a10, 420007c8 <_stext+0x7a8> (40376b9c <usb_serial_jtag_sof_tick_hook>)
420062e9:	fc7f65        	call8	42002ae0 <esp_register_freertos_tick_hook>
}
420062ec:	0a2d      	mov.n	a2, a10
420062ee:	f01d      	retw.n

420062f0 <app_main>:
#include "vector_basic_test.h"
#include "esp_task_wdt.h"   
#include "esp_log.h" 

void app_main(void)
{
420062f0:	004136        	entry	a1, 32
    esp_task_wdt_deinit();
420062f3:	057525        	call8	4200ba44 <esp_task_wdt_deinit>

    // vec_add 
    ESP_LOGI("vector_test_add:", "DTYPE_INT8");
420062f6:	370c      	movi.n	a7, 3
420062f8:	e75a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420062fb:	0008e0        	callx8	a8
420062fe:	e93421        	l32r	a2, 420007d0 <_stext+0x7b0> (3c023d68 <_flash_rodata_start+0x3c48>)
42006301:	e93441        	l32r	a4, 420007d4 <_stext+0x7b4> (3c023d7c <_flash_rodata_start+0x3c5c>)
42006304:	02ed      	mov.n	a14, a2
42006306:	0add      	mov.n	a13, a10
42006308:	04cd      	mov.n	a12, a4
4200630a:	02bd      	mov.n	a11, a2
4200630c:	07ad      	mov.n	a10, a7
4200630e:	e76181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006311:	0008e0        	callx8	a8
    vector_test_add(true, DTYPE_INT8);
42006314:	0b0c      	movi.n	a11, 0
42006316:	1a0c      	movi.n	a10, 1
42006318:	00db25        	call8	420070cc <vector_test_add>
    ESP_LOGI("vector_test_add:", "DTYPE_INT16");
4200631b:	e75181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200631e:	0008e0        	callx8	a8
42006321:	e92d51        	l32r	a5, 420007d8 <_stext+0x7b8> (3c023d94 <_flash_rodata_start+0x3c74>)
42006324:	02ed      	mov.n	a14, a2
42006326:	0add      	mov.n	a13, a10
42006328:	05cd      	mov.n	a12, a5
4200632a:	02bd      	mov.n	a11, a2
4200632c:	07ad      	mov.n	a10, a7
4200632e:	e75981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006331:	0008e0        	callx8	a8
    vector_test_add(true, DTYPE_INT16);
42006334:	1b0c      	movi.n	a11, 1
42006336:	0bad      	mov.n	a10, a11
42006338:	00d925        	call8	420070cc <vector_test_add>
    ESP_LOGI("vector_test_add:", "DTYPE_INT32");
4200633b:	e74981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200633e:	0008e0        	callx8	a8
42006341:	e92661        	l32r	a6, 420007dc <_stext+0x7bc> (3c023db0 <_flash_rodata_start+0x3c90>)
42006344:	02ed      	mov.n	a14, a2
42006346:	0add      	mov.n	a13, a10
42006348:	06cd      	mov.n	a12, a6
4200634a:	02bd      	mov.n	a11, a2
4200634c:	07ad      	mov.n	a10, a7
4200634e:	e75181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006351:	0008e0        	callx8	a8
    vector_test_add(true, DTYPE_INT32);
42006354:	2b0c      	movi.n	a11, 2
42006356:	1a0c      	movi.n	a10, 1
42006358:	00d725        	call8	420070cc <vector_test_add>
    ESP_LOGI("vector_test_add_alias:", "DTYPE_INT32");
4200635b:	e74181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200635e:	0008e0        	callx8	a8
42006361:	e91fe1        	l32r	a14, 420007e0 <_stext+0x7c0> (3c023dcc <_flash_rodata_start+0x3cac>)
42006364:	0add      	mov.n	a13, a10
42006366:	06cd      	mov.n	a12, a6
42006368:	0ebd      	mov.n	a11, a14
4200636a:	07ad      	mov.n	a10, a7
4200636c:	e74a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200636f:	0008e0        	callx8	a8
    vector_test_add_alias(true, DTYPE_FLOAT32);
42006372:	07bd      	mov.n	a11, a7
42006374:	1a0c      	movi.n	a10, 1
42006376:	00f2e5        	call8	420072a4 <vector_test_add_alias>
    ESP_LOGI("vector_test_add:", "DTYPE_FLOAT32");
42006379:	e73981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200637c:	0008e0        	callx8	a8
4200637f:	e91931        	l32r	a3, 420007e4 <_stext+0x7c4> (3c023de4 <_flash_rodata_start+0x3cc4>)
42006382:	02ed      	mov.n	a14, a2
42006384:	0add      	mov.n	a13, a10
42006386:	03cd      	mov.n	a12, a3
42006388:	02bd      	mov.n	a11, a2
4200638a:	07ad      	mov.n	a10, a7
4200638c:	e74281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200638f:	0008e0        	callx8	a8
    vector_test_add(true, DTYPE_FLOAT32);
42006392:	07bd      	mov.n	a11, a7
42006394:	1a0c      	movi.n	a10, 1
42006396:	00d365        	call8	420070cc <vector_test_add>
    ESP_LOGI("vector_test_add_alias:", "DTYPE_FLOAT32");
42006399:	e73181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200639c:	0008e0        	callx8	a8
4200639f:	e910e1        	l32r	a14, 420007e0 <_stext+0x7c0> (3c023dcc <_flash_rodata_start+0x3cac>)
420063a2:	0add      	mov.n	a13, a10
420063a4:	03cd      	mov.n	a12, a3
420063a6:	0ebd      	mov.n	a11, a14
420063a8:	07ad      	mov.n	a10, a7
420063aa:	e73a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420063ad:	0008e0        	callx8	a8
    vector_test_add_alias(true, DTYPE_FLOAT32);
420063b0:	07bd      	mov.n	a11, a7
420063b2:	1a0c      	movi.n	a10, 1
420063b4:	00eee5        	call8	420072a4 <vector_test_add_alias>

    // vec_sub 
    ESP_LOGI("vector_test_sub:", "DTYPE_INT8");
420063b7:	e72a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420063ba:	0008e0        	callx8	a8
420063bd:	e90a21        	l32r	a2, 420007e8 <_stext+0x7c8> (3c023e00 <_flash_rodata_start+0x3ce0>)
420063c0:	02ed      	mov.n	a14, a2
420063c2:	0add      	mov.n	a13, a10
420063c4:	04cd      	mov.n	a12, a4
420063c6:	02bd      	mov.n	a11, a2
420063c8:	07ad      	mov.n	a10, a7
420063ca:	e73281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420063cd:	0008e0        	callx8	a8
    vector_test_sub(true, DTYPE_INT8);
420063d0:	0b0c      	movi.n	a11, 0
420063d2:	1a0c      	movi.n	a10, 1
420063d4:	0107e5        	call8	42007454 <vector_test_sub>
    ESP_LOGI("vector_test_sub_alias:", "DTYPE_INT8");
420063d7:	e72281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420063da:	0008e0        	callx8	a8
420063dd:	e903e1        	l32r	a14, 420007ec <_stext+0x7cc> (3c023e14 <_flash_rodata_start+0x3cf4>)
420063e0:	0add      	mov.n	a13, a10
420063e2:	04cd      	mov.n	a12, a4
420063e4:	0ebd      	mov.n	a11, a14
420063e6:	07ad      	mov.n	a10, a7
420063e8:	e72b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420063eb:	0008e0        	callx8	a8
    vector_test_sub_alias(true, DTYPE_INT8);
420063ee:	0b0c      	movi.n	a11, 0
420063f0:	1a0c      	movi.n	a10, 1
420063f2:	012425        	call8	42007634 <vector_test_sub_alias>
    ESP_LOGI("vector_test_sub:", "DTYPE_INT16");
420063f5:	e71a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420063f8:	0008e0        	callx8	a8
420063fb:	02ed      	mov.n	a14, a2
420063fd:	0add      	mov.n	a13, a10
420063ff:	05cd      	mov.n	a12, a5
42006401:	02bd      	mov.n	a11, a2
42006403:	07ad      	mov.n	a10, a7
42006405:	e72381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006408:	0008e0        	callx8	a8
    vector_test_sub(true, DTYPE_INT16);
4200640b:	1b0c      	movi.n	a11, 1
4200640d:	0bad      	mov.n	a10, a11
4200640f:	010465        	call8	42007454 <vector_test_sub>
    ESP_LOGI("vector_test_sub_alias:", "DTYPE_INT16");
42006412:	e71381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006415:	0008e0        	callx8	a8
42006418:	e8f5e1        	l32r	a14, 420007ec <_stext+0x7cc> (3c023e14 <_flash_rodata_start+0x3cf4>)
4200641b:	0add      	mov.n	a13, a10
4200641d:	05cd      	mov.n	a12, a5
4200641f:	0ebd      	mov.n	a11, a14
42006421:	07ad      	mov.n	a10, a7
42006423:	e71c81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006426:	0008e0        	callx8	a8
    vector_test_sub_alias(true, DTYPE_INT16);
42006429:	1b0c      	movi.n	a11, 1
4200642b:	0bad      	mov.n	a10, a11
4200642d:	012065        	call8	42007634 <vector_test_sub_alias>
    ESP_LOGI("vector_test_sub:", "DTYPE_INT32");
42006430:	e70c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006433:	0008e0        	callx8	a8
42006436:	02ed      	mov.n	a14, a2
42006438:	0add      	mov.n	a13, a10
4200643a:	06cd      	mov.n	a12, a6
4200643c:	02bd      	mov.n	a11, a2
4200643e:	07ad      	mov.n	a10, a7
42006440:	e71581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006443:	0008e0        	callx8	a8
    vector_test_sub(true, DTYPE_INT32);
42006446:	2b0c      	movi.n	a11, 2
42006448:	1a0c      	movi.n	a10, 1
4200644a:	0100a5        	call8	42007454 <vector_test_sub>
    ESP_LOGI("vector_test_sub_alias:", "DTYPE_INT32");
4200644d:	e70481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006450:	0008e0        	callx8	a8
42006453:	e8e6e1        	l32r	a14, 420007ec <_stext+0x7cc> (3c023e14 <_flash_rodata_start+0x3cf4>)
42006456:	0add      	mov.n	a13, a10
42006458:	06cd      	mov.n	a12, a6
4200645a:	0ebd      	mov.n	a11, a14
4200645c:	07ad      	mov.n	a10, a7
4200645e:	e70d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006461:	0008e0        	callx8	a8
    vector_test_sub_alias(true, DTYPE_INT32);
42006464:	2b0c      	movi.n	a11, 2
42006466:	1a0c      	movi.n	a10, 1
42006468:	011ca5        	call8	42007634 <vector_test_sub_alias>
    ESP_LOGI("vector_test_sub:", "DTYPE_FLOAT32");
4200646b:	e6fd81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200646e:	0008e0        	callx8	a8
42006471:	02ed      	mov.n	a14, a2
42006473:	0add      	mov.n	a13, a10
42006475:	03cd      	mov.n	a12, a3
42006477:	02bd      	mov.n	a11, a2
42006479:	07ad      	mov.n	a10, a7
4200647b:	e70681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200647e:	0008e0        	callx8	a8
    vector_test_sub(true, DTYPE_FLOAT32);
42006481:	07bd      	mov.n	a11, a7
42006483:	1a0c      	movi.n	a10, 1
42006485:	00fce5        	call8	42007454 <vector_test_sub>
    ESP_LOGI("vector_test_sub_alias:", "DTYPE_FLOAT32");
42006488:	e6f681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200648b:	0008e0        	callx8	a8
4200648e:	e8d7e1        	l32r	a14, 420007ec <_stext+0x7cc> (3c023e14 <_flash_rodata_start+0x3cf4>)
42006491:	0add      	mov.n	a13, a10
42006493:	03cd      	mov.n	a12, a3
42006495:	0ebd      	mov.n	a11, a14
42006497:	07ad      	mov.n	a10, a7
42006499:	e6fe81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200649c:	0008e0        	callx8	a8
    vector_test_sub_alias(true, DTYPE_FLOAT32);
4200649f:	07bd      	mov.n	a11, a7
420064a1:	1a0c      	movi.n	a10, 1
420064a3:	011925        	call8	42007634 <vector_test_sub_alias>

    // vec_add_scalar 
    ESP_LOGI("vec_add_scalar:", "DTYPE_INT8");
420064a6:	e6ee81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420064a9:	0008e0        	callx8	a8
420064ac:	e8d121        	l32r	a2, 420007f0 <_stext+0x7d0> (3c023e2c <_flash_rodata_start+0x3d0c>)
420064af:	02ed      	mov.n	a14, a2
420064b1:	0add      	mov.n	a13, a10
420064b3:	04cd      	mov.n	a12, a4
420064b5:	02bd      	mov.n	a11, a2
420064b7:	07ad      	mov.n	a10, a7
420064b9:	e6f681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420064bc:	0008e0        	callx8	a8
    vector_test_add_scalar(true, DTYPE_INT8);
420064bf:	0b0c      	movi.n	a11, 0
420064c1:	1a0c      	movi.n	a10, 1
420064c3:	013225        	call8	420077e4 <vector_test_add_scalar>
    ESP_LOGI("vec_add_scalar_alias:", "DTYPE_INT8");
420064c6:	e6e681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420064c9:	0008e0        	callx8	a8
420064cc:	e8cae1        	l32r	a14, 420007f4 <_stext+0x7d4> (3c023e3c <_flash_rodata_start+0x3d1c>)
420064cf:	0add      	mov.n	a13, a10
420064d1:	04cd      	mov.n	a12, a4
420064d3:	0ebd      	mov.n	a11, a14
420064d5:	07ad      	mov.n	a10, a7
420064d7:	e6ef81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420064da:	0008e0        	callx8	a8
    vector_test_add_scalar_alias(true, DTYPE_INT8);
420064dd:	0b0c      	movi.n	a11, 0
420064df:	1a0c      	movi.n	a10, 1
420064e1:	016765        	call8	42007b58 <vector_test_add_scalar_alias>
    ESP_LOGI("vec_add_scalar:", "DTYPE_INT16");
420064e4:	e6df81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420064e7:	0008e0        	callx8	a8
420064ea:	02ed      	mov.n	a14, a2
420064ec:	0add      	mov.n	a13, a10
420064ee:	05cd      	mov.n	a12, a5
420064f0:	02bd      	mov.n	a11, a2
420064f2:	07ad      	mov.n	a10, a7
420064f4:	e6e881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420064f7:	0008e0        	callx8	a8
    vector_test_add_scalar(true, DTYPE_INT16);
420064fa:	1b0c      	movi.n	a11, 1
420064fc:	0bad      	mov.n	a10, a11
420064fe:	012e65        	call8	420077e4 <vector_test_add_scalar>
    ESP_LOGI("vec_add_scalar_alias:", "DTYPE_INT16");
42006501:	e6d781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006504:	0008e0        	callx8	a8
42006507:	e8bbe1        	l32r	a14, 420007f4 <_stext+0x7d4> (3c023e3c <_flash_rodata_start+0x3d1c>)
4200650a:	0add      	mov.n	a13, a10
4200650c:	05cd      	mov.n	a12, a5
4200650e:	0ebd      	mov.n	a11, a14
42006510:	07ad      	mov.n	a10, a7
42006512:	e6e081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006515:	0008e0        	callx8	a8
    vector_test_add_scalar_alias(true, DTYPE_INT16);
42006518:	1b0c      	movi.n	a11, 1
4200651a:	0bad      	mov.n	a10, a11
4200651c:	0163a5        	call8	42007b58 <vector_test_add_scalar_alias>
    ESP_LOGI("vec_add_scalar:", "DTYPE_INT32");
4200651f:	e6d081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006522:	0008e0        	callx8	a8
42006525:	02ed      	mov.n	a14, a2
42006527:	0add      	mov.n	a13, a10
42006529:	06cd      	mov.n	a12, a6
4200652b:	02bd      	mov.n	a11, a2
4200652d:	07ad      	mov.n	a10, a7
4200652f:	e6d981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006532:	0008e0        	callx8	a8
    vector_test_add_scalar(true, DTYPE_INT32);
42006535:	2b0c      	movi.n	a11, 2
42006537:	1a0c      	movi.n	a10, 1
42006539:	012aa5        	call8	420077e4 <vector_test_add_scalar>
    ESP_LOGI("vec_add_scalar_alias:", "DTYPE_INT32");
4200653c:	e6c981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200653f:	0008e0        	callx8	a8
42006542:	e8ace1        	l32r	a14, 420007f4 <_stext+0x7d4> (3c023e3c <_flash_rodata_start+0x3d1c>)
42006545:	0add      	mov.n	a13, a10
42006547:	06cd      	mov.n	a12, a6
42006549:	0ebd      	mov.n	a11, a14
4200654b:	07ad      	mov.n	a10, a7
4200654d:	e6d181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006550:	0008e0        	callx8	a8
    vector_test_add_scalar_alias(true, DTYPE_INT32); 
42006553:	2b0c      	movi.n	a11, 2
42006555:	1a0c      	movi.n	a10, 1
42006557:	016025        	call8	42007b58 <vector_test_add_scalar_alias>
    ESP_LOGI("vec_add_scalar:", "DTYPE_FLOAT32");
4200655a:	e6c181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200655d:	0008e0        	callx8	a8
42006560:	02ed      	mov.n	a14, a2
42006562:	0add      	mov.n	a13, a10
42006564:	03cd      	mov.n	a12, a3
42006566:	02bd      	mov.n	a11, a2
42006568:	07ad      	mov.n	a10, a7
4200656a:	e6ca81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200656d:	0008e0        	callx8	a8
    vector_test_add_scalar_f32(true, DTYPE_FLOAT32);
42006570:	07bd      	mov.n	a11, a7
42006572:	1a0c      	movi.n	a10, 1
42006574:	0143e5        	call8	420079b4 <vector_test_add_scalar_f32>
    ESP_LOGI("vec_add_scalar_alias:", "DTYPE_FLOAT32");
42006577:	e6ba81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200657a:	0008e0        	callx8	a8
4200657d:	e89de1        	l32r	a14, 420007f4 <_stext+0x7d4> (3c023e3c <_flash_rodata_start+0x3d1c>)
42006580:	0add      	mov.n	a13, a10
42006582:	03cd      	mov.n	a12, a3
42006584:	0ebd      	mov.n	a11, a14
42006586:	07ad      	mov.n	a10, a7
42006588:	e6c381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200658b:	0008e0        	callx8	a8
    vector_test_add_scalar_f32_alias(true, DTYPE_FLOAT32);
4200658e:	07bd      	mov.n	a11, a7
42006590:	1a0c      	movi.n	a10, 1
42006592:	0175a5        	call8	42007cec <vector_test_add_scalar_f32_alias>

    // vec_mul_shift
    ESP_LOGI("vec_mul_shift:", "DTYPE_INT8");
42006595:	e6b281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006598:	0008e0        	callx8	a8
4200659b:	e89721        	l32r	a2, 420007f8 <_stext+0x7d8> (3c023e54 <_flash_rodata_start+0x3d34>)
4200659e:	02ed      	mov.n	a14, a2
420065a0:	0add      	mov.n	a13, a10
420065a2:	04cd      	mov.n	a12, a4
420065a4:	02bd      	mov.n	a11, a2
420065a6:	07ad      	mov.n	a10, a7
420065a8:	e6bb81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420065ab:	0008e0        	callx8	a8
    vector_test_mul_shift(true, DTYPE_INT8);
420065ae:	0b0c      	movi.n	a11, 0
420065b0:	1a0c      	movi.n	a10, 1
420065b2:	0188e5        	call8	42007e40 <vector_test_mul_shift>
    ESP_LOGI("vec_mul_shift:", "DTYPE_INT16");
420065b5:	e6aa81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420065b8:	0008e0        	callx8	a8
420065bb:	02ed      	mov.n	a14, a2
420065bd:	0add      	mov.n	a13, a10
420065bf:	05cd      	mov.n	a12, a5
420065c1:	02bd      	mov.n	a11, a2
420065c3:	07ad      	mov.n	a10, a7
420065c5:	e6b381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420065c8:	0008e0        	callx8	a8
    vector_test_mul_shift(true, DTYPE_INT16);
420065cb:	1b0c      	movi.n	a11, 1
420065cd:	0bad      	mov.n	a10, a11
420065cf:	018725        	call8	42007e40 <vector_test_mul_shift>
    ESP_LOGI("vec_mul_shift:", "DTYPE_INT32");
420065d2:	e6a381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420065d5:	0008e0        	callx8	a8
420065d8:	02ed      	mov.n	a14, a2
420065da:	0add      	mov.n	a13, a10
420065dc:	06cd      	mov.n	a12, a6
420065de:	02bd      	mov.n	a11, a2
420065e0:	07ad      	mov.n	a10, a7
420065e2:	e6ac81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420065e5:	0008e0        	callx8	a8
    vector_test_mul_shift(true, DTYPE_INT32);
420065e8:	2b0c      	movi.n	a11, 2
420065ea:	1a0c      	movi.n	a10, 1
420065ec:	018525        	call8	42007e40 <vector_test_mul_shift>
    ESP_LOGI("vec_mul_shift:", "DTYPE_FLOAT32");
420065ef:	e69c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420065f2:	0008e0        	callx8	a8
420065f5:	02ed      	mov.n	a14, a2
420065f7:	0add      	mov.n	a13, a10
420065f9:	03cd      	mov.n	a12, a3
420065fb:	02bd      	mov.n	a11, a2
420065fd:	07ad      	mov.n	a10, a7
420065ff:	e6a581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006602:	0008e0        	callx8	a8
    vector_test_mul_shift(true, DTYPE_FLOAT32);
42006605:	07bd      	mov.n	a11, a7
42006607:	1a0c      	movi.n	a10, 1
42006609:	018365        	call8	42007e40 <vector_test_mul_shift>
    ESP_LOGI("vec_mul_shift_alias:", "DTYPE_INT8");
4200660c:	e69581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200660f:	0008e0        	callx8	a8
42006612:	e87a21        	l32r	a2, 420007fc <_stext+0x7dc> (3c023e64 <_flash_rodata_start+0x3d44>)
42006615:	02ed      	mov.n	a14, a2
42006617:	0add      	mov.n	a13, a10
42006619:	04cd      	mov.n	a12, a4
4200661b:	02bd      	mov.n	a11, a2
4200661d:	07ad      	mov.n	a10, a7
4200661f:	e69d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006622:	0008e0        	callx8	a8
    vector_test_mul_shift_alias(true, DTYPE_INT8);
42006625:	0b0c      	movi.n	a11, 0
42006627:	1a0c      	movi.n	a10, 1
42006629:	01a765        	call8	420080a0 <vector_test_mul_shift_alias>
    ESP_LOGI("vec_mul_shift_alias:", "DTYPE_INT16");
4200662c:	e68d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200662f:	0008e0        	callx8	a8
42006632:	02ed      	mov.n	a14, a2
42006634:	0add      	mov.n	a13, a10
42006636:	05cd      	mov.n	a12, a5
42006638:	02bd      	mov.n	a11, a2
4200663a:	07ad      	mov.n	a10, a7
4200663c:	e69681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200663f:	0008e0        	callx8	a8
    vector_test_mul_shift_alias(true, DTYPE_INT16);
42006642:	1b0c      	movi.n	a11, 1
42006644:	0bad      	mov.n	a10, a11
42006646:	01a5a5        	call8	420080a0 <vector_test_mul_shift_alias>
    ESP_LOGI("vec_mul_shift_alias:", "DTYPE_INT32");
42006649:	e68581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200664c:	0008e0        	callx8	a8
4200664f:	02ed      	mov.n	a14, a2
42006651:	0add      	mov.n	a13, a10
42006653:	06cd      	mov.n	a12, a6
42006655:	02bd      	mov.n	a11, a2
42006657:	07ad      	mov.n	a10, a7
42006659:	e68e81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200665c:	0008e0        	callx8	a8
    vector_test_mul_shift_alias(true, DTYPE_INT32);
4200665f:	2b0c      	movi.n	a11, 2
42006661:	1a0c      	movi.n	a10, 1
42006663:	01a3e5        	call8	420080a0 <vector_test_mul_shift_alias>
    ESP_LOGI("vec_mul_shift_alias:", "DTYPE_FLOAT32");
42006666:	e67e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006669:	0008e0        	callx8	a8
4200666c:	02ed      	mov.n	a14, a2
4200666e:	0add      	mov.n	a13, a10
42006670:	03cd      	mov.n	a12, a3
42006672:	02bd      	mov.n	a11, a2
42006674:	07ad      	mov.n	a10, a7
42006676:	e68781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006679:	0008e0        	callx8	a8
    vector_test_mul_shift_alias(true, DTYPE_FLOAT32);
4200667c:	07bd      	mov.n	a11, a7
4200667e:	1a0c      	movi.n	a10, 1
42006680:	01a1e5        	call8	420080a0 <vector_test_mul_shift_alias>
    
    // vec_sum
    
    ESP_LOGI("vec_sum:", "DTYPE_INT8");
42006683:	e67781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006686:	0008e0        	callx8	a8
42006689:	e85d21        	l32r	a2, 42000800 <_stext+0x7e0> (3c023e7c <_flash_rodata_start+0x3d5c>)
4200668c:	02ed      	mov.n	a14, a2
4200668e:	0add      	mov.n	a13, a10
42006690:	04cd      	mov.n	a12, a4
42006692:	02bd      	mov.n	a11, a2
42006694:	07ad      	mov.n	a10, a7
42006696:	e67f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006699:	0008e0        	callx8	a8
    vector_test_sum(true, DTYPE_INT8);
4200669c:	0b0c      	movi.n	a11, 0
4200669e:	1a0c      	movi.n	a10, 1
420066a0:	01bde5        	call8	42008280 <vector_test_sum>
    ESP_LOGI("vec_sum:", "DTYPE_INT16");
420066a3:	e66f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420066a6:	0008e0        	callx8	a8
420066a9:	02ed      	mov.n	a14, a2
420066ab:	0add      	mov.n	a13, a10
420066ad:	05cd      	mov.n	a12, a5
420066af:	02bd      	mov.n	a11, a2
420066b1:	07ad      	mov.n	a10, a7
420066b3:	e67881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420066b6:	0008e0        	callx8	a8
    vector_test_sum(true, DTYPE_INT16);
420066b9:	1b0c      	movi.n	a11, 1
420066bb:	0bad      	mov.n	a10, a11
420066bd:	01bc25        	call8	42008280 <vector_test_sum>
    //ESP_LOGI("vec_sum:", "DTYPE_INT32");  Overflow not working
    //vector_test_sum(true, DTYPE_INT32);
    ESP_LOGI("vec_sum:", "DTYPE_FLOAT32");
420066c0:	e66881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420066c3:	0008e0        	callx8	a8
420066c6:	02ed      	mov.n	a14, a2
420066c8:	0add      	mov.n	a13, a10
420066ca:	03cd      	mov.n	a12, a3
420066cc:	02bd      	mov.n	a11, a2
420066ce:	07ad      	mov.n	a10, a7
420066d0:	e67181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420066d3:	0008e0        	callx8	a8
    vector_test_sum_f32(true, DTYPE_FLOAT32);
420066d6:	07bd      	mov.n	a11, a7
420066d8:	1a0c      	movi.n	a10, 1
420066da:	01d565        	call8	42008430 <vector_test_sum_f32>
    
    
    // vec_mul_scalar_shift
    ESP_LOGI("vec_mul_scalar_shift:", "DTYPE_INT8");
420066dd:	e66081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420066e0:	0008e0        	callx8	a8
420066e3:	e84821        	l32r	a2, 42000804 <_stext+0x7e4> (3c023e88 <_flash_rodata_start+0x3d68>)
420066e6:	02ed      	mov.n	a14, a2
420066e8:	0add      	mov.n	a13, a10
420066ea:	04cd      	mov.n	a12, a4
420066ec:	02bd      	mov.n	a11, a2
420066ee:	07ad      	mov.n	a10, a7
420066f0:	e66981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420066f3:	0008e0        	callx8	a8
    vector_test_mul_scalar_shift(true, DTYPE_INT8);
420066f6:	0b0c      	movi.n	a11, 0
420066f8:	1a0c      	movi.n	a10, 1
420066fa:	01ed25        	call8	420085cc <vector_test_mul_scalar_shift>
    ESP_LOGI("vec_mul_scalar_shift:", "DTYPE_INT16");
420066fd:	e65881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006700:	0008e0        	callx8	a8
42006703:	02ed      	mov.n	a14, a2
42006705:	0add      	mov.n	a13, a10
42006707:	05cd      	mov.n	a12, a5
42006709:	02bd      	mov.n	a11, a2
4200670b:	07ad      	mov.n	a10, a7
4200670d:	e66181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006710:	0008e0        	callx8	a8
    vector_test_mul_scalar_shift(true, DTYPE_INT16);
42006713:	1b0c      	movi.n	a11, 1
42006715:	0bad      	mov.n	a10, a11
42006717:	01eb65        	call8	420085cc <vector_test_mul_scalar_shift>
    ESP_LOGI("vec_mul_scalar_shift:", "DTYPE_INT32");
4200671a:	e65181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200671d:	0008e0        	callx8	a8
42006720:	02ed      	mov.n	a14, a2
42006722:	0add      	mov.n	a13, a10
42006724:	06cd      	mov.n	a12, a6
42006726:	02bd      	mov.n	a11, a2
42006728:	07ad      	mov.n	a10, a7
4200672a:	e65a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200672d:	0008e0        	callx8	a8
    vector_test_mul_scalar_shift(true, DTYPE_INT32);
42006730:	2b0c      	movi.n	a11, 2
42006732:	1a0c      	movi.n	a10, 1
42006734:	01e965        	call8	420085cc <vector_test_mul_scalar_shift>
    ESP_LOGI("vec_mul_scalar_shift_f32:", "DTYPE_FLOAT32");
42006737:	e64a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200673a:	0008e0        	callx8	a8
4200673d:	e832b1        	l32r	a11, 42000808 <_stext+0x7e8> (3c023ea0 <_flash_rodata_start+0x3d80>)
42006740:	0bed      	mov.n	a14, a11
42006742:	0add      	mov.n	a13, a10
42006744:	03cd      	mov.n	a12, a3
42006746:	07ad      	mov.n	a10, a7
42006748:	e65381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200674b:	0008e0        	callx8	a8
    vector_test_mul_scalar_shift(true, DTYPE_FLOAT32);
4200674e:	07bd      	mov.n	a11, a7
42006750:	1a0c      	movi.n	a10, 1
42006752:	01e7a5        	call8	420085cc <vector_test_mul_scalar_shift>

    // vec_dotp 
    ESP_LOGI("vec_dotp:", "DTYPE_INT8"); 
42006755:	e64281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006758:	0008e0        	callx8	a8
4200675b:	e82c21        	l32r	a2, 4200080c <_stext+0x7ec> (3c023ebc <_flash_rodata_start+0x3d9c>)
4200675e:	02ed      	mov.n	a14, a2
42006760:	0add      	mov.n	a13, a10
42006762:	04cd      	mov.n	a12, a4
42006764:	02bd      	mov.n	a11, a2
42006766:	07ad      	mov.n	a10, a7
42006768:	e64b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200676b:	0008e0        	callx8	a8
    vector_test_dotp(true, DTYPE_INT8);
4200676e:	0b0c      	movi.n	a11, 0
42006770:	1a0c      	movi.n	a10, 1
42006772:	0206a5        	call8	420087dc <vector_test_dotp>
    ESP_LOGI("vec_dotp:", "DTYPE_INT16"); 
42006775:	e63a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006778:	0008e0        	callx8	a8
4200677b:	02ed      	mov.n	a14, a2
4200677d:	0add      	mov.n	a13, a10
4200677f:	05cd      	mov.n	a12, a5
42006781:	02bd      	mov.n	a11, a2
42006783:	07ad      	mov.n	a10, a7
42006785:	e64381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006788:	0008e0        	callx8	a8
    vector_test_dotp(true, DTYPE_INT16);
4200678b:	1b0c      	movi.n	a11, 1
4200678d:	0bad      	mov.n	a10, a11
4200678f:	0204e5        	call8	420087dc <vector_test_dotp>
    ESP_LOGI("vec_dotp:", "DTYPE_INT32"); 
42006792:	e63381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006795:	0008e0        	callx8	a8
42006798:	02ed      	mov.n	a14, a2
4200679a:	0add      	mov.n	a13, a10
4200679c:	06cd      	mov.n	a12, a6
4200679e:	02bd      	mov.n	a11, a2
420067a0:	07ad      	mov.n	a10, a7
420067a2:	e63c81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420067a5:	0008e0        	callx8	a8
    vector_test_dotp(true, DTYPE_INT32);
420067a8:	2b0c      	movi.n	a11, 2
420067aa:	1a0c      	movi.n	a10, 1
420067ac:	0202e5        	call8	420087dc <vector_test_dotp>
    ESP_LOGI("vec_dotp_f32:", "DTYPE_FLOAT32"); 
420067af:	e62c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420067b2:	0008e0        	callx8	a8
420067b5:	e816b1        	l32r	a11, 42000810 <_stext+0x7f0> (3c023ec8 <_flash_rodata_start+0x3da8>)
420067b8:	0bed      	mov.n	a14, a11
420067ba:	0add      	mov.n	a13, a10
420067bc:	03cd      	mov.n	a12, a3
420067be:	07ad      	mov.n	a10, a7
420067c0:	e63581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420067c3:	0008e0        	callx8	a8
    vector_test_dotp_f32(true, DTYPE_FLOAT32);
420067c6:	07bd      	mov.n	a11, a7
420067c8:	1a0c      	movi.n	a10, 1
420067ca:	021fa5        	call8	420089c4 <vector_test_dotp_f32>

    // vec_abs
    ESP_LOGI("vec_abs:", "DTYPE_INT8"); 
420067cd:	e62481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420067d0:	0008e0        	callx8	a8
420067d3:	e81021        	l32r	a2, 42000814 <_stext+0x7f4> (3c023ed8 <_flash_rodata_start+0x3db8>)
420067d6:	02ed      	mov.n	a14, a2
420067d8:	0add      	mov.n	a13, a10
420067da:	04cd      	mov.n	a12, a4
420067dc:	02bd      	mov.n	a11, a2
420067de:	07ad      	mov.n	a10, a7
420067e0:	e62d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420067e3:	0008e0        	callx8	a8
    vector_test_abs(true, DTYPE_INT8);
420067e6:	0b0c      	movi.n	a11, 0
420067e8:	1a0c      	movi.n	a10, 1
420067ea:	023c25        	call8	42008bac <vector_test_abs>
    ESP_LOGI("vec_abs:", "DTYPE_INT16"); 
420067ed:	e61c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420067f0:	0008e0        	callx8	a8
420067f3:	02ed      	mov.n	a14, a2
420067f5:	0add      	mov.n	a13, a10
420067f7:	05cd      	mov.n	a12, a5
420067f9:	02bd      	mov.n	a11, a2
420067fb:	07ad      	mov.n	a10, a7
420067fd:	e62581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006800:	0008e0        	callx8	a8
    vector_test_abs(true, DTYPE_INT16);
42006803:	1b0c      	movi.n	a11, 1
42006805:	0bad      	mov.n	a10, a11
42006807:	023a65        	call8	42008bac <vector_test_abs>
    ESP_LOGI("vec_abs:", "DTYPE_INT32"); 
4200680a:	e61581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200680d:	0008e0        	callx8	a8
42006810:	02ed      	mov.n	a14, a2
42006812:	0add      	mov.n	a13, a10
42006814:	06cd      	mov.n	a12, a6
42006816:	02bd      	mov.n	a11, a2
42006818:	07ad      	mov.n	a10, a7
4200681a:	e61e81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200681d:	0008e0        	callx8	a8
    vector_test_abs(true, DTYPE_INT32);
42006820:	2b0c      	movi.n	a11, 2
42006822:	1a0c      	movi.n	a10, 1
42006824:	023865        	call8	42008bac <vector_test_abs>
    ESP_LOGI("vec_abs:", "DTYPE_FLOAT32"); 
42006827:	e60e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200682a:	0008e0        	callx8	a8
4200682d:	02ed      	mov.n	a14, a2
4200682f:	0add      	mov.n	a13, a10
42006831:	03cd      	mov.n	a12, a3
42006833:	02bd      	mov.n	a11, a2
42006835:	07ad      	mov.n	a10, a7
42006837:	e61781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200683a:	0008e0        	callx8	a8
    vector_test_abs(true, DTYPE_FLOAT32);
4200683d:	07bd      	mov.n	a11, a7
4200683f:	1a0c      	movi.n	a10, 1
42006841:	0236a5        	call8	42008bac <vector_test_abs>

    // vec_ceil
    ESP_LOGI("vec_ceil:", "DTYPE_INT8"); 
42006844:	e60781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006847:	0008e0        	callx8	a8
4200684a:	e7f331        	l32r	a3, 42000818 <_stext+0x7f8> (3c023ee4 <_flash_rodata_start+0x3dc4>)
4200684d:	03ed      	mov.n	a14, a3
4200684f:	0add      	mov.n	a13, a10
42006851:	04cd      	mov.n	a12, a4
42006853:	03bd      	mov.n	a11, a3
42006855:	20a770        	or	a10, a7, a7
42006858:	e60f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200685b:	0008e0        	callx8	a8
    vector_test_ceil(true, DTYPE_INT8);
4200685e:	0b0c      	movi.n	a11, 0
42006860:	1a0c      	movi.n	a10, 1
42006862:	024b65        	call8	42008d18 <vector_test_ceil>
    ESP_LOGI("vec_ceil:", "DTYPE_INT16"); 
42006865:	e5fe81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006868:	0008e0        	callx8	a8
4200686b:	03ed      	mov.n	a14, a3
4200686d:	0add      	mov.n	a13, a10
4200686f:	05cd      	mov.n	a12, a5
42006871:	03bd      	mov.n	a11, a3
42006873:	07ad      	mov.n	a10, a7
42006875:	e60781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006878:	0008e0        	callx8	a8
    vector_test_ceil(true, DTYPE_INT16);
4200687b:	1b0c      	movi.n	a11, 1
4200687d:	0bad      	mov.n	a10, a11
4200687f:	0249a5        	call8	42008d18 <vector_test_ceil>
    ESP_LOGI("vec_ceil:", "DTYPE_INT32"); 
42006882:	e5f781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42006885:	0008e0        	callx8	a8
42006888:	03ed      	mov.n	a14, a3
4200688a:	0add      	mov.n	a13, a10
4200688c:	06cd      	mov.n	a12, a6
4200688e:	03bd      	mov.n	a11, a3
42006890:	07ad      	mov.n	a10, a7
42006892:	e60081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42006895:	0008e0        	callx8	a8
    vector_test_ceil(true, DTYPE_INT32); 
42006898:	2b0c      	movi.n	a11, 2
4200689a:	1a0c      	movi.n	a10, 1
4200689c:	0247a5        	call8	42008d18 <vector_test_ceil>

    
    vector_test_ceil_f32(true, DTYPE_INT32); 
4200689f:	2b0c      	movi.n	a11, 2
420068a1:	1a0c      	movi.n	a10, 1
420068a3:	025ea5        	call8	42008e8c <vector_test_ceil_f32>
}
420068a6:	f01d      	retw.n

420068a8 <timer_init>:
#define CANARY_DATA 0xDEADBEEF

extern gptimer_handle_t gptimer;
extern gptimer_config_t timer_config;

static inline void timer_init(void) { 
420068a8:	004136        	entry	a1, 32
    ESP_ERROR_CHECK(gptimer_new_timer(&timer_config, &gptimer));
420068ab:	e7dcb1        	l32r	a11, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
420068ae:	e7dca1        	l32r	a10, 42000820 <_stext+0x800> (3fc925ac <timer_config>)
420068b1:	10dc25        	call8	42017674 <gptimer_new_timer>
420068b4:	010a16        	beqz	a10, 420068c8 <timer_init+0x20>
420068b7:	e7dbe1        	l32r	a14, 42000824 <_stext+0x804> (3c023ef0 <_flash_rodata_start+0x3dd0>)
420068ba:	e7dbd1        	l32r	a13, 42000828 <_stext+0x808> (3c0275cc <__func__$20>)
420068bd:	dc0c      	movi.n	a12, 13
420068bf:	e7dbb1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
420068c2:	e7dc81        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
420068c5:	0008e0        	callx8	a8
    ESP_ERROR_CHECK(gptimer_enable(gptimer)); 
420068c8:	e7d581        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
420068cb:	08a8      	l32i.n	a10, a8, 0
420068cd:	1113e5        	call8	42017a0c <gptimer_enable>
420068d0:	0a9c      	beqz.n	a10, 420068e4 <timer_init+0x3c>
420068d2:	e7d7e1        	l32r	a14, 42000830 <_stext+0x810> (3c023f4c <_flash_rodata_start+0x3e2c>)
420068d5:	e7d4d1        	l32r	a13, 42000828 <_stext+0x808> (3c0275cc <__func__$20>)
420068d8:	0ea0c2        	movi	a12, 14
420068db:	e7d4b1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
420068de:	e7d581        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
420068e1:	0008e0        	callx8	a8
}
420068e4:	f01d      	retw.n
	...

420068e8 <timer_start>:
static inline void timer_deinit(void){ 
    ESP_ERROR_CHECK(gptimer_disable(gptimer));
    ESP_ERROR_CHECK(gptimer_del_timer(gptimer)); 
}

static inline void timer_start() { 
420068e8:	004136        	entry	a1, 32
    ESP_ERROR_CHECK(gptimer_start(gptimer)); 
420068eb:	e7cc81        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
420068ee:	0028a2        	l32i	a10, a8, 0
420068f1:	112ce5        	call8	42017bc0 <gptimer_start>
420068f4:	011a16        	beqz	a10, 42006909 <timer_start+0x21>
420068f7:	e7d0e1        	l32r	a14, 42000838 <_stext+0x818> (3c023f64 <_flash_rodata_start+0x3e44>)
420068fa:	e7d0d1        	l32r	a13, 4200083c <_stext+0x81c> (3c0275c0 <__func__$19>)
420068fd:	17a0c2        	movi	a12, 23
42006900:	e7cbb1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
42006903:	e7cc81        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
42006906:	0008e0        	callx8	a8
}  
42006909:	f01d      	retw.n
	...

4200690c <timer_end>:

static inline void timer_end(uint32_t* result_ptr) {
4200690c:	006136        	entry	a1, 48
    uint64_t _count; 
    ESP_ERROR_CHECK(gptimer_stop(gptimer)); 
4200690f:	e7c381        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
42006912:	0028a2        	l32i	a10, a8, 0
42006915:	1137a5        	call8	42017c90 <gptimer_stop>
42006918:	fa8c      	beqz.n	a10, 4200692b <timer_end+0x1f>
4200691a:	e7c9e1        	l32r	a14, 42000840 <_stext+0x820> (3c023f7c <_flash_rodata_start+0x3e5c>)
4200691d:	e7c9d1        	l32r	a13, 42000844 <_stext+0x824> (3c0275b4 <__func__$18>)
42006920:	cc1c      	movi.n	a12, 28
42006922:	e7c2b1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
42006925:	e7c381        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
42006928:	0008e0        	callx8	a8
    ESP_ERROR_CHECK(gptimer_get_raw_count(gptimer, &_count));  
4200692b:	01bd      	mov.n	a11, a1
4200692d:	e7bb81        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
42006930:	08a8      	l32i.n	a10, a8, 0
42006932:	110665        	call8	42017998 <gptimer_get_raw_count>
42006935:	fa8c      	beqz.n	a10, 42006948 <timer_end+0x3c>
42006937:	e7c4e1        	l32r	a14, 42000848 <_stext+0x828> (3c023f94 <_flash_rodata_start+0x3e74>)
4200693a:	e7c2d1        	l32r	a13, 42000844 <_stext+0x824> (3c0275b4 <__func__$18>)
4200693d:	dc1c      	movi.n	a12, 29
4200693f:	e7bbb1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
42006942:	e7bc81        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
42006945:	0008e0        	callx8	a8
    *(result_ptr) = *(result_ptr) + (uint32_t)_count; 
42006948:	0288      	l32i.n	a8, a2, 0
4200694a:	0198      	l32i.n	a9, a1, 0
4200694c:	889a      	add.n	a8, a8, a9
4200694e:	0289      	s32i.n	a8, a2, 0
    ESP_ERROR_CHECK(gptimer_set_raw_count(gptimer, 0)); 
42006950:	0c0c      	movi.n	a12, 0
42006952:	0cdd      	mov.n	a13, a12
42006954:	e7b281        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
42006957:	0028a2        	l32i	a10, a8, 0
4200695a:	10fde5        	call8	42017938 <gptimer_set_raw_count>
4200695d:	fa8c      	beqz.n	a10, 42006970 <timer_end+0x64>
4200695f:	e7bbe1        	l32r	a14, 4200084c <_stext+0x82c> (3c023fbc <_flash_rodata_start+0x3e9c>)
42006962:	e7b8d1        	l32r	a13, 42000844 <_stext+0x824> (3c0275b4 <__func__$18>)
42006965:	fc1c      	movi.n	a12, 31
42006967:	e7b1b1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
4200696a:	e7b281        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200696d:	0008e0        	callx8	a8
}  
42006970:	f01d      	retw.n
	...

42006974 <timer_deinit>:
static inline void timer_deinit(void){ 
42006974:	004136        	entry	a1, 32
    ESP_ERROR_CHECK(gptimer_disable(gptimer));
42006977:	e7a981        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
4200697a:	0028a2        	l32i	a10, a8, 0
4200697d:	111665        	call8	42017ae4 <gptimer_disable>
42006980:	010a16        	beqz	a10, 42006994 <timer_deinit+0x20>
42006983:	e7b3e1        	l32r	a14, 42000850 <_stext+0x830> (3c023fe0 <_flash_rodata_start+0x3ec0>)
42006986:	e7b3d1        	l32r	a13, 42000854 <_stext+0x834> (3c0275a4 <__func__$17>)
42006989:	2c1c      	movi.n	a12, 18
4200698b:	e7a8b1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
4200698e:	e7a981        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
42006991:	0008e0        	callx8	a8
    ESP_ERROR_CHECK(gptimer_del_timer(gptimer)); 
42006994:	e7a281        	l32r	a8, 4200081c <_stext+0x7fc> (3fc95368 <gptimer>)
42006997:	0028a2        	l32i	a10, a8, 0
4200699a:	10f025        	call8	4201789c <gptimer_del_timer>
4200699d:	fa8c      	beqz.n	a10, 420069b0 <timer_deinit+0x3c>
4200699f:	e7aee1        	l32r	a14, 42000858 <_stext+0x838> (3c023ffc <_flash_rodata_start+0x3edc>)
420069a2:	e7acd1        	l32r	a13, 42000854 <_stext+0x834> (3c0275a4 <__func__$17>)
420069a5:	3c1c      	movi.n	a12, 19
420069a7:	e7a1b1        	l32r	a11, 4200082c <_stext+0x80c> (3c023f1c <_flash_rodata_start+0x3dfc>)
420069aa:	e7a281        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
420069ad:	0008e0        	callx8	a8
}
420069b0:	f01d      	retw.n
	...

420069b4 <scalar_add>:
#define SCALAR_BASIC_FUNCTIONS_H

#include "vector.h" 


vector_status_t scalar_add(const vector_t *vec1, const vector_t *vec2, vector_t *result) { 
420069b4:	004136        	entry	a1, 32
420069b7:	028d      	mov.n	a8, a2
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
420069b9:	2298      	l32i.n	a9, a2, 8
420069bb:	23a8      	l32i.n	a10, a3, 8
420069bd:	0219a7        	beq	a9, a10, 420069c3 <scalar_add+0xf>
420069c0:	004a46        	j	42006aed <scalar_add+0x139>
420069c3:	24a8      	l32i.n	a10, a4, 8
420069c5:	0219a7        	beq	a9, a10, 420069cb <scalar_add+0x17>
420069c8:	004986        	j	42006af2 <scalar_add+0x13e>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
420069cb:	1228      	l32i.n	a2, a2, 4
420069cd:	1398      	l32i.n	a9, a3, 4
420069cf:	021297        	beq	a2, a9, 420069d5 <scalar_add+0x21>
420069d2:	004886        	j	42006af8 <scalar_add+0x144>
420069d5:	1498      	l32i.n	a9, a4, 4
420069d7:	021297        	beq	a2, a9, 420069dd <scalar_add+0x29>
420069da:	0047c6        	j	42006afd <scalar_add+0x149>
    switch (vec1->type) {
420069dd:	022266        	bnei	a2, 2, 420069e3 <scalar_add+0x2f>
420069e0:	002206        	j	42006a6c <scalar_add+0xb8>
420069e3:	0932f6        	bgeui	a2, 3, 420069f0 <scalar_add+0x3c>
420069e6:	229c      	beqz.n	a2, 420069fc <scalar_add+0x48>
420069e8:	491226        	beqi	a2, 1, 42006a35 <scalar_add+0x81>
420069eb:	320c      	movi.n	a2, 3
420069ed:	004386        	j	42006aff <scalar_add+0x14b>
420069f0:	023266        	bnei	a2, 3, 420069f6 <scalar_add+0x42>
420069f3:	003246        	j	42006ac0 <scalar_add+0x10c>
420069f6:	320c      	movi.n	a2, 3
420069f8:	0040c6        	j	42006aff <scalar_add+0x14b>
420069fb:	08c800        	lsx	f12, a8, a0
        case DTYPE_INT8: {
            int8_t* vec1_data = (int8_t*)(vec1->data);
            int8_t* vec2_data = (int8_t*)(vec2->data); 
420069fe:	03d8      	l32i.n	a13, a3, 0
            int8_t* result_data = (int8_t*)(result->data); 
42006a00:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006a02:	0a0c      	movi.n	a10, 0
42006a04:	000946        	j	42006a2d <scalar_add+0x79>
42006a07:	00          	.byte	00
                int intermediate = vec1_data[i] + vec2_data[i];
42006a08:	9caa      	add.n	a9, a12, a10
42006a0a:	000992        	l8ui	a9, a9, 0
42006a0d:	239900        	sext	a9, a9, 7
42006a10:	bdaa      	add.n	a11, a13, a10
42006a12:	000bb2        	l8ui	a11, a11, 0
42006a15:	23bb00        	sext	a11, a11, 7
42006a18:	99ba      	add.n	a9, a9, a11
                intermediate = intermediate > INT8_MAX ? INT8_MAX : intermediate; 
42006a1a:	7fa0b2        	movi	a11, 127
42006a1d:	4399b0        	min	a9, a9, a11
                intermediate = intermediate < INT8_MIN ? INT8_MIN : intermediate; 
42006a20:	80afb2        	movi	a11, -128
42006a23:	5399b0        	max	a9, a9, a11
                result_data[i] = (int8_t)intermediate;
42006a26:	beaa      	add.n	a11, a14, a10
42006a28:	004b92        	s8i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006a2b:	aa1b      	addi.n	a10, a10, 1
42006a2d:	2898      	l32i.n	a9, a8, 8
42006a2f:	d53a97        	bltu	a10, a9, 42006a08 <scalar_add+0x54>
42006a32:	003246        	j	42006aff <scalar_add+0x14b>
            }
            return VECTOR_SUCCESS;
        }
        case DTYPE_INT16: { 
            int16_t* vec1_data = (int16_t*)(vec1->data);
42006a35:	08c8      	l32i.n	a12, a8, 0
            int16_t* vec2_data = (int16_t*)(vec2->data); 
42006a37:	03d8      	l32i.n	a13, a3, 0
            int16_t* result_data = (int16_t*)(result->data); 
42006a39:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006a3b:	0a0c      	movi.n	a10, 0
42006a3d:	000846        	j	42006a62 <scalar_add+0xae>
                int intermediate = vec1_data[i] + vec2_data[i];
42006a40:	909ac0        	addx2	a9, a10, a12
42006a43:	009992        	l16si	a9, a9, 0
42006a46:	90bad0        	addx2	a11, a10, a13
42006a49:	009bb2        	l16si	a11, a11, 0
42006a4c:	99ba      	add.n	a9, a9, a11
                intermediate = intermediate > INT16_MAX ? INT16_MAX : intermediate; 
42006a4e:	e783b1        	l32r	a11, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
42006a51:	4399b0        	min	a9, a9, a11
                intermediate = intermediate < INT16_MIN ? INT16_MIN : intermediate; 
42006a54:	e783b1        	l32r	a11, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)
42006a57:	5399b0        	max	a9, a9, a11
                result_data[i] = (int16_t)intermediate;
42006a5a:	90bae0        	addx2	a11, a10, a14
42006a5d:	005b92        	s16i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006a60:	aa1b      	addi.n	a10, a10, 1
42006a62:	2898      	l32i.n	a9, a8, 8
42006a64:	d83a97        	bltu	a10, a9, 42006a40 <scalar_add+0x8c>
            }
            return VECTOR_SUCCESS;
42006a67:	020c      	movi.n	a2, 0
42006a69:	002486        	j	42006aff <scalar_add+0x14b>
        }
        case DTYPE_INT32: {
            int32_t* vec1_data = (int32_t*)(vec1->data);
42006a6c:	08d8      	l32i.n	a13, a8, 0
            int32_t* vec2_data = (int32_t*)(vec2->data); 
42006a6e:	03e8      	l32i.n	a14, a3, 0
            int32_t* result_data = (int32_t*)(result->data); 
42006a70:	04f8      	l32i.n	a15, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006a72:	0b0c      	movi.n	a11, 0
42006a74:	000f86        	j	42006ab6 <scalar_add+0x102>
                int64_t intermediate = (int64_t)vec1_data[i] + (int64_t)vec2_data[i];
42006a77:	11cbe0        	slli	a12, a11, 2
42006a7a:	a09bd0        	addx4	a9, a11, a13
42006a7d:	0998      	l32i.n	a9, a9, 0
42006a7f:	31af90        	srai	a10, a9, 31
42006a82:	a04be0        	addx4	a4, a11, a14
42006a85:	0448      	l32i.n	a4, a4, 0
42006a87:	313f40        	srai	a3, a4, 31
42006a8a:	aa3a      	add.n	a10, a10, a3
42006a8c:	809940        	add	a9, a9, a4
42006a8f:	02b947        	bgeu	a9, a4, 42006a95 <scalar_add+0xe1>
42006a92:	01caa2        	addi	a10, a10, 1
                intermediate = intermediate > INT32_MAX ? INT32_MAX : intermediate; 
42006a95:	041ae6        	bgei	a10, 1, 42006a9d <scalar_add+0xe9>
42006a98:	6acc      	bnez.n	a10, 42006aa2 <scalar_add+0xee>
42006a9a:	0049d6        	bgez	a9, 42006aa2 <scalar_add+0xee>
42006a9d:	e6a191        	l32r	a9, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42006aa0:	0a0c      	movi.n	a10, 0
                intermediate = intermediate < INT32_MIN ? INT32_MIN : intermediate; 
42006aa2:	0a4d      	mov.n	a4, a10
42006aa4:	050aa6        	blti	a10, -1, 42006aad <scalar_add+0xf9>
42006aa7:	050a66        	bnei	a10, -1, 42006ab0 <scalar_add+0xfc>
42006aaa:	002996        	bltz	a9, 42006ab0 <scalar_add+0xfc>
42006aad:	e76d91        	l32r	a9, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
                result_data[i] = (int32_t)intermediate;
42006ab0:	afca      	add.n	a10, a15, a12
42006ab2:	0a99      	s32i.n	a9, a10, 0
            for (int i = 0; i < vec1->size; i++){
42006ab4:	bb1b      	addi.n	a11, a11, 1
42006ab6:	2898      	l32i.n	a9, a8, 8
42006ab8:	bb3b97        	bltu	a11, a9, 42006a77 <scalar_add+0xc3>
            }
            return VECTOR_SUCCESS;
42006abb:	020c      	movi.n	a2, 0
42006abd:	000f86        	j	42006aff <scalar_add+0x14b>
        }
        case DTYPE_FLOAT32: {
            float* vec1_data = (float*)(vec1->data);
42006ac0:	08d8      	l32i.n	a13, a8, 0
            float* vec2_data = (float*)(vec2->data); 
42006ac2:	03c8      	l32i.n	a12, a3, 0
            float* result_data = (float*)(result->data); 
42006ac4:	04b8      	l32i.n	a11, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006ac6:	090c      	movi.n	a9, 0
42006ac8:	0005c6        	j	42006ae3 <scalar_add+0x12f>
42006acb:	00          	.byte	00
                float intermediate =  vec1_data[i] + vec2_data[i]; 
42006acc:	a0a9d0        	addx4	a10, a9, a13
42006acf:	000a03        	lsi	f0, a10, 0
42006ad2:	a0a9c0        	addx4	a10, a9, a12
42006ad5:	000a13        	lsi	f1, a10, 0
42006ad8:	0a0010        	add.s	f0, f0, f1
                result_data[i] = intermediate;
42006adb:	a0a9b0        	addx4	a10, a9, a11
42006ade:	004a03        	ssi	f0, a10, 0
            for (int i = 0; i < vec1->size; i++){
42006ae1:	991b      	addi.n	a9, a9, 1
42006ae3:	28a8      	l32i.n	a10, a8, 8
42006ae5:	e339a7        	bltu	a9, a10, 42006acc <scalar_add+0x118>
            }
            return VECTOR_SUCCESS;
42006ae8:	020c      	movi.n	a2, 0
42006aea:	000446        	j	42006aff <scalar_add+0x14b>
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42006aed:	720c      	movi.n	a2, 7
42006aef:	000306        	j	42006aff <scalar_add+0x14b>
42006af2:	720c      	movi.n	a2, 7
42006af4:	0001c6        	j	42006aff <scalar_add+0x14b>
42006af7:	820c00        	mull	a0, a12, a0
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42006afa:	000046        	j	42006aff <scalar_add+0x14b>
42006afd:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR; 
    }   
}
42006aff:	f01d      	retw.n
42006b01:	000000        	ill

42006b04 <scalar_sub>:

vector_status_t scalar_sub(const vector_t *vec1, const vector_t *vec2, vector_t *result) { 
42006b04:	004136        	entry	a1, 32
42006b07:	028d      	mov.n	a8, a2
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42006b09:	2298      	l32i.n	a9, a2, 8
42006b0b:	23a8      	l32i.n	a10, a3, 8
42006b0d:	0219a7        	beq	a9, a10, 42006b13 <scalar_sub+0xf>
42006b10:	004a46        	j	42006c3d <scalar_sub+0x139>
42006b13:	24a8      	l32i.n	a10, a4, 8
42006b15:	0219a7        	beq	a9, a10, 42006b1b <scalar_sub+0x17>
42006b18:	004986        	j	42006c42 <scalar_sub+0x13e>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42006b1b:	1228      	l32i.n	a2, a2, 4
42006b1d:	1398      	l32i.n	a9, a3, 4
42006b1f:	021297        	beq	a2, a9, 42006b25 <scalar_sub+0x21>
42006b22:	004886        	j	42006c48 <scalar_sub+0x144>
42006b25:	1498      	l32i.n	a9, a4, 4
42006b27:	021297        	beq	a2, a9, 42006b2d <scalar_sub+0x29>
42006b2a:	0047c6        	j	42006c4d <scalar_sub+0x149>
    switch (vec1->type) {
42006b2d:	022266        	bnei	a2, 2, 42006b33 <scalar_sub+0x2f>
42006b30:	002286        	j	42006bbe <scalar_sub+0xba>
42006b33:	0932f6        	bgeui	a2, 3, 42006b40 <scalar_sub+0x3c>
42006b36:	229c      	beqz.n	a2, 42006b4c <scalar_sub+0x48>
42006b38:	4a1226        	beqi	a2, 1, 42006b86 <scalar_sub+0x82>
42006b3b:	320c      	movi.n	a2, 3
42006b3d:	004386        	j	42006c4f <scalar_sub+0x14b>
42006b40:	023266        	bnei	a2, 3, 42006b46 <scalar_sub+0x42>
42006b43:	003286        	j	42006c11 <scalar_sub+0x10d>
42006b46:	320c      	movi.n	a2, 3
42006b48:	0040c6        	j	42006c4f <scalar_sub+0x14b>
42006b4b:	08c800        	lsx	f12, a8, a0
        case DTYPE_INT8: {
            int8_t* vec1_data = (int8_t*)(vec1->data);
            int8_t* vec2_data = (int8_t*)(vec2->data); 
42006b4e:	03d8      	l32i.n	a13, a3, 0
            int8_t* result_data = (int8_t*)(result->data); 
42006b50:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006b52:	0a0c      	movi.n	a10, 0
42006b54:	000986        	j	42006b7e <scalar_sub+0x7a>
42006b57:	00          	.byte	00
                int intermediate = vec1_data[i] - vec2_data[i];
42006b58:	9caa      	add.n	a9, a12, a10
42006b5a:	000992        	l8ui	a9, a9, 0
42006b5d:	239900        	sext	a9, a9, 7
42006b60:	bdaa      	add.n	a11, a13, a10
42006b62:	000bb2        	l8ui	a11, a11, 0
42006b65:	23bb00        	sext	a11, a11, 7
42006b68:	c099b0        	sub	a9, a9, a11
                intermediate = intermediate > INT8_MAX ? INT8_MAX : intermediate; 
42006b6b:	7fa0b2        	movi	a11, 127
42006b6e:	4399b0        	min	a9, a9, a11
                intermediate = intermediate < INT8_MIN ? INT8_MIN : intermediate; 
42006b71:	80afb2        	movi	a11, -128
42006b74:	5399b0        	max	a9, a9, a11
                result_data[i] = (int8_t)intermediate;
42006b77:	beaa      	add.n	a11, a14, a10
42006b79:	004b92        	s8i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006b7c:	aa1b      	addi.n	a10, a10, 1
42006b7e:	2898      	l32i.n	a9, a8, 8
42006b80:	d43a97        	bltu	a10, a9, 42006b58 <scalar_sub+0x54>
42006b83:	003206        	j	42006c4f <scalar_sub+0x14b>
            }
            return VECTOR_SUCCESS;
        }
        case DTYPE_INT16: { 
            int16_t* vec1_data = (int16_t*)(vec1->data);
42006b86:	08c8      	l32i.n	a12, a8, 0
            int16_t* vec2_data = (int16_t*)(vec2->data); 
42006b88:	03d8      	l32i.n	a13, a3, 0
            int16_t* result_data = (int16_t*)(result->data); 
42006b8a:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006b8c:	0a0c      	movi.n	a10, 0
42006b8e:	000886        	j	42006bb4 <scalar_sub+0xb0>
                int intermediate = vec1_data[i] - vec2_data[i];
42006b91:	909ac0        	addx2	a9, a10, a12
42006b94:	009992        	l16si	a9, a9, 0
42006b97:	90bad0        	addx2	a11, a10, a13
42006b9a:	009bb2        	l16si	a11, a11, 0
42006b9d:	c099b0        	sub	a9, a9, a11
                intermediate = intermediate > INT16_MAX ? INT16_MAX : intermediate; 
42006ba0:	e72fb1        	l32r	a11, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
42006ba3:	4399b0        	min	a9, a9, a11
                intermediate = intermediate < INT16_MIN ? INT16_MIN : intermediate; 
42006ba6:	e72eb1        	l32r	a11, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)
42006ba9:	5399b0        	max	a9, a9, a11
                result_data[i] = (int16_t)intermediate;
42006bac:	90bae0        	addx2	a11, a10, a14
42006baf:	005b92        	s16i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006bb2:	aa1b      	addi.n	a10, a10, 1
42006bb4:	2898      	l32i.n	a9, a8, 8
42006bb6:	d73a97        	bltu	a10, a9, 42006b91 <scalar_sub+0x8d>
            }
            return VECTOR_SUCCESS;
42006bb9:	020c      	movi.n	a2, 0
42006bbb:	002406        	j	42006c4f <scalar_sub+0x14b>
        }
        case DTYPE_INT32: {
            int32_t* vec1_data = (int32_t*)(vec1->data);
42006bbe:	08e8      	l32i.n	a14, a8, 0
            int32_t* vec2_data = (int32_t*)(vec2->data); 
42006bc0:	03f8      	l32i.n	a15, a3, 0
            int32_t* result_data = (int32_t*)(result->data); 
42006bc2:	0448      	l32i.n	a4, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006bc4:	0b0c      	movi.n	a11, 0
42006bc6:	000f46        	j	42006c07 <scalar_sub+0x103>
                int64_t intermediate = (int64_t)vec1_data[i] - (int64_t)vec2_data[i];
42006bc9:	11cbe0        	slli	a12, a11, 2
42006bcc:	a09be0        	addx4	a9, a11, a14
42006bcf:	09a8      	l32i.n	a10, a9, 0
42006bd1:	319fa0        	srai	a9, a10, 31
42006bd4:	a0dbf0        	addx4	a13, a11, a15
42006bd7:	0dd8      	l32i.n	a13, a13, 0
42006bd9:	313fd0        	srai	a3, a13, 31
42006bdc:	c09930        	sub	a9, a9, a3
42006bdf:	02bad7        	bgeu	a10, a13, 42006be5 <scalar_sub+0xe1>
42006be2:	ffc992        	addi	a9, a9, -1
                intermediate = intermediate > INT32_MAX ? INT32_MAX : intermediate; 
42006be5:	c0aad0        	sub	a10, a10, a13
42006be8:	0419e6        	bgei	a9, 1, 42006bf0 <scalar_sub+0xec>
42006beb:	69cc      	bnez.n	a9, 42006bf5 <scalar_sub+0xf1>
42006bed:	004ad6        	bgez	a10, 42006bf5 <scalar_sub+0xf1>
42006bf0:	e64da1        	l32r	a10, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42006bf3:	090c      	movi.n	a9, 0
                intermediate = intermediate < INT32_MIN ? INT32_MIN : intermediate; 
42006bf5:	0509a6        	blti	a9, -1, 42006bfe <scalar_sub+0xfa>
42006bf8:	050966        	bnei	a9, -1, 42006c01 <scalar_sub+0xfd>
42006bfb:	002a96        	bltz	a10, 42006c01 <scalar_sub+0xfd>
42006bfe:	e719a1        	l32r	a10, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
                result_data[i] = (int32_t)intermediate;
42006c01:	94ca      	add.n	a9, a4, a12
42006c03:	09a9      	s32i.n	a10, a9, 0
            for (int i = 0; i < vec1->size; i++){
42006c05:	bb1b      	addi.n	a11, a11, 1
42006c07:	2898      	l32i.n	a9, a8, 8
42006c09:	bc3b97        	bltu	a11, a9, 42006bc9 <scalar_sub+0xc5>
            }
            return VECTOR_SUCCESS;
42006c0c:	020c      	movi.n	a2, 0
42006c0e:	000f46        	j	42006c4f <scalar_sub+0x14b>
        }
        case DTYPE_FLOAT32: {
            float* vec1_data = (float*)(vec1->data);
42006c11:	08d8      	l32i.n	a13, a8, 0
            float* vec2_data = (float*)(vec2->data); 
42006c13:	03c8      	l32i.n	a12, a3, 0
            float* result_data = (float*)(result->data); 
42006c15:	04b8      	l32i.n	a11, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006c17:	090c      	movi.n	a9, 0
42006c19:	000586        	j	42006c33 <scalar_sub+0x12f>
                float intermediate =  vec1_data[i] - vec2_data[i]; 
42006c1c:	a0a9d0        	addx4	a10, a9, a13
42006c1f:	000a03        	lsi	f0, a10, 0
42006c22:	a0a9c0        	addx4	a10, a9, a12
42006c25:	000a13        	lsi	f1, a10, 0
42006c28:	1a0010        	sub.s	f0, f0, f1
                result_data[i] = intermediate;
42006c2b:	a0a9b0        	addx4	a10, a9, a11
42006c2e:	004a03        	ssi	f0, a10, 0
            for (int i = 0; i < vec1->size; i++){
42006c31:	991b      	addi.n	a9, a9, 1
42006c33:	28a8      	l32i.n	a10, a8, 8
42006c35:	e339a7        	bltu	a9, a10, 42006c1c <scalar_sub+0x118>
            }
            return VECTOR_SUCCESS;
42006c38:	020c      	movi.n	a2, 0
42006c3a:	000446        	j	42006c4f <scalar_sub+0x14b>
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42006c3d:	720c      	movi.n	a2, 7
42006c3f:	000306        	j	42006c4f <scalar_sub+0x14b>
42006c42:	720c      	movi.n	a2, 7
42006c44:	0001c6        	j	42006c4f <scalar_sub+0x14b>
42006c47:	820c00        	mull	a0, a12, a0
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42006c4a:	000046        	j	42006c4f <scalar_sub+0x14b>
42006c4d:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR; 
    }   
}
42006c4f:	f01d      	retw.n
42006c51:	000000        	ill

42006c54 <scalar_add_scalar>:

vector_status_t scalar_add_scalar(const vector_t *vec1, const int scalar, vector_t *result) { 
42006c54:	004136        	entry	a1, 32
42006c57:	029d      	mov.n	a9, a2
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42006c59:	22a8      	l32i.n	a10, a2, 8
42006c5b:	2488      	l32i.n	a8, a4, 8
42006c5d:	021a87        	beq	a10, a8, 42006c63 <scalar_add_scalar+0xf>
42006c60:	003346        	j	42006d31 <scalar_add_scalar+0xdd>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42006c63:	1228      	l32i.n	a2, a2, 4
42006c65:	1488      	l32i.n	a8, a4, 4
42006c67:	021287        	beq	a2, a8, 42006c6d <scalar_add_scalar+0x19>
42006c6a:	003206        	j	42006d36 <scalar_add_scalar+0xe2>
    switch (vec1->type) {
42006c6d:	752226        	beqi	a2, 2, 42006ce6 <scalar_add_scalar+0x92>
42006c70:	0932f6        	bgeui	a2, 3, 42006c7d <scalar_add_scalar+0x29>
42006c73:	129c      	beqz.n	a2, 42006c88 <scalar_add_scalar+0x34>
42006c75:	3d1226        	beqi	a2, 1, 42006cb6 <scalar_add_scalar+0x62>
        }
        case DTYPE_FLOAT32: {
            return VECTOR_UNSUPPORTED_OPERATION;
        }
        default:
            return VECTOR_ERROR; 
42006c78:	320c      	movi.n	a2, 3
42006c7a:	003006        	j	42006d3e <scalar_add_scalar+0xea>
    switch (vec1->type) {
42006c7d:	023226        	beqi	a2, 3, 42006c83 <scalar_add_scalar+0x2f>
42006c80:	002e06        	j	42006d3c <scalar_add_scalar+0xe8>
42006c83:	420c      	movi.n	a2, 4
42006c85:	002d46        	j	42006d3e <scalar_add_scalar+0xea>
            int8_t* vec1_data = (int8_t*)(vec1->data); 
42006c88:	09c8      	l32i.n	a12, a9, 0
            int8_t* result_data = (int8_t*)(result->data); 
42006c8a:	04d8      	l32i.n	a13, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006c8c:	0a0c      	movi.n	a10, 0
42006c8e:	000706        	j	42006cae <scalar_add_scalar+0x5a>
                int intermediate = vec1_data[i] + scalar;
42006c91:	8caa      	add.n	a8, a12, a10
42006c93:	000882        	l8ui	a8, a8, 0
42006c96:	238800        	sext	a8, a8, 7
42006c99:	883a      	add.n	a8, a8, a3
                intermediate = intermediate > INT8_MAX ? INT8_MAX : intermediate; 
42006c9b:	7fa0b2        	movi	a11, 127
42006c9e:	4388b0        	min	a8, a8, a11
                intermediate = intermediate < INT8_MIN ? INT8_MIN : intermediate; 
42006ca1:	80afb2        	movi	a11, -128
42006ca4:	5388b0        	max	a8, a8, a11
                result_data[i] = (int8_t)intermediate;
42006ca7:	bdaa      	add.n	a11, a13, a10
42006ca9:	004b82        	s8i	a8, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006cac:	aa1b      	addi.n	a10, a10, 1
42006cae:	2988      	l32i.n	a8, a9, 8
42006cb0:	dd3a87        	bltu	a10, a8, 42006c91 <scalar_add_scalar+0x3d>
42006cb3:	0021c6        	j	42006d3e <scalar_add_scalar+0xea>
            int16_t* vec1_data = (int16_t*)(vec1->data); 
42006cb6:	09c8      	l32i.n	a12, a9, 0
            int16_t* result_data = (int16_t*)(result->data); 
42006cb8:	04d8      	l32i.n	a13, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006cba:	0a0c      	movi.n	a10, 0
42006cbc:	000706        	j	42006cdc <scalar_add_scalar+0x88>
42006cbf:	8ac000        	round.s	a12, f0, 0
                int intermediate = vec1_data[i] + scalar;
42006cc2:	90          	.byte	0x90
42006cc3:	009882        	l16si	a8, a8, 0
42006cc6:	883a      	add.n	a8, a8, a3
                intermediate = intermediate > INT16_MAX ? INT16_MAX : intermediate; 
42006cc8:	e6e5b1        	l32r	a11, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
42006ccb:	4388b0        	min	a8, a8, a11
                intermediate = intermediate < INT16_MIN ? INT16_MIN : intermediate; 
42006cce:	e6e4b1        	l32r	a11, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)
42006cd1:	5388b0        	max	a8, a8, a11
                result_data[i] = (int16_t)intermediate;
42006cd4:	90bad0        	addx2	a11, a10, a13
42006cd7:	005b82        	s16i	a8, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006cda:	aa1b      	addi.n	a10, a10, 1
42006cdc:	2988      	l32i.n	a8, a9, 8
42006cde:	de3a87        	bltu	a10, a8, 42006cc0 <scalar_add_scalar+0x6c>
            return VECTOR_SUCCESS;
42006ce1:	020c      	movi.n	a2, 0
42006ce3:	0015c6        	j	42006d3e <scalar_add_scalar+0xea>
            int32_t* vec1_data = (int32_t*)(vec1->data); 
42006ce6:	09d8      	l32i.n	a13, a9, 0
            int32_t* result_data = (int32_t*)(result->data); 
42006ce8:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
42006cea:	0b0c      	movi.n	a11, 0
42006cec:	000dc6        	j	42006d27 <scalar_add_scalar+0xd3>
42006cef:	e00000        	subx4	a0, a0, a0
                int64_t intermediate = (int64_t)vec1_data[i] + scalar;
42006cf2:	11cb      	addi.n	a1, a1, 12
42006cf4:	a08bd0        	addx4	a8, a11, a13
42006cf7:	0888      	l32i.n	a8, a8, 0
42006cf9:	31af80        	srai	a10, a8, 31
42006cfc:	31ff30        	srai	a15, a3, 31
42006cff:	aafa      	add.n	a10, a10, a15
42006d01:	883a      	add.n	a8, a8, a3
42006d03:	01b837        	bgeu	a8, a3, 42006d08 <scalar_add_scalar+0xb4>
42006d06:	aa1b      	addi.n	a10, a10, 1
                intermediate = intermediate > INT32_MAX ? INT32_MAX : intermediate; 
42006d08:	041ae6        	bgei	a10, 1, 42006d10 <scalar_add_scalar+0xbc>
42006d0b:	6acc      	bnez.n	a10, 42006d15 <scalar_add_scalar+0xc1>
42006d0d:	0048d6        	bgez	a8, 42006d15 <scalar_add_scalar+0xc1>
42006d10:	e60581        	l32r	a8, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42006d13:	0a0c      	movi.n	a10, 0
                intermediate = intermediate < INT32_MIN ? INT32_MIN : intermediate; 
42006d15:	050aa6        	blti	a10, -1, 42006d1e <scalar_add_scalar+0xca>
42006d18:	050a66        	bnei	a10, -1, 42006d21 <scalar_add_scalar+0xcd>
42006d1b:	002896        	bltz	a8, 42006d21 <scalar_add_scalar+0xcd>
42006d1e:	e6d181        	l32r	a8, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
                result_data[i] = (int32_t)intermediate;
42006d21:	aeca      	add.n	a10, a14, a12
42006d23:	0a89      	s32i.n	a8, a10, 0
            for (int i = 0; i < vec1->size; i++){
42006d25:	bb1b      	addi.n	a11, a11, 1
42006d27:	2988      	l32i.n	a8, a9, 8
42006d29:	c43b87        	bltu	a11, a8, 42006cf1 <scalar_add_scalar+0x9d>
            return VECTOR_SUCCESS;
42006d2c:	020c      	movi.n	a2, 0
42006d2e:	000306        	j	42006d3e <scalar_add_scalar+0xea>
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42006d31:	720c      	movi.n	a2, 7
42006d33:	0001c6        	j	42006d3e <scalar_add_scalar+0xea>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42006d36:	820c      	movi.n	a2, 8
42006d38:	000086        	j	42006d3e <scalar_add_scalar+0xea>
42006d3b:	320c00        	orbc	b0, b12, b0
    }   
}
42006d3e:	f01d      	retw.n

42006d40 <scalar_sum>:
        default:
            return VECTOR_ERROR; 
    }  
}

vector_status_t scalar_sum(const vector_t *vec1, int32_t* result) {  
42006d40:	006136        	entry	a1, 48
42006d43:	028d      	mov.n	a8, a2
    int32_t output = 0;
    switch (vec1->type) {
42006d45:	1228      	l32i.n	a2, a2, 4
42006d47:	572226        	beqi	a2, 2, 42006da2 <scalar_sum+0x62>
42006d4a:	0932f6        	bgeui	a2, 3, 42006d57 <scalar_sum+0x17>
42006d4d:	129c      	beqz.n	a2, 42006d62 <scalar_sum+0x22>
42006d4f:	2f1226        	beqi	a2, 1, 42006d82 <scalar_sum+0x42>
        }
        case DTYPE_FLOAT32: { 
            return VECTOR_UNSUPPORTED_OPERATION;
        }
        default:
            return VECTOR_ERROR; 
42006d52:	320c      	movi.n	a2, 3
42006d54:	005c86        	j	42006eca <scalar_sum+0x18a>
    switch (vec1->type) {
42006d57:	023226        	beqi	a2, 3, 42006d5d <scalar_sum+0x1d>
42006d5a:	005a86        	j	42006ec8 <scalar_sum+0x188>
42006d5d:	420c      	movi.n	a2, 4
42006d5f:	0059c6        	j	42006eca <scalar_sum+0x18a>
            int8_t* vec1_data = (int8_t*)(vec1->data); 
42006d62:	08c8      	l32i.n	a12, a8, 0
            for (int i = 0; i < vec1->size; i++){ 
42006d64:	090c      	movi.n	a9, 0
    int32_t output = 0;
42006d66:	09bd      	mov.n	a11, a9
            for (int i = 0; i < vec1->size; i++){ 
42006d68:	000306        	j	42006d78 <scalar_sum+0x38>
42006d6b:	00          	.byte	00
                output += (int)vec1_data[i];
42006d6c:	ac9a      	add.n	a10, a12, a9
42006d6e:	000aa2        	l8ui	a10, a10, 0
42006d71:	23aa00        	sext	a10, a10, 7
42006d74:	bbaa      	add.n	a11, a11, a10
            for (int i = 0; i < vec1->size; i++){ 
42006d76:	991b      	addi.n	a9, a9, 1
42006d78:	28a8      	l32i.n	a10, a8, 8
42006d7a:	ee39a7        	bltu	a9, a10, 42006d6c <scalar_sum+0x2c>
            *result = output;
42006d7d:	03b9      	s32i.n	a11, a3, 0
            return VECTOR_SUCCESS;
42006d7f:	0051c6        	j	42006eca <scalar_sum+0x18a>
            int16_t* vec1_data = (int16_t*)(vec1->data); 
42006d82:	08c8      	l32i.n	a12, a8, 0
            for (int i = 0; i < vec1->size; i++){ 
42006d84:	090c      	movi.n	a9, 0
    int32_t output = 0;
42006d86:	09ad      	mov.n	a10, a9
            for (int i = 0; i < vec1->size; i++){ 
42006d88:	000286        	j	42006d96 <scalar_sum+0x56>
42006d8b:	00          	.byte	00
                output += (int)vec1_data[i];
42006d8c:	90b9c0        	addx2	a11, a9, a12
42006d8f:	009bb2        	l16si	a11, a11, 0
42006d92:	aaba      	add.n	a10, a10, a11
            for (int i = 0; i < vec1->size; i++){ 
42006d94:	991b      	addi.n	a9, a9, 1
42006d96:	28b8      	l32i.n	a11, a8, 8
42006d98:	f039b7        	bltu	a9, a11, 42006d8c <scalar_sum+0x4c>
            *result = output;
42006d9b:	03a9      	s32i.n	a10, a3, 0
            return VECTOR_SUCCESS;
42006d9d:	020c      	movi.n	a2, 0
42006d9f:	0049c6        	j	42006eca <scalar_sum+0x18a>
            const int32_t *vec1_data = (const int32_t *)vec1->data;
42006da2:	0878      	l32i.n	a7, a8, 0
            int n = vec1->size & ~3;           
42006da4:	2828      	l32i.n	a2, a8, 8
42006da6:	cf7c      	movi.n	a15, -4
42006da8:	10f2f0        	and	a15, a2, a15
            for (int i = 0; i < n; i += 4) {
42006dab:	0c0c      	movi.n	a12, 0
            int64_t lane1 = 0, lane2 = 0, lane3 = 0, lane4 = 0;
42006dad:	0c6d      	mov.n	a6, a12
42006daf:	0cbd      	mov.n	a11, a12
42006db1:	0c5d      	mov.n	a5, a12
42006db3:	0cad      	mov.n	a10, a12
42006db5:	0cdd      	mov.n	a13, a12
42006db7:	0c9d      	mov.n	a9, a12
42006db9:	0c4d      	mov.n	a4, a12
42006dbb:	0c8d      	mov.n	a8, a12
42006dbd:	0129      	s32i.n	a2, a1, 0
42006dbf:	1139      	s32i.n	a3, a1, 4
            for (int i = 0; i < n; i += 4) {
42006dc1:	0036c6        	j	42006ea0 <scalar_sum+0x160>
42006dc4:	00          	.byte	00
                lane1 += vec1_data[i + 0];
42006dc5:	a0ec70        	addx4	a14, a12, a7
42006dc8:	0ee8      	l32i.n	a14, a14, 0
42006dca:	313fe0        	srai	a3, a14, 31
42006dcd:	e4ea      	add.n	a14, a4, a14
42006dcf:	622e40        	saltu	a2, a14, a4
42006dd2:	383a      	add.n	a3, a8, a3
42006dd4:	0e4d      	mov.n	a4, a14
42006dd6:	823a      	add.n	a8, a2, a3
                lane2 += vec1_data[i + 1];
42006dd8:	ec1b      	addi.n	a14, a12, 1
42006dda:	a0ee70        	addx4	a14, a14, a7
42006ddd:	0ee8      	l32i.n	a14, a14, 0
42006ddf:	313fe0        	srai	a3, a14, 31
42006de2:	edea      	add.n	a14, a13, a14
42006de4:	622ed0        	saltu	a2, a14, a13
42006de7:	393a      	add.n	a3, a9, a3
42006de9:	0edd      	mov.n	a13, a14
42006deb:	923a      	add.n	a9, a2, a3
                lane3 += vec1_data[i + 2];
42006ded:	ec2b      	addi.n	a14, a12, 2
42006def:	a0ee70        	addx4	a14, a14, a7
42006df2:	0ee8      	l32i.n	a14, a14, 0
42006df4:	313fe0        	srai	a3, a14, 31
42006df7:	e5ea      	add.n	a14, a5, a14
42006df9:	622e50        	saltu	a2, a14, a5
42006dfc:	3a3a      	add.n	a3, a10, a3
42006dfe:	0e5d      	mov.n	a5, a14
42006e00:	a23a      	add.n	a10, a2, a3
                lane4 += vec1_data[i + 3];
42006e02:	ec3b      	addi.n	a14, a12, 3
42006e04:	a0ee70        	addx4	a14, a14, a7
42006e07:	0ee8      	l32i.n	a14, a14, 0
42006e09:	313fe0        	srai	a3, a14, 31
42006e0c:	e6ea      	add.n	a14, a6, a14
42006e0e:	622e60        	saltu	a2, a14, a6
42006e11:	3b3a      	add.n	a3, a11, a3
42006e13:	0e6d      	mov.n	a6, a14
42006e15:	b23a      	add.n	a11, a2, a3
                if (lane1 < INT32_MIN) lane1 = INT32_MIN; else if (lane1 > INT32_MAX) lane1 = INT32_MAX;
42006e17:	1108a6        	blti	a8, -1, 42006e2c <scalar_sum+0xec>
42006e1a:	020866        	bnei	a8, -1, 42006e20 <scalar_sum+0xe0>
42006e1d:	00b4d6        	bgez	a4, 42006e2c <scalar_sum+0xec>
42006e20:	1018e6        	bgei	a8, 1, 42006e34 <scalar_sum+0xf4>
42006e23:	28dc      	bnez.n	a8, 42006e39 <scalar_sum+0xf9>
42006e25:	00b496        	bltz	a4, 42006e34 <scalar_sum+0xf4>
42006e28:	000346        	j	42006e39 <scalar_sum+0xf9>
42006e2b:	00          	.byte	00
42006e2c:	e68e41        	l32r	a4, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
42006e2f:	f87c      	movi.n	a8, -1
42006e31:	000106        	j	42006e39 <scalar_sum+0xf9>
42006e34:	e5bc41        	l32r	a4, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42006e37:	080c      	movi.n	a8, 0
                if (lane2 < INT32_MIN) lane2 = INT32_MIN; else if (lane2 > INT32_MAX) lane2 = INT32_MAX;
42006e39:	1009a6        	blti	a9, -1, 42006e4d <scalar_sum+0x10d>
42006e3c:	020966        	bnei	a9, -1, 42006e42 <scalar_sum+0x102>
42006e3f:	00add6        	bgez	a13, 42006e4d <scalar_sum+0x10d>
42006e42:	0f19e6        	bgei	a9, 1, 42006e55 <scalar_sum+0x115>
42006e45:	19dc      	bnez.n	a9, 42006e5a <scalar_sum+0x11a>
42006e47:	00ad96        	bltz	a13, 42006e55 <scalar_sum+0x115>
42006e4a:	000306        	j	42006e5a <scalar_sum+0x11a>
42006e4d:	e685d1        	l32r	a13, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
42006e50:	f97c      	movi.n	a9, -1
42006e52:	000106        	j	42006e5a <scalar_sum+0x11a>
42006e55:	e5b3d1        	l32r	a13, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42006e58:	090c      	movi.n	a9, 0
                if (lane3 < INT32_MIN) lane3 = INT32_MIN; else if (lane3 > INT32_MAX) lane3 = INT32_MAX;
42006e5a:	100aa6        	blti	a10, -1, 42006e6e <scalar_sum+0x12e>
42006e5d:	020a66        	bnei	a10, -1, 42006e63 <scalar_sum+0x123>
42006e60:	00a5d6        	bgez	a5, 42006e6e <scalar_sum+0x12e>
42006e63:	111ae6        	bgei	a10, 1, 42006e78 <scalar_sum+0x138>
42006e66:	3adc      	bnez.n	a10, 42006e7d <scalar_sum+0x13d>
42006e68:	00c596        	bltz	a5, 42006e78 <scalar_sum+0x138>
42006e6b:	000386        	j	42006e7d <scalar_sum+0x13d>
42006e6e:	e67d51        	l32r	a5, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
42006e71:	fa7c      	movi.n	a10, -1
42006e73:	000186        	j	42006e7d <scalar_sum+0x13d>
42006e76:	00          	.byte	00
42006e77:	ab5100        	movltz.s	f5, f1, a0
42006e7a:	0a0ce5        	call8	42010f48 <_vfiprintf_r+0x428>
                if (lane4 < INT32_MIN) lane4 = INT32_MIN; else if (lane4 > INT32_MAX) lane4 = INT32_MAX;
42006e7d:	100ba6        	blti	a11, -1, 42006e91 <scalar_sum+0x151>
42006e80:	020b66        	bnei	a11, -1, 42006e86 <scalar_sum+0x146>
42006e83:	00a6d6        	bgez	a6, 42006e91 <scalar_sum+0x151>
42006e86:	0f1be6        	bgei	a11, 1, 42006e99 <scalar_sum+0x159>
42006e89:	1bdc      	bnez.n	a11, 42006e9e <scalar_sum+0x15e>
42006e8b:	00a696        	bltz	a6, 42006e99 <scalar_sum+0x159>
42006e8e:	000306        	j	42006e9e <scalar_sum+0x15e>
42006e91:	e67461        	l32r	a6, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
42006e94:	fb7c      	movi.n	a11, -1
42006e96:	000106        	j	42006e9e <scalar_sum+0x15e>
42006e99:	e5a261        	l32r	a6, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
42006e9c:	0b0c      	movi.n	a11, 0
            for (int i = 0; i < n; i += 4) {
42006e9e:	cc4b      	addi.n	a12, a12, 4
42006ea0:	02acf7        	bge	a12, a15, 42006ea6 <scalar_sum+0x166>
42006ea3:	ffc786        	j	42006dc5 <scalar_sum+0x85>
            wsum += (uint32_t)(int32_t)lane2;
42006ea6:	0128      	l32i.n	a2, a1, 0
42006ea8:	1138      	l32i.n	a3, a1, 4
42006eaa:	dd4a      	add.n	a13, a13, a4
            wsum += (uint32_t)(int32_t)lane3;
42006eac:	dd5a      	add.n	a13, a13, a5
            wsum += (uint32_t)(int32_t)lane4;
42006eae:	dd6a      	add.n	a13, a13, a6
            for (int i = n; i < vec1->size; ++i) {
42006eb0:	000246        	j	42006ebd <scalar_sum+0x17d>
42006eb3:	00          	.byte	00
                wsum += (uint32_t)vec1_data[i];
42006eb4:	a08f70        	addx4	a8, a15, a7
42006eb7:	0888      	l32i.n	a8, a8, 0
42006eb9:	dd8a      	add.n	a13, a13, a8
            for (int i = n; i < vec1->size; ++i) {
42006ebb:	ff1b      	addi.n	a15, a15, 1
42006ebd:	f33f27        	bltu	a15, a2, 42006eb4 <scalar_sum+0x174>
            *result = (int32_t)wsum;
42006ec0:	03d9      	s32i.n	a13, a3, 0
            return VECTOR_SUCCESS;
42006ec2:	020c      	movi.n	a2, 0
42006ec4:	000086        	j	42006eca <scalar_sum+0x18a>
42006ec7:	320c00        	orbc	b0, b12, b0
    }   
}
42006eca:	f01d      	retw.n

42006ecc <scalar_sum_f32>:

vector_status_t scalar_sum_f32(const vector_t *vec1, float* result) {  
42006ecc:	004136        	entry	a1, 32
    float output = 0;
    switch (vec1->type) {
42006ecf:	1288      	l32i.n	a8, a2, 4
42006ed1:	2738b6        	bltui	a8, 3, 42006efc <scalar_sum_f32+0x30>
42006ed4:	293866        	bnei	a8, 3, 42006f01 <scalar_sum_f32+0x35>
        case DTYPE_INT8: return VECTOR_UNSUPPORTED_OPERATION;
        case DTYPE_INT16: return VECTOR_UNSUPPORTED_OPERATION;
        case DTYPE_INT32: return VECTOR_UNSUPPORTED_OPERATION;
        case DTYPE_FLOAT32: { 
            float* vec1_data = (float*)(vec1->data); 
42006ed7:	02a8      	l32i.n	a10, a2, 0
            for (int i = 0; i < vec1->size; i++){ 
42006ed9:	080c      	movi.n	a8, 0
    float output = 0;
42006edb:	e66391        	l32r	a9, 42000868 <_stext+0x848> (0 <IDF_TARGET_ESP32S3>)
42006ede:	fa0950        	wfr	f0, a9
            for (int i = 0; i < vec1->size; i++){ 
42006ee1:	000286        	j	42006eef <scalar_sum_f32+0x23>
                output += (float)vec1_data[i];
42006ee4:	a098a0        	addx4	a9, a8, a10
42006ee7:	000913        	lsi	f1, a9, 0
42006eea:	0a0010        	add.s	f0, f0, f1
            for (int i = 0; i < vec1->size; i++){ 
42006eed:	881b      	addi.n	a8, a8, 1
42006eef:	2298      	l32i.n	a9, a2, 8
42006ef1:	ef3897        	bltu	a8, a9, 42006ee4 <scalar_sum_f32+0x18>
            }
            *result = output;
42006ef4:	004303        	ssi	f0, a3, 0
            return VECTOR_SUCCESS;
42006ef7:	020c      	movi.n	a2, 0
42006ef9:	000186        	j	42006f03 <scalar_sum_f32+0x37>
    switch (vec1->type) {
42006efc:	420c      	movi.n	a2, 4
42006efe:	000046        	j	42006f03 <scalar_sum_f32+0x37>
        }
        default:
            return VECTOR_ERROR; 
42006f01:	320c      	movi.n	a2, 3
    }   
}
42006f03:	f01d      	retw.n
42006f05:	000000        	ill

42006f08 <scalar_abs>:
        default:
            return VECTOR_ERROR;  
    }
}

vector_status_t scalar_abs(const vector_t *vec1,  vector_t* result) {
42006f08:	004136        	entry	a1, 32
42006f0b:	028d      	mov.n	a8, a2
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42006f0d:	22a8      	l32i.n	a10, a2, 8
42006f0f:	2398      	l32i.n	a9, a3, 8
42006f11:	021a97        	beq	a10, a9, 42006f17 <scalar_abs+0xf>
42006f14:	0032c6        	j	42006fe3 <scalar_abs+0xdb>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}   
42006f17:	1228      	l32i.n	a2, a2, 4
42006f19:	1398      	l32i.n	a9, a3, 4
42006f1b:	021297        	beq	a2, a9, 42006f21 <scalar_abs+0x19>
42006f1e:	003186        	j	42006fe8 <scalar_abs+0xe0>
    
    switch (vec1->type){
42006f21:	772226        	beqi	a2, 2, 42006f9c <scalar_abs+0x94>
42006f24:	0932f6        	bgeui	a2, 3, 42006f31 <scalar_abs+0x29>
42006f27:	129c      	beqz.n	a2, 42006f3c <scalar_abs+0x34>
42006f29:	401226        	beqi	a2, 1, 42006f6d <scalar_abs+0x65>
42006f2c:	320c      	movi.n	a2, 3
42006f2e:	002e06        	j	42006fea <scalar_abs+0xe2>
42006f31:	023266        	bnei	a2, 3, 42006f37 <scalar_abs+0x2f>
42006f34:	002186        	j	42006fbe <scalar_abs+0xb6>
42006f37:	320c      	movi.n	a2, 3
42006f39:	002b46        	j	42006fea <scalar_abs+0xe2>
        case (DTYPE_INT8):   {
            int8_t *vec1_data = (int8_t*)(vec1->data);
42006f3c:	08e8      	l32i.n	a14, a8, 0
            int8_t *result_data = (int8_t*)(result->data);
42006f3e:	03f8      	l32i.n	a15, a3, 0
            for (int i = 0; i < vec1->size; i++){
42006f40:	0a0c      	movi.n	a10, 0
42006f42:	000746        	j	42006f63 <scalar_abs+0x5b>
                int8_t val = vec1_data[i];
42006f45:	9eaa      	add.n	a9, a14, a10
42006f47:	000992        	l8ui	a9, a9, 0
                val = val == INT8_MIN ? INT8_MAX : val;
42006f4a:	23d900        	sext	a13, a9, 7
42006f4d:	80afc2        	movi	a12, -128
42006f50:	029dc7        	bne	a13, a12, 42006f56 <scalar_abs+0x4e>
42006f53:	7fa092        	movi	a9, 127
                result_data[i] = val > 0 ? val : -val;
42006f56:	bfba      	add.n	a11, a15, a11
42006f58:	239900        	sext	a9, a9, 7
42006f5b:	609190        	abs	a9, a9
42006f5e:	004b92        	s8i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006f61:	aa1b      	addi.n	a10, a10, 1
42006f63:	2898      	l32i.n	a9, a8, 8
42006f65:	0abd      	mov.n	a11, a10
42006f67:	da3a97        	bltu	a10, a9, 42006f45 <scalar_abs+0x3d>
42006f6a:	001f06        	j	42006fea <scalar_abs+0xe2>
            } 
            return VECTOR_SUCCESS;
        }
        case (DTYPE_INT16):  {
            int16_t *vec1_data = (int16_t*)(vec1->data);
42006f6d:	08e8      	l32i.n	a14, a8, 0
            int16_t *result_data = (int16_t*)(result->data);
42006f6f:	03d8      	l32i.n	a13, a3, 0
            for (int i = 0; i < vec1->size; i++){
42006f71:	090c      	movi.n	a9, 0
42006f73:	000686        	j	42006f91 <scalar_abs+0x89>
                int16_t val = vec1_data[i];
42006f76:	b99a      	add.n	a11, a9, a9
42006f78:	90a9e0        	addx2	a10, a9, a14
42006f7b:	009aa2        	l16si	a10, a10, 0
                val = val == INT16_MIN ? INT16_MAX : val;
42006f7e:	e638c1        	l32r	a12, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)
42006f81:	029ac7        	bne	a10, a12, 42006f87 <scalar_abs+0x7f>
42006f84:	e636a1        	l32r	a10, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
                result_data[i] = val > 0 ? val : -val;
42006f87:	bdba      	add.n	a11, a13, a11
42006f89:	60a1a0        	abs	a10, a10
42006f8c:	005ba2        	s16i	a10, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006f8f:	991b      	addi.n	a9, a9, 1
42006f91:	28a8      	l32i.n	a10, a8, 8
42006f93:	df39a7        	bltu	a9, a10, 42006f76 <scalar_abs+0x6e>
            } 
            return VECTOR_SUCCESS;
42006f96:	020c      	movi.n	a2, 0
42006f98:	001386        	j	42006fea <scalar_abs+0xe2>
42006f9b:	08d800        	lsx	f13, a8, a0
        }
        case (DTYPE_INT32):  {
            int32_t *vec1_data = (int32_t*)(vec1->data);
            int32_t *result_data = (int32_t*)(result->data);
42006f9e:	03c8      	l32i.n	a12, a3, 0
            for (int i = 0; i < vec1->size; i++){
42006fa0:	090c      	movi.n	a9, 0
42006fa2:	000386        	j	42006fb4 <scalar_abs+0xac>
                int32_t val = vec1_data[i];
42006fa5:	a0a9d0        	addx4	a10, a9, a13
42006fa8:	0aa8      	l32i.n	a10, a10, 0
                result_data[i] = val > 0 ? val : -val;
42006faa:	a0b9c0        	addx4	a11, a9, a12
42006fad:	60a1a0        	abs	a10, a10
42006fb0:	0ba9      	s32i.n	a10, a11, 0
            for (int i = 0; i < vec1->size; i++){
42006fb2:	991b      	addi.n	a9, a9, 1
42006fb4:	28a8      	l32i.n	a10, a8, 8
42006fb6:	eb39a7        	bltu	a9, a10, 42006fa5 <scalar_abs+0x9d>
            } 
            return VECTOR_SUCCESS;
42006fb9:	020c      	movi.n	a2, 0
42006fbb:	000ac6        	j	42006fea <scalar_abs+0xe2>
        }
        case (DTYPE_FLOAT32): { 
            int32_t* vec1_data = (int32_t*)vec1->data;
42006fbe:	08d8      	l32i.n	a13, a8, 0
            int32_t* result_data = (int32_t*)result->data;
42006fc0:	03c8      	l32i.n	a12, a3, 0
            for (int i = 0 ; i < vec1->size; i++){
42006fc2:	0a0c      	movi.n	a10, 0
42006fc4:	000446        	j	42006fd9 <scalar_abs+0xd1>
42006fc7:	9ad000        	trunc.s	a13, f0, 0
                int32_t val = vec1_data[i];
42006fca:	0998a0        	l32e	a10, a8, -28
                val = val & INT32_MAX;
42006fcd:	999a      	add.n	a9, a9, a9
42006fcf:	419190        	srli	a9, a9, 1
                result_data[i] = val;
42006fd2:	a0bac0        	addx4	a11, a10, a12
42006fd5:	0b99      	s32i.n	a9, a11, 0
            for (int i = 0 ; i < vec1->size; i++){
42006fd7:	aa1b      	addi.n	a10, a10, 1
42006fd9:	2898      	l32i.n	a9, a8, 8
42006fdb:	e93a97        	bltu	a10, a9, 42006fc8 <scalar_abs+0xc0>
            }
            return VECTOR_SUCCESS;
42006fde:	020c      	movi.n	a2, 0
42006fe0:	000186        	j	42006fea <scalar_abs+0xe2>
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42006fe3:	720c      	movi.n	a2, 7
42006fe5:	000046        	j	42006fea <scalar_abs+0xe2>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}   
42006fe8:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR;  
    }
}
42006fea:	f01d      	retw.n

42006fec <scalar_ceil>:

vector_status_t scalar_ceil(const vector_t *vec1, vector_t* result, const int ceiling){ 
42006fec:	004136        	entry	a1, 32
42006fef:	028d      	mov.n	a8, a2
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42006ff1:	22a8      	l32i.n	a10, a2, 8
42006ff3:	2398      	l32i.n	a9, a3, 8
42006ff5:	021a97        	beq	a10, a9, 42006ffb <scalar_ceil+0xf>
42006ff8:	002d86        	j	420070b2 <scalar_ceil+0xc6>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
42006ffb:	1228      	l32i.n	a2, a2, 4
42006ffd:	1398      	l32i.n	a9, a3, 4
42006fff:	021297        	beq	a2, a9, 42007005 <scalar_ceil+0x19>
42007002:	002c46        	j	420070b7 <scalar_ceil+0xcb>
    switch (vec1->type){
42007005:	022266        	bnei	a2, 2, 4200700b <scalar_ceil+0x1f>
42007008:	002106        	j	42007090 <scalar_ceil+0xa4>
4200700b:	0932f6        	bgeui	a2, 3, 42007018 <scalar_ceil+0x2c>
4200700e:	229c      	beqz.n	a2, 42007024 <scalar_ceil+0x38>
42007010:	481226        	beqi	a2, 1, 4200705c <scalar_ceil+0x70>
        }
        case (DTYPE_FLOAT32): { 
            return VECTOR_UNSUPPORTED_OPERATION;
        }
        default:        
            return VECTOR_ERROR;
42007013:	320c      	movi.n	a2, 3
42007015:	002bc6        	j	420070c8 <scalar_ceil+0xdc>
    switch (vec1->type){
42007018:	023226        	beqi	a2, 3, 4200701e <scalar_ceil+0x32>
4200701b:	002746        	j	420070bc <scalar_ceil+0xd0>
4200701e:	420c      	movi.n	a2, 4
42007020:	002906        	j	420070c8 <scalar_ceil+0xdc>
42007023:	a09200        	addx4	a9, a2, a0
            if(ceiling < INT8_MIN || ceiling > INT8_MAX) { return VECTOR_INVALID_ARGUMENT;}  
42007026:	949a80        	extui	a9, a8, 10, 10
42007029:	ffa0a2        	movi	a10, 255
4200702c:	02ba97        	bgeu	a10, a9, 42007032 <scalar_ceil+0x46>
4200702f:	002386        	j	420070c1 <scalar_ceil+0xd5>
            int8_t ceil = (int8_t)ceiling; 
42007032:	744040        	extui	a4, a4, 0, 8
            int8_t *vec1_data = (int8_t*)(vec1->data);    
42007035:	08d8      	l32i.n	a13, a8, 0
            int8_t *result_data = (int8_t*)(result->data);                                   
42007037:	03e8      	l32i.n	a14, a3, 0
            for (int i = 0; i < vec1->size; i++){
42007039:	0a0c      	movi.n	a10, 0
4200703b:	000506        	j	42007053 <scalar_ceil+0x67>
                int8_t cur_val = vec1_data[i];
4200703e:	9daa      	add.n	a9, a13, a10
42007040:	0009b2        	l8ui	a11, a9, 0
                result_data[i] = cur_val > ceil ? ceil : cur_val;
42007043:	ceaa      	add.n	a12, a14, a10
42007045:	239400        	sext	a9, a4, 7
42007048:	23bb00        	sext	a11, a11, 7
4200704b:	4399b0        	min	a9, a9, a11
4200704e:	004c92        	s8i	a9, a12, 0
            for (int i = 0; i < vec1->size; i++){
42007051:	aa1b      	addi.n	a10, a10, 1
42007053:	2898      	l32i.n	a9, a8, 8
42007055:	e53a97        	bltu	a10, a9, 4200703e <scalar_ceil+0x52>
42007058:	001b06        	j	420070c8 <scalar_ceil+0xdc>
4200705b:	00          	.byte	00
            if(ceiling < INT16_MIN || ceiling > INT16_MAX) { return VECTOR_INVALID_ARGUMENT;} 
4200705c:	e47f91        	l32r	a9, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
4200705f:	949a      	add.n	a9, a4, a9
42007061:	e602a1        	l32r	a10, 4200086c <_stext+0x84c> (ffff <UserFrameTotalSize+0xfeff>)
42007064:	5e3a97        	bltu	a10, a9, 420070c6 <scalar_ceil+0xda>
            int16_t ceil = (int16_t)ceiling; 
42007067:	234480        	sext	a4, a4, 15
            int16_t *vec1_data = (int16_t*)(vec1->data);    
4200706a:	08d8      	l32i.n	a13, a8, 0
            int16_t *result_data = (int16_t*)(result->data);                                   
4200706c:	03c8      	l32i.n	a12, a3, 0
            for (int i = 0; i < vec1->size; i++){
4200706e:	090c      	movi.n	a9, 0
42007070:	000446        	j	42007085 <scalar_ceil+0x99>
42007073:	00          	.byte	00
                int16_t cur_val = vec1_data[i];
42007074:	90a9d0        	addx2	a10, a9, a13
42007077:	009aa2        	l16si	a10, a10, 0
                result_data[i] = cur_val > ceil ? ceil : cur_val;
4200707a:	90b9c0        	addx2	a11, a9, a12
4200707d:	43a4a0        	min	a10, a4, a10
42007080:	005ba2        	s16i	a10, a11, 0
            for (int i = 0; i < vec1->size; i++){
42007083:	991b      	addi.n	a9, a9, 1
42007085:	28a8      	l32i.n	a10, a8, 8
42007087:	e939a7        	bltu	a9, a10, 42007074 <scalar_ceil+0x88>
            return VECTOR_SUCCESS;
4200708a:	020c      	movi.n	a2, 0
4200708c:	000e06        	j	420070c8 <scalar_ceil+0xdc>
4200708f:	08d800        	lsx	f13, a8, a0
            int32_t *result_data = (int32_t*)(result->data);                                   
42007092:	03c8      	l32i.n	a12, a3, 0
            for (int i = 0; i < vec1->size; i++){
42007094:	090c      	movi.n	a9, 0
42007096:	000386        	j	420070a8 <scalar_ceil+0xbc>
                int32_t cur_val = vec1_data[i];
42007099:	a0a9d0        	addx4	a10, a9, a13
4200709c:	0aa8      	l32i.n	a10, a10, 0
                result_data[i] = cur_val > ceil ? ceil : cur_val;
4200709e:	a0b9c0        	addx4	a11, a9, a12
420070a1:	43a4a0        	min	a10, a4, a10
420070a4:	0ba9      	s32i.n	a10, a11, 0
            for (int i = 0; i < vec1->size; i++){
420070a6:	991b      	addi.n	a9, a9, 1
420070a8:	28a8      	l32i.n	a10, a8, 8
420070aa:	eb39a7        	bltu	a9, a10, 42007099 <scalar_ceil+0xad>
            return VECTOR_SUCCESS;
420070ad:	020c      	movi.n	a2, 0
420070af:	000546        	j	420070c8 <scalar_ceil+0xdc>
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
420070b2:	720c      	movi.n	a2, 7
420070b4:	000406        	j	420070c8 <scalar_ceil+0xdc>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
420070b7:	820c      	movi.n	a2, 8
420070b9:	0002c6        	j	420070c8 <scalar_ceil+0xdc>
            return VECTOR_ERROR;
420070bc:	320c      	movi.n	a2, 3
420070be:	000186        	j	420070c8 <scalar_ceil+0xdc>
            if(ceiling < INT8_MIN || ceiling > INT8_MAX) { return VECTOR_INVALID_ARGUMENT;}  
420070c1:	220c      	movi.n	a2, 2
420070c3:	000046        	j	420070c8 <scalar_ceil+0xdc>
            if(ceiling < INT16_MIN || ceiling > INT16_MAX) { return VECTOR_INVALID_ARGUMENT;} 
420070c6:	220c      	movi.n	a2, 2
    }
}
420070c8:	f01d      	retw.n
	...

420070cc <vector_test_add>:
#define MAX_SIZE 256
#define TEST_RUNS 64  

// TODO: write test function dispatcher 

void vector_test_add(bool verbose, dtype type){ 
420070cc:	008136        	entry	a1, 64
420070cf:	056132        	s32i	a3, a1, 20
420070d2:	748020        	extui	a8, a2, 0, 8
420070d5:	066182        	s32i	a8, a1, 24

    timer_init();
420070d8:	ff7ce5        	call8	420068a8 <timer_init>
    set_rand_seed();
420070db:	01f1e5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420070de:	030c      	movi.n	a3, 0
420070e0:	0139      	s32i.n	a3, a1, 0
    uint32_t scalar_time = 0;
420070e2:	1139      	s32i.n	a3, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420070e4:	005cc6        	j	4200725b <vector_test_add+0x18f>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
420070e7:	e5ee81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420070ea:	0008e0        	callx8	a8
420070ed:	318fa0        	srai	a8, a10, 31
420070f0:	758880        	extui	a8, a8, 24, 8
420070f3:	6a8a      	add.n	a6, a10, a8
420070f5:	746060        	extui	a6, a6, 0, 8
420070f8:	c06680        	sub	a6, a6, a8
420070fb:	661b      	addi.n	a6, a6, 1
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors
420070fd:	5158      	l32i.n	a5, a1, 20
420070ff:	05bd      	mov.n	a11, a5
42007101:	06ad      	mov.n	a10, a6
42007103:	01f225        	call8	42009024 <create_test_vector>
42007106:	0a7d      	mov.n	a7, a10
        vector_t *vec2 = create_test_vector(test_size, type);
42007108:	05bd      	mov.n	a11, a5
4200710a:	06ad      	mov.n	a10, a6
4200710c:	01f165        	call8	42009024 <create_test_vector>
4200710f:	0a6d      	mov.n	a6, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42007111:	17b8      	l32i.n	a11, a7, 4
42007113:	27a8      	l32i.n	a10, a7, 8
42007115:	01f0e5        	call8	42009024 <create_test_vector>
42007118:	0a5d      	mov.n	a5, a10
        vector_t *scalar_result = create_test_vector(vec2->size, vec2->type); 
4200711a:	16b8      	l32i.n	a11, a6, 4
4200711c:	26a8      	l32i.n	a10, a6, 8
4200711e:	01f065        	call8	42009024 <create_test_vector>
42007121:	0a4d      	mov.n	a4, a10

        assert(vec1);                                                   // Check if valid
42007123:	f7cc      	bnez.n	a7, 42007136 <vector_test_add+0x6a>
42007125:	e5d2d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42007128:	e5d3c1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
4200712b:	eb1c      	movi.n	a11, 30
4200712d:	e5d2a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007130:	e3f681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007133:	0008e0        	callx8	a8
        assert(vec2);
        assert(simd_result);
42007136:	f5cc      	bnez.n	a5, 42007149 <vector_test_add+0x7d>
42007138:	e5d1d1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
4200713b:	e5cec1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
4200713e:	0b2c      	movi.n	a11, 32
42007140:	e5cea1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007143:	e3f181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007146:	0008e0        	callx8	a8
        assert(scalar_result);
42007149:	facc      	bnez.n	a10, 4200715c <vector_test_add+0x90>
4200714b:	e5cdd1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
4200714e:	e5c9c1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
42007151:	1b2c      	movi.n	a11, 33
42007153:	e5c9a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007156:	e3ec81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007159:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range
4200715c:	20a770        	or	a10, a7, a7
4200715f:	01f365        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2); 
42007162:	06ad      	mov.n	a10, a6
42007164:	01f2e5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs)
42007167:	17b8      	l32i.n	a11, a7, 4
42007169:	27a8      	l32i.n	a10, a7, 8
4200716b:	0228a5        	call8	420093f4 <vector_create>
4200716e:	0a2d      	mov.n	a2, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type); 
42007170:	16b8      	l32i.n	a11, a6, 4
42007172:	26a8      	l32i.n	a10, a6, 8
42007174:	0227e5        	call8	420093f4 <vector_create>
42007177:	41a9      	s32i.n	a10, a1, 16
        vec_copy(vec1, vec1_copy); 
42007179:	02bd      	mov.n	a11, a2
4200717b:	07ad      	mov.n	a10, a7
4200717d:	028765        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);  
42007180:	41b8      	l32i.n	a11, a1, 16
42007182:	06ad      	mov.n	a10, a6
42007184:	0286e5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions
42007187:	02bd      	mov.n	a11, a2
42007189:	07ad      	mov.n	a10, a7
4200718b:	020ae5        	call8	42009238 <vector_assert_eq>
4200718e:	0adc      	bnez.n	a10, 420071a2 <vector_test_add+0xd6>
42007190:	e5bdd1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42007193:	e5b8c1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
42007196:	2ba0b2        	movi	a11, 43
42007199:	e5b7a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200719c:	e3db81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200719f:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
420071a2:	41b8      	l32i.n	a11, a1, 16
420071a4:	06ad      	mov.n	a10, a6
420071a6:	020925        	call8	42009238 <vector_assert_eq>
420071a9:	0adc      	bnez.n	a10, 420071bd <vector_test_add+0xf1>
420071ab:	e5b7d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
420071ae:	e5b1c1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
420071b1:	2ca0b2        	movi	a11, 44
420071b4:	e5b1a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420071b7:	e3d481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420071ba:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
420071bd:	07ad      	mov.n	a10, a7
420071bf:	01f965        	call8	42009154 <vector_check_canary>
420071c2:	facc      	bnez.n	a10, 420071d5 <vector_test_add+0x109>
420071c4:	e5b2d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
420071c7:	e5abc1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
420071ca:	db2c      	movi.n	a11, 45
420071cc:	e5aba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420071cf:	e3ce81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420071d2:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
420071d5:	20a660        	or	a10, a6, a6
420071d8:	01f7a5        	call8	42009154 <vector_check_canary>
420071db:	011a56        	bnez	a10, 420071f0 <vector_test_add+0x124>
420071de:	e5acd1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
420071e1:	e5a4c1        	l32r	a12, 42000874 <_stext+0x854> (3c0275d8 <__func__$21>)
420071e4:	2ea0b2        	movi	a11, 46
420071e7:	e5a4a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420071ea:	e3c781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420071ed:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
420071f0:	ff6f65        	call8	420068e8 <timer_start>
        scalar_add(vec1, vec2, scalar_result);
420071f3:	04cd      	mov.n	a12, a4
420071f5:	06bd      	mov.n	a11, a6
420071f7:	07ad      	mov.n	a10, a7
420071f9:	ff7ba5        	call8	420069b4 <scalar_add>
        timer_end(&scalar_time);
420071fc:	a14b      	addi.n	a10, a1, 4
420071fe:	ff70e5        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42007201:	ff6e65        	call8	420068e8 <timer_start>
        vec_add(vec1, vec2, simd_result);
42007204:	05cd      	mov.n	a12, a5
42007206:	06bd      	mov.n	a11, a6
42007208:	07ad      	mov.n	a10, a7
4200720a:	0225e5        	call8	42009468 <vec_add>
        timer_end(&vec_time); 
4200720d:	01ad      	mov.n	a10, a1
4200720f:	ff6fe5        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42007212:	04bd      	mov.n	a11, a4
42007214:	05ad      	mov.n	a10, a5
42007216:	020225        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs
42007219:	02bd      	mov.n	a11, a2
4200721b:	07ad      	mov.n	a10, a7
4200721d:	0201a5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec2, vec2_copy);
42007220:	41b8      	l32i.n	a11, a1, 16
42007222:	06ad      	mov.n	a10, a6
42007224:	020125        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region
42007227:	07ad      	mov.n	a10, a7
42007229:	01f2a5        	call8	42009154 <vector_check_canary>
        vector_check_canary(vec2);
4200722c:	06ad      	mov.n	a10, a6
4200722e:	01f265        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42007231:	05ad      	mov.n	a10, a5
42007233:	01f225        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42007236:	04ad      	mov.n	a10, a4
42007238:	01f1a5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources
4200723b:	07ad      	mov.n	a10, a7
4200723d:	022065        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
42007240:	06ad      	mov.n	a10, a6
42007242:	022025        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
42007245:	02ad      	mov.n	a10, a2
42007247:	021fe5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy);
4200724a:	41a8      	l32i.n	a10, a1, 16
4200724c:	021f65        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
4200724f:	05ad      	mov.n	a10, a5
42007251:	021f25        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42007254:	04ad      	mov.n	a10, a4
42007256:	021ee5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42007259:	331b      	addi.n	a3, a3, 1
4200725b:	f83c      	movi.n	a8, 63
4200725d:	022837        	blt	a8, a3, 42007263 <vector_test_add+0x197>
42007260:	ffa0c6        	j	420070e7 <vector_test_add+0x1b>
    } 
    timer_deinit();
42007263:	ff7125        	call8	42006974 <timer_deinit>
    if (verbose){
42007266:	6188      	l32i.n	a8, a1, 24
42007268:	58bc      	beqz.n	a8, 420072a1 <vector_test_add+0x1d5>
            ESP_LOGI("vector_test_add", "vector_time: %d", vec_time);
4200726a:	360c      	movi.n	a6, 3
4200726c:	e37d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200726f:	0008e0        	callx8	a8
42007272:	e58871        	l32r	a7, 42000894 <_stext+0x874> (3c0240ec <_flash_rodata_start+0x3fcc>)
42007275:	01f8      	l32i.n	a15, a1, 0
42007277:	07ed      	mov.n	a14, a7
42007279:	0add      	mov.n	a13, a10
4200727b:	e587c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
4200727e:	07bd      	mov.n	a11, a7
42007280:	06ad      	mov.n	a10, a6
42007282:	e38481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007285:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_add", "scalar_time: %d", scalar_time);
42007288:	e37681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200728b:	0008e0        	callx8	a8
4200728e:	11f8      	l32i.n	a15, a1, 4
42007290:	07ed      	mov.n	a14, a7
42007292:	0add      	mov.n	a13, a10
42007294:	e582c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42007297:	07bd      	mov.n	a11, a7
42007299:	06ad      	mov.n	a10, a6
4200729b:	e37e81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200729e:	0008e0        	callx8	a8
    }
}
420072a1:	f01d      	retw.n
	...

420072a4 <vector_test_add_alias>:

void vector_test_add_alias(bool verbose, dtype type) {
420072a4:	008136        	entry	a1, 64
420072a7:	748020        	extui	a8, a2, 0, 8
420072aa:	046182        	s32i	a8, a1, 16
    timer_init();
420072ad:	ff5fa5        	call8	420068a8 <timer_init>
    set_rand_seed();
420072b0:	01d465        	call8	42008ff8 <set_rand_seed>
    uint32_t vec_time = 0;
420072b3:	00a022        	movi	a2, 0
420072b6:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0;
420072b8:	1129      	s32i.n	a2, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++) {
420072ba:	005286        	j	42007408 <vector_test_add_alias+0x164>
        int test_size = 1 + rand() % MAX_SIZE;
420072bd:	e57881        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420072c0:	0008e0        	callx8	a8
420072c3:	318fa0        	srai	a8, a10, 31
420072c6:	758880        	extui	a8, a8, 24, 8
420072c9:	7a8a      	add.n	a7, a10, a8
420072cb:	747070        	extui	a7, a7, 0, 8
420072ce:	c07780        	sub	a7, a7, a8
420072d1:	771b      	addi.n	a7, a7, 1
        vector_t *vec1 = create_test_vector(test_size, type);
420072d3:	03bd      	mov.n	a11, a3
420072d5:	07ad      	mov.n	a10, a7
420072d7:	01d4e5        	call8	42009024 <create_test_vector>
420072da:	0a6d      	mov.n	a6, a10
        vector_t *vec2 = create_test_vector(test_size, type);
420072dc:	03bd      	mov.n	a11, a3
420072de:	07ad      	mov.n	a10, a7
420072e0:	01d425        	call8	42009024 <create_test_vector>
420072e3:	0a7d      	mov.n	a7, a10

        fill_test_vector(vec1);
420072e5:	06ad      	mov.n	a10, a6
420072e7:	01dae5        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2);
420072ea:	07ad      	mov.n	a10, a7
420072ec:	01da65        	call8	42009094 <fill_test_vector>
 
        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);
420072ef:	16b8      	l32i.n	a11, a6, 4
420072f1:	26a8      	l32i.n	a10, a6, 8
420072f3:	021025        	call8	420093f4 <vector_create>
420072f6:	0a5d      	mov.n	a5, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type);
420072f8:	17b8      	l32i.n	a11, a7, 4
420072fa:	27a8      	l32i.n	a10, a7, 8
420072fc:	020f65        	call8	420093f4 <vector_create>
420072ff:	0a4d      	mov.n	a4, a10
        vec_copy(vec1, vec1_copy);
42007301:	05bd      	mov.n	a11, a5
42007303:	06ad      	mov.n	a10, a6
42007305:	026ee5        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);
42007308:	04bd      	mov.n	a11, a4
4200730a:	07ad      	mov.n	a10, a7
4200730c:	026e65        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));
4200730f:	05bd      	mov.n	a11, a5
42007311:	06ad      	mov.n	a10, a6
42007313:	01f265        	call8	42009238 <vector_assert_eq>
42007316:	0adc      	bnez.n	a10, 4200732a <vector_test_add_alias+0x86>
42007318:	e55bd1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
4200731b:	e562c1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
4200731e:	61a0b2        	movi	a11, 97
42007321:	e555a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007324:	e37981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007327:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
4200732a:	20b440        	or	a11, a4, a4
4200732d:	20a770        	or	a10, a7, a7
42007330:	01f065        	call8	42009238 <vector_assert_eq>
42007333:	011a56        	bnez	a10, 42007348 <vector_test_add_alias+0xa4>
42007336:	e554d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
42007339:	e55ac1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
4200733c:	62a0b2        	movi	a11, 98
4200733f:	e54ea1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007342:	e37181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007345:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
42007348:	06ad      	mov.n	a10, a6
4200734a:	01e0a5        	call8	42009154 <vector_check_canary>
4200734d:	0adc      	bnez.n	a10, 42007361 <vector_test_add_alias+0xbd>
4200734f:	e54fd1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42007352:	e554c1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
42007355:	63a0b2        	movi	a11, 99
42007358:	e548a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200735b:	e36b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200735e:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
42007361:	07ad      	mov.n	a10, a7
42007363:	201110        	or	a1, a1, a1
42007366:	01dee5        	call8	42009154 <vector_check_canary>
42007369:	0adc      	bnez.n	a10, 4200737d <vector_test_add_alias+0xd9>
4200736b:	e549d1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
4200736e:	e54dc1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
42007371:	64a0b2        	movi	a11, 100
42007374:	e541a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007377:	e36481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200737a:	0008e0        	callx8	a8
 
        timer_start();
4200737d:	ff56a5        	call8	420068e8 <timer_start>
        vec_add(vec1, vec2, vec1);    
42007380:	06cd      	mov.n	a12, a6
42007382:	07bd      	mov.n	a11, a7
42007384:	06ad      	mov.n	a10, a6
42007386:	020e25        	call8	42009468 <vec_add>
        timer_end(&vec_time);
42007389:	01ad      	mov.n	a10, a1
4200738b:	ff5825        	call8	4200690c <timer_end>
 
        timer_start();
4200738e:	ff55a5        	call8	420068e8 <timer_start>
        scalar_add(vec1_copy, vec2, vec2);  
42007391:	07cd      	mov.n	a12, a7
42007393:	07bd      	mov.n	a11, a7
42007395:	05ad      	mov.n	a10, a5
42007397:	ff61e5        	call8	420069b4 <scalar_add>
        timer_end(&scalar_time);
4200739a:	a14b      	addi.n	a10, a1, 4
4200739c:	ff56e5        	call8	4200690c <timer_end>
 
        assert(vector_assert_eq(vec1, vec2)); 
4200739f:	07bd      	mov.n	a11, a7
420073a1:	06ad      	mov.n	a10, a6
420073a3:	01e965        	call8	42009238 <vector_assert_eq>
420073a6:	0adc      	bnez.n	a10, 420073ba <vector_test_add_alias+0x116>
420073a8:	e540d1        	l32r	a13, 420008a8 <_stext+0x888> (3c02413c <_flash_rodata_start+0x401c>)
420073ab:	e53ec1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
420073ae:	6ea0b2        	movi	a11, 110
420073b1:	e531a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420073b4:	e35581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420073b7:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
420073ba:	06ad      	mov.n	a10, a6
420073bc:	201110        	or	a1, a1, a1
420073bf:	01d965        	call8	42009154 <vector_check_canary>
420073c2:	0adc      	bnez.n	a10, 420073d6 <vector_test_add_alias+0x132>
420073c4:	e532d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
420073c7:	e537c1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
420073ca:	6fa0b2        	movi	a11, 111
420073cd:	e52aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420073d0:	e34e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420073d3:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2)); 
420073d6:	07ad      	mov.n	a10, a7
420073d8:	201110        	or	a1, a1, a1
420073db:	01d7a5        	call8	42009154 <vector_check_canary>
420073de:	0adc      	bnez.n	a10, 420073f2 <vector_test_add_alias+0x14e>
420073e0:	e52cd1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
420073e3:	e530c1        	l32r	a12, 420008a4 <_stext+0x884> (3c02758c <__func__$16>)
420073e6:	70a0b2        	movi	a11, 112
420073e9:	e523a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420073ec:	e34781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420073ef:	0008e0        	callx8	a8
 
        vector_destroy(vec1);
420073f2:	06ad      	mov.n	a10, a6
420073f4:	0204e5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
420073f7:	07ad      	mov.n	a10, a7
420073f9:	0204a5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
420073fc:	05ad      	mov.n	a10, a5
420073fe:	020465        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy); 
42007401:	04ad      	mov.n	a10, a4
42007403:	020425        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++) {
42007406:	221b      	addi.n	a2, a2, 1
42007408:	3fa082        	movi	a8, 63
4200740b:	022827        	blt	a8, a2, 42007411 <vector_test_add_alias+0x16d>
4200740e:	ffaac6        	j	420072bd <vector_test_add_alias+0x19>
    }

    timer_deinit();
42007411:	ff5625        	call8	42006974 <timer_deinit>

    if (verbose) {
42007414:	4188      	l32i.n	a8, a1, 16
42007416:	78bc      	beqz.n	a8, 42007451 <vector_test_add_alias+0x1ad>
        ESP_LOGI("vector_test_add_alias", "vector_time: %d", vec_time);
42007418:	360c      	movi.n	a6, 3
4200741a:	e31181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200741d:	0008e0        	callx8	a8
42007420:	e52371        	l32r	a7, 420008ac <_stext+0x88c> (3c02415c <_flash_rodata_start+0x403c>)
42007423:	01f8      	l32i.n	a15, a1, 0
42007425:	07ed      	mov.n	a14, a7
42007427:	20daa0        	or	a13, a10, a10
4200742a:	e51bc1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
4200742d:	20b770        	or	a11, a7, a7
42007430:	06ad      	mov.n	a10, a6
42007432:	e31881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007435:	0008e0        	callx8	a8
        ESP_LOGI("vector_test_add_alias", "scalar_time: %d", scalar_time);
42007438:	e30a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200743b:	0008e0        	callx8	a8
4200743e:	11f8      	l32i.n	a15, a1, 4
42007440:	07ed      	mov.n	a14, a7
42007442:	0add      	mov.n	a13, a10
42007444:	e516c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42007447:	07bd      	mov.n	a11, a7
42007449:	06ad      	mov.n	a10, a6
4200744b:	e31281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200744e:	0008e0        	callx8	a8
    }
}
42007451:	f01d      	retw.n
	...

42007454 <vector_test_sub>:

void vector_test_sub(bool verbose, dtype type){  
42007454:	008136        	entry	a1, 64
42007457:	056132        	s32i	a3, a1, 20
4200745a:	748020        	extui	a8, a2, 0, 8
4200745d:	066182        	s32i	a8, a1, 24
    timer_init();
42007460:	ff4465        	call8	420068a8 <timer_init>
    set_rand_seed();
42007463:	01b965        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
42007466:	030c      	movi.n	a3, 0
42007468:	0139      	s32i.n	a3, a1, 0
    uint32_t scalar_time = 0;
4200746a:	1139      	s32i.n	a3, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
4200746c:	005f06        	j	420075ec <vector_test_sub+0x198>
4200746f:	00          	.byte	00
        int test_size = 1 + rand() % MAX_SIZE;                          // Random vector sizes 
42007470:	e50c81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007473:	0008e0        	callx8	a8
42007476:	318fa0        	srai	a8, a10, 31
42007479:	758880        	extui	a8, a8, 24, 8
4200747c:	6a8a      	add.n	a6, a10, a8
4200747e:	746060        	extui	a6, a6, 0, 8
42007481:	c06680        	sub	a6, a6, a8
42007484:	661b      	addi.n	a6, a6, 1
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors
42007486:	5158      	l32i.n	a5, a1, 20
42007488:	05bd      	mov.n	a11, a5
4200748a:	06ad      	mov.n	a10, a6
4200748c:	01b965        	call8	42009024 <create_test_vector>
4200748f:	0a7d      	mov.n	a7, a10
        vector_t *vec2 = create_test_vector(test_size, type);
42007491:	05bd      	mov.n	a11, a5
42007493:	06ad      	mov.n	a10, a6
42007495:	01b8e5        	call8	42009024 <create_test_vector>
42007498:	0a6d      	mov.n	a6, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
4200749a:	17b8      	l32i.n	a11, a7, 4
4200749c:	27a8      	l32i.n	a10, a7, 8
4200749e:	01b865        	call8	42009024 <create_test_vector>
420074a1:	0a5d      	mov.n	a5, a10
        vector_t *scalar_result = create_test_vector(vec2->size, vec2->type); 
420074a3:	16b8      	l32i.n	a11, a6, 4
420074a5:	26a8      	l32i.n	a10, a6, 8
420074a7:	01b7e5        	call8	42009024 <create_test_vector>
420074aa:	0a4d      	mov.n	a4, a10

        assert(vec1);                                                   // Check if valid
420074ac:	07dc      	bnez.n	a7, 420074c0 <vector_test_sub+0x6c>
420074ae:	e4f0d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
420074b1:	e4ffc1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
420074b4:	8ea0b2        	movi	a11, 142
420074b7:	e4f0a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420074ba:	e31381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420074bd:	0008e0        	callx8	a8
        assert(vec2);
        assert(simd_result);
420074c0:	05dc      	bnez.n	a5, 420074d4 <vector_test_sub+0x80>
420074c2:	e4eed1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
420074c5:	e4fac1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
420074c8:	90a0b2        	movi	a11, 144
420074cb:	e4eba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420074ce:	e30e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420074d1:	0008e0        	callx8	a8
        assert(scalar_result);
420074d4:	0adc      	bnez.n	a10, 420074e8 <vector_test_sub+0x94>
420074d6:	e4ead1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
420074d9:	e4f5c1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
420074dc:	91a0b2        	movi	a11, 145
420074df:	e4e6a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420074e2:	e30981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420074e5:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range
420074e8:	20a770        	or	a10, a7, a7
420074eb:	01baa5        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2); 
420074ee:	06ad      	mov.n	a10, a6
420074f0:	01ba25        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs)
420074f3:	17b8      	l32i.n	a11, a7, 4
420074f5:	27a8      	l32i.n	a10, a7, 8
420074f7:	01efe5        	call8	420093f4 <vector_create>
420074fa:	0a2d      	mov.n	a2, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type); 
420074fc:	16b8      	l32i.n	a11, a6, 4
420074fe:	26a8      	l32i.n	a10, a6, 8
42007500:	01ef25        	call8	420093f4 <vector_create>
42007503:	41a9      	s32i.n	a10, a1, 16
        vec_copy(vec1, vec1_copy); 
42007505:	02bd      	mov.n	a11, a2
42007507:	07ad      	mov.n	a10, a7
42007509:	024ea5        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);  
4200750c:	41b8      	l32i.n	a11, a1, 16
4200750e:	06ad      	mov.n	a10, a6
42007510:	024e25        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions
42007513:	02bd      	mov.n	a11, a2
42007515:	07ad      	mov.n	a10, a7
42007517:	01d225        	call8	42009238 <vector_assert_eq>
4200751a:	0adc      	bnez.n	a10, 4200752e <vector_test_sub+0xda>
4200751c:	e4dad1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
4200751f:	e4e4c1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
42007522:	9ba0b2        	movi	a11, 155
42007525:	e4d4a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007528:	e2f881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200752b:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
4200752e:	0421b2        	l32i	a11, a1, 16
42007531:	20a660        	or	a10, a6, a6
42007534:	01d025        	call8	42009238 <vector_assert_eq>
42007537:	011a56        	bnez	a10, 4200754c <vector_test_sub+0xf8>
4200753a:	e4d3d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
4200753d:	e4dcc1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
42007540:	9ca0b2        	movi	a11, 156
42007543:	e4cda1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007546:	e2f081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007549:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
4200754c:	07ad      	mov.n	a10, a7
4200754e:	01c065        	call8	42009154 <vector_check_canary>
42007551:	0adc      	bnez.n	a10, 42007565 <vector_test_sub+0x111>
42007553:	e4ced1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42007556:	e4d6c1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
42007559:	9da0b2        	movi	a11, 157
4200755c:	e4c7a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200755f:	e2ea81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007562:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
42007565:	06ad      	mov.n	a10, a6
42007567:	201110        	or	a1, a1, a1
4200756a:	01bea5        	call8	42009154 <vector_check_canary>
4200756d:	0adc      	bnez.n	a10, 42007581 <vector_test_sub+0x12d>
4200756f:	e4c8d1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
42007572:	e4cfc1        	l32r	a12, 420008b0 <_stext+0x890> (3c02757c <__func__$15>)
42007575:	9ea0b2        	movi	a11, 158
42007578:	e4c0a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200757b:	e2e381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200757e:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42007581:	ff3665        	call8	420068e8 <timer_start>
        scalar_sub(vec1, vec2, scalar_result);
42007584:	04cd      	mov.n	a12, a4
42007586:	06bd      	mov.n	a11, a6
42007588:	07ad      	mov.n	a10, a7
4200758a:	ff57a5        	call8	42006b04 <scalar_sub>
        timer_end(&scalar_time);
4200758d:	a14b      	addi.n	a10, a1, 4
4200758f:	ff37e5        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42007592:	ff3565        	call8	420068e8 <timer_start>
        vec_sub(vec1, vec2, simd_result);
42007595:	05cd      	mov.n	a12, a5
42007597:	06bd      	mov.n	a11, a6
42007599:	07ad      	mov.n	a10, a7
4200759b:	01f5e5        	call8	420094f8 <vec_sub>
        timer_end(&vec_time); 
4200759e:	01ad      	mov.n	a10, a1
420075a0:	ff36a5        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
420075a3:	04bd      	mov.n	a11, a4
420075a5:	05ad      	mov.n	a10, a5
420075a7:	01c925        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs
420075aa:	02bd      	mov.n	a11, a2
420075ac:	07ad      	mov.n	a10, a7
420075ae:	01c8a5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec2, vec2_copy);
420075b1:	41b8      	l32i.n	a11, a1, 16
420075b3:	06ad      	mov.n	a10, a6
420075b5:	01c825        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region
420075b8:	07ad      	mov.n	a10, a7
420075ba:	01b9a5        	call8	42009154 <vector_check_canary>
        vector_check_canary(vec2);
420075bd:	06ad      	mov.n	a10, a6
420075bf:	01b965        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
420075c2:	05ad      	mov.n	a10, a5
420075c4:	01b8e5        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
420075c7:	04ad      	mov.n	a10, a4
420075c9:	01b8a5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources
420075cc:	07ad      	mov.n	a10, a7
420075ce:	01e765        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
420075d1:	06ad      	mov.n	a10, a6
420075d3:	01e725        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
420075d6:	02ad      	mov.n	a10, a2
420075d8:	01e6a5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy);
420075db:	41a8      	l32i.n	a10, a1, 16
420075dd:	01e665        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
420075e0:	05ad      	mov.n	a10, a5
420075e2:	01e625        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
420075e5:	04ad      	mov.n	a10, a4
420075e7:	01e5e5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420075ea:	331b      	addi.n	a3, a3, 1
420075ec:	f83c      	movi.n	a8, 63
420075ee:	022837        	blt	a8, a3, 420075f4 <vector_test_sub+0x1a0>
420075f1:	ff9ec6        	j	42007470 <vector_test_sub+0x1c>
    } 
    timer_deinit();
420075f4:	ff37e5        	call8	42006974 <timer_deinit>
    if (verbose){
420075f7:	6188      	l32i.n	a8, a1, 24
420075f9:	58bc      	beqz.n	a8, 42007632 <vector_test_sub+0x1de>
            ESP_LOGI("vector_test_sub", "vector_time: %d", vec_time);
420075fb:	360c      	movi.n	a6, 3
420075fd:	e29881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007600:	0008e0        	callx8	a8
42007603:	e4ac71        	l32r	a7, 420008b4 <_stext+0x894> (3c024174 <_flash_rodata_start+0x4054>)
42007606:	01f8      	l32i.n	a15, a1, 0
42007608:	07ed      	mov.n	a14, a7
4200760a:	0add      	mov.n	a13, a10
4200760c:	e4a3c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
4200760f:	07bd      	mov.n	a11, a7
42007611:	06ad      	mov.n	a10, a6
42007613:	e2a081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007616:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_sub", "scalar_time: %d", scalar_time);
42007619:	e29181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200761c:	0008e0        	callx8	a8
4200761f:	11f8      	l32i.n	a15, a1, 4
42007621:	07ed      	mov.n	a14, a7
42007623:	0add      	mov.n	a13, a10
42007625:	e49dc1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42007628:	07bd      	mov.n	a11, a7
4200762a:	06ad      	mov.n	a10, a6
4200762c:	e29a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200762f:	0008e0        	callx8	a8
    }
}
42007632:	f01d      	retw.n

42007634 <vector_test_sub_alias>:

void vector_test_sub_alias(bool verbose, dtype type) {
42007634:	008136        	entry	a1, 64
42007637:	748020        	extui	a8, a2, 0, 8
4200763a:	046182        	s32i	a8, a1, 16
    timer_init();
4200763d:	ff26a5        	call8	420068a8 <timer_init>
    set_rand_seed();
42007640:	019b65        	call8	42008ff8 <set_rand_seed>
    uint32_t vec_time = 0;
42007643:	00a022        	movi	a2, 0
42007646:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0;
42007648:	1129      	s32i.n	a2, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++) {
4200764a:	005286        	j	42007798 <vector_test_sub_alias+0x164>
        int test_size = 1 + rand() % MAX_SIZE;
4200764d:	e49481        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007650:	0008e0        	callx8	a8
42007653:	318fa0        	srai	a8, a10, 31
42007656:	758880        	extui	a8, a8, 24, 8
42007659:	7a8a      	add.n	a7, a10, a8
4200765b:	747070        	extui	a7, a7, 0, 8
4200765e:	c07780        	sub	a7, a7, a8
42007661:	771b      	addi.n	a7, a7, 1
        vector_t *vec1 = create_test_vector(test_size, type);
42007663:	03bd      	mov.n	a11, a3
42007665:	07ad      	mov.n	a10, a7
42007667:	019be5        	call8	42009024 <create_test_vector>
4200766a:	0a6d      	mov.n	a6, a10
        vector_t *vec2 = create_test_vector(test_size, type);
4200766c:	03bd      	mov.n	a11, a3
4200766e:	07ad      	mov.n	a10, a7
42007670:	019b25        	call8	42009024 <create_test_vector>
42007673:	0a7d      	mov.n	a7, a10

        fill_test_vector(vec1);
42007675:	06ad      	mov.n	a10, a6
42007677:	01a1e5        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2);
4200767a:	07ad      	mov.n	a10, a7
4200767c:	01a165        	call8	42009094 <fill_test_vector>
 
        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);
4200767f:	16b8      	l32i.n	a11, a6, 4
42007681:	26a8      	l32i.n	a10, a6, 8
42007683:	01d725        	call8	420093f4 <vector_create>
42007686:	0a5d      	mov.n	a5, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type);
42007688:	17b8      	l32i.n	a11, a7, 4
4200768a:	27a8      	l32i.n	a10, a7, 8
4200768c:	01d665        	call8	420093f4 <vector_create>
4200768f:	0a4d      	mov.n	a4, a10
        vec_copy(vec1, vec1_copy);
42007691:	05bd      	mov.n	a11, a5
42007693:	06ad      	mov.n	a10, a6
42007695:	0235e5        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);
42007698:	04bd      	mov.n	a11, a4
4200769a:	07ad      	mov.n	a10, a7
4200769c:	023565        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));
4200769f:	05bd      	mov.n	a11, a5
420076a1:	06ad      	mov.n	a10, a6
420076a3:	01b965        	call8	42009238 <vector_assert_eq>
420076a6:	0adc      	bnez.n	a10, 420076ba <vector_test_sub_alias+0x86>
420076a8:	e477d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
420076ab:	e483c1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
420076ae:	d1a0b2        	movi	a11, 209
420076b1:	e471a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420076b4:	e29581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420076b7:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
420076ba:	20b440        	or	a11, a4, a4
420076bd:	20a770        	or	a10, a7, a7
420076c0:	01b765        	call8	42009238 <vector_assert_eq>
420076c3:	011a56        	bnez	a10, 420076d8 <vector_test_sub_alias+0xa4>
420076c6:	e470d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
420076c9:	e47bc1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
420076cc:	d2a0b2        	movi	a11, 210
420076cf:	e46aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420076d2:	e28d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420076d5:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
420076d8:	06ad      	mov.n	a10, a6
420076da:	01a7a5        	call8	42009154 <vector_check_canary>
420076dd:	0adc      	bnez.n	a10, 420076f1 <vector_test_sub_alias+0xbd>
420076df:	e46bd1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
420076e2:	e475c1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
420076e5:	d3a0b2        	movi	a11, 211
420076e8:	e464a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420076eb:	e28781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420076ee:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
420076f1:	07ad      	mov.n	a10, a7
420076f3:	201110        	or	a1, a1, a1
420076f6:	01a5e5        	call8	42009154 <vector_check_canary>
420076f9:	0adc      	bnez.n	a10, 4200770d <vector_test_sub_alias+0xd9>
420076fb:	e465d1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
420076fe:	e46ec1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
42007701:	d4a0b2        	movi	a11, 212
42007704:	e45da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007707:	e28081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200770a:	0008e0        	callx8	a8
 
        timer_start();
4200770d:	ff1da5        	call8	420068e8 <timer_start>
        vec_sub(vec1, vec2, vec1);    
42007710:	06cd      	mov.n	a12, a6
42007712:	07bd      	mov.n	a11, a7
42007714:	06ad      	mov.n	a10, a6
42007716:	01de25        	call8	420094f8 <vec_sub>
        timer_end(&vec_time);
42007719:	01ad      	mov.n	a10, a1
4200771b:	ff1f25        	call8	4200690c <timer_end>
 
        timer_start();
4200771e:	ff1ca5        	call8	420068e8 <timer_start>
        scalar_sub(vec1_copy, vec2, vec2);  
42007721:	07cd      	mov.n	a12, a7
42007723:	07bd      	mov.n	a11, a7
42007725:	05ad      	mov.n	a10, a5
42007727:	ff3de5        	call8	42006b04 <scalar_sub>
        timer_end(&scalar_time);
4200772a:	a14b      	addi.n	a10, a1, 4
4200772c:	ff1de5        	call8	4200690c <timer_end>
 
        assert(vector_assert_eq(vec1, vec2)); 
4200772f:	07bd      	mov.n	a11, a7
42007731:	06ad      	mov.n	a10, a6
42007733:	01b065        	call8	42009238 <vector_assert_eq>
42007736:	0adc      	bnez.n	a10, 4200774a <vector_test_sub_alias+0x116>
42007738:	e45cd1        	l32r	a13, 420008a8 <_stext+0x888> (3c02413c <_flash_rodata_start+0x401c>)
4200773b:	e45fc1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
4200773e:	dea0b2        	movi	a11, 222
42007741:	e44da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007744:	e27181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007747:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
4200774a:	06ad      	mov.n	a10, a6
4200774c:	201110        	or	a1, a1, a1
4200774f:	01a065        	call8	42009154 <vector_check_canary>
42007752:	0adc      	bnez.n	a10, 42007766 <vector_test_sub_alias+0x132>
42007754:	e44ed1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42007757:	e458c1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
4200775a:	dfa0b2        	movi	a11, 223
4200775d:	e446a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007760:	e26a81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007763:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2)); 
42007766:	07ad      	mov.n	a10, a7
42007768:	201110        	or	a1, a1, a1
4200776b:	019ea5        	call8	42009154 <vector_check_canary>
4200776e:	0adc      	bnez.n	a10, 42007782 <vector_test_sub_alias+0x14e>
42007770:	e448d1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
42007773:	e451c1        	l32r	a12, 420008b8 <_stext+0x898> (3c027564 <__func__$14>)
42007776:	e0a0b2        	movi	a11, 224
42007779:	e43fa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200777c:	e26381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200777f:	0008e0        	callx8	a8
 
        vector_destroy(vec1);
42007782:	06ad      	mov.n	a10, a6
42007784:	01cbe5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
42007787:	07ad      	mov.n	a10, a7
42007789:	01cba5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
4200778c:	05ad      	mov.n	a10, a5
4200778e:	01cb65        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy); 
42007791:	04ad      	mov.n	a10, a4
42007793:	01cb25        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++) {
42007796:	221b      	addi.n	a2, a2, 1
42007798:	3fa082        	movi	a8, 63
4200779b:	022827        	blt	a8, a2, 420077a1 <vector_test_sub_alias+0x16d>
4200779e:	ffaac6        	j	4200764d <vector_test_sub_alias+0x19>
    }

    timer_deinit();
420077a1:	ff1d25        	call8	42006974 <timer_deinit>

    if (verbose) {
420077a4:	4188      	l32i.n	a8, a1, 16
420077a6:	78bc      	beqz.n	a8, 420077e1 <vector_test_sub_alias+0x1ad>
        ESP_LOGI("vector_test_sub_alias", "vector_time: %d", vec_time);
420077a8:	360c      	movi.n	a6, 3
420077aa:	e22d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420077ad:	0008e0        	callx8	a8
420077b0:	e44371        	l32r	a7, 420008bc <_stext+0x89c> (3c024184 <_flash_rodata_start+0x4064>)
420077b3:	01f8      	l32i.n	a15, a1, 0
420077b5:	07ed      	mov.n	a14, a7
420077b7:	20daa0        	or	a13, a10, a10
420077ba:	e437c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
420077bd:	20b770        	or	a11, a7, a7
420077c0:	06ad      	mov.n	a10, a6
420077c2:	e23481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420077c5:	0008e0        	callx8	a8
        ESP_LOGI("vector_test_sub_alias", "scalar_time: %d", scalar_time);
420077c8:	e22681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420077cb:	0008e0        	callx8	a8
420077ce:	11f8      	l32i.n	a15, a1, 4
420077d0:	07ed      	mov.n	a14, a7
420077d2:	0add      	mov.n	a13, a10
420077d4:	e432c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
420077d7:	07bd      	mov.n	a11, a7
420077d9:	06ad      	mov.n	a10, a6
420077db:	e22e81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420077de:	0008e0        	callx8	a8
    }
}
420077e1:	f01d      	retw.n
	...

420077e4 <vector_test_add_scalar>:

void vector_test_add_scalar(bool verbose, dtype type){  
420077e4:	008136        	entry	a1, 64
420077e7:	748020        	extui	a8, a2, 0, 8
420077ea:	056182        	s32i	a8, a1, 20
    timer_init();
420077ed:	ff0ba5        	call8	420068a8 <timer_init>
    set_rand_seed();
420077f0:	018065        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420077f3:	00a022        	movi	a2, 0
420077f6:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0;
420077f8:	1129      	s32i.n	a2, a1, 4
    
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420077fa:	005a86        	j	42007968 <vector_test_add_scalar+0x184>
        int rand_scalar; 
        switch (type) {
420077fd:	438c      	beqz.n	a3, 42007805 <vector_test_add_scalar+0x21>
420077ff:	1e1326        	beqi	a3, 1, 42007821 <vector_test_add_scalar+0x3d>
42007802:	000dc6        	j	4200783d <vector_test_add_scalar+0x59>
            case DTYPE_INT8:   rand_scalar = (rand() % 256) - 128;      break;
42007805:	e42681        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007808:	0008e0        	callx8	a8
4200780b:	318fa0        	srai	a8, a10, 31
4200780e:	758880        	extui	a8, a8, 24, 8
42007811:	aa8a      	add.n	a10, a10, a8
42007813:	74a0a0        	extui	a10, a10, 0, 8
42007816:	c0aa80        	sub	a10, a10, a8
42007819:	80ca82        	addi	a8, a10, -128
4200781c:	4189      	s32i.n	a8, a1, 16
4200781e:	000906        	j	42007846 <vector_test_add_scalar+0x62>
            case DTYPE_INT16:  rand_scalar = (rand() % 65536) - 32768;  break;
42007821:	e41f81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007824:	0008e0        	callx8	a8
42007827:	318fa0        	srai	a8, a10, 31
4200782a:	f58080        	extui	a8, a8, 16, 16
4200782d:	aa8a      	add.n	a10, a10, a8
4200782f:	f4a0a0        	extui	a10, a10, 0, 16
42007832:	c0aa80        	sub	a10, a10, a8
42007835:	80da82        	addmi	a8, a10, 0xffff8000
42007838:	4189      	s32i.n	a8, a1, 16
4200783a:	000206        	j	42007846 <vector_test_add_scalar+0x62>
            default:           rand_scalar = rand();                    break;
4200783d:	e41881        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007840:	0008e0        	callx8	a8
42007843:	0461a2        	s32i	a10, a1, 16
        }
        int test_size = 1 + rand() % MAX_SIZE;                          // Random vector sizes 
42007846:	e41681        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007849:	0008e0        	callx8	a8
4200784c:	318fa0        	srai	a8, a10, 31
4200784f:	758880        	extui	a8, a8, 24, 8
42007852:	80aa80        	add	a10, a10, a8
42007855:	74a0a0        	extui	a10, a10, 0, 8
42007858:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors 
4200785b:	03bd      	mov.n	a11, a3
4200785d:	aa1b      	addi.n	a10, a10, 1
4200785f:	017c65        	call8	42009024 <create_test_vector>
42007862:	0a7d      	mov.n	a7, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42007864:	1ab8      	l32i.n	a11, a10, 4
42007866:	2aa8      	l32i.n	a10, a10, 8
42007868:	017ba5        	call8	42009024 <create_test_vector>
4200786b:	0a6d      	mov.n	a6, a10
        vector_t *scalar_result = create_test_vector(vec1->size, vec1->type); 
4200786d:	17b8      	l32i.n	a11, a7, 4
4200786f:	27a8      	l32i.n	a10, a7, 8
42007871:	017b25        	call8	42009024 <create_test_vector>
42007874:	0a5d      	mov.n	a5, a10

        assert(vec1);                                                   // Check if valid 
42007876:	07dc      	bnez.n	a7, 4200788a <vector_test_add_scalar+0xa6>
42007878:	e3fed1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
4200787b:	e411c1        	l32r	a12, 420008c0 <_stext+0x8a0> (3c02754c <__func__$13>)
4200787e:	03a1b2        	movi	a11, 0x103
42007881:	e3fda1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007884:	e22181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007887:	0008e0        	callx8	a8
        assert(simd_result);
4200788a:	06dc      	bnez.n	a6, 4200789e <vector_test_add_scalar+0xba>
4200788c:	e3fcd1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
4200788f:	e40cc1        	l32r	a12, 420008c0 <_stext+0x8a0> (3c02754c <__func__$13>)
42007892:	04a1b2        	movi	a11, 0x104
42007895:	e3f8a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007898:	e21c81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200789b:	0008e0        	callx8	a8
        assert(scalar_result);
4200789e:	0adc      	bnez.n	a10, 420078b2 <vector_test_add_scalar+0xce>
420078a0:	e3f8d1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
420078a3:	e407c1        	l32r	a12, 420008c0 <_stext+0x8a0> (3c02754c <__func__$13>)
420078a6:	05a1b2        	movi	a11, 0x105
420078a9:	e3f3a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420078ac:	e21781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420078af:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
420078b2:	20a770        	or	a10, a7, a7
420078b5:	017de5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
420078b8:	0127b2        	l32i	a11, a7, 4
420078bb:	27a8      	l32i.n	a10, a7, 8
420078bd:	01b365        	call8	420093f4 <vector_create>
420078c0:	0a4d      	mov.n	a4, a10
        assert(vec1_copy);
420078c2:	0adc      	bnez.n	a10, 420078d6 <vector_test_add_scalar+0xf2>
420078c4:	e400d1        	l32r	a13, 420008c4 <_stext+0x8a4> (3c02419c <_flash_rodata_start+0x407c>)
420078c7:	e3fec1        	l32r	a12, 420008c0 <_stext+0x8a0> (3c02754c <__func__$13>)
420078ca:	0aa1b2        	movi	a11, 0x10a
420078cd:	e3eaa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420078d0:	e20e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420078d3:	0008e0        	callx8	a8
        vec_copy(vec1, vec1_copy);  
420078d6:	20baa0        	or	a11, a10, a10
420078d9:	20a770        	or	a10, a7, a7
420078dc:	021165        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
420078df:	04bd      	mov.n	a11, a4
420078e1:	07ad      	mov.n	a10, a7
420078e3:	019565        	call8	42009238 <vector_assert_eq>
420078e6:	0adc      	bnez.n	a10, 420078fa <vector_test_add_scalar+0x116>
420078e8:	e3e7d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
420078eb:	e3f5c1        	l32r	a12, 420008c0 <_stext+0x8a0> (3c02754c <__func__$13>)
420078ee:	0da1b2        	movi	a11, 0x10d
420078f1:	e3e1a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420078f4:	e20581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420078f7:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
420078fa:	07ad      	mov.n	a10, a7
420078fc:	018565        	call8	42009154 <vector_check_canary>
420078ff:	0adc      	bnez.n	a10, 42007913 <vector_test_add_scalar+0x12f>
42007901:	e3e2d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42007904:	e3efc1        	l32r	a12, 420008c0 <_stext+0x8a0> (3c02754c <__func__$13>)
42007907:	0ea1b2        	movi	a11, 0x10e
4200790a:	e3dba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200790d:	e1fe81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007910:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42007913:	fefd65        	call8	420068e8 <timer_start>
        scalar_add_scalar(vec1, rand_scalar, scalar_result);
42007916:	05cd      	mov.n	a12, a5
42007918:	41b8      	l32i.n	a11, a1, 16
4200791a:	07ad      	mov.n	a10, a7
4200791c:	ff3365        	call8	42006c54 <scalar_add_scalar>
        timer_end(&scalar_time);
4200791f:	a14b      	addi.n	a10, a1, 4
42007921:	fefea5        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42007924:	fefc25        	call8	420068e8 <timer_start>
        vec_add_scalar(vec1, rand_scalar, simd_result);
42007927:	06cd      	mov.n	a12, a6
42007929:	41b8      	l32i.n	a11, a1, 16
4200792b:	07ad      	mov.n	a10, a7
4200792d:	01c5a5        	call8	42009588 <vec_add_scalar>
        timer_end(&vec_time); 
42007930:	01ad      	mov.n	a10, a1
42007932:	fefda5        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42007935:	05bd      	mov.n	a11, a5
42007937:	06ad      	mov.n	a10, a6
42007939:	018fe5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs 
4200793c:	04bd      	mov.n	a11, a4
4200793e:	07ad      	mov.n	a10, a7
42007940:	018f65        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region 
42007943:	07ad      	mov.n	a10, a7
42007945:	0180e5        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42007948:	06ad      	mov.n	a10, a6
4200794a:	0180a5        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
4200794d:	05ad      	mov.n	a10, a5
4200794f:	018065        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
42007952:	07ad      	mov.n	a10, a7
42007954:	01aee5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
42007957:	04ad      	mov.n	a10, a4
42007959:	01aea5        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
4200795c:	06ad      	mov.n	a10, a6
4200795e:	01ae65        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42007961:	05ad      	mov.n	a10, a5
42007963:	01ae25        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42007966:	221b      	addi.n	a2, a2, 1
42007968:	3fa082        	movi	a8, 63
4200796b:	022827        	blt	a8, a2, 42007971 <vector_test_add_scalar+0x18d>
4200796e:	ffa2c6        	j	420077fd <vector_test_add_scalar+0x19>
    } 
    timer_deinit();
42007971:	ff0025        	call8	42006974 <timer_deinit>
    if (verbose){
42007974:	5188      	l32i.n	a8, a1, 20
42007976:	78bc      	beqz.n	a8, 420079b1 <vector_test_add_scalar+0x1cd>
            ESP_LOGI("vector_test_add_scalar", "vector_time: %d", vec_time);
42007978:	360c      	movi.n	a6, 3
4200797a:	e1b981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200797d:	0008e0        	callx8	a8
42007980:	e3d271        	l32r	a7, 420008c8 <_stext+0x8a8> (3c0241a8 <_flash_rodata_start+0x4088>)
42007983:	01f8      	l32i.n	a15, a1, 0
42007985:	07ed      	mov.n	a14, a7
42007987:	20daa0        	or	a13, a10, a10
4200798a:	e3c3c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
4200798d:	20b770        	or	a11, a7, a7
42007990:	06ad      	mov.n	a10, a6
42007992:	e1c081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007995:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_add_scalar", "scalar_time: %d", scalar_time);
42007998:	e1b281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200799b:	0008e0        	callx8	a8
4200799e:	11f8      	l32i.n	a15, a1, 4
420079a0:	07ed      	mov.n	a14, a7
420079a2:	0add      	mov.n	a13, a10
420079a4:	e3bec1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
420079a7:	07bd      	mov.n	a11, a7
420079a9:	06ad      	mov.n	a10, a6
420079ab:	e1ba81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420079ae:	0008e0        	callx8	a8
    }
}
420079b1:	f01d      	retw.n
	...

420079b4 <vector_test_add_scalar_f32>:

void vector_test_add_scalar_f32(bool verbose, dtype type){ 
420079b4:	008136        	entry	a1, 64
420079b7:	046132        	s32i	a3, a1, 16
420079ba:	748020        	extui	a8, a2, 0, 8
420079bd:	5189      	s32i.n	a8, a1, 20
    assert(type == DTYPE_FLOAT32);
420079bf:	113326        	beqi	a3, 3, 420079d4 <vector_test_add_scalar_f32+0x20>
420079c2:	e3c2d1        	l32r	a13, 420008cc <_stext+0x8ac> (3c0241c0 <_flash_rodata_start+0x40a0>)
420079c5:	e3c2c1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
420079c8:	2ba1b2        	movi	a11, 0x12b
420079cb:	e3aba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420079ce:	e1ce81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420079d1:	0008e0        	callx8	a8
    timer_init();
420079d4:	feed25        	call8	420068a8 <timer_init>
    set_rand_seed();
420079d7:	016225        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420079da:	00a032        	movi	a3, 0
420079dd:	006132        	s32i	a3, a1, 0
    uint32_t scalar_time = 0;
420079e0:	1139      	s32i.n	a3, a1, 4
    
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420079e2:	004986        	j	42007b0c <vector_test_add_scalar_f32+0x158>
        float rand_scalar = rand_float_val();  
420079e5:	018125        	call8	420091f8 <rand_float_val>
420079e8:	202aa0        	or	a2, a10, a10
        int test_size = 1 + rand() % MAX_SIZE;                          // Random vector sizes 
420079eb:	e3ad81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420079ee:	0008e0        	callx8	a8
420079f1:	318fa0        	srai	a8, a10, 31
420079f4:	758880        	extui	a8, a8, 24, 8
420079f7:	aa8a      	add.n	a10, a10, a8
420079f9:	74a0a0        	extui	a10, a10, 0, 8
420079fc:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors 
420079ff:	41b8      	l32i.n	a11, a1, 16
42007a01:	aa1b      	addi.n	a10, a10, 1
42007a03:	016225        	call8	42009024 <create_test_vector>
42007a06:	0a7d      	mov.n	a7, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42007a08:	1ab8      	l32i.n	a11, a10, 4
42007a0a:	2aa8      	l32i.n	a10, a10, 8
42007a0c:	016165        	call8	42009024 <create_test_vector>
42007a0f:	0a6d      	mov.n	a6, a10
        vector_t *scalar_result = create_test_vector(vec1->size, vec1->type); 
42007a11:	17b8      	l32i.n	a11, a7, 4
42007a13:	27a8      	l32i.n	a10, a7, 8
42007a15:	0160e5        	call8	42009024 <create_test_vector>
42007a18:	0a5d      	mov.n	a5, a10

        assert(vec1);                                                   // Check if valid 
42007a1a:	07dc      	bnez.n	a7, 42007a2e <vector_test_add_scalar_f32+0x7a>
42007a1c:	e395d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42007a1f:	e3acc1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
42007a22:	39a1b2        	movi	a11, 0x139
42007a25:	e394a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007a28:	e1b881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007a2b:	0008e0        	callx8	a8
        assert(simd_result);
42007a2e:	06dc      	bnez.n	a6, 42007a42 <vector_test_add_scalar_f32+0x8e>
42007a30:	e393d1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
42007a33:	e3a7c1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
42007a36:	3aa1b2        	movi	a11, 0x13a
42007a39:	e38fa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007a3c:	e1b381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007a3f:	0008e0        	callx8	a8
        assert(scalar_result);
42007a42:	0adc      	bnez.n	a10, 42007a56 <vector_test_add_scalar_f32+0xa2>
42007a44:	e38fd1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
42007a47:	e3a2c1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
42007a4a:	3ba1b2        	movi	a11, 0x13b
42007a4d:	e38aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007a50:	e1ae81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007a53:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
42007a56:	20a770        	or	a10, a7, a7
42007a59:	0163a5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
42007a5c:	0127b2        	l32i	a11, a7, 4
42007a5f:	27a8      	l32i.n	a10, a7, 8
42007a61:	019925        	call8	420093f4 <vector_create>
42007a64:	0a4d      	mov.n	a4, a10
        assert(vec1_copy);
42007a66:	0adc      	bnez.n	a10, 42007a7a <vector_test_add_scalar_f32+0xc6>
42007a68:	e397d1        	l32r	a13, 420008c4 <_stext+0x8a4> (3c02419c <_flash_rodata_start+0x407c>)
42007a6b:	e399c1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
42007a6e:	40a1b2        	movi	a11, 0x140
42007a71:	e381a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007a74:	e1a581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007a77:	0008e0        	callx8	a8
        vec_copy(vec1, vec1_copy);  
42007a7a:	20baa0        	or	a11, a10, a10
42007a7d:	20a770        	or	a10, a7, a7
42007a80:	01f725        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
42007a83:	04bd      	mov.n	a11, a4
42007a85:	07ad      	mov.n	a10, a7
42007a87:	017b25        	call8	42009238 <vector_assert_eq>
42007a8a:	0adc      	bnez.n	a10, 42007a9e <vector_test_add_scalar_f32+0xea>
42007a8c:	e37ed1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42007a8f:	e390c1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
42007a92:	43a1b2        	movi	a11, 0x143
42007a95:	e378a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007a98:	e19c81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007a9b:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
42007a9e:	07ad      	mov.n	a10, a7
42007aa0:	016b25        	call8	42009154 <vector_check_canary>
42007aa3:	0adc      	bnez.n	a10, 42007ab7 <vector_test_add_scalar_f32+0x103>
42007aa5:	e379d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42007aa8:	e38ac1        	l32r	a12, 420008d0 <_stext+0x8b0> (3c027530 <__func__$12>)
42007aab:	44a1b2        	movi	a11, 0x144
42007aae:	e372a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007ab1:	e19581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007ab4:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42007ab7:	fee325        	call8	420068e8 <timer_start>
        scalar_add_scalar_f32(vec1, rand_scalar, scalar_result);
42007aba:	05cd      	mov.n	a12, a5
42007abc:	02bd      	mov.n	a11, a2
42007abe:	07ad      	mov.n	a10, a7
42007ac0:	0ebb65        	call8	42016678 <scalar_add_scalar_f32>
        timer_end(&scalar_time);
42007ac3:	a14b      	addi.n	a10, a1, 4
42007ac5:	fee465        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42007ac8:	fee1e5        	call8	420068e8 <timer_start>
        vec_add_scalar_f32(vec1, rand_scalar, simd_result);
42007acb:	06cd      	mov.n	a12, a6
42007acd:	02bd      	mov.n	a11, a2
42007acf:	07ad      	mov.n	a10, a7
42007ad1:	01b4a5        	call8	4200961c <vec_add_scalar_f32>
        timer_end(&vec_time); 
42007ad4:	01ad      	mov.n	a10, a1
42007ad6:	fee365        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42007ad9:	05bd      	mov.n	a11, a5
42007adb:	06ad      	mov.n	a10, a6
42007add:	0175a5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs 
42007ae0:	04bd      	mov.n	a11, a4
42007ae2:	07ad      	mov.n	a10, a7
42007ae4:	017525        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region 
42007ae7:	07ad      	mov.n	a10, a7
42007ae9:	0166a5        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42007aec:	06ad      	mov.n	a10, a6
42007aee:	016665        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42007af1:	05ad      	mov.n	a10, a5
42007af3:	016625        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
42007af6:	07ad      	mov.n	a10, a7
42007af8:	0194a5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
42007afb:	04ad      	mov.n	a10, a4
42007afd:	019465        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
42007b00:	06ad      	mov.n	a10, a6
42007b02:	019425        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42007b05:	05ad      	mov.n	a10, a5
42007b07:	0193e5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42007b0a:	331b      	addi.n	a3, a3, 1
42007b0c:	3fa082        	movi	a8, 63
42007b0f:	022837        	blt	a8, a3, 42007b15 <vector_test_add_scalar_f32+0x161>
42007b12:	ffb3c6        	j	420079e5 <vector_test_add_scalar_f32+0x31>
    } 
    timer_deinit();
42007b15:	fee5e5        	call8	42006974 <timer_deinit>
    if (verbose){
42007b18:	5188      	l32i.n	a8, a1, 20
42007b1a:	78bc      	beqz.n	a8, 42007b55 <vector_test_add_scalar_f32+0x1a1>
            ESP_LOGI("vector_test_add_scalar", "vector_time: %d", vec_time);
42007b1c:	360c      	movi.n	a6, 3
42007b1e:	e15081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007b21:	0008e0        	callx8	a8
42007b24:	e36971        	l32r	a7, 420008c8 <_stext+0x8a8> (3c0241a8 <_flash_rodata_start+0x4088>)
42007b27:	01f8      	l32i.n	a15, a1, 0
42007b29:	07ed      	mov.n	a14, a7
42007b2b:	20daa0        	or	a13, a10, a10
42007b2e:	e35ac1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42007b31:	20b770        	or	a11, a7, a7
42007b34:	06ad      	mov.n	a10, a6
42007b36:	e15781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007b39:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_add_scalar", "scalar_time: %d", scalar_time);
42007b3c:	e14981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007b3f:	0008e0        	callx8	a8
42007b42:	11f8      	l32i.n	a15, a1, 4
42007b44:	07ed      	mov.n	a14, a7
42007b46:	0add      	mov.n	a13, a10
42007b48:	e355c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42007b4b:	07bd      	mov.n	a11, a7
42007b4d:	06ad      	mov.n	a10, a6
42007b4f:	e15181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007b52:	0008e0        	callx8	a8
    }
}
42007b55:	f01d      	retw.n
	...

42007b58 <vector_test_add_scalar_alias>:
 
void vector_test_add_scalar_alias(bool verbose, dtype type) {
42007b58:	006136        	entry	a1, 48
42007b5b:	742020        	extui	a2, a2, 0, 8
    timer_init();
42007b5e:	fed4a5        	call8	420068a8 <timer_init>
    set_rand_seed();
42007b61:	014965        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;     
42007b64:	00a052        	movi	a5, 0
42007b67:	006152        	s32i	a5, a1, 0
    uint32_t scalar_time = 0;
42007b6a:	1159      	s32i.n	a5, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++) { 
42007b6c:	004cc6        	j	42007ca3 <vector_test_add_scalar_alias+0x14b>
42007b6f:	438c00        	min	a8, a12, a0
        int rand_scalar;
        switch (type) {
42007b72:	1e1326        	beqi	a3, 1, 42007b94 <vector_test_add_scalar_alias+0x3c>
42007b75:	000d46        	j	42007bae <vector_test_add_scalar_alias+0x56>
            case DTYPE_INT8:   rand_scalar = (rand() % 256) - 128;      break;
42007b78:	e34a81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007b7b:	0008e0        	callx8	a8
42007b7e:	318fa0        	srai	a8, a10, 31
42007b81:	758880        	extui	a8, a8, 24, 8
42007b84:	6a8a      	add.n	a6, a10, a8
42007b86:	746060        	extui	a6, a6, 0, 8
42007b89:	c06680        	sub	a6, a6, a8
42007b8c:	80c662        	addi	a6, a6, -128
42007b8f:	0008c6        	j	42007bb6 <vector_test_add_scalar_alias+0x5e>
42007b92:	810000        	src	a0, a0, a0
            case DTYPE_INT16:  rand_scalar = (rand() % 65536) - 32768;  break;
42007b95:	43          	.byte	0x43
42007b96:	e3          	.byte	0xe3
42007b97:	0008e0        	callx8	a8
42007b9a:	318fa0        	srai	a8, a10, 31
42007b9d:	f58080        	extui	a8, a8, 16, 16
42007ba0:	6a8a      	add.n	a6, a10, a8
42007ba2:	f46060        	extui	a6, a6, 0, 16
42007ba5:	c06680        	sub	a6, a6, a8
42007ba8:	80d662        	addmi	a6, a6, 0xffff8000
42007bab:	0001c6        	j	42007bb6 <vector_test_add_scalar_alias+0x5e>
            default:           rand_scalar = rand();                    break;
42007bae:	e33c81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007bb1:	0008e0        	callx8	a8
42007bb4:	0a6d      	mov.n	a6, a10
        }
 
        int test_size = 1 + rand() % MAX_SIZE;
42007bb6:	e33a81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007bb9:	0008e0        	callx8	a8
42007bbc:	318fa0        	srai	a8, a10, 31
42007bbf:	758880        	extui	a8, a8, 24, 8
42007bc2:	aa8a      	add.n	a10, a10, a8
42007bc4:	74a0a0        	extui	a10, a10, 0, 8
42007bc7:	c0aa80        	sub	a10, a10, a8
 
        vector_t *vec_in = create_test_vector(test_size, type);
42007bca:	03bd      	mov.n	a11, a3
42007bcc:	01caa2        	addi	a10, a10, 1
42007bcf:	014565        	call8	42009024 <create_test_vector>
42007bd2:	0a7d      	mov.n	a7, a10
        assert(vec_in);
42007bd4:	0adc      	bnez.n	a10, 42007be8 <vector_test_add_scalar_alias+0x90>
42007bd6:	e33fd1        	l32r	a13, 420008d4 <_stext+0x8b4> (3c0241d8 <_flash_rodata_start+0x40b8>)
42007bd9:	e33fc1        	l32r	a12, 420008d8 <_stext+0x8b8> (3c027510 <__func__$11>)
42007bdc:	72a1b2        	movi	a11, 0x172
42007bdf:	e326a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007be2:	e14981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007be5:	0008e0        	callx8	a8
        fill_test_vector(vec_in);
42007be8:	014aa5        	call8	42009094 <fill_test_vector>
 
        vector_t *expected = create_test_vector(vec_in->size, vec_in->type);
42007beb:	0127b2        	l32i	a11, a7, 4
42007bee:	0227a2        	l32i	a10, a7, 8
42007bf1:	014325        	call8	42009024 <create_test_vector>
42007bf4:	0a4d      	mov.n	a4, a10
        assert(expected);
42007bf6:	0adc      	bnez.n	a10, 42007c0a <vector_test_add_scalar_alias+0xb2>
42007bf8:	e339d1        	l32r	a13, 420008dc <_stext+0x8bc> (3c0241e0 <_flash_rodata_start+0x40c0>)
42007bfb:	e337c1        	l32r	a12, 420008d8 <_stext+0x8b8> (3c027510 <__func__$11>)
42007bfe:	76a1b2        	movi	a11, 0x176
42007c01:	e31da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007c04:	e14181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007c07:	0008e0        	callx8	a8
        vec_copy(vec_in, expected);
42007c0a:	20baa0        	or	a11, a10, a10
42007c0d:	20a770        	or	a10, a7, a7
42007c10:	01de25        	call8	420099f4 <vec_copy>
 
        assert(vector_assert_eq(vec_in, expected));
42007c13:	04bd      	mov.n	a11, a4
42007c15:	07ad      	mov.n	a10, a7
42007c17:	016225        	call8	42009238 <vector_assert_eq>
42007c1a:	0adc      	bnez.n	a10, 42007c2e <vector_test_add_scalar_alias+0xd6>
42007c1c:	e331d1        	l32r	a13, 420008e0 <_stext+0x8c0> (3c0241ec <_flash_rodata_start+0x40cc>)
42007c1f:	e32ec1        	l32r	a12, 420008d8 <_stext+0x8b8> (3c027510 <__func__$11>)
42007c22:	79a1b2        	movi	a11, 0x179
42007c25:	e314a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007c28:	e13881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007c2b:	0008e0        	callx8	a8
        assert(vector_check_canary(vec_in));
42007c2e:	07ad      	mov.n	a10, a7
42007c30:	201110        	or	a1, a1, a1
42007c33:	015225        	call8	42009154 <vector_check_canary>
42007c36:	0adc      	bnez.n	a10, 42007c4a <vector_test_add_scalar_alias+0xf2>
42007c38:	e32bd1        	l32r	a13, 420008e4 <_stext+0x8c4> (3c024210 <_flash_rodata_start+0x40f0>)
42007c3b:	e327c1        	l32r	a12, 420008d8 <_stext+0x8b8> (3c027510 <__func__$11>)
42007c3e:	7aa1b2        	movi	a11, 0x17a
42007c41:	e30da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007c44:	e13181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007c47:	0008e0        	callx8	a8
        assert(vector_check_canary(expected));
42007c4a:	04ad      	mov.n	a10, a4
42007c4c:	015065        	call8	42009154 <vector_check_canary>
42007c4f:	0adc      	bnez.n	a10, 42007c63 <vector_test_add_scalar_alias+0x10b>
42007c51:	e325d1        	l32r	a13, 420008e8 <_stext+0x8c8> (3c02422c <_flash_rodata_start+0x410c>)
42007c54:	e321c1        	l32r	a12, 420008d8 <_stext+0x8b8> (3c027510 <__func__$11>)
42007c57:	7ba1b2        	movi	a11, 0x17b
42007c5a:	e307a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007c5d:	e12a81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007c60:	0008e0        	callx8	a8
 
        timer_start();
42007c63:	fec865        	call8	420068e8 <timer_start>
        scalar_add_scalar(expected, rand_scalar, expected);
42007c66:	04cd      	mov.n	a12, a4
42007c68:	06bd      	mov.n	a11, a6
42007c6a:	04ad      	mov.n	a10, a4
42007c6c:	fefe65        	call8	42006c54 <scalar_add_scalar>
        timer_end(&scalar_time);
42007c6f:	a14b      	addi.n	a10, a1, 4
42007c71:	fec9a5        	call8	4200690c <timer_end>
 
        timer_start();
42007c74:	fec725        	call8	420068e8 <timer_start>
        vec_add_scalar(vec_in, rand_scalar, vec_in);
42007c77:	07cd      	mov.n	a12, a7
42007c79:	06bd      	mov.n	a11, a6
42007c7b:	07ad      	mov.n	a10, a7
42007c7d:	0190a5        	call8	42009588 <vec_add_scalar>
        timer_end(&vec_time);
42007c80:	01ad      	mov.n	a10, a1
42007c82:	fec8a5        	call8	4200690c <timer_end>
 
        vector_assert_eq(vec_in, expected);
42007c85:	04bd      	mov.n	a11, a4
42007c87:	20a770        	or	a10, a7, a7
42007c8a:	015ae5        	call8	42009238 <vector_assert_eq>
 
        vector_check_canary(vec_in);
42007c8d:	07ad      	mov.n	a10, a7
42007c8f:	014c65        	call8	42009154 <vector_check_canary>
        vector_check_canary(expected);
42007c92:	04ad      	mov.n	a10, a4
42007c94:	014be5        	call8	42009154 <vector_check_canary>
 
        vector_destroy(vec_in);
42007c97:	07ad      	mov.n	a10, a7
42007c99:	017aa5        	call8	42009444 <vector_destroy>
        vector_destroy(expected);
42007c9c:	04ad      	mov.n	a10, a4
42007c9e:	017a65        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++) { 
42007ca1:	551b      	addi.n	a5, a5, 1
42007ca3:	f83c      	movi.n	a8, 63
42007ca5:	022857        	blt	a8, a5, 42007cab <vector_test_add_scalar_alias+0x153>
42007ca8:	ffb106        	j	42007b70 <vector_test_add_scalar_alias+0x18>
    }

    timer_deinit();
42007cab:	fecca5        	call8	42006974 <timer_deinit>

    if (verbose) {
42007cae:	72bc      	beqz.n	a2, 42007ce9 <vector_test_add_scalar_alias+0x191>
        ESP_LOGI("vector_test_add_scalar_aliasing", "vec_time: %u", vec_time);
42007cb0:	360c      	movi.n	a6, 3
42007cb2:	e0eb81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007cb5:	0008e0        	callx8	a8
42007cb8:	e30d71        	l32r	a7, 420008ec <_stext+0x8cc> (3c02424c <_flash_rodata_start+0x412c>)
42007cbb:	01f8      	l32i.n	a15, a1, 0
42007cbd:	07ed      	mov.n	a14, a7
42007cbf:	20daa0        	or	a13, a10, a10
42007cc2:	e30bc1        	l32r	a12, 420008f0 <_stext+0x8d0> (3c02426c <_flash_rodata_start+0x414c>)
42007cc5:	20b770        	or	a11, a7, a7
42007cc8:	06ad      	mov.n	a10, a6
42007cca:	e0f281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007ccd:	0008e0        	callx8	a8
        ESP_LOGI("vector_test_add_scalar_aliasing", "scalar_time: %u", scalar_time);
42007cd0:	e0e481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007cd3:	0008e0        	callx8	a8
42007cd6:	11f8      	l32i.n	a15, a1, 4
42007cd8:	07ed      	mov.n	a14, a7
42007cda:	0add      	mov.n	a13, a10
42007cdc:	e306c1        	l32r	a12, 420008f4 <_stext+0x8d4> (3c024288 <_flash_rodata_start+0x4168>)
42007cdf:	07bd      	mov.n	a11, a7
42007ce1:	06ad      	mov.n	a10, a6
42007ce3:	e0ec81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007ce6:	0008e0        	callx8	a8
    }
}
42007ce9:	f01d      	retw.n
	...

42007cec <vector_test_add_scalar_f32_alias>:
 
void vector_test_add_scalar_f32_alias(bool verbose, dtype type) {
42007cec:	006136        	entry	a1, 48
42007cef:	742020        	extui	a2, a2, 0, 8
    timer_init();
42007cf2:	febb65        	call8	420068a8 <timer_init>
    set_rand_seed();
42007cf5:	013025        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;     
42007cf8:	00a062        	movi	a6, 0
42007cfb:	006162        	s32i	a6, a1, 0
    uint32_t scalar_time = 0;
42007cfe:	1169      	s32i.n	a6, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++) { 
42007d00:	003cc6        	j	42007df7 <vector_test_add_scalar_f32_alias+0x10b>
42007d03:	00          	.byte	00
        float rand_scalar = rand_float_val();
42007d04:	014f25        	call8	420091f8 <rand_float_val>
42007d07:	205aa0        	or	a5, a10, a10
 
        int test_size = 1 + rand() % MAX_SIZE;
42007d0a:	e2e581        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007d0d:	0008e0        	callx8	a8
42007d10:	318fa0        	srai	a8, a10, 31
42007d13:	758880        	extui	a8, a8, 24, 8
42007d16:	80aa80        	add	a10, a10, a8
42007d19:	74a0a0        	extui	a10, a10, 0, 8
42007d1c:	c0aa80        	sub	a10, a10, a8
 
        vector_t *vec_in = create_test_vector(test_size, type);
42007d1f:	03bd      	mov.n	a11, a3
42007d21:	aa1b      	addi.n	a10, a10, 1
42007d23:	013025        	call8	42009024 <create_test_vector>
42007d26:	0a7d      	mov.n	a7, a10
        assert(vec_in);
42007d28:	0adc      	bnez.n	a10, 42007d3c <vector_test_add_scalar_f32_alias+0x50>
42007d2a:	e2ead1        	l32r	a13, 420008d4 <_stext+0x8b4> (3c0241d8 <_flash_rodata_start+0x40b8>)
42007d2d:	e2f2c1        	l32r	a12, 420008f8 <_stext+0x8d8> (3c0274ec <__func__$10>)
42007d30:	a3a1b2        	movi	a11, 0x1a3
42007d33:	e2d1a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007d36:	e0f481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007d39:	0008e0        	callx8	a8
        fill_test_vector(vec_in);
42007d3c:	013565        	call8	42009094 <fill_test_vector>
 
        vector_t *expected = create_test_vector(vec_in->size, vec_in->type);
42007d3f:	0127b2        	l32i	a11, a7, 4
42007d42:	0227a2        	l32i	a10, a7, 8
42007d45:	012de5        	call8	42009024 <create_test_vector>
42007d48:	0a4d      	mov.n	a4, a10
        assert(expected);
42007d4a:	0adc      	bnez.n	a10, 42007d5e <vector_test_add_scalar_f32_alias+0x72>
42007d4c:	e2e4d1        	l32r	a13, 420008dc <_stext+0x8bc> (3c0241e0 <_flash_rodata_start+0x40c0>)
42007d4f:	e2eac1        	l32r	a12, 420008f8 <_stext+0x8d8> (3c0274ec <__func__$10>)
42007d52:	a7a1b2        	movi	a11, 0x1a7
42007d55:	e2c8a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007d58:	e0ec81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007d5b:	0008e0        	callx8	a8
        vec_copy(vec_in, expected);
42007d5e:	20baa0        	or	a11, a10, a10
42007d61:	20a770        	or	a10, a7, a7
42007d64:	01c8e5        	call8	420099f4 <vec_copy>
 
        assert(vector_assert_eq(vec_in, expected));
42007d67:	04bd      	mov.n	a11, a4
42007d69:	07ad      	mov.n	a10, a7
42007d6b:	014ce5        	call8	42009238 <vector_assert_eq>
42007d6e:	0adc      	bnez.n	a10, 42007d82 <vector_test_add_scalar_f32_alias+0x96>
42007d70:	e2dcd1        	l32r	a13, 420008e0 <_stext+0x8c0> (3c0241ec <_flash_rodata_start+0x40cc>)
42007d73:	e2e1c1        	l32r	a12, 420008f8 <_stext+0x8d8> (3c0274ec <__func__$10>)
42007d76:	aaa1b2        	movi	a11, 0x1aa
42007d79:	e2bfa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007d7c:	e0e381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007d7f:	0008e0        	callx8	a8
        assert(vector_check_canary(vec_in));
42007d82:	07ad      	mov.n	a10, a7
42007d84:	201110        	or	a1, a1, a1
42007d87:	013ce5        	call8	42009154 <vector_check_canary>
42007d8a:	0adc      	bnez.n	a10, 42007d9e <vector_test_add_scalar_f32_alias+0xb2>
42007d8c:	e2d6d1        	l32r	a13, 420008e4 <_stext+0x8c4> (3c024210 <_flash_rodata_start+0x40f0>)
42007d8f:	e2dac1        	l32r	a12, 420008f8 <_stext+0x8d8> (3c0274ec <__func__$10>)
42007d92:	aba1b2        	movi	a11, 0x1ab
42007d95:	e2b8a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007d98:	e0dc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007d9b:	0008e0        	callx8	a8
        assert(vector_check_canary(expected));
42007d9e:	04ad      	mov.n	a10, a4
42007da0:	013b25        	call8	42009154 <vector_check_canary>
42007da3:	0adc      	bnez.n	a10, 42007db7 <vector_test_add_scalar_f32_alias+0xcb>
42007da5:	e2d0d1        	l32r	a13, 420008e8 <_stext+0x8c8> (3c02422c <_flash_rodata_start+0x410c>)
42007da8:	e2d4c1        	l32r	a12, 420008f8 <_stext+0x8d8> (3c0274ec <__func__$10>)
42007dab:	aca1b2        	movi	a11, 0x1ac
42007dae:	e2b2a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007db1:	e0d581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007db4:	0008e0        	callx8	a8
 
        timer_start();
42007db7:	feb325        	call8	420068e8 <timer_start>
        scalar_add_scalar_f32(expected, rand_scalar, expected);
42007dba:	04cd      	mov.n	a12, a4
42007dbc:	05bd      	mov.n	a11, a5
42007dbe:	04ad      	mov.n	a10, a4
42007dc0:	0e8b65        	call8	42016678 <scalar_add_scalar_f32>
        timer_end(&scalar_time);
42007dc3:	a14b      	addi.n	a10, a1, 4
42007dc5:	feb465        	call8	4200690c <timer_end>
 
        timer_start();
42007dc8:	feb1e5        	call8	420068e8 <timer_start>
        vec_add_scalar_f32(vec_in, rand_scalar, vec_in);
42007dcb:	07cd      	mov.n	a12, a7
42007dcd:	05bd      	mov.n	a11, a5
42007dcf:	07ad      	mov.n	a10, a7
42007dd1:	0184a5        	call8	4200961c <vec_add_scalar_f32>
        timer_end(&vec_time);
42007dd4:	01ad      	mov.n	a10, a1
42007dd6:	feb365        	call8	4200690c <timer_end>
 
        vector_assert_eq(vec_in, expected);
42007dd9:	04bd      	mov.n	a11, a4
42007ddb:	20a770        	or	a10, a7, a7
42007dde:	0145a5        	call8	42009238 <vector_assert_eq>
 
        vector_check_canary(vec_in);
42007de1:	07ad      	mov.n	a10, a7
42007de3:	013725        	call8	42009154 <vector_check_canary>
        vector_check_canary(expected);
42007de6:	04ad      	mov.n	a10, a4
42007de8:	0136a5        	call8	42009154 <vector_check_canary>
 
        vector_destroy(vec_in);
42007deb:	07ad      	mov.n	a10, a7
42007ded:	016565        	call8	42009444 <vector_destroy>
        vector_destroy(expected);
42007df0:	04ad      	mov.n	a10, a4
42007df2:	016525        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++) { 
42007df5:	661b      	addi.n	a6, a6, 1
42007df7:	f83c      	movi.n	a8, 63
42007df9:	022867        	blt	a8, a6, 42007dff <vector_test_add_scalar_f32_alias+0x113>
42007dfc:	ffc106        	j	42007d04 <vector_test_add_scalar_f32_alias+0x18>
    }

    timer_deinit();
42007dff:	feb765        	call8	42006974 <timer_deinit>

    if (verbose) {
42007e02:	72bc      	beqz.n	a2, 42007e3d <vector_test_add_scalar_f32_alias+0x151>
        ESP_LOGI("vector_test_add_scalar_aliasing", "vec_time: %u", vec_time);
42007e04:	360c      	movi.n	a6, 3
42007e06:	e09681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007e09:	0008e0        	callx8	a8
42007e0c:	e2b871        	l32r	a7, 420008ec <_stext+0x8cc> (3c02424c <_flash_rodata_start+0x412c>)
42007e0f:	01f8      	l32i.n	a15, a1, 0
42007e11:	07ed      	mov.n	a14, a7
42007e13:	20daa0        	or	a13, a10, a10
42007e16:	e2b6c1        	l32r	a12, 420008f0 <_stext+0x8d0> (3c02426c <_flash_rodata_start+0x414c>)
42007e19:	20b770        	or	a11, a7, a7
42007e1c:	06ad      	mov.n	a10, a6
42007e1e:	e09d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007e21:	0008e0        	callx8	a8
        ESP_LOGI("vector_test_add_scalar_aliasing", "scalar_time: %u", scalar_time);
42007e24:	e08f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42007e27:	0008e0        	callx8	a8
42007e2a:	11f8      	l32i.n	a15, a1, 4
42007e2c:	07ed      	mov.n	a14, a7
42007e2e:	0add      	mov.n	a13, a10
42007e30:	e2b1c1        	l32r	a12, 420008f4 <_stext+0x8d4> (3c024288 <_flash_rodata_start+0x4168>)
42007e33:	07bd      	mov.n	a11, a7
42007e35:	06ad      	mov.n	a10, a6
42007e37:	e09781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42007e3a:	0008e0        	callx8	a8
    }
}
42007e3d:	f01d      	retw.n
	...

42007e40 <vector_test_mul_shift>:

void vector_test_mul_shift(bool verbose, dtype type){  
42007e40:	008136        	entry	a1, 64
42007e43:	748020        	extui	a8, a2, 0, 8
42007e46:	076182        	s32i	a8, a1, 28
    timer_init();
42007e49:	fea5e5        	call8	420068a8 <timer_init>
    set_rand_seed();
42007e4c:	011aa5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
42007e4f:	00a082        	movi	a8, 0
42007e52:	0189      	s32i.n	a8, a1, 0
    uint32_t scalar_time = 0;
42007e54:	1189      	s32i.n	a8, a1, 4
    unsigned int rand_shift_amount;

    switch (type) {
42007e56:	438c      	beqz.n	a3, 42007e5e <vector_test_mul_shift+0x1e>
42007e58:	1c1326        	beqi	a3, 1, 42007e78 <vector_test_mul_shift+0x38>
42007e5b:	000cc6        	j	42007e92 <vector_test_mul_shift+0x52>
        case DTYPE_INT8:   rand_shift_amount = (rand() % 8);    break;
42007e5e:	e29081        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007e61:	0008e0        	callx8	a8
42007e64:	318fa0        	srai	a8, a10, 31
42007e67:	258d80        	extui	a8, a8, 29, 3
42007e6a:	aa8a      	add.n	a10, a10, a8
42007e6c:	24a0a0        	extui	a10, a10, 0, 3
42007e6f:	c08a80        	sub	a8, a10, a8
42007e72:	6189      	s32i.n	a8, a1, 24
42007e74:	000c06        	j	42007ea8 <vector_test_mul_shift+0x68>
42007e77:	8a8100        	round.s	a8, f1, 0
        case DTYPE_INT16:  rand_shift_amount = (rand() % 16);   break;
42007e7a:	08e0e2        	s32c1i	a14, a0, 32
42007e7d:	00          	.byte	00
42007e7e:	318fa0        	srai	a8, a10, 31
42007e81:	358c80        	extui	a8, a8, 28, 4
42007e84:	aa8a      	add.n	a10, a10, a8
42007e86:	34a0a0        	extui	a10, a10, 0, 4
42007e89:	c08a80        	sub	a8, a10, a8
42007e8c:	6189      	s32i.n	a8, a1, 24
42007e8e:	000586        	j	42007ea8 <vector_test_mul_shift+0x68>
42007e91:	838100        	moveqz	a8, a1, a0
        default:           rand_shift_amount = (rand() % 32);   break;
42007e94:	08e0e2        	s32c1i	a14, a0, 32
42007e97:	00          	.byte	00
42007e98:	318fa0        	srai	a8, a10, 31
42007e9b:	458b80        	extui	a8, a8, 27, 5
42007e9e:	aa8a      	add.n	a10, a10, a8
42007ea0:	44a0a0        	extui	a10, a10, 0, 5
42007ea3:	c08a80        	sub	a8, a10, a8
42007ea6:	6189      	s32i.n	a8, a1, 24
    }

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42007ea8:	020c      	movi.n	a2, 0
42007eaa:	006a86        	j	42008058 <vector_test_mul_shift+0x218>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
42007ead:	e27c81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42007eb0:	0008e0        	callx8	a8
42007eb3:	318fa0        	srai	a8, a10, 31
42007eb6:	758880        	extui	a8, a8, 24, 8
42007eb9:	6a8a      	add.n	a6, a10, a8
42007ebb:	746060        	extui	a6, a6, 0, 8
42007ebe:	c06680        	sub	a6, a6, a8
42007ec1:	661b      	addi.n	a6, a6, 1
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors
42007ec3:	03bd      	mov.n	a11, a3
42007ec5:	20a660        	or	a10, a6, a6
42007ec8:	0115a5        	call8	42009024 <create_test_vector>
42007ecb:	0a7d      	mov.n	a7, a10
        vector_t *vec2 = create_test_vector(test_size, type);
42007ecd:	03bd      	mov.n	a11, a3
42007ecf:	06ad      	mov.n	a10, a6
42007ed1:	011525        	call8	42009024 <create_test_vector>
42007ed4:	0a6d      	mov.n	a6, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42007ed6:	17b8      	l32i.n	a11, a7, 4
42007ed8:	27a8      	l32i.n	a10, a7, 8
42007eda:	0114a5        	call8	42009024 <create_test_vector>
42007edd:	0a5d      	mov.n	a5, a10
        vector_t *scalar_result = create_test_vector(vec2->size, vec2->type); 
42007edf:	16b8      	l32i.n	a11, a6, 4
42007ee1:	26a8      	l32i.n	a10, a6, 8
42007ee3:	011425        	call8	42009024 <create_test_vector>
42007ee6:	41a9      	s32i.n	a10, a1, 16

        assert(vec1);                                                   // Check if valid
42007ee8:	07dc      	bnez.n	a7, 42007efc <vector_test_mul_shift+0xbc>
42007eea:	e261d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42007eed:	e283c1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007ef0:	dca1b2        	movi	a11, 0x1dc
42007ef3:	e261a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007ef6:	e08481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007ef9:	0008e0        	callx8	a8
        assert(vec2);
        assert(simd_result);
42007efc:	05dc      	bnez.n	a5, 42007f10 <vector_test_mul_shift+0xd0>
42007efe:	e25fd1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
42007f01:	e27ec1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007f04:	dea1b2        	movi	a11, 0x1de
42007f07:	e25ca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007f0a:	e07f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007f0d:	0008e0        	callx8	a8
        assert(scalar_result);
42007f10:	4188      	l32i.n	a8, a1, 16
42007f12:	08dc      	bnez.n	a8, 42007f26 <vector_test_mul_shift+0xe6>
42007f14:	e25bd1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
42007f17:	e279c1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007f1a:	dfa1b2        	movi	a11, 0x1df
42007f1d:	e256a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007f20:	e07a81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007f23:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range
42007f26:	07ad      	mov.n	a10, a7
42007f28:	0116a5        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2); 
42007f2b:	06ad      	mov.n	a10, a6
42007f2d:	011665        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs)
42007f30:	17b8      	l32i.n	a11, a7, 4
42007f32:	27a8      	l32i.n	a10, a7, 8
42007f34:	014be5        	call8	420093f4 <vector_create>
42007f37:	0a4d      	mov.n	a4, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type); 
42007f39:	16b8      	l32i.n	a11, a6, 4
42007f3b:	26a8      	l32i.n	a10, a6, 8
42007f3d:	014b65        	call8	420093f4 <vector_create>
42007f40:	51a9      	s32i.n	a10, a1, 20
        assert(vec1_copy);
42007f42:	04dc      	bnez.n	a4, 42007f56 <vector_test_mul_shift+0x116>
42007f44:	e260d1        	l32r	a13, 420008c4 <_stext+0x8a4> (3c02419c <_flash_rodata_start+0x407c>)
42007f47:	e26dc1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007f4a:	e6a1b2        	movi	a11, 0x1e6
42007f4d:	e24aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007f50:	e06e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007f53:	0008e0        	callx8	a8
        assert(vec2_copy);
42007f56:	5188      	l32i.n	a8, a1, 20
42007f58:	08dc      	bnez.n	a8, 42007f6c <vector_test_mul_shift+0x12c>
42007f5a:	e269d1        	l32r	a13, 42000900 <_stext+0x8e0> (3c0242a8 <_flash_rodata_start+0x4188>)
42007f5d:	e267c1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007f60:	e7a1b2        	movi	a11, 0x1e7
42007f63:	e245a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007f66:	e06881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007f69:	0008e0        	callx8	a8
        vec_copy(vec1, vec1_copy); 
42007f6c:	20b440        	or	a11, a4, a4
42007f6f:	07ad      	mov.n	a10, a7
42007f71:	01a825        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);  
42007f74:	51b8      	l32i.n	a11, a1, 20
42007f76:	06ad      	mov.n	a10, a6
42007f78:	01a7a5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions
42007f7b:	04bd      	mov.n	a11, a4
42007f7d:	07ad      	mov.n	a10, a7
42007f7f:	012ba5        	call8	42009238 <vector_assert_eq>
42007f82:	0adc      	bnez.n	a10, 42007f96 <vector_test_mul_shift+0x156>
42007f84:	e240d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42007f87:	e25dc1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007f8a:	eba1b2        	movi	a11, 0x1eb
42007f8d:	e23aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007f90:	e05e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007f93:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
42007f96:	0521b2        	l32i	a11, a1, 20
42007f99:	20a660        	or	a10, a6, a6
42007f9c:	0129a5        	call8	42009238 <vector_assert_eq>
42007f9f:	011a56        	bnez	a10, 42007fb4 <vector_test_mul_shift+0x174>
42007fa2:	e239d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
42007fa5:	e255c1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007fa8:	eca1b2        	movi	a11, 0x1ec
42007fab:	e233a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007fae:	e05681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007fb1:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
42007fb4:	07ad      	mov.n	a10, a7
42007fb6:	0119e5        	call8	42009154 <vector_check_canary>
42007fb9:	0adc      	bnez.n	a10, 42007fcd <vector_test_mul_shift+0x18d>
42007fbb:	e234d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42007fbe:	e24fc1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007fc1:	eda1b2        	movi	a11, 0x1ed
42007fc4:	e22da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007fc7:	e05081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007fca:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
42007fcd:	06ad      	mov.n	a10, a6
42007fcf:	201110        	or	a1, a1, a1
42007fd2:	011825        	call8	42009154 <vector_check_canary>
42007fd5:	0adc      	bnez.n	a10, 42007fe9 <vector_test_mul_shift+0x1a9>
42007fd7:	e22ed1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
42007fda:	e248c1        	l32r	a12, 420008fc <_stext+0x8dc> (3c0274d4 <__func__$9>)
42007fdd:	eea1b2        	movi	a11, 0x1ee
42007fe0:	e226a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42007fe3:	e04981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42007fe6:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42007fe9:	fe8fe5        	call8	420068e8 <timer_start>
        scalar_mul(vec1, vec2, scalar_result, rand_shift_amount);
42007fec:	61d8      	l32i.n	a13, a1, 24
42007fee:	41c8      	l32i.n	a12, a1, 16
42007ff0:	06bd      	mov.n	a11, a6
42007ff2:	07ad      	mov.n	a10, a7
42007ff4:	0e6d65        	call8	420166cc <scalar_mul>
        timer_end(&scalar_time);
42007ff7:	a14b      	addi.n	a10, a1, 4
42007ff9:	fe9125        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42007ffc:	fe8ea5        	call8	420068e8 <timer_start>
        vec_mul(vec1, vec2, simd_result,  rand_shift_amount);
42007fff:	61d8      	l32i.n	a13, a1, 24
42008001:	05cd      	mov.n	a12, a5
42008003:	06bd      	mov.n	a11, a6
42008005:	07ad      	mov.n	a10, a7
42008007:	016565        	call8	4200965c <vec_mul>
        timer_end(&vec_time); 
4200800a:	01ad      	mov.n	a10, a1
4200800c:	fe8fe5        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
4200800f:	41b8      	l32i.n	a11, a1, 16
42008011:	05ad      	mov.n	a10, a5
42008013:	012265        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs
42008016:	04bd      	mov.n	a11, a4
42008018:	07ad      	mov.n	a10, a7
4200801a:	0121e5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec2, vec2_copy);
4200801d:	51b8      	l32i.n	a11, a1, 20
4200801f:	06ad      	mov.n	a10, a6
42008021:	012165        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region
42008024:	07ad      	mov.n	a10, a7
42008026:	0112e5        	call8	42009154 <vector_check_canary>
        vector_check_canary(vec2);
42008029:	06ad      	mov.n	a10, a6
4200802b:	0112a5        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
4200802e:	05ad      	mov.n	a10, a5
42008030:	011225        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42008033:	41a8      	l32i.n	a10, a1, 16
42008035:	0111e5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources
42008038:	07ad      	mov.n	a10, a7
4200803a:	0140a5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
4200803d:	06ad      	mov.n	a10, a6
4200803f:	014065        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
42008042:	04ad      	mov.n	a10, a4
42008044:	013fe5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy);
42008047:	51a8      	l32i.n	a10, a1, 20
42008049:	013fa5        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
4200804c:	05ad      	mov.n	a10, a5
4200804e:	013f65        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42008051:	41a8      	l32i.n	a10, a1, 16
42008053:	013f25        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008056:	221b      	addi.n	a2, a2, 1
42008058:	f83c      	movi.n	a8, 63
4200805a:	022827        	blt	a8, a2, 42008060 <vector_test_mul_shift+0x220>
4200805d:	ff9306        	j	42007ead <vector_test_mul_shift+0x6d>
    } 
    timer_deinit();
42008060:	fe9125        	call8	42006974 <timer_deinit>
    if (verbose){
42008063:	7188      	l32i.n	a8, a1, 28
42008065:	58bc      	beqz.n	a8, 4200809e <vector_test_mul_shift+0x25e>
            ESP_LOGI("vector_test_mul_shift", "vector_time: %d", vec_time);
42008067:	360c      	movi.n	a6, 3
42008069:	dffd81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200806c:	0008e0        	callx8	a8
4200806f:	e22571        	l32r	a7, 42000904 <_stext+0x8e4> (3c0242b4 <_flash_rodata_start+0x4194>)
42008072:	01f8      	l32i.n	a15, a1, 0
42008074:	07ed      	mov.n	a14, a7
42008076:	0add      	mov.n	a13, a10
42008078:	e208c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
4200807b:	07bd      	mov.n	a11, a7
4200807d:	06ad      	mov.n	a10, a6
4200807f:	e00581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008082:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_mul_shift", "scalar_time: %d", scalar_time);
42008085:	dff681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008088:	0008e0        	callx8	a8
4200808b:	11f8      	l32i.n	a15, a1, 4
4200808d:	07ed      	mov.n	a14, a7
4200808f:	0add      	mov.n	a13, a10
42008091:	e202c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008094:	07bd      	mov.n	a11, a7
42008096:	06ad      	mov.n	a10, a6
42008098:	dfff81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200809b:	0008e0        	callx8	a8
    }
} 
4200809e:	f01d      	retw.n

420080a0 <vector_test_mul_shift_alias>:

void vector_test_mul_shift_alias(bool verbose, dtype type){  
420080a0:	008136        	entry	a1, 64
420080a3:	748020        	extui	a8, a2, 0, 8
420080a6:	056182        	s32i	a8, a1, 20
    timer_init();
420080a9:	fe7fe5        	call8	420068a8 <timer_init>
    set_rand_seed();
420080ac:	00f4a5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420080af:	00a022        	movi	a2, 0
420080b2:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0; 
420080b4:	1129      	s32i.n	a2, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420080b6:	005ec6        	j	42008235 <vector_test_mul_shift_alias+0x195>

        unsigned int rand_shift_amount;

        switch (type) {
420080b9:	438c      	beqz.n	a3, 420080c1 <vector_test_mul_shift_alias+0x21>
420080bb:	191326        	beqi	a3, 1, 420080d8 <vector_test_mul_shift_alias+0x38>
420080be:	000b46        	j	420080ef <vector_test_mul_shift_alias+0x4f>
            case DTYPE_INT8:   rand_shift_amount = (rand() % 8);    break;
420080c1:	e1f781        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420080c4:	0008e0        	callx8	a8
420080c7:	318fa0        	srai	a8, a10, 31
420080ca:	258d80        	extui	a8, a8, 29, 3
420080cd:	aa8a      	add.n	a10, a10, a8
420080cf:	24a0a0        	extui	a10, a10, 0, 3
420080d2:	c04a80        	sub	a4, a10, a8
420080d5:	000ac6        	j	42008104 <vector_test_mul_shift_alias+0x64>
            case DTYPE_INT16:  rand_shift_amount = (rand() % 16);   break;
420080d8:	e1f281        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420080db:	0008e0        	callx8	a8
420080de:	318fa0        	srai	a8, a10, 31
420080e1:	358c80        	extui	a8, a8, 28, 4
420080e4:	aa8a      	add.n	a10, a10, a8
420080e6:	34a0a0        	extui	a10, a10, 0, 4
420080e9:	c04a80        	sub	a4, a10, a8
420080ec:	000506        	j	42008104 <vector_test_mul_shift_alias+0x64>
            default:           rand_shift_amount = (rand() % 32);   break;
420080ef:	e1ec81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420080f2:	0008e0        	callx8	a8
420080f5:	318fa0        	srai	a8, a10, 31
420080f8:	458b80        	extui	a8, a8, 27, 5
420080fb:	80aa80        	add	a10, a10, a8
420080fe:	44a0a0        	extui	a10, a10, 0, 5
42008101:	c04a80        	sub	a4, a10, a8
        }

        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
42008104:	e1e781        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42008107:	0008e0        	callx8	a8
4200810a:	318fa0        	srai	a8, a10, 31
4200810d:	758880        	extui	a8, a8, 24, 8
42008110:	807a80        	add	a7, a10, a8
42008113:	747070        	extui	a7, a7, 0, 8
42008116:	c07780        	sub	a7, a7, a8
42008119:	771b      	addi.n	a7, a7, 1
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors
4200811b:	20b330        	or	a11, a3, a3
4200811e:	07ad      	mov.n	a10, a7
42008120:	00f025        	call8	42009024 <create_test_vector>
42008123:	0a6d      	mov.n	a6, a10
        vector_t *vec2 = create_test_vector(test_size, type); 
42008125:	03bd      	mov.n	a11, a3
42008127:	07ad      	mov.n	a10, a7
42008129:	00efa5        	call8	42009024 <create_test_vector>
4200812c:	0a7d      	mov.n	a7, a10

        assert(vec1);                                                   // Check if valid
4200812e:	06dc      	bnez.n	a6, 42008142 <vector_test_mul_shift_alias+0xa2>
42008130:	e1d0d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008133:	e1f5c1        	l32r	a12, 42000908 <_stext+0x8e8> (3c0274b8 <__func__$8>)
42008136:	23a2b2        	movi	a11, 0x223
42008139:	e1cfa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200813c:	dff381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200813f:	0008e0        	callx8	a8
        assert(vec2); 
42008142:	0adc      	bnez.n	a10, 42008156 <vector_test_mul_shift_alias+0xb6>
42008144:	e1f2d1        	l32r	a13, 4200090c <_stext+0x8ec> (3c0242cc <_flash_rodata_start+0x41ac>)
42008147:	e1f0c1        	l32r	a12, 42000908 <_stext+0x8e8> (3c0274b8 <__func__$8>)
4200814a:	24a2b2        	movi	a11, 0x224
4200814d:	e1caa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008150:	dfee81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008153:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range
42008156:	20a660        	or	a10, a6, a6
42008159:	00f3a5        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2); 
4200815c:	07ad      	mov.n	a10, a7
4200815e:	00f365        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs)
42008161:	16b8      	l32i.n	a11, a6, 4
42008163:	26a8      	l32i.n	a10, a6, 8
42008165:	0128e5        	call8	420093f4 <vector_create>
42008168:	0a5d      	mov.n	a5, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type); 
4200816a:	17b8      	l32i.n	a11, a7, 4
4200816c:	27a8      	l32i.n	a10, a7, 8
4200816e:	012865        	call8	420093f4 <vector_create>
42008171:	41a9      	s32i.n	a10, a1, 16
        vec_copy(vec1, vec1_copy); 
42008173:	05bd      	mov.n	a11, a5
42008175:	06ad      	mov.n	a10, a6
42008177:	0187e5        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);  
4200817a:	41b8      	l32i.n	a11, a1, 16
4200817c:	07ad      	mov.n	a10, a7
4200817e:	018765        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions
42008181:	05bd      	mov.n	a11, a5
42008183:	06ad      	mov.n	a10, a6
42008185:	010b25        	call8	42009238 <vector_assert_eq>
42008188:	0adc      	bnez.n	a10, 4200819c <vector_test_mul_shift_alias+0xfc>
4200818a:	e1bed1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
4200818d:	e1dec1        	l32r	a12, 42000908 <_stext+0x8e8> (3c0274b8 <__func__$8>)
42008190:	2ea2b2        	movi	a11, 0x22e
42008193:	e1b9a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008196:	dfdc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008199:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
4200819c:	0421b2        	l32i	a11, a1, 16
4200819f:	20a770        	or	a10, a7, a7
420081a2:	010965        	call8	42009238 <vector_assert_eq>
420081a5:	011a56        	bnez	a10, 420081ba <vector_test_mul_shift_alias+0x11a>
420081a8:	e1b8d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
420081ab:	e1d7c1        	l32r	a12, 42000908 <_stext+0x8e8> (3c0274b8 <__func__$8>)
420081ae:	2fa2b2        	movi	a11, 0x22f
420081b1:	e1b1a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420081b4:	dfd581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420081b7:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
420081ba:	06ad      	mov.n	a10, a6
420081bc:	201110        	or	a1, a1, a1
420081bf:	00f965        	call8	42009154 <vector_check_canary>
420081c2:	0adc      	bnez.n	a10, 420081d6 <vector_test_mul_shift_alias+0x136>
420081c4:	e1b2d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
420081c7:	e1d0c1        	l32r	a12, 42000908 <_stext+0x8e8> (3c0274b8 <__func__$8>)
420081ca:	30a2b2        	movi	a11, 0x230
420081cd:	e1aaa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420081d0:	dfce81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420081d3:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
420081d6:	07ad      	mov.n	a10, a7
420081d8:	00f7a5        	call8	42009154 <vector_check_canary>
420081db:	0adc      	bnez.n	a10, 420081ef <vector_test_mul_shift_alias+0x14f>
420081dd:	e1acd1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
420081e0:	e1cac1        	l32r	a12, 42000908 <_stext+0x8e8> (3c0274b8 <__func__$8>)
420081e3:	31a2b2        	movi	a11, 0x231
420081e6:	e1a4a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420081e9:	dfc781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420081ec:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
420081ef:	fe6fa5        	call8	420068e8 <timer_start>
        scalar_mul(vec1, vec2, vec1, rand_shift_amount);
420081f2:	04dd      	mov.n	a13, a4
420081f4:	06cd      	mov.n	a12, a6
420081f6:	07bd      	mov.n	a11, a7
420081f8:	06ad      	mov.n	a10, a6
420081fa:	0e4d25        	call8	420166cc <scalar_mul>
        timer_end(&scalar_time);
420081fd:	a14b      	addi.n	a10, a1, 4
420081ff:	fe70e5        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42008202:	fe6e65        	call8	420068e8 <timer_start>
        vec_mul(vec1_copy, vec2, vec2, rand_shift_amount);
42008205:	04dd      	mov.n	a13, a4
42008207:	07cd      	mov.n	a12, a7
42008209:	07bd      	mov.n	a11, a7
4200820b:	05ad      	mov.n	a10, a5
4200820d:	0144e5        	call8	4200965c <vec_mul>
        timer_end(&vec_time); 
42008210:	01ad      	mov.n	a10, a1
42008212:	fe6fa5        	call8	4200690c <timer_end>
 
        vector_check_canary(vec1);                                      // Check modification of canary region
42008215:	06ad      	mov.n	a10, a6
42008217:	00f3e5        	call8	42009154 <vector_check_canary>
        vector_check_canary(vec2); 
4200821a:	07ad      	mov.n	a10, a7
4200821c:	00f365        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources
4200821f:	06ad      	mov.n	a10, a6
42008221:	012225        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
42008224:	07ad      	mov.n	a10, a7
42008226:	0121e5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
42008229:	05ad      	mov.n	a10, a5
4200822b:	0121a5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy); 
4200822e:	41a8      	l32i.n	a10, a1, 16
42008230:	012125        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008233:	221b      	addi.n	a2, a2, 1
42008235:	f83c      	movi.n	a8, 63
42008237:	022827        	blt	a8, a2, 4200823d <vector_test_mul_shift_alias+0x19d>
4200823a:	ff9ec6        	j	420080b9 <vector_test_mul_shift_alias+0x19>
    } 
    timer_deinit();
4200823d:	fe7365        	call8	42006974 <timer_deinit>
    if (verbose){
42008240:	5188      	l32i.n	a8, a1, 20
42008242:	78bc      	beqz.n	a8, 4200827d <vector_test_mul_shift_alias+0x1dd>
            ESP_LOGI("vector_test_mul_shift", "vector_time: %d", vec_time);
42008244:	360c      	movi.n	a6, 3
42008246:	df8681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008249:	0008e0        	callx8	a8
4200824c:	e1ae71        	l32r	a7, 42000904 <_stext+0x8e4> (3c0242b4 <_flash_rodata_start+0x4194>)
4200824f:	01f8      	l32i.n	a15, a1, 0
42008251:	07ed      	mov.n	a14, a7
42008253:	20daa0        	or	a13, a10, a10
42008256:	e190c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42008259:	20b770        	or	a11, a7, a7
4200825c:	06ad      	mov.n	a10, a6
4200825e:	df8d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008261:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_mul_shift", "scalar_time: %d", scalar_time);
42008264:	df7f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008267:	0008e0        	callx8	a8
4200826a:	11f8      	l32i.n	a15, a1, 4
4200826c:	07ed      	mov.n	a14, a7
4200826e:	0add      	mov.n	a13, a10
42008270:	e18bc1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008273:	07bd      	mov.n	a11, a7
42008275:	06ad      	mov.n	a10, a6
42008277:	df8781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200827a:	0008e0        	callx8	a8
    }
}
4200827d:	f01d      	retw.n
	...

42008280 <vector_test_sum>:

void vector_test_sum(bool verbose, dtype type){ 
42008280:	008136        	entry	a1, 64
42008283:	742020        	extui	a2, a2, 0, 8

    timer_init();
42008286:	fe6225        	call8	420068a8 <timer_init>
    set_rand_seed();
42008289:	00d6e5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
4200828c:	00a062        	movi	a6, 0
4200828f:	046162        	s32i	a6, a1, 16
    uint32_t scalar_time = 0;
42008292:	5169      	s32i.n	a6, a1, 20

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008294:	0053c6        	j	420083e7 <vector_test_sum+0x167>
42008297:	828100        	mull	a8, a1, a0
        int test_size = 1 + rand() % MAX_SIZE;                          // Random vector sizes 
4200829a:	08e0e1        	l32r	a14, 41fca61c <_iram_bss_end+0x1c4821c>
4200829d:	00          	.byte	00
4200829e:	318fa0        	srai	a8, a10, 31
420082a1:	758880        	extui	a8, a8, 24, 8
420082a4:	80aa80        	add	a10, a10, a8
420082a7:	74a0a0        	extui	a10, a10, 0, 8
420082aa:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors  
420082ad:	20b330        	or	a11, a3, a3
420082b0:	01caa2        	addi	a10, a10, 1
420082b3:	00d725        	call8	42009024 <create_test_vector>
420082b6:	0a7d      	mov.n	a7, a10
        int32_t vector_sum_val;
        int32_t scalar_sum_val;

        assert(vec1);              
420082b8:	0adc      	bnez.n	a10, 420082cc <vector_test_sum+0x4c>
420082ba:	e16dd1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
420082bd:	e194c1        	l32r	a12, 42000910 <_stext+0x8f0> (3c0274a8 <__func__$7>)
420082c0:	58a2b2        	movi	a11, 0x258
420082c3:	e16da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420082c6:	df9081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420082c9:	0008e0        	callx8	a8
        fill_test_vector(vec1);                                         // Fill with random values in range 
420082cc:	00dc65        	call8	42009094 <fill_test_vector>
        if (type == DTYPE_INT32){                                       // Behavior undefined for overflow.
420082cf:	3b2366        	bnei	a3, 2, 4200830e <vector_test_sum+0x8e>
            int32_t* data = vec1->data;
420082d2:	0758      	l32i.n	a5, a7, 0
            for (int i = 0; i < vec1->size; i++){
420082d4:	060c      	movi.n	a6, 0
420082d6:	000b06        	j	42008306 <vector_test_sum+0x86>
420082d9:	000000        	ill
                int32_t val = rand() % UINT16_MAX + INT16_MIN;
420082dc:	e17181        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420082df:	0008e0        	callx8	a8
420082e2:	e18c81        	l32r	a8, 42000914 <_stext+0x8f4> (80008001 <_rtc_reserved_end+0x1ff08001>)
420082e5:	b28a80        	mulsh	a8, a10, a8
420082e8:	8a8a      	add.n	a8, a10, a8
420082ea:	218f80        	srai	a8, a8, 15
420082ed:	319fa0        	srai	a9, a10, 31
420082f0:	c08890        	sub	a8, a8, a9
420082f3:	119800        	slli	a9, a8, 16
420082f6:	c08980        	sub	a8, a9, a8
420082f9:	c08a80        	sub	a8, a10, a8
420082fc:	80d882        	addmi	a8, a8, 0xffff8000
                data[i] = val;
420082ff:	a09650        	addx4	a9, a6, a5
42008302:	0989      	s32i.n	a8, a9, 0
            for (int i = 0; i < vec1->size; i++){
42008304:	661b      	addi.n	a6, a6, 1
42008306:	2788      	l32i.n	a8, a7, 8
42008308:	d03687        	bltu	a6, a8, 420082dc <vector_test_sum+0x5c>
4200830b:	003806        	j	420083ef <vector_test_sum+0x16f>
            }
            break;
        }

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
4200830e:	0127b2        	l32i	a11, a7, 4
42008311:	27a8      	l32i.n	a10, a7, 8
42008313:	010e25        	call8	420093f4 <vector_create>
42008316:	0a5d      	mov.n	a5, a10
        vec_copy(vec1, vec1_copy);  
42008318:	0abd      	mov.n	a11, a10
4200831a:	07ad      	mov.n	a10, a7
4200831c:	016d65        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
4200831f:	05bd      	mov.n	a11, a5
42008321:	07ad      	mov.n	a10, a7
42008323:	00f165        	call8	42009238 <vector_assert_eq>
42008326:	0adc      	bnez.n	a10, 4200833a <vector_test_sum+0xba>
42008328:	e157d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
4200832b:	e179c1        	l32r	a12, 42000910 <_stext+0x8f0> (3c0274a8 <__func__$7>)
4200832e:	66a2b2        	movi	a11, 0x266
42008331:	e151a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008334:	df7581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008337:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
4200833a:	20a770        	or	a10, a7, a7
4200833d:	00e165        	call8	42009154 <vector_check_canary>
42008340:	0adc      	bnez.n	a10, 42008354 <vector_test_sum+0xd4>
42008342:	e152d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42008345:	e172c1        	l32r	a12, 42000910 <_stext+0x8f0> (3c0274a8 <__func__$7>)
42008348:	67a2b2        	movi	a11, 0x267
4200834b:	e14ba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200834e:	df6e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008351:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42008354:	fe5925        	call8	420068e8 <timer_start>
        assert(scalar_sum(vec1, &scalar_sum_val) == VECTOR_SUCCESS);
42008357:	18c1b2        	addi	a11, a1, 24
4200835a:	20a770        	or	a10, a7, a7
4200835d:	fe9e25        	call8	42006d40 <scalar_sum>
42008360:	0a9c      	beqz.n	a10, 42008374 <vector_test_sum+0xf4>
42008362:	e16dd1        	l32r	a13, 42000918 <_stext+0x8f8> (3c0242d4 <_flash_rodata_start+0x41b4>)
42008365:	e16ac1        	l32r	a12, 42000910 <_stext+0x8f0> (3c0274a8 <__func__$7>)
42008368:	6aa2b2        	movi	a11, 0x26a
4200836b:	e143a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200836e:	df6681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008371:	0008e0        	callx8	a8
        timer_end(&scalar_time);
42008374:	14c1a2        	addi	a10, a1, 20
42008377:	fe5965        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
4200837a:	fe56e5        	call8	420068e8 <timer_start>
        assert(vec_sum(vec1, &vector_sum_val) == VECTOR_SUCCESS);
4200837d:	1cc1b2        	addi	a11, a1, 28
42008380:	07ad      	mov.n	a10, a7
42008382:	013725        	call8	420096f4 <vec_sum>
42008385:	0a9c      	beqz.n	a10, 42008399 <vector_test_sum+0x119>
42008387:	e165d1        	l32r	a13, 4200091c <_stext+0x8fc> (3c024308 <_flash_rodata_start+0x41e8>)
4200838a:	e161c1        	l32r	a12, 42000910 <_stext+0x8f0> (3c0274a8 <__func__$7>)
4200838d:	6ea2b2        	movi	a11, 0x26e
42008390:	e13aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008393:	df5d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008396:	0008e0        	callx8	a8
        timer_end(&vec_time); 
42008399:	10c1a2        	addi	a10, a1, 16
4200839c:	fe56e5        	call8	4200690c <timer_end>
  
        if(vector_sum_val != scalar_sum_val){
4200839f:	7198      	l32i.n	a9, a1, 28
420083a1:	6188      	l32i.n	a8, a1, 24
420083a3:	2f1987        	beq	a9, a8, 420083d6 <vector_test_sum+0x156>
            ESP_LOGE("vector_test_sum", "Sum mismatch: vector_sum: %d, scalar_sum: %d", (int)vector_sum_val, (int)scalar_sum_val);
420083a6:	df2e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420083a9:	0008e0        	callx8	a8
420083ac:	e15db1        	l32r	a11, 42000920 <_stext+0x900> (3c02433c <_flash_rodata_start+0x421c>)
420083af:	6188      	l32i.n	a8, a1, 24
420083b1:	0189      	s32i.n	a8, a1, 0
420083b3:	71f8      	l32i.n	a15, a1, 28
420083b5:	0bed      	mov.n	a14, a11
420083b7:	0add      	mov.n	a13, a10
420083b9:	e15ac1        	l32r	a12, 42000924 <_stext+0x904> (3c02434c <_flash_rodata_start+0x422c>)
420083bc:	1a0c      	movi.n	a10, 1
420083be:	df3581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420083c1:	0008e0        	callx8	a8
            assert(0);
420083c4:	e159d1        	l32r	a13, 42000928 <_stext+0x908> (3c0233b0 <_flash_rodata_start+0x3290>)
420083c7:	e152c1        	l32r	a12, 42000910 <_stext+0x8f0> (3c0274a8 <__func__$7>)
420083ca:	73a2b2        	movi	a11, 0x273
420083cd:	e12aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420083d0:	df4e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420083d3:	0008e0        	callx8	a8
        }
        vector_check_canary(vec1);                                      // Check modification of canary region 
420083d6:	07ad      	mov.n	a10, a7
420083d8:	00d7a5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
420083db:	07ad      	mov.n	a10, a7
420083dd:	010665        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
420083e0:	05ad      	mov.n	a10, a5
420083e2:	010625        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420083e5:	661b      	addi.n	a6, a6, 1
420083e7:	f83c      	movi.n	a8, 63
420083e9:	022867        	blt	a8, a6, 420083ef <vector_test_sum+0x16f>
420083ec:	ffaa06        	j	42008298 <vector_test_sum+0x18>
    } 
    timer_deinit();
420083ef:	fe5865        	call8	42006974 <timer_deinit>
    if (verbose){
420083f2:	72bc      	beqz.n	a2, 4200842d <vector_test_sum+0x1ad>
            ESP_LOGI("vector_test_sum", "vector_time: %d", vec_time);
420083f4:	360c      	movi.n	a6, 3
420083f6:	df1a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420083f9:	0008e0        	callx8	a8
420083fc:	e14971        	l32r	a7, 42000920 <_stext+0x900> (3c02433c <_flash_rodata_start+0x421c>)
420083ff:	41f8      	l32i.n	a15, a1, 16
42008401:	07ed      	mov.n	a14, a7
42008403:	20daa0        	or	a13, a10, a10
42008406:	e124c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42008409:	20b770        	or	a11, a7, a7
4200840c:	06ad      	mov.n	a10, a6
4200840e:	df2181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008411:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_sum", "scalar_time: %d", scalar_time);
42008414:	df1381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008417:	0008e0        	callx8	a8
4200841a:	51f8      	l32i.n	a15, a1, 20
4200841c:	07ed      	mov.n	a14, a7
4200841e:	0add      	mov.n	a13, a10
42008420:	e11fc1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008423:	07bd      	mov.n	a11, a7
42008425:	06ad      	mov.n	a10, a6
42008427:	df1b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200842a:	0008e0        	callx8	a8
    }
}
4200842d:	f01d      	retw.n
	...

42008430 <vector_test_sum_f32>:
 
void vector_test_sum_f32(bool verbose, dtype type){ 
42008430:	008136        	entry	a1, 64
42008433:	742020        	extui	a2, a2, 0, 8
    assert(type == DTYPE_FLOAT32);
42008436:	113326        	beqi	a3, 3, 4200844b <vector_test_sum_f32+0x1b>
42008439:	e124d1        	l32r	a13, 420008cc <_stext+0x8ac> (3c0241c0 <_flash_rodata_start+0x40a0>)
4200843c:	e13cc1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
4200843f:	82a2b2        	movi	a11, 0x282
42008442:	e10da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008445:	df3081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008448:	0008e0        	callx8	a8
    timer_init();
4200844b:	fe45e5        	call8	420068a8 <timer_init>
    set_rand_seed();
4200844e:	00baa5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
42008451:	00a062        	movi	a6, 0
42008454:	046162        	s32i	a6, a1, 16
    uint32_t scalar_time = 0;
42008457:	5169      	s32i.n	a6, a1, 20

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008459:	0049c6        	j	42008584 <vector_test_sum_f32+0x154>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
4200845c:	e11181        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
4200845f:	0008e0        	callx8	a8
42008462:	318fa0        	srai	a8, a10, 31
42008465:	758880        	extui	a8, a8, 24, 8
42008468:	80aa80        	add	a10, a10, a8
4200846b:	74a0a0        	extui	a10, a10, 0, 8
4200846e:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors  
42008471:	20b330        	or	a11, a3, a3
42008474:	01caa2        	addi	a10, a10, 1
42008477:	00bae5        	call8	42009024 <create_test_vector>
4200847a:	0a7d      	mov.n	a7, a10
        float vector_sum;
        float scalar_sum;

        assert(vec1);                
4200847c:	0adc      	bnez.n	a10, 42008490 <vector_test_sum_f32+0x60>
4200847e:	e0fcd1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008481:	e12ac1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
42008484:	8fa2b2        	movi	a11, 0x28f
42008487:	e0fca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200848a:	df1f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200848d:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
42008490:	00c025        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
42008493:	17b8      	l32i.n	a11, a7, 4
42008495:	27a8      	l32i.n	a10, a7, 8
42008497:	00f5e5        	call8	420093f4 <vector_create>
4200849a:	0a5d      	mov.n	a5, a10
        vec_copy(vec1, vec1_copy);  
4200849c:	0abd      	mov.n	a11, a10
4200849e:	07ad      	mov.n	a10, a7
420084a0:	015525        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
420084a3:	05bd      	mov.n	a11, a5
420084a5:	07ad      	mov.n	a10, a7
420084a7:	00d925        	call8	42009238 <vector_assert_eq>
420084aa:	0adc      	bnez.n	a10, 420084be <vector_test_sum_f32+0x8e>
420084ac:	e0f6d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
420084af:	e11fc1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
420084b2:	96a2b2        	movi	a11, 0x296
420084b5:	e0f0a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420084b8:	df1481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420084bb:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
420084be:	20a770        	or	a10, a7, a7
420084c1:	00c925        	call8	42009154 <vector_check_canary>
420084c4:	0adc      	bnez.n	a10, 420084d8 <vector_test_sum_f32+0xa8>
420084c6:	e0f1d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
420084c9:	e118c1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
420084cc:	97a2b2        	movi	a11, 0x297
420084cf:	e0eaa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420084d2:	df0d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420084d5:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
420084d8:	fe40e5        	call8	420068e8 <timer_start>
        assert(scalar_sum_f32(vec1, &scalar_sum) == VECTOR_SUCCESS);
420084db:	18c1b2        	addi	a11, a1, 24
420084de:	20a770        	or	a10, a7, a7
420084e1:	fe9ea5        	call8	42006ecc <scalar_sum_f32>
420084e4:	0a9c      	beqz.n	a10, 420084f8 <vector_test_sum_f32+0xc8>
420084e6:	e112d1        	l32r	a13, 42000930 <_stext+0x910> (3c024388 <_flash_rodata_start+0x4268>)
420084e9:	e110c1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
420084ec:	9aa2b2        	movi	a11, 0x29a
420084ef:	e0e2a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420084f2:	df0581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420084f5:	0008e0        	callx8	a8
        timer_end(&scalar_time);
420084f8:	14c1a2        	addi	a10, a1, 20
420084fb:	fe4125        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
420084fe:	fe3ea5        	call8	420068e8 <timer_start>
        assert(vec_sum_f32(vec1, &vector_sum) == VECTOR_SUCCESS);
42008501:	1cc1b2        	addi	a11, a1, 28
42008504:	07ad      	mov.n	a10, a7
42008506:	012425        	call8	42009748 <vec_sum_f32>
42008509:	0a9c      	beqz.n	a10, 4200851d <vector_test_sum_f32+0xed>
4200850b:	e10ad1        	l32r	a13, 42000934 <_stext+0x914> (3c0243bc <_flash_rodata_start+0x429c>)
4200850e:	e107c1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
42008511:	9ea2b2        	movi	a11, 0x29e
42008514:	e0d9a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008517:	defc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200851a:	0008e0        	callx8	a8
        timer_end(&vec_time); 
4200851d:	10c1a2        	addi	a10, a1, 16
42008520:	fe3ea5        	call8	4200690c <timer_end>
  
        if(!float_eq(vector_sum, scalar_sum)){
42008523:	61b8      	l32i.n	a11, a1, 24
42008525:	71a8      	l32i.n	a10, a1, 28
42008527:	00ce25        	call8	42009208 <float_eq>
4200852a:	045a56        	bnez	a10, 42008573 <vector_test_sum_f32+0x143>
            ESP_LOGE("vector_test_sum", "Sum mismatch: vector_sum: %f, scalar_sum: %f", vector_sum, scalar_sum);
4200852d:	decc81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008530:	0008e0        	callx8	a8
42008533:	0a7d      	mov.n	a7, a10
42008535:	e0fa61        	l32r	a6, 42000920 <_stext+0x900> (3c02433c <_flash_rodata_start+0x421c>)
42008538:	61a8      	l32i.n	a10, a1, 24
4200853a:	e10081        	l32r	a8, 4200093c <_stext+0x91c> (400022a4 <__extendsfdf2>)
4200853d:	0008e0        	callx8	a8
42008540:	21a9      	s32i.n	a10, a1, 8
42008542:	31b9      	s32i.n	a11, a1, 12
42008544:	71a8      	l32i.n	a10, a1, 28
42008546:	e0fd81        	l32r	a8, 4200093c <_stext+0x91c> (400022a4 <__extendsfdf2>)
42008549:	0008e0        	callx8	a8
4200854c:	01a9      	s32i.n	a10, a1, 0
4200854e:	11b9      	s32i.n	a11, a1, 4
42008550:	06ed      	mov.n	a14, a6
42008552:	07dd      	mov.n	a13, a7
42008554:	e0f9c1        	l32r	a12, 42000938 <_stext+0x918> (3c0243f0 <_flash_rodata_start+0x42d0>)
42008557:	06bd      	mov.n	a11, a6
42008559:	1a0c      	movi.n	a10, 1
4200855b:	dece81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200855e:	0008e0        	callx8	a8
            assert(0);
42008561:	e0f1d1        	l32r	a13, 42000928 <_stext+0x908> (3c0233b0 <_flash_rodata_start+0x3290>)
42008564:	e0f2c1        	l32r	a12, 4200092c <_stext+0x90c> (3c027494 <__func__$6>)
42008567:	a3a2b2        	movi	a11, 0x2a3
4200856a:	e0c3a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200856d:	dee681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008570:	0008e0        	callx8	a8
        }
        vector_check_canary(vec1);                                      // Check modification of canary region 
42008573:	07ad      	mov.n	a10, a7
42008575:	00bde5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
42008578:	07ad      	mov.n	a10, a7
4200857a:	00eca5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
4200857d:	05ad      	mov.n	a10, a5
4200857f:	00ec65        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008582:	661b      	addi.n	a6, a6, 1
42008584:	f83c      	movi.n	a8, 63
42008586:	022867        	blt	a8, a6, 4200858c <vector_test_sum_f32+0x15c>
42008589:	ffb3c6        	j	4200845c <vector_test_sum_f32+0x2c>
    } 
    timer_deinit();
4200858c:	fe3e65        	call8	42006974 <timer_deinit>
    if (verbose){
4200858f:	62bc      	beqz.n	a2, 420085c9 <vector_test_sum_f32+0x199>
            ESP_LOGI("vector_test_sum", "vector_time: %d", vec_time);
42008591:	360c      	movi.n	a6, 3
42008593:	deb381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008596:	0008e0        	callx8	a8
42008599:	e0e171        	l32r	a7, 42000920 <_stext+0x900> (3c02433c <_flash_rodata_start+0x421c>)
4200859c:	41f8      	l32i.n	a15, a1, 16
4200859e:	07ed      	mov.n	a14, a7
420085a0:	0add      	mov.n	a13, a10
420085a2:	e0bdc1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
420085a5:	20b770        	or	a11, a7, a7
420085a8:	06ad      	mov.n	a10, a6
420085aa:	deba81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420085ad:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_sum", "scalar_time: %d", scalar_time);
420085b0:	deac81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420085b3:	0008e0        	callx8	a8
420085b6:	51f8      	l32i.n	a15, a1, 20
420085b8:	07ed      	mov.n	a14, a7
420085ba:	0add      	mov.n	a13, a10
420085bc:	e0b8c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
420085bf:	07bd      	mov.n	a11, a7
420085c1:	06ad      	mov.n	a10, a6
420085c3:	deb481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420085c6:	0008e0        	callx8	a8
    }
}
420085c9:	f01d      	retw.n
	...

420085cc <vector_test_mul_scalar_shift>:

void vector_test_mul_scalar_shift(bool verbose, dtype type){  
420085cc:	008136        	entry	a1, 64
420085cf:	748020        	extui	a8, a2, 0, 8
420085d2:	076182        	s32i	a8, a1, 28
    timer_init();
420085d5:	fe2d25        	call8	420068a8 <timer_init>
    set_rand_seed();
420085d8:	00a1e5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420085db:	00a082        	movi	a8, 0
420085de:	0189      	s32i.n	a8, a1, 0
    uint32_t scalar_time = 0;
420085e0:	1189      	s32i.n	a8, a1, 4
    unsigned int rand_shift_amount;

    switch (type) {
420085e2:	638c      	beqz.n	a3, 420085ec <vector_test_mul_scalar_shift+0x20>
420085e4:	1d1326        	beqi	a3, 1, 42008605 <vector_test_mul_scalar_shift+0x39>
420085e7:	000cc6        	j	4200861e <vector_test_mul_scalar_shift+0x52>
420085ea:	810000        	src	a0, a0, a0
        case DTYPE_INT8:   rand_shift_amount = (rand() % 8);    break;
420085ed:	ad          	.byte	0xad
420085ee:	08e0e0        	lsx	f14, a0, a14
420085f1:	00          	.byte	00
420085f2:	318fa0        	srai	a8, a10, 31
420085f5:	258d80        	extui	a8, a8, 29, 3
420085f8:	aa8a      	add.n	a10, a10, a8
420085fa:	24a0a0        	extui	a10, a10, 0, 3
420085fd:	c08a80        	sub	a8, a10, a8
42008600:	6189      	s32i.n	a8, a1, 24
42008602:	000b86        	j	42008634 <vector_test_mul_scalar_shift+0x68>
        case DTYPE_INT16:  rand_shift_amount = (rand() % 16);   break;
42008605:	e0a681        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42008608:	0008e0        	callx8	a8
4200860b:	318fa0        	srai	a8, a10, 31
4200860e:	358c80        	extui	a8, a8, 28, 4
42008611:	aa8a      	add.n	a10, a10, a8
42008613:	34a0a0        	extui	a10, a10, 0, 4
42008616:	c08a80        	sub	a8, a10, a8
42008619:	6189      	s32i.n	a8, a1, 24
4200861b:	000546        	j	42008634 <vector_test_mul_scalar_shift+0x68>
        default:           rand_shift_amount = (rand() % 32);   break;
4200861e:	e0a081        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42008621:	0008e0        	callx8	a8
42008624:	318fa0        	srai	a8, a10, 31
42008627:	458b80        	extui	a8, a8, 27, 5
4200862a:	aa8a      	add.n	a10, a10, a8
4200862c:	44a0a0        	extui	a10, a10, 0, 5
4200862f:	c08a80        	sub	a8, a10, a8
42008632:	6189      	s32i.n	a8, a1, 24
    }

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008634:	020c      	movi.n	a2, 0
42008636:	005646        	j	42008793 <vector_test_mul_scalar_shift+0x1c7>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
42008639:	e09981        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
4200863c:	0008e0        	callx8	a8
4200863f:	318fa0        	srai	a8, a10, 31
42008642:	758880        	extui	a8, a8, 24, 8
42008645:	807a80        	add	a7, a10, a8
42008648:	747070        	extui	a7, a7, 0, 8
4200864b:	c07780        	sub	a7, a7, a8
4200864e:	01c772        	addi	a7, a7, 1
        int rand_scalar;
        if (type != DTYPE_FLOAT32) { rand_scalar = rand_scalar_val(type);}
42008651:	073326        	beqi	a3, 3, 4200865c <vector_test_mul_scalar_shift+0x90>
42008654:	20a330        	or	a10, a3, a3
42008657:	00b425        	call8	42009198 <rand_scalar_val>
4200865a:	51a9      	s32i.n	a10, a1, 20
        float rand_float = rand_float_val();
4200865c:	00b9a5        	call8	420091f8 <rand_float_val>
4200865f:	41a9      	s32i.n	a10, a1, 16
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors 
42008661:	03bd      	mov.n	a11, a3
42008663:	07ad      	mov.n	a10, a7
42008665:	009be5        	call8	42009024 <create_test_vector>
42008668:	0a7d      	mov.n	a7, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
4200866a:	1ab8      	l32i.n	a11, a10, 4
4200866c:	2aa8      	l32i.n	a10, a10, 8
4200866e:	009b65        	call8	42009024 <create_test_vector>
42008671:	0a6d      	mov.n	a6, a10
        vector_t *scalar_result = create_test_vector(vec1->size, vec1->type); 
42008673:	17b8      	l32i.n	a11, a7, 4
42008675:	27a8      	l32i.n	a10, a7, 8
42008677:	009ae5        	call8	42009024 <create_test_vector>
4200867a:	0a5d      	mov.n	a5, a10

        assert(vec1);                                                   // Check if valid 
4200867c:	07dc      	bnez.n	a7, 42008690 <vector_test_mul_scalar_shift+0xc4>
4200867e:	e07cd1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008681:	e0afc1        	l32r	a12, 42000940 <_stext+0x920> (3c027474 <__func__$5>)
42008684:	c8a2b2        	movi	a11, 0x2c8
42008687:	e07ca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200868a:	de9f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200868d:	0008e0        	callx8	a8
        assert(simd_result);
42008690:	06dc      	bnez.n	a6, 420086a4 <vector_test_mul_scalar_shift+0xd8>
42008692:	e07ad1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
42008695:	e0aac1        	l32r	a12, 42000940 <_stext+0x920> (3c027474 <__func__$5>)
42008698:	c9a2b2        	movi	a11, 0x2c9
4200869b:	e077a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200869e:	de9a81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420086a1:	0008e0        	callx8	a8
        assert(scalar_result);
420086a4:	0adc      	bnez.n	a10, 420086b8 <vector_test_mul_scalar_shift+0xec>
420086a6:	e076d1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
420086a9:	e0a5c1        	l32r	a12, 42000940 <_stext+0x920> (3c027474 <__func__$5>)
420086ac:	caa2b2        	movi	a11, 0x2ca
420086af:	e072a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420086b2:	de9581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420086b5:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
420086b8:	20a770        	or	a10, a7, a7
420086bb:	009da5        	call8	42009094 <fill_test_vector>
        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
420086be:	0127b2        	l32i	a11, a7, 4
420086c1:	27a8      	l32i.n	a10, a7, 8
420086c3:	00d325        	call8	420093f4 <vector_create>
420086c6:	0a4d      	mov.n	a4, a10
        assert(vec1_copy); 
420086c8:	0adc      	bnez.n	a10, 420086dc <vector_test_mul_scalar_shift+0x110>
420086ca:	e07ed1        	l32r	a13, 420008c4 <_stext+0x8a4> (3c02419c <_flash_rodata_start+0x407c>)
420086cd:	e09cc1        	l32r	a12, 42000940 <_stext+0x920> (3c027474 <__func__$5>)
420086d0:	cea2b2        	movi	a11, 0x2ce
420086d3:	e069a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420086d6:	de8c81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420086d9:	0008e0        	callx8	a8
        vec_copy(vec1, vec1_copy);  
420086dc:	20baa0        	or	a11, a10, a10
420086df:	20a770        	or	a10, a7, a7
420086e2:	013125        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
420086e5:	04bd      	mov.n	a11, a4
420086e7:	07ad      	mov.n	a10, a7
420086e9:	00b4e5        	call8	42009238 <vector_assert_eq>
420086ec:	0adc      	bnez.n	a10, 42008700 <vector_test_mul_scalar_shift+0x134>
420086ee:	e065d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
420086f1:	e093c1        	l32r	a12, 42000940 <_stext+0x920> (3c027474 <__func__$5>)
420086f4:	d1a2b2        	movi	a11, 0x2d1
420086f7:	e060a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420086fa:	de8381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420086fd:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
42008700:	07ad      	mov.n	a10, a7
42008702:	00a525        	call8	42009154 <vector_check_canary>
42008705:	0adc      	bnez.n	a10, 42008719 <vector_test_mul_scalar_shift+0x14d>
42008707:	e061d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
4200870a:	e08dc1        	l32r	a12, 42000940 <_stext+0x920> (3c027474 <__func__$5>)
4200870d:	d2a2b2        	movi	a11, 0x2d2
42008710:	e05aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008713:	de7d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008716:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42008719:	fe1ce5        	call8	420068e8 <timer_start>
        if (type == DTYPE_FLOAT32){
4200871c:	0c3366        	bnei	a3, 3, 4200872c <vector_test_mul_scalar_shift+0x160>
            scalar_mul_scalar_f32(vec1, rand_float, scalar_result);
4200871f:	05cd      	mov.n	a12, a5
42008721:	0421b2        	l32i	a11, a1, 16
42008724:	07ad      	mov.n	a10, a7
42008726:	0e22e5        	call8	42016954 <scalar_mul_scalar_f32>
42008729:	000286        	j	42008737 <vector_test_mul_scalar_shift+0x16b>
        } else{
            scalar_mul_scalar(vec1, rand_scalar, scalar_result, rand_shift_amount); 
4200872c:	61d8      	l32i.n	a13, a1, 24
4200872e:	05cd      	mov.n	a12, a5
42008730:	51b8      	l32i.n	a11, a1, 20
42008732:	07ad      	mov.n	a10, a7
42008734:	0e1065        	call8	4201683c <scalar_mul_scalar>
        }
        timer_end(&scalar_time);
42008737:	a14b      	addi.n	a10, a1, 4
42008739:	fe1d25        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
4200873c:	fe1aa5        	call8	420068e8 <timer_start>
        if (type == DTYPE_FLOAT32){
4200873f:	0d3366        	bnei	a3, 3, 42008750 <vector_test_mul_scalar_shift+0x184>
            vec_mul_scalar_f32(vec1, rand_float, simd_result);
42008742:	06cd      	mov.n	a12, a6
42008744:	41b8      	l32i.n	a11, a1, 16
42008746:	20a770        	or	a10, a7, a7
42008749:	010c65        	call8	42009810 <vec_mul_scalar_f32>
4200874c:	0002c6        	j	4200875b <vector_test_mul_scalar_shift+0x18f>
4200874f:	00          	.byte	00
        } else{
            vec_mul_scalar(vec1, rand_scalar, simd_result, rand_shift_amount); 
42008750:	61d8      	l32i.n	a13, a1, 24
42008752:	06cd      	mov.n	a12, a6
42008754:	51b8      	l32i.n	a11, a1, 20
42008756:	07ad      	mov.n	a10, a7
42008758:	010125        	call8	4200976c <vec_mul_scalar>
        }
        timer_end(&vec_time); 
4200875b:	01ad      	mov.n	a10, a1
4200875d:	fe1ae5        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42008760:	05bd      	mov.n	a11, a5
42008762:	06ad      	mov.n	a10, a6
42008764:	00ad25        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs 
42008767:	04bd      	mov.n	a11, a4
42008769:	07ad      	mov.n	a10, a7
4200876b:	00ace5        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region 
4200876e:	07ad      	mov.n	a10, a7
42008770:	009e25        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42008773:	06ad      	mov.n	a10, a6
42008775:	009de5        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42008778:	05ad      	mov.n	a10, a5
4200877a:	009da5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
4200877d:	07ad      	mov.n	a10, a7
4200877f:	00cc65        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
42008782:	04ad      	mov.n	a10, a4
42008784:	00cbe5        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
42008787:	06ad      	mov.n	a10, a6
42008789:	00cba5        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
4200878c:	05ad      	mov.n	a10, a5
4200878e:	00cb65        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008791:	221b      	addi.n	a2, a2, 1
42008793:	f83c      	movi.n	a8, 63
42008795:	022827        	blt	a8, a2, 4200879b <vector_test_mul_scalar_shift+0x1cf>
42008798:	ffa746        	j	42008639 <vector_test_mul_scalar_shift+0x6d>
    } 
    timer_deinit();
4200879b:	fe1da5        	call8	42006974 <timer_deinit>
    if (verbose){
4200879e:	7188      	l32i.n	a8, a1, 28
420087a0:	58bc      	beqz.n	a8, 420087d9 <vector_test_mul_scalar_shift+0x20d>
            ESP_LOGI("vector_test_mul_scalar", "vector_time: %d", vec_time);
420087a2:	360c      	movi.n	a6, 3
420087a4:	de2f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420087a7:	0008e0        	callx8	a8
420087aa:	e06671        	l32r	a7, 42000944 <_stext+0x924> (3c02442c <_flash_rodata_start+0x430c>)
420087ad:	01f8      	l32i.n	a15, a1, 0
420087af:	07ed      	mov.n	a14, a7
420087b1:	0add      	mov.n	a13, a10
420087b3:	e039c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
420087b6:	07bd      	mov.n	a11, a7
420087b8:	06ad      	mov.n	a10, a6
420087ba:	de3681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420087bd:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_mul_scalar", "scalar_time: %d", scalar_time);
420087c0:	de2881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420087c3:	0008e0        	callx8	a8
420087c6:	11f8      	l32i.n	a15, a1, 4
420087c8:	07ed      	mov.n	a14, a7
420087ca:	0add      	mov.n	a13, a10
420087cc:	e034c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
420087cf:	07bd      	mov.n	a11, a7
420087d1:	06ad      	mov.n	a10, a6
420087d3:	de3081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420087d6:	0008e0        	callx8	a8
    }
} 
420087d9:	f01d      	retw.n
	...

420087dc <vector_test_dotp>:

void vector_test_dotp(bool verbose, dtype type){ 
420087dc:	008136        	entry	a1, 64
420087df:	748020        	extui	a8, a2, 0, 8
420087e2:	046182        	s32i	a8, a1, 16

    timer_init();
420087e5:	fe0c25        	call8	420068a8 <timer_init>
    set_rand_seed();
420087e8:	0080e5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420087eb:	00a052        	movi	a5, 0
420087ee:	0159      	s32i.n	a5, a1, 0
    uint32_t scalar_time = 0;
420087f0:	1159      	s32i.n	a5, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420087f2:	006106        	j	4200897a <vector_test_dotp+0x19e>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
420087f5:	e02a81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420087f8:	0008e0        	callx8	a8
420087fb:	318fa0        	srai	a8, a10, 31
420087fe:	758880        	extui	a8, a8, 24, 8
42008801:	806a80        	add	a6, a10, a8
42008804:	746060        	extui	a6, a6, 0, 8
42008807:	c06680        	sub	a6, a6, a8
4200880a:	01c662        	addi	a6, a6, 1
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors
4200880d:	03bd      	mov.n	a11, a3
4200880f:	06ad      	mov.n	a10, a6
42008811:	008125        	call8	42009024 <create_test_vector>
42008814:	0a7d      	mov.n	a7, a10
        vector_t *vec2 = create_test_vector(test_size, type); 
42008816:	03bd      	mov.n	a11, a3
42008818:	06ad      	mov.n	a10, a6
4200881a:	0080a5        	call8	42009024 <create_test_vector>
4200881d:	0a6d      	mov.n	a6, a10
        int32_t scalar_result = 0xDEADBEEF;
4200881f:	e04a81        	l32r	a8, 42000948 <_stext+0x928> (deadbeef <_rtc_reserved_end+0x7e9dbeef>)
42008822:	3189      	s32i.n	a8, a1, 12
        int32_t simd_result = 0xDEADBEEF;
42008824:	2189      	s32i.n	a8, a1, 8

        assert(vec1);                                                   // Check if valid
42008826:	07dc      	bnez.n	a7, 4200883a <vector_test_dotp+0x5e>
42008828:	e012d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
4200882b:	e048c1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
4200882e:	05a3b2        	movi	a11, 0x305
42008831:	e011a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008834:	de3581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008837:	0008e0        	callx8	a8
        assert(vec2); 
4200883a:	0adc      	bnez.n	a10, 4200884e <vector_test_dotp+0x72>
4200883c:	e034d1        	l32r	a13, 4200090c <_stext+0x8ec> (3c0242cc <_flash_rodata_start+0x41ac>)
4200883f:	e043c1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
42008842:	06a3b2        	movi	a11, 0x306
42008845:	e00ca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008848:	de3081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200884b:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range
4200884e:	20a770        	or	a10, a7, a7
42008851:	008425        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2); 
42008854:	06ad      	mov.n	a10, a6
42008856:	0083e5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs)
42008859:	17b8      	l32i.n	a11, a7, 4
4200885b:	27a8      	l32i.n	a10, a7, 8
4200885d:	00b965        	call8	420093f4 <vector_create>
42008860:	0a4d      	mov.n	a4, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type); 
42008862:	16b8      	l32i.n	a11, a6, 4
42008864:	26a8      	l32i.n	a10, a6, 8
42008866:	00b8e5        	call8	420093f4 <vector_create>
42008869:	0a2d      	mov.n	a2, a10
        vec_copy(vec1, vec1_copy); 
4200886b:	04bd      	mov.n	a11, a4
4200886d:	07ad      	mov.n	a10, a7
4200886f:	011865        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);  
42008872:	02bd      	mov.n	a11, a2
42008874:	06ad      	mov.n	a10, a6
42008876:	0117e5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions
42008879:	04bd      	mov.n	a11, a4
4200887b:	07ad      	mov.n	a10, a7
4200887d:	009ba5        	call8	42009238 <vector_assert_eq>
42008880:	0adc      	bnez.n	a10, 42008894 <vector_test_dotp+0xb8>
42008882:	e000d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42008885:	e031c1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
42008888:	10a3b2        	movi	a11, 0x310
4200888b:	dffba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
4200888e:	de1e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008891:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
42008894:	20b220        	or	a11, a2, a2
42008897:	20a660        	or	a10, a6, a6
4200889a:	0099e5        	call8	42009238 <vector_assert_eq>
4200889d:	011a56        	bnez	a10, 420088b2 <vector_test_dotp+0xd6>
420088a0:	dffad1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
420088a3:	e02ac1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
420088a6:	11a3b2        	movi	a11, 0x311
420088a9:	dff3a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420088ac:	de1781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420088af:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
420088b2:	07ad      	mov.n	a10, a7
420088b4:	201110        	or	a1, a1, a1
420088b7:	0089e5        	call8	42009154 <vector_check_canary>
420088ba:	0adc      	bnez.n	a10, 420088ce <vector_test_dotp+0xf2>
420088bc:	dff4d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
420088bf:	e023c1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
420088c2:	12a3b2        	movi	a11, 0x312
420088c5:	dfeca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420088c8:	de1081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420088cb:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
420088ce:	20a660        	or	a10, a6, a6
420088d1:	008825        	call8	42009154 <vector_check_canary>
420088d4:	0adc      	bnez.n	a10, 420088e8 <vector_test_dotp+0x10c>
420088d6:	dfeed1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
420088d9:	e01cc1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
420088dc:	13a3b2        	movi	a11, 0x313
420088df:	dfe6a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
420088e2:	de0981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420088e5:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
420088e8:	fdffe5        	call8	420068e8 <timer_start>
        assert(scalar_dotp(vec1, vec2, &scalar_result) == VECTOR_SUCCESS);
420088eb:	c1cb      	addi.n	a12, a1, 12
420088ed:	06bd      	mov.n	a11, a6
420088ef:	07ad      	mov.n	a10, a7
420088f1:	0e0ae5        	call8	420169a0 <scalar_dotp>
420088f4:	0a9c      	beqz.n	a10, 42008908 <vector_test_dotp+0x12c>
420088f6:	e016d1        	l32r	a13, 42000950 <_stext+0x930> (3c024444 <_flash_rodata_start+0x4324>)
420088f9:	e014c1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
420088fc:	16a3b2        	movi	a11, 0x316
420088ff:	dfdea1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008902:	de0181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008905:	0008e0        	callx8	a8
        timer_end(&scalar_time);
42008908:	04c1a2        	addi	a10, a1, 4
4200890b:	fe0025        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
4200890e:	fdfda5        	call8	420068e8 <timer_start>
        assert(vec_dotp(vec1, vec2, &simd_result) == VECTOR_SUCCESS);
42008911:	c18b      	addi.n	a12, a1, 8
42008913:	06bd      	mov.n	a11, a6
42008915:	07ad      	mov.n	a10, a7
42008917:	00f3a5        	call8	42009850 <vec_dotp>
4200891a:	0a9c      	beqz.n	a10, 4200892e <vector_test_dotp+0x152>
4200891c:	e00ed1        	l32r	a13, 42000954 <_stext+0x934> (3c024480 <_flash_rodata_start+0x4360>)
4200891f:	e00bc1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
42008922:	1aa3b2        	movi	a11, 0x31a
42008925:	dfd4a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008928:	ddf881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200892b:	0008e0        	callx8	a8
        timer_end(&vec_time); 
4200892e:	01ad      	mov.n	a10, a1
42008930:	fdfda5        	call8	4200690c <timer_end>
 
        assert( scalar_result == simd_result);
42008933:	3198      	l32i.n	a9, a1, 12
42008935:	2188      	l32i.n	a8, a1, 8
42008937:	111987        	beq	a9, a8, 4200894c <vector_test_dotp+0x170>
4200893a:	e007d1        	l32r	a13, 42000958 <_stext+0x938> (3c0244b8 <_flash_rodata_start+0x4398>)
4200893d:	e003c1        	l32r	a12, 4200094c <_stext+0x92c> (3c027460 <__func__$4>)
42008940:	1da3b2        	movi	a11, 0x31d
42008943:	dfcda1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008946:	ddf081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008949:	0008e0        	callx8	a8
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs
4200894c:	04bd      	mov.n	a11, a4
4200894e:	07ad      	mov.n	a10, a7
42008950:	008e65        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec2, vec2_copy);
42008953:	02bd      	mov.n	a11, a2
42008955:	06ad      	mov.n	a10, a6
42008957:	008e25        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region
4200895a:	07ad      	mov.n	a10, a7
4200895c:	007f65        	call8	42009154 <vector_check_canary>
        vector_check_canary(vec2); 
4200895f:	06ad      	mov.n	a10, a6
42008961:	007f25        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources
42008964:	07ad      	mov.n	a10, a7
42008966:	00ade5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
42008969:	06ad      	mov.n	a10, a6
4200896b:	00ada5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
4200896e:	04ad      	mov.n	a10, a4
42008970:	00ad25        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy); 
42008973:	02ad      	mov.n	a10, a2
42008975:	00ace5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008978:	551b      	addi.n	a5, a5, 1
4200897a:	f83c      	movi.n	a8, 63
4200897c:	022857        	blt	a8, a5, 42008982 <vector_test_dotp+0x1a6>
4200897f:	ff9c86        	j	420087f5 <vector_test_dotp+0x19>
    } 
    timer_deinit();
42008982:	fdff25        	call8	42006974 <timer_deinit>
    if (verbose){
42008985:	4188      	l32i.n	a8, a1, 16
42008987:	68bc      	beqz.n	a8, 420089c1 <vector_test_dotp+0x1e5>
            ESP_LOGI("vector_test_dotp", "vector_time: %d", vec_time);
42008989:	360c      	movi.n	a6, 3
4200898b:	ddb581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200898e:	0008e0        	callx8	a8
42008991:	dff271        	l32r	a7, 4200095c <_stext+0x93c> (3c0244d8 <_flash_rodata_start+0x43b8>)
42008994:	01f8      	l32i.n	a15, a1, 0
42008996:	07ed      	mov.n	a14, a7
42008998:	0add      	mov.n	a13, a10
4200899a:	dfbfc1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
4200899d:	20b770        	or	a11, a7, a7
420089a0:	06ad      	mov.n	a10, a6
420089a2:	ddbc81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420089a5:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_dotp", "scalar_time: %d", scalar_time);
420089a8:	ddae81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420089ab:	0008e0        	callx8	a8
420089ae:	11f8      	l32i.n	a15, a1, 4
420089b0:	07ed      	mov.n	a14, a7
420089b2:	0add      	mov.n	a13, a10
420089b4:	dfbac1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
420089b7:	07bd      	mov.n	a11, a7
420089b9:	06ad      	mov.n	a10, a6
420089bb:	ddb681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420089be:	0008e0        	callx8	a8
    }
}
420089c1:	f01d      	retw.n
	...

420089c4 <vector_test_dotp_f32>:

void vector_test_dotp_f32(bool verbose, dtype type){ 
420089c4:	008136        	entry	a1, 64
420089c7:	748020        	extui	a8, a2, 0, 8
420089ca:	046182        	s32i	a8, a1, 16

    timer_init();
420089cd:	fdeda5        	call8	420068a8 <timer_init>
    set_rand_seed();
420089d0:	006265        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
420089d3:	00a052        	movi	a5, 0
420089d6:	0159      	s32i.n	a5, a1, 0
    uint32_t scalar_time = 0;
420089d8:	1159      	s32i.n	a5, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
420089da:	006086        	j	42008b60 <vector_test_dotp_f32+0x19c>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
420089dd:	dfb081        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420089e0:	0008e0        	callx8	a8
420089e3:	318fa0        	srai	a8, a10, 31
420089e6:	758880        	extui	a8, a8, 24, 8
420089e9:	806a80        	add	a6, a10, a8
420089ec:	746060        	extui	a6, a6, 0, 8
420089ef:	c06680        	sub	a6, a6, a8
420089f2:	01c662        	addi	a6, a6, 1
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors
420089f5:	03bd      	mov.n	a11, a3
420089f7:	20a660        	or	a10, a6, a6
420089fa:	0062a5        	call8	42009024 <create_test_vector>
420089fd:	0a7d      	mov.n	a7, a10
        vector_t *vec2 = create_test_vector(test_size, type); 
420089ff:	03bd      	mov.n	a11, a3
42008a01:	06ad      	mov.n	a10, a6
42008a03:	006225        	call8	42009024 <create_test_vector>
42008a06:	0a6d      	mov.n	a6, a10
        float scalar_result;
        float simd_result;

        assert(vec1);                                                   // Check if valid
42008a08:	07dc      	bnez.n	a7, 42008a1c <vector_test_dotp_f32+0x58>
42008a0a:	df99d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008a0d:	dfd4c1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008a10:	3ea3b2        	movi	a11, 0x33e
42008a13:	df99a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008a16:	ddbc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008a19:	0008e0        	callx8	a8
        assert(vec2); 
42008a1c:	0adc      	bnez.n	a10, 42008a30 <vector_test_dotp_f32+0x6c>
42008a1e:	dfbbd1        	l32r	a13, 4200090c <_stext+0x8ec> (3c0242cc <_flash_rodata_start+0x41ac>)
42008a21:	dfcfc1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008a24:	3fa3b2        	movi	a11, 0x33f
42008a27:	df94a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008a2a:	ddb781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008a2d:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range
42008a30:	20a770        	or	a10, a7, a7
42008a33:	006625        	call8	42009094 <fill_test_vector>
        fill_test_vector(vec2); 
42008a36:	06ad      	mov.n	a10, a6
42008a38:	0065a5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs)
42008a3b:	17b8      	l32i.n	a11, a7, 4
42008a3d:	27a8      	l32i.n	a10, a7, 8
42008a3f:	009b65        	call8	420093f4 <vector_create>
42008a42:	0a4d      	mov.n	a4, a10
        vector_t *vec2_copy = vector_create(vec2->size, vec2->type); 
42008a44:	16b8      	l32i.n	a11, a6, 4
42008a46:	26a8      	l32i.n	a10, a6, 8
42008a48:	009aa5        	call8	420093f4 <vector_create>
42008a4b:	0a2d      	mov.n	a2, a10
        vec_copy(vec1, vec1_copy); 
42008a4d:	04bd      	mov.n	a11, a4
42008a4f:	07ad      	mov.n	a10, a7
42008a51:	00fa25        	call8	420099f4 <vec_copy>
        vec_copy(vec2, vec2_copy);  
42008a54:	02bd      	mov.n	a11, a2
42008a56:	06ad      	mov.n	a10, a6
42008a58:	00f9a5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions
42008a5b:	04bd      	mov.n	a11, a4
42008a5d:	07ad      	mov.n	a10, a7
42008a5f:	007da5        	call8	42009238 <vector_assert_eq>
42008a62:	0adc      	bnez.n	a10, 42008a76 <vector_test_dotp_f32+0xb2>
42008a64:	df88d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42008a67:	dfbec1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008a6a:	49a3b2        	movi	a11, 0x349
42008a6d:	df82a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008a70:	dda681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008a73:	0008e0        	callx8	a8
        assert(vector_assert_eq(vec2, vec2_copy));
42008a76:	20b220        	or	a11, a2, a2
42008a79:	20a660        	or	a10, a6, a6
42008a7c:	007ba5        	call8	42009238 <vector_assert_eq>
42008a7f:	011a56        	bnez	a10, 42008a94 <vector_test_dotp_f32+0xd0>
42008a82:	df81d1        	l32r	a13, 42000888 <_stext+0x868> (3c024090 <_flash_rodata_start+0x3f70>)
42008a85:	dfb6c1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008a88:	4aa3b2        	movi	a11, 0x34a
42008a8b:	df7ba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008a8e:	dd9e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008a91:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1));
42008a94:	07ad      	mov.n	a10, a7
42008a96:	006be5        	call8	42009154 <vector_check_canary>
42008a99:	0adc      	bnez.n	a10, 42008aad <vector_test_dotp_f32+0xe9>
42008a9b:	df7cd1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42008a9e:	dfb0c1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008aa1:	4ba3b2        	movi	a11, 0x34b
42008aa4:	df75a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008aa7:	dd9881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008aaa:	0008e0        	callx8	a8
        assert(vector_check_canary(vec2));
42008aad:	06ad      	mov.n	a10, a6
42008aaf:	201110        	or	a1, a1, a1
42008ab2:	006a25        	call8	42009154 <vector_check_canary>
42008ab5:	0adc      	bnez.n	a10, 42008ac9 <vector_test_dotp_f32+0x105>
42008ab7:	df76d1        	l32r	a13, 42000890 <_stext+0x870> (3c0240d0 <_flash_rodata_start+0x3fb0>)
42008aba:	dfa9c1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008abd:	4ca3b2        	movi	a11, 0x34c
42008ac0:	df6ea1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008ac3:	dd9181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008ac6:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42008ac9:	fde1e5        	call8	420068e8 <timer_start>
        assert(scalar_dotp_f32(vec1, vec2, &scalar_result) == VECTOR_SUCCESS);
42008acc:	c1cb      	addi.n	a12, a1, 12
42008ace:	20b660        	or	a11, a6, a6
42008ad1:	07ad      	mov.n	a10, a7
42008ad3:	0df8e5        	call8	42016a60 <scalar_dotp_f32>
42008ad6:	0a9c      	beqz.n	a10, 42008aea <vector_test_dotp_f32+0x126>
42008ad8:	dfa3d1        	l32r	a13, 42000964 <_stext+0x944> (3c0244ec <_flash_rodata_start+0x43cc>)
42008adb:	dfa1c1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008ade:	4fa3b2        	movi	a11, 0x34f
42008ae1:	df65a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008ae4:	dd8981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008ae7:	0008e0        	callx8	a8
        timer_end(&scalar_time);
42008aea:	04c1a2        	addi	a10, a1, 4
42008aed:	fde1e5        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42008af0:	fddf65        	call8	420068e8 <timer_start>
        assert(vec_dotp_f32(vec1, vec2, &simd_result) == VECTOR_SUCCESS);
42008af3:	c18b      	addi.n	a12, a1, 8
42008af5:	06bd      	mov.n	a11, a6
42008af7:	07ad      	mov.n	a10, a7
42008af9:	00dc25        	call8	420098bc <vec_dotp_f32>
42008afc:	0a9c      	beqz.n	a10, 42008b10 <vector_test_dotp_f32+0x14c>
42008afe:	df9ad1        	l32r	a13, 42000968 <_stext+0x948> (3c02452c <_flash_rodata_start+0x440c>)
42008b01:	df97c1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008b04:	53a3b2        	movi	a11, 0x353
42008b07:	df5ca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008b0a:	dd7f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008b0d:	0008e0        	callx8	a8
        timer_end(&vec_time); 
42008b10:	20a110        	or	a10, a1, a1
42008b13:	fddfa5        	call8	4200690c <timer_end>
 
        assert(float_eq(scalar_result, simd_result));
42008b16:	0221b2        	l32i	a11, a1, 8
42008b19:	31a8      	l32i.n	a10, a1, 12
42008b1b:	006ee5        	call8	42009208 <float_eq>
42008b1e:	0adc      	bnez.n	a10, 42008b32 <vector_test_dotp_f32+0x16e>
42008b20:	df93d1        	l32r	a13, 4200096c <_stext+0x94c> (3c024568 <_flash_rodata_start+0x4448>)
42008b23:	df8fc1        	l32r	a12, 42000960 <_stext+0x940> (3c027448 <__func__$3>)
42008b26:	56a3b2        	movi	a11, 0x356
42008b29:	df53a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008b2c:	dd7781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008b2f:	0008e0        	callx8	a8
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs
42008b32:	04bd      	mov.n	a11, a4
42008b34:	07ad      	mov.n	a10, a7
42008b36:	007025        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec2, vec2_copy);
42008b39:	02bd      	mov.n	a11, a2
42008b3b:	06ad      	mov.n	a10, a6
42008b3d:	006fa5        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region
42008b40:	07ad      	mov.n	a10, a7
42008b42:	006125        	call8	42009154 <vector_check_canary>
        vector_check_canary(vec2); 
42008b45:	06ad      	mov.n	a10, a6
42008b47:	0060e5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources
42008b4a:	07ad      	mov.n	a10, a7
42008b4c:	008f65        	call8	42009444 <vector_destroy>
        vector_destroy(vec2);
42008b4f:	06ad      	mov.n	a10, a6
42008b51:	008f25        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy);
42008b54:	04ad      	mov.n	a10, a4
42008b56:	008ee5        	call8	42009444 <vector_destroy>
        vector_destroy(vec2_copy); 
42008b59:	02ad      	mov.n	a10, a2
42008b5b:	008ea5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008b5e:	551b      	addi.n	a5, a5, 1
42008b60:	3fa082        	movi	a8, 63
42008b63:	022857        	blt	a8, a5, 42008b69 <vector_test_dotp_f32+0x1a5>
42008b66:	ff9cc6        	j	420089dd <vector_test_dotp_f32+0x19>
    } 
    timer_deinit();
42008b69:	fde0a5        	call8	42006974 <timer_deinit>
    if (verbose){
42008b6c:	4188      	l32i.n	a8, a1, 16
42008b6e:	78bc      	beqz.n	a8, 42008ba9 <vector_test_dotp_f32+0x1e5>
            ESP_LOGI("vector_test_dotp", "vector_time: %d", vec_time);
42008b70:	360c      	movi.n	a6, 3
42008b72:	dd3b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008b75:	0008e0        	callx8	a8
42008b78:	df7971        	l32r	a7, 4200095c <_stext+0x93c> (3c0244d8 <_flash_rodata_start+0x43b8>)
42008b7b:	01f8      	l32i.n	a15, a1, 0
42008b7d:	07ed      	mov.n	a14, a7
42008b7f:	20daa0        	or	a13, a10, a10
42008b82:	df45c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42008b85:	20b770        	or	a11, a7, a7
42008b88:	06ad      	mov.n	a10, a6
42008b8a:	dd4281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008b8d:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_dotp", "scalar_time: %d", scalar_time);
42008b90:	dd3481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008b93:	0008e0        	callx8	a8
42008b96:	11f8      	l32i.n	a15, a1, 4
42008b98:	07ed      	mov.n	a14, a7
42008b9a:	0add      	mov.n	a13, a10
42008b9c:	df40c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008b9f:	07bd      	mov.n	a11, a7
42008ba1:	06ad      	mov.n	a10, a6
42008ba3:	dd3c81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008ba6:	0008e0        	callx8	a8
    }
}
42008ba9:	f01d      	retw.n
	...

42008bac <vector_test_abs>:

void vector_test_abs(bool verbose, dtype type){  
42008bac:	008136        	entry	a1, 64
42008baf:	748020        	extui	a8, a2, 0, 8
42008bb2:	046182        	s32i	a8, a1, 16
    timer_init();
42008bb5:	fdcf25        	call8	420068a8 <timer_init>
    set_rand_seed();
42008bb8:	0043e5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
42008bbb:	00a022        	movi	a2, 0
42008bbe:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0;
42008bc0:	1129      	s32i.n	a2, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008bc2:	004186        	j	42008ccc <vector_test_abs+0x120>
        int test_size = 1 + rand() % MAX_SIZE;                              // Random vector sizes 
42008bc5:	df3681        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42008bc8:	0008e0        	callx8	a8
42008bcb:	318fa0        	srai	a8, a10, 31
42008bce:	758880        	extui	a8, a8, 24, 8
42008bd1:	80aa80        	add	a10, a10, a8
42008bd4:	74a0a0        	extui	a10, a10, 0, 8
42008bd7:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors 
42008bda:	20b330        	or	a11, a3, a3
42008bdd:	aa1b      	addi.n	a10, a10, 1
42008bdf:	004465        	call8	42009024 <create_test_vector>
42008be2:	0a7d      	mov.n	a7, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42008be4:	1ab8      	l32i.n	a11, a10, 4
42008be6:	2aa8      	l32i.n	a10, a10, 8
42008be8:	0043a5        	call8	42009024 <create_test_vector>
42008beb:	0a6d      	mov.n	a6, a10
        vector_t *scalar_result = create_test_vector(vec1->size, vec1->type); 
42008bed:	17b8      	l32i.n	a11, a7, 4
42008bef:	27a8      	l32i.n	a10, a7, 8
42008bf1:	004325        	call8	42009024 <create_test_vector>
42008bf4:	0a5d      	mov.n	a5, a10

        assert(vec1);                                                   // Check if valid 
42008bf6:	07dc      	bnez.n	a7, 42008c0a <vector_test_abs+0x5e>
42008bf8:	df1ed1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008bfb:	df5dc1        	l32r	a12, 42000970 <_stext+0x950> (3c027438 <__func__$2>)
42008bfe:	75a3b2        	movi	a11, 0x375
42008c01:	df1da1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008c04:	dd4181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008c07:	0008e0        	callx8	a8
        assert(simd_result);
42008c0a:	06dc      	bnez.n	a6, 42008c1e <vector_test_abs+0x72>
42008c0c:	df1cd1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
42008c0f:	df58c1        	l32r	a12, 42000970 <_stext+0x950> (3c027438 <__func__$2>)
42008c12:	76a3b2        	movi	a11, 0x376
42008c15:	df18a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008c18:	dd3c81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008c1b:	0008e0        	callx8	a8
        assert(scalar_result);
42008c1e:	0adc      	bnez.n	a10, 42008c32 <vector_test_abs+0x86>
42008c20:	df18d1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
42008c23:	df53c1        	l32r	a12, 42000970 <_stext+0x950> (3c027438 <__func__$2>)
42008c26:	77a3b2        	movi	a11, 0x377
42008c29:	df13a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008c2c:	dd3781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008c2f:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
42008c32:	07ad      	mov.n	a10, a7
42008c34:	0045e5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
42008c37:	17b8      	l32i.n	a11, a7, 4
42008c39:	27a8      	l32i.n	a10, a7, 8
42008c3b:	007ba5        	call8	420093f4 <vector_create>
42008c3e:	0a4d      	mov.n	a4, a10
        vec_copy(vec1, vec1_copy);  
42008c40:	0abd      	mov.n	a11, a10
42008c42:	07ad      	mov.n	a10, a7
42008c44:	00dae5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
42008c47:	04bd      	mov.n	a11, a4
42008c49:	07ad      	mov.n	a10, a7
42008c4b:	005ee5        	call8	42009238 <vector_assert_eq>
42008c4e:	0adc      	bnez.n	a10, 42008c62 <vector_test_abs+0xb6>
42008c50:	df0dd1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42008c53:	df47c1        	l32r	a12, 42000970 <_stext+0x950> (3c027438 <__func__$2>)
42008c56:	7ea3b2        	movi	a11, 0x37e
42008c59:	df07a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008c5c:	dd2b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008c5f:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
42008c62:	07ad      	mov.n	a10, a7
42008c64:	004ee5        	call8	42009154 <vector_check_canary>
42008c67:	0adc      	bnez.n	a10, 42008c7b <vector_test_abs+0xcf>
42008c69:	df08d1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42008c6c:	df41c1        	l32r	a12, 42000970 <_stext+0x950> (3c027438 <__func__$2>)
42008c6f:	7fa3b2        	movi	a11, 0x37f
42008c72:	df01a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008c75:	dd2481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008c78:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42008c7b:	fdc6e5        	call8	420068e8 <timer_start>
        scalar_abs(vec1, scalar_result);
42008c7e:	05bd      	mov.n	a11, a5
42008c80:	07ad      	mov.n	a10, a7
42008c82:	fe2865        	call8	42006f08 <scalar_abs>
        timer_end(&scalar_time);
42008c85:	a14b      	addi.n	a10, a1, 4
42008c87:	fdc865        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42008c8a:	fdc5e5        	call8	420068e8 <timer_start>
        vec_abs(vec1, simd_result);
42008c8d:	06bd      	mov.n	a11, a6
42008c8f:	07ad      	mov.n	a10, a7
42008c91:	00c665        	call8	420098f8 <vec_abs>
        timer_end(&vec_time); 
42008c94:	01ad      	mov.n	a10, a1
42008c96:	fdc765        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42008c99:	05bd      	mov.n	a11, a5
42008c9b:	06ad      	mov.n	a10, a6
42008c9d:	0059a5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs 
42008ca0:	04bd      	mov.n	a11, a4
42008ca2:	07ad      	mov.n	a10, a7
42008ca4:	005925        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region 
42008ca7:	07ad      	mov.n	a10, a7
42008ca9:	004aa5        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42008cac:	06ad      	mov.n	a10, a6
42008cae:	004a65        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42008cb1:	05ad      	mov.n	a10, a5
42008cb3:	004a25        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
42008cb6:	07ad      	mov.n	a10, a7
42008cb8:	0078a5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
42008cbb:	04ad      	mov.n	a10, a4
42008cbd:	007865        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
42008cc0:	06ad      	mov.n	a10, a6
42008cc2:	007825        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42008cc5:	05ad      	mov.n	a10, a5
42008cc7:	0077e5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008cca:	221b      	addi.n	a2, a2, 1
42008ccc:	3fa082        	movi	a8, 63
42008ccf:	022827        	blt	a8, a2, 42008cd5 <vector_test_abs+0x129>
42008cd2:	ffbbc6        	j	42008bc5 <vector_test_abs+0x19>
    } 
    timer_deinit();
42008cd5:	fdc9e5        	call8	42006974 <timer_deinit>
    if (verbose){
42008cd8:	4188      	l32i.n	a8, a1, 16
42008cda:	78bc      	beqz.n	a8, 42008d15 <vector_test_abs+0x169>
            ESP_LOGI("vector_test_abs", "vector_time: %d", vec_time);
42008cdc:	360c      	movi.n	a6, 3
42008cde:	dce081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008ce1:	0008e0        	callx8	a8
42008ce4:	df2471        	l32r	a7, 42000974 <_stext+0x954> (3c024590 <_flash_rodata_start+0x4470>)
42008ce7:	01f8      	l32i.n	a15, a1, 0
42008ce9:	07ed      	mov.n	a14, a7
42008ceb:	20daa0        	or	a13, a10, a10
42008cee:	deeac1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42008cf1:	20b770        	or	a11, a7, a7
42008cf4:	06ad      	mov.n	a10, a6
42008cf6:	dce781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008cf9:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_abs", "scalar_time: %d", scalar_time);
42008cfc:	dcd981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008cff:	0008e0        	callx8	a8
42008d02:	11f8      	l32i.n	a15, a1, 4
42008d04:	07ed      	mov.n	a14, a7
42008d06:	0add      	mov.n	a13, a10
42008d08:	dee5c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008d0b:	07bd      	mov.n	a11, a7
42008d0d:	06ad      	mov.n	a10, a6
42008d0f:	dce181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008d12:	0008e0        	callx8	a8
    }
}
42008d15:	f01d      	retw.n
	...

42008d18 <vector_test_ceil>:

void vector_test_ceil(bool verbose, dtype type){  
42008d18:	008136        	entry	a1, 64
42008d1b:	748020        	extui	a8, a2, 0, 8
42008d1e:	056182        	s32i	a8, a1, 20
    timer_init();
42008d21:	fdb865        	call8	420068a8 <timer_init>
    set_rand_seed();
42008d24:	002d25        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
42008d27:	00a022        	movi	a2, 0
42008d2a:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0;
42008d2c:	1129      	s32i.n	a2, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008d2e:	004406        	j	42008e42 <vector_test_ceil+0x12a>
        int test_size = 1 + rand() % MAX_SIZE;                          // Random vector sizes 
42008d31:	dedb81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42008d34:	0008e0        	callx8	a8
42008d37:	318fa0        	srai	a8, a10, 31
42008d3a:	758880        	extui	a8, a8, 24, 8
42008d3d:	aa8a      	add.n	a10, a10, a8
42008d3f:	74a0a0        	extui	a10, a10, 0, 8
42008d42:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors 
42008d45:	20b330        	or	a11, a3, a3
42008d48:	aa1b      	addi.n	a10, a10, 1
42008d4a:	002da5        	call8	42009024 <create_test_vector>
42008d4d:	0a7d      	mov.n	a7, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42008d4f:	1ab8      	l32i.n	a11, a10, 4
42008d51:	2aa8      	l32i.n	a10, a10, 8
42008d53:	002d25        	call8	42009024 <create_test_vector>
42008d56:	0a6d      	mov.n	a6, a10
        vector_t *scalar_result = create_test_vector(vec1->size, vec1->type); 
42008d58:	17b8      	l32i.n	a11, a7, 4
42008d5a:	27a8      	l32i.n	a10, a7, 8
42008d5c:	002c65        	call8	42009024 <create_test_vector>
42008d5f:	0a5d      	mov.n	a5, a10
        int rand_scalar = rand_scalar_val(type);
42008d61:	03ad      	mov.n	a10, a3
42008d63:	004365        	call8	42009198 <rand_scalar_val>
42008d66:	41a9      	s32i.n	a10, a1, 16

        assert(vec1);                                                   // Check if valid 
42008d68:	07dc      	bnez.n	a7, 42008d7c <vector_test_ceil+0x64>
42008d6a:	dec1d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008d6d:	df02c1        	l32r	a12, 42000978 <_stext+0x958> (3c027424 <__func__$1>)
42008d70:	a9a3b2        	movi	a11, 0x3a9
42008d73:	dec1a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008d76:	dce481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008d79:	0008e0        	callx8	a8
        assert(simd_result);
42008d7c:	06dc      	bnez.n	a6, 42008d90 <vector_test_ceil+0x78>
42008d7e:	debfd1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
42008d81:	defdc1        	l32r	a12, 42000978 <_stext+0x958> (3c027424 <__func__$1>)
42008d84:	aaa3b2        	movi	a11, 0x3aa
42008d87:	debca1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008d8a:	dcdf81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008d8d:	0008e0        	callx8	a8
        assert(scalar_result);
42008d90:	05dc      	bnez.n	a5, 42008da4 <vector_test_ceil+0x8c>
42008d92:	debbd1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
42008d95:	def8c1        	l32r	a12, 42000978 <_stext+0x958> (3c027424 <__func__$1>)
42008d98:	aba3b2        	movi	a11, 0x3ab
42008d9b:	deb7a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008d9e:	dcda81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008da1:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
42008da4:	07ad      	mov.n	a10, a7
42008da6:	002ee5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
42008da9:	17b8      	l32i.n	a11, a7, 4
42008dab:	27a8      	l32i.n	a10, a7, 8
42008dad:	006465        	call8	420093f4 <vector_create>
42008db0:	0a4d      	mov.n	a4, a10
        vec_copy(vec1, vec1_copy);  
42008db2:	0abd      	mov.n	a11, a10
42008db4:	07ad      	mov.n	a10, a7
42008db6:	00c3e5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
42008db9:	04bd      	mov.n	a11, a4
42008dbb:	07ad      	mov.n	a10, a7
42008dbd:	0047a5        	call8	42009238 <vector_assert_eq>
42008dc0:	0adc      	bnez.n	a10, 42008dd4 <vector_test_ceil+0xbc>
42008dc2:	deb0d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42008dc5:	deecc1        	l32r	a12, 42000978 <_stext+0x958> (3c027424 <__func__$1>)
42008dc8:	b2a3b2        	movi	a11, 0x3b2
42008dcb:	deaba1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008dce:	dcce81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008dd1:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
42008dd4:	07ad      	mov.n	a10, a7
42008dd6:	0037e5        	call8	42009154 <vector_check_canary>
42008dd9:	0adc      	bnez.n	a10, 42008ded <vector_test_ceil+0xd5>
42008ddb:	deacd1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42008dde:	dee6c1        	l32r	a12, 42000978 <_stext+0x958> (3c027424 <__func__$1>)
42008de1:	b3a3b2        	movi	a11, 0x3b3
42008de4:	dea5a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008de7:	dcc881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008dea:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42008ded:	fdafa5        	call8	420068e8 <timer_start>
        scalar_ceil(vec1, scalar_result, rand_scalar);
42008df0:	41c8      	l32i.n	a12, a1, 16
42008df2:	05bd      	mov.n	a11, a5
42008df4:	07ad      	mov.n	a10, a7
42008df6:	fe1f65        	call8	42006fec <scalar_ceil>
        timer_end(&scalar_time);
42008df9:	a14b      	addi.n	a10, a1, 4
42008dfb:	fdb125        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42008dfe:	fdaea5        	call8	420068e8 <timer_start>
        vec_ceil(vec1, simd_result, rand_scalar);
42008e01:	41c8      	l32i.n	a12, a1, 16
42008e03:	06bd      	mov.n	a11, a6
42008e05:	07ad      	mov.n	a10, a7
42008e07:	00b665        	call8	4200996c <vec_ceil>
        timer_end(&vec_time); 
42008e0a:	01ad      	mov.n	a10, a1
42008e0c:	fdafe5        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42008e0f:	05bd      	mov.n	a11, a5
42008e11:	06ad      	mov.n	a10, a6
42008e13:	004265        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs 
42008e16:	04bd      	mov.n	a11, a4
42008e18:	07ad      	mov.n	a10, a7
42008e1a:	0041e5        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region 
42008e1d:	07ad      	mov.n	a10, a7
42008e1f:	003365        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42008e22:	06ad      	mov.n	a10, a6
42008e24:	0032e5        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42008e27:	05ad      	mov.n	a10, a5
42008e29:	0032a5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
42008e2c:	07ad      	mov.n	a10, a7
42008e2e:	006165        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
42008e31:	04ad      	mov.n	a10, a4
42008e33:	006125        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
42008e36:	06ad      	mov.n	a10, a6
42008e38:	0060a5        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42008e3b:	05ad      	mov.n	a10, a5
42008e3d:	006065        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008e40:	221b      	addi.n	a2, a2, 1
42008e42:	f83c      	movi.n	a8, 63
42008e44:	022827        	blt	a8, a2, 42008e4a <vector_test_ceil+0x132>
42008e47:	ffb986        	j	42008d31 <vector_test_ceil+0x19>
    } 
    timer_deinit();
42008e4a:	fdb2a5        	call8	42006974 <timer_deinit>
    if (verbose){
42008e4d:	5188      	l32i.n	a8, a1, 20
42008e4f:	68bc      	beqz.n	a8, 42008e89 <vector_test_ceil+0x171>
            ESP_LOGI("vector_test_ceil", "vector_time: %d", vec_time);
42008e51:	360c      	movi.n	a6, 3
42008e53:	dc8381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008e56:	0008e0        	callx8	a8
42008e59:	dec871        	l32r	a7, 4200097c <_stext+0x95c> (3c0245a0 <_flash_rodata_start+0x4480>)
42008e5c:	01f8      	l32i.n	a15, a1, 0
42008e5e:	07ed      	mov.n	a14, a7
42008e60:	0add      	mov.n	a13, a10
42008e62:	de8dc1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42008e65:	20b770        	or	a11, a7, a7
42008e68:	06ad      	mov.n	a10, a6
42008e6a:	dc8a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008e6d:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_ceil", "scalar_time: %d", scalar_time);
42008e70:	dc7c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008e73:	0008e0        	callx8	a8
42008e76:	11f8      	l32i.n	a15, a1, 4
42008e78:	07ed      	mov.n	a14, a7
42008e7a:	0add      	mov.n	a13, a10
42008e7c:	de88c1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008e7f:	07bd      	mov.n	a11, a7
42008e81:	06ad      	mov.n	a10, a6
42008e83:	dc8481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008e86:	0008e0        	callx8	a8
    }
}
42008e89:	f01d      	retw.n
	...

42008e8c <vector_test_ceil_f32>:

void vector_test_ceil_f32(bool verbose, dtype type){  
42008e8c:	008136        	entry	a1, 64
42008e8f:	748020        	extui	a8, a2, 0, 8
42008e92:	056182        	s32i	a8, a1, 20
    timer_init();
42008e95:	fda125        	call8	420068a8 <timer_init>
    set_rand_seed();
42008e98:	0015e5        	call8	42008ff8 <set_rand_seed>

    uint32_t vec_time = 0;                                              // Runtime logs
42008e9b:	00a022        	movi	a2, 0
42008e9e:	0129      	s32i.n	a2, a1, 0
    uint32_t scalar_time = 0;
42008ea0:	1129      	s32i.n	a2, a1, 4

    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008ea2:	0041c6        	j	42008fad <vector_test_ceil_f32+0x121>
        int test_size = 1 + rand() % MAX_SIZE;                          // Random vector sizes 
42008ea5:	de7e81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42008ea8:	0008e0        	callx8	a8
42008eab:	318fa0        	srai	a8, a10, 31
42008eae:	758880        	extui	a8, a8, 24, 8
42008eb1:	aa8a      	add.n	a10, a10, a8
42008eb3:	74a0a0        	extui	a10, a10, 0, 8
42008eb6:	c0aa80        	sub	a10, a10, a8
        vector_t *vec1 = create_test_vector(test_size, type);           // Allocating the test vectors 
42008eb9:	20b330        	or	a11, a3, a3
42008ebc:	aa1b      	addi.n	a10, a10, 1
42008ebe:	001665        	call8	42009024 <create_test_vector>
42008ec1:	0a7d      	mov.n	a7, a10
        vector_t *simd_result = create_test_vector(vec1->size, vec1->type); 
42008ec3:	1ab8      	l32i.n	a11, a10, 4
42008ec5:	2aa8      	l32i.n	a10, a10, 8
42008ec7:	0015e5        	call8	42009024 <create_test_vector>
42008eca:	0a5d      	mov.n	a5, a10
        vector_t *scalar_result = create_test_vector(vec1->size, vec1->type); 
42008ecc:	17b8      	l32i.n	a11, a7, 4
42008ece:	27a8      	l32i.n	a10, a7, 8
42008ed0:	001525        	call8	42009024 <create_test_vector>
42008ed3:	0a6d      	mov.n	a6, a10
        float rand_float = rand_float_val(type);
42008ed5:	03ad      	mov.n	a10, a3
42008ed7:	003225        	call8	420091f8 <rand_float_val>
42008eda:	41a9      	s32i.n	a10, a1, 16

        assert(vec1);                                                   // Check if valid 
42008edc:	07dc      	bnez.n	a7, 42008ef0 <vector_test_ceil_f32+0x64>
42008ede:	de64d1        	l32r	a13, 42000870 <_stext+0x850> (3c024018 <_flash_rodata_start+0x3ef8>)
42008ee1:	dea7c1        	l32r	a12, 42000980 <_stext+0x960> (3c02740c <__func__$0>)
42008ee4:	dda3b2        	movi	a11, 0x3dd
42008ee7:	de64a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008eea:	dc8781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008eed:	0008e0        	callx8	a8
        assert(simd_result);
42008ef0:	05dc      	bnez.n	a5, 42008f04 <vector_test_ceil_f32+0x78>
42008ef2:	de62d1        	l32r	a13, 4200087c <_stext+0x85c> (3c024050 <_flash_rodata_start+0x3f30>)
42008ef5:	dea2c1        	l32r	a12, 42000980 <_stext+0x960> (3c02740c <__func__$0>)
42008ef8:	dea3b2        	movi	a11, 0x3de
42008efb:	de5fa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008efe:	dc8281        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008f01:	0008e0        	callx8	a8
        assert(scalar_result);
42008f04:	06dc      	bnez.n	a6, 42008f18 <vector_test_ceil_f32+0x8c>
42008f06:	de5ed1        	l32r	a13, 42000880 <_stext+0x860> (3c02405c <_flash_rodata_start+0x3f3c>)
42008f09:	de9dc1        	l32r	a12, 42000980 <_stext+0x960> (3c02740c <__func__$0>)
42008f0c:	dfa3b2        	movi	a11, 0x3df
42008f0f:	de5aa1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008f12:	dc7d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008f15:	0008e0        	callx8	a8

        fill_test_vector(vec1);                                         // Fill with random values in range 
42008f18:	07ad      	mov.n	a10, a7
42008f1a:	0017a5        	call8	42009094 <fill_test_vector>

        vector_t *vec1_copy = vector_create(vec1->size, vec1->type);    // Creating copies (to check for modification of inputs) 
42008f1d:	17b8      	l32i.n	a11, a7, 4
42008f1f:	27a8      	l32i.n	a10, a7, 8
42008f21:	004d25        	call8	420093f4 <vector_create>
42008f24:	0a4d      	mov.n	a4, a10
        vec_copy(vec1, vec1_copy);  
42008f26:	0abd      	mov.n	a11, a10
42008f28:	07ad      	mov.n	a10, a7
42008f2a:	00aca5        	call8	420099f4 <vec_copy>

        assert(vector_assert_eq(vec1, vec1_copy));                      // Checking copies, canary regions 
42008f2d:	04bd      	mov.n	a11, a4
42008f2f:	07ad      	mov.n	a10, a7
42008f31:	003065        	call8	42009238 <vector_assert_eq>
42008f34:	0adc      	bnez.n	a10, 42008f48 <vector_test_ceil_f32+0xbc>
42008f36:	de53d1        	l32r	a13, 42000884 <_stext+0x864> (3c02406c <_flash_rodata_start+0x3f4c>)
42008f39:	de91c1        	l32r	a12, 42000980 <_stext+0x960> (3c02740c <__func__$0>)
42008f3c:	e6a3b2        	movi	a11, 0x3e6
42008f3f:	de4ea1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008f42:	dc7181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008f45:	0008e0        	callx8	a8
        assert(vector_check_canary(vec1)); 
42008f48:	07ad      	mov.n	a10, a7
42008f4a:	0020a5        	call8	42009154 <vector_check_canary>
42008f4d:	0adc      	bnez.n	a10, 42008f61 <vector_test_ceil_f32+0xd5>
42008f4f:	de4fd1        	l32r	a13, 4200088c <_stext+0x86c> (3c0240b4 <_flash_rodata_start+0x3f94>)
42008f52:	de8bc1        	l32r	a12, 42000980 <_stext+0x960> (3c02740c <__func__$0>)
42008f55:	e7a3b2        	movi	a11, 0x3e7
42008f58:	de48a1        	l32r	a10, 42000878 <_stext+0x858> (3c02403c <_flash_rodata_start+0x3f1c>)
42008f5b:	dc6b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42008f5e:	0008e0        	callx8	a8
 
        timer_start();                                                  // Scalar functions are assumed intended behavior
42008f61:	fd9865        	call8	420068e8 <timer_start>
        scalar_ceil_f32(vec1, scalar_result, rand_float);
42008f64:	41c8      	l32i.n	a12, a1, 16
42008f66:	06bd      	mov.n	a11, a6
42008f68:	07ad      	mov.n	a10, a7
42008f6a:	0db325        	call8	42016a9c <scalar_ceil_f32>
        timer_end(&scalar_time);
42008f6d:	a14b      	addi.n	a10, a1, 4
42008f6f:	fd99e5        	call8	4200690c <timer_end>

        timer_start();                                                  // Running tests
42008f72:	fd9765        	call8	420068e8 <timer_start>
        //vec_ceil_f32(vec1, simd_result, rand_float);
        timer_end(&vec_time); 
42008f75:	01ad      	mov.n	a10, a1
42008f77:	fd9965        	call8	4200690c <timer_end>

        vector_assert_eq(simd_result, scalar_result);                   // Check results
42008f7a:	06bd      	mov.n	a11, a6
42008f7c:	05ad      	mov.n	a10, a5
42008f7e:	002ba5        	call8	42009238 <vector_assert_eq>
        vector_assert_eq(vec1, vec1_copy);                              // Check modification of inputs 
42008f81:	04bd      	mov.n	a11, a4
42008f83:	07ad      	mov.n	a10, a7
42008f85:	002b25        	call8	42009238 <vector_assert_eq>
        vector_check_canary(vec1);                                      // Check modification of canary region 
42008f88:	07ad      	mov.n	a10, a7
42008f8a:	001ca5        	call8	42009154 <vector_check_canary>
        vector_check_canary(simd_result);
42008f8d:	05ad      	mov.n	a10, a5
42008f8f:	001c65        	call8	42009154 <vector_check_canary>
        vector_check_canary(scalar_result);
42008f92:	06ad      	mov.n	a10, a6
42008f94:	001be5        	call8	42009154 <vector_check_canary>
  
        vector_destroy(vec1);                                           // Free resources 
42008f97:	07ad      	mov.n	a10, a7
42008f99:	004aa5        	call8	42009444 <vector_destroy>
        vector_destroy(vec1_copy); 
42008f9c:	04ad      	mov.n	a10, a4
42008f9e:	004a65        	call8	42009444 <vector_destroy>
        vector_destroy(simd_result);
42008fa1:	05ad      	mov.n	a10, a5
42008fa3:	004a25        	call8	42009444 <vector_destroy>
        vector_destroy(scalar_result);
42008fa6:	06ad      	mov.n	a10, a6
42008fa8:	0049a5        	call8	42009444 <vector_destroy>
    for (int run_num = 0; run_num < TEST_RUNS; run_num++){
42008fab:	221b      	addi.n	a2, a2, 1
42008fad:	f83c      	movi.n	a8, 63
42008faf:	022827        	blt	a8, a2, 42008fb5 <vector_test_ceil_f32+0x129>
42008fb2:	ffbbc6        	j	42008ea5 <vector_test_ceil_f32+0x19>
    } 
    timer_deinit();
42008fb5:	fd9be5        	call8	42006974 <timer_deinit>
    if (verbose){
42008fb8:	5188      	l32i.n	a8, a1, 20
42008fba:	78bc      	beqz.n	a8, 42008ff5 <vector_test_ceil_f32+0x169>
            ESP_LOGI("vector_test_ceil", "vector_time: %d", vec_time);
42008fbc:	360c      	movi.n	a6, 3
42008fbe:	dc2881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008fc1:	0008e0        	callx8	a8
42008fc4:	de6e71        	l32r	a7, 4200097c <_stext+0x95c> (3c0245a0 <_flash_rodata_start+0x4480>)
42008fc7:	01f8      	l32i.n	a15, a1, 0
42008fc9:	07ed      	mov.n	a14, a7
42008fcb:	20daa0        	or	a13, a10, a10
42008fce:	de32c1        	l32r	a12, 42000898 <_stext+0x878> (3c0240fc <_flash_rodata_start+0x3fdc>)
42008fd1:	20b770        	or	a11, a7, a7
42008fd4:	06ad      	mov.n	a10, a6
42008fd6:	dc2f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008fd9:	0008e0        	callx8	a8
            ESP_LOGI("vector_test_ceil", "scalar_time: %d", scalar_time);
42008fdc:	dc2181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42008fdf:	0008e0        	callx8	a8
42008fe2:	11f8      	l32i.n	a15, a1, 4
42008fe4:	07ed      	mov.n	a14, a7
42008fe6:	0add      	mov.n	a13, a10
42008fe8:	de2dc1        	l32r	a12, 4200089c <_stext+0x87c> (3c02411c <_flash_rodata_start+0x3ffc>)
42008feb:	07bd      	mov.n	a11, a7
42008fed:	06ad      	mov.n	a10, a6
42008fef:	dc2981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42008ff2:	0008e0        	callx8	a8
    }
}
42008ff5:	f01d      	retw.n
	...

42008ff8 <set_rand_seed>:
    .resolution_hz = 1 * 1000 * 1000,   // Resolution is 1 MHz, i.e., 1 tick equals 1 microsecond
}; 
 
// HELPER FUNCTIONS
 
void set_rand_seed(void){
42008ff8:	004136        	entry	a1, 32
    int seed = time(NULL);              // One second resolution -> switch to esp_timer for more randomness
42008ffb:	0a0c      	movi.n	a10, 0
42008ffd:	043665        	call8	4200d364 <time>
42009000:	0a7d      	mov.n	a7, a10
    srand(seed);
42009002:	de6281        	l32r	a8, 4200098c <_stext+0x96c> (400014ac <srand>)
42009005:	0008e0        	callx8	a8
    ESP_LOGI("fill_test_vector", "Seed set: %d", seed);
42009008:	dc1681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200900b:	0008e0        	callx8	a8
4200900e:	de5db1        	l32r	a11, 42000984 <_stext+0x964> (3c0245b4 <_flash_rodata_start+0x4494>)
42009011:	07fd      	mov.n	a15, a7
42009013:	0bed      	mov.n	a14, a11
42009015:	0add      	mov.n	a13, a10
42009017:	de5cc1        	l32r	a12, 42000988 <_stext+0x968> (3c0245c8 <_flash_rodata_start+0x44a8>)
4200901a:	3a0c      	movi.n	a10, 3
4200901c:	dc1e81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200901f:	0008e0        	callx8	a8
}
42009022:	f01d      	retw.n

42009024 <create_test_vector>:
void set_seed(int seed){
    srand(seed);
    ESP_LOGI("fill_test_vector", "Seed set: %d", seed);
}

vector_t* create_test_vector(const size_t size, const dtype type){ 
42009024:	004136        	entry	a1, 32
42009027:	026d      	mov.n	a6, a2
    vector_t *vec = malloc(sizeof(vector_t));
42009029:	10a0a2        	movi	a10, 16
4200902c:	dde481        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
4200902f:	0008e0        	callx8	a8
42009032:	0a2d      	mov.n	a2, a10
    if (!vec) { 
42009034:	cadc      	bnez.n	a10, 42009054 <create_test_vector+0x30>
        ESP_LOGI("create_test_vector", "Failed to allocate memory");
42009036:	dc0a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42009039:	0008e0        	callx8	a8
4200903c:	de55b1        	l32r	a11, 42000990 <_stext+0x970> (3c0245e4 <_flash_rodata_start+0x44c4>)
4200903f:	0bed      	mov.n	a14, a11
42009041:	20daa0        	or	a13, a10, a10
42009044:	de54c1        	l32r	a12, 42000994 <_stext+0x974> (3c0245f8 <_flash_rodata_start+0x44d8>)
42009047:	03a0a2        	movi	a10, 3
4200904a:	dc1281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200904d:	0008e0        	callx8	a8
        return NULL;
42009050:	000f06        	j	42009090 <create_test_vector+0x6c>
42009053:	a33000        	movltz	a3, a0, a0
    } 
 
    vec->data = heap_caps_aligned_alloc(16, size * sizeof_dtype(type) + 4, MALLOC_CAP_DEFAULT); // Allocate aligned memory for the data array
42009056:	aa2520        	floor.s	a2, f5, 2
42009059:	0d          	.byte	0xd
4200905a:	825a60        	mull	a5, a10, a6
4200905d:	de4ec1        	l32r	a12, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
42009060:	04c5b2        	addi	a11, a5, 4
42009063:	10a0a2        	movi	a10, 16
42009066:	de4d81        	l32r	a8, 4200099c <_stext+0x97c> (40376028 <heap_caps_aligned_alloc>)
42009069:	0008e0        	callx8	a8
4200906c:	0a7d      	mov.n	a7, a10
4200906e:	02a9      	s32i.n	a10, a2, 0
    if (!vec->data) { 
42009070:	cacc      	bnez.n	a10, 42009080 <create_test_vector+0x5c>
        free(vec);  
42009072:	02ad      	mov.n	a10, a2
42009074:	dd3e81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
42009077:	0008e0        	callx8	a8
        return NULL;
4200907a:	072d      	mov.n	a2, a7
4200907c:	000406        	j	42009090 <create_test_vector+0x6c>
4200907f:	7a5a00        	divn.s	f5, f10, f0
    }
    void* data_end = vec->data + size * sizeof_dtype(type);
    int32_t* canary_region = data_end;
    canary_region[0] = CANARY_DATA;
42009082:	de3181        	l32r	a8, 42000948 <_stext+0x928> (deadbeef <_rtc_reserved_end+0x7e9dbeef>)
42009085:	0789      	s32i.n	a8, a7, 0

    vec->type = type;
42009087:	1239      	s32i.n	a3, a2, 4
    vec->size = size;  
42009089:	2269      	s32i.n	a6, a2, 8
    vec->owns_data = true;                                                                  // Indicates that this vector_t owns the data 
4200908b:	180c      	movi.n	a8, 1
4200908d:	0c4282        	s8i	a8, a2, 12
    return vec;                                                                             // Return the created vector_t
}
42009090:	f01d      	retw.n
	...

42009094 <fill_test_vector>:

void fill_test_vector(vector_t *vec){
42009094:	004136        	entry	a1, 32
    switch (vec->type){
42009097:	1288      	l32i.n	a8, a2, 4
42009099:	4b2826        	beqi	a8, 2, 420090e8 <fill_test_vector+0x54>
4200909c:	0838f6        	bgeui	a8, 3, 420090a8 <fill_test_vector+0x14>
4200909f:	b88c      	beqz.n	a8, 420090ae <fill_test_vector+0x1a>
420090a1:	251826        	beqi	a8, 1, 420090ca <fill_test_vector+0x36>
420090a4:	002a06        	j	42009150 <fill_test_vector+0xbc>
420090a7:	00          	.byte	00
420090a8:	663826        	beqi	a8, 3, 42009112 <fill_test_vector+0x7e>
420090ab:	002846        	j	42009150 <fill_test_vector+0xbc>
        case (DTYPE_INT8): {
            int8_t* data = vec->data;
420090ae:	0268      	l32i.n	a6, a2, 0
            for (int i = 0; i < vec->size; i++){
420090b0:	070c      	movi.n	a7, 0
420090b2:	000306        	j	420090c2 <fill_test_vector+0x2e>
                uint8_t u = (uint8_t)rand();
420090b5:	ddfa81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420090b8:	0008e0        	callx8	a8
                data[i] = (int8_t)u;
420090bb:	867a      	add.n	a8, a6, a7
420090bd:	0048a2        	s8i	a10, a8, 0
            for (int i = 0; i < vec->size; i++){
420090c0:	771b      	addi.n	a7, a7, 1
420090c2:	2288      	l32i.n	a8, a2, 8
420090c4:	ed3787        	bltu	a7, a8, 420090b5 <fill_test_vector+0x21>
420090c7:	002146        	j	42009150 <fill_test_vector+0xbc>
            }
            break;
        }
        case (DTYPE_INT16): {
            int16_t* data = vec->data;
420090ca:	0268      	l32i.n	a6, a2, 0
            for (int i = 0; i < vec->size; i++){ 
420090cc:	070c      	movi.n	a7, 0
420090ce:	000346        	j	420090df <fill_test_vector+0x4b>
                uint16_t u = (uint16_t)rand();
420090d1:	ddf381        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420090d4:	0008e0        	callx8	a8
                data[i] = (int16_t)u; 
420090d7:	908760        	addx2	a8, a7, a6
420090da:	0058a2        	s16i	a10, a8, 0
            for (int i = 0; i < vec->size; i++){ 
420090dd:	771b      	addi.n	a7, a7, 1
420090df:	2288      	l32i.n	a8, a2, 8
420090e1:	ec3787        	bltu	a7, a8, 420090d1 <fill_test_vector+0x3d>
420090e4:	001a06        	j	42009150 <fill_test_vector+0xbc>
420090e7:	025800        	andb	b5, b8, b0
            }
            break;
        }
        case (DTYPE_INT32): {
            int32_t* data = vec->data;
            for (int i = 0; i < vec->size; i++){
420090ea:	060c      	movi.n	a6, 0
420090ec:	000686        	j	4200910a <fill_test_vector+0x76>
420090ef:	810000        	src	a0, a0, a0
                int32_t val = (rand() << 16) ^ rand();
420090f2:	ddeb      	addi.n	a13, a13, 14
420090f4:	0008e0        	callx8	a8
420090f7:	117a00        	slli	a7, a10, 16
420090fa:	dde981        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420090fd:	0008e0        	callx8	a8
42009100:	3077a0        	xor	a7, a7, a10
                data[i] = val;
42009103:	a08650        	addx4	a8, a6, a5
42009106:	0879      	s32i.n	a7, a8, 0
            for (int i = 0; i < vec->size; i++){
42009108:	661b      	addi.n	a6, a6, 1
4200910a:	2288      	l32i.n	a8, a2, 8
4200910c:	e13687        	bltu	a6, a8, 420090f1 <fill_test_vector+0x5d>
4200910f:	000f46        	j	42009150 <fill_test_vector+0xbc>
            }
            break;
        }
        case (DTYPE_FLOAT32): {
            float* data = vec->data;
42009112:	0258      	l32i.n	a5, a2, 0
            for (int i = 0; i < vec->size; i++){
42009114:	060c      	movi.n	a6, 0
42009116:	000c46        	j	4200914b <fill_test_vector+0xb7>
                uint32_t r = (rand() << 16) ^ rand();
42009119:	dde181        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
4200911c:	0008e0        	callx8	a8
4200911f:	117a00        	slli	a7, a10, 16
42009122:	dddf81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
42009125:	0008e0        	callx8	a8
42009128:	3077a0        	xor	a7, a7, a10
                float f = (r / 4294967296.0f); 
4200912b:	da0700        	ufloat.s	f0, a7, 0
4200912e:	de1c81        	l32r	a8, 420009a0 <_stext+0x980> (2f800000 <UserFrameTotalSize+0x2f7fff00>)
42009131:	fa1850        	wfr	f1, a8
42009134:	2a0010        	mul.s	f0, f0, f1
                data[i] = 2.0f * f - 1.0f; 
42009137:	0a0000        	add.s	f0, f0, f0
4200913a:	a08650        	addx4	a8, a6, a5
4200913d:	de1991        	l32r	a9, 420009a4 <_stext+0x984> (3f800000 <_esp_system_init_fn_array_end+0x37d6d5c>)
42009140:	fa1950        	wfr	f1, a9
42009143:	1a0010        	sub.s	f0, f0, f1
42009146:	004803        	ssi	f0, a8, 0
            for (int i = 0; i < vec->size; i++){
42009149:	661b      	addi.n	a6, a6, 1
4200914b:	2288      	l32i.n	a8, a2, 8
4200914d:	c83687        	bltu	a6, a8, 42009119 <fill_test_vector+0x85>
            }
            break;
        }
    }
}
42009150:	f01d      	retw.n
	...

42009154 <vector_check_canary>:
        default:
            break;
    }
}

bool vector_check_canary(vector_t* vec){
42009154:	006136        	entry	a1, 48
    void *data_end = vec->data;
42009157:	0278      	l32i.n	a7, a2, 0
    data_end += vec->size * sizeof_dtype(vec->type);
42009159:	2268      	l32i.n	a6, a2, 8
4200915b:	0122a2        	l32i	a10, a2, 4
4200915e:	0d99a5        	call8	42016af8 <sizeof_dtype>
42009161:	8266a0        	mull	a6, a6, a10
42009164:	776a      	add.n	a7, a7, a6
    uint32_t canary_data =*(uint32_t*)data_end;
42009166:	002772        	l32i	a7, a7, 0
    if (canary_data != CANARY_DATA){
42009169:	ddf781        	l32r	a8, 42000948 <_stext+0x928> (deadbeef <_rtc_reserved_end+0x7e9dbeef>)
4200916c:	211787        	beq	a7, a8, 42009191 <vector_check_canary+0x3d>
        ESP_LOGE("vector_check_canary", "Canary modified: expected %d, found: %d", CANARY_DATA, canary_data);
4200916f:	dbbc81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42009172:	0008e0        	callx8	a8
42009175:	de0cb1        	l32r	a11, 420009a8 <_stext+0x988> (3c024620 <_flash_rodata_start+0x4500>)
42009178:	0179      	s32i.n	a7, a1, 0
4200917a:	ddf3f1        	l32r	a15, 42000948 <_stext+0x928> (deadbeef <_rtc_reserved_end+0x7e9dbeef>)
4200917d:	0bed      	mov.n	a14, a11
4200917f:	0add      	mov.n	a13, a10
42009181:	de0ac1        	l32r	a12, 420009ac <_stext+0x98c> (3c024634 <_flash_rodata_start+0x4514>)
42009184:	1a0c      	movi.n	a10, 1
42009186:	dbc381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42009189:	0008e0        	callx8	a8
        return false;
4200918c:	020c      	movi.n	a2, 0
4200918e:	000046        	j	42009193 <vector_check_canary+0x3f>
    }
    return true;
42009191:	120c      	movi.n	a2, 1
}
42009193:	f01d      	retw.n
42009195:	000000        	ill

42009198 <rand_scalar_val>:
 
int rand_scalar_val(dtype type){
42009198:	004136        	entry	a1, 32
    switch (type){
4200919b:	1e1226        	beqi	a2, 1, 420091bd <rand_scalar_val+0x25>
4200919e:	362226        	beqi	a2, 2, 420091d8 <rand_scalar_val+0x40>
420091a1:	f2fc      	bnez.n	a2, 420091e4 <rand_scalar_val+0x4c>
        case DTYPE_INT8: { 
            return INT8_MIN + rand() % (INT8_MAX - INT8_MIN + 1); 
420091a3:	ddbf81        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420091a6:	0008e0        	callx8	a8
420091a9:	318fa0        	srai	a8, a10, 31
420091ac:	758880        	extui	a8, a8, 24, 8
420091af:	2a8a      	add.n	a2, a10, a8
420091b1:	742020        	extui	a2, a2, 0, 8
420091b4:	c02280        	sub	a2, a2, a8
420091b7:	80c222        	addi	a2, a2, -128
420091ba:	000e06        	j	420091f6 <rand_scalar_val+0x5e>
        }
        case DTYPE_INT16: { 
            return INT16_MIN + rand() % (INT16_MAX - INT16_MIN + 1); 
420091bd:	ddb881        	l32r	a8, 420008a0 <_stext+0x880> (400014a0 <rand>)
420091c0:	0008e0        	callx8	a8
420091c3:	318fa0        	srai	a8, a10, 31
420091c6:	f58080        	extui	a8, a8, 16, 16
420091c9:	2a8a      	add.n	a2, a10, a8
420091cb:	f42020        	extui	a2, a2, 0, 16
420091ce:	c02280        	sub	a2, a2, a8
420091d1:	80d222        	addmi	a2, a2, 0xffff8000
420091d4:	000786        	j	420091f6 <rand_scalar_val+0x5e>
420091d7:	b28100        	mulsh	a8, a1, a0
        }
        case DTYPE_INT32: {  
            return (int32_t)rand();   
420091da:	dd          	.byte	0xdd
420091db:	0008e0        	callx8	a8
420091de:	0a2d      	mov.n	a2, a10
420091e0:	000486        	j	420091f6 <rand_scalar_val+0x5e>
420091e3:	00          	.byte	00
        }
        default:
            assert(false);
420091e4:	ddf3d1        	l32r	a13, 420009b0 <_stext+0x990> (3c022ea4 <_flash_rodata_start+0x2d84>)
420091e7:	ddf3c1        	l32r	a12, 420009b4 <_stext+0x994> (3c0275e8 <__func__$0>)
420091ea:	7fa0b2        	movi	a11, 127
420091ed:	ddf2a1        	l32r	a10, 420009b8 <_stext+0x998> (3c024688 <_flash_rodata_start+0x4568>)
420091f0:	dbc681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420091f3:	0008e0        	callx8	a8
    }
}
420091f6:	f01d      	retw.n

420091f8 <rand_float_val>:

float rand_float_val(){
420091f8:	004136        	entry	a1, 32
     return (float)rand_scalar_val(DTYPE_INT32);
420091fb:	2a0c      	movi.n	a10, 2
420091fd:	fff9a5        	call8	42009198 <rand_scalar_val>
}
42009200:	ca0a00        	float.s	f0, a10, 0
42009203:	fa2040        	rfr	a2, f0
42009206:	f01d      	retw.n

42009208 <float_eq>:

bool float_eq(float a, float b){
42009208:	004136        	entry	a1, 32
4200920b:	fa1250        	wfr	f1, a2
4200920e:	fa0350        	wfr	f0, a3
    return ((a - b) <= 1e-4f || (b - a) <= 1e-4f);
42009211:	1a2100        	sub.s	f2, f1, f0
42009214:	ddea81        	l32r	a8, 420009bc <_stext+0x99c> (38d1b717 <UserFrameTotalSize+0x38d1b617>)
42009217:	fa3850        	wfr	f3, a8
4200921a:	6b0230        	ole.s	b0, f2, f3
4200921d:	0d1076        	bt	b0, 4200922e <float_eq+0x26>
42009220:	1a0010        	sub.s	f0, f0, f1
42009223:	6b0030        	ole.s	b0, f0, f3
42009226:	0a0076        	bf	b0, 42009234 <float_eq+0x2c>
42009229:	120c      	movi.n	a2, 1
4200922b:	0001c6        	j	42009236 <float_eq+0x2e>
4200922e:	120c      	movi.n	a2, 1
42009230:	000086        	j	42009236 <float_eq+0x2e>
42009233:	020c00        	andb	b0, b12, b0
}
42009236:	f01d      	retw.n

42009238 <vector_assert_eq>:

bool vector_assert_eq(vector_t *vec1, vector_t *vec2){
42009238:	008136        	entry	a1, 64
4200923b:	027d      	mov.n	a7, a2
4200923d:	038d      	mov.n	a8, a3
    if (vec1->type != vec2->type) { ESP_LOGE("vector_assert_eq", "type mismatch"); return false;}
4200923f:	1298      	l32i.n	a9, a2, 4
42009241:	13a8      	l32i.n	a10, a3, 4
42009243:	1d19a7        	beq	a9, a10, 42009264 <vector_assert_eq+0x2c>
42009246:	db8681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42009249:	0008e0        	callx8	a8
4200924c:	ddddb1        	l32r	a11, 420009c0 <_stext+0x9a0> (3c0246a0 <_flash_rodata_start+0x4580>)
4200924f:	0bed      	mov.n	a14, a11
42009251:	0add      	mov.n	a13, a10
42009253:	dddcc1        	l32r	a12, 420009c4 <_stext+0x9a4> (3c0246b4 <_flash_rodata_start+0x4594>)
42009256:	1a0c      	movi.n	a10, 1
42009258:	db8f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200925b:	0008e0        	callx8	a8
4200925e:	020c      	movi.n	a2, 0
42009260:	006346        	j	420093f1 <vector_assert_eq+0x1b9>
42009263:	22b800        	orb	b11, b8, b0
    if (vec1->size != vec2->size) { ESP_LOGE("vector_assert_eq", "size mismatch"); return false;}
42009266:	23a8      	l32i.n	a10, a3, 8
42009268:	1d1ba7        	beq	a11, a10, 42009289 <vector_assert_eq+0x51>
4200926b:	db7d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200926e:	0008e0        	callx8	a8
42009271:	ddd3b1        	l32r	a11, 420009c0 <_stext+0x9a0> (3c0246a0 <_flash_rodata_start+0x4580>)
42009274:	0bed      	mov.n	a14, a11
42009276:	0add      	mov.n	a13, a10
42009278:	ddd4c1        	l32r	a12, 420009c8 <_stext+0x9a8> (3c0246d0 <_flash_rodata_start+0x45b0>)
4200927b:	01a0a2        	movi	a10, 1
4200927e:	db8581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42009281:	0008e0        	callx8	a8
42009284:	020c      	movi.n	a2, 0
42009286:	0059c6        	j	420093f1 <vector_assert_eq+0x1b9>
    bool equals_flag = true;
    switch (vec1->type){
42009289:	022966        	bnei	a9, 2, 4200928f <vector_assert_eq+0x57>
4200928c:	002d06        	j	42009344 <vector_assert_eq+0x10c>
4200928f:	0939f6        	bgeui	a9, 3, 4200929c <vector_assert_eq+0x64>
42009292:	299c      	beqz.n	a9, 420092a8 <vector_assert_eq+0x70>
42009294:	621926        	beqi	a9, 1, 420092fa <vector_assert_eq+0xc2>
42009297:	120c      	movi.n	a2, 1
42009299:	005506        	j	420093f1 <vector_assert_eq+0x1b9>
4200929c:	023966        	bnei	a9, 3, 420092a2 <vector_assert_eq+0x6a>
4200929f:	003a46        	j	4200938c <vector_assert_eq+0x154>
420092a2:	120c      	movi.n	a2, 1
420092a4:	005246        	j	420093f1 <vector_assert_eq+0x1b9>
420092a7:	023800        	andb	b3, b8, b0
        case (DTYPE_INT8): {
            int8_t *vec1_data = (int8_t*)(vec1->data);
            int8_t *vec2_data = (int8_t*)(vec2->data);
420092aa:	0888      	l32i.n	a8, a8, 0
420092ac:	4189      	s32i.n	a8, a1, 16
            for (int i = 0; i < vec1->size; i++)
420092ae:	060c      	movi.n	a6, 0
    bool equals_flag = true;
420092b0:	120c      	movi.n	a2, 1
            for (int i = 0; i < vec1->size; i++)
420092b2:	000f06        	j	420092f2 <vector_assert_eq+0xba>
            {
                int8_t val1 = vec1_data[i]; 
420092b5:	836a      	add.n	a8, a3, a6
420092b7:	000852        	l8ui	a5, a8, 0
                int8_t val2 = vec2_data[i];
420092ba:	4188      	l32i.n	a8, a1, 16
420092bc:	886a      	add.n	a8, a8, a6
420092be:	000842        	l8ui	a4, a8, 0
                if (val1 != val2){
420092c1:	239500        	sext	a9, a5, 7
420092c4:	238400        	sext	a8, a4, 7
420092c7:	251987        	beq	a9, a8, 420092f0 <vector_assert_eq+0xb8>
                    ESP_LOGE("vector_assert_eq", "Mismatch found at %d, vec1: %d, vec2 %d", i, (int)val1, (int)val2);
420092ca:	db6581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420092cd:	0008e0        	callx8	a8
420092d0:	ddbcb1        	l32r	a11, 420009c0 <_stext+0x9a0> (3c0246a0 <_flash_rodata_start+0x4580>)
420092d3:	234400        	sext	a4, a4, 7
420092d6:	1149      	s32i.n	a4, a1, 4
420092d8:	235500        	sext	a5, a5, 7
420092db:	0159      	s32i.n	a5, a1, 0
420092dd:	06fd      	mov.n	a15, a6
420092df:	0bed      	mov.n	a14, a11
420092e1:	0add      	mov.n	a13, a10
420092e3:	ddbac1        	l32r	a12, 420009cc <_stext+0x9ac> (3c0246ec <_flash_rodata_start+0x45cc>)
420092e6:	1a0c      	movi.n	a10, 1
420092e8:	db6b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420092eb:	0008e0        	callx8	a8
                    equals_flag = false;
420092ee:	020c      	movi.n	a2, 0
            for (int i = 0; i < vec1->size; i++)
420092f0:	661b      	addi.n	a6, a6, 1
420092f2:	2788      	l32i.n	a8, a7, 8
420092f4:	bd3687        	bltu	a6, a8, 420092b5 <vector_assert_eq+0x7d>
420092f7:	003d86        	j	420093f1 <vector_assert_eq+0x1b9>
                }
            } 
            break;
        }
        case (DTYPE_INT16): {
            int16_t *vec1_data = (int16_t*)(vec1->data);
420092fa:	0238      	l32i.n	a3, a2, 0
            int16_t *vec2_data = (int16_t*)(vec2->data);
420092fc:	0888      	l32i.n	a8, a8, 0
420092fe:	4189      	s32i.n	a8, a1, 16
            for (int i = 0; i < vec1->size; i++)
42009300:	060c      	movi.n	a6, 0
    bool equals_flag = true;
42009302:	120c      	movi.n	a2, 1
            for (int i = 0; i < vec1->size; i++)
42009304:	000d06        	j	4200933c <vector_assert_eq+0x104>
42009307:	300000        	xor	a0, a0, a0
            {
                int16_t val1 = vec1_data[i]; 
4200930a:	529086        	j	4201dd50 <_etext+0x461a>
4200930d:	0098      	l32i.n	a9, a0, 0
                int16_t val2 = vec2_data[i];
4200930f:	4188      	l32i.n	a8, a1, 16
42009311:	908680        	addx2	a8, a6, a8
42009314:	009842        	l16si	a4, a8, 0
                if (val1 != val2){
42009317:	1f1547        	beq	a5, a4, 4200933a <vector_assert_eq+0x102>
                    ESP_LOGE("vector_assert_eq", "Mismatch found at %d, vec1: %d, vec2 %d", i, (int)val1, (int)val2);
4200931a:	db5181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200931d:	0008e0        	callx8	a8
42009320:	dda8b1        	l32r	a11, 420009c0 <_stext+0x9a0> (3c0246a0 <_flash_rodata_start+0x4580>)
42009323:	1149      	s32i.n	a4, a1, 4
42009325:	0159      	s32i.n	a5, a1, 0
42009327:	06fd      	mov.n	a15, a6
42009329:	0bed      	mov.n	a14, a11
4200932b:	0add      	mov.n	a13, a10
4200932d:	dda7c1        	l32r	a12, 420009cc <_stext+0x9ac> (3c0246ec <_flash_rodata_start+0x45cc>)
42009330:	1a0c      	movi.n	a10, 1
42009332:	db5881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42009335:	0008e0        	callx8	a8
                    equals_flag = false;
42009338:	020c      	movi.n	a2, 0
            for (int i = 0; i < vec1->size; i++)
4200933a:	661b      	addi.n	a6, a6, 1
4200933c:	2788      	l32i.n	a8, a7, 8
4200933e:	c73687        	bltu	a6, a8, 42009309 <vector_assert_eq+0xd1>
42009341:	002b06        	j	420093f1 <vector_assert_eq+0x1b9>
                }
            } 
            break;
        }
        case (DTYPE_INT32): {
            int32_t *vec1_data = (int32_t*)(vec1->data);
42009344:	0238      	l32i.n	a3, a2, 0
            int32_t *vec2_data = (int32_t*)(vec2->data);
42009346:	0888      	l32i.n	a8, a8, 0
42009348:	4189      	s32i.n	a8, a1, 16
            for (int i = 0; i < vec1->size; i++)
4200934a:	060c      	movi.n	a6, 0
    bool equals_flag = true;
4200934c:	120c      	movi.n	a2, 1
            for (int i = 0; i < vec1->size; i++)
4200934e:	000c86        	j	42009384 <vector_assert_eq+0x14c>
            {
                int32_t val1 = vec1_data[i]; 
42009351:	a08630        	addx4	a8, a6, a3
42009354:	0858      	l32i.n	a5, a8, 0
                int32_t val2 = vec2_data[i];
42009356:	042182        	l32i	a8, a1, 16
42009359:	a08680        	addx4	a8, a6, a8
4200935c:	002842        	l32i	a4, a8, 0
                if (val1 != val2){
4200935f:	1f1457        	beq	a4, a5, 42009382 <vector_assert_eq+0x14a>
                    ESP_LOGE("vector_assert_eq", "Mismatch found at %d, vec1: %d, vec2 %d", i, (int)val1, (int)val2);
42009362:	db3f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42009365:	0008e0        	callx8	a8
42009368:	dd96b1        	l32r	a11, 420009c0 <_stext+0x9a0> (3c0246a0 <_flash_rodata_start+0x4580>)
4200936b:	1149      	s32i.n	a4, a1, 4
4200936d:	0159      	s32i.n	a5, a1, 0
4200936f:	06fd      	mov.n	a15, a6
42009371:	0bed      	mov.n	a14, a11
42009373:	0add      	mov.n	a13, a10
42009375:	dd95c1        	l32r	a12, 420009cc <_stext+0x9ac> (3c0246ec <_flash_rodata_start+0x45cc>)
42009378:	1a0c      	movi.n	a10, 1
4200937a:	db4681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200937d:	0008e0        	callx8	a8
                    equals_flag = false;
42009380:	020c      	movi.n	a2, 0
            for (int i = 0; i < vec1->size; i++)
42009382:	661b      	addi.n	a6, a6, 1
42009384:	2788      	l32i.n	a8, a7, 8
42009386:	c73687        	bltu	a6, a8, 42009351 <vector_assert_eq+0x119>
42009389:	001906        	j	420093f1 <vector_assert_eq+0x1b9>
                }
            } 
            break;
        }
        case (DTYPE_FLOAT32): {
            float *vec1_data = (float*)(vec1->data);
4200938c:	0298      	l32i.n	a9, a2, 0
4200938e:	4199      	s32i.n	a9, a1, 16
            float *vec2_data = (float*)(vec2->data);
42009390:	0388      	l32i.n	a8, a3, 0
42009392:	5189      	s32i.n	a8, a1, 20
            for (int i = 0; i < vec1->size; i++)
42009394:	060c      	movi.n	a6, 0
    bool equals_flag = true;
42009396:	120c      	movi.n	a2, 1
            for (int i = 0; i < vec1->size; i++)
42009398:	001406        	j	420093ec <vector_assert_eq+0x1b4>
            {
                float val1 = vec1_data[i]; 
4200939b:	4188      	l32i.n	a8, a1, 16
4200939d:	a08680        	addx4	a8, a6, a8
420093a0:	0848      	l32i.n	a4, a8, 0
                float val2 = vec2_data[i];
420093a2:	5188      	l32i.n	a8, a1, 20
420093a4:	a08680        	addx4	a8, a6, a8
420093a7:	0838      	l32i.n	a3, a8, 0
                if (!float_eq(val1,val1)){
420093a9:	04bd      	mov.n	a11, a4
420093ab:	04ad      	mov.n	a10, a4
420093ad:	ffe5a5        	call8	42009208 <float_eq>
420093b0:	0a5d      	mov.n	a5, a10
420093b2:	4afc      	bnez.n	a10, 420093ea <vector_assert_eq+0x1b2>
                    ESP_LOGE("vector_assert_eq_f32", "Mismatch found at %d, vec1: %f, vec2 %f", i, val1, val2);
420093b4:	db2b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420093b7:	0008e0        	callx8	a8
420093ba:	0a2d      	mov.n	a2, a10
420093bc:	03ad      	mov.n	a10, a3
420093be:	dd5f81        	l32r	a8, 4200093c <_stext+0x91c> (400022a4 <__extendsfdf2>)
420093c1:	0008e0        	callx8	a8
420093c4:	21a9      	s32i.n	a10, a1, 8
420093c6:	31b9      	s32i.n	a11, a1, 12
420093c8:	04ad      	mov.n	a10, a4
420093ca:	dd5c81        	l32r	a8, 4200093c <_stext+0x91c> (400022a4 <__extendsfdf2>)
420093cd:	0008e0        	callx8	a8
420093d0:	01a9      	s32i.n	a10, a1, 0
420093d2:	11b9      	s32i.n	a11, a1, 4
420093d4:	06fd      	mov.n	a15, a6
420093d6:	dd7ee1        	l32r	a14, 420009d0 <_stext+0x9b0> (3c024724 <_flash_rodata_start+0x4604>)
420093d9:	02dd      	mov.n	a13, a2
420093db:	dd7ec1        	l32r	a12, 420009d4 <_stext+0x9b4> (3c02473c <_flash_rodata_start+0x461c>)
420093de:	0ebd      	mov.n	a11, a14
420093e0:	1a0c      	movi.n	a10, 1
420093e2:	db2c81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420093e5:	0008e0        	callx8	a8
                    equals_flag = false;
420093e8:	052d      	mov.n	a2, a5
            for (int i = 0; i < vec1->size; i++)
420093ea:	661b      	addi.n	a6, a6, 1
420093ec:	2788      	l32i.n	a8, a7, 8
420093ee:	a93687        	bltu	a6, a8, 4200939b <vector_assert_eq+0x163>
        default:
            break;
    }
    if (!equals_flag){ return false;}
    return true;
}
420093f1:	f01d      	retw.n
	...

420093f4 <vector_create>:
        .size = (length),                                                \
        .owns_data = false                                               \
    }


vector_t *vector_create(size_t size, dtype type) {
420093f4:	004136        	entry	a1, 32
420093f7:	207220        	or	a7, a2, a2
    if (type < DTYPE_INT8 || type > DTYPE_FLOAT32) { return NULL;}
420093fa:	4043f6        	bgeui	a3, 4, 4200943e <vector_create+0x4a>

    vector_t *vec = malloc(sizeof(vector_t));                                               // Returns NULL if size == 0
420093fd:	10a0a2        	movi	a10, 16
42009400:	dcef81        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
42009403:	0008e0        	callx8	a8
42009406:	202aa0        	or	a2, a10, a10
    if (!vec) { return NULL;}
42009409:	3abc      	beqz.n	a10, 42009440 <vector_create+0x4c>
 
    vec->data = heap_caps_aligned_alloc(16, size * sizeof_dtype(type), MALLOC_CAP_DEFAULT); // Allocate aligned memory for the data array
4200940b:	03ad      	mov.n	a10, a3
4200940d:	0d71a5        	call8	42016b28 <sizeof_dtype>
42009410:	dd62c1        	l32r	a12, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
42009413:	82ba70        	mull	a11, a10, a7
42009416:	0a1c      	movi.n	a10, 16
42009418:	dd6181        	l32r	a8, 4200099c <_stext+0x97c> (40376028 <heap_caps_aligned_alloc>)
4200941b:	0008e0        	callx8	a8
4200941e:	0a6d      	mov.n	a6, a10
42009420:	02a9      	s32i.n	a10, a2, 0
    if (!vec->data) {                                           
42009422:	bacc      	bnez.n	a10, 42009431 <vector_create+0x3d>
        free(vec);  
42009424:	02ad      	mov.n	a10, a2
42009426:	dc5181        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
42009429:	0008e0        	callx8	a8
        return NULL;
4200942c:	062d      	mov.n	a2, a6
4200942e:	000386        	j	42009440 <vector_create+0x4c>
    }

    vec->type = type;
42009431:	1239      	s32i.n	a3, a2, 4
    vec->size = size;  
42009433:	2279      	s32i.n	a7, a2, 8
    vec->owns_data = true;                                                                  // Indicates that this vector_t owns the data 
42009435:	180c      	movi.n	a8, 1
42009437:	0c4282        	s8i	a8, a2, 12
    return vec;                                                                             // Return the created vector_t
4200943a:	000086        	j	42009440 <vector_create+0x4c>
4200943d:	020c00        	andb	b0, b12, b0
}
42009440:	f01d      	retw.n
	...

42009444 <vector_destroy>:
    if ((uint32_t)vec->data & 0xF) { return VECTOR_UNALIGNED_DATA;}                         // Data not 128-bit aligned
    if (vec->type < DTYPE_INT8 || vec->type > DTYPE_FLOAT32) { return VECTOR_TYPE_MISMATCH;}// Invalid Type
    return VECTOR_SUCCESS;                                                                  
}

vector_status_t vector_destroy(vector_t *vec) { 
42009444:	004136        	entry	a1, 32
    if (vec && vec->owns_data) {
42009447:	129c      	beqz.n	a2, 4200945c <vector_destroy+0x18>
42009449:	0c0282        	l8ui	a8, a2, 12
4200944c:	c88c      	beqz.n	a8, 4200945c <vector_destroy+0x18>
        if (vec->data) { 
4200944e:	02a8      	l32i.n	a10, a2, 0
42009450:	8a8c      	beqz.n	a10, 4200945c <vector_destroy+0x18>
            heap_caps_free(vec->data);
42009452:	dd6181        	l32r	a8, 420009d8 <_stext+0x9b8> (40376134 <heap_caps_free>)
42009455:	0008e0        	callx8	a8
            vec->data = NULL;
42009458:	080c      	movi.n	a8, 0
4200945a:	0289      	s32i.n	a8, a2, 0
        }
    }
    free(vec);  
4200945c:	02ad      	mov.n	a10, a2
4200945e:	dc4381        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
42009461:	0008e0        	callx8	a8
    vec = NULL;
    return VECTOR_SUCCESS;
}
42009464:	020c      	movi.n	a2, 0
42009466:	f01d      	retw.n

42009468 <vec_add>:
#include "vector_basic_functions.h"
#include "simd_functions.h"

vector_status_t vec_add(const vector_t *vec1, const vector_t *vec2, vector_t *result) { 
42009468:	004136        	entry	a1, 32
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
4200946b:	22d8      	l32i.n	a13, a2, 8
4200946d:	2388      	l32i.n	a8, a3, 8
4200946f:	6e9d87        	bne	a13, a8, 420094e1 <vec_add+0x79>
42009472:	2488      	l32i.n	a8, a4, 8
42009474:	6e9d87        	bne	a13, a8, 420094e6 <vec_add+0x7e>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42009477:	1288      	l32i.n	a8, a2, 4
42009479:	1398      	l32i.n	a9, a3, 4
4200947b:	6d9897        	bne	a8, a9, 420094ec <vec_add+0x84>
4200947e:	1498      	l32i.n	a9, a4, 4
42009480:	6d9897        	bne	a8, a9, 420094f1 <vec_add+0x89>
    switch (vec1->type) {
42009483:	372826        	beqi	a8, 2, 420094be <vec_add+0x56>
42009486:	0a38f6        	bgeui	a8, 3, 42009494 <vec_add+0x2c>
42009489:	f88c      	beqz.n	a8, 4200949c <vec_add+0x34>
4200948b:	1e1826        	beqi	a8, 1, 420094ad <vec_add+0x45>
4200948e:	320c      	movi.n	a2, 3
42009490:	0017c6        	j	420094f3 <vec_add+0x8b>
42009493:	00          	.byte	00
42009494:	383826        	beqi	a8, 3, 420094d0 <vec_add+0x68>
42009497:	320c      	movi.n	a2, 3
42009499:	001586        	j	420094f3 <vec_add+0x8b>
        case DTYPE_INT8: {
            return simd_add_i8((int8_t*)(vec1->data), (int8_t*)(vec2->data), (int8_t*)(result->data), vec1->size); 
4200949c:	0024c2        	l32i	a12, a4, 0
4200949f:	0023b2        	l32i	a11, a3, 0
420094a2:	0022a2        	l32i	a10, a2, 0
420094a5:	0dcde5        	call8	42017184 <simd_add_i8>
420094a8:	0a2d      	mov.n	a2, a10
420094aa:	001146        	j	420094f3 <vec_add+0x8b>
        }
        case DTYPE_INT16: { 
            return simd_add_i16((int16_t*)(vec1->data), (int16_t*)(vec2->data), (int16_t*)(result->data), vec1->size); 
420094ad:	0024c2        	l32i	a12, a4, 0
420094b0:	0023b2        	l32i	a11, a3, 0
420094b3:	0022a2        	l32i	a10, a2, 0
420094b6:	0062a5        	call8	42009ae0 <simd_add_i16>
420094b9:	0a2d      	mov.n	a2, a10
420094bb:	000d06        	j	420094f3 <vec_add+0x8b>
        }
        case DTYPE_INT32: {
            return simd_add_i32((int32_t*)(vec1->data), (int32_t*)(vec2->data), (int32_t*)(result->data), vec1->size); 
420094be:	0024c2        	l32i	a12, a4, 0
420094c1:	0023b2        	l32i	a11, a3, 0
420094c4:	0022a2        	l32i	a10, a2, 0
420094c7:	0d9fe5        	call8	42016ec4 <simd_add_i32>
420094ca:	0a2d      	mov.n	a2, a10
420094cc:	0008c6        	j	420094f3 <vec_add+0x8b>
420094cf:	24c200        	extui	a12, a0, 2, 3
        }
        case DTYPE_FLOAT32: {
            return simd_add_f32((float*)(vec1->data), (float*)(vec2->data), (float*)(result->data), vec1->size); 
420094d2:	23b200        	sext	a11, a2, 7
420094d5:	22a200        	orb	b10, b2, b0
420094d8:	67e500        	ee.stf.64.xp	f14, f6, a0, a5
420094db:	0d          	.byte	0xd
420094dc:	0a2d      	mov.n	a2, a10
420094de:	000446        	j	420094f3 <vec_add+0x8b>
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
420094e1:	720c      	movi.n	a2, 7
420094e3:	000306        	j	420094f3 <vec_add+0x8b>
420094e6:	720c      	movi.n	a2, 7
420094e8:	0001c6        	j	420094f3 <vec_add+0x8b>
420094eb:	820c00        	mull	a0, a12, a0
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
420094ee:	000046        	j	420094f3 <vec_add+0x8b>
420094f1:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR; 
    }   
}
420094f3:	f01d      	retw.n
420094f5:	000000        	ill

420094f8 <vec_sub>:
 
vector_status_t vec_sub(const vector_t *vec1, const vector_t *vec2, vector_t *result) {  
420094f8:	004136        	entry	a1, 32
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
420094fb:	22d8      	l32i.n	a13, a2, 8
420094fd:	2388      	l32i.n	a8, a3, 8
420094ff:	6e9d87        	bne	a13, a8, 42009571 <vec_sub+0x79>
42009502:	2488      	l32i.n	a8, a4, 8
42009504:	6e9d87        	bne	a13, a8, 42009576 <vec_sub+0x7e>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;} 
42009507:	1288      	l32i.n	a8, a2, 4
42009509:	1398      	l32i.n	a9, a3, 4
4200950b:	6d9897        	bne	a8, a9, 4200957c <vec_sub+0x84>
4200950e:	1498      	l32i.n	a9, a4, 4
42009510:	6d9897        	bne	a8, a9, 42009581 <vec_sub+0x89>
    switch (vec1->type) {
42009513:	372826        	beqi	a8, 2, 4200954e <vec_sub+0x56>
42009516:	0938f6        	bgeui	a8, 3, 42009523 <vec_sub+0x2b>
42009519:	f88c      	beqz.n	a8, 4200952c <vec_sub+0x34>
4200951b:	1e1826        	beqi	a8, 1, 4200953d <vec_sub+0x45>
4200951e:	320c      	movi.n	a2, 3
42009520:	0017c6        	j	42009583 <vec_sub+0x8b>
42009523:	393826        	beqi	a8, 3, 42009560 <vec_sub+0x68>
42009526:	320c      	movi.n	a2, 3
42009528:	0015c6        	j	42009583 <vec_sub+0x8b>
4200952b:	24c200        	extui	a12, a0, 2, 3
        case DTYPE_INT8: {
            return simd_sub_i8((int8_t*)(vec1->data), (int8_t*)(vec2->data), (int8_t*)(result->data), vec1->size);                                             
4200952e:	23b200        	sext	a11, a2, 7
42009531:	22a200        	orb	b10, b2, b0
42009534:	e2a500        	remu	a10, a5, a0
42009537:	0d          	.byte	0xd
42009538:	0a2d      	mov.n	a2, a10
4200953a:	001146        	j	42009583 <vec_sub+0x8b>
        }
        case DTYPE_INT16: {
            return simd_sub_i16((int16_t*)(vec1->data), (int16_t*)(vec2->data), (int16_t*)(result->data), vec1->size); 
4200953d:	0024c2        	l32i	a12, a4, 0
42009540:	0023b2        	l32i	a11, a3, 0
42009543:	0022a2        	l32i	a10, a2, 0
42009546:	0062e5        	call8	42009b74 <simd_sub_i16>
42009549:	0a2d      	mov.n	a2, a10
4200954b:	000d06        	j	42009583 <vec_sub+0x8b>
        }
        case DTYPE_INT32: {
            return simd_sub_i32((int32_t*)(vec1->data), (int32_t*)(vec2->data), (int32_t*)(result->data), vec1->size); 
4200954e:	0024c2        	l32i	a12, a4, 0
42009551:	0023b2        	l32i	a11, a3, 0
42009554:	0022a2        	l32i	a10, a2, 0
42009557:	0db5e5        	call8	420170b4 <simd_sub_i32>
4200955a:	0a2d      	mov.n	a2, a10
4200955c:	0008c6        	j	42009583 <vec_sub+0x8b>
4200955f:	24c200        	extui	a12, a0, 2, 3
        }
        case DTYPE_FLOAT32: { 
            return simd_sub_f32((float*)(vec1->data), (float*)(vec2->data), (float*)(result->data), vec1->size);  
42009562:	23b200        	sext	a11, a2, 7
42009565:	22a200        	orb	b10, b2, b0
42009568:	742500        	extui	a2, a0, 5, 8
4200956b:	0d          	.byte	0xd
4200956c:	0a2d      	mov.n	a2, a10
4200956e:	000446        	j	42009583 <vec_sub+0x8b>
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
42009571:	720c      	movi.n	a2, 7
42009573:	000306        	j	42009583 <vec_sub+0x8b>
42009576:	720c      	movi.n	a2, 7
42009578:	0001c6        	j	42009583 <vec_sub+0x8b>
4200957b:	820c00        	mull	a0, a12, a0
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;} 
4200957e:	000046        	j	42009583 <vec_sub+0x8b>
42009581:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR;                                  
    } 
}
42009583:	f01d      	retw.n
42009585:	000000        	ill

42009588 <vec_add_scalar>:

vector_status_t vec_add_scalar(const vector_t *vec1, const int value, vector_t *result) { 
42009588:	006136        	entry	a1, 48
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
4200958b:	22d8      	l32i.n	a13, a2, 8
4200958d:	2488      	l32i.n	a8, a4, 8
4200958f:	7a9d87        	bne	a13, a8, 4200960d <vec_add_scalar+0x85>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42009592:	1288      	l32i.n	a8, a2, 4
42009594:	1498      	l32i.n	a9, a4, 4
42009596:	789897        	bne	a8, a9, 42009612 <vec_add_scalar+0x8a>
    switch (vec1->type)
42009599:	5d2826        	beqi	a8, 2, 420095fa <vec_add_scalar+0x72>
4200959c:	0938f6        	bgeui	a8, 3, 420095a9 <vec_add_scalar+0x21>
4200959f:	e88c      	beqz.n	a8, 420095b1 <vec_add_scalar+0x29>
420095a1:	2f1826        	beqi	a8, 1, 420095d4 <vec_add_scalar+0x4c>
        }
        case DTYPE_FLOAT32:{
            return VECTOR_UNSUPPORTED_OPERATION; // Please use vec_add_scalar_f32()
        }
        default:
            return VECTOR_ERROR;
420095a4:	320c      	movi.n	a2, 3
420095a6:	001c06        	j	4200961a <vec_add_scalar+0x92>
    switch (vec1->type)
420095a9:	6b3866        	bnei	a8, 3, 42009618 <vec_add_scalar+0x90>
420095ac:	420c      	movi.n	a2, 4
420095ae:	001a06        	j	4200961a <vec_add_scalar+0x92>
            if(value < INT8_MIN || value > INT8_MAX) {return VECTOR_INVALID_ARGUMENT;}     
420095b1:	80a082        	movi	a8, 128
420095b4:	838a      	add.n	a8, a3, a8
420095b6:	ffa092        	movi	a9, 255
420095b9:	103987        	bltu	a9, a8, 420095cd <vec_add_scalar+0x45>
            int8_t val = (int8_t)value;                                                     
420095bc:	004132        	s8i	a3, a1, 0
            return simd_add_scalar_i8((int8_t*)(vec1->data), &val, (int8_t*)(result->data), vec1->size);  
420095bf:	04c8      	l32i.n	a12, a4, 0
420095c1:	01bd      	mov.n	a11, a1
420095c3:	02a8      	l32i.n	a10, a2, 0
420095c5:	0dc0e5        	call8	420171d4 <simd_add_scalar_i8>
420095c8:	0a2d      	mov.n	a2, a10
420095ca:	001306        	j	4200961a <vec_add_scalar+0x92>
            if(value < INT8_MIN || value > INT8_MAX) {return VECTOR_INVALID_ARGUMENT;}     
420095cd:	220c      	movi.n	a2, 2
420095cf:	0011c6        	j	4200961a <vec_add_scalar+0x92>
420095d2:	810000        	src	a0, a0, a0
            if(value < INT16_MIN  || value > INT16_MAX) {return VECTOR_INVALID_ARGUMENT;}    
420095d5:	80db21        	l32r	a2, 41fe9944 <_iram_bss_end+0x1c67544>
420095d8:	918083        	lsip	f8, a0, 0x244
420095db:	87dca4        	ee.vmulas.s16.qacc.ldbc.incp	q2, a10, q4, q7
420095de:	1339      	s32i.n	a3, a3, 4
            int16_t val = (int16_t)value;                                                
420095e0:	005132        	s16i	a3, a1, 0
            return simd_add_scalar_i16((int16_t*)(vec1->data), &val, (int16_t*)(result->data), vec1->size);  
420095e3:	0024c2        	l32i	a12, a4, 0
420095e6:	20b110        	or	a11, a1, a1
420095e9:	02a8      	l32i.n	a10, a2, 0
420095eb:	005425        	call8	42009b2c <simd_add_scalar_i16>
420095ee:	0a2d      	mov.n	a2, a10
420095f0:	000986        	j	4200961a <vec_add_scalar+0x92>
420095f3:	220c00        	orb	b0, b12, b0
            if(value < INT16_MIN  || value > INT16_MAX) {return VECTOR_INVALID_ARGUMENT;}    
420095f6:	000806        	j	4200961a <vec_add_scalar+0x92>
420095f9:	00          	.byte	00
            int32_t val = (int32_t)value;             
420095fa:	006132        	s32i	a3, a1, 0
            return simd_add_scalar_i32((int32_t*)(vec1->data), &val, (int32_t*)(result->data), vec1->size);  
420095fd:	0024c2        	l32i	a12, a4, 0
42009600:	20b110        	or	a11, a1, a1
42009603:	02a8      	l32i.n	a10, a2, 0
42009605:	0d8fe5        	call8	42016f04 <simd_add_scalar_i32>
42009608:	0a2d      	mov.n	a2, a10
4200960a:	000306        	j	4200961a <vec_add_scalar+0x92>
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
4200960d:	720c      	movi.n	a2, 7
4200960f:	0001c6        	j	4200961a <vec_add_scalar+0x92>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42009612:	820c      	movi.n	a2, 8
42009614:	000086        	j	4200961a <vec_add_scalar+0x92>
42009617:	320c00        	orbc	b0, b12, b0
    }  
}
4200961a:	f01d      	retw.n

4200961c <vec_add_scalar_f32>:

vector_status_t vec_add_scalar_f32(const vector_t *vec1, const float value, vector_t *result) { 
4200961c:	006136        	entry	a1, 48
4200961f:	006132        	s32i	a3, a1, 0
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42009622:	0222d2        	l32i	a13, a2, 8
42009625:	022482        	l32i	a8, a4, 8
42009628:	1a9d87        	bne	a13, a8, 42009646 <vec_add_scalar_f32+0x2a>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
4200962b:	1288      	l32i.n	a8, a2, 4
4200962d:	1498      	l32i.n	a9, a4, 4
4200962f:	199897        	bne	a8, a9, 4200964c <vec_add_scalar_f32+0x30>
    switch (vec1->type)
42009632:	1b38b6        	bltui	a8, 3, 42009651 <vec_add_scalar_f32+0x35>
42009635:	1d3866        	bnei	a8, 3, 42009656 <vec_add_scalar_f32+0x3a>
    {
        case DTYPE_INT8: return VECTOR_UNSUPPORTED_OPERATION;                                 
        case DTYPE_INT16: return VECTOR_UNSUPPORTED_OPERATION;
        case DTYPE_INT32: return VECTOR_UNSUPPORTED_OPERATION;
        case DTYPE_FLOAT32:{
            return simd_add_scalar_f32((float*)(vec1->data), &value, (float*)(result->data), vec1->size);
42009638:	04c8      	l32i.n	a12, a4, 0
4200963a:	01bd      	mov.n	a11, a1
4200963c:	02a8      	l32i.n	a10, a2, 0
4200963e:	0d5565        	call8	42016b94 <simd_add_scalar_f32>
42009641:	0a2d      	mov.n	a2, a10
42009643:	000446        	j	42009658 <vec_add_scalar_f32+0x3c>
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42009646:	720c      	movi.n	a2, 7
42009648:	000306        	j	42009658 <vec_add_scalar_f32+0x3c>
4200964b:	820c00        	mull	a0, a12, a0
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
4200964e:	000186        	j	42009658 <vec_add_scalar_f32+0x3c>
    switch (vec1->type)
42009651:	420c      	movi.n	a2, 4
42009653:	000046        	j	42009658 <vec_add_scalar_f32+0x3c>
        }
        default:
            return VECTOR_ERROR;
42009656:	320c      	movi.n	a2, 3
    }  
}
42009658:	f01d      	retw.n
	...

4200965c <vec_mul>:

vector_status_t vec_mul(const vector_t *vec1, const vector_t *vec2, vector_t *result, const unsigned int shift_amount) { 
4200965c:	004136        	entry	a1, 32
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
4200965f:	22e8      	l32i.n	a14, a2, 8
42009661:	2388      	l32i.n	a8, a3, 8
42009663:	799e87        	bne	a14, a8, 420096e0 <vec_mul+0x84>
42009666:	2488      	l32i.n	a8, a4, 8
42009668:	799e87        	bne	a14, a8, 420096e5 <vec_mul+0x89>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
4200966b:	1288      	l32i.n	a8, a2, 4
4200966d:	1398      	l32i.n	a9, a3, 4
4200966f:	779897        	bne	a8, a9, 420096ea <vec_mul+0x8e>
42009672:	1498      	l32i.n	a9, a4, 4
42009674:	779897        	bne	a8, a9, 420096ef <vec_mul+0x93>
    switch (vec1->type) {
42009677:	3d2826        	beqi	a8, 2, 420096b8 <vec_mul+0x5c>
4200967a:	0a38f6        	bgeui	a8, 3, 42009688 <vec_mul+0x2c>
4200967d:	f88c      	beqz.n	a8, 42009690 <vec_mul+0x34>
4200967f:	211826        	beqi	a8, 1, 420096a4 <vec_mul+0x48>
42009682:	320c      	movi.n	a2, 3
42009684:	001a46        	j	420096f1 <vec_mul+0x95>
42009687:	00          	.byte	00
42009688:	403826        	beqi	a8, 3, 420096cc <vec_mul+0x70>
4200968b:	320c      	movi.n	a2, 3
4200968d:	001806        	j	420096f1 <vec_mul+0x95>
        case DTYPE_INT8: { 
            return simd_mul_shift_i8((int8_t*)(vec1->data), (int8_t*)(vec2->data), (int8_t*)(result->data), shift_amount, vec1->size);
42009690:	20d550        	or	a13, a5, a5
42009693:	0024c2        	l32i	a12, a4, 0
42009696:	0023b2        	l32i	a11, a3, 0
42009699:	02a8      	l32i.n	a10, a2, 0
4200969b:	0dc7a5        	call8	42017314 <simd_mul_shift_i8>
4200969e:	0a2d      	mov.n	a2, a10
420096a0:	001346        	j	420096f1 <vec_mul+0x95>
420096a3:	d55000        	extui	a5, a0, 16, 14
        }
        case DTYPE_INT16: { 
            return simd_mul_shift_i16((int16_t*)(vec1->data), (int16_t*)(vec2->data), (int16_t*)(result->data), shift_amount, vec1->size); 
420096a6:	24c220        	extui	a12, a2, 2, 3
420096a9:	23b200        	sext	a11, a2, 7
420096ac:	02a800        	andb	b10, b8, b0
420096af:	0d7525        	call8	42016e00 <simd_mul_shift_i16>
420096b2:	0a2d      	mov.n	a2, a10
420096b4:	000e46        	j	420096f1 <vec_mul+0x95>
420096b7:	d55000        	extui	a5, a0, 16, 14
        }
        case DTYPE_INT32: { 
            return simd_mul_shift_i32((int32_t*)(vec1->data), (int32_t*)(vec2->data), (int32_t*)(result->data), shift_amount, vec1->size);
420096ba:	24c220        	extui	a12, a2, 2, 3
420096bd:	23b200        	sext	a11, a2, 7
420096c0:	02a800        	andb	b10, b8, b0
420096c3:	0d9765        	call8	42017038 <simd_mul_shift_i32>
420096c6:	0a2d      	mov.n	a2, a10
420096c8:	000946        	j	420096f1 <vec_mul+0x95>
420096cb:	d55000        	extui	a5, a0, 16, 14
        }
        case DTYPE_FLOAT32: {
            return simd_mul_shift_f32((float*)(vec1->data), (float*)(vec2->data), (float*)(result->data), shift_amount, vec1->size);  
420096ce:	24c220        	extui	a12, a2, 2, 3
420096d1:	23b200        	sext	a11, a2, 7
420096d4:	02a800        	andb	b10, b8, b0
420096d7:	0d59a5        	call8	42016c70 <simd_mul_shift_f32>
420096da:	0a2d      	mov.n	a2, a10
420096dc:	000446        	j	420096f1 <vec_mul+0x95>
420096df:	720c00        	salt	a0, a12, a0
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
420096e2:	0002c6        	j	420096f1 <vec_mul+0x95>
420096e5:	720c      	movi.n	a2, 7
420096e7:	000186        	j	420096f1 <vec_mul+0x95>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
420096ea:	820c      	movi.n	a2, 8
420096ec:	000046        	j	420096f1 <vec_mul+0x95>
420096ef:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR; 
    }  
}
420096f1:	f01d      	retw.n
	...

420096f4 <vec_sum>:

vector_status_t vec_sum(const vector_t *vec1, int32_t* result){ 
420096f4:	004136        	entry	a1, 32
420096f7:	03bd      	mov.n	a11, a3
    switch (vec1->type){
420096f9:	1288      	l32i.n	a8, a2, 4
420096fb:	352826        	beqi	a8, 2, 42009734 <vec_sum+0x40>
420096fe:	0a38f6        	bgeui	a8, 3, 4200970c <vec_sum+0x18>
42009701:	f88c      	beqz.n	a8, 42009714 <vec_sum+0x20>
42009703:	1d1826        	beqi	a8, 1, 42009724 <vec_sum+0x30>
        }
        case(DTYPE_FLOAT32): {
            return VECTOR_UNSUPPORTED_OPERATION; // Please use vec_sum_f32
        }
        default:
            return VECTOR_ERROR;
42009706:	320c      	movi.n	a2, 3
42009708:	000e86        	j	42009746 <vec_sum+0x52>
4200970b:	00          	.byte	00
    switch (vec1->type){
4200970c:	343866        	bnei	a8, 3, 42009744 <vec_sum+0x50>
4200970f:	420c      	movi.n	a2, 4
42009711:	000c46        	j	42009746 <vec_sum+0x52>
            return simd_sum_i8((int8_t*)(vec1->data), result, vec1->size); 
42009714:	0222c2        	l32i	a12, a2, 8
42009717:	0022a2        	l32i	a10, a2, 0
4200971a:	0dc9a5        	call8	420173b4 <simd_sum_i8>
4200971d:	202aa0        	or	a2, a10, a10
42009720:	000886        	j	42009746 <vec_sum+0x52>
42009723:	22c200        	orb	b12, b2, b0
            return simd_sum_i16((int16_t*)(vec1->data), result, vec1->size); 
42009726:	22a202        	movi	a0, 0x222
42009729:	00          	.byte	00
4200972a:	0d71e5        	call8	42016e48 <simd_sum_i16>
4200972d:	202aa0        	or	a2, a10, a10
42009730:	000486        	j	42009746 <vec_sum+0x52>
42009733:	22c200        	orb	b12, b2, b0
            return simd_sum_i32((int32_t*)(vec1->data), result, vec1->size); 
42009736:	22a202        	movi	a0, 0x222
42009739:	9ba500        	movnez.s	f10, f5, a0
4200973c:	0d          	.byte	0xd
4200973d:	202aa0        	or	a2, a10, a10
42009740:	000086        	j	42009746 <vec_sum+0x52>
42009743:	320c00        	orbc	b0, b12, b0
    } 
}
42009746:	f01d      	retw.n

42009748 <vec_sum_f32>:

vector_status_t vec_sum_f32(const vector_t *vec1, float* result){ 
42009748:	004136        	entry	a1, 32
    switch (vec1->type){
4200974b:	1288      	l32i.n	a8, a2, 4
4200974d:	1038b6        	bltui	a8, 3, 42009761 <vec_sum_f32+0x19>
42009750:	123866        	bnei	a8, 3, 42009766 <vec_sum_f32+0x1e>
        case(DTYPE_INT8): return VECTOR_UNSUPPORTED_OPERATION;  
        case(DTYPE_INT16): return VECTOR_UNSUPPORTED_OPERATION;   
        case(DTYPE_INT32): return VECTOR_UNSUPPORTED_OPERATION;  
        case(DTYPE_FLOAT32):  {
            return simd_sum_f32((float*)vec1->data, result, vec1->size); // Please use vec_sum
42009753:	22c8      	l32i.n	a12, a2, 8
42009755:	03bd      	mov.n	a11, a3
42009757:	02a8      	l32i.n	a10, a2, 0
42009759:	0d58e5        	call8	42016ce8 <simd_sum_f32>
4200975c:	0a2d      	mov.n	a2, a10
4200975e:	000186        	j	42009768 <vec_sum_f32+0x20>
    switch (vec1->type){
42009761:	420c      	movi.n	a2, 4
42009763:	000046        	j	42009768 <vec_sum_f32+0x20>
        }
        default:
            return VECTOR_ERROR;
42009766:	320c      	movi.n	a2, 3
    } 
}
42009768:	f01d      	retw.n
	...

4200976c <vec_mul_scalar>:

vector_status_t vec_mul_scalar(const vector_t *vec1, const int value, vector_t *result, const unsigned int shift_amount) {  
4200976c:	006136        	entry	a1, 48
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
4200976f:	22e8      	l32i.n	a14, a2, 8
42009771:	2488      	l32i.n	a8, a4, 8
42009773:	021e87        	beq	a14, a8, 42009779 <vec_mul_scalar+0xd>
42009776:	002186        	j	42009800 <vec_mul_scalar+0x94>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
42009779:	1288      	l32i.n	a8, a2, 4
4200977b:	1498      	l32i.n	a9, a4, 4
4200977d:	021897        	beq	a8, a9, 42009783 <vec_mul_scalar+0x17>
42009780:	002046        	j	42009805 <vec_mul_scalar+0x99>
    switch (vec1->type) {
42009783:	632826        	beqi	a8, 2, 420097ea <vec_mul_scalar+0x7e>
42009786:	0938f6        	bgeui	a8, 3, 42009793 <vec_mul_scalar+0x27>
42009789:	f88c      	beqz.n	a8, 4200979c <vec_mul_scalar+0x30>
4200978b:	351826        	beqi	a8, 1, 420097c4 <vec_mul_scalar+0x58>
        }
        case DTYPE_FLOAT32: {
            return VECTOR_UNSUPPORTED_OPERATION;  
        }
        default:
            return VECTOR_ERROR;                                                 
4200978e:	320c      	movi.n	a2, 3
42009790:	001e06        	j	4200980c <vec_mul_scalar+0xa0>
    switch (vec1->type) {
42009793:	733866        	bnei	a8, 3, 4200980a <vec_mul_scalar+0x9e>
42009796:	420c      	movi.n	a2, 4
42009798:	001c06        	j	4200980c <vec_mul_scalar+0xa0>
4200979b:	a08200        	addx4	a8, a2, a0
            if(value < INT8_MIN || value > INT8_MAX) {return VECTOR_INVALID_ARGUMENT;}          
4200979e:	838080        	moveqz	a8, a0, a8
420097a1:	a09280        	addx4	a9, a2, a8
420097a4:	143987ff 	ee.vmulas.s16.qacc.ld.ip.qup	q1, a15, 0x170, q6, q0, q3, q1
            int8_t val = (int8_t)value; 
420097a8:	004132        	s8i	a3, a1, 0
            return simd_mul_scalar_i8(vec1->data, &val, result->data, shift_amount, vec1->size); 
420097ab:	20d550        	or	a13, a5, a5
420097ae:	0024c2        	l32i	a12, a4, 0
420097b1:	01bd      	mov.n	a11, a1
420097b3:	02a8      	l32i.n	a10, a2, 0
420097b5:	0db125        	call8	420172c8 <simd_mul_scalar_i8>
420097b8:	0a2d      	mov.n	a2, a10
420097ba:	001386        	j	4200980c <vec_mul_scalar+0xa0>
            if(value < INT8_MIN || value > INT8_MAX) {return VECTOR_INVALID_ARGUMENT;}          
420097bd:	220c      	movi.n	a2, 2
420097bf:	001246        	j	4200980c <vec_mul_scalar+0xa0>
420097c2:	810000        	src	a0, a0, a0
            if(value < INT16_MIN || value > INT16_MAX) {return VECTOR_INVALID_ARGUMENT;}   
420097c5:	80daa5        	call8	41f8a570 <_iram_bss_end+0x1c08170>
420097c8:	918083        	lsip	f8, a0, 0x244
420097cb:	dc28      	l32i.n	a2, a12, 52
420097cd:	143987        	bltu	a9, a8, 420097e5 <vec_mul_scalar+0x79>
            int16_t val = (int16_t)value;   
420097d0:	005132        	s16i	a3, a1, 0
            return simd_mul_scalar_i16(vec1->data, &val, result->data, shift_amount, vec1->size); 
420097d3:	20d550        	or	a13, a5, a5
420097d6:	0024c2        	l32i	a12, a4, 0
420097d9:	01bd      	mov.n	a11, a1
420097db:	02a8      	l32i.n	a10, a2, 0
420097dd:	0d5de5        	call8	42016dbc <simd_mul_scalar_i16>
420097e0:	0a2d      	mov.n	a2, a10
420097e2:	000986        	j	4200980c <vec_mul_scalar+0xa0>
            if(value < INT16_MIN || value > INT16_MAX) {return VECTOR_INVALID_ARGUMENT;}   
420097e5:	220c      	movi.n	a2, 2
420097e7:	000846        	j	4200980c <vec_mul_scalar+0xa0>
            int32_t val = (int32_t)value;   
420097ea:	006132        	s32i	a3, a1, 0
            return simd_mul_scalar_i32((int32_t*)(vec1->data), &val, (int32_t*)(result->data), shift_amount, vec1->size); 
420097ed:	20d550        	or	a13, a5, a5
420097f0:	0024c2        	l32i	a12, a4, 0
420097f3:	01bd      	mov.n	a11, a1
420097f5:	02a8      	l32i.n	a10, a2, 0
420097f7:	0d7d25        	call8	42016fc8 <simd_mul_scalar_i32>
420097fa:	0a2d      	mov.n	a2, a10
420097fc:	000306        	j	4200980c <vec_mul_scalar+0xa0>
420097ff:	720c00        	salt	a0, a12, a0
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42009802:	000186        	j	4200980c <vec_mul_scalar+0xa0>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
42009805:	820c      	movi.n	a2, 8
42009807:	000046        	j	4200980c <vec_mul_scalar+0xa0>
            return VECTOR_ERROR;                                                 
4200980a:	320c      	movi.n	a2, 3
    }  
}
4200980c:	f01d      	retw.n
	...

42009810 <vec_mul_scalar_f32>:

vector_status_t vec_mul_scalar_f32(const vector_t *vec1, const float value, vector_t *result) {  
42009810:	006136        	entry	a1, 48
42009813:	006132        	s32i	a3, a1, 0
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
42009816:	0222d2        	l32i	a13, a2, 8
42009819:	022482        	l32i	a8, a4, 8
4200981c:	1a9d87        	bne	a13, a8, 4200983a <vec_mul_scalar_f32+0x2a>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
4200981f:	1288      	l32i.n	a8, a2, 4
42009821:	1498      	l32i.n	a9, a4, 4
42009823:	189897        	bne	a8, a9, 4200983f <vec_mul_scalar_f32+0x2f>
    switch (vec1->type) {
42009826:	1a38b6        	bltui	a8, 3, 42009844 <vec_mul_scalar_f32+0x34>
42009829:	1c3866        	bnei	a8, 3, 42009849 <vec_mul_scalar_f32+0x39>
        case DTYPE_INT8: return VECTOR_UNSUPPORTED_OPERATION;  
        case DTYPE_INT16: return VECTOR_UNSUPPORTED_OPERATION;   
        case DTYPE_INT32: return VECTOR_UNSUPPORTED_OPERATION;  
        case DTYPE_FLOAT32: {
            return simd_mul_scalar_f32((float*)(vec1->data), &value, (float*)(result->data), vec1->size); 
4200982c:	04c8      	l32i.n	a12, a4, 0
4200982e:	01bd      	mov.n	a11, a1
42009830:	02a8      	l32i.n	a10, a2, 0
42009832:	0d4025        	call8	42016c34 <simd_mul_scalar_f32>
42009835:	0a2d      	mov.n	a2, a10
42009837:	000406        	j	4200984b <vec_mul_scalar_f32+0x3b>
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
4200983a:	720c      	movi.n	a2, 7
4200983c:	0002c6        	j	4200984b <vec_mul_scalar_f32+0x3b>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
4200983f:	820c      	movi.n	a2, 8
42009841:	000186        	j	4200984b <vec_mul_scalar_f32+0x3b>
    switch (vec1->type) {
42009844:	420c      	movi.n	a2, 4
42009846:	000046        	j	4200984b <vec_mul_scalar_f32+0x3b>
        }
        default:
            return VECTOR_ERROR;                                                 
42009849:	320c      	movi.n	a2, 3
    }  
}
4200984b:	f01d      	retw.n
4200984d:	000000        	ill

42009850 <vec_dotp>:

vector_status_t vec_dotp(const vector_t *vec1, const vector_t *vec2, int32_t *result){   
42009850:	004136        	entry	a1, 32
    if (vec1->size != vec2->size ) { return VECTOR_SIZE_MISMATCH;}  
42009853:	22d8      	l32i.n	a13, a2, 8
42009855:	2388      	l32i.n	a8, a3, 8
42009857:	529d87        	bne	a13, a8, 420098ad <vec_dotp+0x5d>
    if (vec1->type != vec2->type) { return VECTOR_TYPE_MISMATCH;}   
4200985a:	1288      	l32i.n	a8, a2, 4
4200985c:	1398      	l32i.n	a9, a3, 4
4200985e:	509897        	bne	a8, a9, 420098b2 <vec_dotp+0x62>
    switch (vec1->type){
42009861:	372826        	beqi	a8, 2, 4200989c <vec_dotp+0x4c>
42009864:	0938f6        	bgeui	a8, 3, 42009871 <vec_dotp+0x21>
42009867:	e88c      	beqz.n	a8, 42009879 <vec_dotp+0x29>
42009869:	1d1826        	beqi	a8, 1, 4200988a <vec_dotp+0x3a>
        }
        case (DTYPE_FLOAT32): { 
            return VECTOR_UNSUPPORTED_OPERATION; // Please use vec_dotp_f32
        }
        default:
            return VECTOR_ERROR; 
4200986c:	320c      	movi.n	a2, 3
4200986e:	001206        	j	420098ba <vec_dotp+0x6a>
    switch (vec1->type){
42009871:	433866        	bnei	a8, 3, 420098b8 <vec_dotp+0x68>
42009874:	420c      	movi.n	a2, 4
42009876:	001006        	j	420098ba <vec_dotp+0x6a>
            return simd_dotp_i8((int8_t*)(vec1->data), (int8_t*)(vec2->data), result,vec1->size); 
42009879:	20c440        	or	a12, a4, a4
4200987c:	0023b2        	l32i	a11, a3, 0
4200987f:	0022a2        	l32i	a10, a2, 0
42009882:	0da025        	call8	42017284 <simd_dotp_i8>
42009885:	0a2d      	mov.n	a2, a10
42009887:	000bc6        	j	420098ba <vec_dotp+0x6a>
            return simd_dotp_i16((int16_t*)(vec1->data), (int16_t*)(vec2->data), result,vec1->size); 
4200988a:	20c440        	or	a12, a4, a4
4200988d:	0023b2        	l32i	a11, a3, 0
42009890:	0022a2        	l32i	a10, a2, 0
42009893:	0d4ea5        	call8	42016d7c <simd_dotp_i16>
42009896:	0a2d      	mov.n	a2, a10
42009898:	000786        	j	420098ba <vec_dotp+0x6a>
4200989b:	c44000        	extui	a4, a0, 0, 13
            return simd_dotp_i32((int32_t*)(vec1->data), (int32_t*)(vec2->data), result,vec1->size); 
4200989e:	23b220        	sext	a11, a2, 9
420098a1:	22a200        	orb	b10, b2, b0
420098a4:	00          	.byte	00
420098a5:	0d6d25        	call8	42016f78 <simd_dotp_i32>
420098a8:	0a2d      	mov.n	a2, a10
420098aa:	000306        	j	420098ba <vec_dotp+0x6a>
    if (vec1->size != vec2->size ) { return VECTOR_SIZE_MISMATCH;}  
420098ad:	720c      	movi.n	a2, 7
420098af:	0001c6        	j	420098ba <vec_dotp+0x6a>
    if (vec1->type != vec2->type) { return VECTOR_TYPE_MISMATCH;}   
420098b2:	820c      	movi.n	a2, 8
420098b4:	000086        	j	420098ba <vec_dotp+0x6a>
420098b7:	320c00        	orbc	b0, b12, b0
    }
}
420098ba:	f01d      	retw.n

420098bc <vec_dotp_f32>:

vector_status_t vec_dotp_f32(const vector_t *vec1, const vector_t *vec2, float *result){   
420098bc:	004136        	entry	a1, 32
    if (vec1->size != vec2->size ) { return VECTOR_SIZE_MISMATCH;}  
420098bf:	22d8      	l32i.n	a13, a2, 8
420098c1:	2388      	l32i.n	a8, a3, 8
420098c3:	1a9d87        	bne	a13, a8, 420098e1 <vec_dotp_f32+0x25>
    if (vec1->type != vec2->type) { return VECTOR_TYPE_MISMATCH;}   
420098c6:	1288      	l32i.n	a8, a2, 4
420098c8:	1398      	l32i.n	a9, a3, 4
420098ca:	189897        	bne	a8, a9, 420098e6 <vec_dotp_f32+0x2a>
    
    switch (vec1->type){
420098cd:	1b38b6        	bltui	a8, 3, 420098ec <vec_dotp_f32+0x30>
420098d0:	1d3866        	bnei	a8, 3, 420098f1 <vec_dotp_f32+0x35>
        case (DTYPE_INT8):   return VECTOR_UNSUPPORTED_OPERATION;
        case (DTYPE_INT16):  return VECTOR_UNSUPPORTED_OPERATION;
        case (DTYPE_INT32):  return VECTOR_UNSUPPORTED_OPERATION;
        case (DTYPE_FLOAT32): {
            return simd_dotp_f32((float*)(vec1->data), (float*)(vec2->data), result,vec1->size); 
420098d3:	04cd      	mov.n	a12, a4
420098d5:	03b8      	l32i.n	a11, a3, 0
420098d7:	02a8      	l32i.n	a10, a2, 0
420098d9:	0d31a5        	call8	42016bf4 <simd_dotp_f32>
420098dc:	0a2d      	mov.n	a2, a10
420098de:	000446        	j	420098f3 <vec_dotp_f32+0x37>
    if (vec1->size != vec2->size ) { return VECTOR_SIZE_MISMATCH;}  
420098e1:	720c      	movi.n	a2, 7
420098e3:	000306        	j	420098f3 <vec_dotp_f32+0x37>
    if (vec1->type != vec2->type) { return VECTOR_TYPE_MISMATCH;}   
420098e6:	820c      	movi.n	a2, 8
420098e8:	0001c6        	j	420098f3 <vec_dotp_f32+0x37>
420098eb:	420c00        	xorb	b0, b12, b0
    switch (vec1->type){
420098ee:	000046        	j	420098f3 <vec_dotp_f32+0x37>
        }
        default:
            return VECTOR_ERROR;  
420098f1:	320c      	movi.n	a2, 3
    }
}
420098f3:	f01d      	retw.n
420098f5:	000000        	ill

420098f8 <vec_abs>:

vector_status_t vec_abs(const vector_t *vec1, vector_t* result){ 
420098f8:	004136        	entry	a1, 32
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
420098fb:	22c8      	l32i.n	a12, a2, 8
420098fd:	2388      	l32i.n	a8, a3, 8
420098ff:	5e9c87        	bne	a12, a8, 42009961 <vec_abs+0x69>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}   
42009902:	1288      	l32i.n	a8, a2, 4
42009904:	1398      	l32i.n	a9, a3, 4
42009906:	5c9897        	bne	a8, a9, 42009966 <vec_abs+0x6e>

    switch (vec1->type){
42009909:	352826        	beqi	a8, 2, 42009942 <vec_abs+0x4a>
4200990c:	0938f6        	bgeui	a8, 3, 42009919 <vec_abs+0x21>
4200990f:	f88c      	beqz.n	a8, 42009922 <vec_abs+0x2a>
42009911:	1d1826        	beqi	a8, 1, 42009932 <vec_abs+0x3a>
42009914:	520c      	movi.n	a2, 5
42009916:	001386        	j	42009968 <vec_abs+0x70>
42009919:	353826        	beqi	a8, 3, 42009952 <vec_abs+0x5a>
4200991c:	520c      	movi.n	a2, 5
4200991e:	001186        	j	42009968 <vec_abs+0x70>
42009921:	23b200        	sext	a11, a2, 7
        case (DTYPE_INT8): {
            return simd_abs_i8((int8_t*)(vec1->data), (int8_t*)(result->data), vec1->size); 
42009924:	22a200        	orb	b10, b2, b0
42009927:	80a500        	add	a10, a5, a0
4200992a:	0d          	.byte	0xd
4200992b:	202aa0        	or	a2, a10, a10
4200992e:	000d86        	j	42009968 <vec_abs+0x70>
42009931:	23b200        	sext	a11, a2, 7
        }
        case (DTYPE_INT16): {
            return simd_abs_i16((int16_t*)(vec1->data), (int16_t*)(result->data), vec1->size); 
42009934:	22a200        	orb	b10, b2, b0
42009937:	15a500        	extui	a10, a0, 21, 2
4200993a:	2aa000        	mul.s	f10, f0, f0
4200993d:	098620        	l32e	a2, a6, -32
42009940:	b20000        	mulsh	a0, a0, a0
        }
        case (DTYPE_INT32): { 
            return simd_abs_i32((int32_t*)(vec1->data), (int32_t*)(result->data), vec1->size);
42009943:	a20023        	lsi	f2, a0, 0x288
42009946:	a50022        	l8ui	a2, a0, 165
42009949:	a00d53        	lsi	f5, a13, 0x280
4200994c:	202a      	add.n	a2, a0, a2
4200994e:	000586        	j	42009968 <vec_abs+0x70>
42009951:	23b200        	sext	a11, a2, 7
        };
        case (DTYPE_FLOAT32): { 
            return simd_abs_f32((float*)(vec1->data), (float*)(result->data), vec1->size);
42009954:	22a200        	orb	b10, b2, b0
42009957:	10a500        	and	a10, a5, a0
4200995a:	2aa000        	mul.s	f10, f0, f0
4200995d:	018620        	slli	a8, a6, 30
42009960:	720c00        	salt	a0, a12, a0
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42009963:	000046        	j	42009968 <vec_abs+0x70>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}   
42009966:	820c      	movi.n	a2, 8
        };
        default:
            return VECTOR_NOT_IMPLEMENTED;
    }
}
42009968:	f01d      	retw.n
	...

4200996c <vec_ceil>:

vector_status_t vec_ceil(const vector_t *vec1, vector_t* result, const int ceiling){ 
4200996c:	006136        	entry	a1, 48
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
4200996f:	0222d2        	l32i	a13, a2, 8
42009972:	022382        	l32i	a8, a3, 8
42009975:	6c9d87        	bne	a13, a8, 420099e5 <vec_ceil+0x79>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
42009978:	012282        	l32i	a8, a2, 4
4200997b:	1398      	l32i.n	a9, a3, 4
4200997d:	699897        	bne	a8, a9, 420099ea <vec_ceil+0x7e>
    switch (vec1->type){
42009980:	281826        	beqi	a8, 1, 420099ac <vec_ceil+0x40>
42009983:	4b2826        	beqi	a8, 2, 420099d2 <vec_ceil+0x66>
42009986:	066856        	bnez	a8, 420099f0 <vec_ceil+0x84>
        case (DTYPE_INT8): {
            if(ceiling < INT8_MIN || ceiling > INT8_MAX) { return VECTOR_INVALID_ARGUMENT;}                  // Ensure ceiling is within int8_t range
42009989:	80a082        	movi	a8, 128
4200998c:	848a      	add.n	a8, a4, a8
4200998e:	ffa092        	movi	a9, 255
42009991:	103987        	bltu	a9, a8, 420099a5 <vec_ceil+0x39>
            int8_t ceil = (int8_t)ceiling;                                  // Cast int to int8_t pointer
42009994:	004142        	s8i	a4, a1, 0
            return simd_ceil_i8((int8_t*)(vec1->data), (int8_t*)(result->data), &ceil, vec1->size); 
42009997:	01cd      	mov.n	a12, a1
42009999:	03b8      	l32i.n	a11, a3, 0
4200999b:	02a8      	l32i.n	a10, a2, 0
4200999d:	0d8825        	call8	42017220 <simd_ceil_i8>
420099a0:	0a2d      	mov.n	a2, a10
420099a2:	001306        	j	420099f2 <vec_ceil+0x86>
            if(ceiling < INT8_MIN || ceiling > INT8_MAX) { return VECTOR_INVALID_ARGUMENT;}                  // Ensure ceiling is within int8_t range
420099a5:	220c      	movi.n	a2, 2
420099a7:	0011c6        	j	420099f2 <vec_ceil+0x86>
420099aa:	810000        	src	a0, a0, a0
        }
        case (DTYPE_INT16): { 
            if(ceiling < INT16_MIN || ceiling > INT16_MAX) { return VECTOR_INVALID_ARGUMENT;}                 // Ensure ceiling is within int16_t range
420099ad:	da2b      	addi.n	a13, a10, 2
420099af:	808480        	add	a8, a4, a8
420099b2:	dbae91        	l32r	a9, 4200086c <_stext+0x84c> (ffff <UserFrameTotalSize+0xfeff>)
420099b5:	133987        	bltu	a9, a8, 420099cc <vec_ceil+0x60>
            int16_t ceil = (int16_t)ceiling;                                // Cast int to int16_t pointer
420099b8:	005142        	s16i	a4, a1, 0
            return simd_ceil_i16((int16_t*)(vec1->data), (int16_t*)(result->data), &ceil, vec1->size); 
420099bb:	20c110        	or	a12, a1, a1
420099be:	0023b2        	l32i	a11, a3, 0
420099c1:	02a8      	l32i.n	a10, a2, 0
420099c3:	0d35e5        	call8	42016d20 <simd_ceil_i16>
420099c6:	0a2d      	mov.n	a2, a10
420099c8:	000986        	j	420099f2 <vec_ceil+0x86>
420099cb:	220c00        	orb	b0, b12, b0
            if(ceiling < INT16_MIN || ceiling > INT16_MAX) { return VECTOR_INVALID_ARGUMENT;}                 // Ensure ceiling is within int16_t range
420099ce:	000806        	j	420099f2 <vec_ceil+0x86>
420099d1:	00          	.byte	00
        }
        case (DTYPE_INT32): { 
            int32_t ceil = (int32_t)ceiling;                                // Cast int to int16_t pointer
420099d2:	006142        	s32i	a4, a1, 0
            return simd_ceil_i32((int32_t*)(vec1->data), (int32_t*)(result->data), &ceil, vec1->size); 
420099d5:	20c110        	or	a12, a1, a1
420099d8:	0023b2        	l32i	a11, a3, 0
420099db:	02a8      	l32i.n	a10, a2, 0
420099dd:	0d5665        	call8	42016f44 <simd_ceil_i32>
420099e0:	0a2d      	mov.n	a2, a10
420099e2:	000306        	j	420099f2 <vec_ceil+0x86>
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
420099e5:	720c      	movi.n	a2, 7
420099e7:	0001c6        	j	420099f2 <vec_ceil+0x86>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
420099ea:	820c      	movi.n	a2, 8
420099ec:	000086        	j	420099f2 <vec_ceil+0x86>
420099ef:	00          	.byte	00
    switch (vec1->type){
420099f0:	520c      	movi.n	a2, 5
            return VECTOR_NOT_IMPLEMENTED;
        }
        default:        
            return VECTOR_NOT_IMPLEMENTED;
    }
}
420099f2:	f01d      	retw.n

420099f4 <vec_copy>:
        default:
            return VECTOR_ERROR;
    }
}

vector_status_t vec_copy(vector_t *vec1, vector_t *result){ 
420099f4:	004136        	entry	a1, 32
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
420099f7:	22c8      	l32i.n	a12, a2, 8
420099f9:	2388      	l32i.n	a8, a3, 8
420099fb:	5a9c87        	bne	a12, a8, 42009a59 <vec_copy+0x65>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
420099fe:	1288      	l32i.n	a8, a2, 4
42009a00:	1398      	l32i.n	a9, a3, 4
42009a02:	589897        	bne	a8, a9, 42009a5e <vec_copy+0x6a>
    switch (vec1->type){
42009a05:	342826        	beqi	a8, 2, 42009a3d <vec_copy+0x49>
42009a08:	0938f6        	bgeui	a8, 3, 42009a15 <vec_copy+0x21>
42009a0b:	f88c      	beqz.n	a8, 42009a1e <vec_copy+0x2a>
42009a0d:	1d1826        	beqi	a8, 1, 42009a2e <vec_copy+0x3a>
42009a10:	320c      	movi.n	a2, 3
42009a12:	001286        	j	42009a60 <vec_copy+0x6c>
42009a15:	313826        	beqi	a8, 3, 42009a4a <vec_copy+0x56>
42009a18:	320c      	movi.n	a2, 3
42009a1a:	001086        	j	42009a60 <vec_copy+0x6c>
42009a1d:	23b200        	sext	a11, a2, 7
        case (DTYPE_INT8): {   
            return simd_copy_i8((int8_t*)(vec1->data), (int8_t*)(result->data), vec1->size);
42009a20:	22a200        	orb	b10, b2, b0
42009a23:	83a500        	moveqz	a10, a5, a0
42009a26:	0d          	.byte	0xd
42009a27:	202aa0        	or	a2, a10, a10
42009a2a:	000c86        	j	42009a60 <vec_copy+0x6c>
42009a2d:	23b200        	sext	a11, a2, 7
        }
        case (DTYPE_INT16): {  
            return simd_copy_i16((int16_t*)(vec1->data), (int16_t*)(result->data), vec1->size);
42009a30:	22a200        	orb	b10, b2, b0
42009a33:	322500        	orbc	b2, b5, b0
42009a36:	0d          	.byte	0xd
42009a37:	202aa0        	or	a2, a10, a10
42009a3a:	000886        	j	42009a60 <vec_copy+0x6c>
        }
        case (DTYPE_INT32): {   
            return simd_copy_i32((int32_t*)(vec1->data), (int32_t*)(result->data), vec1->size);
42009a3d:	03b8      	l32i.n	a11, a3, 0
42009a3f:	02a8      	l32i.n	a10, a2, 0
42009a41:	0d18e5        	call8	42016bd0 <simd_copy_i32>
42009a44:	0a2d      	mov.n	a2, a10
42009a46:	000586        	j	42009a60 <vec_copy+0x6c>
42009a49:	23b200        	sext	a11, a2, 7
        }
        case (DTYPE_FLOAT32): {
            return simd_copy_i32((int32_t*)(vec1->data), (int32_t*)(result->data), vec1->size);
42009a4c:	22a200        	orb	b10, b2, b0
42009a4f:	17e500        	ee.stf.64.xp	f14, f1, a0, a5
42009a52:	0d          	.byte	0xd
42009a53:	202aa0        	or	a2, a10, a10
42009a56:	000186        	j	42009a60 <vec_copy+0x6c>
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42009a59:	720c      	movi.n	a2, 7
42009a5b:	000046        	j	42009a60 <vec_copy+0x6c>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
42009a5e:	820c      	movi.n	a2, 8
        }
        default:
            return VECTOR_ERROR;
    }
}
42009a60:	f01d      	retw.n
	...

42009a64 <simd_abs_f32>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_abs_f32:
    entry a1, 16                                    // reserve 16 bytes for the stack frame 
42009a64:	002136        	entry	a1, 16
    movi  a6, 0x7fffffff                            // set up bitmask
42009a67:	daaf61        	l32r	a6, 42000524 <_stext+0x504> (7fffffff <_rtc_reserved_end+0x1fefffff>)
    s32i.n a6, a1, 0                                // store bitmask on stack for broadcast load
42009a6a:	0169      	s32i.n	a6, a1, 0
    extui a5, a4, 0, 2                              // extracts the lowest 2 bits of a4 into a5 (a4 % 4), for tail processing
42009a6c:	145040        	extui	a5, a4, 0, 2
    srli a4, a4, 2                                  // shift a4 right by 2 to get the number of 16-byte blocks a4 = (a4 / 4)
42009a6f:	414240        	srli	a4, a4, 2

    // Processes 16 byte chunks
    ee.vldbc.32 q0, a1                              // broadcast loads bitmask into vector register       
42009a72:	cd7714        	ee.vldbc.32	q0, a1
    loopnez a4, .Lsimd_loop                     
42009a75:	089476        	loopnez	a4, 42009a81 <simd_abs_f32+0x1d>
        ee.vld.128.ip q1, a2, 16                    // loads float data
42009a78:	838124        	ee.vld.128.ip	q1, a2, 16
        ee.andq q1, q1, q0                          // applies bitmask, zeroing sign bit
42009a7b:	cdb014        	ee.andq	q1, q1, q0
        ee.vst.128.ip q1, a3, 16                    // stores result
42009a7e:	8a8134        	ee.vst.128.ip	q1, a3, 16
    .Lsimd_loop:  

    loopnez a5, .Ltail_loop
42009a81:	0a9576        	loopnez	a5, 42009a8f <simd_abs_f32+0x2b>
        l32i.n a7, a2, 0                            // loads vector data
42009a84:	0278      	l32i.n	a7, a2, 0
        and a7, a7, a6                              // applies bitmask
42009a86:	107760        	and	a7, a7, a6
        s32i.n a7, a3, 0                            // store the result in address at a3
42009a89:	0379      	s32i.n	a7, a3, 0
        addi a2, a2, 4                              // increment pointers
42009a8b:	224b      	addi.n	a2, a2, 4
        addi a3, a3, 4
42009a8d:	334b      	addi.n	a3, a3, 4
    .Ltail_loop:

    movi.n a2, 0                                    // return VECTOR_SUCCESS
42009a8f:	020c      	movi.n	a2, 0
    retw.n
42009a91:	f01d      	retw.n
	...

42009a94 <simd_abs_i16>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_abs_i16:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42009a94:	002136        	entry	a1, 16
    extui a5, a4, 0, 3                          // a5 = a4 % 8 (remaining tail elements)
42009a97:	245040        	extui	a5, a4, 0, 3
    srli a4, a4, 3                              // a4 = a4 / 8 (number of 16-byte SIMD blocks)
42009a9a:	414340        	srli	a4, a4, 3
    movi a7, -32767                             // a7 = -32767, for replacing -32768 edge cases
42009a9d:	dbcf71        	l32r	a7, 420009dc <_stext+0x9bc> (ffff8001 <_rtc_reserved_end+0x9fef8001>)
    beqz a4, .Ltail_start                       // if no full blocks, skip SIMD loop
42009aa0:	04ac      	beqz.n	a4, 42009ac4 <simd_abs_i16+0x30>

    // SIMD loop for 16-byte blocks 
    ssai 0                                      // Clears Shift Amount Register
42009aa2:	404000        	ssai	0
    s16i a7, a1, 0                               // store -32767 to stack (for broadcast loading)
42009aa5:	005172        	s16i	a7, a1, 0
    ee.vld.128.ip   q0, a2, 16                  // load 16 bytes from [a2] into q0, post-increment a2 by 16
42009aa8:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vcmp.eq.s16   q1, q1, q1                 // fill q1 with all 0xFF (-1), used as multiplier for negation
42009aab:	8e8994        	ee.vcmp.eq.s16	q1, q1, q1
    ee.vldbc.16.ip   q2, a1, 0                  // broadcast-load -32767 from stack into all lanes of q2
42009aae:	950014        	ee.vldbc.16.ip	q2, a1, 0
    loopnez a4, .Lsimd_loop                     // repeat loop a4 times (zero-overhead loop counter)
42009ab1:	0c9476        	loopnez	a4, 42009ac1 <simd_abs_i16+0x2d>
        ee.vmax.s16.ld.incp  q0, a2, q4, q0, q2 // q4 = max(q0, -32767); replace -32768 with -32767, load next 16 bytes into q0, post-increment a2
42009ab4:	e0141d2e 	ee.vmax.s16.ld.incp	q0, a2, q4, q0, q2
        ee.vmul.s16 q3, q4, q1                  // q3 = q4 * -1; negates all q4 values
42009ab8:	9eac84        	ee.vmul.s16	q3, q4, q1
        ee.vmax.s16 q4, q4, q3                  // q4 = max(q4, q3); effectively performs abs(q4)
42009abb:	ae3c24        	ee.vmax.s16	q4, q4, q3
        ee.vst.128.ip  q4, a3, 16               // store result q4 to [a3], post-increment a3 by 16
42009abe:	aa0134        	ee.vst.128.ip	q4, a3, 16
    .Lsimd_loop:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element  
42009ac1:	f0c222        	addi	a2, a2, -16
42009ac4:	f03d      	nop.n

    .Ltail_start:    
    // Handle remaining elements that are not a multiple of 16
    loopnez a5, .Ltail_loop
42009ac6:	0f9576        	loopnez	a5, 42009ad9 <simd_abs_i16+0x45>
        l16si a8, a2, 0                          // loads and sign-extends the element into a8 
42009ac9:	009282        	l16si	a8, a2, 0
        
        max a8, a8, a7                          // sets a8 to -32767 if it is -32768
42009acc:	538870        	max	a8, a8, a7
        abs a8, a8                              // takes the abs of a8
42009acf:	608180        	abs	a8, a8
 
        s16i a8, a3, 0                          // store the saturated result in address at a4
42009ad2:	005382        	s16i	a8, a3, 0

        addi.n a2, a2, 2                        // increment pointers 
42009ad5:	222b      	addi.n	a2, a2, 2
        addi.n a3, a3, 2 
42009ad7:	332b      	addi.n	a3, a3, 2
    .Ltail_loop:  

    movi.n a2, 0                                // return exit code 0 (success)
42009ad9:	020c      	movi.n	a2, 0
    retw.n
42009adb:	f01d      	retw.n
42009add:	000000        	ill

42009ae0 <simd_add_i16>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_i16:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42009ae0:	002136        	entry	a1, 16
    extui a6, a5, 0, 3                          // extracts the lowest 3 bits of a5 into a6 (a5 % 8), for tail processing
42009ae3:	246050        	extui	a6, a5, 0, 3
    srli a5, a5, 3                              // shift a5 right by 3 to get the number of 16-byte blocks (a5 / 3)
42009ae6:	415350        	srli	a5, a5, 3
    beqz a5, .Ltail_start                       // if no full blocks (a5 == 0), skip SIMD and go to scalar tail
42009ae9:	159c      	beqz.n	a5, 42009afe <simd_add_i16+0x1e>

    // SIMD addition loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0, then increment a2 by 16
42009aeb:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42009aee:	099576        	loopnez	a5, 42009afb <simd_add_i16+0x1b>
        ee.vld.128.ip     q1, a3, 16            // loads 16 bytes from a3 into q1, increment a3 by 16
42009af1:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vadds.s16.ld.incp q0, a2, q4, q0, q1 // adds q0 and q1, stores result in q4, increments a2, updates q0
42009af4:	e0a40d2e 	ee.vadds.s16.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores 16 bytes from q4 to address at a4, increment a4 by 16
42009af8:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42009afb:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    // Handle remaining elements that were not part of a full 16-byte block
    movi a9, 32767                              // loads upper saturation limit int16_t
42009afe:	db5791        	l32r	a9, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
    movi a10, -32768                            // loads lower saturation limit int16_t
42009b01:	db57a1        	l32r	a10, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)
42009b04:	f03d      	nop.n

    // Handle remaining elements that are not a multiple of 16
    loopnez a6, .Ltail_loop
42009b06:	1c9676        	loopnez	a6, 42009b26 <simd_add_i16+0x46>
        l16si a7, a2, 0                         // loads and sign-extends the elements of the two vectors
42009b09:	009272        	l16si	a7, a2, 0
        l16si a8, a3, 0  
42009b0c:	009382        	l16si	a8, a3, 0
        
        add a7, a7, a8                          // perform signed addition
42009b0f:	778a      	add.n	a7, a7, a8

        // Saturation logic
        salt a11, a7, a10                       // sets a11 to 1 if a7 is less than lower limit
42009b11:	72b7a0        	salt	a11, a7, a10
        movnez a7, a10, a11                     // conditional move if non-zero sets a7 to lower limit if a11 is non-zero
42009b14:	937ab0        	movnez	a7, a10, a11
        salt a11, a9, a7                        // sets a11 to 1 if a7 is greater than upper limit
42009b17:	72b970        	salt	a11, a9, a7
        movnez a7, a9, a11                      // conditional move if non-zero sets a7 to upper limit if a11 is non-zero
42009b1a:	9379b0        	movnez	a7, a9, a11

        s16i a7, a4, 0                          // store the saturated result in address at a4
42009b1d:	005472        	s16i	a7, a4, 0

        addi.n a2, a2, 2                        // increment pointers
42009b20:	222b      	addi.n	a2, a2, 2
        addi.n a3, a3, 2
42009b22:	332b      	addi.n	a3, a3, 2
        addi.n a4, a4, 2 
42009b24:	442b      	addi.n	a4, a4, 2
    .Ltail_loop:  

    movi.n a2, 0                                // return exit code 0 (success)
42009b26:	020c      	movi.n	a2, 0
    retw.n
42009b28:	f01d      	retw.n
	...

42009b2c <simd_add_scalar_i16>:
    *   a4 - Pointer to the result vector (int16_t*)
    *   a5 - number of elements in the vector
    * Returns: 0 on success
*/
simd_add_scalar_i16:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42009b2c:	002136        	entry	a1, 16
    extui a6, a5, 0, 3                          // moves the last 3 bits (i.e. number of elements that are not a multiple of 16) into a6
42009b2f:	246050        	extui	a6, a5, 0, 3
    srli a5, a5, 3                              // bit shift to convert number of 16-bit elements to number of 128-bit blocks
42009b32:	415350        	srli	a5, a5, 3
    beqz a5, .Ltail_start                       // if a5 is zero, skip the SIMD addition loop
42009b35:	159c      	beqz.n	a5, 42009b4a <simd_add_scalar_i16+0x1e>

    // SIMD addition loop for 16 byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0 (128-bit vector load), increments a2
42009b37:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.16.ip     q1, a3, 0                // load the 16-bit scalar value at the address of a3 and broadcasts it into q1,
42009b3a:	858034        	ee.vldbc.16.ip	q1, a3, 0
    loopnez a5, .Lsimd_end  
42009b3d:	069576        	loopnez	a5, 42009b47 <simd_add_scalar_i16+0x1b>
        ee.vadds.s16.ld.incp q0, a2, q4, q0, q1 // adds q0 and q1, stores result in q4, increments a2, updates q0
42009b40:	e0a40d2e 	ee.vadds.s16.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores result from q4 into a4, increments a4
42009b44:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_end:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42009b47:	f0c222        	addi	a2, a2, -16

    .Ltail_start:

    // After processing all full 16-byte blocks, we handle the remaining elements
    movi a9, 32767                              // Load saturation limit for positive values
42009b4a:	db4491        	l32r	a9, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
    movi a10, -32768                            // Load saturation limit for negative values
42009b4d:	db44a1        	l32r	a10, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)

    l16si a8, a3, 0                             // Load the scalar value to be added, sign-extended to 32 bits 
42009b50:	009382        	l16si	a8, a3, 0
42009b53:	f03d      	nop.n
    loopnez a6, .Ltail_end
42009b55:	179676        	loopnez	a6, 42009b70 <simd_add_scalar_i16+0x44>
        l16si a7, a2, 0                         // Loads and sign-extends the elements of the two vectors 
42009b58:	009272        	l16si	a7, a2, 0
        addi a2, a2, 2                          // increment pointers 
42009b5b:	222b      	addi.n	a2, a2, 2
        add a7, a7, a8                          // Adds the two signed 16-bit integers 
42009b5d:	778a      	add.n	a7, a7, a8

        // Saturation logic
        salt a11, a7, a10                       // sets a11 to 1 if a7 is less than -32768
42009b5f:	72b7a0        	salt	a11, a7, a10
        movnez a7, a10, a11                     // Conditional move if non-zero sets a7 to -32768 if a11 is non-zero
42009b62:	937ab0        	movnez	a7, a10, a11
        salt a11, a9, a7                        // sets a11 to 1 if a7 is greater than 32767
42009b65:	72b970        	salt	a11, a9, a7
        movnez a7, a9, a11                      // Conditional move if non-zero sets a7 to 32767 if a11 is non-zero
42009b68:	9379b0        	movnez	a7, a9, a11

        s16i a7, a4, 0                          // store the result in the result vector 
42009b6b:	005472        	s16i	a7, a4, 0
        addi a4, a4, 2                          // increment pointers
42009b6e:	442b      	addi.n	a4, a4, 2
    .Ltail_end:  

    movi.n a2, 0                                // return VECTOR_SUCCESS
42009b70:	020c      	movi.n	a2, 0
    retw.n
42009b72:	f01d      	retw.n

42009b74 <simd_sub_i16>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_sub_i16:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42009b74:	002136        	entry	a1, 16
    extui a6, a5, 0, 3                          // extracts the lowest 3 bits of a5 into a6 (a5 % 8), for tail processing
42009b77:	246050        	extui	a6, a5, 0, 3
    srli a5, a5, 3                              // shift a5 right by 3 to get the number of 16-byte blocks (a5 / 3)
42009b7a:	415350        	srli	a5, a5, 3
    beqz a5, .Ltail_start                       // if no full blocks (a5 == 0), skip SIMD and go to scalar tail
42009b7d:	159c      	beqz.n	a5, 42009b92 <simd_sub_i16+0x1e>

    // SIMD subtraction loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16        // loads 16 bytes from a2 into q0, then increment a2 by 16
42009b7f:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a5, .Lsimd_loop             // loop until a5 == 0
42009b82:	099576        	loopnez	a5, 42009b8f <simd_sub_i16+0x1b>
        ee.vld.128.ip     q1, a3, 16    // loads 16 bytes from a3 into q1, increment a3 by 16
42009b85:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vsubs.s16.ld.incp q0, a2, q4, q0, q1 //subtracts q1 from q0, stores result in q4, increments a2, updates q0
42009b88:	e0c40d2e 	ee.vsubs.s16.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16    // stores 16 bytes from q4 to address at a4, increment a4 by 16
42009b8c:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:

    addi a2, a2, -16                    // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42009b8f:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    // Handle remaining elements that were not part of a full 16-byte block
    movi a9, 32767                      // loads upper saturation limit int16_t
42009b92:	db3291        	l32r	a9, 4200085c <_stext+0x83c> (7fff <UserFrameTotalSize+0x7eff>)
    movi a10, -32768                    // loads lower saturation limit int16_t
42009b95:	db32a1        	l32r	a10, 42000860 <_stext+0x840> (ffff8000 <_rtc_reserved_end+0x9fef8000>)
42009b98:	f03d      	nop.n

    // Handle remaining elements that are not a multiple of 16
    loopnez a6, .Ltail_loop
42009b9a:	1d9676        	loopnez	a6, 42009bbb <simd_sub_i16+0x47>
        l16si a7, a2, 0                 // loads and sign-extends the elements of the two vectors
42009b9d:	009272        	l16si	a7, a2, 0
        l16si a8, a3, 0
42009ba0:	009382        	l16si	a8, a3, 0

        sub a7, a7, a8                  // perform signed subtraction
42009ba3:	c07780        	sub	a7, a7, a8

        // Saturation logic
        salt a11, a7, a10               // sets a11 to 1 if a7 is less than lower limit
42009ba6:	72b7a0        	salt	a11, a7, a10
        movnez a7, a10, a11             // conditional move if non-zero sets a7 to lower limit if a11 is non-zero
42009ba9:	937ab0        	movnez	a7, a10, a11
        salt a11, a9, a7                // sets a11 to 1 if a7 is greater than upper limit
42009bac:	72b970        	salt	a11, a9, a7
        movnez a7, a9, a11              // conditional move if non-zero sets a7 to upper limit if a11 is non-zero
42009baf:	9379b0        	movnez	a7, a9, a11

        s16i a7, a4, 0                  // store the saturated result in address at a4
42009bb2:	005472        	s16i	a7, a4, 0

        addi.n a2, a2, 2                // increment pointers
42009bb5:	222b      	addi.n	a2, a2, 2
        addi.n a3, a3, 2
42009bb7:	332b      	addi.n	a3, a3, 2
        addi.n a4, a4, 2 
42009bb9:	442b      	addi.n	a4, a4, 2
    .Ltail_loop:  

    movi.n a2, 0                        //return exit code 0 (success)
42009bbb:	020c      	movi.n	a2, 0
    retw.n
42009bbd:	f01d      	retw.n
	...

42009bc0 <timer_ll_set_clock_source>:
{
42009bc0:	004136        	entry	a1, 32
    timg_dev_t *hw = TIMER_LL_GET_HW(group_id);
42009bc3:	52cc      	bnez.n	a2, 42009bcc <timer_ll_set_clock_source+0xc>
42009bc5:	db8681        	l32r	a8, 420009e0 <_stext+0x9c0> (6001f000 <TIMERG0>)
42009bc8:	0000c6        	j	42009bcf <timer_ll_set_clock_source+0xf>
42009bcb:	a58100        	extui	a8, a0, 17, 11
42009bce:	26d9      	s32i.n	a13, a6, 8
    switch (clk_src) {
42009bd0:	0c0944        	ee.st.qacc_l.l.128.ip	a4, 144
42009bd3:	97b9      	s32i.n	a11, a7, 36
42009bd5:	061d14        	ee.ld.qacc_h.l.128.ip	a1, 0x1d0
42009bd8:	000d      	mov.n	a0, a0
42009bda:	300000        	xor	a0, a0, a0
        hw->hw_timer[timer_num].config.tn_use_xtal = 0;
42009bdd:	33          	.byte	0x33
42009bde:	3380b0        	clamps	a8, a0, 18
42009be1:	20c0a0        	or	a12, a0, a10
42009be4:	00          	.byte	00
42009be5:	0388      	l32i.n	a8, a3, 0
42009be7:	ffad92        	movi	a9, 0xfffffdff
42009bea:	108890        	and	a8, a8, a9
42009bed:	0020c0        	memw
42009bf0:	0389      	s32i.n	a8, a3, 0
        break;
42009bf2:	000a86        	j	42009c20 <timer_ll_set_clock_source+0x60>
        hw->hw_timer[timer_num].config.tn_use_xtal = 1;
42009bf5:	b03330        	addx8	a3, a3, a3
42009bf8:	a03380        	addx4	a3, a3, a8
42009bfb:	0020c0        	memw
42009bfe:	0388      	l32i.n	a8, a3, 0
42009c00:	00a292        	movi	a9, 0x200
42009c03:	208890        	or	a8, a8, a9
42009c06:	0020c0        	memw
42009c09:	0389      	s32i.n	a8, a3, 0
        break;
42009c0b:	000446        	j	42009c20 <timer_ll_set_clock_source+0x60>
42009c0e:	75d100        	extui	a13, a0, 17, 8
        HAL_ASSERT(false && "unsupported clock source");
42009c11:	c1db      	addi.n	a12, a1, 13
42009c13:	5cdb75        	call12	420669c8 <_etext+0x4d292>
42009c16:	a1ab      	addi.n	a10, a1, 10
42009c18:	81db75        	call12	41f8b9d0 <_iram_bss_end+0x1c095d0>
42009c1b:	d93b      	addi.n	a13, a9, 3
42009c1d:	0008e0        	callx8	a8
}
42009c20:	f01d      	retw.n
	...

42009c24 <timer_ll_set_clock_prescale>:
{
42009c24:	006136        	entry	a1, 48
    HAL_ASSERT(divider >= 2 && divider <= 65536);
42009c27:	fec482        	addi	a8, a4, -2
42009c2a:	db7191        	l32r	a9, 420009f0 <_stext+0x9d0> (fffe <UserFrameTotalSize+0xfefe>)
42009c2d:	11b987        	bgeu	a9, a8, 42009c42 <timer_ll_set_clock_prescale+0x1e>
42009c30:	db71d1        	l32r	a13, 420009f4 <_stext+0x9d4> (3c024b2c <_flash_rodata_start+0x4a0c>)
42009c33:	db71c1        	l32r	a12, 420009f8 <_stext+0x9d8> (3c02766c <__func__$3>)
42009c36:	86a0b2        	movi	a11, 134
42009c39:	db6ca1        	l32r	a10, 420009ec <_stext+0x9cc> (3c024af8 <_flash_rodata_start+0x49d8>)
42009c3c:	d93381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42009c3f:	0008e0        	callx8	a8
    if (divider >= 65536) {
42009c42:	db0a81        	l32r	a8, 4200086c <_stext+0x84c> (ffff <UserFrameTotalSize+0xfeff>)
42009c45:	01b847        	bgeu	a8, a4, 42009c4a <timer_ll_set_clock_prescale+0x26>
        divider = 0;
42009c48:	040c      	movi.n	a4, 0
    HAL_FORCE_MODIFY_U32_REG_FIELD(hw->hw_timer[timer_num].config, tn_divider, divider);
42009c4a:	b09330        	addx8	a9, a3, a3
42009c4d:	a09920        	addx4	a9, a9, a2
42009c50:	0020c0        	memw
42009c53:	0988      	l32i.n	a8, a9, 0
42009c55:	0020c0        	memw
42009c58:	0189      	s32i.n	a8, a1, 0
42009c5a:	0020c0        	memw
42009c5d:	0188      	l32i.n	a8, a1, 0
42009c5f:	f44040        	extui	a4, a4, 0, 16
42009c62:	114430        	slli	a4, a4, 13
42009c65:	db65a1        	l32r	a10, 420009fc <_stext+0x9dc> (e0001fff <_rtc_reserved_end+0x7ff01fff>)
42009c68:	1088a0        	and	a8, a8, a10
42009c6b:	208840        	or	a8, a8, a4
42009c6e:	0020c0        	memw
42009c71:	0189      	s32i.n	a8, a1, 0
42009c73:	0020c0        	memw
42009c76:	0188      	l32i.n	a8, a1, 0
42009c78:	0020c0        	memw
42009c7b:	0989      	s32i.n	a8, a9, 0
    hw->hw_timer[timer_num].config.tn_divcnt_rst = 1;
42009c7d:	b03330        	addx8	a3, a3, a3
42009c80:	092d      	mov.n	a2, a9
42009c82:	0020c0        	memw
42009c85:	0988      	l32i.n	a8, a9, 0
42009c87:	db4491        	l32r	a9, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
42009c8a:	208890        	or	a8, a8, a9
42009c8d:	0020c0        	memw
42009c90:	0289      	s32i.n	a8, a2, 0
}
42009c92:	f01d      	retw.n

42009c94 <gptimer_acquire_group_handle>:

// gptimer driver platform, it's always a singleton
static gptimer_platform_t s_platform;

gptimer_group_t *gptimer_acquire_group_handle(int group_id)
{
42009c94:	004136        	entry	a1, 32
42009c97:	027d      	mov.n	a7, a2
    bool new_group = false;
    gptimer_group_t *group = NULL;

    // prevent install timer group concurrently
    _lock_acquire(&s_platform.mutex);
42009c99:	db5961        	l32r	a6, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009c9c:	06ad      	mov.n	a10, a6
42009c9e:	dab981        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
42009ca1:	0008e0        	callx8	a8
    if (!s_platform.groups[group_id]) {
42009ca4:	a06260        	addx4	a6, a2, a6
42009ca7:	1628      	l32i.n	a2, a6, 4
42009ca9:	72ec      	bnez.n	a2, 42009cd4 <gptimer_acquire_group_handle+0x40>
        group = heap_caps_calloc(1, sizeof(gptimer_group_t), GPTIMER_MEM_ALLOC_CAPS);
42009cab:	da03c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
42009cae:	4b1c      	movi.n	a11, 20
42009cb0:	1a0c      	movi.n	a10, 1
42009cb2:	db5681        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
42009cb5:	0008e0        	callx8	a8
42009cb8:	0a2d      	mov.n	a2, a10
        if (group) {
42009cba:	7aac      	beqz.n	a10, 42009ce5 <gptimer_acquire_group_handle+0x51>
            new_group = true;
            s_platform.groups[group_id] = group;
42009cbc:	db5181        	l32r	a8, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009cbf:	a08780        	addx4	a8, a7, a8
42009cc2:	18a9      	s32i.n	a10, a8, 4
            // initialize timer group members
            group->group_id = group_id;
42009cc4:	0a79      	s32i.n	a7, a10, 0
            group->spinlock = (portMUX_TYPE)portMUX_INITIALIZER_UNLOCKED;
42009cc6:	d9f881        	l32r	a8, 420004a8 <_stext+0x488> (b33fffff <_rtc_reserved_end+0x532fffff>)
42009cc9:	1a89      	s32i.n	a8, a10, 4
42009ccb:	080c      	movi.n	a8, 0
42009ccd:	2a89      	s32i.n	a8, a10, 8
            new_group = true;
42009ccf:	160c      	movi.n	a6, 1
42009cd1:	000046        	j	42009cd6 <gptimer_acquire_group_handle+0x42>
42009cd4:	060c      	movi.n	a6, 0
    } else {
        group = s_platform.groups[group_id];
    }
    if (group) {
        // someone acquired the group handle means we have a new object that refer to this group
        s_platform.group_ref_counts[group_id]++;
42009cd6:	db4a81        	l32r	a8, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009cd9:	a08780        	addx4	a8, a7, a8
42009cdc:	3898      	l32i.n	a9, a8, 12
42009cde:	991b      	addi.n	a9, a9, 1
42009ce0:	3899      	s32i.n	a9, a8, 12
42009ce2:	000046        	j	42009ce7 <gptimer_acquire_group_handle+0x53>
    bool new_group = false;
42009ce5:	060c      	movi.n	a6, 0
    }
    _lock_release(&s_platform.mutex);
42009ce7:	db46a1        	l32r	a10, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009cea:	daa781        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
42009ced:	0008e0        	callx8	a8

    if (new_group) {
42009cf0:	0a5656        	bnez	a6, 42009d99 <gptimer_acquire_group_handle+0x105>
42009cf3:	003046        	j	42009db8 <gptimer_acquire_group_handle+0x124>
42009cf6:	560000        	ee.ldf.64.xp	f0, f5, a0, a0
    if (group_id == 0) {
42009cf9:	810487        	bnone	a4, a8, 42009c7e <timer_ll_set_clock_prescale+0x5a>
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
42009cfc:	c0d956        	bnez	a9, 4200990d <vec_abs+0x15>
42009cff:	20          	.byte	0x20
42009d00:	00          	.byte	00
42009d01:	6898      	l32i.n	a9, a8, 24
42009d03:	daa6a1        	l32r	a10, 4200079c <_stext+0x77c> (2000 <UserFrameTotalSize+0x1f00>)
42009d06:	2099a0        	or	a9, a9, a10
42009d09:	0020c0        	memw
42009d0c:	6899      	s32i.n	a9, a8, 24
        SYSTEM.perip_rst_en0.timergroup_rst = 1;
42009d0e:	0020c0        	memw
42009d11:	8898      	l32i.n	a9, a8, 32
42009d13:	2099a0        	or	a9, a9, a10
42009d16:	0020c0        	memw
42009d19:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup_rst = 0;
42009d1b:	0020c0        	memw
42009d1e:	8898      	l32i.n	a9, a8, 32
42009d20:	db39a1        	l32r	a10, 42000a04 <_stext+0x9e4> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
42009d23:	1099a0        	and	a9, a9, a10
42009d26:	0020c0        	memw
42009d29:	8899      	s32i.n	a9, a8, 32
        TIMERG0.wdtconfig0.wdt_flashboot_mod_en = 0;
42009d2b:	db2d91        	l32r	a9, 420009e0 <_stext+0x9c0> (6001f000 <TIMERG0>)
42009d2e:	0020c0        	memw
42009d31:	122982        	l32i	a8, a9, 72
42009d34:	d94ca1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42009d37:	1088a0        	and	a8, a8, a10
42009d3a:	0020c0        	memw
42009d3d:	126982        	s32i	a8, a9, 72
42009d40:	001146        	j	42009d89 <gptimer_acquire_group_handle+0xf5>
42009d43:	448100        	extui	a8, a0, 1, 5
        SYSTEM.perip_clk_en0.timergroup1_clk_en = enable;
42009d46:	c0d9      	s32i.n	a13, a0, 48
42009d48:	20          	.byte	0x20
42009d49:	00          	.byte	00
42009d4a:	6898      	l32i.n	a9, a8, 24
42009d4c:	d943a1        	l32r	a10, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
42009d4f:	2099a0        	or	a9, a9, a10
42009d52:	0020c0        	memw
42009d55:	6899      	s32i.n	a9, a8, 24
        SYSTEM.perip_rst_en0.timergroup1_rst = 1;
42009d57:	0020c0        	memw
42009d5a:	8898      	l32i.n	a9, a8, 32
42009d5c:	2099a0        	or	a9, a9, a10
42009d5f:	0020c0        	memw
42009d62:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup1_rst = 0;
42009d64:	0020c0        	memw
42009d67:	8898      	l32i.n	a9, a8, 32
42009d69:	d93ca1        	l32r	a10, 4200025c <_stext+0x23c> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42009d6c:	1099a0        	and	a9, a9, a10
42009d6f:	0020c0        	memw
42009d72:	8899      	s32i.n	a9, a8, 32
        TIMERG1.wdtconfig0.wdt_flashboot_mod_en = 0;
42009d74:	d93b91        	l32r	a9, 42000260 <_stext+0x240> (60020000 <TIMERG1>)
42009d77:	0020c0        	memw
42009d7a:	122982        	l32i	a8, a9, 72
42009d7d:	d939a1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42009d80:	1088a0        	and	a8, a8, a10
42009d83:	0020c0        	memw
42009d86:	126982        	s32i	a8, a9, 72
        // !!! HARDWARE SHARED RESOURCE !!!
        // the gptimer and watchdog reside in the same the timer group
        // we need to increase/decrease the reference count before enable/disable/reset the peripheral
        PERIPH_RCC_ACQUIRE_ATOMIC(timer_group_periph_signals.groups[group_id].module, ref_count) {
42009d89:	05ad      	mov.n	a10, a5
42009d8b:	d93a81        	l32r	a8, 42000274 <_stext+0x254> (40378200 <periph_rcc_acquire_exit>)
42009d8e:	0008e0        	callx8	a8
42009d91:	660b      	addi.n	a6, a6, -1
42009d93:	746060        	extui	a6, a6, 0, 8
42009d96:	000046        	j	42009d9b <gptimer_acquire_group_handle+0x107>
42009d99:	160c      	movi.n	a6, 1
42009d9b:	969c      	beqz.n	a6, 42009db8 <gptimer_acquire_group_handle+0x124>
42009d9d:	908770        	addx2	a8, a7, a7
42009da0:	db1a91        	l32r	a9, 42000a08 <_stext+0x9e8> (3c027e5c <timer_group_periph_signals>)
42009da3:	a08890        	addx4	a8, a8, a9
42009da6:	0858      	l32i.n	a5, a8, 0
42009da8:	05ad      	mov.n	a10, a5
42009daa:	d93381        	l32r	a8, 42000278 <_stext+0x258> (403781f0 <periph_rcc_acquire_enter>)
42009dad:	0008e0        	callx8	a8
42009db0:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
42009db2:	f42a16        	beqz	a10, 42009cf8 <gptimer_acquire_group_handle+0x64>
42009db5:	fff406        	j	42009d89 <gptimer_acquire_group_handle+0xf5>
        }
        ESP_LOGD(TAG, "new group (%d) @%p", group_id, group);
    }

    return group;
}
42009db8:	f01d      	retw.n
	...

42009dbc <gptimer_release_group_handle>:

void gptimer_release_group_handle(gptimer_group_t *group)
{
42009dbc:	004136        	entry	a1, 32
    int group_id = group->group_id;
42009dbf:	0268      	l32i.n	a6, a2, 0
    bool do_deinitialize = false;

    _lock_acquire(&s_platform.mutex);
42009dc1:	db0f71        	l32r	a7, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009dc4:	07ad      	mov.n	a10, a7
42009dc6:	da6f81        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
42009dc9:	0008e0        	callx8	a8
    s_platform.group_ref_counts[group_id]--;
42009dcc:	a07670        	addx4	a7, a6, a7
42009dcf:	3788      	l32i.n	a8, a7, 12
42009dd1:	880b      	addi.n	a8, a8, -1
42009dd3:	3789      	s32i.n	a8, a7, 12
    if (s_platform.group_ref_counts[group_id] == 0) {
42009dd5:	c8ec      	bnez.n	a8, 42009e05 <gptimer_release_group_handle+0x49>
        assert(s_platform.groups[group_id]);
42009dd7:	db0a81        	l32r	a8, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009dda:	a08680        	addx4	a8, a6, a8
42009ddd:	1888      	l32i.n	a8, a8, 4
42009ddf:	011856        	bnez	a8, 42009df4 <gptimer_release_group_handle+0x38>
42009de2:	db0bd1        	l32r	a13, 42000a10 <_stext+0x9f0> (3c024b50 <_flash_rodata_start+0x4a30>)
42009de5:	db0bc1        	l32r	a12, 42000a14 <_stext+0x9f4> (3c0276c0 <__func__$6>)
42009de8:	47a0b2        	movi	a11, 71
42009deb:	db0ba1        	l32r	a10, 42000a18 <_stext+0x9f8> (3c024b94 <_flash_rodata_start+0x4a74>)
42009dee:	d8c681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42009df1:	0008e0        	callx8	a8
        do_deinitialize = true;
        s_platform.groups[group_id] = NULL;
42009df4:	db0381        	l32r	a8, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009df7:	a08680        	addx4	a8, a6, a8
42009dfa:	090c      	movi.n	a9, 0
42009dfc:	1899      	s32i.n	a9, a8, 4
        do_deinitialize = true;
42009dfe:	170c      	movi.n	a7, 1
42009e00:	0000c6        	j	42009e07 <gptimer_release_group_handle+0x4b>
42009e03:	00          	.byte	00
42009e04:	070c00        	ee.stf.64.xp	f0, f0, a0, a12
    }
    _lock_release(&s_platform.mutex);
42009e07:	dafea1        	l32r	a10, 42000a00 <_stext+0x9e0> (3fc9536c <s_platform>)
42009e0a:	da5f81        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
42009e0d:	0008e0        	callx8	a8

    if (do_deinitialize) {
42009e10:	d7fc      	bnez.n	a7, 42009e51 <gptimer_release_group_handle+0x95>
42009e12:	001886        	j	42009e78 <gptimer_release_group_handle+0xbc>
    if (group_id == 0) {
42009e15:	46dc      	bnez.n	a6, 42009e2d <gptimer_release_group_handle+0x71>
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
42009e17:	d90f91        	l32r	a9, 42000254 <_stext+0x234> (600c0000 <SYSTEM>)
42009e1a:	0020c0        	memw
42009e1d:	6988      	l32i.n	a8, a9, 24
42009e1f:	daf9a1        	l32r	a10, 42000a04 <_stext+0x9e4> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
42009e22:	1088a0        	and	a8, a8, a10
42009e25:	0020c0        	memw
42009e28:	6989      	s32i.n	a8, a9, 24
42009e2a:	000486        	j	42009e40 <gptimer_release_group_handle+0x84>
        SYSTEM.perip_clk_en0.timergroup1_clk_en = enable;
42009e2d:	d90991        	l32r	a9, 42000254 <_stext+0x234> (600c0000 <SYSTEM>)
42009e30:	0020c0        	memw
42009e33:	6988      	l32i.n	a8, a9, 24
42009e35:	d909a1        	l32r	a10, 4200025c <_stext+0x23c> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
42009e38:	1088a0        	and	a8, a8, a10
42009e3b:	0020c0        	memw
42009e3e:	6989      	s32i.n	a8, a9, 24
        // disable bus clock for the timer group
        PERIPH_RCC_RELEASE_ATOMIC(timer_group_periph_signals.groups[group_id].module, ref_count) {
42009e40:	05ad      	mov.n	a10, a5
42009e42:	daf681        	l32r	a8, 42000a1c <_stext+0x9fc> (4037826c <periph_rcc_release_exit>)
42009e45:	0008e0        	callx8	a8
42009e48:	770b      	addi.n	a7, a7, -1
42009e4a:	747070        	extui	a7, a7, 0, 8
42009e4d:	000086        	j	42009e53 <gptimer_release_group_handle+0x97>
42009e50:	170c00        	ee.stf.64.xp	f0, f1, a0, a12
42009e53:	979c      	beqz.n	a7, 42009e70 <gptimer_release_group_handle+0xb4>
42009e55:	908660        	addx2	a8, a6, a6
42009e58:	daec91        	l32r	a9, 42000a08 <_stext+0x9e8> (3c027e5c <timer_group_periph_signals>)
42009e5b:	a08890        	addx4	a8, a8, a9
42009e5e:	0858      	l32i.n	a5, a8, 0
42009e60:	05ad      	mov.n	a10, a5
42009e62:	daef81        	l32r	a8, 42000a20 <_stext+0xa00> (40378254 <periph_rcc_release_enter>)
42009e65:	0008e0        	callx8	a8
42009e68:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
42009e6a:	fa7a16        	beqz	a10, 42009e15 <gptimer_release_group_handle+0x59>
42009e6d:	fff3c6        	j	42009e40 <gptimer_release_group_handle+0x84>
                timer_ll_enable_bus_clock(group_id, false);
            }
        }
        free(group);
42009e70:	02ad      	mov.n	a10, a2
42009e72:	d9be81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
42009e75:	0008e0        	callx8	a8
        ESP_LOGD(TAG, "del group (%d)", group_id);
    }
}
42009e78:	f01d      	retw.n
	...

42009e7c <gptimer_select_periph_clock>:

esp_err_t gptimer_select_periph_clock(gptimer_t *timer, gptimer_clock_source_t src_clk, uint32_t resolution_hz)
{
42009e7c:	008136        	entry	a1, 64
42009e7f:	027d      	mov.n	a7, a2
    uint32_t counter_src_hz = 0;
42009e81:	0b0c      	movi.n	a11, 0
42009e83:	41b9      	s32i.n	a11, a1, 16
    int timer_id = timer->timer_id;
42009e85:	1268      	l32i.n	a6, a2, 4
    int group_id = timer->group->group_id;
42009e87:	0288      	l32i.n	a8, a2, 0
42009e89:	0858      	l32i.n	a5, a8, 0
        periph_rtc_dig_clk8m_enable();
    }
#endif // SOC_TIMER_GROUP_SUPPORT_RC_FAST

    // get clock source frequency
    ESP_RETURN_ON_ERROR(esp_clk_tree_src_get_freq_hz((soc_module_clk_t)src_clk, ESP_CLK_TREE_SRC_FREQ_PRECISION_CACHED, &counter_src_hz),
42009e8b:	10c1c2        	addi	a12, a1, 16
42009e8e:	03ad      	mov.n	a10, a3
42009e90:	0258e5        	call8	4200c420 <esp_clk_tree_src_get_freq_hz>
42009e93:	0a2d      	mov.n	a2, a10
42009e95:	3aac      	beqz.n	a10, 42009ebc <gptimer_select_periph_clock+0x40>
42009e97:	d87281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42009e9a:	0008e0        	callx8	a8
42009e9d:	dae2b1        	l32r	a11, 42000a28 <_stext+0xa08> (3c024774 <_flash_rodata_start+0x4654>)
42009ea0:	68a082        	movi	a8, 104
42009ea3:	0189      	s32i.n	a8, a1, 0
42009ea5:	dadff1        	l32r	a15, 42000a24 <_stext+0xa04> (3c0276a4 <__FUNCTION__$5>)
42009ea8:	0bed      	mov.n	a14, a11
42009eaa:	0add      	mov.n	a13, a10
42009eac:	dae0c1        	l32r	a12, 42000a2c <_stext+0xa0c> (3c024ba8 <_flash_rodata_start+0x4a88>)
42009eaf:	01a0a2        	movi	a10, 1
42009eb2:	d87881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42009eb5:	0008e0        	callx8	a8
42009eb8:	001306        	j	42009f08 <gptimer_select_periph_clock+0x8c>
42009ebb:	a0b200        	addx4	a11, a2, a0
        ESP_RETURN_ON_ERROR(esp_pm_lock_create(pm_lock_type, 0, timer->pm_lock_name, &timer->pm_lock),
                            TAG, "create pm lock failed");
    }
#endif // CONFIG_PM_ENABLE

    esp_clk_tree_enable_src((soc_module_clk_t)src_clk, true);
42009ebe:	03ad01        	l32r	a0, 41fcad74 <_iram_bss_end+0x1c48974>
42009ec1:	0d5be5        	call8	42017480 <esp_clk_tree_enable_src>
    // !!! HARDWARE SHARED RESOURCE !!!
    // on some ESP chip, different peripheral's clock source setting are mixed in the same register
    // so we need to make this done in an atomic way
    GPTIMER_CLOCK_SRC_ATOMIC() {
        timer_ll_set_clock_source(group_id, timer_id, src_clk);
42009ec4:	03cd      	mov.n	a12, a3
42009ec6:	20b660        	or	a11, a6, a6
42009ec9:	20a550        	or	a10, a5, a5
42009ecc:	ffcf25        	call8	42009bc0 <timer_ll_set_clock_source>
        timer_ll_enable_clock(group_id, timer_id, true);
    }
    timer->clk_src = src_clk;
42009ecf:	126732        	s32i	a3, a7, 72
    uint32_t prescale = counter_src_hz / resolution_hz; // potential resolution loss here
42009ed2:	4138      	l32i.n	a3, a1, 16
42009ed4:	c23340        	quou	a3, a3, a4
    timer_ll_set_clock_prescale(timer->hal.dev, timer_id, prescale);
42009ed7:	03cd      	mov.n	a12, a3
42009ed9:	06bd      	mov.n	a11, a6
42009edb:	97a8      	l32i.n	a10, a7, 36
42009edd:	ffd465        	call8	42009c24 <timer_ll_set_clock_prescale>
    timer->resolution_hz = counter_src_hz / prescale; // this is the real resolution
42009ee0:	41c8      	l32i.n	a12, a1, 16
42009ee2:	c2cc30        	quou	a12, a12, a3
42009ee5:	27c9      	s32i.n	a12, a7, 8
    if (timer->resolution_hz != resolution_hz) {
42009ee7:	1d1c47        	beq	a12, a4, 42009f08 <gptimer_select_periph_clock+0x8c>
        ESP_LOGW(TAG, "resolution lost, expect %"PRIu32", real %"PRIu32, resolution_hz, timer->resolution_hz);
42009eea:	d85d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42009eed:	0008e0        	callx8	a8
42009ef0:	daceb1        	l32r	a11, 42000a28 <_stext+0xa08> (3c024774 <_flash_rodata_start+0x4654>)
42009ef3:	2788      	l32i.n	a8, a7, 8
42009ef5:	0189      	s32i.n	a8, a1, 0
42009ef7:	04fd      	mov.n	a15, a4
42009ef9:	0bed      	mov.n	a14, a11
42009efb:	0add      	mov.n	a13, a10
42009efd:	daccc1        	l32r	a12, 42000a30 <_stext+0xa10> (3c024be0 <_flash_rodata_start+0x4ac0>)
42009f00:	2a0c      	movi.n	a10, 2
42009f02:	d86481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42009f05:	0008e0        	callx8	a8
    }
    return ESP_OK;
}
42009f08:	f01d      	retw.n
	...

42009f0c <bootloader_init_mem>:
#include "esp_cpu.h"

#include "hal/apm_hal.h"

void bootloader_init_mem(void)
{
42009f0c:	004136        	entry	a1, 32
#endif // SOC_APM_CTRL_FILTER_SUPPORTED
#endif

#ifdef CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE
    // protect memory region
    esp_cpu_configure_region_protection();
42009f0f:	024ca5        	call8	4200c3d8 <esp_cpu_configure_region_protection>
#endif
}
42009f12:	f01d      	retw.n

42009f14 <bootloader_flash_update_id>:
#define FLASH_CS_SETUP_TIME 3
#define FLASH_CS_HOLD_TIME  3
#define FLASH_CS_HOLD_DELAY 2

void bootloader_flash_update_id()
{
42009f14:	004136        	entry	a1, 32
    esp_rom_spiflash_chip_t *chip = &rom_spiflash_legacy_data->chip;
42009f17:	dac781        	l32r	a8, 42000a34 <_stext+0xa14> (3fceffe4 <rom_spiflash_legacy_data>)
42009f1a:	0878      	l32i.n	a7, a8, 0
    chip->device_id = bootloader_read_flash_id();
42009f1c:	dac781        	l32r	a8, 42000a38 <_stext+0xa18> (403774fc <bootloader_read_flash_id>)
42009f1f:	0008e0        	callx8	a8
42009f22:	07a9      	s32i.n	a10, a7, 0
}
42009f24:	f01d      	retw.n
	...

42009f28 <s_get_bus_mask>:
{
42009f28:	004136        	entry	a1, 32
    uint32_t vaddr_end = vaddr_start + len - 1;
42009f2b:	323a      	add.n	a3, a2, a3
42009f2d:	330b      	addi.n	a3, a3, -1
    if (vaddr_start >= SOC_IRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_IRAM0_CACHE_ADDRESS_HIGH) {
42009f2f:	dac391        	l32r	a9, 42000a3c <_stext+0xa1c> (41ffffff <_iram_bss_end+0x1c7dbff>)
42009f32:	629920        	saltu	a9, a9, a2
42009f35:	dac281        	l32r	a8, 42000a40 <_stext+0xa20> (43ffffff <_etext+0x1fe68c9>)
42009f38:	628830        	saltu	a8, a8, a3
42009f3b:	880b      	addi.n	a8, a8, -1
42009f3d:	608080        	neg	a8, a8
42009f40:	258897        	bany	a8, a9, 42009f69 <s_get_bus_mask+0x41>
    } else if (vaddr_start >= SOC_DRAM0_CACHE_ADDRESS_LOW && vaddr_end < SOC_DRAM0_CACHE_ADDRESS_HIGH) {
42009f43:	dac091        	l32r	a9, 42000a44 <_stext+0xa24> (3bffffff <UserFrameTotalSize+0x3bfffeff>)
42009f46:	629920        	saltu	a9, a9, a2
42009f49:	dabf81        	l32r	a8, 42000a48 <_stext+0xa28> (3dffffff <_esp_system_init_fn_array_end+0x1fd6d5b>)
42009f4c:	628830        	saltu	a8, a8, a3
42009f4f:	880b      	addi.n	a8, a8, -1
42009f51:	608080        	neg	a8, a8
42009f54:	168897        	bany	a8, a9, 42009f6e <s_get_bus_mask+0x46>
        HAL_ASSERT(0);      //Out of region
42009f57:	dabdd1        	l32r	a13, 42000a4c <_stext+0xa2c> (3c0233b0 <_flash_rodata_start+0x3290>)
42009f5a:	dabdc1        	l32r	a12, 42000a50 <_stext+0xa30> (3c027790 <__func__$9>)
42009f5d:	3aa2b2        	movi	a11, 0x23a
42009f60:	dabda1        	l32r	a10, 42000a54 <_stext+0xa34> (3c020504 <_flash_rodata_start+0x3e4>)
42009f63:	d86981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42009f66:	0008e0        	callx8	a8
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_IBUS0);    //Both cores have their own IBUS0
42009f69:	120c      	movi.n	a2, 1
42009f6b:	000046        	j	42009f70 <s_get_bus_mask+0x48>
        mask = (cache_bus_mask_t)(mask | CACHE_BUS_DBUS0);    //Both cores have their own DBUS0
42009f6e:	820c      	movi.n	a2, 8
}
42009f70:	f01d      	retw.n
	...

42009f74 <s_reserve_irom_region>:
{
42009f74:	004136        	entry	a1, 32
    size_t irom_len_to_reserve = (uint32_t)&_instruction_reserved_end - (uint32_t)&_instruction_reserved_start;
42009f77:	dab881        	l32r	a8, 42000a58 <_stext+0xa38> (42019736 <_etext>)
42009f7a:	dab8a1        	l32r	a10, 42000a5c <_stext+0xa3c> (42000020 <_stext>)
42009f7d:	c0b8a0        	sub	a11, a8, a10
    return vaddr & SOC_MMU_LINEAR_ADDR_MASK;
42009f80:	dab891        	l32r	a9, 42000a60 <_stext+0xa40> (1ffffff <UserFrameTotalSize+0x1fffeff>)
42009f83:	108890        	and	a8, a8, a9
42009f86:	109a90        	and	a9, a10, a9
    assert((mmu_ll_vaddr_to_laddr((uint32_t)&_instruction_reserved_end) - mmu_ll_vaddr_to_laddr((uint32_t)&_instruction_reserved_start)) == irom_len_to_reserve);
42009f89:	c08890        	sub	a8, a8, a9
42009f8c:	1118b7        	beq	a8, a11, 42009fa1 <s_reserve_irom_region+0x2d>
42009f8f:	dab5d1        	l32r	a13, 42000a64 <_stext+0xa44> (3c024cb8 <_flash_rodata_start+0x4b98>)
42009f92:	dab5c1        	l32r	a12, 42000a68 <_stext+0xa48> (3c0277a4 <__func__$10>)
42009f95:	92a0b2        	movi	a11, 146
42009f98:	dab5a1        	l32r	a10, 42000a6c <_stext+0xa4c> (3c024d68 <_flash_rodata_start+0x4c48>)
42009f9b:	d85b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42009f9e:	0008e0        	callx8	a8
    irom_len_to_reserve += (uint32_t)&_instruction_reserved_start - ALIGN_DOWN_BY((uint32_t)&_instruction_reserved_start, CONFIG_MMU_PAGE_SIZE);
42009fa1:	f470a0        	extui	a7, a10, 0, 16
42009fa4:	8077b0        	add	a7, a7, a11
    irom_len_to_reserve = ALIGN_UP_BY(irom_len_to_reserve, CONFIG_MMU_PAGE_SIZE);
42009fa7:	da3181        	l32r	a8, 4200086c <_stext+0x84c> (ffff <UserFrameTotalSize+0xfeff>)
42009faa:	807780        	add	a7, a7, a8
42009fad:	f57070        	extui	a7, a7, 16, 16
42009fb0:	117700        	slli	a7, a7, 16
    cache_bus_mask_t bus_mask = s_get_bus_mask((uint32_t)&_instruction_reserved_start, irom_len_to_reserve);
42009fb3:	20b770        	or	a11, a7, a7
42009fb6:	fff725        	call8	42009f28 <s_get_bus_mask>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009fb9:	080c      	movi.n	a8, 0
42009fbb:	000bc6        	j	42009fee <s_reserve_irom_region+0x7a>
42009fbe:	800000        	add	a0, a0, a0
        if (bus_mask & hw_mem_regions[i].bus_id) {
42009fc1:	a098      	l32i.n	a9, a0, 40
42009fc3:	b09920        	addx8	a9, a9, a2
42009fc6:	09b8      	l32i.n	a11, a9, 0
42009fc8:	200ba7        	bnone	a11, a10, 42009fec <s_reserve_irom_region+0x78>
            if (hw_mem_regions[i].region_size <= irom_len_to_reserve) {
42009fcb:	39b8      	l32i.n	a11, a9, 12
42009fcd:	0d37b7        	bltu	a7, a11, 42009fde <s_reserve_irom_region+0x6a>
                hw_mem_regions[i].free_head = hw_mem_regions[i].end;
42009fd0:	29c8      	l32i.n	a12, a9, 8
42009fd2:	49c9      	s32i.n	a12, a9, 16
                hw_mem_regions[i].max_slot_size = 0;
42009fd4:	0c0c      	movi.n	a12, 0
42009fd6:	59c9      	s32i.n	a12, a9, 20
                irom_len_to_reserve -= hw_mem_regions[i].region_size;
42009fd8:	c077b0        	sub	a7, a7, a11
42009fdb:	000346        	j	42009fec <s_reserve_irom_region+0x78>
                hw_mem_regions[i].free_head = hw_mem_regions[i].free_head + irom_len_to_reserve;
42009fde:	49b8      	l32i.n	a11, a9, 16
42009fe0:	bb7a      	add.n	a11, a11, a7
42009fe2:	49b9      	s32i.n	a11, a9, 16
                hw_mem_regions[i].max_slot_size -= irom_len_to_reserve;
42009fe4:	59b8      	l32i.n	a11, a9, 20
42009fe6:	c0bb70        	sub	a11, a11, a7
42009fe9:	0569b2        	s32i	a11, a9, 20
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
42009fec:	881b      	addi.n	a8, a8, 1
42009fee:	fce816        	beqz	a8, 42009fc0 <s_reserve_irom_region+0x4c>
}
42009ff1:	f01d      	retw.n
	...

42009ff4 <s_reserve_drom_region>:
{
42009ff4:	004136        	entry	a1, 32
    size_t drom_len_to_reserve = (uint32_t)&_rodata_reserved_end - (uint32_t)&_rodata_reserved_start;
42009ff7:	da9e81        	l32r	a8, 42000a70 <_stext+0xa50> (3c0292a4 <_esp_system_init_fn_array_end>)
42009ffa:	da9ea1        	l32r	a10, 42000a74 <_stext+0xa54> (3c020020 <esp_app_desc>)
42009ffd:	c0b8a0        	sub	a11, a8, a10
4200a000:	da9891        	l32r	a9, 42000a60 <_stext+0xa40> (1ffffff <UserFrameTotalSize+0x1fffeff>)
4200a003:	108890        	and	a8, a8, a9
4200a006:	109a90        	and	a9, a10, a9
    assert((mmu_ll_vaddr_to_laddr((uint32_t)&_rodata_reserved_end) - mmu_ll_vaddr_to_laddr((uint32_t)&_rodata_reserved_start)) == drom_len_to_reserve);
4200a009:	c08890        	sub	a8, a8, a9
4200a00c:	1118b7        	beq	a8, a11, 4200a021 <s_reserve_drom_region+0x2d>
4200a00f:	da9ad1        	l32r	a13, 42000a78 <_stext+0xa58> (3c024d78 <_flash_rodata_start+0x4c58>)
4200a012:	da9ac1        	l32r	a12, 42000a7c <_stext+0xa5c> (3c027778 <__func__$8>)
4200a015:	aea0b2        	movi	a11, 174
4200a018:	da95a1        	l32r	a10, 42000a6c <_stext+0xa4c> (3c024d68 <_flash_rodata_start+0x4c48>)
4200a01b:	d83b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200a01e:	0008e0        	callx8	a8
    drom_len_to_reserve += (uint32_t)&_rodata_reserved_start - ALIGN_DOWN_BY((uint32_t)&_rodata_reserved_start, CONFIG_MMU_PAGE_SIZE);
4200a021:	f470a0        	extui	a7, a10, 0, 16
4200a024:	8077b0        	add	a7, a7, a11
    drom_len_to_reserve = ALIGN_UP_BY(drom_len_to_reserve, CONFIG_MMU_PAGE_SIZE);
4200a027:	da1181        	l32r	a8, 4200086c <_stext+0x84c> (ffff <UserFrameTotalSize+0xfeff>)
4200a02a:	807780        	add	a7, a7, a8
4200a02d:	f57070        	extui	a7, a7, 16, 16
4200a030:	117700        	slli	a7, a7, 16
    cache_bus_mask_t bus_mask = s_get_bus_mask((uint32_t)&_rodata_reserved_start, drom_len_to_reserve);
4200a033:	20b770        	or	a11, a7, a7
4200a036:	ffef25        	call8	42009f28 <s_get_bus_mask>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a039:	080c      	movi.n	a8, 0
4200a03b:	000bc6        	j	4200a06e <s_reserve_drom_region+0x7a>
4200a03e:	800000        	add	a0, a0, a0
        if (bus_mask & hw_mem_regions[i].bus_id) {
4200a041:	a098      	l32i.n	a9, a0, 40
4200a043:	b09920        	addx8	a9, a9, a2
4200a046:	09b8      	l32i.n	a11, a9, 0
4200a048:	200ba7        	bnone	a11, a10, 4200a06c <s_reserve_drom_region+0x78>
            if (hw_mem_regions[i].region_size <= drom_len_to_reserve) {
4200a04b:	39b8      	l32i.n	a11, a9, 12
4200a04d:	0d37b7        	bltu	a7, a11, 4200a05e <s_reserve_drom_region+0x6a>
                hw_mem_regions[i].free_head = hw_mem_regions[i].end;
4200a050:	29c8      	l32i.n	a12, a9, 8
4200a052:	49c9      	s32i.n	a12, a9, 16
                hw_mem_regions[i].max_slot_size = 0;
4200a054:	0c0c      	movi.n	a12, 0
4200a056:	59c9      	s32i.n	a12, a9, 20
                drom_len_to_reserve -= hw_mem_regions[i].region_size;
4200a058:	c077b0        	sub	a7, a7, a11
4200a05b:	000346        	j	4200a06c <s_reserve_drom_region+0x78>
                hw_mem_regions[i].free_head = hw_mem_regions[i].free_head + drom_len_to_reserve;
4200a05e:	49b8      	l32i.n	a11, a9, 16
4200a060:	bb7a      	add.n	a11, a11, a7
4200a062:	49b9      	s32i.n	a11, a9, 16
                hw_mem_regions[i].max_slot_size -= drom_len_to_reserve;
4200a064:	59b8      	l32i.n	a11, a9, 20
4200a066:	c0bb70        	sub	a11, a11, a7
4200a069:	0569b2        	s32i	a11, a9, 20
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a06c:	881b      	addi.n	a8, a8, 1
4200a06e:	fce816        	beqz	a8, 4200a040 <s_reserve_drom_region+0x4c>
}
4200a071:	f01d      	retw.n
	...

4200a074 <esp_mmu_map_init>:
{
4200a074:	00a136        	entry	a1, 80
    mem_region_t hw_mem_regions[SOC_MMU_LINEAR_ADDRESS_REGION_NUM] = {};
4200a077:	8c2c      	movi.n	a12, 40
4200a079:	0b0c      	movi.n	a11, 0
4200a07b:	20a110        	or	a10, a1, a1
4200a07e:	d8a181        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200a081:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a084:	0a0c      	movi.n	a10, 0
4200a086:	001286        	j	4200a0d4 <esp_mmu_map_init+0x60>
        hw_mem_regions[i].start = g_mmu_mem_regions[i].start;
4200a089:	909aa0        	addx2	a9, a10, a10
4200a08c:	1189d0        	slli	a8, a9, 3
4200a08f:	da7c91        	l32r	a9, 42000a80 <_stext+0xa60> (3c0277d0 <g_mmu_mem_regions>)
4200a092:	998a      	add.n	a9, a9, a8
4200a094:	09c8      	l32i.n	a12, a9, 0
4200a096:	a0baa0        	addx4	a11, a10, a10
4200a099:	118bd0        	slli	a8, a11, 3
4200a09c:	818a      	add.n	a8, a1, a8
4200a09e:	18c9      	s32i.n	a12, a8, 4
        hw_mem_regions[i].end = g_mmu_mem_regions[i].end;
4200a0a0:	19b8      	l32i.n	a11, a9, 4
4200a0a2:	28b9      	s32i.n	a11, a8, 8
        hw_mem_regions[i].region_size = g_mmu_mem_regions[i].size;
4200a0a4:	29b8      	l32i.n	a11, a9, 8
4200a0a6:	38b9      	s32i.n	a11, a8, 12
        hw_mem_regions[i].max_slot_size = g_mmu_mem_regions[i].size;
4200a0a8:	58b9      	s32i.n	a11, a8, 20
        hw_mem_regions[i].free_head = g_mmu_mem_regions[i].start;
4200a0aa:	48c9      	s32i.n	a12, a8, 16
        hw_mem_regions[i].bus_id = g_mmu_mem_regions[i].bus_id;
4200a0ac:	39c8      	l32i.n	a12, a9, 12
4200a0ae:	08c9      	s32i.n	a12, a8, 0
        hw_mem_regions[i].caps = g_mmu_mem_regions[i].caps;
4200a0b0:	59c8      	l32i.n	a12, a9, 20
4200a0b2:	68c9      	s32i.n	a12, a8, 24
        hw_mem_regions[i].targets = g_mmu_mem_regions[i].targets;
4200a0b4:	4998      	l32i.n	a9, a9, 16
4200a0b6:	076892        	s32i	a9, a8, 28
        assert(hw_mem_regions[i].region_size % CONFIG_MMU_PAGE_SIZE == 0);
4200a0b9:	f4b0b0        	extui	a11, a11, 0, 16
4200a0bc:	011b16        	beqz	a11, 4200a0d1 <esp_mmu_map_init+0x5d>
4200a0bf:	da71d1        	l32r	a13, 42000a84 <_stext+0xa64> (3c024e0c <_flash_rodata_start+0x4cec>)
4200a0c2:	da71c1        	l32r	a12, 42000a88 <_stext+0xa68> (3c0277bc <__func__$11>)
4200a0c5:	d3a0b2        	movi	a11, 211
4200a0c8:	da69a1        	l32r	a10, 42000a6c <_stext+0xa4c> (3c024d68 <_flash_rodata_start+0x4c48>)
4200a0cb:	d80f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200a0ce:	0008e0        	callx8	a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a0d1:	01caa2        	addi	a10, a10, 1
4200a0d4:	fb1a16        	beqz	a10, 4200a089 <esp_mmu_map_init+0x15>
    s_reserve_irom_region(hw_mem_regions, SOC_MMU_LINEAR_ADDRESS_REGION_NUM);
4200a0d7:	01a0b2        	movi	a11, 1
4200a0da:	01ad      	mov.n	a10, a1
4200a0dc:	ffe965        	call8	42009f74 <s_reserve_irom_region>
    s_reserve_drom_region(hw_mem_regions, SOC_MMU_LINEAR_ADDRESS_REGION_NUM);
4200a0df:	1b0c      	movi.n	a11, 1
4200a0e1:	01ad      	mov.n	a10, a1
4200a0e3:	fff125        	call8	42009ff4 <s_reserve_drom_region>
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a0e6:	080c      	movi.n	a8, 0
    uint32_t region_num = 0;
4200a0e8:	085d      	mov.n	a5, a8
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a0ea:	000406        	j	4200a0fe <esp_mmu_map_init+0x8a>
        if (hw_mem_regions[i].caps != MEM_REGION_MERGED) {
4200a0ed:	a0a880        	addx4	a10, a8, a8
4200a0f0:	119ad0        	slli	a9, a10, 3
4200a0f3:	919a      	add.n	a9, a1, a9
4200a0f5:	6998      	l32i.n	a9, a9, 24
4200a0f7:	010926        	beqi	a9, -1, 4200a0fc <esp_mmu_map_init+0x88>
            region_num++;
4200a0fa:	551b      	addi.n	a5, a5, 1
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a0fc:	881b      	addi.n	a8, a8, 1
4200a0fe:	feb816        	beqz	a8, 4200a0ed <esp_mmu_map_init+0x79>
    s_mmu_ctx.num_regions = region_num;
4200a101:	da6281        	l32r	a8, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a104:	0859      	s32i.n	a5, a8, 0
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a106:	070c      	movi.n	a7, 0
    uint32_t available_region_idx = 0;
4200a108:	076d      	mov.n	a6, a7
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a10a:	000a86        	j	4200a138 <esp_mmu_map_init+0xc4>
        if (hw_mem_regions[i].caps == MEM_REGION_MERGED) {
4200a10d:	a09770        	addx4	a9, a7, a7
4200a110:	1189d0        	slli	a8, a9, 3
4200a113:	818a      	add.n	a8, a1, a8
4200a115:	6888      	l32i.n	a8, a8, 24
4200a117:	1b0826        	beqi	a8, -1, 4200a136 <esp_mmu_map_init+0xc2>
        memcpy(&s_mmu_ctx.mem_regions[available_region_idx], &hw_mem_regions[i], sizeof(mem_region_t));
4200a11a:	a08660        	addx4	a8, a6, a6
4200a11d:	11a8d0        	slli	a10, a8, 3
4200a120:	da5b81        	l32r	a8, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a123:	aa8a      	add.n	a10, a10, a8
4200a125:	11b9d0        	slli	a11, a9, 3
4200a128:	8c2c      	movi.n	a12, 40
4200a12a:	b1ba      	add.n	a11, a1, a11
4200a12c:	aa4b      	addi.n	a10, a10, 4
4200a12e:	d7be81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200a131:	0008e0        	callx8	a8
        available_region_idx++;
4200a134:	661b      	addi.n	a6, a6, 1
    for (int i = 0; i < SOC_MMU_LINEAR_ADDRESS_REGION_NUM; i++) {
4200a136:	771b      	addi.n	a7, a7, 1
4200a138:	fd1716        	beqz	a7, 4200a10d <esp_mmu_map_init+0x99>
    for (int i = 0; i < available_region_idx; i++) {
4200a13b:	080c      	movi.n	a8, 0
4200a13d:	0007c6        	j	4200a160 <esp_mmu_map_init+0xec>
        TAILQ_INIT(&s_mmu_ctx.mem_regions[i].mem_block_head);
4200a140:	da53b1        	l32r	a11, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a143:	a09880        	addx4	a9, a8, a8
4200a146:	11a9d0        	slli	a10, a9, 3
4200a149:	abaa      	add.n	a10, a11, a10
4200a14b:	090c      	movi.n	a9, 0
4200a14d:	9a99      	s32i.n	a9, a10, 36
4200a14f:	a0c880        	addx4	a12, a8, a8
4200a152:	119cd0        	slli	a9, a12, 3
4200a155:	20c992        	addi	a9, a9, 32
4200a158:	99ba      	add.n	a9, a9, a11
4200a15a:	994b      	addi.n	a9, a9, 4
4200a15c:	aa99      	s32i.n	a9, a10, 40
    for (int i = 0; i < available_region_idx; i++) {
4200a15e:	881b      	addi.n	a8, a8, 1
4200a160:	dc3867        	bltu	a8, a6, 4200a140 <esp_mmu_map_init+0xcc>
    assert(available_region_idx == region_num);
4200a163:	111657        	beq	a6, a5, 4200a178 <esp_mmu_map_init+0x104>
4200a166:	da4ad1        	l32r	a13, 42000a90 <_stext+0xa70> (3c024e48 <_flash_rodata_start+0x4d28>)
4200a169:	da47c1        	l32r	a12, 42000a88 <_stext+0xa68> (3c0277bc <__func__$11>)
4200a16c:	05a1b2        	movi	a11, 0x105
4200a16f:	da3fa1        	l32r	a10, 42000a6c <_stext+0xa4c> (3c024d68 <_flash_rodata_start+0x4c48>)
4200a172:	d7e581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200a175:	0008e0        	callx8	a8
}
4200a178:	f01d      	retw.n
	...

4200a17c <esp_mmu_map>:
{
4200a17c:	00a136        	entry	a1, 80
4200a17f:	8179      	s32i.n	a7, a1, 32
4200a181:	5159      	s32i.n	a5, a1, 20
    ESP_RETURN_ON_FALSE(out_ptr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
4200a183:	a7ec      	bnez.n	a7, 4200a1b1 <esp_mmu_map+0x35>
4200a185:	da4371        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a188:	0768      	l32i.n	a6, a7, 0
4200a18a:	d7b581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a18d:	0008e0        	callx8	a8
4200a190:	cfa182        	movi	a8, 0x1cf
4200a193:	0189      	s32i.n	a8, a1, 0
4200a195:	da40f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a198:	07e8      	l32i.n	a14, a7, 0
4200a19a:	0add      	mov.n	a13, a10
4200a19c:	da40c1        	l32r	a12, 42000a9c <_stext+0xa7c> (3c024e6c <_flash_rodata_start+0x4d4c>)
4200a19f:	06bd      	mov.n	a11, a6
4200a1a1:	1a0c      	movi.n	a10, 1
4200a1a3:	d7bc81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a1a6:	0008e0        	callx8	a8
4200a1a9:	02a182        	movi	a8, 0x102
4200a1ac:	6189      	s32i.n	a8, a1, 24
4200a1ae:	00f4c6        	j	4200a585 <esp_mmu_map+0x409>
    ESP_RETURN_ON_FALSE((paddr_start % CONFIG_MMU_PAGE_SIZE == 0), ESP_ERR_INVALID_ARG, TAG, "paddr must be rounded up to the nearest multiple of CONFIG_MMU_PAGE_SIZE");
4200a1b1:	f45020        	extui	a5, a2, 0, 16
4200a1b4:	d5ac      	beqz.n	a5, 4200a1e5 <esp_mmu_map+0x69>
4200a1b6:	da3771        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a1b9:	0768      	l32i.n	a6, a7, 0
4200a1bb:	d7a981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a1be:	0008e0        	callx8	a8
4200a1c1:	d3a182        	movi	a8, 0x1d3
4200a1c4:	0189      	s32i.n	a8, a1, 0
4200a1c6:	da34f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a1c9:	07e8      	l32i.n	a14, a7, 0
4200a1cb:	0add      	mov.n	a13, a10
4200a1cd:	da34c1        	l32r	a12, 42000aa0 <_stext+0xa80> (3c024eb4 <_flash_rodata_start+0x4d94>)
4200a1d0:	20b660        	or	a11, a6, a6
4200a1d3:	01a0a2        	movi	a10, 1
4200a1d6:	d7af81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a1d9:	0008e0        	callx8	a8
4200a1dc:	02a182        	movi	a8, 0x102
4200a1df:	6189      	s32i.n	a8, a1, 24
4200a1e1:	00e806        	j	4200a585 <esp_mmu_map+0x409>
4200a1e4:	21a200        	srai	a10, a0, 2
    ESP_RETURN_ON_ERROR(s_mem_caps_check(caps), TAG, "invalid caps");
4200a1e7:	20a505        	call0	4202ac38 <_etext+0x11502>
4200a1ea:	0d          	.byte	0xd
4200a1eb:	0661a2        	s32i	a10, a1, 24
4200a1ee:	026a16        	beqz	a10, 4200a218 <esp_mmu_map+0x9c>
4200a1f1:	da2871        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a1f4:	0768      	l32i.n	a6, a7, 0
4200a1f6:	d79a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a1f9:	0008e0        	callx8	a8
4200a1fc:	d4a182        	movi	a8, 0x1d4
4200a1ff:	0189      	s32i.n	a8, a1, 0
4200a201:	da25f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a204:	07e8      	l32i.n	a14, a7, 0
4200a206:	0add      	mov.n	a13, a10
4200a208:	da27c1        	l32r	a12, 42000aa4 <_stext+0xa84> (3c024e90 <_flash_rodata_start+0x4d70>)
4200a20b:	06bd      	mov.n	a11, a6
4200a20d:	1a0c      	movi.n	a10, 1
4200a20f:	d7a181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a212:	0008e0        	callx8	a8
4200a215:	00db06        	j	4200a585 <esp_mmu_map+0x409>
    _lock_acquire(&s_mmu_ctx.mutex);
4200a218:	da24a1        	l32r	a10, 42000aa8 <_stext+0xa88> (3fc953ac <s_mmu_ctx+0x2c>)
4200a21b:	d95a81        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
4200a21e:	0008e0        	callx8	a8
    size_t aligned_size = ALIGN_UP_BY(size, CONFIG_MMU_PAGE_SIZE);
4200a221:	d99281        	l32r	a8, 4200086c <_stext+0x84c> (ffff <UserFrameTotalSize+0xfeff>)
4200a224:	803380        	add	a3, a3, a8
4200a227:	f53030        	extui	a3, a3, 16, 16
4200a22a:	113300        	slli	a3, a3, 16
    int32_t found_region_id = s_find_available_region(s_mmu_ctx.mem_regions, s_mmu_ctx.num_regions, aligned_size, caps, target);
4200a22d:	20e440        	or	a14, a4, a4
4200a230:	0521d2        	l32i	a13, a1, 20
4200a233:	03cd      	mov.n	a12, a3
4200a235:	da1581        	l32r	a8, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a238:	08b8      	l32i.n	a11, a8, 0
4200a23a:	da1ca1        	l32r	a10, 42000aac <_stext+0xa8c> (3fc95384 <s_mmu_ctx+0x4>)
4200a23d:	0d1d25        	call8	42017410 <s_find_available_region>
4200a240:	71a9      	s32i.n	a10, a1, 28
    ESP_GOTO_ON_FALSE(found_region_id != -1, ESP_ERR_NOT_FOUND, err, TAG, "no such vaddr range");
4200a242:	2f0a66        	bnei	a10, -1, 4200a275 <esp_mmu_map+0xf9>
4200a245:	da1371        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a248:	0768      	l32i.n	a6, a7, 0
4200a24a:	d78581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a24d:	0008e0        	callx8	a8
4200a250:	dba182        	movi	a8, 0x1db
4200a253:	0189      	s32i.n	a8, a1, 0
4200a255:	da10f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a258:	07e8      	l32i.n	a14, a7, 0
4200a25a:	0add      	mov.n	a13, a10
4200a25c:	da15c1        	l32r	a12, 42000ab0 <_stext+0xa90> (3c024f14 <_flash_rodata_start+0x4df4>)
4200a25f:	06bd      	mov.n	a11, a6
4200a261:	1a0c      	movi.n	a10, 1
4200a263:	d78c81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a266:	0008e0        	callx8	a8
    mem_block_t *dummy_head = NULL;
4200a269:	080c      	movi.n	a8, 0
4200a26b:	9189      	s32i.n	a8, a1, 36
    ESP_GOTO_ON_FALSE(found_region_id != -1, ESP_ERR_NOT_FOUND, err, TAG, "no such vaddr range");
4200a26d:	05a182        	movi	a8, 0x105
4200a270:	6189      	s32i.n	a8, a1, 24
4200a272:	00be86        	j	4200a570 <esp_mmu_map+0x3f4>
    if (TAILQ_EMPTY(&found_region->mem_block_head)) {
4200a275:	7188      	l32i.n	a8, a1, 28
4200a277:	a08880        	addx4	a8, a8, a8
4200a27a:	da0491        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a27d:	b08890        	addx8	a8, a8, a9
4200a280:	9888      	l32i.n	a8, a8, 36
4200a282:	102856        	bnez	a8, 4200a388 <esp_mmu_map+0x20c>
        dummy_head = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200a285:	d88cc1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
4200a288:	cb2c      	movi.n	a11, 44
4200a28a:	1a0c      	movi.n	a10, 1
4200a28c:	d9e081        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
4200a28f:	0008e0        	callx8	a8
4200a292:	91a9      	s32i.n	a10, a1, 36
        ESP_GOTO_ON_FALSE(dummy_head, ESP_ERR_NO_MEM, err, TAG, "no mem");
4200a294:	caec      	bnez.n	a10, 4200a2c4 <esp_mmu_map+0x148>
4200a296:	d9ff71        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a299:	0768      	l32i.n	a6, a7, 0
4200a29b:	d77181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a29e:	0008e0        	callx8	a8
4200a2a1:	e3a182        	movi	a8, 0x1e3
4200a2a4:	0189      	s32i.n	a8, a1, 0
4200a2a6:	d9fcf1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a2a9:	07e8      	l32i.n	a14, a7, 0
4200a2ab:	0add      	mov.n	a13, a10
4200a2ad:	da01c1        	l32r	a12, 42000ab4 <_stext+0xa94> (3c024f40 <_flash_rodata_start+0x4e20>)
4200a2b0:	20b660        	or	a11, a6, a6
4200a2b3:	01a0a2        	movi	a10, 1
4200a2b6:	d77781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a2b9:	0008e0        	callx8	a8
4200a2bc:	01a182        	movi	a8, 0x101
4200a2bf:	6189      	s32i.n	a8, a1, 24
4200a2c1:	00aac6        	j	4200a570 <esp_mmu_map+0x3f4>
        dummy_head->laddr_start = found_region->free_head;
4200a2c4:	7188      	l32i.n	a8, a1, 28
4200a2c6:	a08880        	addx4	a8, a8, a8
4200a2c9:	d9f091        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a2cc:	b08890        	addx8	a8, a8, a9
4200a2cf:	5898      	l32i.n	a9, a8, 20
4200a2d1:	91a8      	l32i.n	a10, a1, 36
4200a2d3:	0a99      	s32i.n	a9, a10, 0
        dummy_head->laddr_end = found_region->free_head;
4200a2d5:	1a99      	s32i.n	a9, a10, 4
        dummy_head->size = 0;
4200a2d7:	090c      	movi.n	a9, 0
4200a2d9:	4a99      	s32i.n	a9, a10, 16
        dummy_head->caps = caps;
4200a2db:	0a9d      	mov.n	a9, a10
4200a2dd:	51a8      	l32i.n	a10, a1, 20
4200a2df:	59a9      	s32i.n	a10, a9, 20
        TAILQ_INSERT_HEAD(&found_region->mem_block_head, dummy_head, entries);
4200a2e1:	9888      	l32i.n	a8, a8, 36
4200a2e3:	9989      	s32i.n	a8, a9, 36
4200a2e5:	788c      	beqz.n	a8, 4200a2f0 <esp_mmu_map+0x174>
4200a2e7:	24c992        	addi	a9, a9, 36
4200a2ea:	a899      	s32i.n	a9, a8, 40
4200a2ec:	000486        	j	4200a302 <esp_mmu_map+0x186>
4200a2ef:	00          	.byte	00
4200a2f0:	9188      	l32i.n	a8, a1, 36
4200a2f2:	24c892        	addi	a9, a8, 36
4200a2f5:	7188      	l32i.n	a8, a1, 28
4200a2f7:	a08880        	addx4	a8, a8, a8
4200a2fa:	d9e4a1        	l32r	a10, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a2fd:	b088a0        	addx8	a8, a8, a10
4200a300:	a899      	s32i.n	a9, a8, 40
4200a302:	d9e291        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a305:	71a8      	l32i.n	a10, a1, 28
4200a307:	a08aa0        	addx4	a8, a10, a10
4200a30a:	b08890        	addx8	a8, a8, a9
4200a30d:	91b8      	l32i.n	a11, a1, 36
4200a30f:	98b9      	s32i.n	a11, a8, 36
4200a311:	a08aa0        	addx4	a8, a10, a10
4200a314:	1188d0        	slli	a8, a8, 3
4200a317:	20c882        	addi	a8, a8, 32
4200a31a:	889a      	add.n	a8, a8, a9
4200a31c:	884b      	addi.n	a8, a8, 4
4200a31e:	ab89      	s32i.n	a8, a11, 40
        dummy_tail = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200a320:	d866c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
4200a323:	cb2c      	movi.n	a11, 44
4200a325:	1a0c      	movi.n	a10, 1
4200a327:	d9b981        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
4200a32a:	0008e0        	callx8	a8
4200a32d:	b1a9      	s32i.n	a10, a1, 44
        ESP_GOTO_ON_FALSE(dummy_tail, ESP_ERR_NO_MEM, err, TAG, "no mem");
4200a32f:	aaec      	bnez.n	a10, 4200a35d <esp_mmu_map+0x1e1>
4200a331:	d9d871        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a334:	0768      	l32i.n	a6, a7, 0
4200a336:	d74a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a339:	0008e0        	callx8	a8
4200a33c:	eda182        	movi	a8, 0x1ed
4200a33f:	0189      	s32i.n	a8, a1, 0
4200a341:	d9d5f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a344:	07e8      	l32i.n	a14, a7, 0
4200a346:	0add      	mov.n	a13, a10
4200a348:	d9dbc1        	l32r	a12, 42000ab4 <_stext+0xa94> (3c024f40 <_flash_rodata_start+0x4e20>)
4200a34b:	06bd      	mov.n	a11, a6
4200a34d:	1a0c      	movi.n	a10, 1
4200a34f:	d75181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a352:	0008e0        	callx8	a8
4200a355:	01a182        	movi	a8, 0x101
4200a358:	6189      	s32i.n	a8, a1, 24
4200a35a:	008186        	j	4200a564 <esp_mmu_map+0x3e8>
        dummy_tail->laddr_start = found_region->end;
4200a35d:	7188      	l32i.n	a8, a1, 28
4200a35f:	a08880        	addx4	a8, a8, a8
4200a362:	d9ca91        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a365:	b08890        	addx8	a8, a8, a9
4200a368:	3898      	l32i.n	a9, a8, 12
4200a36a:	b1a8      	l32i.n	a10, a1, 44
4200a36c:	0a99      	s32i.n	a9, a10, 0
        dummy_tail->laddr_end = found_region->end;
4200a36e:	1a99      	s32i.n	a9, a10, 4
        dummy_tail->size = 0;
4200a370:	090c      	movi.n	a9, 0
4200a372:	4a99      	s32i.n	a9, a10, 16
        dummy_tail->caps = caps;
4200a374:	51b8      	l32i.n	a11, a1, 20
4200a376:	5ab9      	s32i.n	a11, a10, 20
        TAILQ_INSERT_TAIL(&found_region->mem_block_head, dummy_tail, entries);
4200a378:	9a99      	s32i.n	a9, a10, 36
4200a37a:	a898      	l32i.n	a9, a8, 40
4200a37c:	aa99      	s32i.n	a9, a10, 40
4200a37e:	09a9      	s32i.n	a10, a9, 0
4200a380:	24ca92        	addi	a9, a10, 36
4200a383:	a899      	s32i.n	a9, a8, 40
4200a385:	000146        	j	4200a38e <esp_mmu_map+0x212>
    mem_block_t *dummy_tail = NULL;
4200a388:	080c      	movi.n	a8, 0
4200a38a:	b189      	s32i.n	a8, a1, 44
    mem_block_t *dummy_head = NULL;
4200a38c:	9189      	s32i.n	a8, a1, 36
    bool allow_overlap = flags & ESP_MMU_MMAP_FLAG_PADDR_SHARED;
4200a38e:	048060        	extui	a8, a6, 0, 1
4200a391:	4189      	s32i.n	a8, a1, 16
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
4200a393:	7188      	l32i.n	a8, a1, 28
4200a395:	a08880        	addx4	a8, a8, a8
4200a398:	d9bd91        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a39b:	b08890        	addx8	a8, a8, a9
4200a39e:	9878      	l32i.n	a7, a8, 36
4200a3a0:	a159      	s32i.n	a5, a1, 40
4200a3a2:	000a86        	j	4200a3d0 <esp_mmu_map+0x254>
        if (target == mem_block->target) {
4200a3a5:	082782        	l32i	a8, a7, 32
4200a3a8:	229847        	bne	a8, a4, 4200a3ce <esp_mmu_map+0x252>
            if ((s_is_enclosed(mem_block->paddr_start, mem_block->paddr_end, paddr_start, aligned_size))) {
4200a3ab:	062762        	l32i	a6, a7, 24
4200a3ae:	7758      	l32i.n	a5, a7, 28
4200a3b0:	03dd      	mov.n	a13, a3
4200a3b2:	02cd      	mov.n	a12, a2
4200a3b4:	05bd      	mov.n	a11, a5
4200a3b6:	06ad      	mov.n	a10, a6
4200a3b8:	0d0825        	call8	4201743c <s_is_enclosed>
4200a3bb:	dadc      	bnez.n	a10, 4200a3dc <esp_mmu_map+0x260>
            if (!allow_overlap && (s_is_overlapped(mem_block->paddr_start, mem_block->paddr_end, paddr_start, aligned_size))) {
4200a3bd:	4188      	l32i.n	a8, a1, 16
4200a3bf:	b8cc      	bnez.n	a8, 4200a3ce <esp_mmu_map+0x252>
4200a3c1:	03dd      	mov.n	a13, a3
4200a3c3:	02cd      	mov.n	a12, a2
4200a3c5:	05bd      	mov.n	a11, a5
4200a3c7:	06ad      	mov.n	a10, a6
4200a3c9:	0d0925        	call8	4201745c <s_is_overlapped>
4200a3cc:	4adc      	bnez.n	a10, 4200a3e4 <esp_mmu_map+0x268>
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
4200a3ce:	9778      	l32i.n	a7, a7, 36
4200a3d0:	fd1756        	bnez	a7, 4200a3a5 <esp_mmu_map+0x229>
    bool is_overlapped = false;
4200a3d3:	a158      	l32i.n	a5, a1, 40
4200a3d5:	080c      	movi.n	a8, 0
    bool is_enclosed = false;
4200a3d7:	08ad      	mov.n	a10, a8
4200a3d9:	000346        	j	4200a3ea <esp_mmu_map+0x26e>
    bool is_overlapped = false;
4200a3dc:	a158      	l32i.n	a5, a1, 40
4200a3de:	080c      	movi.n	a8, 0
4200a3e0:	000186        	j	4200a3ea <esp_mmu_map+0x26e>
4200a3e3:	0a8d00        	add.s	f8, f13, f0
    bool is_enclosed = false;
4200a3e6:	a158      	l32i.n	a5, a1, 40
4200a3e8:	41a8      	l32i.n	a10, a1, 16
    if (is_enclosed) {
4200a3ea:	fabc      	beqz.n	a10, 4200a42d <esp_mmu_map+0x2b1>
        const uint32_t new_paddr_offset = paddr_start - mem_block->paddr_start;
4200a3ec:	6798      	l32i.n	a9, a7, 24
4200a3ee:	c09290        	sub	a9, a2, a9
        *out_ptr = (void *)mem_block->vaddr_start + new_paddr_offset;
4200a3f1:	2788      	l32i.n	a8, a7, 8
4200a3f3:	889a      	add.n	a8, a8, a9
4200a3f5:	8198      	l32i.n	a9, a1, 32
4200a3f7:	0989      	s32i.n	a8, a9, 0
        ESP_GOTO_ON_FALSE(false, ESP_ERR_INVALID_STATE, err, TAG, "paddr block is mapped already, vaddr_start: %p, size: 0x%x", (void *)mem_block->vaddr_start, mem_block->size);
4200a3f9:	d9a661        	l32r	a6, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a3fc:	0658      	l32i.n	a5, a6, 0
4200a3fe:	d71881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a401:	0008e0        	callx8	a8
4200a404:	2788      	l32i.n	a8, a7, 8
4200a406:	4798      	l32i.n	a9, a7, 16
4200a408:	2199      	s32i.n	a9, a1, 8
4200a40a:	1189      	s32i.n	a8, a1, 4
4200a40c:	18a282        	movi	a8, 0x218
4200a40f:	0189      	s32i.n	a8, a1, 0
4200a411:	d9a1f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a414:	06e8      	l32i.n	a14, a6, 0
4200a416:	0add      	mov.n	a13, a10
4200a418:	d9a8c1        	l32r	a12, 42000ab8 <_stext+0xa98> (3c024f5c <_flash_rodata_start+0x4e3c>)
4200a41b:	05bd      	mov.n	a11, a5
4200a41d:	1a0c      	movi.n	a10, 1
4200a41f:	d71d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a422:	0008e0        	callx8	a8
4200a425:	03a182        	movi	a8, 0x103
4200a428:	6189      	s32i.n	a8, a1, 24
4200a42a:	004d86        	j	4200a564 <esp_mmu_map+0x3e8>
    if (!allow_overlap && is_overlapped) {
4200a42d:	190c      	movi.n	a9, 1
4200a42f:	41a8      	l32i.n	a10, a1, 16
4200a431:	309a90        	xor	a9, a10, a9
4200a434:	749090        	extui	a9, a9, 0, 8
4200a437:	106980        	and	a6, a9, a8
4200a43a:	2b0987        	bnone	a9, a8, 4200a469 <esp_mmu_map+0x2ed>
        ESP_GOTO_ON_FALSE(false, ESP_ERR_INVALID_ARG, err, TAG, "paddr block is overlapped with an already mapped paddr block");
4200a43d:	d99571        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a440:	0768      	l32i.n	a6, a7, 0
4200a442:	d70781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a445:	0008e0        	callx8	a8
4200a448:	1ca282        	movi	a8, 0x21c
4200a44b:	0189      	s32i.n	a8, a1, 0
4200a44d:	d992f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a450:	07e8      	l32i.n	a14, a7, 0
4200a452:	0add      	mov.n	a13, a10
4200a454:	d99ac1        	l32r	a12, 42000abc <_stext+0xa9c> (3c024fac <_flash_rodata_start+0x4e8c>)
4200a457:	06bd      	mov.n	a11, a6
4200a459:	1a0c      	movi.n	a10, 1
4200a45b:	d70e81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a45e:	0008e0        	callx8	a8
4200a461:	02a182        	movi	a8, 0x102
4200a464:	6189      	s32i.n	a8, a1, 24
4200a466:	003e86        	j	4200a564 <esp_mmu_map+0x3e8>
    new_block = (mem_block_t *)heap_caps_calloc(1, sizeof(mem_block_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
4200a469:	d813c1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
4200a46c:	cb2c      	movi.n	a11, 44
4200a46e:	1a0c      	movi.n	a10, 1
4200a470:	d96781        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
4200a473:	0008e0        	callx8	a8
4200a476:	0a7d      	mov.n	a7, a10
    ESP_GOTO_ON_FALSE(new_block, ESP_ERR_NO_MEM, err, TAG, "no mem");
4200a478:	caec      	bnez.n	a10, 4200a4a8 <esp_mmu_map+0x32c>
4200a47a:	d98671        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a47d:	0768      	l32i.n	a6, a7, 0
4200a47f:	d6f881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a482:	0008e0        	callx8	a8
4200a485:	21a282        	movi	a8, 0x221
4200a488:	0189      	s32i.n	a8, a1, 0
4200a48a:	d983f1        	l32r	a15, 42000a98 <_stext+0xa78> (3c02776c <__FUNCTION__$5>)
4200a48d:	07e8      	l32i.n	a14, a7, 0
4200a48f:	0add      	mov.n	a13, a10
4200a491:	d988c1        	l32r	a12, 42000ab4 <_stext+0xa94> (3c024f40 <_flash_rodata_start+0x4e20>)
4200a494:	20b660        	or	a11, a6, a6
4200a497:	01a0a2        	movi	a10, 1
4200a49a:	d6fe81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a49d:	0008e0        	callx8	a8
4200a4a0:	01a182        	movi	a8, 0x101
4200a4a3:	6189      	s32i.n	a8, a1, 24
4200a4a5:	002ec6        	j	4200a564 <esp_mmu_map+0x3e8>
    uint32_t last_end = TAILQ_FIRST(&found_region->mem_block_head)->laddr_end;
4200a4a8:	7188      	l32i.n	a8, a1, 28
4200a4aa:	a08880        	addx4	a8, a8, a8
4200a4ad:	d97791        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a4b0:	b08890        	addx8	a8, a8, a9
4200a4b3:	9888      	l32i.n	a8, a8, 36
4200a4b5:	18a8      	l32i.n	a10, a8, 4
    mem_block_t *found_block = NULL;  //This stands for the block we found, whose slot between its prior block is where we will insert the new block to
4200a4b7:	0b0c      	movi.n	a11, 0
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
4200a4b9:	0006c6        	j	4200a4d8 <esp_mmu_map+0x35c>
4200a4bc:	00          	.byte	00
4200a4bd:	089800        	lsx	f9, a8, a0
        slot_len = mem_block->laddr_start - last_end;
4200a4c0:	c099a0        	sub	a9, a9, a10
        if (!found) {
4200a4c3:	a6cc      	bnez.n	a6, 4200a4d1 <esp_mmu_map+0x355>
            if (slot_len >= aligned_size) {
4200a4c5:	083937        	bltu	a9, a3, 4200a4d1 <esp_mmu_map+0x355>
                slot_len -= aligned_size;
4200a4c8:	c09930        	sub	a9, a9, a3
                new_block->laddr_start = last_end;
4200a4cb:	07a9      	s32i.n	a10, a7, 0
                found_block = mem_block;
4200a4cd:	08bd      	mov.n	a11, a8
                found = true;
4200a4cf:	160c      	movi.n	a6, 1
        max_slot_len = (slot_len > max_slot_len) ? slot_len : max_slot_len;
4200a4d1:	735590        	maxu	a5, a5, a9
        last_end = mem_block->laddr_end;
4200a4d4:	18a8      	l32i.n	a10, a8, 4
    TAILQ_FOREACH(mem_block, &found_region->mem_block_head, entries) {
4200a4d6:	9888      	l32i.n	a8, a8, 36
4200a4d8:	fe2856        	bnez	a8, 4200a4be <esp_mmu_map+0x342>
    assert(found);
4200a4db:	011656        	bnez	a6, 4200a4f0 <esp_mmu_map+0x374>
4200a4de:	d978d1        	l32r	a13, 42000ac0 <_stext+0xaa0> (3c025000 <_flash_rodata_start+0x4ee0>)
4200a4e1:	d978c1        	l32r	a12, 42000ac4 <_stext+0xaa4> (3c027760 <__func__$4>)
4200a4e4:	3ca2b2        	movi	a11, 0x23c
4200a4e7:	d961a1        	l32r	a10, 42000a6c <_stext+0xa4c> (3c024d68 <_flash_rodata_start+0x4c48>)
4200a4ea:	d70781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200a4ed:	0008e0        	callx8	a8
    TAILQ_INSERT_BEFORE(found_block, new_block, entries);
4200a4f0:	ab88      	l32i.n	a8, a11, 40
4200a4f2:	a789      	s32i.n	a8, a7, 40
4200a4f4:	97b9      	s32i.n	a11, a7, 36
4200a4f6:	ab88      	l32i.n	a8, a11, 40
4200a4f8:	0879      	s32i.n	a7, a8, 0
4200a4fa:	24c782        	addi	a8, a7, 36
4200a4fd:	ab89      	s32i.n	a8, a11, 40
    found_region->max_slot_size = max_slot_len;
4200a4ff:	7188      	l32i.n	a8, a1, 28
4200a501:	a08880        	addx4	a8, a8, a8
4200a504:	d96291        	l32r	a9, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a507:	b08890        	addx8	a8, a8, a9
4200a50a:	6859      	s32i.n	a5, a8, 24
    new_block->laddr_end = new_block->laddr_start + aligned_size;
4200a50c:	0798      	l32i.n	a9, a7, 0
4200a50e:	839a      	add.n	a8, a3, a9
4200a510:	1789      	s32i.n	a8, a7, 4
    new_block->size = aligned_size;
4200a512:	4739      	s32i.n	a3, a7, 16
    new_block->caps = caps;
4200a514:	51b8      	l32i.n	a11, a1, 20
4200a516:	57b9      	s32i.n	a11, a7, 20
    new_block->paddr_start = paddr_start;
4200a518:	6729      	s32i.n	a2, a7, 24
    new_block->paddr_end = paddr_start + aligned_size;
4200a51a:	a32a      	add.n	a10, a3, a2
4200a51c:	77a9      	s32i.n	a10, a7, 28
    new_block->target = target;
4200a51e:	8749      	s32i.n	a4, a7, 32
    if (caps & MMU_MEM_CAP_EXEC) {
4200a520:	116b07        	bbci	a11, 0, 4200a535 <esp_mmu_map+0x3b9>
    return vaddr_base | laddr;
4200a523:	d969a1        	l32r	a10, 42000ac8 <_stext+0xaa8> (42000000 <_iram_bss_end+0x1c7dc00>)
4200a526:	2099a0        	or	a9, a9, a10
        new_block->vaddr_start = mmu_ll_laddr_to_vaddr(new_block->laddr_start, MMU_VADDR_INSTRUCTION, target);
4200a529:	2799      	s32i.n	a9, a7, 8
4200a52b:	2088a0        	or	a8, a8, a10
        new_block->vaddr_end = mmu_ll_laddr_to_vaddr(new_block->laddr_end, MMU_VADDR_INSTRUCTION, target);
4200a52e:	3789      	s32i.n	a8, a7, 12
4200a530:	000386        	j	4200a542 <esp_mmu_map+0x3c6>
4200a533:	a10000        	sll	a0, a0
4200a536:	a0d965        	call8	41fab2cc <_iram_bss_end+0x1c28ecc>
4200a539:	2099      	s32i.n	a9, a0, 8
        new_block->vaddr_start = mmu_ll_laddr_to_vaddr(new_block->laddr_start, MMU_VADDR_DATA, target);
4200a53b:	2799      	s32i.n	a9, a7, 8
4200a53d:	2088a0        	or	a8, a8, a10
        new_block->vaddr_end = mmu_ll_laddr_to_vaddr(new_block->laddr_end, MMU_VADDR_DATA, target);
4200a540:	3789      	s32i.n	a8, a7, 12
    s_do_mapping(target, new_block->vaddr_start, paddr_start, aligned_size);
4200a542:	03dd      	mov.n	a13, a3
4200a544:	02cd      	mov.n	a12, a2
4200a546:	27b8      	l32i.n	a11, a7, 8
4200a548:	20a440        	or	a10, a4, a4
4200a54b:	d96181        	l32r	a8, 42000ad0 <_stext+0xab0> (403775f8 <s_do_mapping>)
4200a54e:	0008e0        	callx8	a8
    *out_ptr = (void *)new_block->vaddr_start;
4200a551:	2788      	l32i.n	a8, a7, 8
4200a553:	8198      	l32i.n	a9, a1, 32
4200a555:	0989      	s32i.n	a8, a9, 0
    _lock_release(&s_mmu_ctx.mutex);
4200a557:	d954a1        	l32r	a10, 42000aa8 <_stext+0xa88> (3fc953ac <s_mmu_ctx+0x2c>)
4200a55a:	d88b81        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
4200a55d:	0008e0        	callx8	a8
    return ESP_OK;
4200a560:	000846        	j	4200a585 <esp_mmu_map+0x409>
4200a563:	00          	.byte	00
    if (dummy_tail) {
4200a564:	b188      	l32i.n	a8, a1, 44
4200a566:	688c      	beqz.n	a8, 4200a570 <esp_mmu_map+0x3f4>
        free(dummy_tail);
4200a568:	08ad      	mov.n	a10, a8
4200a56a:	d80081        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200a56d:	0008e0        	callx8	a8
    if (dummy_head) {
4200a570:	9188      	l32i.n	a8, a1, 36
4200a572:	688c      	beqz.n	a8, 4200a57c <esp_mmu_map+0x400>
        free(dummy_head);
4200a574:	08ad      	mov.n	a10, a8
4200a576:	d7fd81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200a579:	0008e0        	callx8	a8
    _lock_release(&s_mmu_ctx.mutex);
4200a57c:	d94ba1        	l32r	a10, 42000aa8 <_stext+0xa88> (3fc953ac <s_mmu_ctx+0x2c>)
4200a57f:	d88281        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
4200a582:	0008e0        	callx8	a8
}
4200a585:	6128      	l32i.n	a2, a1, 24
4200a587:	f01d      	retw.n
4200a589:	000000        	ill

4200a58c <esp_mmu_unmap>:
{
4200a58c:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(ptr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
4200a58f:	a2ec      	bnez.n	a2, 4200a5bd <esp_mmu_unmap+0x31>
4200a591:	d94071        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a594:	0768      	l32i.n	a6, a7, 0
4200a596:	d6b281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a599:	0008e0        	callx8	a8
4200a59c:	86a282        	movi	a8, 0x286
4200a59f:	0189      	s32i.n	a8, a1, 0
4200a5a1:	d94cf1        	l32r	a15, 42000ad4 <_stext+0xab4> (3c027750 <__FUNCTION__$2>)
4200a5a4:	07e8      	l32i.n	a14, a7, 0
4200a5a6:	0add      	mov.n	a13, a10
4200a5a8:	d93dc1        	l32r	a12, 42000a9c <_stext+0xa7c> (3c024e6c <_flash_rodata_start+0x4d4c>)
4200a5ab:	06bd      	mov.n	a11, a6
4200a5ad:	1a0c      	movi.n	a10, 1
4200a5af:	d6b981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a5b2:	0008e0        	callx8	a8
4200a5b5:	02a122        	movi	a2, 0x102
4200a5b8:	0043c6        	j	4200a6cb <esp_mmu_unmap+0x13f>
4200a5bb:	900000        	addx2	a0, a0, a0
    return vaddr & SOC_MMU_LINEAR_ADDR_MASK;
4200a5be:	201122        	l16ui	a2, a1, 64
4200a5c1:	a14127        	ball	a1, a2, 4200a566 <esp_mmu_map+0x3ea>
    _lock_acquire(&s_mmu_ctx.mutex);
4200a5c4:	d939      	s32i.n	a3, a9, 52
4200a5c6:	d86f81        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
4200a5c9:	0008e0        	callx8	a8
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
4200a5cc:	080c      	movi.n	a8, 0
    mem_region_t *region = NULL;
4200a5ce:	089d      	mov.n	a9, a8
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
4200a5d0:	0008c6        	j	4200a5f7 <esp_mmu_unmap+0x6b>
4200a5d3:	00          	.byte	00
        if (ptr_laddr >= s_mmu_ctx.mem_regions[i].free_head && ptr_laddr < s_mmu_ctx.mem_regions[i].end) {
4200a5d4:	a0a880        	addx4	a10, a8, a8
4200a5d7:	d92db1        	l32r	a11, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a5da:	b0aab0        	addx8	a10, a10, a11
4200a5dd:	5aa8      	l32i.n	a10, a10, 20
4200a5df:	1232a7        	bltu	a2, a10, 4200a5f5 <esp_mmu_unmap+0x69>
4200a5e2:	a0a880        	addx4	a10, a8, a8
4200a5e5:	b0aab0        	addx8	a10, a10, a11
4200a5e8:	3aa8      	l32i.n	a10, a10, 12
4200a5ea:	07b2a7        	bgeu	a2, a10, 4200a5f5 <esp_mmu_unmap+0x69>
            region = &s_mmu_ctx.mem_regions[i];
4200a5ed:	a09880        	addx4	a9, a8, a8
4200a5f0:	b099b0        	addx8	a9, a9, a11
4200a5f3:	994b      	addi.n	a9, a9, 4
    for (int i = 0; i < s_mmu_ctx.num_regions; i++) {
4200a5f5:	881b      	addi.n	a8, a8, 1
4200a5f7:	d925a1        	l32r	a10, 42000a8c <_stext+0xa6c> (3fc95380 <s_mmu_ctx>)
4200a5fa:	0aa8      	l32i.n	a10, a10, 0
4200a5fc:	d438a7        	bltu	a8, a10, 4200a5d4 <esp_mmu_unmap+0x48>
    ESP_GOTO_ON_FALSE(region, ESP_ERR_NOT_FOUND, err, TAG, "munmap target pointer is outside external memory regions");
4200a5ff:	59ec      	bnez.n	a9, 4200a628 <esp_mmu_unmap+0x9c>
4200a601:	d92471        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a604:	0768      	l32i.n	a6, a7, 0
4200a606:	d69681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a609:	0008e0        	callx8	a8
4200a60c:	96a282        	movi	a8, 0x296
4200a60f:	0189      	s32i.n	a8, a1, 0
4200a611:	d930f1        	l32r	a15, 42000ad4 <_stext+0xab4> (3c027750 <__FUNCTION__$2>)
4200a614:	07e8      	l32i.n	a14, a7, 0
4200a616:	0add      	mov.n	a13, a10
4200a618:	d930c1        	l32r	a12, 42000ad8 <_stext+0xab8> (3c025008 <_flash_rodata_start+0x4ee8>)
4200a61b:	06bd      	mov.n	a11, a6
4200a61d:	1a0c      	movi.n	a10, 1
4200a61f:	d69d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a622:	0008e0        	callx8	a8
4200a625:	002586        	j	4200a6bf <esp_mmu_unmap+0x133>
    TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
4200a628:	89a8      	l32i.n	a10, a9, 32
4200a62a:	0a7d      	mov.n	a7, a10
4200a62c:	000c06        	j	4200a660 <esp_mmu_unmap+0xd4>
4200a62f:	1a7700        	sub.s	f7, f7, f0
        if (mem_block == TAILQ_FIRST(&region->mem_block_head) || mem_block == TAILQ_LAST(&region->mem_block_head, mem_block_head_)) {
4200a632:	882a      	add.n	a8, a8, a2
4200a634:	8899      	s32i.n	a9, a8, 32
4200a636:	8818      	l32i.n	a1, a8, 32
4200a638:	7708      	l32i.n	a0, a7, 28
4200a63a:	2118      	l32i.n	a1, a1, 8
        if (mem_block->laddr_start == ptr_laddr) {
4200a63c:	0788      	l32i.n	a8, a7, 0
4200a63e:	1c9287        	bne	a2, a8, 4200a65e <esp_mmu_unmap+0xd2>
            slot_len = TAILQ_NEXT(mem_block, entries)->laddr_start - TAILQ_PREV(mem_block, mem_block_head_, entries)->laddr_end;
4200a641:	9788      	l32i.n	a8, a7, 36
4200a643:	0888      	l32i.n	a8, a8, 0
4200a645:	a7a8      	l32i.n	a10, a7, 40
4200a647:	1aa8      	l32i.n	a10, a10, 4
4200a649:	0aa8      	l32i.n	a10, a10, 0
4200a64b:	1aa8      	l32i.n	a10, a10, 4
4200a64d:	c088a0        	sub	a8, a8, a10
            region->max_slot_size = (slot_len > region->max_slot_size) ? slot_len : region->max_slot_size;
4200a650:	59a8      	l32i.n	a10, a9, 20
4200a652:	7388a0        	maxu	a8, a8, a10
4200a655:	5989      	s32i.n	a8, a9, 20
        TAILQ_REMOVE(&region->mem_block_head, found_block, entries);
4200a657:	9788      	l32i.n	a8, a7, 36
4200a659:	08fc      	bnez.n	a8, 4200a68d <esp_mmu_unmap+0x101>
4200a65b:	000d46        	j	4200a694 <esp_mmu_unmap+0x108>
    TAILQ_FOREACH(mem_block, &region->mem_block_head, entries) {
4200a65e:	9778      	l32i.n	a7, a7, 36
4200a660:	fcc756        	bnez	a7, 4200a630 <esp_mmu_unmap+0xa4>
    ESP_GOTO_ON_FALSE(found, ESP_ERR_NOT_FOUND, err, TAG, "munmap target pointer isn't mapped yet");
4200a663:	d90c71        	l32r	a7, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a666:	0768      	l32i.n	a6, a7, 0
4200a668:	d67e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a66b:	0008e0        	callx8	a8
4200a66e:	aea282        	movi	a8, 0x2ae
4200a671:	0189      	s32i.n	a8, a1, 0
4200a673:	d918f1        	l32r	a15, 42000ad4 <_stext+0xab4> (3c027750 <__FUNCTION__$2>)
4200a676:	07e8      	l32i.n	a14, a7, 0
4200a678:	0add      	mov.n	a13, a10
4200a67a:	d918c1        	l32r	a12, 42000adc <_stext+0xabc> (3c025058 <_flash_rodata_start+0x4f38>)
4200a67d:	06bd      	mov.n	a11, a6
4200a67f:	01a0a2        	movi	a10, 1
4200a682:	d68481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a685:	0008e0        	callx8	a8
4200a688:	000cc6        	j	4200a6bf <esp_mmu_unmap+0x133>
4200a68b:	00          	.byte	00
4200a68c:	a79800        	ee.stf.64.xp	f9, f10, a0, a8
        TAILQ_REMOVE(&region->mem_block_head, found_block, entries);
4200a68f:	a899      	s32i.n	a9, a8, 40
4200a691:	0000c6        	j	4200a698 <esp_mmu_unmap+0x10c>
4200a694:	a788      	l32i.n	a8, a7, 40
4200a696:	9989      	s32i.n	a8, a9, 36
4200a698:	a788      	l32i.n	a8, a7, 40
4200a69a:	9798      	l32i.n	a9, a7, 36
4200a69c:	0899      	s32i.n	a9, a8, 0
    s_do_unmapping(mem_block->vaddr_start, mem_block->size);
4200a69e:	47b8      	l32i.n	a11, a7, 16
4200a6a0:	27a8      	l32i.n	a10, a7, 8
4200a6a2:	d90f81        	l32r	a8, 42000ae0 <_stext+0xac0> (403776e4 <s_do_unmapping>)
4200a6a5:	0008e0        	callx8	a8
    free(found_block);
4200a6a8:	07ad      	mov.n	a10, a7
4200a6aa:	d7b081        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200a6ad:	0008e0        	callx8	a8
    _lock_release(&s_mmu_ctx.mutex);
4200a6b0:	d8fea1        	l32r	a10, 42000aa8 <_stext+0xa88> (3fc953ac <s_mmu_ctx+0x2c>)
4200a6b3:	d83581        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
4200a6b6:	0008e0        	callx8	a8
    return ESP_OK;
4200a6b9:	020c      	movi.n	a2, 0
4200a6bb:	000306        	j	4200a6cb <esp_mmu_unmap+0x13f>
4200a6be:	faa100        	mov.s	f10, f1
    _lock_release(&s_mmu_ctx.mutex);
4200a6c1:	81d8      	l32i.n	a13, a1, 32
4200a6c3:	e0d831        	l32r	a3, 42002a24 <esp_vApplicationIdleHook+0x2c> (8e0f681 <UserFrameTotalSize+0x8e0f581>)
4200a6c6:	0008      	l32i.n	a0, a0, 0
    return ret;
4200a6c8:	05a122        	movi	a2, 0x105
}
4200a6cb:	f01d      	retw.n
4200a6cd:	000000        	ill

4200a6d0 <esp_mmu_vaddr_to_paddr>:

esp_err_t esp_mmu_vaddr_to_paddr(void *vaddr, esp_paddr_t *out_paddr, mmu_target_t *out_target)
{
4200a6d0:	008136        	entry	a1, 64
    ESP_RETURN_ON_FALSE(vaddr && out_paddr, ESP_ERR_INVALID_ARG, TAG, "null pointer");
4200a6d3:	40f280        	nsau	a8, a2
4200a6d6:	418580        	srli	a8, a8, 5
4200a6d9:	40f390        	nsau	a9, a3
4200a6dc:	419590        	srli	a9, a9, 5
4200a6df:	208890        	or	a8, a8, a9
4200a6e2:	98ac      	beqz.n	a8, 4200a70f <esp_mmu_vaddr_to_paddr+0x3f>
4200a6e4:	d8ec41        	l32r	a4, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a6e7:	002432        	l32i	a3, a4, 0
4200a6ea:	d65d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a6ed:	0008e0        	callx8	a8
4200a6f0:	22a382        	movi	a8, 0x322
4200a6f3:	0189      	s32i.n	a8, a1, 0
4200a6f5:	d8fbf1        	l32r	a15, 42000ae4 <_stext+0xac4> (3c027738 <__FUNCTION__$1>)
4200a6f8:	04e8      	l32i.n	a14, a4, 0
4200a6fa:	0add      	mov.n	a13, a10
4200a6fc:	d8e8c1        	l32r	a12, 42000a9c <_stext+0xa7c> (3c024e6c <_flash_rodata_start+0x4d4c>)
4200a6ff:	03bd      	mov.n	a11, a3
4200a701:	1a0c      	movi.n	a10, 1
4200a703:	d66481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a706:	0008e0        	callx8	a8
4200a709:	02a122        	movi	a2, 0x102
4200a70c:	002206        	j	4200a798 <esp_mmu_vaddr_to_paddr+0xc8>
    ESP_RETURN_ON_FALSE(mmu_hal_check_valid_ext_vaddr_region(0, (uint32_t)vaddr, 1, MMU_VADDR_DATA | MMU_VADDR_INSTRUCTION), ESP_ERR_INVALID_ARG, TAG, "not a valid external virtual address");
4200a70f:	3d0c      	movi.n	a13, 3
4200a711:	1c0c      	movi.n	a12, 1
4200a713:	02bd      	mov.n	a11, a2
4200a715:	0a0c      	movi.n	a10, 0
4200a717:	d8f681        	l32r	a8, 42000af0 <_stext+0xad0> (4037ccf0 <mmu_hal_check_valid_ext_vaddr_region>)
4200a71a:	0008e0        	callx8	a8
4200a71d:	02ba56        	bnez	a10, 4200a74c <esp_mmu_vaddr_to_paddr+0x7c>
4200a720:	d8dd41        	l32r	a4, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a723:	002432        	l32i	a3, a4, 0
4200a726:	d64e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a729:	0008e0        	callx8	a8
4200a72c:	23a382        	movi	a8, 0x323
4200a72f:	0189      	s32i.n	a8, a1, 0
4200a731:	d8ecf1        	l32r	a15, 42000ae4 <_stext+0xac4> (3c027738 <__FUNCTION__$1>)
4200a734:	04e8      	l32i.n	a14, a4, 0
4200a736:	0add      	mov.n	a13, a10
4200a738:	d8ecc1        	l32r	a12, 42000ae8 <_stext+0xac8> (3c025094 <_flash_rodata_start+0x4f74>)
4200a73b:	03bd      	mov.n	a11, a3
4200a73d:	1a0c      	movi.n	a10, 1
4200a73f:	d65581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a742:	0008e0        	callx8	a8
4200a745:	02a122        	movi	a2, 0x102
4200a748:	001306        	j	4200a798 <esp_mmu_vaddr_to_paddr+0xc8>
4200a74b:	080c00        	lsx	f0, a12, a0

    esp_paddr_t paddr = 0;
4200a74e:	4189      	s32i.n	a8, a1, 16
    mmu_target_t target = 0;
4200a750:	5189      	s32i.n	a8, a1, 20

    bool is_mapped = s_vaddr_to_paddr((uint32_t)vaddr, &paddr, &target);
4200a752:	14c1c2        	addi	a12, a1, 20
4200a755:	10c1b2        	addi	a11, a1, 16
4200a758:	02ad      	mov.n	a10, a2
4200a75a:	d8e681        	l32r	a8, 42000af4 <_stext+0xad4> (403776fc <s_vaddr_to_paddr>)
4200a75d:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE(is_mapped, ESP_ERR_NOT_FOUND, TAG, "vaddr isn't mapped");
4200a760:	aaec      	bnez.n	a10, 4200a78e <esp_mmu_vaddr_to_paddr+0xbe>
4200a762:	d8cc41        	l32r	a4, 42000a94 <_stext+0xa74> (3fc9396c <TAG>)
4200a765:	0438      	l32i.n	a3, a4, 0
4200a767:	d63e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a76a:	0008e0        	callx8	a8
4200a76d:	29a382        	movi	a8, 0x329
4200a770:	0189      	s32i.n	a8, a1, 0
4200a772:	d8dcf1        	l32r	a15, 42000ae4 <_stext+0xac4> (3c027738 <__FUNCTION__$1>)
4200a775:	04e8      	l32i.n	a14, a4, 0
4200a777:	0add      	mov.n	a13, a10
4200a779:	d8dcc1        	l32r	a12, 42000aec <_stext+0xacc> (3c0250d0 <_flash_rodata_start+0x4fb0>)
4200a77c:	20b330        	or	a11, a3, a3
4200a77f:	01a0a2        	movi	a10, 1
4200a782:	d64481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a785:	0008e0        	callx8	a8
4200a788:	05a122        	movi	a2, 0x105
4200a78b:	000246        	j	4200a798 <esp_mmu_vaddr_to_paddr+0xc8>

    *out_paddr = paddr;
4200a78e:	4188      	l32i.n	a8, a1, 16
4200a790:	0389      	s32i.n	a8, a3, 0
    *out_target = target;
4200a792:	5188      	l32i.n	a8, a1, 20
4200a794:	0489      	s32i.n	a8, a4, 0

    return ESP_OK;
4200a796:	020c      	movi.n	a2, 0
}
4200a798:	f01d      	retw.n
	...

4200a79c <gpio_sleep_input_enable>:
    gpio_hal_sleep_input_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_sleep_input_enable(gpio_num_t gpio_num)
{
4200a79c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200a79f:	02d296        	bltz	a2, 4200a7d0 <gpio_sleep_input_enable+0x34>
4200a7a2:	0a2c      	movi.n	a10, 32
4200a7a4:	10a2a0        	and	a10, a2, a10
4200a7a7:	f87c      	movi.n	a8, -1
4200a7a9:	308280        	xor	a8, a2, a8
4200a7ac:	d78391        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200a7af:	401800        	ssl	a8
4200a7b2:	a19900        	sll	a9, a9
4200a7b5:	d78181        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200a7b8:	400200        	ssr	a2
4200a7bb:	918080        	srl	a8, a8
4200a7be:	208980        	or	a8, a9, a8
4200a7c1:	d77f91        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200a7c4:	400200        	ssr	a2
4200a7c7:	919090        	srl	a9, a9
4200a7ca:	9389a0        	movnez	a8, a9, a10
4200a7cd:	2be807        	bbsi	a8, 0, 4200a7fc <gpio_sleep_input_enable+0x60>
4200a7d0:	d62481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a7d3:	0008e0        	callx8	a8
4200a7d6:	d8c9b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200a7d9:	d8ca81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200a7dc:	1189      	s32i.n	a8, a1, 4
4200a7de:	89a382        	movi	a8, 0x389
4200a7e1:	0189      	s32i.n	a8, a1, 0
4200a7e3:	d8c5f1        	l32r	a15, 42000af8 <_stext+0xad8> (3c0278e0 <__FUNCTION__$13>)
4200a7e6:	0bed      	mov.n	a14, a11
4200a7e8:	0add      	mov.n	a13, a10
4200a7ea:	d8c5c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200a7ed:	1a0c      	movi.n	a10, 1
4200a7ef:	d62981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a7f2:	0008e0        	callx8	a8
4200a7f5:	02a122        	movi	a2, 0x102
4200a7f8:	000646        	j	4200a815 <gpio_sleep_input_enable+0x79>
4200a7fb:	c38100        	movf	a8, a1, b0
  * @param gpio_num GPIO number
  */
__attribute__((always_inline))
static inline void gpio_ll_sleep_input_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    PIN_SLP_INPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200a7fe:	80d8      	l32i.n	a13, a0, 32
4200a800:	98a022        	movi	a2, 152
4200a803:	20c002        	addi	a0, a0, 32
4200a806:	098800        	l32e	a0, a8, -32
4200a809:	0a1c      	movi.n	a10, 16
4200a80b:	2088a0        	or	a8, a8, a10
4200a80e:	0020c0        	memw
4200a811:	0989      	s32i.n	a8, a9, 0
    gpio_hal_sleep_input_enable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
4200a813:	020c      	movi.n	a2, 0
}
4200a815:	f01d      	retw.n
	...

4200a818 <gpio_sleep_input_disable>:
{
4200a818:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200a81b:	02d296        	bltz	a2, 4200a84c <gpio_sleep_input_disable+0x34>
4200a81e:	0a2c      	movi.n	a10, 32
4200a820:	10a2a0        	and	a10, a2, a10
4200a823:	f87c      	movi.n	a8, -1
4200a825:	308280        	xor	a8, a2, a8
4200a828:	d76491        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200a82b:	401800        	ssl	a8
4200a82e:	a19900        	sll	a9, a9
4200a831:	d76281        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200a834:	400200        	ssr	a2
4200a837:	918080        	srl	a8, a8
4200a83a:	208980        	or	a8, a9, a8
4200a83d:	d76091        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200a840:	400200        	ssr	a2
4200a843:	919090        	srl	a9, a9
4200a846:	9389a0        	movnez	a8, a9, a10
4200a849:	2ae807        	bbsi	a8, 0, 4200a877 <gpio_sleep_input_disable+0x5f>
4200a84c:	d60581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a84f:	0008e0        	callx8	a8
4200a852:	d8aab1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200a855:	d8ab81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200a858:	1189      	s32i.n	a8, a1, 4
4200a85a:	82a382        	movi	a8, 0x382
4200a85d:	0189      	s32i.n	a8, a1, 0
4200a85f:	d8abf1        	l32r	a15, 42000b0c <_stext+0xaec> (3c0278c4 <__FUNCTION__$12>)
4200a862:	0bed      	mov.n	a14, a11
4200a864:	0add      	mov.n	a13, a10
4200a866:	d8a6c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200a869:	1a0c      	movi.n	a10, 1
4200a86b:	d60a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a86e:	0008e0        	callx8	a8
4200a871:	02a122        	movi	a2, 0x102
4200a874:	000606        	j	4200a890 <gpio_sleep_input_disable+0x78>
    PIN_SLP_INPUT_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200a877:	d8a481        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200a87a:	a02280        	addx4	a2, a2, a8
4200a87d:	0298      	l32i.n	a9, a2, 0
4200a87f:	0020c0        	memw
4200a882:	0988      	l32i.n	a8, a9, 0
4200a884:	fa6c      	movi.n	a10, -17
4200a886:	1088a0        	and	a8, a8, a10
4200a889:	0020c0        	memw
4200a88c:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
4200a88e:	020c      	movi.n	a2, 0
}
4200a890:	f01d      	retw.n
	...

4200a894 <gpio_sleep_output_enable>:
    gpio_hal_sleep_output_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_sleep_output_enable(gpio_num_t gpio_num)
{
4200a894:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), "GPIO output gpio_num error", ESP_ERR_INVALID_ARG);
4200a897:	02d296        	bltz	a2, 4200a8c8 <gpio_sleep_output_enable+0x34>
4200a89a:	0a2c      	movi.n	a10, 32
4200a89c:	10a2a0        	and	a10, a2, a10
4200a89f:	f87c      	movi.n	a8, -1
4200a8a1:	308280        	xor	a8, a2, a8
4200a8a4:	d74591        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200a8a7:	401800        	ssl	a8
4200a8aa:	a19900        	sll	a9, a9
4200a8ad:	d74381        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200a8b0:	400200        	ssr	a2
4200a8b3:	918080        	srl	a8, a8
4200a8b6:	208980        	or	a8, a9, a8
4200a8b9:	d74191        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200a8bc:	400200        	ssr	a2
4200a8bf:	919090        	srl	a9, a9
4200a8c2:	9389a0        	movnez	a8, a9, a10
4200a8c5:	2be807        	bbsi	a8, 0, 4200a8f4 <gpio_sleep_output_enable+0x60>
4200a8c8:	d5e681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a8cb:	0008e0        	callx8	a8
4200a8ce:	d88bb1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200a8d1:	d89081        	l32r	a8, 42000b14 <_stext+0xaf4> (3c02512c <_flash_rodata_start+0x500c>)
4200a8d4:	1189      	s32i.n	a8, a1, 4
4200a8d6:	97a382        	movi	a8, 0x397
4200a8d9:	0189      	s32i.n	a8, a1, 0
4200a8db:	d88df1        	l32r	a15, 42000b10 <_stext+0xaf0> (3c0278a8 <__FUNCTION__$11>)
4200a8de:	0bed      	mov.n	a14, a11
4200a8e0:	0add      	mov.n	a13, a10
4200a8e2:	d887c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200a8e5:	1a0c      	movi.n	a10, 1
4200a8e7:	d5eb81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a8ea:	0008e0        	callx8	a8
4200a8ed:	02a122        	movi	a2, 0x102
4200a8f0:	000646        	j	4200a90d <gpio_sleep_output_enable+0x79>
4200a8f3:	858100        	extui	a8, a0, 17, 9
  * @param gpio_num GPIO number
  */
__attribute__((always_inline))
static inline void gpio_ll_sleep_output_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    PIN_SLP_OUTPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200a8f6:	80d8      	l32i.n	a13, a0, 32
4200a8f8:	98a022        	movi	a2, 152
4200a8fb:	20c002        	addi	a0, a0, 32
4200a8fe:	098800        	l32e	a0, a8, -32
4200a901:	1a0c      	movi.n	a10, 1
4200a903:	2088a0        	or	a8, a8, a10
4200a906:	0020c0        	memw
4200a909:	0989      	s32i.n	a8, a9, 0
    gpio_hal_sleep_output_enable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
4200a90b:	020c      	movi.n	a2, 0
}
4200a90d:	f01d      	retw.n
	...

4200a910 <gpio_sleep_output_disable>:
{
4200a910:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200a913:	02d296        	bltz	a2, 4200a944 <gpio_sleep_output_disable+0x34>
4200a916:	0a2c      	movi.n	a10, 32
4200a918:	10a2a0        	and	a10, a2, a10
4200a91b:	f87c      	movi.n	a8, -1
4200a91d:	308280        	xor	a8, a2, a8
4200a920:	d72691        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200a923:	401800        	ssl	a8
4200a926:	a19900        	sll	a9, a9
4200a929:	d72481        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200a92c:	400200        	ssr	a2
4200a92f:	918080        	srl	a8, a8
4200a932:	208980        	or	a8, a9, a8
4200a935:	d72291        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200a938:	400200        	ssr	a2
4200a93b:	919090        	srl	a9, a9
4200a93e:	9389a0        	movnez	a8, a9, a10
4200a941:	2be807        	bbsi	a8, 0, 4200a970 <gpio_sleep_output_disable+0x60>
4200a944:	d5c781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a947:	0008e0        	callx8	a8
4200a94a:	d86cb1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200a94d:	d86d81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200a950:	1189      	s32i.n	a8, a1, 4
4200a952:	90a382        	movi	a8, 0x390
4200a955:	0189      	s32i.n	a8, a1, 0
4200a957:	d870f1        	l32r	a15, 42000b18 <_stext+0xaf8> (3c02788c <__FUNCTION__$10>)
4200a95a:	0bed      	mov.n	a14, a11
4200a95c:	0add      	mov.n	a13, a10
4200a95e:	d868c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200a961:	1a0c      	movi.n	a10, 1
4200a963:	d5cc81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a966:	0008e0        	callx8	a8
4200a969:	02a122        	movi	a2, 0x102
4200a96c:	000646        	j	4200a989 <gpio_sleep_output_disable+0x79>
4200a96f:	668100        	ee.ldf.64.xp	f8, f6, a0, a1
    PIN_SLP_OUTPUT_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200a972:	80d8      	l32i.n	a13, a0, 32
4200a974:	98a022        	movi	a2, 152
4200a977:	20c002        	addi	a0, a0, 32
4200a97a:	098800        	l32e	a0, a8, -32
4200a97d:	ea7c      	movi.n	a10, -2
4200a97f:	1088a0        	and	a8, a8, a10
4200a982:	0020c0        	memw
4200a985:	0989      	s32i.n	a8, a9, 0
    return ESP_OK;
4200a987:	020c      	movi.n	a2, 0
}
4200a989:	f01d      	retw.n
	...

4200a98c <gpio_sleep_pulldown_en>:
{
4200a98c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200a98f:	02d296        	bltz	a2, 4200a9c0 <gpio_sleep_pulldown_en+0x34>
4200a992:	0a2c      	movi.n	a10, 32
4200a994:	10a2a0        	and	a10, a2, a10
4200a997:	f87c      	movi.n	a8, -1
4200a999:	308280        	xor	a8, a2, a8
4200a99c:	d70791        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200a99f:	401800        	ssl	a8
4200a9a2:	a19900        	sll	a9, a9
4200a9a5:	d70581        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200a9a8:	400200        	ssr	a2
4200a9ab:	918080        	srl	a8, a8
4200a9ae:	208980        	or	a8, a9, a8
4200a9b1:	d70391        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200a9b4:	400200        	ssr	a2
4200a9b7:	919090        	srl	a9, a9
4200a9ba:	9389a0        	movnez	a8, a9, a10
4200a9bd:	2ce807        	bbsi	a8, 0, 4200a9ed <gpio_sleep_pulldown_en+0x61>
4200a9c0:	d5a881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200a9c3:	0008e0        	callx8	a8
4200a9c6:	d84db1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200a9c9:	d84e81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200a9cc:	1189      	s32i.n	a8, a1, 4
4200a9ce:	6ca382        	movi	a8, 0x36c
4200a9d1:	0189      	s32i.n	a8, a1, 0
4200a9d3:	d852f1        	l32r	a15, 42000b1c <_stext+0xafc> (3c027858 <__FUNCTION__$8>)
4200a9d6:	0bed      	mov.n	a14, a11
4200a9d8:	0add      	mov.n	a13, a10
4200a9da:	d849c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200a9dd:	1a0c      	movi.n	a10, 1
4200a9df:	d5ad81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200a9e2:	0008e0        	callx8	a8
4200a9e5:	02a122        	movi	a2, 0x102
4200a9e8:	000b86        	j	4200aa1a <gpio_sleep_pulldown_en+0x8e>
4200a9eb:	00          	.byte	00
4200a9ec:	00          	.byte	00
4200a9ed:	fb7c      	movi.n	a11, -1
4200a9ef:	d84ca1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200a9f2:	d68f81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200a9f5:	0008e0        	callx8	a8
    PIN_SLP_PULLDOWN_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200a9f8:	d84481        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200a9fb:	a02280        	addx4	a2, a2, a8
4200a9fe:	0298      	l32i.n	a9, a2, 0
4200aa00:	0020c0        	memw
4200aa03:	0988      	l32i.n	a8, a9, 0
4200aa05:	4a0c      	movi.n	a10, 4
4200aa07:	2088a0        	or	a8, a8, a10
4200aa0a:	0020c0        	memw
4200aa0d:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
4200aa0f:	d844a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200aa12:	d68881        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200aa15:	0008e0        	callx8	a8
    return ESP_OK;
4200aa18:	020c      	movi.n	a2, 0
}
4200aa1a:	f01d      	retw.n

4200aa1c <gpio_sleep_pullup_en>:
{
4200aa1c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200aa1f:	02d296        	bltz	a2, 4200aa50 <gpio_sleep_pullup_en+0x34>
4200aa22:	0a2c      	movi.n	a10, 32
4200aa24:	10a2a0        	and	a10, a2, a10
4200aa27:	f87c      	movi.n	a8, -1
4200aa29:	308280        	xor	a8, a2, a8
4200aa2c:	d6e391        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200aa2f:	401800        	ssl	a8
4200aa32:	a19900        	sll	a9, a9
4200aa35:	d6e181        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200aa38:	400200        	ssr	a2
4200aa3b:	918080        	srl	a8, a8
4200aa3e:	208980        	or	a8, a9, a8
4200aa41:	d6df91        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200aa44:	400200        	ssr	a2
4200aa47:	919090        	srl	a9, a9
4200aa4a:	9389a0        	movnez	a8, a9, a10
4200aa4d:	2ce807        	bbsi	a8, 0, 4200aa7d <gpio_sleep_pullup_en+0x61>
4200aa50:	d58481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200aa53:	0008e0        	callx8	a8
4200aa56:	d829b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200aa59:	d82a81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200aa5c:	1189      	s32i.n	a8, a1, 4
4200aa5e:	56a382        	movi	a8, 0x356
4200aa61:	0189      	s32i.n	a8, a1, 0
4200aa63:	d830f1        	l32r	a15, 42000b24 <_stext+0xb04> (3c027840 <__FUNCTION__$7>)
4200aa66:	0bed      	mov.n	a14, a11
4200aa68:	0add      	mov.n	a13, a10
4200aa6a:	d825c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200aa6d:	1a0c      	movi.n	a10, 1
4200aa6f:	d58981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200aa72:	0008e0        	callx8	a8
4200aa75:	02a122        	movi	a2, 0x102
4200aa78:	000b86        	j	4200aaaa <gpio_sleep_pullup_en+0x8e>
4200aa7b:	00          	.byte	00
4200aa7c:	00          	.byte	00
4200aa7d:	fb7c      	movi.n	a11, -1
4200aa7f:	d828a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200aa82:	d66b81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200aa85:	0008e0        	callx8	a8
    PIN_SLP_PULLUP_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200aa88:	d82081        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200aa8b:	a02280        	addx4	a2, a2, a8
4200aa8e:	0298      	l32i.n	a9, a2, 0
4200aa90:	0020c0        	memw
4200aa93:	0988      	l32i.n	a8, a9, 0
4200aa95:	8a0c      	movi.n	a10, 8
4200aa97:	2088a0        	or	a8, a8, a10
4200aa9a:	0020c0        	memw
4200aa9d:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
4200aa9f:	d820a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200aaa2:	d66481        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200aaa5:	0008e0        	callx8	a8
    return ESP_OK;
4200aaa8:	020c      	movi.n	a2, 0
}
4200aaaa:	f01d      	retw.n

4200aaac <gpio_sleep_pulldown_dis>:
{
4200aaac:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200aaaf:	02d296        	bltz	a2, 4200aae0 <gpio_sleep_pulldown_dis+0x34>
4200aab2:	0a2c      	movi.n	a10, 32
4200aab4:	10a2a0        	and	a10, a2, a10
4200aab7:	f87c      	movi.n	a8, -1
4200aab9:	308280        	xor	a8, a2, a8
4200aabc:	d6bf91        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200aabf:	401800        	ssl	a8
4200aac2:	a19900        	sll	a9, a9
4200aac5:	d6bd81        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200aac8:	400200        	ssr	a2
4200aacb:	918080        	srl	a8, a8
4200aace:	208980        	or	a8, a9, a8
4200aad1:	d6bb91        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200aad4:	400200        	ssr	a2
4200aad7:	919090        	srl	a9, a9
4200aada:	9389a0        	movnez	a8, a9, a10
4200aadd:	2ce807        	bbsi	a8, 0, 4200ab0d <gpio_sleep_pulldown_dis+0x61>
4200aae0:	d56081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200aae3:	0008e0        	callx8	a8
4200aae6:	d805b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200aae9:	d80681        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200aaec:	1189      	s32i.n	a8, a1, 4
4200aaee:	77a382        	movi	a8, 0x377
4200aaf1:	0189      	s32i.n	a8, a1, 0
4200aaf3:	d80df1        	l32r	a15, 42000b28 <_stext+0xb08> (3c027828 <__FUNCTION__$6>)
4200aaf6:	0bed      	mov.n	a14, a11
4200aaf8:	0add      	mov.n	a13, a10
4200aafa:	d801c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200aafd:	1a0c      	movi.n	a10, 1
4200aaff:	d56581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ab02:	0008e0        	callx8	a8
4200ab05:	02a122        	movi	a2, 0x102
4200ab08:	000b86        	j	4200ab3a <gpio_sleep_pulldown_dis+0x8e>
4200ab0b:	00          	.byte	00
4200ab0c:	00          	.byte	00
4200ab0d:	fb7c      	movi.n	a11, -1
4200ab0f:	d804a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200ab12:	d64781        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200ab15:	0008e0        	callx8	a8
    PIN_SLP_PULLDOWN_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200ab18:	d7fc81        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200ab1b:	a02280        	addx4	a2, a2, a8
4200ab1e:	0298      	l32i.n	a9, a2, 0
4200ab20:	0020c0        	memw
4200ab23:	0988      	l32i.n	a8, a9, 0
4200ab25:	ba7c      	movi.n	a10, -5
4200ab27:	1088a0        	and	a8, a8, a10
4200ab2a:	0020c0        	memw
4200ab2d:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
4200ab2f:	d7fca1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200ab32:	d64081        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200ab35:	0008e0        	callx8	a8
    return ESP_OK;
4200ab38:	020c      	movi.n	a2, 0
}
4200ab3a:	f01d      	retw.n

4200ab3c <gpio_sleep_pullup_dis>:
{
4200ab3c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200ab3f:	02d296        	bltz	a2, 4200ab70 <gpio_sleep_pullup_dis+0x34>
4200ab42:	0a2c      	movi.n	a10, 32
4200ab44:	10a2a0        	and	a10, a2, a10
4200ab47:	f87c      	movi.n	a8, -1
4200ab49:	308280        	xor	a8, a2, a8
4200ab4c:	d69b91        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200ab4f:	401800        	ssl	a8
4200ab52:	a19900        	sll	a9, a9
4200ab55:	d69981        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200ab58:	400200        	ssr	a2
4200ab5b:	918080        	srl	a8, a8
4200ab5e:	208980        	or	a8, a9, a8
4200ab61:	d69791        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200ab64:	400200        	ssr	a2
4200ab67:	919090        	srl	a9, a9
4200ab6a:	9389a0        	movnez	a8, a9, a10
4200ab6d:	2ce807        	bbsi	a8, 0, 4200ab9d <gpio_sleep_pullup_dis+0x61>
4200ab70:	d53c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ab73:	0008e0        	callx8	a8
4200ab76:	d7e1b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200ab79:	d7e281        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200ab7c:	1189      	s32i.n	a8, a1, 4
4200ab7e:	61a382        	movi	a8, 0x361
4200ab81:	0189      	s32i.n	a8, a1, 0
4200ab83:	d7eaf1        	l32r	a15, 42000b2c <_stext+0xb0c> (3c027810 <__FUNCTION__$5>)
4200ab86:	0bed      	mov.n	a14, a11
4200ab88:	0add      	mov.n	a13, a10
4200ab8a:	d7ddc1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200ab8d:	1a0c      	movi.n	a10, 1
4200ab8f:	d54181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ab92:	0008e0        	callx8	a8
4200ab95:	02a122        	movi	a2, 0x102
4200ab98:	000b86        	j	4200abca <gpio_sleep_pullup_dis+0x8e>
4200ab9b:	00          	.byte	00
4200ab9c:	00          	.byte	00
4200ab9d:	fb7c      	movi.n	a11, -1
4200ab9f:	d7e0a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200aba2:	d62381        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200aba5:	0008e0        	callx8	a8
    PIN_SLP_PULLUP_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200aba8:	d7d881        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200abab:	a02280        	addx4	a2, a2, a8
4200abae:	0298      	l32i.n	a9, a2, 0
4200abb0:	0020c0        	memw
4200abb3:	0988      	l32i.n	a8, a9, 0
4200abb5:	7a7c      	movi.n	a10, -9
4200abb7:	1088a0        	and	a8, a8, a10
4200abba:	0020c0        	memw
4200abbd:	0989      	s32i.n	a8, a9, 0
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
4200abbf:	d7d8a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200abc2:	d61c81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200abc5:	0008e0        	callx8	a8
    return ESP_OK;
4200abc8:	020c      	movi.n	a2, 0
}
4200abca:	f01d      	retw.n

4200abcc <gpio_sleep_set_direction>:

esp_err_t gpio_sleep_set_direction(gpio_num_t gpio_num, gpio_mode_t mode)
{
4200abcc:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200abcf:	02d296        	bltz	a2, 4200ac00 <gpio_sleep_set_direction+0x34>
4200abd2:	0a2c      	movi.n	a10, 32
4200abd4:	10a2a0        	and	a10, a2, a10
4200abd7:	f87c      	movi.n	a8, -1
4200abd9:	308280        	xor	a8, a2, a8
4200abdc:	d67791        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200abdf:	401800        	ssl	a8
4200abe2:	a19900        	sll	a9, a9
4200abe5:	d67581        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200abe8:	400200        	ssr	a2
4200abeb:	918080        	srl	a8, a8
4200abee:	208980        	or	a8, a9, a8
4200abf1:	d67391        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200abf4:	400200        	ssr	a2
4200abf7:	919090        	srl	a9, a9
4200abfa:	9389a0        	movnez	a8, a9, a10
4200abfd:	2ce807        	bbsi	a8, 0, 4200ac2d <gpio_sleep_set_direction+0x61>
4200ac00:	d51881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ac03:	0008e0        	callx8	a8
4200ac06:	d7bdb1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200ac09:	d7be81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200ac0c:	1189      	s32i.n	a8, a1, 4
4200ac0e:	9ea382        	movi	a8, 0x39e
4200ac11:	0189      	s32i.n	a8, a1, 0
4200ac13:	d7c7f1        	l32r	a15, 42000b30 <_stext+0xb10> (3c0278f8 <__FUNCTION__$14>)
4200ac16:	0bed      	mov.n	a14, a11
4200ac18:	0add      	mov.n	a13, a10
4200ac1a:	d7b9c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200ac1d:	1a0c      	movi.n	a10, 1
4200ac1f:	d51d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ac22:	0008e0        	callx8	a8
4200ac25:	02a122        	movi	a2, 0x102
4200ac28:	000a86        	j	4200ac56 <gpio_sleep_set_direction+0x8a>
4200ac2b:	070000        	ee.stf.64.xp	f0, f0, a0, a0
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t ret = ESP_OK;

    if (mode & GPIO_MODE_DEF_INPUT) {
4200ac2e:	ad0863        	lsi	f6, a8, 0x2b4
        gpio_sleep_input_enable(gpio_num);
4200ac31:	b6a502        	movi	a0, 0x5b6
4200ac34:	000186ff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 96, q6, q0, q0, q1
4200ac38:	a22000        	muluh	a2, a0, a0
    } else {
        gpio_sleep_input_disable(gpio_num);
4200ac3b:	20          	.byte	0x20
4200ac3c:	ffbda5        	call8	4200a818 <gpio_sleep_input_disable>
    }

    if (mode & GPIO_MODE_DEF_OUTPUT) {
4200ac3f:	0a6317        	bbci	a3, 1, 4200ac4d <gpio_sleep_set_direction+0x81>
        gpio_sleep_output_enable(gpio_num);
4200ac42:	20a220        	or	a10, a2, a2
4200ac45:	ffc4e5        	call8	4200a894 <gpio_sleep_output_enable>
    } else {
        gpio_sleep_output_disable(gpio_num);
    }

    return ret;
4200ac48:	020c      	movi.n	a2, 0
4200ac4a:	000206        	j	4200ac56 <gpio_sleep_set_direction+0x8a>
        gpio_sleep_output_disable(gpio_num);
4200ac4d:	20a220        	or	a10, a2, a2
4200ac50:	ffcbe5        	call8	4200a910 <gpio_sleep_output_disable>
    return ret;
4200ac53:	00a022        	movi	a2, 0
}
4200ac56:	000090        	retw
4200ac59:	000000        	ill

4200ac5c <gpio_sleep_set_pull_mode>:

esp_err_t gpio_sleep_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
4200ac5c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200ac5f:	02d296        	bltz	a2, 4200ac90 <gpio_sleep_set_pull_mode+0x34>
4200ac62:	0a2c      	movi.n	a10, 32
4200ac64:	10a2a0        	and	a10, a2, a10
4200ac67:	f87c      	movi.n	a8, -1
4200ac69:	308280        	xor	a8, a2, a8
4200ac6c:	d65391        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200ac6f:	401800        	ssl	a8
4200ac72:	a19900        	sll	a9, a9
4200ac75:	d65181        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200ac78:	400200        	ssr	a2
4200ac7b:	918080        	srl	a8, a8
4200ac7e:	208980        	or	a8, a9, a8
4200ac81:	d64f91        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200ac84:	400200        	ssr	a2
4200ac87:	919090        	srl	a9, a9
4200ac8a:	9389a0        	movnez	a8, a9, a10
4200ac8d:	2be807        	bbsi	a8, 0, 4200acbc <gpio_sleep_set_pull_mode+0x60>
4200ac90:	d4f481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ac93:	0008e0        	callx8	a8
4200ac96:	d799b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200ac99:	d79a81        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200ac9c:	1189      	s32i.n	a8, a1, 4
4200ac9e:	b8a382        	movi	a8, 0x3b8
4200aca1:	0189      	s32i.n	a8, a1, 0
4200aca3:	d7a4f1        	l32r	a15, 42000b34 <_stext+0xb14> (3c027870 <__FUNCTION__$9>)
4200aca6:	0bed      	mov.n	a14, a11
4200aca8:	0add      	mov.n	a13, a10
4200acaa:	d795c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200acad:	1a0c      	movi.n	a10, 1
4200acaf:	d4f981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200acb2:	0008e0        	callx8	a8
4200acb5:	02a122        	movi	a2, 0x102
4200acb8:	002ac6        	j	4200ad67 <gpio_sleep_set_pull_mode+0x10b>
4200acbb:	43b600        	min	a11, a6, a0
    GPIO_CHECK(pull <= GPIO_FLOATING, "GPIO pull mode error", ESP_ERR_INVALID_ARG);
4200acbe:	812c      	movi.n	a1, 40
4200acc0:	d4e8      	l32i.n	a14, a4, 52
4200acc2:	0008e0        	callx8	a8
4200acc5:	d78db1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200acc8:	d79c81        	l32r	a8, 42000b38 <_stext+0xb18> (3c025148 <_flash_rodata_start+0x5028>)
4200accb:	1189      	s32i.n	a8, a1, 4
4200accd:	b9a382        	movi	a8, 0x3b9
4200acd0:	0189      	s32i.n	a8, a1, 0
4200acd2:	d798f1        	l32r	a15, 42000b34 <_stext+0xb14> (3c027870 <__FUNCTION__$9>)
4200acd5:	0bed      	mov.n	a14, a11
4200acd7:	0add      	mov.n	a13, a10
4200acd9:	d789c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200acdc:	1a0c      	movi.n	a10, 1
4200acde:	d4ed81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ace1:	0008e0        	callx8	a8
4200ace4:	02a122        	movi	a2, 0x102
4200ace7:	001f06        	j	4200ad67 <gpio_sleep_set_pull_mode+0x10b>
4200acea:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
    esp_err_t ret = ESP_OK;

    switch (pull) {
4200aced:	23          	.byte	0x23
4200acee:	33f635        	call12	4203ec50 <_etext+0x2551a>
4200acf1:	8c09      	s32i.n	a0, a12, 32
4200acf3:	c3          	.byte	0xc3
4200acf4:	1c1326        	beqi	a3, 1, 4200ad14 <gpio_sleep_set_pull_mode+0xb8>
4200acf7:	001306        	j	4200ad47 <gpio_sleep_set_pull_mode+0xeb>
4200acfa:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
4200acfd:	33          	.byte	0x33
4200acfe:	110636        	entry	a6, 0x880
4200ad01:	a22000        	muluh	a2, a0, a0
    case GPIO_PULLUP_ONLY:
        gpio_sleep_pulldown_dis(gpio_num);
4200ad04:	da6520        	ufloat.s	f6, a5, 2
4200ad07:	20a220ff 	ee.vmulas.s8.accx.ld.ip.qup	q0, a15, 0, q4, q5, q2, q2
        gpio_sleep_pullup_en(gpio_num);
4200ad0b:	ffd125        	call8	4200aa1c <gpio_sleep_pullup_en>
    esp_err_t ret = ESP_OK;
4200ad0e:	020c      	movi.n	a2, 0
        break;
4200ad10:	0014c6        	j	4200ad67 <gpio_sleep_set_pull_mode+0x10b>
4200ad13:	a22000        	muluh	a2, a0, a0

    case GPIO_PULLDOWN_ONLY:
        gpio_sleep_pulldown_en(gpio_num);
4200ad16:	c76520        	ee.stf.64.xp	f6, f12, a2, a5
4200ad19:	20a220ff 	ee.vmulas.s8.accx.ld.ip.qup	q0, a15, 0, q4, q5, q2, q2
        gpio_sleep_pullup_dis(gpio_num);
4200ad1d:	ffe1e5        	call8	4200ab3c <gpio_sleep_pullup_dis>
    esp_err_t ret = ESP_OK;
4200ad20:	020c      	movi.n	a2, 0
        break;
4200ad22:	001046        	j	4200ad67 <gpio_sleep_set_pull_mode+0x10b>

    case GPIO_PULLUP_PULLDOWN:
        gpio_sleep_pulldown_en(gpio_num);
4200ad25:	20a220        	or	a10, a2, a2
4200ad28:	ffc625        	call8	4200a98c <gpio_sleep_pulldown_en>
        gpio_sleep_pullup_en(gpio_num);
4200ad2b:	20a220        	or	a10, a2, a2
4200ad2e:	ffcee5        	call8	4200aa1c <gpio_sleep_pullup_en>
    esp_err_t ret = ESP_OK;
4200ad31:	020c      	movi.n	a2, 0
        break;
4200ad33:	000c06        	j	4200ad67 <gpio_sleep_set_pull_mode+0x10b>

    case GPIO_FLOATING:
        gpio_sleep_pulldown_dis(gpio_num);
4200ad36:	20a220        	or	a10, a2, a2
4200ad39:	ffd725        	call8	4200aaac <gpio_sleep_pulldown_dis>
        gpio_sleep_pullup_dis(gpio_num);
4200ad3c:	20a220        	or	a10, a2, a2
4200ad3f:	ffdfe5        	call8	4200ab3c <gpio_sleep_pullup_dis>
    esp_err_t ret = ESP_OK;
4200ad42:	020c      	movi.n	a2, 0
        break;
4200ad44:	0007c6        	j	4200ad67 <gpio_sleep_set_pull_mode+0x10b>

    default:
        ESP_LOGE(GPIO_TAG, "Unknown pull up/down mode,gpio_num=%u,pull=%u", gpio_num, pull);
4200ad47:	d4c681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ad4a:	0008e0        	callx8	a8
4200ad4d:	d76bb1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200ad50:	0139      	s32i.n	a3, a1, 0
4200ad52:	02fd      	mov.n	a15, a2
4200ad54:	0bed      	mov.n	a14, a11
4200ad56:	0add      	mov.n	a13, a10
4200ad58:	d779c1        	l32r	a12, 42000b3c <_stext+0xb1c> (3c025160 <_flash_rodata_start+0x5040>)
4200ad5b:	01a0a2        	movi	a10, 1
4200ad5e:	d4cd81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ad61:	0008e0        	callx8	a8
        ret = ESP_ERR_INVALID_ARG;
4200ad64:	02a122        	movi	a2, 0x102
        break;
    }

    return ret;
}
4200ad67:	f01d      	retw.n
4200ad69:	000000        	ill

4200ad6c <gpio_sleep_sel_en>:

esp_err_t gpio_sleep_sel_en(gpio_num_t gpio_num)
{
4200ad6c:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200ad6f:	02d296        	bltz	a2, 4200ada0 <gpio_sleep_sel_en+0x34>
4200ad72:	0a2c      	movi.n	a10, 32
4200ad74:	10a2a0        	and	a10, a2, a10
4200ad77:	f87c      	movi.n	a8, -1
4200ad79:	308280        	xor	a8, a2, a8
4200ad7c:	d60f91        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200ad7f:	401800        	ssl	a8
4200ad82:	a19900        	sll	a9, a9
4200ad85:	d60d81        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200ad88:	400200        	ssr	a2
4200ad8b:	918080        	srl	a8, a8
4200ad8e:	208980        	or	a8, a9, a8
4200ad91:	d60b91        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200ad94:	400200        	ssr	a2
4200ad97:	919090        	srl	a9, a9
4200ad9a:	9389a0        	movnez	a8, a9, a10
4200ad9d:	2ae807        	bbsi	a8, 0, 4200adcb <gpio_sleep_sel_en+0x5f>
4200ada0:	d4b081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ada3:	0008e0        	callx8	a8
4200ada6:	d755b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200ada9:	d75681        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200adac:	1189      	s32i.n	a8, a1, 4
4200adae:	dca382        	movi	a8, 0x3dc
4200adb1:	0189      	s32i.n	a8, a1, 0
4200adb3:	d763f1        	l32r	a15, 42000b40 <_stext+0xb20> (3c0277fc <__FUNCTION__$4>)
4200adb6:	0bed      	mov.n	a14, a11
4200adb8:	0add      	mov.n	a13, a10
4200adba:	d751c1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200adbd:	1a0c      	movi.n	a10, 1
4200adbf:	d4b581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200adc2:	0008e0        	callx8	a8
4200adc5:	02a122        	movi	a2, 0x102
4200adc8:	000b06        	j	4200adf8 <gpio_sleep_sel_en+0x8c>
4200adcb:	fb7c      	movi.n	a11, -1
4200adcd:	d754a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200add0:	d59881        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200add3:	0008e0        	callx8	a8
    PIN_SLP_SEL_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200add6:	d74c81        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200add9:	a02280        	addx4	a2, a2, a8
4200addc:	0298      	l32i.n	a9, a2, 0
4200adde:	0020c0        	memw
4200ade1:	0988      	l32i.n	a8, a9, 0
4200ade3:	2a0c      	movi.n	a10, 2
4200ade5:	2088a0        	or	a8, a8, a10
4200ade8:	0020c0        	memw
4200adeb:	0989      	s32i.n	a8, a9, 0

    portENTER_CRITICAL(&gpio_context.gpio_spinlock);
    gpio_hal_sleep_sel_en(gpio_context.gpio_hal, gpio_num);
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
4200aded:	d74ca1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200adf0:	d59181        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200adf3:	0008e0        	callx8	a8

    return ESP_OK;
4200adf6:	020c      	movi.n	a2, 0
}
4200adf8:	f01d      	retw.n
	...

4200adfc <gpio_sleep_sel_dis>:

esp_err_t gpio_sleep_sel_dis(gpio_num_t gpio_num)
{
4200adfc:	006136        	entry	a1, 48
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200adff:	02d296        	bltz	a2, 4200ae30 <gpio_sleep_sel_dis+0x34>
4200ae02:	0a2c      	movi.n	a10, 32
4200ae04:	10a2a0        	and	a10, a2, a10
4200ae07:	f87c      	movi.n	a8, -1
4200ae09:	308280        	xor	a8, a2, a8
4200ae0c:	d5eb91        	l32r	a9, 420005b8 <_stext+0x598> (3fffe <UserFrameTotalSize+0x3fefe>)
4200ae0f:	401800        	ssl	a8
4200ae12:	a19900        	sll	a9, a9
4200ae15:	d5e981        	l32r	a8, 420005bc <_stext+0x59c> (fc3fffff <_rtc_reserved_end+0x9c2fffff>)
4200ae18:	400200        	ssr	a2
4200ae1b:	918080        	srl	a8, a8
4200ae1e:	208980        	or	a8, a9, a8
4200ae21:	d5e791        	l32r	a9, 420005c0 <_stext+0x5a0> (1ffff <UserFrameTotalSize+0x1feff>)
4200ae24:	400200        	ssr	a2
4200ae27:	919090        	srl	a9, a9
4200ae2a:	9389a0        	movnez	a8, a9, a10
4200ae2d:	2ce807        	bbsi	a8, 0, 4200ae5d <gpio_sleep_sel_dis+0x61>
4200ae30:	d48c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ae33:	0008e0        	callx8	a8
4200ae36:	d731b1        	l32r	a11, 42000afc <_stext+0xadc> (3c0250f8 <_flash_rodata_start+0x4fd8>)
4200ae39:	d73281        	l32r	a8, 42000b04 <_stext+0xae4> (3c025118 <_flash_rodata_start+0x4ff8>)
4200ae3c:	1189      	s32i.n	a8, a1, 4
4200ae3e:	e7a382        	movi	a8, 0x3e7
4200ae41:	0189      	s32i.n	a8, a1, 0
4200ae43:	d740f1        	l32r	a15, 42000b44 <_stext+0xb24> (3c0277e8 <__FUNCTION__$3>)
4200ae46:	0bed      	mov.n	a14, a11
4200ae48:	0add      	mov.n	a13, a10
4200ae4a:	d72dc1        	l32r	a12, 42000b00 <_stext+0xae0> (3c025100 <_flash_rodata_start+0x4fe0>)
4200ae4d:	1a0c      	movi.n	a10, 1
4200ae4f:	d49181        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ae52:	0008e0        	callx8	a8
4200ae55:	02a122        	movi	a2, 0x102
4200ae58:	000b86        	j	4200ae8a <gpio_sleep_sel_dis+0x8e>
4200ae5b:	00          	.byte	00
4200ae5c:	00          	.byte	00
4200ae5d:	fb7c      	movi.n	a11, -1
4200ae5f:	d730a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200ae62:	d57381        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200ae65:	0008e0        	callx8	a8
    PIN_SLP_SEL_DISABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200ae68:	d72881        	l32r	a8, 42000b08 <_stext+0xae8> (3c027d98 <GPIO_PIN_MUX_REG>)
4200ae6b:	a02280        	addx4	a2, a2, a8
4200ae6e:	0298      	l32i.n	a9, a2, 0
4200ae70:	0020c0        	memw
4200ae73:	0988      	l32i.n	a8, a9, 0
4200ae75:	da7c      	movi.n	a10, -3
4200ae77:	1088a0        	and	a8, a8, a10
4200ae7a:	0020c0        	memw
4200ae7d:	0989      	s32i.n	a8, a9, 0

    portENTER_CRITICAL(&gpio_context.gpio_spinlock);
    gpio_hal_sleep_sel_dis(gpio_context.gpio_hal, gpio_num);
    portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
4200ae7f:	d728a1        	l32r	a10, 42000b20 <_stext+0xb00> (3fc929f4 <gpio_context+0x4>)
4200ae82:	d56c81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200ae85:	0008e0        	callx8	a8

    return ESP_OK;
4200ae88:	020c      	movi.n	a2, 0
}
4200ae8a:	f01d      	retw.n

4200ae8c <spi_flash_init_lock>:
{
4200ae8c:	004136        	entry	a1, 32
    s_flash_op_mutex = xSemaphoreCreateRecursiveMutex();
4200ae8f:	04a0a2        	movi	a10, 4
4200ae92:	d73181        	l32r	a8, 42000b58 <_stext+0xb38> (40379b6c <xQueueCreateMutex>)
4200ae95:	0008e0        	callx8	a8
4200ae98:	d72c81        	l32r	a8, 42000b48 <_stext+0xb28> (3fc953b4 <s_flash_op_mutex>)
4200ae9b:	08a9      	s32i.n	a10, a8, 0
    assert(s_flash_op_mutex != NULL);
4200ae9d:	facc      	bnez.n	a10, 4200aeb0 <spi_flash_init_lock+0x24>
4200ae9f:	d72bd1        	l32r	a13, 42000b4c <_stext+0xb2c> (3c02519c <_flash_rodata_start+0x507c>)
4200aea2:	d72bc1        	l32r	a12, 42000b50 <_stext+0xb30> (3c02797c <__func__$2>)
4200aea5:	6b4c      	movi.n	a11, 70
4200aea7:	d72ba1        	l32r	a10, 42000b54 <_stext+0xb34> (3c0251d3 <_flash_rodata_start+0x50b3>)
4200aeaa:	d49781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200aead:	0008e0        	callx8	a8
}
4200aeb0:	f01d      	retw.n
	...

4200aeb4 <spi_flash_op_lock>:
{
4200aeb4:	004136        	entry	a1, 32
    xSemaphoreTakeRecursive(s_flash_op_mutex, portMAX_DELAY);
4200aeb7:	fb7c      	movi.n	a11, -1
4200aeb9:	d72381        	l32r	a8, 42000b48 <_stext+0xb28> (3fc953b4 <s_flash_op_mutex>)
4200aebc:	08a8      	l32i.n	a10, a8, 0
4200aebe:	d72781        	l32r	a8, 42000b5c <_stext+0xb3c> (40379da4 <xQueueTakeMutexRecursive>)
4200aec1:	0008e0        	callx8	a8
}
4200aec4:	f01d      	retw.n
	...

4200aec8 <spi_flash_op_unlock>:
{
4200aec8:	004136        	entry	a1, 32
    xSemaphoreGiveRecursive(s_flash_op_mutex);
4200aecb:	d71f81        	l32r	a8, 42000b48 <_stext+0xb28> (3fc953b4 <s_flash_op_mutex>)
4200aece:	08a8      	l32i.n	a10, a8, 0
4200aed0:	d72481        	l32r	a8, 42000b60 <_stext+0xb40> (40379ba0 <xQueueGiveMutexRecursive>)
4200aed3:	0008e0        	callx8	a8
}
4200aed6:	f01d      	retw.n

4200aed8 <spi_flash_mmap>:
{
4200aed8:	008136        	entry	a1, 64
4200aedb:	4169      	s32i.n	a6, a1, 16
    void *ptr = NULL;
4200aedd:	080c      	movi.n	a8, 0
4200aedf:	0189      	s32i.n	a8, a1, 0
    block = heap_caps_calloc(1, sizeof(mmap_block_t), MALLOC_CAP_INTERNAL);
4200aee1:	d5b1c1        	l32r	a12, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
4200aee4:	8b0c      	movi.n	a11, 8
4200aee6:	1a0c      	movi.n	a10, 1
4200aee8:	d6c981        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
4200aeeb:	0008e0        	callx8	a8
4200aeee:	0a7d      	mov.n	a7, a10
    if (!block) {
4200aef0:	061a16        	beqz	a10, 4200af55 <spi_flash_mmap+0x7d>
    vaddr_list = heap_caps_calloc(1, 1 * sizeof(uint32_t), MALLOC_CAP_INTERNAL);
4200aef3:	d5adc1        	l32r	a12, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
4200aef6:	4b0c      	movi.n	a11, 4
4200aef8:	1a0c      	movi.n	a10, 1
4200aefa:	d6c481        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
4200aefd:	0008e0        	callx8	a8
4200af00:	0a6d      	mov.n	a6, a10
    if (!vaddr_list) {
4200af02:	056a16        	beqz	a10, 4200af5c <spi_flash_mmap+0x84>
    block->vaddr_list = vaddr_list;
4200af05:	07a9      	s32i.n	a10, a7, 0
    if (memory == SPI_FLASH_MMAP_INST) {
4200af07:	041466        	bnei	a4, 1, 4200af0f <spi_flash_mmap+0x37>
        caps = MMU_MEM_CAP_EXEC | MMU_MEM_CAP_32BIT;
4200af0a:	9d0c      	movi.n	a13, 9
4200af0c:	000086        	j	4200af12 <spi_flash_mmap+0x3a>
        caps = MMU_MEM_CAP_READ | MMU_MEM_CAP_8BIT;
4200af0f:	12a0d2        	movi	a13, 18
    ret = esp_mmu_map(src_addr, size, MMU_TARGET_FLASH0, caps, ESP_MMU_MMAP_FLAG_PADDR_SHARED, &ptr);
4200af12:	20f110        	or	a15, a1, a1
4200af15:	01a0e2        	movi	a14, 1
4200af18:	0ecd      	mov.n	a12, a14
4200af1a:	03bd      	mov.n	a11, a3
4200af1c:	02ad      	mov.n	a10, a2
4200af1e:	ff25e5        	call8	4200a17c <esp_mmu_map>
4200af21:	0a2d      	mov.n	a2, a10
    if (ret == ESP_OK) {
4200af23:	9acc      	bnez.n	a10, 4200af30 <spi_flash_mmap+0x58>
        vaddr_list[0] = (uint32_t)ptr;
4200af25:	0188      	l32i.n	a8, a1, 0
4200af27:	0689      	s32i.n	a8, a6, 0
        block->list_num = 1;
4200af29:	180c      	movi.n	a8, 1
4200af2b:	1789      	s32i.n	a8, a7, 4
4200af2d:	0005c6        	j	4200af48 <spi_flash_mmap+0x70>
    } else if (ret == ESP_ERR_INVALID_STATE) {
4200af30:	03a182        	movi	a8, 0x103
4200af33:	069a87        	bne	a10, a8, 4200af3d <spi_flash_mmap+0x65>
        block->list_num = 0;
4200af36:	080c      	movi.n	a8, 0
4200af38:	1789      	s32i.n	a8, a7, 4
4200af3a:	000286        	j	4200af48 <spi_flash_mmap+0x70>
        free(vaddr_list);
4200af3d:	06ad      	mov.n	a10, a6
4200af3f:	d58b81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200af42:	0008e0        	callx8	a8
4200af45:	000586        	j	4200af5f <spi_flash_mmap+0x87>
    *out_ptr = ptr;
4200af48:	0188      	l32i.n	a8, a1, 0
4200af4a:	0589      	s32i.n	a8, a5, 0
    *out_handle = (uint32_t)block;
4200af4c:	4188      	l32i.n	a8, a1, 16
4200af4e:	0879      	s32i.n	a7, a8, 0
    return ESP_OK;
4200af50:	020c      	movi.n	a2, 0
4200af52:	0004c6        	j	4200af69 <spi_flash_mmap+0x91>
        ret = ESP_ERR_NO_MEM;
4200af55:	01a122        	movi	a2, 0x101
4200af58:	0000c6        	j	4200af5f <spi_flash_mmap+0x87>
4200af5b:	a12200        	sll	a2, a2
        ret = ESP_ERR_NO_MEM;
4200af5e:	678c01        	l32r	a0, 41fe4d90 <_iram_bss_end+0x1c62990>
        free(block);
4200af61:	07ad      	mov.n	a10, a7
4200af63:	d58281        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200af66:	0008e0        	callx8	a8
}
4200af69:	f01d      	retw.n
	...

4200af6c <spi_flash_munmap>:
{
4200af6c:	004136        	entry	a1, 32
    for (int i = 0; i < block->list_num; i++) {
4200af6f:	070c      	movi.n	a7, 0
4200af71:	0008c6        	j	4200af98 <spi_flash_munmap+0x2c>
        ret = esp_mmu_unmap((void *)block->vaddr_list[i]);
4200af74:	0288      	l32i.n	a8, a2, 0
4200af76:	a08780        	addx4	a8, a7, a8
4200af79:	08a8      	l32i.n	a10, a8, 0
4200af7b:	ff6125        	call8	4200a58c <esp_mmu_unmap>
        if (ret == ESP_ERR_NOT_FOUND) {
4200af7e:	05a182        	movi	a8, 0x105
4200af81:	119a87        	bne	a10, a8, 4200af96 <spi_flash_munmap+0x2a>
            assert(0 && "invalid handle, or handle already unmapped");
4200af84:	d6f8d1        	l32r	a13, 42000b64 <_stext+0xb44> (3c025330 <_flash_rodata_start+0x5210>)
4200af87:	d6f8c1        	l32r	a12, 42000b68 <_stext+0xb48> (3c027990 <__func__$1>)
4200af8a:	f7a0b2        	movi	a11, 247
4200af8d:	d6f7a1        	l32r	a10, 42000b6c <_stext+0xb4c> (3c025323 <_flash_rodata_start+0x5203>)
4200af90:	d45e81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200af93:	0008e0        	callx8	a8
    for (int i = 0; i < block->list_num; i++) {
4200af96:	771b      	addi.n	a7, a7, 1
4200af98:	1288      	l32i.n	a8, a2, 4
4200af9a:	d62787        	blt	a7, a8, 4200af74 <spi_flash_munmap+0x8>
    free(block->vaddr_list);
4200af9d:	02a8      	l32i.n	a10, a2, 0
4200af9f:	d57381        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200afa2:	0008e0        	callx8	a8
    free(block);
4200afa5:	02ad      	mov.n	a10, a2
4200afa7:	d57181        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200afaa:	0008e0        	callx8	a8
}
4200afad:	f01d      	retw.n
	...

4200afb0 <spi_flash_cache2phys>:
 * V1 (Latest): added to ROM
 */
// The ROM implementation returns physical address of the PSRAM when the .text or .rodata is in the PSRAM.
// Patched when XIP from PSRAM (partially) enabled.
size_t spi_flash_cache2phys(const void *cached)
{
4200afb0:	006136        	entry	a1, 48
4200afb3:	02ad      	mov.n	a10, a2
    if (cached == NULL) {
4200afb5:	229c      	beqz.n	a2, 4200afcb <spi_flash_cache2phys+0x1b>
        return SPI_FLASH_CACHE2PHYS_FAIL;
    }

    esp_err_t ret = ESP_FAIL;
    uint32_t paddr = 0;
4200afb7:	080c      	movi.n	a8, 0
4200afb9:	0189      	s32i.n	a8, a1, 0
    mmu_target_t target = 0;
4200afbb:	1189      	s32i.n	a8, a1, 4
    if (paddr != SPI_FLASH_CACHE2PHYS_FAIL) {
        return paddr;
    }
#endif

    ret = esp_mmu_vaddr_to_paddr((void *)cached, &paddr, &target);
4200afbd:	c14b      	addi.n	a12, a1, 4
4200afbf:	01bd      	mov.n	a11, a1
4200afc1:	ff70e5        	call8	4200a6d0 <esp_mmu_vaddr_to_paddr>
    if (ret != ESP_OK) {
4200afc4:	8acc      	bnez.n	a10, 4200afd0 <spi_flash_cache2phys+0x20>
        offset = instruction_flash2spiram_offset();
    }
#endif
#endif  //#if !CONFIG_SPIRAM_FLASH_LOAD_TO_PSRAM

    return paddr + offset * CONFIG_MMU_PAGE_SIZE;
4200afc6:	0128      	l32i.n	a2, a1, 0
4200afc8:	000186        	j	4200afd2 <spi_flash_cache2phys+0x22>
        return SPI_FLASH_CACHE2PHYS_FAIL;
4200afcb:	f27c      	movi.n	a2, -1
4200afcd:	000046        	j	4200afd2 <spi_flash_cache2phys+0x22>
        return SPI_FLASH_CACHE2PHYS_FAIL;
4200afd0:	f27c      	movi.n	a2, -1
}
4200afd2:	f01d      	retw.n

4200afd4 <esp_mspi_get_io>:
{
4200afd4:	004136        	entry	a1, 32
    assert(io <= ESP_MSPI_IO_D7);
4200afd7:	a80c      	movi.n	a8, 10
4200afd9:	11b827        	bgeu	a8, a2, 4200afee <esp_mspi_get_io+0x1a>
4200afdc:	d6e5d1        	l32r	a13, 42000b70 <_stext+0xb50> (3c025364 <_flash_rodata_start+0x5244>)
4200afdf:	d6e5c1        	l32r	a12, 42000b74 <_stext+0xb54> (3c0279a4 <__func__$0>)
4200afe2:	f8a0b2        	movi	a11, 248
4200afe5:	d6e4a1        	l32r	a10, 42000b78 <_stext+0xb58> (3c025397 <_flash_rodata_start+0x5277>)
4200afe8:	d44881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200afeb:	0008e0        	callx8	a8
    if (io == ESP_MSPI_IO_WP) {
4200afee:	1e5266        	bnei	a2, 5, 4200b010 <esp_mspi_get_io+0x3c>
        spiconfig = esp_rom_efuse_get_flash_wp_gpio();
4200aff1:	d6e381        	l32r	a8, 42000b80 <_stext+0xb60> (40001fa4 <esp_rom_efuse_get_flash_wp_gpio>)
4200aff4:	0008e0        	callx8	a8
        return (spiconfig == 0x3f) ? s_mspi_io_num_default[io] : spiconfig & 0x3f;
4200aff7:	f83c      	movi.n	a8, 63
4200aff9:	0b9a87        	bne	a10, a8, 4200b008 <esp_mspi_get_io+0x34>
4200affc:	d6e081        	l32r	a8, 42000b7c <_stext+0xb5c> (3c0279b4 <s_mspi_io_num_default>)
4200afff:	882a      	add.n	a8, a8, a2
4200b001:	000822        	l8ui	a2, a8, 0
4200b004:	001246        	j	4200b051 <esp_mspi_get_io+0x7d>
4200b007:	20a000        	or	a10, a0, a0
4200b00a:	54          	.byte	0x54
4200b00b:	001086        	j	4200b051 <esp_mspi_get_io+0x7d>
4200b00e:	f60000        	ee.ldf.64.xp	f0, f15, a0, a0
    spiconfig = (io < ESP_MSPI_IO_WP) ? esp_rom_efuse_get_flash_gpio_info() : esp_rom_efuse_get_opiconfig();
4200b011:	810852        	l8ui	a5, a8, 129
4200b014:	d6dc      	bnez.n	a6, 4200b035 <esp_mspi_get_io+0x61>
4200b016:	0008e0        	callx8	a8
4200b019:	000086        	j	4200b01f <esp_mspi_get_io+0x4b>
4200b01c:	00e3a5        	call8	4200be58 <esp_rom_efuse_get_opiconfig>
    if (spiconfig == ESP_ROM_EFUSE_FLASH_DEFAULT_SPI) {
4200b01f:	9acc      	bnez.n	a10, 4200b02c <esp_mspi_get_io+0x58>
        mspi_io = s_mspi_io_num_default[io];
4200b021:	d6d681        	l32r	a8, 42000b7c <_stext+0xb5c> (3c0279b4 <s_mspi_io_num_default>)
4200b024:	882a      	add.n	a8, a8, a2
4200b026:	000822        	l8ui	a2, a8, 0
4200b029:	000906        	j	4200b051 <esp_mspi_get_io+0x7d>
    } else if (io < ESP_MSPI_IO_WP) {
4200b02c:	1052f6        	bgeui	a2, 5, 4200b040 <esp_mspi_get_io+0x6c>
        mspi_io = (spiconfig >> io * 6) & 0x3f;
4200b02f:	902220        	addx2	a2, a2, a2
4200b032:	222a      	add.n	a2, a2, a2
4200b034:	400200        	ssr	a2
4200b037:	91a0a0        	srl	a10, a10
4200b03a:	5420a0        	extui	a2, a10, 0, 6
4200b03d:	000406        	j	4200b051 <esp_mspi_get_io+0x7d>
        mspi_io = (spiconfig >> (io - ESP_MSPI_IO_DQS) * 6) & 0x3f;
4200b040:	902220        	addx2	a2, a2, a2
4200b043:	222a      	add.n	a2, a2, a2
4200b045:	dcc222        	addi	a2, a2, -36
4200b048:	400200        	ssr	a2
4200b04b:	91a0a0        	srl	a10, a10
4200b04e:	5420a0        	extui	a2, a10, 0, 6
}
4200b051:	f01d      	retw.n
	...

4200b054 <esp_mspi_pin_reserve>:
{
4200b054:	004136        	entry	a1, 32
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
4200b057:	070c      	movi.n	a7, 0
    uint64_t reserve_pin_mask = 0;
4200b059:	075d      	mov.n	a5, a7
4200b05b:	076d      	mov.n	a6, a7
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
4200b05d:	000e86        	j	4200b09b <esp_mspi_pin_reserve+0x47>
        if (!bootloader_flash_is_octal_mode_enabled()
4200b060:	d55981        	l32r	a8, 420005c4 <_stext+0x5a4> (403775bc <bootloader_flash_is_octal_mode_enabled>)
4200b063:	0008e0        	callx8	a8
4200b066:	4acc      	bnez.n	a10, 4200b06e <esp_mspi_pin_reserve+0x1a>
            && i >=  ESP_MSPI_IO_DQS && i <= ESP_MSPI_IO_D7) {
4200b068:	fac782        	addi	a8, a7, -6
4200b06b:	2958b6        	bltui	a8, 5, 4200b098 <esp_mspi_pin_reserve+0x44>
        mspi_io = esp_mspi_get_io(i);
4200b06e:	20a770        	or	a10, a7, a7
4200b071:	fff625        	call8	4200afd4 <esp_mspi_get_io>
        if (mspi_io < 64) {     // 'reserve_pin_mask' have 64 bits length
4200b074:	3fa082        	movi	a8, 63
4200b077:	1d38a7        	bltu	a8, a10, 4200b098 <esp_mspi_pin_reserve+0x44>
            reserve_pin_mask |= BIT64(mspi_io);
4200b07a:	20a092        	movi	a9, 32
4200b07d:	109a90        	and	a9, a10, a9
4200b080:	0b0c      	movi.n	a11, 0
4200b082:	180c      	movi.n	a8, 1
4200b084:	401a00        	ssl	a10
4200b087:	a18800        	sll	a8, a8
4200b08a:	08ad      	mov.n	a10, a8
4200b08c:	83ab90        	moveqz	a10, a11, a9
4200b08f:	938b90        	movnez	a8, a11, a9
4200b092:	205580        	or	a5, a5, a8
4200b095:	2066a0        	or	a6, a6, a10
    for (esp_mspi_io_t i = 0; i < ESP_MSPI_IO_MAX; i++) {
4200b098:	01c772        	addi	a7, a7, 1
4200b09b:	0aa082        	movi	a8, 10
4200b09e:	beb877        	bgeu	a8, a7, 4200b060 <esp_mspi_pin_reserve+0xc>
    esp_gpio_reserve(reserve_pin_mask);
4200b0a1:	20a550        	or	a10, a5, a5
4200b0a4:	06bd      	mov.n	a11, a6
4200b0a6:	013625        	call8	4200c408 <esp_gpio_reserve>
}
4200b0a9:	f01d      	retw.n
	...

4200b0ac <spimem_flash_ll_get_source_freq_mhz>:
{
4200b0ac:	004136        	entry	a1, 32
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4200b0af:	d6b681        	l32r	a8, 42000b88 <_stext+0xb68> (60003000 <SPIMEM0>)
4200b0b2:	0020c0        	memw
4200b0b5:	3b2882        	l32i	a8, a8, 236
4200b0b8:	148080        	extui	a8, a8, 0, 2
4200b0bb:	132826        	beqi	a8, 2, 4200b0d2 <spimem_flash_ll_get_source_freq_mhz+0x26>
4200b0be:	0738f6        	bgeui	a8, 3, 4200b0c9 <spimem_flash_ll_get_source_freq_mhz+0x1d>
4200b0c1:	389c      	beqz.n	a8, 4200b0d8 <spimem_flash_ll_get_source_freq_mhz+0x2c>
4200b0c3:	161826        	beqi	a8, 1, 4200b0dd <spimem_flash_ll_get_source_freq_mhz+0x31>
4200b0c6:	000086        	j	4200b0cc <spimem_flash_ll_get_source_freq_mhz+0x20>
4200b0c9:	173826        	beqi	a8, 3, 4200b0e4 <spimem_flash_ll_get_source_freq_mhz+0x38>
        abort();
4200b0cc:	d40481        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200b0cf:	0008e0        	callx8	a8
        clock_val = 160;
4200b0d2:	a0a022        	movi	a2, 160
4200b0d5:	000386        	j	4200b0e7 <spimem_flash_ll_get_source_freq_mhz+0x3b>
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4200b0d8:	025c      	movi.n	a2, 80
4200b0da:	000246        	j	4200b0e7 <spimem_flash_ll_get_source_freq_mhz+0x3b>
        clock_val = 120;
4200b0dd:	78a022        	movi	a2, 120
4200b0e0:	0000c6        	j	4200b0e7 <spimem_flash_ll_get_source_freq_mhz+0x3b>
4200b0e3:	a02200        	addx4	a2, a2, a0
        clock_val = 240;
4200b0e6:	f01df0        	subx8	a1, a13, a15
4200b0e9:	000000        	ill

4200b0ec <s_esp_flash_choose_correct_mode>:
};

#if CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT
/* This function is used to correct flash mode if config option is not consistent with efuse information */
static void s_esp_flash_choose_correct_mode(memspi_host_config_t *cfg)
{
4200b0ec:	004136        	entry	a1, 32
    static const char *mode = FLASH_MODE_STRING;
    if (bootloader_flash_is_octal_mode_enabled()) {
4200b0ef:	d53581        	l32r	a8, 420005c4 <_stext+0x5a4> (403775bc <bootloader_flash_is_octal_mode_enabled>)
4200b0f2:	0008e0        	callx8	a8
4200b0f5:	baac      	beqz.n	a10, 4200b124 <s_esp_flash_choose_correct_mode+0x38>
4200b0f7:	d3cd81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b0fa:	0888      	l32i.n	a8, a8, 0
    #if !CONFIG_ESPTOOLPY_FLASHMODE_OPI
        ESP_EARLY_LOGW(TAG, "Octal flash chip is using but %s mode is selected, will automatically switch to Octal mode", mode);
4200b0fc:	1628b6        	bltui	a8, 2, 4200b116 <s_esp_flash_choose_correct_mode+0x2a>
4200b0ff:	d3d881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b102:	0008e0        	callx8	a8
4200b105:	d6a1d1        	l32r	a13, 42000b8c <_stext+0xb6c> (3c0254f4 <_flash_rodata_start+0x53d4>)
4200b108:	d6a2c1        	l32r	a12, 42000b90 <_stext+0xb70> (3c027a90 <TAG>)
4200b10b:	0abd      	mov.n	a11, a10
4200b10d:	d6a1a1        	l32r	a10, 42000b94 <_stext+0xb74> (3c0254f8 <_flash_rodata_start+0x53d8>)
4200b110:	d3d581        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b113:	0008e0        	callx8	a8
        cfg->octal_mode_en = 1;
4200b116:	180c      	movi.n	a8, 1
4200b118:	294282        	s8i	a8, a2, 41
        cfg->default_io_mode = SPI_FLASH_OPI_STR;
4200b11b:	081c      	movi.n	a8, 16
4200b11d:	b289      	s32i.n	a8, a2, 44
        default_chip.read_mode = SPI_FLASH_OPI_STR;
4200b11f:	d69e91        	l32r	a9, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b122:	4989      	s32i.n	a8, a9, 16
        cfg->octal_mode_en = 0;
        cfg->default_io_mode = SPI_FLASH_DIO;
        default_chip.read_mode = SPI_FLASH_DIO;
    #endif
    }
}
4200b124:	f01d      	retw.n
	...

4200b128 <esp_flash_init_default_chip>:
#endif // CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT

extern esp_err_t esp_flash_suspend_cmd_init(esp_flash_t* chip);
esp_err_t esp_flash_init_default_chip(void)
{
4200b128:	00c136        	entry	a1, 96
    const esp_rom_spiflash_chip_t *legacy_chip = &g_rom_flashchip;
4200b12b:	d64281        	l32r	a8, 42000a34 <_stext+0xa14> (3fceffe4 <rom_spiflash_legacy_data>)
4200b12e:	0878      	l32i.n	a7, a8, 0
    memspi_host_config_t cfg = ESP_FLASH_HOST_CONFIG_DEFAULT();
4200b130:	cc3c      	movi.n	a12, 60
4200b132:	0b0c      	movi.n	a11, 0
4200b134:	01ad      	mov.n	a10, a1
4200b136:	d47381        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200b139:	0008e0        	callx8	a8
4200b13c:	180c      	movi.n	a8, 1
4200b13e:	0c4182        	s8i	a8, a1, 12
4200b141:	144182        	s8i	a8, a1, 20
4200b144:	085c      	movi.n	a8, 80
4200b146:	c189      	s32i.n	a8, a1, 48

    #if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3
    // Only these chips have efuses for spi pin configuration.
    cfg.iomux = esp_rom_efuse_get_flash_gpio_info() == 0 ?  true : false;
4200b148:	d68f81        	l32r	a8, 42000b84 <_stext+0xb64> (40001f74 <esp_rom_efuse_get_flash_gpio_info>)
4200b14b:	0008e0        	callx8	a8
4200b14e:	40faa0        	nsau	a10, a10
4200b151:	41a5a0        	srli	a10, a10, 5
4200b154:	1441a2        	s8i	a10, a1, 20
    cfg.default_io_mode = DEFAULT_FLASH_MODE;
    #endif

    #if CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT
    // Automatically detect flash mode in run time
    s_esp_flash_choose_correct_mode(&cfg);
4200b157:	01ad      	mov.n	a10, a1
4200b159:	fff925        	call8	4200b0ec <s_esp_flash_choose_correct_mode>
    #endif

    #if !CONFIG_SPI_FLASH_OVERRIDE_CHIP_DRIVER_LIST
    spi_flash_chip_list_check(&default_chip, legacy_chip->device_id);
4200b15c:	07b8      	l32i.n	a11, a7, 0
4200b15e:	d68ea1        	l32r	a10, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b161:	0c3165        	call8	42017478 <spi_flash_chip_list_check>
    #endif

    // For chips need time tuning, get value directly from system here.
    #if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    if (spi_flash_timing_is_tuned()) {
4200b164:	d69481        	l32r	a8, 42000bb4 <_stext+0xb94> (403781e8 <spi_flash_timing_is_tuned>)
4200b167:	0008e0        	callx8	a8
4200b16a:	ca8c      	beqz.n	a10, 4200b17a <esp_flash_init_default_chip+0x52>
        cfg.using_timing_tuning = 1;
4200b16c:	180c      	movi.n	a8, 1
4200b16e:	2a4182        	s8i	a8, a1, 42
        spi_timing_get_flash_timing_param(&cfg.timing_reg);
4200b171:	20a110        	or	a10, a1, a1
4200b174:	d69181        	l32r	a8, 42000bb8 <_stext+0xb98> (40378174 <spi_timing_get_flash_timing_param>)
4200b177:	0008e0        	callx8	a8
    }
    #endif // SOC_SPI_MEM_SUPPORT_TIMING_TUNING

    cfg.clock_src_freq = spi_flash_ll_get_source_clock_freq_mhz(cfg.host_id);
4200b17a:	8188      	l32i.n	a8, a1, 32
4200b17c:	58cc      	bnez.n	a8, 4200b185 <esp_flash_init_default_chip+0x5d>
4200b17e:	fff2e5        	call8	4200b0ac <spimem_flash_ll_get_source_freq_mhz>
4200b181:	000086        	j	4200b187 <esp_flash_init_default_chip+0x5f>
4200b184:	0a5c00        	add.s	f5, f12, f0
4200b187:	d1a9      	s32i.n	a10, a1, 52
    #if CONFIG_SPI_FLASH_AUTO_CHECK_SUSPEND_STATUS
    cfg.auto_waiti_pes = true;
    #endif

    //the host is already initialized, only do init for the data and load it to the host
    esp_err_t err = memspi_host_init_pointers(&esp_flash_default_host, &cfg);
4200b189:	01bd      	mov.n	a11, a1
4200b18b:	d684a1        	l32r	a10, 42000b9c <_stext+0xb7c> (3fc939b8 <esp_flash_default_host>)
4200b18e:	d68b81        	l32r	a8, 42000bbc <_stext+0xb9c> (403804c8 <memspi_host_init_pointers>)
4200b191:	0008e0        	callx8	a8
4200b194:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4200b196:	0bba56        	bnez	a10, 4200b255 <esp_flash_init_default_chip+0x12d>
        return err;
    }

    // ROM TODO: account for non-standard default pins in efuse
    // ROM TODO: to account for chips which are slow to power on, maybe keep probing in a loop here
    err = esp_flash_init_main(&default_chip);
4200b199:	d67fa1        	l32r	a10, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b19c:	d68981        	l32r	a8, 42000bc0 <_stext+0xba0> (40380098 <esp_flash_init_main>)
4200b19f:	0008e0        	callx8	a8
4200b1a2:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4200b1a4:	0ada56        	bnez	a10, 4200b255 <esp_flash_init_default_chip+0x12d>
        return err;
    }
    if (default_chip.size < legacy_chip->chip_size) {
4200b1a7:	d67c81        	l32r	a8, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b1aa:	5888      	l32i.n	a8, a8, 20
4200b1ac:	012792        	l32i	a9, a7, 4
4200b1af:	31b897        	bgeu	a8, a9, 4200b1e4 <esp_flash_init_default_chip+0xbc>
4200b1b2:	d39e81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b1b5:	002882        	l32i	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Detected size(%dk) smaller than the size in the binary image header(%dk). Probe failed.", default_chip.size/1024, legacy_chip->chip_size/1024);
4200b1b8:	020816        	beqz	a8, 4200b1dc <esp_flash_init_default_chip+0xb4>
4200b1bb:	d3a981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b1be:	0008e0        	callx8	a8
4200b1c1:	d67581        	l32r	a8, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b1c4:	58d8      	l32i.n	a13, a8, 20
4200b1c6:	17e8      	l32i.n	a14, a7, 4
4200b1c8:	41eae0        	srli	a14, a14, 10
4200b1cb:	41dad0        	srli	a13, a13, 10
4200b1ce:	d670c1        	l32r	a12, 42000b90 <_stext+0xb70> (3c027a90 <TAG>)
4200b1d1:	0abd      	mov.n	a11, a10
4200b1d3:	d673a1        	l32r	a10, 42000ba0 <_stext+0xb80> (3c025560 <_flash_rodata_start+0x5440>)
4200b1d6:	d3a381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b1d9:	0008e0        	callx8	a8
        return ESP_ERR_FLASH_SIZE_NOT_MATCH;
4200b1dc:	04a122        	movi	a2, 0x104
4200b1df:	001c86        	j	4200b255 <esp_flash_init_default_chip+0x12d>
4200b1e2:	870000        	ee.stf.64.xp	f0, f8, a0, a0
    }

    if (default_chip.size > legacy_chip->chip_size) {
4200b1e5:	28b9      	s32i.n	a11, a8, 8
4200b1e7:	d39181        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b1ea:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGW(TAG, "Detected size(%dk) larger than the size in the binary image header(%dk). Using the size in the binary image header.", default_chip.size/1024, legacy_chip->chip_size/1024);
4200b1ec:	2028b6        	bltui	a8, 2, 4200b210 <esp_flash_init_default_chip+0xe8>
4200b1ef:	d39c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b1f2:	0008e0        	callx8	a8
4200b1f5:	d66881        	l32r	a8, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b1f8:	58d8      	l32i.n	a13, a8, 20
4200b1fa:	17e8      	l32i.n	a14, a7, 4
4200b1fc:	41eae0        	srli	a14, a14, 10
4200b1ff:	41dad0        	srli	a13, a13, 10
4200b202:	d663c1        	l32r	a12, 42000b90 <_stext+0xb70> (3c027a90 <TAG>)
4200b205:	0abd      	mov.n	a11, a10
4200b207:	d667a1        	l32r	a10, 42000ba4 <_stext+0xb84> (3c0255c8 <_flash_rodata_start+0x54a8>)
4200b20a:	d39681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b20d:	0008e0        	callx8	a8
    }
#if !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM // IDF-10019
    if (legacy_chip->chip_size > 16 * 1024 * 1024) {
4200b210:	1788      	l32i.n	a8, a7, 4
4200b212:	d3f791        	l32r	a9, 420001f0 <_stext+0x1d0> (1000000 <UserFrameTotalSize+0xffff00>)
4200b215:	30b987        	bgeu	a9, a8, 4200b249 <esp_flash_init_default_chip+0x121>
        ESP_RETURN_ON_ERROR_ISR(esp_mspi_32bit_address_flash_feature_check(), TAG, "32bit address feature check failed");
4200b218:	d66b81        	l32r	a8, 42000bc4 <_stext+0xba4> (40377d00 <esp_mspi_32bit_address_flash_feature_check>)
4200b21b:	0008e0        	callx8	a8
4200b21e:	0a6d      	mov.n	a6, a10
4200b220:	5aac      	beqz.n	a10, 4200b249 <esp_flash_init_default_chip+0x121>
4200b222:	d38281        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b225:	0888      	l32i.n	a8, a8, 0
4200b227:	019816        	beqz	a8, 4200b244 <esp_flash_init_default_chip+0x11c>
4200b22a:	d38d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b22d:	0008e0        	callx8	a8
4200b230:	a7a1e2        	movi	a14, 0x1a7
4200b233:	d65dd1        	l32r	a13, 42000ba8 <_stext+0xb88> (3c027a74 <__FUNCTION__$1>)
4200b236:	d656c1        	l32r	a12, 42000b90 <_stext+0xb70> (3c027a90 <TAG>)
4200b239:	0abd      	mov.n	a11, a10
4200b23b:	d65ca1        	l32r	a10, 42000bac <_stext+0xb8c> (3c02564c <_flash_rodata_start+0x552c>)
4200b23e:	d38981        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b241:	0008e0        	callx8	a8
4200b244:	062d      	mov.n	a2, a6
4200b246:	0002c6        	j	4200b255 <esp_flash_init_default_chip+0x12d>
    }
#endif // !CONFIG_IDF_TARGET_ESP32P4 || !CONFIG_APP_BUILD_TYPE_RAM
    // Set chip->size equal to ROM flash size(also equal to the size in binary image header), which means the available size that can be used
    default_chip.size = legacy_chip->chip_size;
4200b249:	1798      	l32i.n	a9, a7, 4
4200b24b:	d65381        	l32r	a8, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b24e:	5899      	s32i.n	a9, a8, 20

    esp_flash_default_chip = &default_chip;
4200b250:	d65891        	l32r	a9, 42000bb0 <_stext+0xb90> (3fc953c4 <esp_flash_default_chip>)
4200b253:	0989      	s32i.n	a8, a9, 0
        default_chip.hpm_dummy_ena = 1;
    }
#endif

    return ESP_OK;
}
4200b255:	f01d      	retw.n
	...

4200b258 <esp_flash_app_init>:

esp_err_t esp_flash_app_init(void)
{
4200b258:	004136        	entry	a1, 32
    };
    err = esp_ldo_acquire_channel(&ldo_config, &s_ldo_chan);
    if (err != ESP_OK) return err;
#endif // CONFIG_ESP_LDO_RESERVE_SPI_NOR_FLASH

    spi_flash_init_lock();
4200b25b:	ffc325        	call8	4200ae8c <spi_flash_init_lock>
    spi_flash_guard_set(&g_flash_guard_default_ops);
4200b25e:	d65aa1        	l32r	a10, 42000bc8 <_stext+0xba8> (3fc93970 <g_flash_guard_default_ops>)
4200b261:	d65a81        	l32r	a8, 42000bcc <_stext+0xbac> (40377a6c <spi_flash_guard_set>)
4200b264:	0008e0        	callx8	a8
#endif
#if CONFIG_SPI_FLASH_SHARE_SPI1_BUS
    err = esp_flash_init_main_bus_lock();
    if (err != ESP_OK) return err;
#endif
    err = esp_flash_app_enable_os_functions(&default_chip);
4200b267:	d64ca1        	l32r	a10, 42000b98 <_stext+0xb78> (3fc93998 <default_chip>)
4200b26a:	0e42a5        	call8	42019694 <esp_flash_app_enable_os_functions>
    return err;
}
4200b26d:	202aa0        	or	a2, a10, a10
4200b270:	000090        	retw
	...

4200b274 <esp_crosscore_int_init>:
{
4200b274:	004136        	entry	a1, 32
4200b277:	fb7c      	movi.n	a11, -1
4200b279:	d655a1        	l32r	a10, 42000bd0 <_stext+0xbb0> (3fc92a7c <reason_spinlock>)
4200b27c:	d46d81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200b27f:	0008e0        	callx8	a8
    asm volatile (
4200b282:	03eb80        	rsr.prid	a8
4200b285:	048d80        	extui	a8, a8, 13, 1
    reason[esp_cpu_get_core_id()] = 0;
4200b288:	d65391        	l32r	a9, 42000bd4 <_stext+0xbb4> (3fc953d0 <reason>)
4200b28b:	a08890        	addx4	a8, a8, a9
4200b28e:	090c      	movi.n	a9, 0
4200b290:	0020c0        	memw
4200b293:	006892        	s32i	a9, a8, 0
    portEXIT_CRITICAL(&reason_spinlock);
4200b296:	d64ea1        	l32r	a10, 42000bd0 <_stext+0xbb0> (3fc92a7c <reason_spinlock>)
4200b299:	d46681        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200b29c:	0008e0        	callx8	a8
4200b29f:	03eb80        	rsr.prid	a8
4200b2a2:	048d80        	extui	a8, a8, 13, 1
    if (esp_cpu_get_core_id() == 0) {
4200b2a5:	48dc      	bnez.n	a8, 4200b2bd <esp_crosscore_int_init+0x49>
        err = esp_intr_alloc(SYS_CPU_INTR_FROM_CPU_0_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[0], NULL);
4200b2a7:	0e0c      	movi.n	a14, 0
4200b2a9:	d64ad1        	l32r	a13, 42000bd4 <_stext+0xbb4> (3fc953d0 <reason>)
4200b2ac:	d64bc1        	l32r	a12, 42000bd8 <_stext+0xbb8> (40377ba4 <esp_crosscore_isr>)
4200b2af:	00a4b2        	movi	a11, 0x400
4200b2b2:	4fa0a2        	movi	a10, 79
4200b2b5:	f87625        	call8	42003a18 <esp_intr_alloc>
4200b2b8:	0004c6        	j	4200b2cf <esp_crosscore_int_init+0x5b>
4200b2bb:	e20000        	remu	a0, a0, a0
        err = esp_intr_alloc(SYS_CPU_INTR_FROM_CPU_1_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[1], NULL);
4200b2be:	d100a0        	mul16s	a0, a0, a10
4200b2c1:	c1d647        	bbs	a6, a4, 4200b286 <esp_crosscore_int_init+0x12>
4200b2c4:	b2d645        	call0	41fbe02c <_iram_bss_end+0x1c3bc2c>
4200b2c7:	a200a4        	ee.vldbc.32.ip	q4, a10, 0
4200b2ca:	a550a0        	extui	a5, a10, 16, 11
4200b2cd:	74          	.byte	0x74
4200b2ce:	16f8      	l32i.n	a15, a6, 4
    ESP_ERROR_CHECK(err);
4200b2d0:	011a      	add.n	a0, a1, a1
4200b2d2:	d643e1        	l32r	a14, 42000be0 <_stext+0xbc0> (3c025724 <_flash_rodata_start+0x5604>)
4200b2d5:	d643d1        	l32r	a13, 42000be4 <_stext+0xbc4> (3c027ad0 <__func__$1>)
4200b2d8:	69a0c2        	movi	a12, 105
4200b2db:	d643b1        	l32r	a11, 42000be8 <_stext+0xbc8> (3c025728 <_flash_rodata_start+0x5608>)
4200b2de:	d55581        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200b2e1:	0008e0        	callx8	a8
}
4200b2e4:	f01d      	retw.n
	...

4200b2e8 <esp_system_console_put_char>:
#include "esp_rom_uart.h"
#include "esp_rom_usb_serial.h"
#include "esp_rom_caps.h"

void esp_system_console_put_char(char c)
{
4200b2e8:	004136        	entry	a1, 32
    esp_rom_output_tx_one_char(c);
4200b2eb:	74a020        	extui	a10, a2, 0, 8
4200b2ee:	d63f81        	l32r	a8, 42000bec <_stext+0xbcc> (40000648 <esp_rom_output_tx_one_char>)
4200b2f1:	0008e0        	callx8	a8
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG && !ESP_ROM_CONSOLE_OUTPUT_SECONDARY
    esp_rom_usb_serial_putc(c);
#endif // CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG && !ESP_ROM_CONSOLE_OUTPUT_SECONDARY
}
4200b2f4:	f01d      	retw.n
	...

4200b2f8 <find_entry_and_check_all_reset>:
 * @param[in] user_entry User entry
 * @param[out] all_reset Whether all entries have been reset
 * @return Whether the user entry exists
 */
static TASK_WDT_FN_ATTR bool find_entry_and_check_all_reset(twdt_entry_t *user_entry, bool *all_reset)
{
4200b2f8:	004136        	entry	a1, 32
4200b2fb:	02ad      	mov.n	a10, a2
    bool found_user_entry = false;
    bool found_non_reset = false;

    twdt_entry_t *entry;
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b2fd:	d63c81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b300:	0888      	l32i.n	a8, a8, 0
4200b302:	1888      	l32i.n	a8, a8, 4
    bool found_non_reset = false;
4200b304:	0b0c      	movi.n	a11, 0
    bool found_user_entry = false;
4200b306:	0b2d      	mov.n	a2, a11
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b308:	000546        	j	4200b321 <find_entry_and_check_all_reset+0x29>
4200b30b:	18a700        	lsxp	f10, a7, a0
        if (entry == user_entry) {
4200b30e:	9208      	l32i.n	a0, a2, 36
            found_user_entry = true;
        } else if (entry->has_reset == false) {
4200b310:	0c08      	l32i.n	a0, a12, 0
4200b312:	798c      	beqz.n	a9, 4200b31d <find_entry_and_check_all_reset+0x25>
4200b314:	0001c6        	j	4200b31f <find_entry_and_check_all_reset+0x27>
4200b317:	120c00        	andbc	b0, b12, b0
            found_user_entry = true;
4200b31a:	000046        	j	4200b31f <find_entry_and_check_all_reset+0x27>
            found_non_reset = true;
4200b31d:	1b0c      	movi.n	a11, 1
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b31f:	0888      	l32i.n	a8, a8, 0
4200b321:	fe7856        	bnez	a8, 4200b30c <find_entry_and_check_all_reset+0x14>
        }
    }

    *all_reset = !found_non_reset;
4200b324:	180c      	movi.n	a8, 1
4200b326:	30bb80        	xor	a11, a11, a8
4200b329:	0043b2        	s8i	a11, a3, 0
    return found_user_entry;
}
4200b32c:	f01d      	retw.n
	...

4200b330 <find_entry_from_task_handle_and_check_all_reset>:
 * @param[in] handle Task handle
 * @param[out] all_reset Whether all entries have been reset
 * @return Task entry, or NULL if not found
 */
static TASK_WDT_FN_ATTR twdt_entry_t *find_entry_from_task_handle_and_check_all_reset(TaskHandle_t handle, bool *all_reset)
{
4200b330:	004136        	entry	a1, 32
4200b333:	02ad      	mov.n	a10, a2
    twdt_entry_t *target = NULL;
    bool found_non_reset = false;

    twdt_entry_t *entry;
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b335:	d62e81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b338:	0888      	l32i.n	a8, a8, 0
4200b33a:	1888      	l32i.n	a8, a8, 4
    bool found_non_reset = false;
4200b33c:	0b0c      	movi.n	a11, 0
    twdt_entry_t *target = NULL;
4200b33e:	0b2d      	mov.n	a2, a11
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b340:	000586        	j	4200b35a <find_entry_from_task_handle_and_check_all_reset+0x2a>
4200b343:	189800        	lsxp	f9, a8, a0
        if (entry->task_handle == handle) {
4200b346:	0719a7        	beq	a9, a10, 4200b351 <find_entry_from_task_handle_and_check_all_reset+0x21>
            target = entry;
        } else if (entry->has_reset == false) {
4200b349:	0c0892        	l8ui	a9, a8, 12
4200b34c:	698c      	beqz.n	a9, 4200b356 <find_entry_from_task_handle_and_check_all_reset+0x26>
4200b34e:	000186        	j	4200b358 <find_entry_from_task_handle_and_check_all_reset+0x28>
            target = entry;
4200b351:	082d      	mov.n	a2, a8
4200b353:	000046        	j	4200b358 <find_entry_from_task_handle_and_check_all_reset+0x28>
            found_non_reset = true;
4200b356:	1b0c      	movi.n	a11, 1
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b358:	0888      	l32i.n	a8, a8, 0
4200b35a:	fe6856        	bnez	a8, 4200b344 <find_entry_from_task_handle_and_check_all_reset+0x14>
        }
    }

    *all_reset = !found_non_reset;
4200b35d:	180c      	movi.n	a8, 1
4200b35f:	30bb80        	xor	a11, a11, a8
4200b362:	0043b2        	s8i	a11, a3, 0
    return target;
}
4200b365:	f01d      	retw.n
	...

4200b368 <task_wdt_timer_feed>:
{
4200b368:	004136        	entry	a1, 32
    esp_task_wdt_impl_timer_feed(p_twdt_obj->impl_ctx);
4200b36b:	d62171        	l32r	a7, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b36e:	0788      	l32i.n	a8, a7, 0
4200b370:	08a8      	l32i.n	a10, a8, 0
4200b372:	d62081        	l32r	a8, 42000bf4 <_stext+0xbd4> (40377c84 <esp_task_wdt_impl_timer_feed>)
4200b375:	0008e0        	callx8	a8
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b378:	0788      	l32i.n	a8, a7, 0
4200b37a:	1888      	l32i.n	a8, a8, 4
4200b37c:	0001c6        	j	4200b387 <task_wdt_timer_feed+0x1f>
4200b37f:	090c00        	l32e	a0, a12, -64
        entry->has_reset = false;
4200b382:	0c4892        	s8i	a9, a8, 12
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200b385:	0888      	l32i.n	a8, a8, 0
4200b387:	ff5856        	bnez	a8, 4200b380 <task_wdt_timer_feed+0x18>
}
4200b38a:	f01d      	retw.n

4200b38c <add_entry>:
 * @param[in] entry_data Data associated with the entry (either a task handle or user entry name)
 * @param[out] entry_ret Pointer to created entry
 * @return ESP_OK if entry was added, failure otherwise
 */
static esp_err_t add_entry(bool is_task, void *entry_data, twdt_entry_t **entry_ret)
{
4200b38c:	006136        	entry	a1, 48
    esp_err_t ret;

    // Allocate entry object
    twdt_entry_t *entry = calloc(1, sizeof(twdt_entry_t));
4200b38f:	0b1c      	movi.n	a11, 16
4200b391:	1a0c      	movi.n	a10, 1
4200b393:	d61f81        	l32r	a8, 42000c10 <_stext+0xbf0> (4037fe9c <calloc>)
4200b396:	0008e0        	callx8	a8
4200b399:	0a7d      	mov.n	a7, a10
    if (entry == NULL) {
4200b39b:	0f9a16        	beqz	a10, 4200b498 <add_entry+0x10c>
        return ESP_ERR_NO_MEM;
    }
    if (is_task) {
4200b39e:	328c      	beqz.n	a2, 4200b3a5 <add_entry+0x19>
        entry->task_handle = (TaskHandle_t)entry_data;
4200b3a0:	1a39      	s32i.n	a3, a10, 4
4200b3a2:	000046        	j	4200b3a7 <add_entry+0x1b>
    } else {
        entry->user_name = (const char *)entry_data;
4200b3a5:	2a39      	s32i.n	a3, a10, 8
4200b3a7:	fb7c      	movi.n	a11, -1
4200b3a9:	d613a1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b3ac:	d42181        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200b3af:	0008e0        	callx8	a8
    }

    portENTER_CRITICAL(&spinlock);
    // Check TWDT state
    ESP_GOTO_ON_FALSE_ISR((p_twdt_obj != NULL), ESP_ERR_INVALID_STATE, state_err, TAG, "task watchdog was never initialized");
4200b3b2:	d60f81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b3b5:	0888      	l32i.n	a8, a8, 0
4200b3b7:	78ec      	bnez.n	a8, 4200b3e2 <add_entry+0x56>
4200b3b9:	d31c81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b3bc:	002882        	l32i	a8, a8, 0
4200b3bf:	019816        	beqz	a8, 4200b3dc <add_entry+0x50>
4200b3c2:	d32781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b3c5:	0008e0        	callx8	a8
4200b3c8:	bfa0e2        	movi	a14, 191
4200b3cb:	d60cd1        	l32r	a13, 42000bfc <_stext+0xbdc> (3c027b20 <__FUNCTION__$7>)
4200b3ce:	d60cc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b3d1:	0abd      	mov.n	a11, a10
4200b3d3:	d60ca1        	l32r	a10, 42000c04 <_stext+0xbe4> (3c025760 <_flash_rodata_start+0x5640>)
4200b3d6:	d32381        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b3d9:	0008e0        	callx8	a8
4200b3dc:	03a122        	movi	a2, 0x103
4200b3df:	002846        	j	4200b484 <add_entry+0xf8>
    // Check if the task is an entry, and if all entries have been reset
    bool all_reset;
    if (is_task) {
4200b3e2:	02bc      	beqz.n	a2, 4200b416 <add_entry+0x8a>
        twdt_entry_t *entry_found = find_entry_from_task_handle_and_check_all_reset(entry->task_handle, &all_reset);
4200b3e4:	01bd      	mov.n	a11, a1
4200b3e6:	0127a2        	l32i	a10, a7, 4
4200b3e9:	fff465        	call8	4200b330 <find_entry_from_task_handle_and_check_all_reset>
        ESP_GOTO_ON_FALSE_ISR((entry_found == NULL), ESP_ERR_INVALID_ARG, state_err, TAG, "task is already subscribed");
4200b3ec:	059a16        	beqz	a10, 4200b449 <add_entry+0xbd>
4200b3ef:	d30f81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b3f2:	0888      	l32i.n	a8, a8, 0
4200b3f4:	889c      	beqz.n	a8, 4200b410 <add_entry+0x84>
4200b3f6:	d31a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b3f9:	0008e0        	callx8	a8
4200b3fc:	c4a0e2        	movi	a14, 196
4200b3ff:	d5ffd1        	l32r	a13, 42000bfc <_stext+0xbdc> (3c027b20 <__FUNCTION__$7>)
4200b402:	d5ffc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b405:	0abd      	mov.n	a11, a10
4200b407:	d600a1        	l32r	a10, 42000c08 <_stext+0xbe8> (3c02579c <_flash_rodata_start+0x567c>)
4200b40a:	d31681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b40d:	0008e0        	callx8	a8
4200b410:	02a122        	movi	a2, 0x102
4200b413:	001b46        	j	4200b484 <add_entry+0xf8>
    } else {
        bool entry_found = find_entry_and_check_all_reset(entry, &all_reset);
4200b416:	01bd      	mov.n	a11, a1
4200b418:	07ad      	mov.n	a10, a7
4200b41a:	ffede5        	call8	4200b2f8 <find_entry_and_check_all_reset>
        ESP_GOTO_ON_FALSE_ISR(!entry_found, ESP_ERR_INVALID_ARG, state_err, TAG, "user is already subscribed");
4200b41d:	8aac      	beqz.n	a10, 4200b449 <add_entry+0xbd>
4200b41f:	d30381        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b422:	0888      	l32i.n	a8, a8, 0
4200b424:	889c      	beqz.n	a8, 4200b440 <add_entry+0xb4>
4200b426:	d30e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b429:	0008e0        	callx8	a8
4200b42c:	c7a0e2        	movi	a14, 199
4200b42f:	d5f3d1        	l32r	a13, 42000bfc <_stext+0xbdc> (3c027b20 <__FUNCTION__$7>)
4200b432:	d5f3c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b435:	0abd      	mov.n	a11, a10
4200b437:	d5f5a1        	l32r	a10, 42000c0c <_stext+0xbec> (3c0257cc <_flash_rodata_start+0x56ac>)
4200b43a:	d30a81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b43d:	0008e0        	callx8	a8
4200b440:	02a122        	movi	a2, 0x102
4200b443:	000f46        	j	4200b484 <add_entry+0xf8>
4200b446:	000000        	ill
    }
    // Add entry to list
    SLIST_INSERT_HEAD(&p_twdt_obj->entries_slist, entry, slist_entry);
4200b449:	d5e981        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b44c:	0888      	l32i.n	a8, a8, 0
4200b44e:	1898      	l32i.n	a9, a8, 4
4200b450:	0799      	s32i.n	a9, a7, 0
4200b452:	1879      	s32i.n	a7, a8, 4
    // Start the timer if it has not been started yet and was waiting on a task to registered
    if (p_twdt_obj->waiting_for_task) {
4200b454:	0d0892        	l8ui	a9, a8, 13
4200b457:	d98c      	beqz.n	a9, 4200b468 <add_entry+0xdc>
        esp_task_wdt_impl_timer_restart(p_twdt_obj->impl_ctx);
4200b459:	08a8      	l32i.n	a10, a8, 0
4200b45b:	009ca5        	call8	4200be24 <esp_task_wdt_impl_timer_restart>
        p_twdt_obj->waiting_for_task = false;
4200b45e:	d5e481        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b461:	0888      	l32i.n	a8, a8, 0
4200b463:	090c      	movi.n	a9, 0
4200b465:	0d4892        	s8i	a9, a8, 13
    }
    if (all_reset) {   //Reset hardware timer if all other tasks in list have reset in
4200b468:	000182        	l8ui	a8, a1, 0
4200b46b:	002816        	beqz	a8, 4200b471 <add_entry+0xe5>
        task_wdt_timer_feed();
4200b46e:	ffefa5        	call8	4200b368 <task_wdt_timer_feed>
    }
    portEXIT_CRITICAL(&spinlock);
4200b471:	d5e1a1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b474:	d3f081        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200b477:	0008e0        	callx8	a8
    *entry_ret = entry;
4200b47a:	0479      	s32i.n	a7, a4, 0
    return ESP_OK;
4200b47c:	020c      	movi.n	a2, 0
4200b47e:	000646        	j	4200b49b <add_entry+0x10f>
4200b481:	000000        	ill

state_err:
    portEXIT_CRITICAL(&spinlock);
4200b484:	d5dda1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b487:	d3eb81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200b48a:	0008e0        	callx8	a8
    free(entry);
4200b48d:	07ad      	mov.n	a10, a7
4200b48f:	d43781        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200b492:	0008e0        	callx8	a8
    return ret;
4200b495:	000086        	j	4200b49b <add_entry+0x10f>
        return ESP_ERR_NO_MEM;
4200b498:	01a122        	movi	a2, 0x101
}
4200b49b:	f01d      	retw.n
4200b49d:	000000        	ill

4200b4a0 <delete_entry>:
 * @param[in] is_task Whether the entry is a task entry or user entry
 * @param[in] entry_data Data associated with the entry (either a task handle or user entry name)
 * @return ESP_OK if entry was deleted, failure otherwise
 */
static esp_err_t delete_entry(bool is_task, void *entry_data)
{
4200b4a0:	006136        	entry	a1, 48
4200b4a3:	fb7c      	movi.n	a11, -1
4200b4a5:	d5d4a1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b4a8:	d3e281        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200b4ab:	0008e0        	callx8	a8
    esp_err_t ret;

    portENTER_CRITICAL(&spinlock);
    // Check TWDT state
    ESP_GOTO_ON_FALSE_ISR((p_twdt_obj != NULL), ESP_ERR_INVALID_STATE, err, TAG, "task watchdog was never initialized");
4200b4ae:	d5d081        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b4b1:	0888      	l32i.n	a8, a8, 0
4200b4b3:	78ec      	bnez.n	a8, 4200b4de <delete_entry+0x3e>
4200b4b5:	d2dd81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b4b8:	002882        	l32i	a8, a8, 0
4200b4bb:	019816        	beqz	a8, 4200b4d8 <delete_entry+0x38>
4200b4be:	d2e881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b4c1:	0008e0        	callx8	a8
4200b4c4:	eaa0e2        	movi	a14, 234
4200b4c7:	d5d3d1        	l32r	a13, 42000c14 <_stext+0xbf4> (3c027ae8 <__FUNCTION__$2>)
4200b4ca:	d5cdc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b4cd:	0abd      	mov.n	a11, a10
4200b4cf:	d5cda1        	l32r	a10, 42000c04 <_stext+0xbe4> (3c025760 <_flash_rodata_start+0x5640>)
4200b4d2:	d2e481        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b4d5:	0008e0        	callx8	a8
4200b4d8:	03a122        	movi	a2, 0x103
4200b4db:	003206        	j	4200b5a7 <delete_entry+0x107>
    // Find entry for task
    bool all_reset;
    twdt_entry_t *entry;
    if (is_task) {
4200b4de:	034216        	beqz	a2, 4200b516 <delete_entry+0x76>
        entry = find_entry_from_task_handle_and_check_all_reset((TaskHandle_t)entry_data, &all_reset);
4200b4e1:	20b110        	or	a11, a1, a1
4200b4e4:	20a330        	or	a10, a3, a3
4200b4e7:	ffe4a5        	call8	4200b330 <find_entry_from_task_handle_and_check_all_reset>
4200b4ea:	0a3d      	mov.n	a3, a10
        ESP_GOTO_ON_FALSE_ISR((entry != NULL), ESP_ERR_NOT_FOUND, err, TAG, "task not found");
4200b4ec:	058a56        	bnez	a10, 4200b548 <delete_entry+0xa8>
4200b4ef:	d2cf81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b4f2:	0888      	l32i.n	a8, a8, 0
4200b4f4:	889c      	beqz.n	a8, 4200b510 <delete_entry+0x70>
4200b4f6:	d2da81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b4f9:	0008e0        	callx8	a8
4200b4fc:	f0a0e2        	movi	a14, 240
4200b4ff:	d5c5d1        	l32r	a13, 42000c14 <_stext+0xbf4> (3c027ae8 <__FUNCTION__$2>)
4200b502:	d5bfc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b505:	0abd      	mov.n	a11, a10
4200b507:	d5c4a1        	l32r	a10, 42000c18 <_stext+0xbf8> (3c0257fc <_flash_rodata_start+0x56dc>)
4200b50a:	d2d681        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b50d:	0008e0        	callx8	a8
4200b510:	05a122        	movi	a2, 0x105
4200b513:	002406        	j	4200b5a7 <delete_entry+0x107>
    } else {
        entry = (twdt_entry_t *)entry_data;
        bool entry_found = find_entry_and_check_all_reset(entry, &all_reset);
4200b516:	01bd      	mov.n	a11, a1
4200b518:	03ad      	mov.n	a10, a3
4200b51a:	ffdde5        	call8	4200b2f8 <find_entry_and_check_all_reset>
        ESP_GOTO_ON_FALSE_ISR(entry_found, ESP_ERR_NOT_FOUND, err, TAG, "user not found");
4200b51d:	7aec      	bnez.n	a10, 4200b548 <delete_entry+0xa8>
4200b51f:	d2c381        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b522:	0888      	l32i.n	a8, a8, 0
4200b524:	889c      	beqz.n	a8, 4200b540 <delete_entry+0xa0>
4200b526:	d2ce81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b529:	0008e0        	callx8	a8
4200b52c:	f4a0e2        	movi	a14, 244
4200b52f:	d5b9d1        	l32r	a13, 42000c14 <_stext+0xbf4> (3c027ae8 <__FUNCTION__$2>)
4200b532:	d5b3c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b535:	0abd      	mov.n	a11, a10
4200b537:	d5b9a1        	l32r	a10, 42000c1c <_stext+0xbfc> (3c025820 <_flash_rodata_start+0x5700>)
4200b53a:	d2ca81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b53d:	0008e0        	callx8	a8
4200b540:	05a122        	movi	a2, 0x105
4200b543:	001806        	j	4200b5a7 <delete_entry+0x107>
4200b546:	810000        	src	a0, a0, a0
    }
    // Remove entry
    SLIST_REMOVE(&p_twdt_obj->entries_slist, entry, twdt_entry, slist_entry);
4200b549:	d5aa      	add.n	a13, a5, a10
4200b54b:	08a8      	l32i.n	a10, a8, 0
4200b54d:	1a88      	l32i.n	a8, a10, 4
4200b54f:	069387        	bne	a3, a8, 4200b559 <delete_entry+0xb9>
4200b552:	0888      	l32i.n	a8, a8, 0
4200b554:	1a89      	s32i.n	a8, a10, 4
4200b556:	000346        	j	4200b567 <delete_entry+0xc7>
4200b559:	209880        	or	a9, a8, a8
4200b55c:	002882        	l32i	a8, a8, 0
4200b55f:	f69387        	bne	a3, a8, 4200b559 <delete_entry+0xb9>
4200b562:	002882        	l32i	a8, a8, 0
4200b565:	0989      	s32i.n	a8, a9, 0
    /* Stop the timer if we don't have any more tasks/objects to watch */
    if (SLIST_EMPTY(&p_twdt_obj->entries_slist)) {
4200b567:	1a88      	l32i.n	a8, a10, 4
4200b569:	b8cc      	bnez.n	a8, 4200b578 <delete_entry+0xd8>
        p_twdt_obj->waiting_for_task = true;
4200b56b:	180c      	movi.n	a8, 1
4200b56d:	0d4a82        	s8i	a8, a10, 13
        esp_task_wdt_impl_timer_stop(p_twdt_obj->impl_ctx);
4200b570:	0aa8      	l32i.n	a10, a10, 0
4200b572:	008865        	call8	4200bdf8 <esp_task_wdt_impl_timer_stop>
4200b575:	000106        	j	4200b57d <delete_entry+0xdd>
    } else {
        p_twdt_obj->waiting_for_task = false;
4200b578:	080c      	movi.n	a8, 0
4200b57a:	0d4a82        	s8i	a8, a10, 13
    }
    /* Reset hardware timer if all remaining tasks have reset and if the list of tasks is not empty */
    if (!p_twdt_obj->waiting_for_task && all_reset) {
4200b57d:	d59c81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b580:	0888      	l32i.n	a8, a8, 0
4200b582:	0d0882        	l8ui	a8, a8, 13
4200b585:	78cc      	bnez.n	a8, 4200b590 <delete_entry+0xf0>
4200b587:	000182        	l8ui	a8, a1, 0
4200b58a:	002816        	beqz	a8, 4200b590 <delete_entry+0xf0>
        task_wdt_timer_feed();
4200b58d:	ffdda5        	call8	4200b368 <task_wdt_timer_feed>
    }
    portEXIT_CRITICAL(&spinlock);
4200b590:	d59aa1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b593:	d3a881        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200b596:	0008e0        	callx8	a8
    free(entry);
4200b599:	03ad      	mov.n	a10, a3
4200b59b:	d3f481        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200b59e:	0008e0        	callx8	a8
    return ESP_OK;
4200b5a1:	020c      	movi.n	a2, 0
4200b5a3:	000246        	j	4200b5b0 <delete_entry+0x110>
4200b5a6:	94a100        	extui	a10, a0, 1, 10

err:
    portEXIT_CRITICAL(&spinlock);
4200b5a9:	a281d5        	call4	41faddc8 <_iram_bss_end+0x1c2b9c8>
4200b5ac:	d3          	.byte	0xd3
4200b5ad:	0008e0        	callx8	a8
    return ret;
}
4200b5b0:	f01d      	retw.n
	...

4200b5b4 <get_task_affinity>:
 * +------------------------+--------------------------------+--------------------------+
 *
 */

static UBaseType_t get_task_affinity(const TaskHandle_t xTask)
{
4200b5b4:	004136        	entry	a1, 32
4200b5b7:	02ad      	mov.n	a10, a2
    if (xTask == NULL) {
4200b5b9:	329c      	beqz.n	a2, 4200b5d0 <get_task_affinity+0x1c>
    return vTaskCoreAffinityGet(xTask);
#else
    return BIT(0);
#endif
#else
    BaseType_t task_affinity = xTaskGetCoreID(xTask);
4200b5bb:	d3f381        	l32r	a8, 42000588 <_stext+0x568> (4037c714 <xTaskGetCoreID>)
4200b5be:	0008e0        	callx8	a8
    if (task_affinity == 0 || task_affinity == 1) {
4200b5c1:	102af6        	bgeui	a10, 2, 4200b5d5 <get_task_affinity+0x21>
        return BIT(task_affinity);
4200b5c4:	120c      	movi.n	a2, 1
4200b5c6:	401a00        	ssl	a10
4200b5c9:	a12200        	sll	a2, a2
4200b5cc:	0001c6        	j	4200b5d7 <get_task_affinity+0x23>
4200b5cf:	320c00        	orbc	b0, b12, b0
        return BIT(1) | BIT(0);
4200b5d2:	000046        	j	4200b5d7 <get_task_affinity+0x23>
    }
    return BIT(1) | BIT(0);
4200b5d5:	320c      	movi.n	a2, 3
#endif
}
4200b5d7:	f01d      	retw.n
4200b5d9:	000000        	ill

4200b5dc <task_wdt_timeout_abort>:
 * It is called either by the function right below or by a crosscore interrupt,
 * in the case where the other core (than the main one) has to abort because one
 * of his tasks didn't reset the TWDT on time.
 */
void task_wdt_timeout_abort(bool current_core)
{
4200b5dc:	006136        	entry	a1, 48
4200b5df:	742020        	extui	a2, a2, 0, 8
    TaskSnapshot_t snapshot = { 0 };
4200b5e2:	0ca0c2        	movi	a12, 12
4200b5e5:	0b0c      	movi.n	a11, 0
4200b5e7:	20a110        	or	a10, a1, a1
4200b5ea:	d34681        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200b5ed:	0008e0        	callx8	a8
4200b5f0:	d28f81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b5f3:	0888      	l32i.n	a8, a8, 0
    BaseType_t __attribute__((unused)) ret = pdTRUE;

    ESP_EARLY_LOGE(TAG, "Aborting.");
4200b5f5:	389c      	beqz.n	a8, 4200b60c <task_wdt_timeout_abort+0x30>
4200b5f7:	d29a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b5fa:	0008e0        	callx8	a8
4200b5fd:	d580c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b600:	20baa0        	or	a11, a10, a10
4200b603:	d587a1        	l32r	a10, 42000c20 <_stext+0xc00> (3c025844 <_flash_rodata_start+0x5724>)
4200b606:	d29781        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b609:	0008e0        	callx8	a8
    esp_reset_reason_set_hint(ESP_RST_TASK_WDT);
4200b60c:	6a0c      	movi.n	a10, 6
4200b60e:	d33781        	l32r	a8, 420002ec <_stext+0x2cc> (40377cf0 <esp_reset_reason_set_hint>)
4200b611:	0008e0        	callx8	a8
    ret = vTaskGetSnapshot(xTaskGetCurrentTaskHandle(), &snapshot);
4200b614:	d36e81        	l32r	a8, 420003cc <_stext+0x3ac> (4037b778 <xTaskGetCurrentTaskHandle>)
4200b617:	0008e0        	callx8	a8
4200b61a:	01bd      	mov.n	a11, a1
4200b61c:	d58881        	l32r	a8, 42000c3c <_stext+0xc1c> (4037c798 <vTaskGetSnapshot>)
4200b61f:	0008e0        	callx8	a8
    assert(ret == pdTRUE);
4200b622:	111a26        	beqi	a10, 1, 4200b637 <task_wdt_timeout_abort+0x5b>
4200b625:	d57fd1        	l32r	a13, 42000c24 <_stext+0xc04> (3c02585c <_flash_rodata_start+0x573c>)
4200b628:	d580c1        	l32r	a12, 42000c28 <_stext+0xc08> (3c027b9c <__func__$15>)
4200b62b:	7ea1b2        	movi	a11, 0x17e
4200b62e:	d57fa1        	l32r	a10, 42000c2c <_stext+0xc0c> (3c025891 <_flash_rodata_start+0x5771>)
4200b631:	d2b581        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200b634:	0008e0        	callx8	a8
    g_panic_abort = true;
4200b637:	180c      	movi.n	a8, 1
4200b639:	d32091        	l32r	a9, 420002bc <_stext+0x29c> (3fc94d3c <g_panic_abort>)
4200b63c:	004982        	s8i	a8, a9, 0
     * an ISR context, but it is intended, it is not because an ISR encountered an
     * exception. If we don't set such flag, later tested by coredump, the latter would
     * switch the execution frame/context we are giving it to the interrupt stack.
     * For details about this behavior in the TODO task: IDF-5694
     */
    g_twdt_isr = true;
4200b63f:	d57c91        	l32r	a9, 42000c30 <_stext+0xc10> (3fc953dc <g_twdt_isr>)
4200b642:	004982        	s8i	a8, a9, 0
    void *frame = (void *) snapshot.pxTopOfStack;
4200b645:	1178      	l32i.n	a7, a1, 4

    if (current_core) {
4200b647:	22ac      	beqz.n	a2, 4200b66d <task_wdt_timeout_abort+0x91>
4200b649:	d27881        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b64c:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "Print CPU %d (current core) " BACKTRACE_MSG, xPortGetCoreID());
4200b64e:	c8bc      	beqz.n	a8, 4200b68e <task_wdt_timeout_abort+0xb2>
4200b650:	d28481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b653:	0008e0        	callx8	a8
4200b656:	0abd      	mov.n	a11, a10
4200b658:	03ebd0        	rsr.prid	a13
4200b65b:	04ddd0        	extui	a13, a13, 13, 1
4200b65e:	d568c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b661:	d574a1        	l32r	a10, 42000c34 <_stext+0xc14> (3c02589c <_flash_rodata_start+0x577c>)
4200b664:	d28081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b667:	0008e0        	callx8	a8
4200b66a:	000806        	j	4200b68e <task_wdt_timeout_abort+0xb2>
4200b66d:	d26f81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b670:	0888      	l32i.n	a8, a8, 0
    } else {
        ESP_EARLY_LOGE(TAG, "Print CPU %d " BACKTRACE_MSG, xPortGetCoreID());
4200b672:	889c      	beqz.n	a8, 4200b68e <task_wdt_timeout_abort+0xb2>
4200b674:	d27b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b677:	0008e0        	callx8	a8
4200b67a:	0abd      	mov.n	a11, a10
4200b67c:	03ebd0        	rsr.prid	a13
4200b67f:	04ddd0        	extui	a13, a13, 13, 1
4200b682:	d55fc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b685:	d56ca1        	l32r	a10, 42000c38 <_stext+0xc18> (3c0258d0 <_flash_rodata_start+0x57b0>)
4200b688:	d27781        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b68b:	0008e0        	callx8	a8
    }

    xt_unhandled_exception(frame);
4200b68e:	07ad      	mov.n	a10, a7
4200b690:	d56c81        	l32r	a8, 42000c40 <_stext+0xc20> (403759fc <xt_unhandled_exception>)
4200b693:	0008e0        	callx8	a8
}
4200b696:	f01d      	retw.n

4200b698 <task_wdt_timeout_handling>:

static void task_wdt_timeout_handling(int cores_fail, bool panic)
{
4200b698:	004136        	entry	a1, 32
4200b69b:	03eb70        	rsr.prid	a7
4200b69e:	047d70        	extui	a7, a7, 13, 1
    const int current_core = xPortGetCoreID();

    if (panic) {
4200b6a1:	053316        	beqz	a3, 4200b6f8 <task_wdt_timeout_handling+0x60>
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
        const int other_core = !current_core;
4200b6a4:	40f730        	nsau	a3, a7
4200b6a7:	413530        	srli	a3, a3, 5

        if ((cores_fail & BIT(0)) && (cores_fail & BIT(1))) {
4200b6aa:	380c      	movi.n	a8, 3
4200b6ac:	31c287        	bnall	a2, a8, 4200b6e1 <task_wdt_timeout_handling+0x49>
4200b6af:	d25f81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b6b2:	0888      	l32i.n	a8, a8, 0
            /* In the case where both CPUs have failing tasks, print the current CPU backtrace and then let the
             * other core fail. */
            ESP_EARLY_LOGE(TAG, "Print CPU %d (current core) " BACKTRACE_MSG, current_core);
4200b6b4:	489c      	beqz.n	a8, 4200b6cc <task_wdt_timeout_handling+0x34>
4200b6b6:	d26a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b6b9:	0008e0        	callx8	a8
4200b6bc:	07dd      	mov.n	a13, a7
4200b6be:	d550c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b6c1:	0abd      	mov.n	a11, a10
4200b6c3:	d55ca1        	l32r	a10, 42000c34 <_stext+0xc14> (3c02589c <_flash_rodata_start+0x577c>)
4200b6c6:	d26781        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b6c9:	0008e0        	callx8	a8
            esp_backtrace_print(100);
4200b6cc:	64a0a2        	movi	a10, 100
4200b6cf:	d55d81        	l32r	a8, 42000c44 <_stext+0xc24> (40375c40 <esp_backtrace_print>)
4200b6d2:	0008e0        	callx8	a8
            /* TODO: the interrupt we send should have the highest priority */
            esp_crosscore_int_send_twdt_abort(other_core);
4200b6d5:	03ad      	mov.n	a10, a3
4200b6d7:	d55c81        	l32r	a8, 42000c48 <_stext+0xc28> (40377c74 <esp_crosscore_int_send_twdt_abort>)
4200b6da:	0008e0        	callx8	a8
            /* We are going to abort, on the other core, we have nothing to
             * do anymore here, just wait until we crash */
            while (1) {}
4200b6dd:	ffff06        	j	4200b6dd <task_wdt_timeout_handling+0x45>
4200b6e0:	00          	.byte	00
        } else if (cores_fail & BIT(other_core)) {
4200b6e1:	0b5237        	bbc	a2, a3, 4200b6f0 <task_wdt_timeout_handling+0x58>
            /* If only the other core is failing, we can tell it to abort. */
            esp_crosscore_int_send_twdt_abort(other_core);
4200b6e4:	03ad      	mov.n	a10, a3
4200b6e6:	d55881        	l32r	a8, 42000c48 <_stext+0xc28> (40377c74 <esp_crosscore_int_send_twdt_abort>)
4200b6e9:	0008e0        	callx8	a8
            while (1) {}
4200b6ec:	ffff06        	j	4200b6ec <task_wdt_timeout_handling+0x54>
4200b6ef:	1a0c00        	sub.s	f0, f12, f0
        }
#endif // !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
        /* Current core is failing, abort right now */
        task_wdt_timeout_abort(true);
4200b6f2:	ffeea5        	call8	4200b5dc <task_wdt_timeout_abort>
4200b6f5:	0015c6        	j	4200b750 <task_wdt_timeout_handling+0xb8>
    } else {
        /* Print backtrace of the core that failed to reset the watchdog */
        if (cores_fail & BIT(current_core)) {
4200b6f8:	255277        	bbc	a2, a7, 4200b721 <task_wdt_timeout_handling+0x89>
4200b6fb:	d24c81        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b6fe:	0888      	l32i.n	a8, a8, 0
            ESP_EARLY_LOGE(TAG, "Print CPU %d (current core) " BACKTRACE_MSG, current_core);
4200b700:	489c      	beqz.n	a8, 4200b718 <task_wdt_timeout_handling+0x80>
4200b702:	d25781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b705:	0008e0        	callx8	a8
4200b708:	07dd      	mov.n	a13, a7
4200b70a:	d53dc1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b70d:	0abd      	mov.n	a11, a10
4200b70f:	d549a1        	l32r	a10, 42000c34 <_stext+0xc14> (3c02589c <_flash_rodata_start+0x577c>)
4200b712:	d25481        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b715:	0008e0        	callx8	a8
            esp_backtrace_print(100);
4200b718:	64a0a2        	movi	a10, 100
4200b71b:	d54a81        	l32r	a8, 42000c44 <_stext+0xc24> (40375c40 <esp_backtrace_print>)
4200b71e:	0008e0        	callx8	a8
        }
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
        const int other_core = !current_core;
4200b721:	40f770        	nsau	a7, a7
4200b724:	417570        	srli	a7, a7, 5
        if (cores_fail & BIT(other_core)) {
4200b727:	255277        	bbc	a2, a7, 4200b750 <task_wdt_timeout_handling+0xb8>
4200b72a:	d24081        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b72d:	0888      	l32i.n	a8, a8, 0
            ESP_EARLY_LOGE(TAG, "Print CPU %d " BACKTRACE_MSG, other_core);
4200b72f:	015816        	beqz	a8, 4200b748 <task_wdt_timeout_handling+0xb0>
4200b732:	d24b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b735:	0008e0        	callx8	a8
4200b738:	07dd      	mov.n	a13, a7
4200b73a:	d531c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b73d:	0abd      	mov.n	a11, a10
4200b73f:	d53ea1        	l32r	a10, 42000c38 <_stext+0xc18> (3c0258d0 <_flash_rodata_start+0x57b0>)
4200b742:	d24881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b745:	0008e0        	callx8	a8
            esp_crosscore_int_send_print_backtrace(other_core);
4200b748:	07ad      	mov.n	a10, a7
4200b74a:	d54081        	l32r	a8, 42000c4c <_stext+0xc2c> (40377c64 <esp_crosscore_int_send_print_backtrace>)
4200b74d:	0008e0        	callx8	a8
        }
#endif // !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    }
}
4200b750:	f01d      	retw.n
	...

4200b754 <esp_task_wdt_add>:
    subscribe_idle(p_twdt_obj->idle_core_mask); // Resubscribe idle tasks
    return ret;
}

esp_err_t esp_task_wdt_add(TaskHandle_t task_handle)
{
4200b754:	008136        	entry	a1, 64
4200b757:	02bd      	mov.n	a11, a2
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
4200b759:	d52581        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b75c:	002882        	l32i	a8, a8, 0
4200b75f:	027856        	bnez	a8, 4200b78a <esp_task_wdt_add+0x36>
4200b762:	d23f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b765:	0008e0        	callx8	a8
4200b768:	d526b1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b76b:	9fa282        	movi	a8, 0x29f
4200b76e:	0189      	s32i.n	a8, a1, 0
4200b770:	d538f1        	l32r	a15, 42000c50 <_stext+0xc30> (3c027b2c <__FUNCTION__$8>)
4200b773:	0bed      	mov.n	a14, a11
4200b775:	20daa0        	or	a13, a10, a10
4200b778:	d537c1        	l32r	a12, 42000c54 <_stext+0xc34> (3c0258f4 <_flash_rodata_start+0x57d4>)
4200b77b:	01a0a2        	movi	a10, 1
4200b77e:	d24581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200b781:	0008e0        	callx8	a8
4200b784:	03a122        	movi	a2, 0x103
4200b787:	0004c6        	j	4200b79e <esp_task_wdt_add+0x4a>
    esp_err_t ret;
    if (task_handle == NULL) {   // Get handle of current task if none is provided
4200b78a:	62cc      	bnez.n	a2, 4200b794 <esp_task_wdt_add+0x40>
        task_handle = xTaskGetCurrentTaskHandle();
4200b78c:	d31081        	l32r	a8, 420003cc <_stext+0x3ac> (4037b778 <xTaskGetCurrentTaskHandle>)
4200b78f:	0008e0        	callx8	a8
4200b792:	0abd      	mov.n	a11, a10
    }

    twdt_entry_t *entry;
    ret = add_entry(true, (void *)task_handle, &entry);
4200b794:	10c1c2        	addi	a12, a1, 16
4200b797:	1a0c      	movi.n	a10, 1
4200b799:	ffbf25        	call8	4200b38c <add_entry>
4200b79c:	0a2d      	mov.n	a2, a10
    (void) entry; // Returned entry pointer not used
    return ret;
}
4200b79e:	f01d      	retw.n

4200b7a0 <subscribe_idle>:
{
4200b7a0:	004136        	entry	a1, 32
    int core_num = 0;
4200b7a3:	070c      	movi.n	a7, 0
    while (core_mask != 0) {
4200b7a5:	001646        	j	4200b802 <subscribe_idle+0x62>
4200b7a8:	620700        	saltu	a0, a7, a0
        if (core_mask & 0x1) {
4200b7ab:	a77050        	ee.stf.64.xp	f7, f10, a5, a0
            TaskHandle_t idle_task_handle = xTaskGetIdleTaskHandleForCore(core_num);
4200b7ae:	308120        	xor	a8, a1, a2
4200b7b1:	08e0d5        	call4	420145c0 <get_arg$isra$0+0x3f4>
4200b7b4:	1a5600        	sub.s	f5, f6, f0
            assert(idle_task_handle);
4200b7b7:	28d101        	l32r	a0, 41fd5afc <_iram_bss_end+0x1c536fc>
4200b7ba:	28c1d5        	call4	420343d8 <_etext+0x1aca2>
4200b7bd:	a1b2d5        	call4	41fad2ec <_iram_bss_end+0x1c2aeec>
4200b7c0:	1aa137        	bge	a1, a3, 4200b7de <subscribe_idle+0x3e>
4200b7c3:	5181d5        	call4	4205cfe0 <_etext+0x438aa>
4200b7c6:	08e0d2        	s32c1i	a13, a0, 32
4200b7c9:	00          	.byte	00
            ESP_ERROR_CHECK(esp_task_wdt_add(idle_task_handle));
4200b7ca:	fff8a5        	call8	4200b754 <esp_task_wdt_add>
4200b7cd:	0a9c      	beqz.n	a10, 4200b7e1 <subscribe_idle+0x41>
4200b7cf:	d524e1        	l32r	a14, 42000c60 <_stext+0xc40> (3c025938 <_flash_rodata_start+0x5818>)
4200b7d2:	d522d1        	l32r	a13, 42000c5c <_stext+0xc3c> (3c027b68 <__func__$12>)
4200b7d5:	38a1c2        	movi	a12, 0x138
4200b7d8:	d523b1        	l32r	a11, 42000c64 <_stext+0xc44> (3c02595c <_flash_rodata_start+0x583c>)
4200b7db:	d41681        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200b7de:	0008e0        	callx8	a8
            ESP_ERROR_CHECK(esp_register_freertos_idle_hook_for_cpu(idle_hook_cb, core_num));
4200b7e1:	07bd      	mov.n	a11, a7
4200b7e3:	d521a1        	l32r	a10, 42000c68 <_stext+0xc48> (4200b994 <idle_hook_cb>)
4200b7e6:	f72465        	call8	42002a2c <esp_register_freertos_idle_hook_for_cpu>
4200b7e9:	0a9c      	beqz.n	a10, 4200b7fd <subscribe_idle+0x5d>
4200b7eb:	d520e1        	l32r	a14, 42000c6c <_stext+0xc4c> (3c02598c <_flash_rodata_start+0x586c>)
4200b7ee:	d51bd1        	l32r	a13, 42000c5c <_stext+0xc3c> (3c027b68 <__func__$12>)
4200b7f1:	39a1c2        	movi	a12, 0x139
4200b7f4:	d51cb1        	l32r	a11, 42000c64 <_stext+0xc44> (3c02595c <_flash_rodata_start+0x583c>)
4200b7f7:	d40f81        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200b7fa:	0008e0        	callx8	a8
        core_mask >>= 1;
4200b7fd:	412120        	srli	a2, a2, 1
        core_num++;
4200b800:	771b      	addi.n	a7, a7, 1
    while (core_mask != 0) {
4200b802:	fa3256        	bnez	a2, 4200b7a9 <subscribe_idle+0x9>
}
4200b805:	f01d      	retw.n
	...

4200b808 <esp_task_wdt_init>:
{
4200b808:	006136        	entry	a1, 48
4200b80b:	027d      	mov.n	a7, a2
    ESP_RETURN_ON_FALSE((config != NULL && config->idle_core_mask < (1 << CONFIG_FREERTOS_NUMBER_OF_CORES)), ESP_ERR_INVALID_ARG, TAG, "Invalid arguments");
4200b80d:	328c      	beqz.n	a2, 4200b814 <esp_task_wdt_init+0xc>
4200b80f:	1288      	l32i.n	a8, a2, 4
4200b811:	2748b6        	bltui	a8, 4, 4200b83c <esp_task_wdt_init+0x34>
4200b814:	d21381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b817:	0008e0        	callx8	a8
4200b81a:	d4f9b1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b81d:	04a282        	movi	a8, 0x204
4200b820:	0189      	s32i.n	a8, a1, 0
4200b822:	d514f1        	l32r	a15, 42000c74 <_stext+0xc54> (3c027b88 <__FUNCTION__$14>)
4200b825:	0bed      	mov.n	a14, a11
4200b827:	0add      	mov.n	a13, a10
4200b829:	d513c1        	l32r	a12, 42000c78 <_stext+0xc58> (3c0259cc <_flash_rodata_start+0x58ac>)
4200b82c:	1a0c      	movi.n	a10, 1
4200b82e:	d21981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200b831:	0008e0        	callx8	a8
4200b834:	02a122        	movi	a2, 0x102
4200b837:	002d46        	j	4200b8f0 <esp_task_wdt_init+0xe8>
4200b83a:	810000        	src	a0, a0, a0
    ESP_RETURN_ON_FALSE(p_twdt_obj == NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT already initialized");
4200b83d:	ed          	.byte	0xed
4200b83e:	d4          	.byte	0xd4
4200b83f:	0888      	l32i.n	a8, a8, 0
4200b841:	58ac      	beqz.n	a8, 4200b86a <esp_task_wdt_init+0x62>
4200b843:	d20781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b846:	0008e0        	callx8	a8
4200b849:	d4edb1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b84c:	05a282        	movi	a8, 0x205
4200b84f:	0189      	s32i.n	a8, a1, 0
4200b851:	d508f1        	l32r	a15, 42000c74 <_stext+0xc54> (3c027b88 <__FUNCTION__$14>)
4200b854:	0bed      	mov.n	a14, a11
4200b856:	0add      	mov.n	a13, a10
4200b858:	d509c1        	l32r	a12, 42000c7c <_stext+0xc5c> (3c0259f4 <_flash_rodata_start+0x58d4>)
4200b85b:	01a0a2        	movi	a10, 1
4200b85e:	d20d81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200b861:	0008e0        	callx8	a8
4200b864:	03a122        	movi	a2, 0x103
4200b867:	002146        	j	4200b8f0 <esp_task_wdt_init+0xe8>
    obj = calloc(1, sizeof(twdt_obj_t));
4200b86a:	0b1c      	movi.n	a11, 16
4200b86c:	1a0c      	movi.n	a10, 1
4200b86e:	d4e881        	l32r	a8, 42000c10 <_stext+0xbf0> (4037fe9c <calloc>)
4200b871:	0008e0        	callx8	a8
4200b874:	0a6d      	mov.n	a6, a10
    ESP_GOTO_ON_FALSE((obj != NULL), ESP_ERR_NO_MEM, err, TAG, "insufficient memory");
4200b876:	4aec      	bnez.n	a10, 4200b89e <esp_task_wdt_init+0x96>
4200b878:	d1fa81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b87b:	0008e0        	callx8	a8
4200b87e:	d4e0b1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b881:	0ba282        	movi	a8, 0x20b
4200b884:	0189      	s32i.n	a8, a1, 0
4200b886:	d4fbf1        	l32r	a15, 42000c74 <_stext+0xc54> (3c027b88 <__FUNCTION__$14>)
4200b889:	0bed      	mov.n	a14, a11
4200b88b:	0add      	mov.n	a13, a10
4200b88d:	d4fcc1        	l32r	a12, 42000c80 <_stext+0xc60> (3c025a24 <_flash_rodata_start+0x5904>)
4200b890:	1a0c      	movi.n	a10, 1
4200b892:	d20081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200b895:	0008e0        	callx8	a8
4200b898:	01a122        	movi	a2, 0x101
4200b89b:	001246        	j	4200b8e8 <esp_task_wdt_init+0xe0>
    SLIST_INIT(&obj->entries_slist);
4200b89e:	00a082        	movi	a8, 0
4200b8a1:	016a82        	s32i	a8, a10, 4
    obj->panic = config->trigger_panic;
4200b8a4:	080282        	l8ui	a8, a2, 8
4200b8a7:	0c4a82        	s8i	a8, a10, 12
    ret = esp_task_wdt_impl_timer_allocate(config, task_wdt_isr, &obj->impl_ctx);
4200b8aa:	0acd      	mov.n	a12, a10
4200b8ac:	d4f6b1        	l32r	a11, 42000c84 <_stext+0xc64> (4200bba8 <task_wdt_isr>)
4200b8af:	02ad      	mov.n	a10, a2
4200b8b1:	003c25        	call8	4200bc74 <esp_task_wdt_impl_timer_allocate>
4200b8b4:	0a2d      	mov.n	a2, a10
    if (ret != ESP_OK) {
4200b8b6:	eaec      	bnez.n	a10, 4200b8e8 <esp_task_wdt_init+0xe0>
    p_twdt_obj = obj;
4200b8b8:	d4ce81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b8bb:	0869      	s32i.n	a6, a8, 0
    p_twdt_obj->idle_core_mask = config->idle_core_mask;
4200b8bd:	17a8      	l32i.n	a10, a7, 4
4200b8bf:	0266a2        	s32i	a10, a6, 8
    if (config->idle_core_mask) {
4200b8c2:	002a16        	beqz	a10, 4200b8c8 <esp_task_wdt_init+0xc0>
        subscribe_idle(config->idle_core_mask);
4200b8c5:	ffeda5        	call8	4200b7a0 <subscribe_idle>
    if (!SLIST_EMPTY(&p_twdt_obj->entries_slist)) {
4200b8c8:	d4ca81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b8cb:	0888      	l32i.n	a8, a8, 0
4200b8cd:	1898      	l32i.n	a9, a8, 4
4200b8cf:	d98c      	beqz.n	a9, 4200b8e0 <esp_task_wdt_init+0xd8>
        p_twdt_obj->waiting_for_task = false;
4200b8d1:	090c      	movi.n	a9, 0
4200b8d3:	0d4892        	s8i	a9, a8, 13
        esp_task_wdt_impl_timer_restart(p_twdt_obj->impl_ctx);
4200b8d6:	0028a2        	l32i	a10, a8, 0
4200b8d9:	0054a5        	call8	4200be24 <esp_task_wdt_impl_timer_restart>
4200b8dc:	000406        	j	4200b8f0 <esp_task_wdt_init+0xe8>
4200b8df:	00          	.byte	00
        p_twdt_obj->waiting_for_task = true;
4200b8e0:	190c      	movi.n	a9, 1
4200b8e2:	0d4892        	s8i	a9, a8, 13
4200b8e5:	0001c6        	j	4200b8f0 <esp_task_wdt_init+0xe8>
    free(obj);
4200b8e8:	06ad      	mov.n	a10, a6
4200b8ea:	d32081        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200b8ed:	0008e0        	callx8	a8
}
4200b8f0:	f01d      	retw.n
	...

4200b8f4 <esp_task_wdt_reset>:
    }
    return ret;
}

esp_err_t TASK_WDT_FN_ATTR esp_task_wdt_reset(void)
{
4200b8f4:	008136        	entry	a1, 64
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
4200b8f7:	d4be81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b8fa:	0888      	l32i.n	a8, a8, 0
4200b8fc:	98ec      	bnez.n	a8, 4200b929 <esp_task_wdt_reset+0x35>
4200b8fe:	d1d881        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b901:	0008e0        	callx8	a8
4200b904:	d4bfb1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b907:	baa282        	movi	a8, 0x2ba
4200b90a:	0189      	s32i.n	a8, a1, 0
4200b90c:	d4dff1        	l32r	a15, 42000c88 <_stext+0xc68> (3c027b0c <__FUNCTION__$5>)
4200b90f:	0bed      	mov.n	a14, a11
4200b911:	20daa0        	or	a13, a10, a10
4200b914:	d4d0c1        	l32r	a12, 42000c54 <_stext+0xc34> (3c0258f4 <_flash_rodata_start+0x57d4>)
4200b917:	01a0a2        	movi	a10, 1
4200b91a:	d1de81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200b91d:	0008e0        	callx8	a8
4200b920:	03a122        	movi	a2, 0x103
4200b923:	001a46        	j	4200b990 <esp_task_wdt_reset+0x9c>
4200b926:	000000        	ill
    esp_err_t ret;
    TaskHandle_t handle = xTaskGetCurrentTaskHandle();
4200b929:	d2a881        	l32r	a8, 420003cc <_stext+0x3ac> (4037b778 <xTaskGetCurrentTaskHandle>)
4200b92c:	0008e0        	callx8	a8
4200b92f:	0a7d      	mov.n	a7, a10
4200b931:	fb7c      	movi.n	a11, -1
4200b933:	d4b1a1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b936:	d2be81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200b939:	0008e0        	callx8	a8

    portENTER_CRITICAL(&spinlock);
    // Find entry from task handle
    bool all_reset;
    twdt_entry_t *entry;
    entry = find_entry_from_task_handle_and_check_all_reset(handle, &all_reset);
4200b93c:	10c1b2        	addi	a11, a1, 16
4200b93f:	20a770        	or	a10, a7, a7
4200b942:	ff9ee5        	call8	4200b330 <find_entry_from_task_handle_and_check_all_reset>
    ESP_GOTO_ON_FALSE_ISR((entry != NULL), ESP_ERR_NOT_FOUND, err, TAG, "task not found");
4200b945:	5aec      	bnez.n	a10, 4200b96e <esp_task_wdt_reset+0x7a>
4200b947:	d1b981        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200b94a:	0888      	l32i.n	a8, a8, 0
4200b94c:	889c      	beqz.n	a8, 4200b968 <esp_task_wdt_reset+0x74>
4200b94e:	d1c481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b951:	0008e0        	callx8	a8
4200b954:	c3a2e2        	movi	a14, 0x2c3
4200b957:	d4ccd1        	l32r	a13, 42000c88 <_stext+0xc68> (3c027b0c <__FUNCTION__$5>)
4200b95a:	d4a9c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b95d:	0abd      	mov.n	a11, a10
4200b95f:	d4aea1        	l32r	a10, 42000c18 <_stext+0xbf8> (3c0257fc <_flash_rodata_start+0x56dc>)
4200b962:	d1c081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200b965:	0008e0        	callx8	a8
4200b968:	05a122        	movi	a2, 0x105
4200b96b:	000606        	j	4200b987 <esp_task_wdt_reset+0x93>
    // Mark entry as reset and issue timer reset if all entries have been reset
    entry->has_reset = true;    // Reset the task if it's on the task list
4200b96e:	01a082        	movi	a8, 1
4200b971:	0c4a82        	s8i	a8, a10, 12
    if (all_reset) {    // Reset if all other tasks in list have reset in
4200b974:	100182        	l8ui	a8, a1, 16
4200b977:	00a816        	beqz	a8, 4200b985 <esp_task_wdt_reset+0x91>
        task_wdt_timer_feed();
4200b97a:	ff9ee5        	call8	4200b368 <task_wdt_timer_feed>
    }
    ret = ESP_OK;
4200b97d:	00a022        	movi	a2, 0
4200b980:	0000c6        	j	4200b987 <esp_task_wdt_reset+0x93>
4200b983:	00          	.byte	00
4200b984:	020c00        	andb	b0, b12, b0
err:
    portEXIT_CRITICAL(&spinlock);
4200b987:	d49ca1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200b98a:	d2aa81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200b98d:	0008e0        	callx8	a8

    return ret;
}
4200b990:	f01d      	retw.n
	...

4200b994 <idle_hook_cb>:
{
4200b994:	004136        	entry	a1, 32
    esp_task_wdt_reset();
4200b997:	fff5e5        	call8	4200b8f4 <esp_task_wdt_reset>
}
4200b99a:	120c      	movi.n	a2, 1
4200b99c:	f01d      	retw.n
	...

4200b9a0 <esp_task_wdt_delete>:

    return ret;
}

esp_err_t esp_task_wdt_delete(TaskHandle_t task_handle)
{
4200b9a0:	006136        	entry	a1, 48
4200b9a3:	02bd      	mov.n	a11, a2
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
4200b9a5:	d49281        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200b9a8:	002882        	l32i	a8, a8, 0
4200b9ab:	027856        	bnez	a8, 4200b9d6 <esp_task_wdt_delete+0x36>
4200b9ae:	d1ac81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200b9b1:	0008e0        	callx8	a8
4200b9b4:	d493b1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200b9b7:	eaa282        	movi	a8, 0x2ea
4200b9ba:	0189      	s32i.n	a8, a1, 0
4200b9bc:	d4b4f1        	l32r	a15, 42000c8c <_stext+0xc6c> (3c027af8 <__FUNCTION__$3>)
4200b9bf:	0bed      	mov.n	a14, a11
4200b9c1:	20daa0        	or	a13, a10, a10
4200b9c4:	d4a4c1        	l32r	a12, 42000c54 <_stext+0xc34> (3c0258f4 <_flash_rodata_start+0x57d4>)
4200b9c7:	01a0a2        	movi	a10, 1
4200b9ca:	d1b281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200b9cd:	0008e0        	callx8	a8
4200b9d0:	03a122        	movi	a2, 0x103
4200b9d3:	0004c6        	j	4200b9ea <esp_task_wdt_delete+0x4a>
    esp_err_t ret;
    if (task_handle == NULL) {
4200b9d6:	008256        	bnez	a2, 4200b9e2 <esp_task_wdt_delete+0x42>
        task_handle = xTaskGetCurrentTaskHandle();
4200b9d9:	d27c81        	l32r	a8, 420003cc <_stext+0x3ac> (4037b778 <xTaskGetCurrentTaskHandle>)
4200b9dc:	0008e0        	callx8	a8
4200b9df:	20baa0        	or	a11, a10, a10
    }

    ret = delete_entry(true, (void *)task_handle);
4200b9e2:	01a0a2        	movi	a10, 1
4200b9e5:	ffaba5        	call8	4200b4a0 <delete_entry>
4200b9e8:	0a2d      	mov.n	a2, a10
    return ret;
}
4200b9ea:	f01d      	retw.n

4200b9ec <unsubscribe_idle>:
{
4200b9ec:	004136        	entry	a1, 32
    int core_num = 0;
4200b9ef:	070c      	movi.n	a7, 0
    while (core_mask != 0) {
4200b9f1:	001246        	j	4200ba3e <unsubscribe_idle+0x52>
4200b9f4:	620700        	saltu	a0, a7, a0
        if (core_mask & 0x1) {
4200b9f7:	07ad40        	ee.stf.64.xp	f10, f0, a4, a13
            TaskHandle_t idle_task_handle = xTaskGetIdleTaskHandleForCore(core_num);
4200b9fa:	d49d81        	l32r	a8, 42000c70 <_stext+0xc50> (4037c724 <xTaskGetIdleTaskHandleForCore>)
4200b9fd:	0008e0        	callx8	a8
4200ba00:	0a6d      	mov.n	a6, a10
            assert(idle_task_handle);
4200ba02:	0adc      	bnez.n	a10, 4200ba16 <unsubscribe_idle+0x2a>
4200ba04:	d495d1        	l32r	a13, 42000c58 <_stext+0xc38> (3c025924 <_flash_rodata_start+0x5804>)
4200ba07:	d4a2c1        	l32r	a12, 42000c90 <_stext+0xc70> (3c027b54 <__func__$10>)
4200ba0a:	1da1b2        	movi	a11, 0x11d
4200ba0d:	d487a1        	l32r	a10, 42000c2c <_stext+0xc0c> (3c025891 <_flash_rodata_start+0x5771>)
4200ba10:	d1be81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200ba13:	0008e0        	callx8	a8
            esp_deregister_freertos_idle_hook_for_cpu(idle_hook_cb, core_num);
4200ba16:	20b770        	or	a11, a7, a7
4200ba19:	d493a1        	l32r	a10, 42000c68 <_stext+0xc48> (4200b994 <idle_hook_cb>)
4200ba1c:	f70da5        	call8	42002af8 <esp_deregister_freertos_idle_hook_for_cpu>
            ESP_ERROR_CHECK(esp_task_wdt_delete(idle_task_handle));
4200ba1f:	20a660        	or	a10, a6, a6
4200ba22:	fff7e5        	call8	4200b9a0 <esp_task_wdt_delete>
4200ba25:	0a9c      	beqz.n	a10, 4200ba39 <unsubscribe_idle+0x4d>
4200ba27:	d49be1        	l32r	a14, 42000c94 <_stext+0xc74> (3c025a50 <_flash_rodata_start+0x5930>)
4200ba2a:	d499d1        	l32r	a13, 42000c90 <_stext+0xc70> (3c027b54 <__func__$10>)
4200ba2d:	1fa1c2        	movi	a12, 0x11f
4200ba30:	d48db1        	l32r	a11, 42000c64 <_stext+0xc44> (3c02595c <_flash_rodata_start+0x583c>)
4200ba33:	d38081        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200ba36:	0008e0        	callx8	a8
        core_mask >>= 1;
4200ba39:	412120        	srli	a2, a2, 1
        core_num++;
4200ba3c:	771b      	addi.n	a7, a7, 1
    while (core_mask != 0) {
4200ba3e:	fb3256        	bnez	a2, 4200b9f5 <unsubscribe_idle+0x9>
}
4200ba41:	f01d      	retw.n
	...

4200ba44 <esp_task_wdt_deinit>:
{
4200ba44:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
4200ba47:	d46a81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200ba4a:	0888      	l32i.n	a8, a8, 0
4200ba4c:	68ec      	bnez.n	a8, 4200ba76 <esp_task_wdt_deinit+0x32>
4200ba4e:	d18481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ba51:	0008e0        	callx8	a8
4200ba54:	d46bb1        	l32r	a11, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200ba57:	84a282        	movi	a8, 0x284
4200ba5a:	0189      	s32i.n	a8, a1, 0
4200ba5c:	d48ff1        	l32r	a15, 42000c98 <_stext+0xc78> (3c027b40 <__FUNCTION__$9>)
4200ba5f:	0bed      	mov.n	a14, a11
4200ba61:	20daa0        	or	a13, a10, a10
4200ba64:	d47cc1        	l32r	a12, 42000c54 <_stext+0xc34> (3c0258f4 <_flash_rodata_start+0x57d4>)
4200ba67:	01a0a2        	movi	a10, 1
4200ba6a:	d18a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200ba6d:	0008e0        	callx8	a8
4200ba70:	03a122        	movi	a2, 0x103
4200ba73:	001786        	j	4200bad5 <esp_task_wdt_deinit+0x91>
    unsubscribe_idle(p_twdt_obj->idle_core_mask);
4200ba76:	0228a2        	l32i	a10, a8, 8
4200ba79:	fff725        	call8	4200b9ec <unsubscribe_idle>
    ESP_GOTO_ON_FALSE_ISR(SLIST_EMPTY(&p_twdt_obj->entries_slist), ESP_ERR_INVALID_STATE, err, TAG, "Tasks/users still subscribed");
4200ba7c:	d45d81        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200ba7f:	002882        	l32i	a8, a8, 0
4200ba82:	1898      	l32i.n	a9, a8, 4
4200ba84:	09bc      	beqz.n	a9, 4200bab8 <esp_task_wdt_deinit+0x74>
4200ba86:	d16981        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200ba89:	0888      	l32i.n	a8, a8, 0
4200ba8b:	889c      	beqz.n	a8, 4200baa7 <esp_task_wdt_deinit+0x63>
4200ba8d:	d17481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200ba90:	0008e0        	callx8	a8
4200ba93:	8aa2e2        	movi	a14, 0x28a
4200ba96:	d480d1        	l32r	a13, 42000c98 <_stext+0xc78> (3c027b40 <__FUNCTION__$9>)
4200ba99:	d459c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200ba9c:	0abd      	mov.n	a11, a10
4200ba9e:	d47fa1        	l32r	a10, 42000c9c <_stext+0xc7c> (3c025a78 <_flash_rodata_start+0x5958>)
4200baa1:	d17081        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200baa4:	0008e0        	callx8	a8
    subscribe_idle(p_twdt_obj->idle_core_mask); // Resubscribe idle tasks
4200baa7:	d45281        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200baaa:	0888      	l32i.n	a8, a8, 0
4200baac:	28a8      	l32i.n	a10, a8, 8
4200baae:	ffcf25        	call8	4200b7a0 <subscribe_idle>
    return ret;
4200bab1:	03a122        	movi	a2, 0x103
4200bab4:	000746        	j	4200bad5 <esp_task_wdt_deinit+0x91>
4200bab7:	00          	.byte	00
    esp_task_wdt_impl_timer_stop(p_twdt_obj->impl_ctx);
4200bab8:	0028a2        	l32i	a10, a8, 0
4200babb:	0033e5        	call8	4200bdf8 <esp_task_wdt_impl_timer_stop>
    esp_task_wdt_impl_timer_free(p_twdt_obj->impl_ctx);
4200babe:	d44c71        	l32r	a7, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200bac1:	002782        	l32i	a8, a7, 0
4200bac4:	08a8      	l32i.n	a10, a8, 0
4200bac6:	002925        	call8	4200bd58 <esp_task_wdt_impl_timer_free>
    free(p_twdt_obj);
4200bac9:	07a8      	l32i.n	a10, a7, 0
4200bacb:	d2a881        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200bace:	0008e0        	callx8	a8
    p_twdt_obj = NULL;
4200bad1:	020c      	movi.n	a2, 0
4200bad3:	0729      	s32i.n	a2, a7, 0
}
4200bad5:	f01d      	retw.n
	...

4200bad8 <esp_task_wdt_print_triggered_tasks>:

    return ret;
}

esp_err_t esp_task_wdt_print_triggered_tasks(task_wdt_msg_handler msg_handler, void *opaque, int *cpus_fail)
{
4200bad8:	004136        	entry	a1, 32
    if (SLIST_EMPTY(&p_twdt_obj->entries_slist)) {
4200badb:	d44581        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200bade:	0888      	l32i.n	a8, a8, 0
4200bae0:	1888      	l32i.n	a8, a8, 4
4200bae2:	0bc816        	beqz	a8, 4200bba2 <esp_task_wdt_print_triggered_tasks+0xca>

    twdt_entry_t *entry;
    const char *caption = "Task watchdog got triggered. "
                          "The following tasks/users did not reset the watchdog in time:";

    if (msg_handler == NULL) {
4200bae5:	f2dc      	bnez.n	a2, 4200bb08 <esp_task_wdt_print_triggered_tasks+0x30>
4200bae7:	d15181        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200baea:	0888      	l32i.n	a8, a8, 0
        ESP_EARLY_LOGE(TAG, "%s", caption);
4200baec:	08ac      	beqz.n	a8, 4200bb10 <esp_task_wdt_print_triggered_tasks+0x38>
4200baee:	d15c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200baf1:	0008e0        	callx8	a8
4200baf4:	d46ed1        	l32r	a13, 42000cac <_stext+0xc8c> (3c025ad0 <_flash_rodata_start+0x59b0>)
4200baf7:	d442c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200bafa:	0abd      	mov.n	a11, a10
4200bafc:	d46da1        	l32r	a10, 42000cb0 <_stext+0xc90> (3c025b2c <_flash_rodata_start+0x5a0c>)
4200baff:	d15981        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200bb02:	0008e0        	callx8	a8
4200bb05:	0001c6        	j	4200bb10 <esp_task_wdt_print_triggered_tasks+0x38>
    } else {
        msg_handler(opaque, caption);
4200bb08:	d469b1        	l32r	a11, 42000cac <_stext+0xc8c> (3c025ad0 <_flash_rodata_start+0x59b0>)
4200bb0b:	03ad      	mov.n	a10, a3
4200bb0d:	0002e0        	callx8	a2
    }

    // Find what entries triggered the TWDT timeout (i.e., which entries have not been reset)
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200bb10:	d43881        	l32r	a8, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200bb13:	0888      	l32i.n	a8, a8, 0
4200bb15:	1878      	l32i.n	a7, a8, 4
4200bb17:	001fc6        	j	4200bb9a <esp_task_wdt_print_triggered_tasks+0xc2>
4200bb1a:	820000        	mull	a0, a0, a0
        if (!entry->has_reset) {
4200bb1d:	560c07        	bnone	a12, a0, 4200bb77 <esp_task_wdt_print_triggered_tasks+0x9f>
4200bb20:	0758      	l32i.n	a5, a7, 0
            const char *cpu;
            const char *name = entry->task_handle ? pcTaskGetName(entry->task_handle) : entry->user_name;
4200bb22:	17a8      	l32i.n	a10, a7, 4
4200bb24:	aa8c      	beqz.n	a10, 4200bb32 <esp_task_wdt_print_triggered_tasks+0x5a>
4200bb26:	d46581        	l32r	a8, 42000cbc <_stext+0xc9c> (4037b910 <pcTaskGetName>)
4200bb29:	0008e0        	callx8	a8
4200bb2c:	0a6d      	mov.n	a6, a10
4200bb2e:	0000c6        	j	4200bb35 <esp_task_wdt_print_triggered_tasks+0x5d>
4200bb31:	276200        	ee.stf.64.xp	f6, f2, a0, a2
4200bb34:	27a202        	movi	a0, 0x227
            const UBaseType_t affinity = get_task_affinity(entry->task_handle);
4200bb37:	a7a501        	l32r	a0, 41ff59cc <_iram_bss_end+0x1c735cc>
4200bb3a:	006416ff 	ee.vmulas.s16.accx.ld.ip.qup	q0, a15, 96, q4, q2, q6, q4
            if (cpus_fail) {
                *cpus_fail |= affinity;
4200bb3e:	0488      	l32i.n	a8, a4, 0
4200bb40:	208a80        	or	a8, a10, a8
4200bb43:	0489      	s32i.n	a8, a4, 0
            }
            if (affinity == BIT(0)) {
4200bb45:	081a26        	beqi	a10, 1, 4200bb51 <esp_task_wdt_print_triggered_tasks+0x79>
                cpu = " (CPU 0)";
            } else if (affinity == BIT(1)) {
4200bb48:	0c2a66        	bnei	a10, 2, 4200bb58 <esp_task_wdt_print_triggered_tasks+0x80>
                cpu = " (CPU 1)";
4200bb4b:	d45651        	l32r	a5, 42000ca4 <_stext+0xc84> (3c025ab8 <_flash_rodata_start+0x5998>)
4200bb4e:	000246        	j	4200bb5b <esp_task_wdt_print_triggered_tasks+0x83>
                cpu = " (CPU 0)";
4200bb51:	d45351        	l32r	a5, 42000ca0 <_stext+0xc80> (3c025aac <_flash_rodata_start+0x598c>)
4200bb54:	0000c6        	j	4200bb5b <esp_task_wdt_print_triggered_tasks+0x83>
4200bb57:	545100        	extui	a5, a0, 1, 6
            } else {
                cpu = " (CPU 0/1)";
4200bb5a:	d4          	.byte	0xd4
            }
            if (msg_handler == NULL) {
4200bb5b:	22ec      	bnez.n	a2, 4200bb81 <esp_task_wdt_print_triggered_tasks+0xa9>
4200bb5d:	d13381        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
4200bb60:	0888      	l32i.n	a8, a8, 0
                ESP_EARLY_LOGE(TAG, " - %s%s", name, cpu);
4200bb62:	28bc      	beqz.n	a8, 4200bb98 <esp_task_wdt_print_triggered_tasks+0xc0>
4200bb64:	d13f81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200bb67:	0008e0        	callx8	a8
4200bb6a:	05ed      	mov.n	a14, a5
4200bb6c:	06dd      	mov.n	a13, a6
4200bb6e:	d424c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200bb71:	0abd      	mov.n	a11, a10
4200bb73:	d450a1        	l32r	a10, 42000cb4 <_stext+0xc94> (3c025b3c <_flash_rodata_start+0x5a1c>)
4200bb76:	d13b81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200bb79:	0008e0        	callx8	a8
4200bb7c:	000606        	j	4200bb98 <esp_task_wdt_print_triggered_tasks+0xc0>
4200bb7f:	b10000        	sra	a0, a0
            } else {
                msg_handler(opaque, "\n - ");
4200bb82:	4d          	.byte	0x4d
4200bb83:	a330d4        	ee.vld.128.ip	q4, a13, 0x300
4200bb86:	02e020        	andb	b14, b0, b2
4200bb89:	06bd00        	ee.ldf.64.xp	f11, f0, a0, a13
                msg_handler(opaque, name);
4200bb8c:	03ad      	mov.n	a10, a3
4200bb8e:	0002e0        	callx8	a2
                msg_handler(opaque, cpu);
4200bb91:	05bd      	mov.n	a11, a5
4200bb93:	03ad      	mov.n	a10, a3
4200bb95:	0002e0        	callx8	a2
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
4200bb98:	0778      	l32i.n	a7, a7, 0
4200bb9a:	f7e756        	bnez	a7, 4200bb1c <esp_task_wdt_print_triggered_tasks+0x44>
            }
        }
    }
    return ESP_OK;
4200bb9d:	020c      	movi.n	a2, 0
4200bb9f:	000046        	j	4200bba4 <esp_task_wdt_print_triggered_tasks+0xcc>
        return ESP_FAIL;
4200bba2:	f27c      	movi.n	a2, -1
}
4200bba4:	f01d      	retw.n
	...

4200bba8 <task_wdt_isr>:
{
4200bba8:	006136        	entry	a1, 48
4200bbab:	fb7c      	movi.n	a11, -1
4200bbad:	d412a1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200bbb0:	d22081        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4200bbb3:	0008e0        	callx8	a8
    esp_task_wdt_impl_timeout_triggered(p_twdt_obj->impl_ctx);
4200bbb6:	d40e71        	l32r	a7, 42000bf0 <_stext+0xbd0> (3fc953d8 <p_twdt_obj>)
4200bbb9:	0788      	l32i.n	a8, a7, 0
4200bbbb:	08a8      	l32i.n	a10, a8, 0
4200bbbd:	0021a5        	call8	4200bdd8 <esp_task_wdt_impl_timeout_triggered>
    int cpus_fail = 0;
4200bbc0:	0a0c      	movi.n	a10, 0
4200bbc2:	01a9      	s32i.n	a10, a1, 0
    bool panic = p_twdt_obj->panic;
4200bbc4:	0788      	l32i.n	a8, a7, 0
4200bbc6:	0c0862        	l8ui	a6, a8, 12
    if (esp_task_wdt_print_triggered_tasks(NULL, NULL, &cpus_fail) != ESP_OK) {
4200bbc9:	20c110        	or	a12, a1, a1
4200bbcc:	0abd      	mov.n	a11, a10
4200bbce:	fff0a5        	call8	4200bad8 <esp_task_wdt_print_triggered_tasks>
4200bbd1:	207aa0        	or	a7, a10, a10
4200bbd4:	00da16        	beqz	a10, 4200bbe5 <task_wdt_isr+0x3d>
        portEXIT_CRITICAL_ISR(&spinlock);
4200bbd7:	d408a1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200bbda:	d21681        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200bbdd:	0008e0        	callx8	a8
        return;
4200bbe0:	0022c6        	j	4200bc6f <task_wdt_isr+0xc7>
4200bbe3:	810000        	src	a0, a0, a0
4200bbe6:	82d111        	l32r	a1, 41fec72c <_iram_bss_end+0x1c6a32c>
4200bbe9:	0028      	l32i.n	a2, a0, 0
    ESP_EARLY_LOGE(TAG, "%s", DRAM_STR("Tasks currently running:"));
4200bbeb:	04d816        	beqz	a8, 4200bc3c <task_wdt_isr+0x94>
4200bbee:	d11c81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200bbf1:	0008e0        	callx8	a8
4200bbf4:	d433d1        	l32r	a13, 42000cc0 <_stext+0xca0> (3fc93ae4 <__c$16>)
4200bbf7:	d402c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200bbfa:	0abd      	mov.n	a11, a10
4200bbfc:	d42da1        	l32r	a10, 42000cb0 <_stext+0xc90> (3c025b2c <_flash_rodata_start+0x5a0c>)
4200bbff:	d11981        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200bc02:	0008e0        	callx8	a8
4200bc05:	000cc6        	j	4200bc3c <task_wdt_isr+0x94>
4200bc08:	088100        	lsx	f8, a1, a0
4200bc0b:	0888d1        	l32r	a13, 41fcde2c <_iram_bss_end+0x1c4ba2c>
        ESP_EARLY_LOGE(TAG, "CPU %d: %s", x, pcTaskGetName(xTaskGetCurrentTaskHandleForCore(x)));
4200bc0e:	88ac      	beqz.n	a8, 4200bc3a <task_wdt_isr+0x92>
4200bc10:	d11481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200bc13:	0008e0        	callx8	a8
4200bc16:	0a5d      	mov.n	a5, a10
4200bc18:	07ad      	mov.n	a10, a7
4200bc1a:	d42e81        	l32r	a8, 42000cd4 <_stext+0xcb4> (4037c758 <xTaskGetCurrentTaskHandleForCore>)
4200bc1d:	0008e0        	callx8	a8
4200bc20:	d42781        	l32r	a8, 42000cbc <_stext+0xc9c> (4037b910 <pcTaskGetName>)
4200bc23:	0008e0        	callx8	a8
4200bc26:	0aed      	mov.n	a14, a10
4200bc28:	20d770        	or	a13, a7, a7
4200bc2b:	d3f5c1        	l32r	a12, 42000c00 <_stext+0xbe0> (3c025754 <_flash_rodata_start+0x5634>)
4200bc2e:	20b550        	or	a11, a5, a5
4200bc31:	d424a1        	l32r	a10, 42000cc4 <_stext+0xca4> (3c025b5c <_flash_rodata_start+0x5a3c>)
4200bc34:	d10c81        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
4200bc37:	0008e0        	callx8	a8
    for (int x = 0; x < CONFIG_FREERTOS_NUMBER_OF_CORES; x++) {
4200bc3a:	771b      	addi.n	a7, a7, 1
4200bc3c:	c927a6        	blti	a7, 2, 4200bc09 <task_wdt_isr+0x61>
    portEXIT_CRITICAL_ISR(&spinlock);
4200bc3f:	d3eea1        	l32r	a10, 42000bf8 <_stext+0xbd8> (3fc92a84 <spinlock>)
4200bc42:	d1fc81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4200bc45:	0008e0        	callx8	a8
    if (esp_task_wdt_isr_user_handler != NULL) {
4200bc48:	d42081        	l32r	a8, 42000cc8 <_stext+0xca8> (0 <IDF_TARGET_ESP32S3>)
4200bc4b:	005816        	beqz	a8, 4200bc54 <task_wdt_isr+0xac>
        esp_task_wdt_isr_user_handler();
4200bc4e:	d41e81        	l32r	a8, 42000cc8 <_stext+0xca8> (0 <IDF_TARGET_ESP32S3>)
4200bc51:	0008e0        	callx8	a8
    assert(cpus_fail != 0);
4200bc54:	01a8      	l32i.n	a10, a1, 0
4200bc56:	0adc      	bnez.n	a10, 4200bc6a <task_wdt_isr+0xc2>
4200bc58:	d41dd1        	l32r	a13, 42000ccc <_stext+0xcac> (3c025b74 <_flash_rodata_start+0x5a54>)
4200bc5b:	d41dc1        	l32r	a12, 42000cd0 <_stext+0xcb0> (3c027b78 <__func__$13>)
4200bc5e:	fca1b2        	movi	a11, 0x1fc
4200bc61:	d3f2a1        	l32r	a10, 42000c2c <_stext+0xc0c> (3c025891 <_flash_rodata_start+0x5771>)
4200bc64:	d12981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200bc67:	0008e0        	callx8	a8
    task_wdt_timeout_handling(cpus_fail, panic);
4200bc6a:	06bd      	mov.n	a11, a6
4200bc6c:	ffa2a5        	call8	4200b698 <task_wdt_timeout_handling>
}
4200bc6f:	f01d      	retw.n
4200bc71:	000000        	ill

4200bc74 <esp_task_wdt_impl_timer_allocate>:
{
4200bc74:	004136        	entry	a1, 32
    if (config == NULL || obj == NULL) {
4200bc77:	40f280        	nsau	a8, a2
4200bc7a:	418580        	srli	a8, a8, 5
4200bc7d:	40f490        	nsau	a9, a4
4200bc80:	419590        	srli	a9, a9, 5
4200bc83:	208890        	or	a8, a8, a9
4200bc86:	0c6856        	bnez	a8, 4200bd50 <esp_task_wdt_impl_timer_allocate+0xdc>
        esp_intr_alloc(TWDT_INTR_SOURCE, 0, callback, NULL, &ctx->intr_handle);
4200bc89:	d413e1        	l32r	a14, 42000cd8 <_stext+0xcb8> (3fc953e8 <init_context+0x8>)
4200bc8c:	00a0d2        	movi	a13, 0
4200bc8f:	20c330        	or	a12, a3, a3
4200bc92:	20bdd0        	or	a11, a13, a13
4200bc95:	4a3c      	movi.n	a10, 52
4200bc97:	f7d825        	call8	42003a18 <esp_intr_alloc>
        PERIPH_RCC_ACQUIRE_ATOMIC(TWDT_PERIPH_MODULE, ref_count) {
4200bc9a:	130c      	movi.n	a3, 1
4200bc9c:	0014c6        	j	4200bcf3 <esp_task_wdt_impl_timer_allocate+0x7f>
4200bc9f:	810000        	src	a0, a0, a0
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
4200bca2:	d16c      	movi.n	a1, -19
4200bca4:	0020c0        	memw
4200bca7:	6898      	l32i.n	a9, a8, 24
4200bca9:	d2bca1        	l32r	a10, 4200079c <_stext+0x77c> (2000 <UserFrameTotalSize+0x1f00>)
4200bcac:	2099a0        	or	a9, a9, a10
4200bcaf:	0020c0        	memw
4200bcb2:	6899      	s32i.n	a9, a8, 24
        SYSTEM.perip_rst_en0.timergroup_rst = 1;
4200bcb4:	0020c0        	memw
4200bcb7:	8898      	l32i.n	a9, a8, 32
4200bcb9:	2099a0        	or	a9, a9, a10
4200bcbc:	0020c0        	memw
4200bcbf:	8899      	s32i.n	a9, a8, 32
        SYSTEM.perip_rst_en0.timergroup_rst = 0;
4200bcc1:	0020c0        	memw
4200bcc4:	8898      	l32i.n	a9, a8, 32
4200bcc6:	d34fa1        	l32r	a10, 42000a04 <_stext+0x9e4> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4200bcc9:	1099a0        	and	a9, a9, a10
4200bccc:	0020c0        	memw
4200bccf:	8899      	s32i.n	a9, a8, 32
        TIMERG0.wdtconfig0.wdt_flashboot_mod_en = 0;
4200bcd1:	d34391        	l32r	a9, 420009e0 <_stext+0x9c0> (6001f000 <TIMERG0>)
4200bcd4:	0020c0        	memw
4200bcd7:	122982        	l32i	a8, a9, 72
4200bcda:	d162a1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
4200bcdd:	1088a0        	and	a8, a8, a10
4200bce0:	0020c0        	memw
4200bce3:	126982        	s32i	a8, a9, 72
4200bce6:	aa0c      	movi.n	a10, 10
4200bce8:	d16381        	l32r	a8, 42000274 <_stext+0x254> (40378200 <periph_rcc_acquire_exit>)
4200bceb:	0008e0        	callx8	a8
4200bcee:	330b      	addi.n	a3, a3, -1
4200bcf0:	743030        	extui	a3, a3, 0, 8
4200bcf3:	049356        	bnez	a3, 4200bd40 <esp_task_wdt_impl_timer_allocate+0xcc>
        wdt_hal_init(&ctx->hal, TWDT_INSTANCE, TWDT_PRESCALER, true);
4200bcf6:	d3f931        	l32r	a3, 42000cdc <_stext+0xcbc> (3fc953e0 <init_context>)
4200bcf9:	1d0c      	movi.n	a13, 1
4200bcfb:	d15bc1        	l32r	a12, 42000268 <_stext+0x248> (9c40 <UserFrameTotalSize+0x9b40>)
4200bcfe:	0dbd      	mov.n	a11, a13
4200bd00:	03ad      	mov.n	a10, a3
4200bd02:	d15e81        	l32r	a8, 4200027c <_stext+0x25c> (40000dbc <wdt_hal_init>)
4200bd05:	0008e0        	callx8	a8
        wdt_hal_write_protect_disable(&ctx->hal);
4200bd08:	03ad      	mov.n	a10, a3
4200bd0a:	d10381        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
4200bd0d:	0008e0        	callx8	a8
        wdt_hal_config_stage(&ctx->hal, WDT_STAGE0, config->timeout_ms * (1000 / TWDT_TICKS_PER_US), WDT_STAGE_ACTION_INT);
4200bd10:	02c8      	l32i.n	a12, a2, 0
4200bd12:	1d0c      	movi.n	a13, 1
4200bd14:	ccca      	add.n	a12, a12, a12
4200bd16:	0b0c      	movi.n	a11, 0
4200bd18:	03ad      	mov.n	a10, a3
4200bd1a:	d12481        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
4200bd1d:	0008e0        	callx8	a8
        wdt_hal_config_stage(&ctx->hal, WDT_STAGE1, config->timeout_ms * (2 * 1000 / TWDT_TICKS_PER_US), WDT_STAGE_ACTION_RESET_SYSTEM);
4200bd20:	02c8      	l32i.n	a12, a2, 0
4200bd22:	3d0c      	movi.n	a13, 3
4200bd24:	11cce0        	slli	a12, a12, 2
4200bd27:	1b0c      	movi.n	a11, 1
4200bd29:	03ad      	mov.n	a10, a3
4200bd2b:	d12081        	l32r	a8, 420001ac <_stext+0x18c> (40000dd4 <wdt_hal_config_stage>)
4200bd2e:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
4200bd31:	03ad      	mov.n	a10, a3
4200bd33:	d0fb81        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
4200bd36:	0008e0        	callx8	a8
        *obj = (twdt_ctx_t) ctx;
4200bd39:	0439      	s32i.n	a3, a4, 0
    esp_err_t ret = ESP_OK;
4200bd3b:	020c      	movi.n	a2, 0
4200bd3d:	000486        	j	4200bd53 <esp_task_wdt_impl_timer_allocate+0xdf>
        PERIPH_RCC_ACQUIRE_ATOMIC(TWDT_PERIPH_MODULE, ref_count) {
4200bd40:	aa0c      	movi.n	a10, 10
4200bd42:	d14d81        	l32r	a8, 42000278 <_stext+0x258> (403781f0 <periph_rcc_acquire_enter>)
4200bd45:	0008e0        	callx8	a8
4200bd48:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
4200bd4a:	f53a16        	beqz	a10, 4200bca1 <esp_task_wdt_impl_timer_allocate+0x2d>
4200bd4d:	ffe546        	j	4200bce6 <esp_task_wdt_impl_timer_allocate+0x72>
        ret = ESP_ERR_INVALID_STATE;
4200bd50:	03a122        	movi	a2, 0x103
}
4200bd53:	f01d      	retw.n
4200bd55:	000000        	ill

4200bd58 <esp_task_wdt_impl_timer_free>:
{
4200bd58:	004136        	entry	a1, 32
    if (ctx != NULL) {
4200bd5b:	075216        	beqz	a2, 4200bdd4 <esp_task_wdt_impl_timer_free+0x7c>
        wdt_hal_deinit(&ctx->hal);
4200bd5e:	02ad      	mov.n	a10, a2
4200bd60:	d3e481        	l32r	a8, 42000cf0 <_stext+0xcd0> (40000dc8 <wdt_hal_deinit>)
4200bd63:	0008e0        	callx8	a8
        ESP_ERROR_CHECK(esp_intr_disable(ctx->intr_handle));
4200bd66:	22a8      	l32i.n	a10, a2, 8
4200bd68:	d20381        	l32r	a8, 42000574 <_stext+0x554> (40376654 <esp_intr_disable>)
4200bd6b:	0008e0        	callx8	a8
4200bd6e:	3abc      	beqz.n	a10, 4200bda5 <esp_task_wdt_impl_timer_free+0x4d>
4200bd70:	d3dce1        	l32r	a14, 42000ce0 <_stext+0xcc0> (3c025b84 <_flash_rodata_start+0x5a64>)
4200bd73:	d3dcd1        	l32r	a13, 42000ce4 <_stext+0xcc4> (3c027bb4 <__func__$0>)
4200bd76:	a8a0c2        	movi	a12, 168
4200bd79:	d3dbb1        	l32r	a11, 42000ce8 <_stext+0xcc8> (3c025ba8 <_flash_rodata_start+0x5a88>)
4200bd7c:	d2ae81        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200bd7f:	0008e0        	callx8	a8
        SYSTEM.perip_clk_en0.timergroup_clk_en = enable;
4200bd82:	d13491        	l32r	a9, 42000254 <_stext+0x234> (600c0000 <SYSTEM>)
4200bd85:	0020c0        	memw
4200bd88:	6988      	l32i.n	a8, a9, 24
4200bd8a:	d31ea1        	l32r	a10, 42000a04 <_stext+0x9e4> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
4200bd8d:	1088a0        	and	a8, a8, a10
4200bd90:	0020c0        	memw
4200bd93:	6989      	s32i.n	a8, a9, 24
        PERIPH_RCC_RELEASE_ATOMIC(TWDT_PERIPH_MODULE, ref_count) {
4200bd95:	aa0c      	movi.n	a10, 10
4200bd97:	d32181        	l32r	a8, 42000a1c <_stext+0x9fc> (4037826c <periph_rcc_release_exit>)
4200bd9a:	0008e0        	callx8	a8
4200bd9d:	770b      	addi.n	a7, a7, -1
4200bd9f:	747070        	extui	a7, a7, 0, 8
4200bda2:	000046        	j	4200bda7 <esp_task_wdt_impl_timer_free+0x4f>
4200bda5:	170c      	movi.n	a7, 1
4200bda7:	e78c      	beqz.n	a7, 4200bdb9 <esp_task_wdt_impl_timer_free+0x61>
4200bda9:	aa0c      	movi.n	a10, 10
4200bdab:	d31d81        	l32r	a8, 42000a20 <_stext+0xa00> (40378254 <periph_rcc_release_enter>)
4200bdae:	0008e0        	callx8	a8
4200bdb1:	0abd      	mov.n	a11, a10
            if (ref_count == 0) {
4200bdb3:	fcba16        	beqz	a10, 4200bd82 <esp_task_wdt_impl_timer_free+0x2a>
4200bdb6:	fff6c6        	j	4200bd95 <esp_task_wdt_impl_timer_free+0x3d>
        ESP_ERROR_CHECK(esp_intr_free(ctx->intr_handle));
4200bdb9:	0222a2        	l32i	a10, a2, 8
4200bdbc:	f7d625        	call8	42003b20 <esp_intr_free>
4200bdbf:	011a16        	beqz	a10, 4200bdd4 <esp_task_wdt_impl_timer_free+0x7c>
4200bdc2:	d3cae1        	l32r	a14, 42000cec <_stext+0xccc> (3c025be8 <_flash_rodata_start+0x5ac8>)
4200bdc5:	d3c7d1        	l32r	a13, 42000ce4 <_stext+0xcc4> (3c027bb4 <__func__$0>)
4200bdc8:	b2a0c2        	movi	a12, 178
4200bdcb:	d3c7b1        	l32r	a11, 42000ce8 <_stext+0xcc8> (3c025ba8 <_flash_rodata_start+0x5a88>)
4200bdce:	d29981        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
4200bdd1:	0008e0        	callx8	a8
}
4200bdd4:	000090        	retw
	...

4200bdd8 <esp_task_wdt_impl_timeout_triggered>:

void esp_task_wdt_impl_timeout_triggered(twdt_ctx_t obj)
{
4200bdd8:	004136        	entry	a1, 32
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx != NULL) {
4200bddb:	629c      	beqz.n	a2, 4200bdf5 <esp_task_wdt_impl_timeout_triggered+0x1d>
        /* Reset hardware timer so that 2nd stage timeout is not reached (will trigger system reset) */
        wdt_hal_write_protect_disable(&ctx->hal);
4200bddd:	02ad      	mov.n	a10, a2
4200bddf:	d0ce81        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
4200bde2:	0008e0        	callx8	a8
        wdt_hal_handle_intr(&ctx->hal);  // Feeds WDT and clears acknowledges interrupt
4200bde5:	02ad      	mov.n	a10, a2
4200bde7:	d3c381        	l32r	a8, 42000cf4 <_stext+0xcd4> (40000e10 <wdt_hal_handle_intr>)
4200bdea:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
4200bded:	02ad      	mov.n	a10, a2
4200bdef:	d0cc81        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
4200bdf2:	0008e0        	callx8	a8
    }
}
4200bdf5:	f01d      	retw.n
	...

4200bdf8 <esp_task_wdt_impl_timer_stop>:

esp_err_t esp_task_wdt_impl_timer_stop(twdt_ctx_t obj)
{
4200bdf8:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx == NULL) {
4200bdfb:	d29c      	beqz.n	a2, 4200be1c <esp_task_wdt_impl_timer_stop+0x24>
        ret = ESP_ERR_INVALID_STATE;
    }

    if (ret == ESP_OK) {
        wdt_hal_write_protect_disable(&ctx->hal);
4200bdfd:	02ad      	mov.n	a10, a2
4200bdff:	d0c681        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
4200be02:	0008e0        	callx8	a8
        wdt_hal_disable(&ctx->hal);
4200be05:	02ad      	mov.n	a10, a2
4200be07:	d0c581        	l32r	a8, 4200011c <_stext+0xfc> (40000e04 <wdt_hal_disable>)
4200be0a:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
4200be0d:	02ad      	mov.n	a10, a2
4200be0f:	d0c481        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
4200be12:	0008e0        	callx8	a8
    esp_err_t ret = ESP_OK;
4200be15:	020c      	movi.n	a2, 0
4200be17:	000106        	j	4200be1f <esp_task_wdt_impl_timer_stop+0x27>
4200be1a:	220000        	orb	b0, b0, b0
        ret = ESP_ERR_INVALID_STATE;
4200be1d:	1d03a1        	l32r	a10, 41fd322c <_iram_bss_end+0x1c50e2c>
    }

    return ret;
}
4200be20:	0000f0        	callx12	a0
	...

4200be24 <esp_task_wdt_impl_timer_restart>:

esp_err_t esp_task_wdt_impl_timer_restart(twdt_ctx_t obj)
{
4200be24:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx == NULL) {
4200be27:	52ac      	beqz.n	a2, 4200be50 <esp_task_wdt_impl_timer_restart+0x2c>
        ret = ESP_ERR_INVALID_STATE;
    }

    if (ret == ESP_OK) {
        wdt_hal_write_protect_disable(&ctx->hal);
4200be29:	02ad      	mov.n	a10, a2
4200be2b:	d0bb81        	l32r	a8, 42000118 <_stext+0xf8> (40000de0 <wdt_hal_write_protect_disable>)
4200be2e:	0008e0        	callx8	a8
        wdt_hal_enable(&ctx->hal);
4200be31:	02ad      	mov.n	a10, a2
4200be33:	d11381        	l32r	a8, 42000280 <_stext+0x260> (40000df8 <wdt_hal_enable>)
4200be36:	0008e0        	callx8	a8
        wdt_hal_feed(&ctx->hal);
4200be39:	02ad      	mov.n	a10, a2
4200be3b:	d0db81        	l32r	a8, 420001a8 <_stext+0x188> (40000e1c <wdt_hal_feed>)
4200be3e:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
4200be41:	02ad      	mov.n	a10, a2
4200be43:	d0b781        	l32r	a8, 42000120 <_stext+0x100> (40000dec <wdt_hal_write_protect_enable>)
4200be46:	0008e0        	callx8	a8
    esp_err_t ret = ESP_OK;
4200be49:	020c      	movi.n	a2, 0
4200be4b:	000106        	j	4200be53 <esp_task_wdt_impl_timer_restart+0x2f>
4200be4e:	220000        	orb	b0, b0, b0
        ret = ESP_ERR_INVALID_STATE;
4200be51:	1d03a1        	l32r	a10, 41fd3260 <_iram_bss_end+0x1c50e60>
    }

    return ret;
}
4200be54:	0000f0        	callx12	a0
	...

4200be58 <esp_rom_efuse_get_opiconfig>:
/**
 * Since rom of esp32s3 does not export function ets_efuse_get_opiconfig,
 * patch this function here.
 */
uint32_t esp_rom_efuse_get_opiconfig(void)
{
4200be58:	004136        	entry	a1, 32
    uint64_t spiconfig1 = REG_GET_FIELD(EFUSE_RD_MAC_SPI_SYS_2_REG, EFUSE_SPI_PAD_CONF_1);
4200be5b:	d3a781        	l32r	a8, 42000cf8 <_stext+0xcd8> (6000704c <EFUSE+0x4c>)
4200be5e:	0020c0        	memw
4200be61:	0898      	l32i.n	a9, a8, 0
    uint64_t spiconfig2 = REG_GET_FIELD(EFUSE_RD_MAC_SPI_SYS_3_REG, EFUSE_SPI_PAD_CONF_2);
4200be63:	d3a681        	l32r	a8, 42000cfc <_stext+0xcdc> (60007050 <EFUSE+0x50>)
4200be66:	0020c0        	memw
4200be69:	0888      	l32i.n	a8, a8, 0
4200be6b:	118820        	slli	a8, a8, 14
4200be6e:	418e80        	srli	a8, a8, 14
    uint64_t opiconfig = (spiconfig2 << 12) | (spiconfig1 >> 20);
4200be71:	118840        	slli	a8, a8, 12
4200be74:	b59490        	extui	a9, a9, 20, 12
4200be77:	202890        	or	a2, a8, a9
    if (opiconfig == 0 || opiconfig == 0x3fffffffllu) {
4200be7a:	40f280        	nsau	a8, a2
4200be7d:	418580        	srli	a8, a8, 5
4200be80:	d11f91        	l32r	a9, 420002fc <_stext+0x2dc> (3fffffff <ets_rom_layout_p+0xe0003>)
4200be83:	309290        	xor	a9, a2, a9
4200be86:	40f990        	nsau	a9, a9
4200be89:	419590        	srli	a9, a9, 5
4200be8c:	208890        	or	a8, a8, a9
4200be8f:	188c      	beqz.n	a8, 4200be94 <esp_rom_efuse_get_opiconfig+0x3c>
        return 0;
4200be91:	00a022        	movi	a2, 0
    // [42:47] -- D4
    // [48:53] -- D5
    // [54:59] -- D6
    // [60:65] -- D7
    return opiconfig & 0x3fffffff;
}
4200be94:	f01d      	retw.n
	...

4200be98 <gpspi_flash_ll_calculate_clock_reg>:
 * @param clkdiv frequency division factor
 *
 * @return Register setting for the given clock division factor.
 */
static inline uint32_t gpspi_flash_ll_calculate_clock_reg(uint8_t clkdiv)
{
4200be98:	004136        	entry	a1, 32
    uint32_t div_parameter;
    // See comments of `clock` in `spi_struct.h`
    if (clkdiv == 1) {
4200be9b:	211226        	beqi	a2, 1, 4200bec0 <gpspi_flash_ll_calculate_clock_reg+0x28>
        div_parameter = (1 << 31);
    } else {
        div_parameter = ((clkdiv - 1) | (((clkdiv / 2 - 1) & 0xff) << 6) | (((clkdiv - 1) & 0xff) << 12));
4200be9e:	820b      	addi.n	a8, a2, -1
4200bea0:	412120        	srli	a2, a2, 1
4200bea3:	220b      	addi.n	a2, a2, -1
4200bea5:	1122a0        	slli	a2, a2, 6
4200bea8:	742620        	extui	a2, a2, 6, 8
4200beab:	1122a0        	slli	a2, a2, 6
4200beae:	202820        	or	a2, a8, a2
4200beb1:	118840        	slli	a8, a8, 12
4200beb4:	748c80        	extui	a8, a8, 12, 8
4200beb7:	118840        	slli	a8, a8, 12
4200beba:	202280        	or	a2, a2, a8
4200bebd:	000086        	j	4200bec3 <gpspi_flash_ll_calculate_clock_reg+0x2b>
        div_parameter = (1 << 31);
4200bec0:	d26921        	l32r	a2, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
    }
    return div_parameter;
}
4200bec3:	f01d      	retw.n
4200bec5:	000000        	ill

4200bec8 <spimem_flash_ll_calculate_clock_reg>:
{
4200bec8:	004136        	entry	a1, 32
    if (clkdiv == 1) {
4200becb:	211226        	beqi	a2, 1, 4200bef0 <spimem_flash_ll_calculate_clock_reg+0x28>
        div_parameter = ((clkdiv - 1) | (((clkdiv - 1) / 2 & 0xff) << 8) | (((clkdiv - 1) & 0xff) << 16));
4200bece:	220b      	addi.n	a2, a2, -1
4200bed0:	058f20        	extui	a8, a2, 31, 1
4200bed3:	882a      	add.n	a8, a8, a2
4200bed5:	218180        	srai	a8, a8, 1
4200bed8:	118880        	slli	a8, a8, 8
4200bedb:	f48080        	extui	a8, a8, 0, 16
4200bede:	208280        	or	a8, a2, a8
4200bee1:	112200        	slli	a2, a2, 16
4200bee4:	752020        	extui	a2, a2, 16, 8
4200bee7:	112200        	slli	a2, a2, 16
4200beea:	202820        	or	a2, a8, a2
4200beed:	000086        	j	4200bef3 <spimem_flash_ll_calculate_clock_reg+0x2b>
        div_parameter = (1 << 31);
4200bef0:	d25d21        	l32r	a2, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
}
4200bef3:	f01d      	retw.n
4200bef5:	000000        	ill

4200bef8 <extra_dummy_under_timing_tuning>:
    return apb_period_n / apbclk_n;
}

#if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
static inline int extra_dummy_under_timing_tuning(const spi_flash_hal_config_t *cfg)
{
4200bef8:	004136        	entry	a1, 32
    bool main_flash = (cfg->host_id == SPI1_HOST && cfg->cs_num == 0);
4200befb:	8288      	l32i.n	a8, a2, 32
4200befd:	38cc      	bnez.n	a8, 4200bf04 <extra_dummy_under_timing_tuning+0xc>
4200beff:	092282        	l32i	a8, a2, 36
4200bf02:	488c      	beqz.n	a8, 4200bf0a <extra_dummy_under_timing_tuning+0x12>
         * Instead, for both Quad and Octal Flash, we use `usr_dummy` and set the whole dummy length (usr_dummy + extra_dummy) to this register.
         */
        extra_dummy = cfg->extra_dummy;
    } else {
        // TODO: for other flash chips, dummy get logic implement here. Currently, still calculate extra dummy by itself.
        abort();
4200bf04:	d07681        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200bf07:	0008e0        	callx8	a8
        extra_dummy = cfg->extra_dummy;
4200bf0a:	0228      	l32i.n	a2, a2, 0
    }

    return extra_dummy;
}
4200bf0c:	f01d      	retw.n
	...

4200bf10 <get_flash_clock_divider>:
{
4200bf10:	008136        	entry	a1, 64
    const int src_freq_mhz = cfg->clock_src_freq;
4200bf13:	d268      	l32i.n	a6, a2, 52
    const int cfg_freq_mhz = cfg->freq_mhz;
4200bf15:	c278      	l32i.n	a7, a2, 48
    if (src_freq_mhz < cfg_freq_mhz) {
4200bf17:	23a677        	bge	a6, a7, 4200bf3e <get_flash_clock_divider+0x2e>
        HAL_LOGE(TAG, "Target frequency %dMHz higher than src %dMHz.", cfg_freq_mhz, src_freq_mhz);
4200bf1a:	d05181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200bf1d:	0008e0        	callx8	a8
4200bf20:	d378b1        	l32r	a11, 42000d00 <_stext+0xce0> (3c025c08 <_flash_rodata_start+0x5ae8>)
4200bf23:	0169      	s32i.n	a6, a1, 0
4200bf25:	07fd      	mov.n	a15, a7
4200bf27:	0bed      	mov.n	a14, a11
4200bf29:	20daa0        	or	a13, a10, a10
4200bf2c:	d376c1        	l32r	a12, 42000d04 <_stext+0xce4> (3c025c14 <_flash_rodata_start+0x5af4>)
4200bf2f:	01a0a2        	movi	a10, 1
4200bf32:	d05881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200bf35:	0008e0        	callx8	a8
        abort();
4200bf38:	d06981        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200bf3b:	0008e0        	callx8	a8
        best_div = (src_freq_mhz + cfg_freq_mhz - 1) / cfg_freq_mhz;
4200bf3e:	276a      	add.n	a2, a7, a6
4200bf40:	220b      	addi.n	a2, a2, -1
4200bf42:	d22270        	quos	a2, a2, a7
        const div_t res = div(src_freq_mhz, cfg_freq_mhz);
4200bf45:	20b770        	or	a11, a7, a7
4200bf48:	06ad      	mov.n	a10, a6
4200bf4a:	d37081        	l32r	a8, 42000d0c <_stext+0xcec> (40001464 <div>)
4200bf4d:	0008e0        	callx8	a8
4200bf50:	41a9      	s32i.n	a10, a1, 16
4200bf52:	51b9      	s32i.n	a11, a1, 20
        if (res.rem != 0) {
4200bf54:	052182        	l32i	a8, a1, 20
4200bf57:	019816        	beqz	a8, 4200bf74 <get_flash_clock_divider+0x64>
            HAL_LOGW(TAG, "Flash clock frequency round down to %d", res.quot);
4200bf5a:	d04181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200bf5d:	0008e0        	callx8	a8
4200bf60:	d368b1        	l32r	a11, 42000d00 <_stext+0xce0> (3c025c08 <_flash_rodata_start+0x5ae8>)
4200bf63:	41f8      	l32i.n	a15, a1, 16
4200bf65:	0bed      	mov.n	a14, a11
4200bf67:	0add      	mov.n	a13, a10
4200bf69:	d367c1        	l32r	a12, 42000d08 <_stext+0xce8> (3c025c50 <_flash_rodata_start+0x5b30>)
4200bf6c:	2a0c      	movi.n	a10, 2
4200bf6e:	d04981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200bf71:	0008e0        	callx8	a8
}
4200bf74:	f01d      	retw.n
	...

4200bf78 <spi_flash_cal_clock>:
{
4200bf78:	004136        	entry	a1, 32
4200bf7b:	20a220        	or	a10, a2, a2
    uint32_t div_parameter = spi_flash_ll_calculate_clock_reg(cfg->host_id, get_flash_clock_divider(cfg));
4200bf7e:	082282        	l32i	a8, a2, 32
4200bf81:	010856        	bnez	a8, 4200bf95 <spi_flash_cal_clock+0x1d>
4200bf84:	fff8a5        	call8	4200bf10 <get_flash_clock_divider>
4200bf87:	74a0a0        	extui	a10, a10, 0, 8
4200bf8a:	fff3e5        	call8	4200bec8 <spimem_flash_ll_calculate_clock_reg>
4200bf8d:	0a2d      	mov.n	a2, a10
4200bf8f:	000386        	j	4200bfa1 <spi_flash_cal_clock+0x29>
4200bf92:	000000        	ill
4200bf95:	fff7a5        	call8	4200bf10 <get_flash_clock_divider>
4200bf98:	74a0a0        	extui	a10, a10, 0, 8
4200bf9b:	ffefe5        	call8	4200be98 <gpspi_flash_ll_calculate_clock_reg>
4200bf9e:	202aa0        	or	a2, a10, a10
}
4200bfa1:	000090        	retw

4200bfa4 <spi_flash_hal_init>:
#endif //SOC_SPI_MEM_SUPPORT_TIMING_TUNING

esp_err_t spi_flash_hal_init(spi_flash_hal_context_t *data_out, const spi_flash_hal_config_t *cfg)
{
4200bfa4:	006136        	entry	a1, 48
    if (cfg->cs_num >= SOC_SPI_PERIPH_CS_NUM(cfg->host_id)) {
4200bfa7:	9378      	l32i.n	a7, a3, 36
4200bfa9:	8388      	l32i.n	a8, a3, 32
4200bfab:	688c      	beqz.n	a8, 4200bfb5 <spi_flash_hal_init+0x11>
4200bfad:	091866        	bnei	a8, 1, 4200bfba <spi_flash_hal_init+0x16>
4200bfb0:	690c      	movi.n	a9, 6
4200bfb2:	000186        	j	4200bfbc <spi_flash_hal_init+0x18>
4200bfb5:	290c      	movi.n	a9, 2
4200bfb7:	000046        	j	4200bfbc <spi_flash_hal_init+0x18>
4200bfba:	390c      	movi.n	a9, 3
4200bfbc:	022797        	blt	a7, a9, 4200bfc2 <spi_flash_hal_init+0x1e>
4200bfbf:	003f46        	j	4200c0c0 <spi_flash_hal_init+0x11c>
        return ESP_ERR_INVALID_ARG;
    }

    *data_out = (spi_flash_hal_context_t) {
        .inst = data_out->inst, // Keeps the function pointer table
4200bfc2:	0248      	l32i.n	a4, a2, 0
4200bfc4:	0a1826        	beqi	a8, 1, 4200bfd2 <spi_flash_hal_init+0x2e>
4200bfc7:	0f2826        	beqi	a8, 2, 4200bfda <spi_flash_hal_init+0x36>
4200bfca:	689c      	beqz.n	a8, 4200bfe4 <spi_flash_hal_init+0x40>
        .spi = spi_flash_ll_get_hw(cfg->host_id),
4200bfcc:	d04481        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200bfcf:	0008e0        	callx8	a8
        .inst = data_out->inst, // Keeps the function pointer table
4200bfd2:	d35081        	l32r	a8, 42000d14 <_stext+0xcf4> (60024000 <GPSPI2>)
4200bfd5:	2189      	s32i.n	a8, a1, 8
4200bfd7:	0003c6        	j	4200bfea <spi_flash_hal_init+0x46>
4200bfda:	d34f81        	l32r	a8, 42000d18 <_stext+0xcf8> (60025000 <GPSPI3>)
4200bfdd:	2189      	s32i.n	a8, a1, 8
4200bfdf:	0001c6        	j	4200bfea <spi_flash_hal_init+0x46>
4200bfe2:	810000        	src	a0, a0, a0
4200bfe5:	d34b      	addi.n	a13, a3, 4
4200bfe7:	026182        	s32i	a8, a1, 8
        .cs_num = cfg->cs_num,
        .cs_hold = cfg->cs_hold,
        .cs_setup = cfg->cs_setup,
4200bfea:	0c0352        	l8ui	a5, a3, 12
        .cs_hold = cfg->cs_hold,
4200bfed:	022362        	l32i	a6, a3, 8
        .base_io_mode = cfg->default_io_mode,
4200bff0:	0b2382        	l32i	a8, a3, 44
4200bff3:	0189      	s32i.n	a8, a1, 0
        .freq_mhz = cfg->freq_mhz,
4200bff5:	c398      	l32i.n	a9, a3, 48
4200bff7:	1199      	s32i.n	a9, a1, 4
    *data_out = (spi_flash_hal_context_t) {
4200bff9:	0c3c      	movi.n	a12, 48
4200bffb:	0b0c      	movi.n	a11, 0
4200bffd:	02ad      	mov.n	a10, a2
4200bfff:	d0c181        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200c002:	0008e0        	callx8	a8
4200c005:	0249      	s32i.n	a4, a2, 0
4200c007:	21a8      	l32i.n	a10, a1, 8
4200c009:	12a9      	s32i.n	a10, a2, 4
4200c00b:	2279      	s32i.n	a7, a2, 8
4200c00d:	0e4252        	s8i	a5, a2, 14
4200c010:	0f4262        	s8i	a6, a2, 15
4200c013:	0188      	l32i.n	a8, a1, 0
4200c015:	5289      	s32i.n	a8, a2, 20
4200c017:	1198      	l32i.n	a9, a1, 4
4200c019:	a299      	s32i.n	a9, a2, 40
    };
#if SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    if (cfg->using_timing_tuning) {
4200c01b:	2a0382        	l8ui	a8, a3, 42
4200c01e:	489c      	beqz.n	a8, 4200c036 <spi_flash_hal_init+0x92>
        data_out->extra_dummy = extra_dummy_under_timing_tuning(cfg);
4200c020:	03ad      	mov.n	a10, a3
4200c022:	ffed65        	call8	4200bef8 <extra_dummy_under_timing_tuning>
4200c025:	0c42a2        	s8i	a10, a2, 12
        data_out->fdummy_rin = cfg->fdummy_rin;
4200c028:	1388      	l32i.n	a8, a3, 4
4200c02a:	0d4282        	s8i	a8, a2, 13
        data_out->clock_conf = cfg->clock_config;
4200c02d:	4388      	l32i.n	a8, a3, 16
4200c02f:	4289      	s32i.n	a8, a2, 16
4200c031:	001146        	j	4200c07a <spi_flash_hal_init+0xd6>
4200c034:	720000        	salt	a0, a0, a0
    } else
#endif // SOC_SPI_MEM_SUPPORT_TIMING_TUNING
    {
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200c037:	300623        	lsi	f2, a6, 192
4200c03a:	a3          	.byte	0xa3
4200c03b:	20          	.byte	0x20
4200c03c:	ffed25        	call8	4200bf10 <get_flash_clock_divider>
4200c03f:	d33781        	l32r	a8, 42000d1c <_stext+0xcfc> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
4200c042:	c2a8a0        	quou	a10, a8, a10
    const int apbclk_n = APB_CLK_FREQ / eff_clk;
4200c045:	d2a8a0        	quos	a10, a8, a10
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
4200c048:	01c782        	addi	a8, a7, 1
4200c04b:	a08880        	addx4	a8, a8, a8
4200c04e:	1188c0        	slli	a8, a8, 4
4200c051:	d09591        	l32r	a9, 420002a8 <_stext+0x288> (10624dd3 <UserFrameTotalSize+0x10624cd3>)
4200c054:	b29890        	mulsh	a9, a8, a9
4200c057:	219690        	srai	a9, a9, 6
4200c05a:	31bf80        	srai	a11, a8, 31
4200c05d:	c099b0        	sub	a9, a9, a11
    if (apb_period_n < 0) {
4200c060:	19acb2        	movi	a11, 0xfffffc19
4200c063:	01a8b7        	bge	a8, a11, 4200c068 <spi_flash_hal_init+0xc4>
        apb_period_n = 0;
4200c066:	090c      	movi.n	a9, 0
    return apb_period_n / apbclk_n;
4200c068:	d299a0        	quos	a9, a9, a10
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200c06b:	0c4292        	s8i	a9, a2, 12
        data_out->clock_conf = (spi_flash_ll_clock_reg_t)spi_flash_cal_clock(cfg);
4200c06e:	20a330        	or	a10, a3, a3
4200c071:	fff065        	call8	4200bf78 <spi_flash_cal_clock>
4200c074:	0020c0        	memw
4200c077:	0462a2        	s32i	a10, a2, 16
    }


    if (cfg->auto_sus_en) {
4200c07a:	280382        	l8ui	a8, a3, 40
4200c07d:	01b816        	beqz	a8, 4200c09c <spi_flash_hal_init+0xf8>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND;
4200c080:	6288      	l32i.n	a8, a2, 24
4200c082:	190c      	movi.n	a9, 1
4200c084:	209890        	or	a9, a8, a9
4200c087:	6299      	s32i.n	a9, a2, 24
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
4200c089:	390c      	movi.n	a9, 3
4200c08b:	208890        	or	a8, a8, a9
4200c08e:	6289      	s32i.n	a8, a2, 24
        data_out->tsus_val = cfg->tsus_val;
4200c090:	380382        	l8ui	a8, a3, 56
4200c093:	2c4282        	s8i	a8, a2, 44
        data_out->auto_waiti_pes = cfg->auto_waiti_pes;
4200c096:	390382        	l8ui	a8, a3, 57
4200c099:	2d4282        	s8i	a8, a2, 45
#if CONFIG_SPI_FLASH_SOFTWARE_RESUME
    data_out->flags &= ~SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
#endif

#if SOC_SPI_MEM_SUPPORT_FLASH_OPI_MODE
    if (cfg->octal_mode_en) {
4200c09c:	290382        	l8ui	a8, a3, 41
4200c09f:	788c      	beqz.n	a8, 4200c0aa <spi_flash_hal_init+0x106>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_OCTAL_MODE;
4200c0a1:	6288      	l32i.n	a8, a2, 24
4200c0a3:	490c      	movi.n	a9, 4
4200c0a5:	208890        	or	a8, a8, a9
4200c0a8:	6289      	s32i.n	a8, a2, 24
    }

    if (cfg->default_io_mode == SPI_FLASH_OPI_DTR) {
4200c0aa:	b398      	l32i.n	a9, a3, 44
4200c0ac:	181c      	movi.n	a8, 17
4200c0ae:	149987        	bne	a9, a8, 4200c0c6 <spi_flash_hal_init+0x122>
        data_out->slicer_flags |= SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR;
4200c0b1:	9288      	l32i.n	a8, a2, 36
4200c0b3:	190c      	movi.n	a9, 1
4200c0b5:	208890        	or	a8, a8, a9
4200c0b8:	9289      	s32i.n	a8, a2, 36
    }
#endif

    return ESP_OK;
4200c0ba:	020c      	movi.n	a2, 0
4200c0bc:	000206        	j	4200c0c8 <spi_flash_hal_init+0x124>
4200c0bf:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_ARG;
4200c0c2:	004602        	s8i	a0, a6, 0
4200c0c5:	020c00        	andb	b0, b12, b0
}
4200c0c8:	f01d      	retw.n
	...

4200c0cc <spi_flash_hal_supports_direct_write>:

bool spi_flash_hal_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4200c0cc:	004136        	entry	a1, 32
    (void)p;
    bool direct_write = (((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
4200c0cf:	1228      	l32i.n	a2, a2, 4
4200c0d1:	d30f81        	l32r	a8, 42000d10 <_stext+0xcf0> (60002000 <SPIMEM1>)
4200c0d4:	c02280        	sub	a2, a2, a8
    return direct_write;
}
4200c0d7:	180c      	movi.n	a8, 1
4200c0d9:	932820        	movnez	a2, a8, a2
4200c0dc:	f01d      	retw.n
	...

4200c0e0 <spi_flash_hal_supports_direct_read>:


bool spi_flash_hal_supports_direct_read(spi_flash_host_inst_t *host, const void *p)
{
4200c0e0:	004136        	entry	a1, 32
    (void)p;
    //currently the host doesn't support to read through dma, no word-aligned requirements
    bool direct_read = ( ((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
4200c0e3:	1228      	l32i.n	a2, a2, 4
4200c0e5:	d30a81        	l32r	a8, 42000d10 <_stext+0xcf0> (60002000 <SPIMEM1>)
4200c0e8:	c02280        	sub	a2, a2, a8
    return direct_read;
}
4200c0eb:	180c      	movi.n	a8, 1
4200c0ed:	932820        	movnez	a2, a8, a2
4200c0f0:	f01d      	retw.n
	...

4200c0f4 <clk_hal_lp_slow_get_freq_hz>:
{
    return clk_hal_ahb_get_freq_hz();
}

uint32_t clk_hal_lp_slow_get_freq_hz(void)
{
4200c0f4:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
4200c0f7:	d19281        	l32r	a8, 42000740 <_stext+0x720> (60008074 <RTCCNTL+0x74>)
4200c0fa:	0020c0        	memw
4200c0fd:	0888      	l32i.n	a8, a8, 0
4200c0ff:	158e80        	extui	a8, a8, 30, 2
    switch (clk_sel) {
4200c102:	161826        	beqi	a8, 1, 4200c11c <clk_hal_lp_slow_get_freq_hz+0x28>
4200c105:	1b2826        	beqi	a8, 2, 4200c124 <clk_hal_lp_slow_get_freq_hz+0x30>
4200c108:	08ac      	beqz.n	a8, 4200c12c <clk_hal_lp_slow_get_freq_hz+0x38>
        HAL_ASSERT(false);
4200c10a:	d306d1        	l32r	a13, 42000d24 <_stext+0xd04> (3c022ea4 <_flash_rodata_start+0x2d84>)
4200c10d:	d306c1        	l32r	a12, 42000d28 <_stext+0xd08> (3c027bd4 <__func__$0>)
4200c110:	1aa2b2        	movi	a11, 0x21a
4200c113:	d306a1        	l32r	a10, 42000d2c <_stext+0xd0c> (3c025c84 <_flash_rodata_start+0x5b64>)
4200c116:	cffc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200c119:	0008e0        	callx8	a8
    switch (clk_ll_rtc_slow_get_src()) {
    case SOC_RTC_SLOW_CLK_SRC_RC_SLOW:
        return SOC_CLK_RC_SLOW_FREQ_APPROX;
    case SOC_RTC_SLOW_CLK_SRC_XTAL32K:
        return SOC_CLK_XTAL32K_FREQ_APPROX;
4200c11c:	d04f21        	l32r	a2, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
4200c11f:	000306        	j	4200c12f <clk_hal_lp_slow_get_freq_hz+0x3b>
4200c122:	210000        	srai	a0, a0, 0
    case SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256:
        return SOC_CLK_RC_FAST_D256_FREQ_APPROX;
4200c125:	06d182        	addmi	a8, a1, 0x600
4200c128:	000001        	l32r	a0, 41fcc128 <_iram_bss_end+0x1c49d28>
4200c12b:	00          	.byte	00
    switch (clk_sel) {
4200c12c:	d2fd21        	l32r	a2, 42000d20 <_stext+0xd00> (21340 <UserFrameTotalSize+0x21240>)
    default:
        // Unknown RTC_SLOW_CLK mux input
        HAL_ASSERT(false);
        return 0;
    }
}
4200c12f:	f01d      	retw.n
4200c131:	000000        	ill

4200c134 <clk_hal_xtal_get_freq_mhz>:

uint32_t clk_hal_xtal_get_freq_mhz(void)
{
4200c134:	004136        	entry	a1, 32
    uint32_t xtal_freq_reg = READ_PERI_REG(RTC_XTAL_FREQ_REG);
4200c137:	d2fe81        	l32r	a8, 42000d30 <_stext+0xd10> (600080c0 <RTCCNTL+0xc0>)
4200c13a:	0020c0        	memw
4200c13d:	0828      	l32i.n	a2, a8, 0
    if ((xtal_freq_reg & 0xFFFF) == ((xtal_freq_reg >> 16) & 0xFFFF) &&
4200c13f:	f49020        	extui	a9, a2, 0, 16
4200c142:	f58020        	extui	a8, a2, 16, 16
4200c145:	0f9987        	bne	a9, a8, 4200c158 <clk_hal_xtal_get_freq_mhz+0x24>
        xtal_freq_reg != 0 && xtal_freq_reg != UINT32_MAX) {
4200c148:	820b      	addi.n	a8, a2, -1
4200c14a:	d97c      	movi.n	a9, -3
4200c14c:	083987        	bltu	a9, a8, 4200c158 <clk_hal_xtal_get_freq_mhz+0x24>
        return xtal_freq_reg & ~RTC_DISABLE_ROM_LOG & UINT16_MAX;
4200c14f:	e42120        	extui	a2, a2, 1, 15
4200c152:	802220        	add	a2, a2, a2
    uint32_t freq = clk_ll_xtal_load_freq_mhz();
    if (freq == 0) {
4200c155:	019256        	bnez	a2, 4200c172 <clk_hal_xtal_get_freq_mhz+0x3e>
        HAL_LOGW(CLK_HAL_TAG, "invalid RTC_XTAL_FREQ_REG value, assume 40MHz");
4200c158:	cfc281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c15b:	0008e0        	callx8	a8
4200c15e:	d2f5b1        	l32r	a11, 42000d34 <_stext+0xd14> (3c025cbc <_flash_rodata_start+0x5b9c>)
4200c161:	0bed      	mov.n	a14, a11
4200c163:	0add      	mov.n	a13, a10
4200c165:	d2f4c1        	l32r	a12, 42000d38 <_stext+0xd18> (3c025cc4 <_flash_rodata_start+0x5ba4>)
4200c168:	2a0c      	movi.n	a10, 2
4200c16a:	cfca81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c16d:	0008e0        	callx8	a8
        return (uint32_t)SOC_XTAL_FREQ_40M;
4200c170:	822c      	movi.n	a2, 40
    }
    return freq;
}
4200c172:	f01d      	retw.n

4200c174 <clk_hal_soc_root_get_freq_mhz>:
{
4200c174:	004136        	entry	a1, 32
    switch (cpu_clk_src) {
4200c177:	0d1226        	beqi	a2, 1, 4200c188 <clk_hal_soc_root_get_freq_mhz+0x14>
4200c17a:	332226        	beqi	a2, 2, 4200c1b1 <clk_hal_soc_root_get_freq_mhz+0x3d>
4200c17d:	f2dc      	bnez.n	a2, 4200c1a0 <clk_hal_soc_root_get_freq_mhz+0x2c>
        return clk_hal_xtal_get_freq_mhz();
4200c17f:	fffb65        	call8	4200c134 <clk_hal_xtal_get_freq_mhz>
4200c182:	0a2d      	mov.n	a2, a10
4200c184:	000e06        	j	4200c1c0 <clk_hal_soc_root_get_freq_mhz+0x4c>
4200c187:	00          	.byte	00
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
4200c188:	d2ed81        	l32r	a8, 42000d3c <_stext+0xd1c> (600c0010 <SYSTEM+0x10>)
4200c18b:	0020c0        	memw
4200c18e:	0888      	l32i.n	a8, a8, 0
4200c190:	049280        	extui	a9, a8, 2, 1
    switch (pll_freq_sel) {
4200c193:	216827        	bbci	a8, 2, 4200c1b8 <clk_hal_soc_root_get_freq_mhz+0x44>
4200c196:	241966        	bnei	a9, 1, 4200c1be <clk_hal_soc_root_get_freq_mhz+0x4a>
        return CLK_LL_PLL_480M_FREQ_MHZ;
4200c199:	e0a122        	movi	a2, 0x1e0
4200c19c:	000806        	j	4200c1c0 <clk_hal_soc_root_get_freq_mhz+0x4c>
4200c19f:	00          	.byte	00
        HAL_ASSERT(false);
4200c1a0:	d2e1d1        	l32r	a13, 42000d24 <_stext+0xd04> (3c022ea4 <_flash_rodata_start+0x2d84>)
4200c1a3:	d2e7c1        	l32r	a12, 42000d40 <_stext+0xd20> (3c027bec <__func__$2>)
4200c1a6:	bb1c      	movi.n	a11, 27
4200c1a8:	d2e7a1        	l32r	a10, 42000d44 <_stext+0xd24> (3c025d00 <_flash_rodata_start+0x5be0>)
4200c1ab:	cfd781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200c1ae:	0008e0        	callx8	a8
    switch (cpu_clk_src) {
4200c1b1:	121c      	movi.n	a2, 17
4200c1b3:	000246        	j	4200c1c0 <clk_hal_soc_root_get_freq_mhz+0x4c>
4200c1b6:	220000        	orb	b0, b0, b0
    switch (pll_freq_sel) {
4200c1b9:	4640a1        	l32r	a10, 41fddabc <_iram_bss_end+0x1c5b6bc>
4200c1bc:	00          	.byte	00
4200c1bd:	020c00        	andb	b0, b12, b0
}
4200c1c0:	f01d      	retw.n
	...

4200c1c4 <clk_hal_cpu_get_freq_hz>:
{
4200c1c4:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
4200c1c7:	d2e081        	l32r	a8, 42000d48 <_stext+0xd28> (600c0060 <SYSTEM+0x60>)
4200c1ca:	0020c0        	memw
4200c1cd:	08a8      	l32i.n	a10, a8, 0
4200c1cf:	14aaa0        	extui	a10, a10, 10, 2
    switch (clk_sel) {
4200c1d2:	0b1a26        	beqi	a10, 1, 4200c1e1 <clk_hal_cpu_get_freq_hz+0x1d>
4200c1d5:	022a66        	bnei	a10, 2, 4200c1db <clk_hal_cpu_get_freq_hz+0x17>
4200c1d8:	002446        	j	4200c26d <clk_hal_cpu_get_freq_hz+0xa9>
4200c1db:	08ba56        	bnez	a10, 4200c26a <clk_hal_cpu_get_freq_hz+0xa6>
4200c1de:	0022c6        	j	4200c26d <clk_hal_cpu_get_freq_hz+0xa9>
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
4200c1e1:	d2d681        	l32r	a8, 42000d3c <_stext+0xd1c> (600c0010 <SYSTEM+0x10>)
4200c1e4:	0020c0        	memw
4200c1e7:	0888      	l32i.n	a8, a8, 0
4200c1e9:	049280        	extui	a9, a8, 2, 1
    switch (pll_freq_sel) {
4200c1ec:	086827        	bbci	a8, 2, 4200c1f8 <clk_hal_cpu_get_freq_hz+0x34>
4200c1ef:	0b1966        	bnei	a9, 1, 4200c1fe <clk_hal_cpu_get_freq_hz+0x3a>
        return CLK_LL_PLL_480M_FREQ_MHZ;
4200c1f2:	e0a192        	movi	a9, 0x1e0
4200c1f5:	0001c6        	j	4200c200 <clk_hal_cpu_get_freq_hz+0x3c>
    switch (pll_freq_sel) {
4200c1f8:	40a192        	movi	a9, 0x140
4200c1fb:	000046        	j	4200c200 <clk_hal_cpu_get_freq_hz+0x3c>
        return 0;
4200c1fe:	090c      	movi.n	a9, 0
    uint32_t cpu_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL);
4200c200:	d2cf81        	l32r	a8, 42000d3c <_stext+0xd1c> (600c0010 <SYSTEM+0x10>)
4200c203:	0020c0        	memw
4200c206:	0888      	l32i.n	a8, a8, 0
4200c208:	148080        	extui	a8, a8, 0, 2
    switch (cpu_freq_sel) {
4200c20b:	091826        	beqi	a8, 1, 4200c218 <clk_hal_cpu_get_freq_hz+0x54>
4200c20e:	0e2826        	beqi	a8, 2, 4200c220 <clk_hal_cpu_get_freq_hz+0x5c>
4200c211:	18dc      	bnez.n	a8, 4200c226 <clk_hal_cpu_get_freq_hz+0x62>
4200c213:	025c      	movi.n	a2, 80
4200c215:	0003c6        	j	4200c228 <clk_hal_cpu_get_freq_hz+0x64>
        return CLK_LL_PLL_160M_FREQ_MHZ;
4200c218:	a0a022        	movi	a2, 160
4200c21b:	000246        	j	4200c228 <clk_hal_cpu_get_freq_hz+0x64>
4200c21e:	220000        	orb	b0, b0, b0
        return CLK_LL_PLL_240M_FREQ_MHZ;
4200c221:	46f0a0        	ee.ldf.64.xp	f15, f4, a10, a0
4200c224:	00          	.byte	00
4200c225:	020c00        	andb	b0, b12, b0
        if (pll_freq_mhz == CLK_LL_PLL_320M_FREQ_MHZ && cpu_freq_mhz == CLK_LL_PLL_240M_FREQ_MHZ) {
4200c228:	c0ae82        	movi	a8, 0xfffffec0
4200c22b:	809980        	add	a9, a9, a8
4200c22e:	40f990        	nsau	a9, a9
4200c231:	419590        	srli	a9, a9, 5
4200c234:	10af82        	movi	a8, -240
4200c237:	828a      	add.n	a8, a2, a8
4200c239:	40f880        	nsau	a8, a8
4200c23c:	418580        	srli	a8, a8, 5
4200c23f:	1d0987        	bnone	a9, a8, 4200c260 <clk_hal_cpu_get_freq_hz+0x9c>
            HAL_LOGE(CLK_HAL_TAG, "Invalid cpu config");
4200c242:	cf8781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c245:	0008e0        	callx8	a8
4200c248:	d2bbb1        	l32r	a11, 42000d34 <_stext+0xd14> (3c025cbc <_flash_rodata_start+0x5b9c>)
4200c24b:	0bed      	mov.n	a14, a11
4200c24d:	0add      	mov.n	a13, a10
4200c24f:	d2bfc1        	l32r	a12, 42000d4c <_stext+0xd2c> (3c025d2c <_flash_rodata_start+0x5c0c>)
4200c252:	1a0c      	movi.n	a10, 1
4200c254:	cf9081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c257:	0008e0        	callx8	a8
            return 0;
4200c25a:	020c      	movi.n	a2, 0
4200c25c:	000a06        	j	4200c288 <clk_hal_cpu_get_freq_hz+0xc4>
4200c25f:	00          	.byte	00
        return cpu_freq_mhz * MHZ;
4200c260:	d13981        	l32r	a8, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
4200c263:	822280        	mull	a2, a2, a8
4200c266:	000786        	j	4200c288 <clk_hal_cpu_get_freq_hz+0xc4>
4200c269:	a0a200        	addx4	a10, a2, a0
        return SOC_CPU_CLK_SRC_INVALID;
4200c26c:	03          	.byte	0x3
        return clk_hal_soc_root_get_freq_mhz(source) * MHZ / clk_ll_cpu_get_divider();
4200c26d:	fff065        	call8	4200c174 <clk_hal_soc_root_get_freq_mhz>
4200c270:	d13581        	l32r	a8, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
4200c273:	822a80        	mull	a2, a10, a8
    return REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT) + 1;
4200c276:	d2b481        	l32r	a8, 42000d48 <_stext+0xd28> (600c0060 <SYSTEM+0x60>)
4200c279:	0020c0        	memw
4200c27c:	002882        	l32i	a8, a8, 0
4200c27f:	948080        	extui	a8, a8, 0, 10
4200c282:	01c882        	addi	a8, a8, 1
4200c285:	c22280        	quou	a2, a2, a8
}
4200c288:	f01d      	retw.n
	...

4200c28c <clk_hal_ahb_get_freq_hz>:
{
4200c28c:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
4200c28f:	d2ae81        	l32r	a8, 42000d48 <_stext+0xd28> (600c0060 <SYSTEM+0x60>)
4200c292:	0020c0        	memw
4200c295:	0888      	l32i.n	a8, a8, 0
4200c297:	148a80        	extui	a8, a8, 10, 2
    switch (clk_sel) {
4200c29a:	071826        	beqi	a8, 1, 4200c2a5 <clk_hal_ahb_get_freq_hz+0x19>
        return clk_hal_cpu_get_freq_hz();
4200c29d:	fff265        	call8	4200c1c4 <clk_hal_cpu_get_freq_hz>
4200c2a0:	0a2d      	mov.n	a2, a10
4200c2a2:	000086        	j	4200c2a8 <clk_hal_ahb_get_freq_hz+0x1c>
        return CLK_LL_AHB_MAX_FREQ_MHZ * MHZ;
4200c2a5:	d29d21        	l32r	a2, 42000d1c <_stext+0xcfc> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
}
4200c2a8:	f01d      	retw.n
	...

4200c2ac <clk_hal_apb_get_freq_hz>:
{
4200c2ac:	004136        	entry	a1, 32
    return clk_hal_ahb_get_freq_hz();
4200c2af:	fffde5        	call8	4200c28c <clk_hal_ahb_get_freq_hz>
}
4200c2b2:	0a2d      	mov.n	a2, a10
4200c2b4:	f01d      	retw.n
	...

4200c2b8 <brownout_ll_set_threshold>:
{
4200c2b8:	004136        	entry	a1, 32
4200c2bb:	02fd      	mov.n	a15, a2
    REGI2C_WRITE_MASK(I2C_BOD, I2C_BOD_THRESHOLD, threshold);
4200c2bd:	0e0c      	movi.n	a14, 0
4200c2bf:	2d0c      	movi.n	a13, 2
4200c2c1:	5c0c      	movi.n	a12, 5
4200c2c3:	1b0c      	movi.n	a11, 1
4200c2c5:	61a0a2        	movi	a10, 97
4200c2c8:	d2a281        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
4200c2cb:	0008e0        	callx8	a8
}
4200c2ce:	f01d      	retw.n

4200c2d0 <brownout_hal_config>:

#include "hal/brownout_ll.h"
#include "hal/brownout_hal.h"

void brownout_hal_config(const brownout_hal_config_t *cfg)
{
4200c2d0:	004136        	entry	a1, 32
    RTCCNTL.fib_sel.val &= ~BROWNOUT_DETECTOR_LL_FIB_ENABLE;
4200c2d3:	cf9071        	l32r	a7, 42000114 <_stext+0xf4> (60008000 <RTCCNTL>)
4200c2d6:	0020c0        	memw
4200c2d9:	522782        	l32i	a8, a7, 0x148
4200c2dc:	d97c      	movi.n	a9, -3
4200c2de:	108890        	and	a8, a8, a9
4200c2e1:	0020c0        	memw
4200c2e4:	526782        	s32i	a8, a7, 0x148
    RTCCNTL.brown_out.ana_rst_en = enable;
4200c2e7:	0020c0        	memw
4200c2ea:	3a2782        	l32i	a8, a7, 232
4200c2ed:	d29991        	l32r	a9, 42000d54 <_stext+0xd34> (efffffff <_rtc_reserved_end+0x8fefffff>)
4200c2f0:	108890        	and	a8, a8, a9
4200c2f3:	0020c0        	memw
4200c2f6:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.int_wait = cycle;
4200c2f9:	0020c0        	memw
4200c2fc:	3a2782        	l32i	a8, a7, 232
4200c2ff:	d29691        	l32r	a9, 42000d58 <_stext+0xd38> (ffffc00f <_rtc_reserved_end+0x9fefc00f>)
4200c302:	108890        	and	a8, a8, a9
4200c305:	092c      	movi.n	a9, 32
4200c307:	208890        	or	a8, a8, a9
4200c30a:	0020c0        	memw
4200c30d:	3a6782        	s32i	a8, a7, 232
    // If brownout software control is enabled, hw ana reset should be disabled, because it always has the highest priority.
    brownout_ll_ana_reset_enable(false);
    brownout_ll_set_intr_wait_cycles(2);
    brownout_ll_enable_flash_suspend(cfg->flash_power_down);
4200c310:	030292        	l8ui	a9, a2, 3
    RTCCNTL.brown_out.close_flash_ena = enable;
4200c313:	0020c0        	memw
4200c316:	3a2782        	l32i	a8, a7, 232
4200c319:	049090        	extui	a9, a9, 0, 1
4200c31c:	119920        	slli	a9, a9, 14
4200c31f:	cfd1a1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
4200c322:	1088a0        	and	a8, a8, a10
4200c325:	208890        	or	a8, a8, a9
4200c328:	0020c0        	memw
4200c32b:	3a6782        	s32i	a8, a7, 232
    brownout_ll_enable_rf_power_down(cfg->rf_power_down);
4200c32e:	040292        	l8ui	a9, a2, 4
    RTCCNTL.brown_out.pd_rf_ena = enable;
4200c331:	0020c0        	memw
4200c334:	3a2782        	l32i	a8, a7, 232
4200c337:	049090        	extui	a9, a9, 0, 1
4200c33a:	119910        	slli	a9, a9, 15
4200c33d:	cfc7a1        	l32r	a10, 4200025c <_stext+0x23c> (ffff7fff <_rtc_reserved_end+0x9fef7fff>)
4200c340:	1088a0        	and	a8, a8, a10
4200c343:	208890        	or	a8, a8, a9
4200c346:	0020c0        	memw
4200c349:	3a6782        	s32i	a8, a7, 232
/**
 * @brief Clear BOD internal count.
 */
static inline void brownout_ll_clear_count(void)
{
    RTCCNTL.brown_out.cnt_clr = 1;
4200c34c:	0020c0        	memw
4200c34f:	3a2782        	l32i	a8, a7, 232
4200c352:	d28291        	l32r	a9, 42000d5c <_stext+0xd3c> (20000000 <UserFrameTotalSize+0x1fffff00>)
4200c355:	208890        	or	a8, a8, a9
4200c358:	0020c0        	memw
4200c35b:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.cnt_clr = 0;
4200c35e:	0020c0        	memw
4200c361:	3a2782        	l32i	a8, a7, 232
4200c364:	d27f91        	l32r	a9, 42000d60 <_stext+0xd40> (dfffffff <_rtc_reserved_end+0x7fefffff>)
4200c367:	108890        	and	a8, a8, a9
4200c36a:	0020c0        	memw
4200c36d:	3a6782        	s32i	a8, a7, 232
    brownout_ll_clear_count();
    brownout_ll_reset_config(cfg->reset_enabled, 0x3ff, BROWNOUT_RESET_LEVEL_SYSTEM);
4200c370:	020292        	l8ui	a9, a2, 2
    RTCCNTL.brown_out.rst_wait = reset_wait;
4200c373:	0020c0        	memw
4200c376:	3a2782        	l32i	a8, a7, 232
4200c379:	d27aa1        	l32r	a10, 42000d64 <_stext+0xd44> (3ff0000 <UserFrameTotalSize+0x3feff00>)
4200c37c:	2088a0        	or	a8, a8, a10
4200c37f:	0020c0        	memw
4200c382:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.rst_ena = reset_ena;
4200c385:	0020c0        	memw
4200c388:	3a2782        	l32i	a8, a7, 232
4200c38b:	049090        	extui	a9, a9, 0, 1
4200c38e:	019960        	slli	a9, a9, 26
4200c391:	d275a1        	l32r	a10, 42000d68 <_stext+0xd48> (fbffffff <_rtc_reserved_end+0x9befffff>)
4200c394:	1088a0        	and	a8, a8, a10
4200c397:	208890        	or	a8, a8, a9
4200c39a:	0020c0        	memw
4200c39d:	3a6782        	s32i	a8, a7, 232
    RTCCNTL.brown_out.rst_sel = reset_level;
4200c3a0:	0020c0        	memw
4200c3a3:	3a2782        	l32i	a8, a7, 232
4200c3a6:	d27191        	l32r	a9, 42000d6c <_stext+0xd4c> (8000000 <UserFrameTotalSize+0x7ffff00>)
4200c3a9:	208890        	or	a8, a8, a9
4200c3ac:	0020c0        	memw
4200c3af:	3a6782        	s32i	a8, a7, 232
    brownout_ll_set_threshold(cfg->threshold);
4200c3b2:	0002a2        	l8ui	a10, a2, 0
4200c3b5:	fff025        	call8	4200c2b8 <brownout_ll_set_threshold>
    brownout_ll_bod_enable(cfg->enabled);
4200c3b8:	010292        	l8ui	a9, a2, 1
    RTCCNTL.brown_out.ena = bod_enable;
4200c3bb:	0020c0        	memw
4200c3be:	3a2782        	l32i	a8, a7, 232
4200c3c1:	049090        	extui	a9, a9, 0, 1
4200c3c4:	019920        	slli	a9, a9, 30
4200c3c7:	d26aa1        	l32r	a10, 42000d70 <_stext+0xd50> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4200c3ca:	1088a0        	and	a8, a8, a10
4200c3cd:	208890        	or	a8, a8, a9
4200c3d0:	0020c0        	memw
4200c3d3:	3a6782        	s32i	a8, a7, 232
}
4200c3d6:	f01d      	retw.n

4200c3d8 <esp_cpu_configure_region_protection>:

#include <stdint.h>
#include "hal/mpu_hal.h"

void esp_cpu_configure_region_protection(void)
{
4200c3d8:	008136        	entry	a1, 64
    /* Note: currently this is configured the same on all Xtensa targets
     *
     * Both chips have the address space divided into 8 regions, 512MB each.
     */
    const int illegal_regions[] = {0, 4, 5, 6, 7}; // 0x00000000, 0x80000000, 0xa0000000, 0xc0000000, 0xe0000000
4200c3db:	4c1c      	movi.n	a12, 20
4200c3dd:	d265b1        	l32r	a11, 42000d74 <_stext+0xd54> (3c028408 <rtc_io_num_map+0xc4>)
4200c3e0:	01ad      	mov.n	a10, a1
4200c3e2:	cf1181        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200c3e5:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4200c3e8:	070c      	movi.n	a7, 0
4200c3ea:	000346        	j	4200c3fb <esp_cpu_configure_region_protection+0x23>
        mpu_hal_set_region_access(illegal_regions[i], MPU_REGION_ILLEGAL);
4200c3ed:	a08710        	addx4	a8, a7, a1
4200c3f0:	00a0b2        	movi	a11, 0
4200c3f3:	0028a2        	l32i	a10, a8, 0
4200c3f6:	0b09a5        	call8	42017490 <mpu_hal_set_region_access>
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4200c3f9:	771b      	addi.n	a7, a7, 1
4200c3fb:	ee57b6        	bltui	a7, 5, 4200c3ed <esp_cpu_configure_region_protection+0x15>
    }

    mpu_hal_set_region_access(1, MPU_REGION_RW); // 0x20000000
4200c3fe:	1b0c      	movi.n	a11, 1
4200c400:	0bad      	mov.n	a10, a11
4200c402:	0b08e5        	call8	42017490 <mpu_hal_set_region_access>
}
4200c405:	f01d      	retw.n
	...

4200c408 <esp_gpio_reserve>:
#include "esp_private/esp_gpio_reserve.h"

static _Atomic uint64_t s_reserved_pin_mask = ATOMIC_VAR_INIT(~(SOC_GPIO_VALID_GPIO_MASK));

uint64_t esp_gpio_reserve(uint64_t gpio_mask)
{
4200c408:	004136        	entry	a1, 32
4200c40b:	02cd      	mov.n	a12, a2
4200c40d:	03dd      	mov.n	a13, a3
    return atomic_fetch_or(&s_reserved_pin_mask, gpio_mask);
4200c40f:	5e0c      	movi.n	a14, 5
4200c411:	d259a1        	l32r	a10, 42000d78 <_stext+0xd58> (3fc92a90 <s_reserved_pin_mask>)
4200c414:	d25a81        	l32r	a8, 42000d7c <_stext+0xd5c> (4037ff10 <__atomic_fetch_or_8>)
4200c417:	0008e0        	callx8	a8
}
4200c41a:	0a2d      	mov.n	a2, a10
4200c41c:	0b3d      	mov.n	a3, a11
4200c41e:	f01d      	retw.n

4200c420 <esp_clk_tree_src_get_freq_hz>:

static const char *TAG = "esp_clk_tree";

esp_err_t esp_clk_tree_src_get_freq_hz(soc_module_clk_t clk_src, esp_clk_tree_src_freq_precision_t precision,
uint32_t *freq_value)
{
4200c420:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(clk_src > 0 && clk_src < SOC_MOD_CLK_INVALID, ESP_ERR_INVALID_ARG, TAG, "unknown clk src");
4200c423:	820b      	addi.n	a8, a2, -1
4200c425:	b90c      	movi.n	a9, 11
4200c427:	25b987        	bgeu	a9, a8, 4200c450 <esp_clk_tree_src_get_freq_hz+0x30>
4200c42a:	cf0d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c42d:	0008e0        	callx8	a8
4200c430:	d256b1        	l32r	a11, 42000d88 <_stext+0xd68> (3c0261c0 <_flash_rodata_start+0x60a0>)
4200c433:	581c      	movi.n	a8, 21
4200c435:	0189      	s32i.n	a8, a1, 0
4200c437:	d253f1        	l32r	a15, 42000d84 <_stext+0xd64> (3c02841c <__FUNCTION__$0>)
4200c43a:	0bed      	mov.n	a14, a11
4200c43c:	0add      	mov.n	a13, a10
4200c43e:	d253c1        	l32r	a12, 42000d8c <_stext+0xd6c> (3c0261d0 <_flash_rodata_start+0x60b0>)
4200c441:	1a0c      	movi.n	a10, 1
4200c443:	cf1481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c446:	0008e0        	callx8	a8
4200c449:	02a122        	movi	a2, 0x102
4200c44c:	005406        	j	4200c5a0 <esp_clk_tree_src_get_freq_hz+0x180>
4200c44f:	33b600        	clamps	a11, a6, 7
    ESP_RETURN_ON_FALSE(precision < ESP_CLK_TREE_SRC_FREQ_PRECISION_INVALID, ESP_ERR_INVALID_ARG, TAG, "unknown precision");
4200c452:	038126        	beqi	a1, 8, 4200c459 <esp_clk_tree_src_get_freq_hz+0x39>
4200c455:	0008e0cf 	ee.vmulas.s16.accx.ld.ip.qup	q1, a12, 0, q7, q4, q0, q0
4200c459:	d24bb1        	l32r	a11, 42000d88 <_stext+0xd68> (3c0261c0 <_flash_rodata_start+0x60a0>)
4200c45c:	681c      	movi.n	a8, 22
4200c45e:	0189      	s32i.n	a8, a1, 0
4200c460:	d249f1        	l32r	a15, 42000d84 <_stext+0xd64> (3c02841c <__FUNCTION__$0>)
4200c463:	0bed      	mov.n	a14, a11
4200c465:	20daa0        	or	a13, a10, a10
4200c468:	d24ac1        	l32r	a12, 42000d90 <_stext+0xd70> (3c0261f8 <_flash_rodata_start+0x60d8>)
4200c46b:	01a0a2        	movi	a10, 1
4200c46e:	cf0981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c471:	0008e0        	callx8	a8
4200c474:	02a122        	movi	a2, 0x102
4200c477:	004946        	j	4200c5a0 <esp_clk_tree_src_get_freq_hz+0x180>
    ESP_RETURN_ON_FALSE(freq_value, ESP_ERR_INVALID_ARG, TAG, "null pointer");
4200c47a:	64ec      	bnez.n	a4, 4200c4a4 <esp_clk_tree_src_get_freq_hz+0x84>
4200c47c:	cef981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c47f:	0008e0        	callx8	a8
4200c482:	d241b1        	l32r	a11, 42000d88 <_stext+0xd68> (3c0261c0 <_flash_rodata_start+0x60a0>)
4200c485:	781c      	movi.n	a8, 23
4200c487:	0189      	s32i.n	a8, a1, 0
4200c489:	d23ef1        	l32r	a15, 42000d84 <_stext+0xd64> (3c02841c <__FUNCTION__$0>)
4200c48c:	0bed      	mov.n	a14, a11
4200c48e:	0add      	mov.n	a13, a10
4200c490:	d241c1        	l32r	a12, 42000d94 <_stext+0xd74> (3c024e6c <_flash_rodata_start+0x4d4c>)
4200c493:	01a0a2        	movi	a10, 1
4200c496:	ceff81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c499:	0008e0        	callx8	a8
4200c49c:	02a122        	movi	a2, 0x102
4200c49f:	003f46        	j	4200c5a0 <esp_clk_tree_src_get_freq_hz+0x180>
4200c4a2:	660000        	ee.ldf.64.xp	f0, f6, a0, a0

    uint32_t clk_src_freq = 0;
    switch (clk_src) {
4200c4a5:	460262        	l8ui	a6, a2, 70
4200c4a8:	0039      	s32i.n	a3, a0, 0
4200c4aa:	2272f6        	bgeui	a2, 7, 4200c4d0 <esp_clk_tree_src_get_freq_hz+0xb0>
4200c4ad:	023266        	bnei	a2, 3, 4200c4b3 <esp_clk_tree_src_get_freq_hz+0x93>
4200c4b0:	002306        	j	4200c540 <esp_clk_tree_src_get_freq_hz+0x120>
4200c4b3:	0d42f6        	bgeui	a2, 4, 4200c4c4 <esp_clk_tree_src_get_freq_hz+0xa4>
4200c4b6:	3e1226        	beqi	a2, 1, 4200c4f8 <esp_clk_tree_src_get_freq_hz+0xd8>
4200c4b9:	022266        	bnei	a2, 2, 4200c4bf <esp_clk_tree_src_get_freq_hz+0x9f>
4200c4bc:	002206        	j	4200c548 <esp_clk_tree_src_get_freq_hz+0x128>
4200c4bf:	002986        	j	4200c569 <esp_clk_tree_src_get_freq_hz+0x149>
4200c4c2:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
4200c4c5:	42          	.byte	0x42
4200c4c6:	6639      	s32i.n	a3, a6, 24
4200c4c8:	c60252        	l8ui	a5, a2, 198
4200c4cb:	060032        	l8ui	a3, a0, 6
4200c4ce:	660026        	beqi	a0, -1, 4200c538 <esp_clk_tree_src_get_freq_hz+0x118>
4200c4d1:	460292        	l8ui	a9, a2, 70
4200c4d4:	20          	.byte	0x20
4200c4d5:	00          	.byte	00
4200c4d6:	a80c      	movi.n	a8, 10
4200c4d8:	103827        	bltu	a8, a2, 4200c4ec <esp_clk_tree_src_get_freq_hz+0xcc>
4200c4db:	028266        	bnei	a2, 8, 4200c4e1 <esp_clk_tree_src_get_freq_hz+0xc1>
4200c4de:	001f86        	j	4200c560 <esp_clk_tree_src_get_freq_hz+0x140>
4200c4e1:	980c      	movi.n	a8, 9
4200c4e3:	691287        	beq	a2, a8, 4200c550 <esp_clk_tree_src_get_freq_hz+0x130>
4200c4e6:	2a7226        	beqi	a2, 7, 4200c514 <esp_clk_tree_src_get_freq_hz+0xf4>
4200c4e9:	001f06        	j	4200c569 <esp_clk_tree_src_get_freq_hz+0x149>
4200c4ec:	b80c      	movi.n	a8, 11
4200c4ee:	161287        	beq	a2, a8, 4200c508 <esp_clk_tree_src_get_freq_hz+0xe8>
4200c4f1:	5ba226        	beqi	a2, 12, 4200c550 <esp_clk_tree_src_get_freq_hz+0x130>
4200c4f4:	001c46        	j	4200c569 <esp_clk_tree_src_get_freq_hz+0x149>
4200c4f7:	00          	.byte	00
    case SOC_MOD_CLK_CPU:
        clk_src_freq = clk_hal_cpu_get_freq_hz();
4200c4f8:	ffcca5        	call8	4200c1c4 <clk_hal_cpu_get_freq_hz>
        break;
4200c4fb:	0019c6        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
4200c4fe:	000000        	ill
    case SOC_MOD_CLK_APB:
        clk_src_freq = clk_hal_apb_get_freq_hz();
4200c501:	ffdaa5        	call8	4200c2ac <clk_hal_apb_get_freq_hz>
        break;
4200c504:	001786        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
4200c507:	c2a500        	quou	a10, a5, a0
    case SOC_MOD_CLK_XTAL:
        clk_src_freq = clk_hal_xtal_get_freq_mhz() * MHZ;
4200c50a:	d08e81ff 	ee.fft.ams.s16.ld.incp	q1, a15, q1, q2, q6, q0, q6, 0
4200c50e:	82aa80        	mull	a10, a10, a8
        break;
4200c511:	001446        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
4200c514:	d20a81        	l32r	a8, 42000d3c <_stext+0xd1c> (600c0010 <SYSTEM+0x10>)
4200c517:	0020c0        	memw
4200c51a:	0888      	l32i.n	a8, a8, 0
4200c51c:	049280        	extui	a9, a8, 2, 1
    switch (pll_freq_sel) {
4200c51f:	086827        	bbci	a8, 2, 4200c52b <esp_clk_tree_src_get_freq_hz+0x10b>
4200c522:	0b1966        	bnei	a9, 1, 4200c531 <esp_clk_tree_src_get_freq_hz+0x111>
        return CLK_LL_PLL_480M_FREQ_MHZ;
4200c525:	e0a1a2        	movi	a10, 0x1e0
4200c528:	0001c6        	j	4200c533 <esp_clk_tree_src_get_freq_hz+0x113>
    switch (pll_freq_sel) {
4200c52b:	40a1a2        	movi	a10, 0x140
4200c52e:	000046        	j	4200c533 <esp_clk_tree_src_get_freq_hz+0x113>
        return 0;
4200c531:	0a0c      	movi.n	a10, 0
        break;
    case SOC_MOD_CLK_PLL_F160M:
        clk_src_freq = CLK_LL_PLL_160M_FREQ_MHZ * MHZ;
        break;
    case SOC_MOD_CLK_PLL_D2:
        clk_src_freq = (clk_ll_bbpll_get_freq_mhz() * MHZ) >> 1;
4200c533:	d08481        	l32r	a8, 42000744 <_stext+0x724> (f4240 <UserFrameTotalSize+0xf4140>)
4200c536:	82aa80        	mull	a10, a10, a8
4200c539:	41a1a0        	srli	a10, a10, 1
        break;
4200c53c:	000986        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
4200c53f:	00          	.byte	00
    case SOC_MOD_CLK_RTC_SLOW:
        clk_src_freq = esp_clk_tree_lp_slow_get_freq_hz(precision);
4200c540:	03ad      	mov.n	a10, a3
4200c542:	f98965        	call8	42005dd8 <esp_clk_tree_lp_slow_get_freq_hz>
        break;
4200c545:	000746        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
    case SOC_MOD_CLK_RTC_FAST:
        clk_src_freq = esp_clk_tree_lp_fast_get_freq_hz(precision);
4200c548:	03ad      	mov.n	a10, a3
4200c54a:	f98ee5        	call8	42005e38 <esp_clk_tree_lp_fast_get_freq_hz>
        break;
4200c54d:	000546        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
    case SOC_MOD_CLK_RC_FAST:
    case SOC_MOD_CLK_TEMP_SENSOR:
        clk_src_freq = esp_clk_tree_rc_fast_get_freq_hz(precision);
4200c550:	03ad      	mov.n	a10, a3
4200c552:	f98ca5        	call8	42005e1c <esp_clk_tree_rc_fast_get_freq_hz>
        break;
4200c555:	000346        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
    case SOC_MOD_CLK_RC_FAST_D256:
        clk_src_freq = esp_clk_tree_rc_fast_d256_get_freq_hz(precision);
4200c558:	03ad      	mov.n	a10, a3
4200c55a:	f97c65        	call8	42005d20 <esp_clk_tree_rc_fast_d256_get_freq_hz>
        break;
4200c55d:	000146        	j	4200c566 <esp_clk_tree_src_get_freq_hz+0x146>
    case SOC_MOD_CLK_XTAL32K:
        clk_src_freq = esp_clk_tree_xtal32k_get_freq_hz(precision);
4200c560:	20a330        	or	a10, a3, a3
4200c563:	f981a5        	call8	42005d7c <esp_clk_tree_xtal32k_get_freq_hz>
        break;
    default:
        break;
    }

    ESP_RETURN_ON_FALSE(clk_src_freq, ESP_FAIL, TAG,
4200c566:	032a56        	bnez	a10, 4200c59c <esp_clk_tree_src_get_freq_hz+0x17c>
4200c569:	cebd81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c56c:	0008e0        	callx8	a8
4200c56f:	d206b1        	l32r	a11, 42000d88 <_stext+0xd68> (3c0261c0 <_flash_rodata_start+0x60a0>)
4200c572:	41a082        	movi	a8, 65
4200c575:	0189      	s32i.n	a8, a1, 0
4200c577:	d203f1        	l32r	a15, 42000d84 <_stext+0xd64> (3c02841c <__FUNCTION__$0>)
4200c57a:	0bed      	mov.n	a14, a11
4200c57c:	0add      	mov.n	a13, a10
4200c57e:	d206c1        	l32r	a12, 42000d98 <_stext+0xd78> (3c026220 <_flash_rodata_start+0x6100>)
4200c581:	1a0c      	movi.n	a10, 1
4200c583:	cec481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c586:	0008e0        	callx8	a8
4200c589:	f27c      	movi.n	a2, -1
4200c58b:	000446        	j	4200c5a0 <esp_clk_tree_src_get_freq_hz+0x180>
4200c58e:	a10000        	sll	a0, a0
    switch (clk_src) {
4200c591:	d1fc      	bnez.n	a1, 4200c5d2 <esp_partition_is_flash_region_writable+0x2e>
4200c593:	000146        	j	4200c59c <esp_clk_tree_src_get_freq_hz+0x17c>
4200c596:	000000        	ill
        clk_src_freq = CLK_LL_PLL_80M_FREQ_MHZ * MHZ;
4200c599:	d1e0a1        	l32r	a10, 42000d1c <_stext+0xcfc> (4c4b400 <UserFrameTotalSize+0x4c4b300>)
                        "freq shouldn't be 0, calibration failed");
    *freq_value = clk_src_freq;
4200c59c:	04a9      	s32i.n	a10, a4, 0
    return ESP_OK;
4200c59e:	020c      	movi.n	a2, 0
}
4200c5a0:	f01d      	retw.n
	...

4200c5a4 <esp_partition_is_flash_region_writable>:
    }
    return false;
}

bool esp_partition_is_flash_region_writable(size_t addr, size_t size)
{
4200c5a4:	004136        	entry	a1, 32
    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);
4200c5a7:	00a0c2        	movi	a12, 0
4200c5aa:	ffa0b2        	movi	a11, 255
4200c5ad:	20abb0        	or	a10, a11, a11
4200c5b0:	0035a5        	call8	4200c90c <esp_partition_find>
4200c5b3:	207aa0        	or	a7, a10, a10
    for (; it != NULL; it = esp_partition_next(it)) {
4200c5b6:	000a06        	j	4200c5e2 <esp_partition_is_flash_region_writable+0x3e>
        const esp_partition_t *p = esp_partition_get(it);
4200c5b9:	07ad      	mov.n	a10, a7
4200c5bb:	0038e5        	call8	4200c948 <esp_partition_get>
        if (p->readonly) {
4200c5be:	2a0a82        	l8ui	a8, a10, 42
4200c5c1:	489c      	beqz.n	a8, 4200c5d9 <esp_partition_is_flash_region_writable+0x35>
            if (addr >= p->address && addr < p->address + p->size) {
4200c5c3:	3a88      	l32i.n	a8, a10, 12
4200c5c5:	073287        	bltu	a2, a8, 4200c5d0 <esp_partition_is_flash_region_writable+0x2c>
4200c5c8:	4a98      	l32i.n	a9, a10, 16
4200c5ca:	809890        	add	a9, a8, a9
4200c5cd:	193297        	bltu	a2, a9, 4200c5ea <esp_partition_is_flash_region_writable+0x46>
                return false;
            }
            if (addr < p->address && addr + size > p->address) {
4200c5d0:	05b287        	bgeu	a2, a8, 4200c5d9 <esp_partition_is_flash_region_writable+0x35>
4200c5d3:	809230        	add	a9, a2, a3
4200c5d6:	163897        	bltu	a8, a9, 4200c5f0 <esp_partition_is_flash_region_writable+0x4c>
    for (; it != NULL; it = esp_partition_next(it)) {
4200c5d9:	20a770        	or	a10, a7, a7
4200c5dc:	002a25        	call8	4200c880 <esp_partition_next>
4200c5df:	207aa0        	or	a7, a10, a10
4200c5e2:	fd3756        	bnez	a7, 4200c5b9 <esp_partition_is_flash_region_writable+0x15>
                return false;
            }
        }
    }
    return true;
4200c5e5:	120c      	movi.n	a2, 1
4200c5e7:	0001c6        	j	4200c5f2 <esp_partition_is_flash_region_writable+0x4e>
                return false;
4200c5ea:	020c      	movi.n	a2, 0
4200c5ec:	000086        	j	4200c5f2 <esp_partition_is_flash_region_writable+0x4e>
4200c5ef:	020c00        	andb	b0, b12, b0
}
4200c5f2:	f01d      	retw.n

4200c5f4 <esp_partition_main_flash_region_safe>:

bool esp_partition_main_flash_region_safe(size_t addr, size_t size)
{
4200c5f4:	004136        	entry	a1, 32
    if (addr <= ESP_PARTITION_TABLE_OFFSET + ESP_PARTITION_TABLE_MAX_LEN) {
4200c5f7:	d1e981        	l32r	a8, 42000d9c <_stext+0xd7c> (8c00 <UserFrameTotalSize+0x8b00>)
4200c5fa:	1bb827        	bgeu	a8, a2, 4200c619 <esp_partition_main_flash_region_safe+0x25>
        return false;
    }
    const esp_partition_t *p = esp_ota_get_running_partition();
4200c5fd:	003665        	call8	4200c964 <esp_ota_get_running_partition>
    if (addr >= p->address && addr < p->address + p->size) {
4200c600:	3a88      	l32i.n	a8, a10, 12
4200c602:	063287        	bltu	a2, a8, 4200c60c <esp_partition_main_flash_region_safe+0x18>
4200c605:	4a98      	l32i.n	a9, a10, 16
4200c607:	989a      	add.n	a9, a8, a9
4200c609:	113297        	bltu	a2, a9, 4200c61e <esp_partition_main_flash_region_safe+0x2a>
        return false;
    }
    if (addr < p->address && addr + size > p->address) {
4200c60c:	14b287        	bgeu	a2, a8, 4200c624 <esp_partition_main_flash_region_safe+0x30>
4200c60f:	323a      	add.n	a3, a2, a3
4200c611:	143837        	bltu	a8, a3, 4200c629 <esp_partition_main_flash_region_safe+0x35>
        return false;
    }
    return true;
4200c614:	120c      	movi.n	a2, 1
4200c616:	000446        	j	4200c62b <esp_partition_main_flash_region_safe+0x37>
        return false;
4200c619:	020c      	movi.n	a2, 0
4200c61b:	000306        	j	4200c62b <esp_partition_main_flash_region_safe+0x37>
        return false;
4200c61e:	020c      	movi.n	a2, 0
4200c620:	0001c6        	j	4200c62b <esp_partition_main_flash_region_safe+0x37>
4200c623:	120c00        	andbc	b0, b12, b0
    return true;
4200c626:	000046        	j	4200c62b <esp_partition_main_flash_region_safe+0x37>
        return false;
4200c629:	020c      	movi.n	a2, 0
}
4200c62b:	f01d      	retw.n
4200c62d:	000000        	ill

4200c630 <is_partition_encrypted>:
static _lock_t s_partition_list_lock;

static const char *TAG = "partition";

static bool is_partition_encrypted(bool encryption_config, esp_partition_type_t type, esp_partition_subtype_t subtype)
{
4200c630:	004136        	entry	a1, 32
4200c633:	207220        	or	a7, a2, a2
    (void) subtype;
    (void) encryption_config;
    return false;
#else
    bool ret_encrypted = encryption_config;
    if (!esp_flash_encryption_enabled()) {
4200c636:	d1da81        	l32r	a8, 42000da0 <_stext+0xd80> (403775cc <esp_flash_encryption_enabled>)
4200c639:	0008e0        	callx8	a8
4200c63c:	0a2d      	mov.n	a2, a10
4200c63e:	043a16        	beqz	a10, 4200c685 <is_partition_encrypted+0x55>
        /* If flash encryption is not turned on, no partitions should be treated as encrypted */
        ret_encrypted = false;
    } else if (type == ESP_PARTITION_TYPE_APP
4200c641:	40f380        	nsau	a8, a3
4200c644:	418580        	srli	a8, a8, 5
                || (type == ESP_PARTITION_TYPE_BOOTLOADER)
4200c647:	fec392        	addi	a9, a3, -2
4200c64a:	40f990        	nsau	a9, a9
4200c64d:	419590        	srli	a9, a9, 5
4200c650:	208890        	or	a8, a8, a9
    } else if (type == ESP_PARTITION_TYPE_APP
4200c653:	e8ec      	bnez.n	a8, 4200c685 <is_partition_encrypted+0x55>
                || (type == ESP_PARTITION_TYPE_PARTITION_TABLE)
4200c655:	2c3326        	beqi	a3, 3, 4200c685 <is_partition_encrypted+0x55>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_OTA)
4200c658:	330b      	addi.n	a3, a3, -1
4200c65a:	40f330        	nsau	a3, a3
4200c65d:	413530        	srli	a3, a3, 5
4200c660:	40f480        	nsau	a8, a4
4200c663:	418580        	srli	a8, a8, 5
4200c666:	1b8387        	bany	a3, a8, 4200c685 <is_partition_encrypted+0x55>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_TEE_OTA)
4200c669:	70af82        	movi	a8, -144
4200c66c:	848a      	add.n	a8, a4, a8
4200c66e:	40f880        	nsau	a8, a8
4200c671:	418580        	srli	a8, a8, 5
4200c674:	0d8387        	bany	a3, a8, 4200c685 <is_partition_encrypted+0x55>
                || (type == ESP_PARTITION_TYPE_DATA && subtype == ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS)) {
4200c677:	fcc442        	addi	a4, a4, -4
4200c67a:	40f440        	nsau	a4, a4
4200c67d:	414540        	srli	a4, a4, 5
4200c680:	018347        	bany	a3, a4, 4200c685 <is_partition_encrypted+0x55>
    bool ret_encrypted = encryption_config;
4200c683:	072d      	mov.n	a2, a7
    // FE can be enabled in virt eFuses but not in real eFuses.
    ret_encrypted &= efuse_hal_flash_encryption_enabled();
#endif
    return ret_encrypted;
#endif
}
4200c685:	f01d      	retw.n
	...

4200c688 <load_partitions>:

// Create linked list of partition_list_item_t structures.
// This function is called only once, with s_partition_list_lock taken.
static esp_err_t load_partitions(void)
{
4200c688:	016136        	entry	a1, 176
#if !CONFIG_IDF_TARGET_LINUX
    spi_flash_mmap_handle_t handle;
#endif

    // Temporary list of loaded partitions, if valid then we copy this to s_partition_list
    typeof(s_partition_list) new_partitions_list = SLIST_HEAD_INITIALIZER(s_partition_list);
4200c68b:	040c      	movi.n	a4, 0
    const uint8_t *md5_part = NULL;
    const uint8_t *stored_md5;
    uint8_t calc_md5[ESP_ROM_MD5_DIGEST_LEN];
    md5_context_t context;

    esp_rom_md5_init(&context);
4200c68d:	18c1a2        	addi	a10, a1, 24
4200c690:	d1cc81        	l32r	a8, 42000dc0 <_stext+0xda0> (40001c5c <MD5Init>)
4200c693:	0008e0        	callx8	a8

#if CONFIG_IDF_TARGET_LINUX
    esp_err_t err = esp_partition_file_mmap(&p_start);
    size_t mapped_size = ESP_PARTITION_EMULATED_SECTOR_SIZE;
#else
    esp_err_t err = spi_flash_mmap(partition_align_pg_size,
4200c696:	e14b      	addi.n	a14, a1, 4
4200c698:	01dd      	mov.n	a13, a1
4200c69a:	04cd      	mov.n	a12, a4
4200c69c:	d0bfb1        	l32r	a11, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
4200c69f:	04ad      	mov.n	a10, a4
4200c6a1:	fe8365        	call8	4200aed8 <spi_flash_mmap>
4200c6a4:	0a2d      	mov.n	a2, a10
                                   SPI_FLASH_SEC_SIZE, SPI_FLASH_MMAP_DATA, (const void **)&p_start, &handle);
    size_t mapped_size = SPI_FLASH_SEC_SIZE;
#endif

    if (err != ESP_OK) {
4200c6a6:	14ca56        	bnez	a10, 4200c7f6 <load_partitions+0x16e>
        return err;
    }

    // calculate partition address within mmap-ed region
    p_start += partition_pad;
4200c6a9:	0138      	l32i.n	a3, a1, 0
4200c6ab:	ceeb61        	l32r	a6, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
4200c6ae:	636a      	add.n	a6, a3, a6
4200c6b0:	0169      	s32i.n	a6, a1, 0
    p_end = p_start + mapped_size;
4200c6b2:	d1bc81        	l32r	a8, 42000da4 <_stext+0xd84> (9000 <UserFrameTotalSize+0x8f00>)
4200c6b5:	338a      	add.n	a3, a3, a8
    partition_list_item_t *last = NULL;
4200c6b7:	045d      	mov.n	a5, a4

    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200c6b9:	002b06        	j	4200c769 <load_partitions+0xe1>
        esp_partition_info_t entry;
        // copying to RAM instead of using pointer to flash to avoid any chance of TOCTOU due to cache miss
        // when flash encryption is used
        memcpy(&entry, p_entry, sizeof(entry));
4200c6bc:	0c2c      	movi.n	a12, 32
4200c6be:	06bd      	mov.n	a11, a6
4200c6c0:	70c1a2        	addi	a10, a1, 112
4200c6c3:	ce5981        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200c6c6:	0008e0        	callx8	a8

#if CONFIG_PARTITION_TABLE_MD5
        if (entry.magic == ESP_PARTITION_MAGIC_MD5) {
4200c6c9:	381182        	l16ui	a8, a1, 112
4200c6cc:	d1bc91        	l32r	a9, 42000dbc <_stext+0xd9c> (ebeb <UserFrameTotalSize+0xeaeb>)
4200c6cf:	029897        	bne	a8, a9, 4200c6d5 <load_partitions+0x4d>
4200c6d2:	0026c6        	j	4200c771 <load_partitions+0xe9>
            md5_part = p_entry;
            break;
        }
#endif
        if (entry.magic != ESP_PARTITION_MAGIC) {
4200c6d5:	d1b891        	l32r	a9, 42000db8 <_stext+0xd98> (50aa <UserFrameTotalSize+0x4faa>)
4200c6d8:	021897        	beq	a8, a9, 4200c6de <load_partitions+0x56>
4200c6db:	001f46        	j	4200c75c <load_partitions+0xd4>
            break;
        }

#if CONFIG_PARTITION_TABLE_MD5
        esp_rom_md5_update(&context, &entry, sizeof(entry));
4200c6de:	0c2c      	movi.n	a12, 32
4200c6e0:	70c1b2        	addi	a11, a1, 112
4200c6e3:	18c1a2        	addi	a10, a1, 24
4200c6e6:	d1b781        	l32r	a8, 42000dc4 <_stext+0xda4> (40001c68 <MD5Update>)
4200c6e9:	0008e0        	callx8	a8
#endif

        // allocate new linked list item and populate it with data from partition table
        partition_list_item_t *item = (partition_list_item_t *) calloc(1, sizeof(partition_list_item_t));
4200c6ec:	4b3c      	movi.n	a11, 52
4200c6ee:	1a0c      	movi.n	a10, 1
4200c6f0:	d14881        	l32r	a8, 42000c10 <_stext+0xbf0> (4037fe9c <calloc>)
4200c6f3:	0008e0        	callx8	a8
4200c6f6:	0a7d      	mov.n	a7, a10
        if (item == NULL) {
4200c6f8:	065a16        	beqz	a10, 4200c761 <load_partitions+0xd9>
            break;
        }
#if CONFIG_IDF_TARGET_LINUX
        item->info.flash_chip = NULL;
#else
        item->info.flash_chip = esp_flash_default_chip;
4200c6fb:	d12d81        	l32r	a8, 42000bb0 <_stext+0xb90> (3fc953c4 <esp_flash_default_chip>)
4200c6fe:	0888      	l32i.n	a8, a8, 0
4200c700:	0a89      	s32i.n	a8, a10, 0
#endif
        item->info.address = entry.pos.offset;
4200c702:	1d2182        	l32i	a8, a1, 116
4200c705:	3a89      	s32i.n	a8, a10, 12
        item->info.size = entry.pos.size;
4200c707:	1e2182        	l32i	a8, a1, 120
4200c70a:	4a89      	s32i.n	a8, a10, 16
#if CONFIG_IDF_TARGET_LINUX
        item->info.erase_size = ESP_PARTITION_EMULATED_SECTOR_SIZE;
#else
        item->info.erase_size = SPI_FLASH_SEC_SIZE;
4200c70c:	d0a381        	l32r	a8, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
4200c70f:	5a89      	s32i.n	a8, a10, 20
#endif
        item->info.type = entry.type;
4200c711:	7201b2        	l8ui	a11, a1, 114
4200c714:	1ab9      	s32i.n	a11, a10, 4
        item->info.subtype = entry.subtype;
4200c716:	7301c2        	l8ui	a12, a1, 115
4200c719:	026ac2        	s32i	a12, a10, 8
        item->info.encrypted = is_partition_encrypted(entry.flags & PART_FLAG_ENCRYPTED, entry.type, entry.subtype);
4200c71c:	2321a2        	l32i	a10, a1, 140
4200c71f:	04a0a0        	extui	a10, a10, 0, 1
4200c722:	fff0e5        	call8	4200c630 <is_partition_encrypted>
4200c725:	2947a2        	s8i	a10, a7, 41
        item->info.readonly = entry.flags & PART_FLAG_READONLY;
4200c728:	232182        	l32i	a8, a1, 140
4200c72b:	048180        	extui	a8, a8, 1, 1
4200c72e:	2a4782        	s8i	a8, a7, 42
        item->user_registered = false;
4200c731:	080c      	movi.n	a8, 0
4200c733:	2c4782        	s8i	a8, a7, 44
            ESP_LOGI(TAG, "Ignoring encrypted flag for \"%s\" partition", entry.label);
            item->info.encrypted = false;
        }
#endif
        // item->info.label is initialized by calloc, so resulting string will be null terminated
        strncpy(item->info.label, (const char *) entry.label, sizeof(item->info.label) - 1);
4200c736:	0c1c      	movi.n	a12, 16
4200c738:	7cc1b2        	addi	a11, a1, 124
4200c73b:	18c7a2        	addi	a10, a7, 24
4200c73e:	d1a281        	l32r	a8, 42000dc8 <_stext+0xda8> (40001224 <strncpy>)
4200c741:	0008e0        	callx8	a8

        // add it to the list
        if (last == NULL) {
4200c744:	55cc      	bnez.n	a5, 4200c74d <load_partitions+0xc5>
            SLIST_INSERT_HEAD(&new_partitions_list, item, next);
4200c746:	c749      	s32i.n	a4, a7, 48
4200c748:	074d      	mov.n	a4, a7
4200c74a:	000146        	j	4200c753 <load_partitions+0xcb>
        } else {
            SLIST_INSERT_AFTER(last, item, next);
4200c74d:	c588      	l32i.n	a8, a5, 48
4200c74f:	c789      	s32i.n	a8, a7, 48
4200c751:	c579      	s32i.n	a7, a5, 48
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200c753:	20c662        	addi	a6, a6, 32
        }
        last = item;
4200c756:	075d      	mov.n	a5, a7
4200c758:	000346        	j	4200c769 <load_partitions+0xe1>
4200c75b:	060c00        	ee.ldf.64.xp	f0, f0, a0, a12
    const uint8_t *md5_part = NULL;
4200c75e:	0003c6        	j	4200c771 <load_partitions+0xe9>
4200c761:	0a6d      	mov.n	a6, a10
            err = ESP_ERR_NO_MEM;
4200c763:	01a122        	movi	a2, 0x101
4200c766:	0001c6        	j	4200c771 <load_partitions+0xe9>
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200c769:	02b637        	bgeu	a6, a3, 4200c76f <load_partitions+0xe7>
4200c76c:	ffd306        	j	4200c6bc <load_partitions+0x34>
    const uint8_t *md5_part = NULL;
4200c76f:	060c      	movi.n	a6, 0
    }

#if CONFIG_PARTITION_TABLE_MD5
    if (md5_part == NULL) {
4200c771:	f6dc      	bnez.n	a6, 4200c794 <load_partitions+0x10c>
        ESP_LOGE(TAG, "No MD5 found in partition table");
4200c773:	ce3b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c776:	0008e0        	callx8	a8
4200c779:	d18bb1        	l32r	a11, 42000da8 <_stext+0xd88> (3c026260 <_flash_rodata_start+0x6140>)
4200c77c:	0bed      	mov.n	a14, a11
4200c77e:	0add      	mov.n	a13, a10
4200c780:	d18bc1        	l32r	a12, 42000dac <_stext+0xd8c> (3c02626c <_flash_rodata_start+0x614c>)
4200c783:	01a0a2        	movi	a10, 1
4200c786:	ce4381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c789:	0008e0        	callx8	a8
        err = ESP_ERR_NOT_FOUND;
4200c78c:	05a122        	movi	a2, 0x105
4200c78f:	001246        	j	4200c7dc <load_partitions+0x154>
4200c792:	620000        	saltu	a0, a0, a0
    } else {
        stored_md5 = md5_part + ESP_PARTITION_MD5_OFFSET;
4200c795:	8b10c6        	j	41fef3dc <_iram_bss_end+0x1c6cfdc>
        esp_rom_md5_final(calc_md5, &context);
4200c798:	c1b271        	l32r	a7, 41ffce60 <_iram_bss_end+0x1c7aa60>
4200c79b:	ad18      	l32i.n	a1, a13, 40
4200c79d:	8b8107        	bany	a1, a0, 4200c72c <load_partitions+0xa4>
4200c7a0:	08e0d1        	l32r	a13, 41fceb20 <_iram_bss_end+0x1c4c720>
4200c7a3:	00          	.byte	00
#if !CONFIG_IDF_TARGET_LINUX
        ESP_LOG_BUFFER_HEXDUMP("calculated md5", calc_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
        ESP_LOG_BUFFER_HEXDUMP("stored md5", stored_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
#endif

        if (memcmp(calc_md5, stored_md5, ESP_ROM_MD5_DIGEST_LEN) != 0) {
4200c7a4:	0c1c      	movi.n	a12, 16
4200c7a6:	06bd      	mov.n	a11, a6
4200c7a8:	07ad      	mov.n	a10, a7
4200c7aa:	d18981        	l32r	a8, 42000dd0 <_stext+0xdb0> (4000120c <memcmp>)
4200c7ad:	0008e0        	callx8	a8
4200c7b0:	ea9c      	beqz.n	a10, 4200c7d2 <load_partitions+0x14a>
            ESP_LOGE(TAG, "Partition table MD5 mismatch");
4200c7b2:	ce2b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c7b5:	0008e0        	callx8	a8
4200c7b8:	d17cb1        	l32r	a11, 42000da8 <_stext+0xd88> (3c026260 <_flash_rodata_start+0x6140>)
4200c7bb:	0bed      	mov.n	a14, a11
4200c7bd:	20daa0        	or	a13, a10, a10
4200c7c0:	d17cc1        	l32r	a12, 42000db0 <_stext+0xd90> (3c02629c <_flash_rodata_start+0x617c>)
4200c7c3:	01a0a2        	movi	a10, 1
4200c7c6:	ce3381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c7c9:	0008e0        	callx8	a8
            err = ESP_ERR_INVALID_STATE;
4200c7cc:	03a122        	movi	a2, 0x103
4200c7cf:	000246        	j	4200c7dc <load_partitions+0x154>
            ESP_LOGV(TAG, "Partition table MD5 verified");
        }
    }
#endif

    if (err == ESP_OK) {
4200c7d2:	62cc      	bnez.n	a2, 4200c7dc <load_partitions+0x154>
        /* Don't copy the list to the static variable unless it's verified */
        s_partition_list = new_partitions_list;
4200c7d4:	d17881        	l32r	a8, 42000db4 <_stext+0xd94> (3fc953f0 <s_partition_list>)
4200c7d7:	0849      	s32i.n	a4, a8, 0
4200c7d9:	0004c6        	j	4200c7f0 <load_partitions+0x168>
    } else {
        /* Otherwise, free all the memory we just allocated */
        partition_list_item_t *it = new_partitions_list.slh_first;
4200c7dc:	04ad      	mov.n	a10, a4
        while (it) {
4200c7de:	0002c6        	j	4200c7ed <load_partitions+0x165>
            partition_list_item_t *next = it->next.sle_next;
4200c7e1:	0c2a72        	l32i	a7, a10, 48
            free(it);
4200c7e4:	cf6281        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200c7e7:	0008e0        	callx8	a8
            it = next;
4200c7ea:	20a770        	or	a10, a7, a7
        while (it) {
4200c7ed:	ff0a56        	bnez	a10, 4200c7e1 <load_partitions+0x159>
        }
    }

#if !CONFIG_IDF_TARGET_LINUX
    spi_flash_munmap(handle);
4200c7f0:	0121a2        	l32i	a10, a1, 4
4200c7f3:	fe77a5        	call8	4200af6c <spi_flash_munmap>
#endif

    return err;
}
4200c7f6:	f01d      	retw.n

4200c7f8 <ensure_partitions_loaded>:

    assert(SLIST_EMPTY(&s_partition_list));
}

static esp_err_t ensure_partitions_loaded(void)
{
4200c7f8:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
    if (SLIST_EMPTY(&s_partition_list)) {
4200c7fb:	d16e81        	l32r	a8, 42000db4 <_stext+0xd94> (3fc953f0 <s_partition_list>)
4200c7fe:	0888      	l32i.n	a8, a8, 0
4200c800:	044856        	bnez	a8, 4200c848 <ensure_partitions_loaded+0x50>
        // only lock if list is empty (and check again after acquiring lock)
        _lock_acquire(&s_partition_list_lock);
4200c803:	d174a1        	l32r	a10, 42000dd4 <_stext+0xdb4> (3fc953ec <s_partition_list_lock>)
4200c806:	cfdf81        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
4200c809:	0008e0        	callx8	a8
        if (SLIST_EMPTY(&s_partition_list)) {
4200c80c:	d16a81        	l32r	a8, 42000db4 <_stext+0xd94> (3fc953f0 <s_partition_list>)
4200c80f:	0888      	l32i.n	a8, a8, 0
4200c811:	58ec      	bnez.n	a8, 4200c83a <ensure_partitions_loaded+0x42>
            ESP_LOGV(TAG, "Loading the partition table");
            err = load_partitions();
4200c813:	ffe765        	call8	4200c688 <load_partitions>
4200c816:	0a2d      	mov.n	a2, a10
            if (err != ESP_OK) {
4200c818:	0aac      	beqz.n	a10, 4200c83c <ensure_partitions_loaded+0x44>
                ESP_LOGE(TAG, "load_partitions returned 0x%x", err);
4200c81a:	ce1181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4200c81d:	0008e0        	callx8	a8
4200c820:	d162b1        	l32r	a11, 42000da8 <_stext+0xd88> (3c026260 <_flash_rodata_start+0x6140>)
4200c823:	02fd      	mov.n	a15, a2
4200c825:	0bed      	mov.n	a14, a11
4200c827:	0add      	mov.n	a13, a10
4200c829:	d16bc1        	l32r	a12, 42000dd8 <_stext+0xdb8> (3c0262c8 <_flash_rodata_start+0x61a8>)
4200c82c:	1a0c      	movi.n	a10, 1
4200c82e:	ce1981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4200c831:	0008e0        	callx8	a8
4200c834:	000106        	j	4200c83c <ensure_partitions_loaded+0x44>
4200c837:	000000        	ill
    esp_err_t err = ESP_OK;
4200c83a:	020c      	movi.n	a2, 0
            }
        }
        _lock_release(&s_partition_list_lock);
4200c83c:	d166a1        	l32r	a10, 42000dd4 <_stext+0xdb4> (3fc953ec <s_partition_list_lock>)
4200c83f:	cfd281        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
4200c842:	0008e0        	callx8	a8
4200c845:	000046        	j	4200c84a <ensure_partitions_loaded+0x52>
    esp_err_t err = ESP_OK;
4200c848:	020c      	movi.n	a2, 0
    }
    return err;
}
4200c84a:	f01d      	retw.n

4200c84c <iterator_create>:

static esp_partition_iterator_opaque_t *iterator_create(esp_partition_type_t type,
        esp_partition_subtype_t subtype, const char *label)
{
4200c84c:	004136        	entry	a1, 32
4200c84f:	027d      	mov.n	a7, a2
    esp_partition_iterator_opaque_t *it =
        (esp_partition_iterator_opaque_t *) malloc(sizeof(esp_partition_iterator_opaque_t));
4200c851:	4a1c      	movi.n	a10, 20
4200c853:	cfda81        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
4200c856:	0008e0        	callx8	a8
4200c859:	0a2d      	mov.n	a2, a10
    if (it == NULL) {
4200c85b:	fa8c      	beqz.n	a10, 4200c86e <iterator_create+0x22>
        return NULL;
    }
    it->type = type;
4200c85d:	0a79      	s32i.n	a7, a10, 0
    it->subtype = subtype;
4200c85f:	1a39      	s32i.n	a3, a10, 4
    it->label = label;
4200c861:	2a49      	s32i.n	a4, a10, 8
    it->next_item = SLIST_FIRST(&s_partition_list);
4200c863:	d15481        	l32r	a8, 42000db4 <_stext+0xd94> (3fc953f0 <s_partition_list>)
4200c866:	0888      	l32i.n	a8, a8, 0
4200c868:	3a89      	s32i.n	a8, a10, 12
    it->info = NULL;
4200c86a:	080c      	movi.n	a8, 0
4200c86c:	4a89      	s32i.n	a8, a10, 16
    return it;
}
4200c86e:	f01d      	retw.n

4200c870 <esp_partition_iterator_release>:
    esp_partition_iterator_release(it);
    return res;
}

void esp_partition_iterator_release(esp_partition_iterator_t iterator)
{
4200c870:	004136        	entry	a1, 32
4200c873:	20a220        	or	a10, a2, a2
    // iterator == NULL is okay
    free(iterator);
4200c876:	cf3d81        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4200c879:	0008e0        	callx8	a8
}
4200c87c:	f01d      	retw.n
	...

4200c880 <esp_partition_next>:
{
4200c880:	004136        	entry	a1, 32
4200c883:	027d      	mov.n	a7, a2
    assert(it);
4200c885:	02dc      	bnez.n	a2, 4200c899 <esp_partition_next+0x19>
4200c887:	d155d1        	l32r	a13, 42000ddc <_stext+0xdbc> (3c020230 <_flash_rodata_start+0x110>)
4200c88a:	d155c1        	l32r	a12, 42000de0 <_stext+0xdc0> (3c028454 <__func__$3>)
4200c88d:	48a1b2        	movi	a11, 0x148
4200c890:	d155a1        	l32r	a10, 42000de4 <_stext+0xdc4> (3c026333 <_flash_rodata_start+0x6213>)
4200c893:	ce1d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200c896:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
4200c899:	032222        	l32i	a2, a2, 12
4200c89c:	008256        	bnez	a2, 4200c8a8 <esp_partition_next+0x28>
        esp_partition_iterator_release(it);
4200c89f:	20a770        	or	a10, a7, a7
4200c8a2:	fffce5        	call8	4200c870 <esp_partition_iterator_release>
        return NULL;
4200c8a5:	0017c6        	j	4200c908 <esp_partition_next+0x88>
    _lock_acquire(&s_partition_list_lock);
4200c8a8:	d14ba1        	l32r	a10, 42000dd4 <_stext+0xdb4> (3fc953ec <s_partition_list_lock>)
4200c8ab:	cfb681        	l32r	a8, 42000784 <_stext+0x764> (40376a3c <_lock_acquire>)
4200c8ae:	0008e0        	callx8	a8
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
4200c8b1:	000b46        	j	4200c8e2 <esp_partition_next+0x62>
        if (it->type != ESP_PARTITION_TYPE_ANY && it->type != p->type) {
4200c8b4:	0788      	l32i.n	a8, a7, 0
4200c8b6:	ffa092        	movi	a9, 255
4200c8b9:	041897        	beq	a8, a9, 4200c8c1 <esp_partition_next+0x41>
4200c8bc:	1698      	l32i.n	a9, a6, 4
4200c8be:	1c9897        	bne	a8, a9, 4200c8de <esp_partition_next+0x5e>
        if (it->subtype != ESP_PARTITION_SUBTYPE_ANY && it->subtype != p->subtype) {
4200c8c1:	1788      	l32i.n	a8, a7, 4
4200c8c3:	ffa092        	movi	a9, 255
4200c8c6:	041897        	beq	a8, a9, 4200c8ce <esp_partition_next+0x4e>
4200c8c9:	2698      	l32i.n	a9, a6, 8
4200c8cb:	0f9897        	bne	a8, a9, 4200c8de <esp_partition_next+0x5e>
        if (it->label != NULL && strcmp(it->label, p->label) != 0) {
4200c8ce:	27a8      	l32i.n	a10, a7, 8
4200c8d0:	014a16        	beqz	a10, 4200c8e8 <esp_partition_next+0x68>
4200c8d3:	18c6b2        	addi	a11, a6, 24
4200c8d6:	cedd81        	l32r	a8, 4200044c <_stext+0x42c> (40001230 <strcmp>)
4200c8d9:	0008e0        	callx8	a8
4200c8dc:	8a8c      	beqz.n	a10, 4200c8e8 <esp_partition_next+0x68>
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
4200c8de:	c688      	l32i.n	a8, a6, 48
4200c8e0:	3789      	s32i.n	a8, a7, 12
4200c8e2:	032762        	l32i	a6, a7, 12
4200c8e5:	fcb656        	bnez	a6, 4200c8b4 <esp_partition_next+0x34>
    _lock_release(&s_partition_list_lock);
4200c8e8:	d13ba1        	l32r	a10, 42000dd4 <_stext+0xdb4> (3fc953ec <s_partition_list_lock>)
4200c8eb:	cfa781        	l32r	a8, 42000788 <_stext+0x768> (40376a7c <_lock_release>)
4200c8ee:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
4200c8f1:	032722        	l32i	a2, a7, 12
4200c8f4:	008256        	bnez	a2, 4200c900 <esp_partition_next+0x80>
        esp_partition_iterator_release(it);
4200c8f7:	20a770        	or	a10, a7, a7
4200c8fa:	fff765        	call8	4200c870 <esp_partition_iterator_release>
        return NULL;
4200c8fd:	0001c6        	j	4200c908 <esp_partition_next+0x88>
    it->info = &it->next_item->info;
4200c900:	4729      	s32i.n	a2, a7, 16
    it->next_item = SLIST_NEXT(it->next_item, next);
4200c902:	c288      	l32i.n	a8, a2, 48
4200c904:	3789      	s32i.n	a8, a7, 12
    return it;
4200c906:	072d      	mov.n	a2, a7
}
4200c908:	f01d      	retw.n
	...

4200c90c <esp_partition_find>:
{
4200c90c:	004136        	entry	a1, 32
    if (ensure_partitions_loaded() != ESP_OK) {
4200c90f:	ffeea5        	call8	4200c7f8 <ensure_partitions_loaded>
4200c912:	026a56        	bnez	a10, 4200c93c <esp_partition_find+0x30>
    if (type == ESP_PARTITION_TYPE_ANY && subtype != ESP_PARTITION_SUBTYPE_ANY) {
4200c915:	01af92        	movi	a9, -255
4200c918:	829a      	add.n	a8, a2, a9
4200c91a:	40f880        	nsau	a8, a8
4200c91d:	418580        	srli	a8, a8, 5
4200c920:	939a      	add.n	a9, a3, a9
4200c922:	1a0c      	movi.n	a10, 1
4200c924:	83a990        	moveqz	a10, a9, a9
4200c927:	1788a7        	bany	a8, a10, 4200c942 <esp_partition_find+0x36>
    esp_partition_iterator_t it = iterator_create(type, subtype, label);
4200c92a:	04cd      	mov.n	a12, a4
4200c92c:	03bd      	mov.n	a11, a3
4200c92e:	02ad      	mov.n	a10, a2
4200c930:	fff1a5        	call8	4200c84c <iterator_create>
    if (it == NULL) {
4200c933:	da8c      	beqz.n	a10, 4200c944 <esp_partition_find+0x38>
    it = esp_partition_next(it);
4200c935:	fff4a5        	call8	4200c880 <esp_partition_next>
    return it;
4200c938:	000206        	j	4200c944 <esp_partition_find+0x38>
4200c93b:	0a0c00        	add.s	f0, f12, f0
        return NULL;
4200c93e:	000086        	j	4200c944 <esp_partition_find+0x38>
4200c941:	0a0c00        	add.s	f0, f12, f0
}
4200c944:	0a2d      	mov.n	a2, a10
4200c946:	f01d      	retw.n

4200c948 <esp_partition_get>:

const esp_partition_t *esp_partition_get(esp_partition_iterator_t iterator)
{
4200c948:	004136        	entry	a1, 32
    assert(iterator != NULL);
4200c94b:	011256        	bnez	a2, 4200c960 <esp_partition_get+0x18>
4200c94e:	d126d1        	l32r	a13, 42000de8 <_stext+0xdc8> (3c026340 <_flash_rodata_start+0x6220>)
4200c951:	d126c1        	l32r	a12, 42000dec <_stext+0xdcc> (3c028440 <__func__$2>)
4200c954:	7ba1b2        	movi	a11, 0x17b
4200c957:	d123a1        	l32r	a10, 42000de4 <_stext+0xdc4> (3c026333 <_flash_rodata_start+0x6213>)
4200c95a:	cdeb81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200c95d:	0008e0        	callx8	a8
    return iterator->info;
}
4200c960:	4228      	l32i.n	a2, a2, 16
4200c962:	f01d      	retw.n

4200c964 <esp_ota_get_running_partition>:
    }
}


const esp_partition_t* esp_ota_get_running_partition(void)
{
4200c964:	004136        	entry	a1, 32

    /*
     * Currently running partition is unlikely to change across reset cycle,
     * so it can be cached here, and avoid lookup on every flash write operation.
     */
    if (curr_partition != NULL) {
4200c967:	d12281        	l32r	a8, 42000df0 <_stext+0xdd0> (3fc953f4 <curr_partition$2>)
4200c96a:	0828      	l32i.n	a2, a8, 0
4200c96c:	072256        	bnez	a2, 4200c9e2 <esp_ota_get_running_partition+0x7e>
        return curr_partition;
    }

    /* Find the flash address of this exact function. By definition that is part
       of the currently running firmware. Then find the enclosing partition. */
    size_t phys_offs = spi_flash_cache2phys(esp_ota_get_running_partition);
4200c96f:	d121a1        	l32r	a10, 42000df4 <_stext+0xdd4> (4200c964 <esp_ota_get_running_partition>)
4200c972:	fe63e5        	call8	4200afb0 <spi_flash_cache2phys>
4200c975:	206aa0        	or	a6, a10, a10

    assert (phys_offs != SPI_FLASH_CACHE2PHYS_FAIL); /* indicates cache2phys lookup is buggy */
4200c978:	110a66        	bnei	a10, -1, 4200c98d <esp_ota_get_running_partition+0x29>
4200c97b:	d11fd1        	l32r	a13, 42000df8 <_stext+0xdd8> (3c026354 <_flash_rodata_start+0x6234>)
4200c97e:	d11fc1        	l32r	a12, 42000dfc <_stext+0xddc> (3c028468 <__func__$1>)
4200c981:	cca2b2        	movi	a11, 0x2cc
4200c984:	d11fa1        	l32r	a10, 42000e00 <_stext+0xde0> (3c026398 <_flash_rodata_start+0x6278>)
4200c987:	cde081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200c98a:	0008e0        	callx8	a8

    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP,
4200c98d:	0c0c      	movi.n	a12, 0
4200c98f:	ffa0b2        	movi	a11, 255
4200c992:	0cad      	mov.n	a10, a12
4200c994:	fff765        	call8	4200c90c <esp_partition_find>
4200c997:	0a7d      	mov.n	a7, a10
                                                     ESP_PARTITION_SUBTYPE_ANY,
                                                     NULL);
    assert(it != NULL); /* has to be at least one app partition */
4200c999:	03ca56        	bnez	a10, 4200c9d9 <esp_ota_get_running_partition+0x75>
4200c99c:	d11ad1        	l32r	a13, 42000e04 <_stext+0xde4> (3c0263a8 <_flash_rodata_start+0x6288>)
4200c99f:	d117c1        	l32r	a12, 42000dfc <_stext+0xddc> (3c028468 <__func__$1>)
4200c9a2:	d1a2b2        	movi	a11, 0x2d1
4200c9a5:	d116a1        	l32r	a10, 42000e00 <_stext+0xde0> (3c026398 <_flash_rodata_start+0x6278>)
4200c9a8:	cdd881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4200c9ab:	0008e0        	callx8	a8

    while (it != NULL) {
        const esp_partition_t *p = esp_partition_get(it);
4200c9ae:	20a770        	or	a10, a7, a7
4200c9b1:	fff965        	call8	4200c948 <esp_partition_get>
4200c9b4:	202aa0        	or	a2, a10, a10
        if (p->address <= phys_offs && p->address + p->size > phys_offs) {
4200c9b7:	3a88      	l32i.n	a8, a10, 12
4200c9b9:	153687        	bltu	a6, a8, 4200c9d2 <esp_ota_get_running_partition+0x6e>
4200c9bc:	4a98      	l32i.n	a9, a10, 16
4200c9be:	889a      	add.n	a8, a8, a9
4200c9c0:	0eb687        	bgeu	a6, a8, 4200c9d2 <esp_ota_get_running_partition+0x6e>
            esp_partition_iterator_release(it);
4200c9c3:	07ad      	mov.n	a10, a7
4200c9c5:	ffeaa5        	call8	4200c870 <esp_partition_iterator_release>
            curr_partition = p;
4200c9c8:	d10a81        	l32r	a8, 42000df0 <_stext+0xdd0> (3fc953f4 <curr_partition$2>)
4200c9cb:	0829      	s32i.n	a2, a8, 0
            return p;
4200c9cd:	000446        	j	4200c9e2 <esp_ota_get_running_partition+0x7e>
4200c9d0:	00          	.byte	00
4200c9d1:	07ad00        	ee.stf.64.xp	f10, f0, a0, a13
        }
        it = esp_partition_next(it);
4200c9d4:	ffeaa5        	call8	4200c880 <esp_partition_next>
4200c9d7:	0a7d      	mov.n	a7, a10
    while (it != NULL) {
4200c9d9:	fd1756        	bnez	a7, 4200c9ae <esp_ota_get_running_partition+0x4a>
    }

    abort(); /* Partition table is invalid or corrupt */
4200c9dc:	cdc081        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
4200c9df:	0008e0        	callx8	a8
}
4200c9e2:	f01d      	retw.n

4200c9e4 <_fclose_r>:
4200c9e4:	004136        	entry	a1, 32
4200c9e7:	027d      	mov.n	a7, a2
4200c9e9:	53bc      	beqz.n	a3, 4200ca22 <_fclose_r+0x3e>
4200c9eb:	a28c      	beqz.n	a2, 4200c9f9 <_fclose_r+0x15>
4200c9ed:	a288      	l32i.n	a8, a2, 40
4200c9ef:	68cc      	bnez.n	a8, 4200c9f9 <_fclose_r+0x15>
4200c9f1:	02ad      	mov.n	a10, a2
4200c9f3:	201110        	or	a1, a1, a1
4200c9f6:	004665        	call8	4200ce5c <__sinit>
4200c9f9:	192382        	l32i	a8, a3, 100
4200c9fc:	0ee807        	bbsi	a8, 0, 4200ca0e <_fclose_r+0x2a>
4200c9ff:	061382        	l16ui	a8, a3, 12
4200ca02:	22e897        	bbsi	a8, 9, 4200ca28 <_fclose_r+0x44>
4200ca05:	1623a2        	l32i	a10, a3, 88
4200ca08:	d10081        	l32r	a8, 42000e08 <_stext+0xde8> (40376b04 <__retarget_lock_acquire_recursive>)
4200ca0b:	0008e0        	callx8	a8
4200ca0e:	069382        	l16si	a8, a3, 12
4200ca11:	38dc      	bnez.n	a8, 4200ca28 <_fclose_r+0x44>
4200ca13:	192382        	l32i	a8, a3, 100
4200ca16:	08e807        	bbsi	a8, 0, 4200ca22 <_fclose_r+0x3e>
4200ca19:	1623a2        	l32i	a10, a3, 88
4200ca1c:	d0fc81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200ca1f:	0008e0        	callx8	a8
4200ca22:	020c      	movi.n	a2, 0
4200ca24:	001fc6        	j	4200caa7 <_fclose_r+0xc3>
4200ca27:	00          	.byte	00
4200ca28:	03bd      	mov.n	a11, a3
4200ca2a:	07ad      	mov.n	a10, a7
4200ca2c:	201110        	or	a1, a1, a1
4200ca2f:	000925        	call8	4200cac0 <__sflush_r>
4200ca32:	c388      	l32i.n	a8, a3, 48
4200ca34:	0a2d      	mov.n	a2, a10
4200ca36:	00c816        	beqz	a8, 4200ca46 <_fclose_r+0x62>
4200ca39:	0823b2        	l32i	a11, a3, 32
4200ca3c:	07ad      	mov.n	a10, a7
4200ca3e:	0008e0        	callx8	a8
4200ca41:	f87c      	movi.n	a8, -1
4200ca43:	a328a0        	movltz	a2, a8, a10
4200ca46:	061382        	l16ui	a8, a3, 12
4200ca49:	096877        	bbci	a8, 7, 4200ca56 <_fclose_r+0x72>
4200ca4c:	43b8      	l32i.n	a11, a3, 16
4200ca4e:	07ad      	mov.n	a10, a7
4200ca50:	d0f081        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200ca53:	0008e0        	callx8	a8
4200ca56:	d3b8      	l32i.n	a11, a3, 52
4200ca58:	0b9c      	beqz.n	a11, 4200ca6c <_fclose_r+0x88>
4200ca5a:	44c382        	addi	a8, a3, 68
4200ca5d:	071b87        	beq	a11, a8, 4200ca68 <_fclose_r+0x84>
4200ca60:	07ad      	mov.n	a10, a7
4200ca62:	d0eb81        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200ca65:	0008e0        	callx8	a8
4200ca68:	080c      	movi.n	a8, 0
4200ca6a:	d389      	s32i.n	a8, a3, 52
4200ca6c:	1223b2        	l32i	a11, a3, 72
4200ca6f:	bb8c      	beqz.n	a11, 4200ca7e <_fclose_r+0x9a>
4200ca71:	07ad      	mov.n	a10, a7
4200ca73:	d0e781        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200ca76:	0008e0        	callx8	a8
4200ca79:	080c      	movi.n	a8, 0
4200ca7b:	126382        	s32i	a8, a3, 72
4200ca7e:	201110        	or	a1, a1, a1
4200ca81:	003125        	call8	4200cd94 <__sfp_lock_acquire>
4200ca84:	080c      	movi.n	a8, 0
4200ca86:	065382        	s16i	a8, a3, 12
4200ca89:	192382        	l32i	a8, a3, 100
4200ca8c:	08e807        	bbsi	a8, 0, 4200ca98 <_fclose_r+0xb4>
4200ca8f:	1623a2        	l32i	a10, a3, 88
4200ca92:	d0de81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200ca95:	0008e0        	callx8	a8
4200ca98:	1623a2        	l32i	a10, a3, 88
4200ca9b:	d0de81        	l32r	a8, 42000e14 <_stext+0xdf4> (40376ad4 <__retarget_lock_close_recursive>)
4200ca9e:	0008e0        	callx8	a8
4200caa1:	201110        	or	a1, a1, a1
4200caa4:	002fe5        	call8	4200cda4 <__sfp_lock_release>
4200caa7:	f01d      	retw.n
4200caa9:	000000        	ill

4200caac <fclose>:
4200caac:	004136        	entry	a1, 32
4200caaf:	d0da81        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200cab2:	0008e0        	callx8	a8
4200cab5:	02bd      	mov.n	a11, a2
4200cab7:	fff2e5        	call8	4200c9e4 <_fclose_r>
4200caba:	0a2d      	mov.n	a2, a10
4200cabc:	f01d      	retw.n
	...

4200cac0 <__sflush_r>:
4200cac0:	004136        	entry	a1, 32
4200cac3:	069382        	l16si	a8, a3, 12
4200cac6:	026837        	bbci	a8, 3, 4200cacc <__sflush_r+0xc>
4200cac9:	003ac6        	j	4200cbb8 <__sflush_r+0xf8>
4200cacc:	190c      	movi.n	a9, 1
4200cace:	119950        	slli	a9, a9, 11
4200cad1:	209890        	or	a9, a8, a9
4200cad4:	065392        	s16i	a9, a3, 12
4200cad7:	1398      	l32i.n	a9, a3, 4
4200cad9:	0819e6        	bgei	a9, 1, 4200cae5 <__sflush_r+0x25>
4200cadc:	102392        	l32i	a9, a3, 64
4200cadf:	0219e6        	bgei	a9, 1, 4200cae5 <__sflush_r+0x25>
4200cae2:	004206        	j	4200cbee <__sflush_r+0x12e>
4200cae5:	b398      	l32i.n	a9, a3, 44
4200cae7:	103916        	beqz	a9, 4200cbee <__sflush_r+0x12e>
4200caea:	0a0c      	movi.n	a10, 0
4200caec:	048c80        	extui	a8, a8, 12, 1
4200caef:	0278      	l32i.n	a7, a2, 0
4200caf1:	118840        	slli	a8, a8, 12
4200caf4:	02a9      	s32i.n	a10, a2, 0
4200caf6:	488c      	beqz.n	a8, 4200cafe <__sflush_r+0x3e>
4200caf8:	1523c2        	l32i	a12, a3, 84
4200cafb:	001086        	j	4200cb41 <__sflush_r+0x81>
4200cafe:	83b8      	l32i.n	a11, a3, 32
4200cb00:	0c0c      	movi.n	a12, 0
4200cb02:	1d0c      	movi.n	a13, 1
4200cb04:	20a220        	or	a10, a2, a2
4200cb07:	0009e0        	callx8	a9
4200cb0a:	0acd      	mov.n	a12, a10
4200cb0c:	310a66        	bnei	a10, -1, 4200cb41 <__sflush_r+0x81>
4200cb0f:	0288      	l32i.n	a8, a2, 0
4200cb11:	c8ac      	beqz.n	a8, 4200cb41 <__sflush_r+0x81>
4200cb13:	e3c892        	addi	a9, a8, -29
4200cb16:	40f9a0        	nsau	a10, a9
4200cb19:	41a5a0        	srli	a10, a10, 5
4200cb1c:	898c      	beqz.n	a9, 4200cb28 <__sflush_r+0x68>
4200cb1e:	eac882        	addi	a8, a8, -22
4200cb21:	190c      	movi.n	a9, 1
4200cb23:	939a80        	movnez	a9, a10, a8
4200cb26:	398c      	beqz.n	a9, 4200cb2d <__sflush_r+0x6d>
4200cb28:	0279      	s32i.n	a7, a2, 0
4200cb2a:	003006        	j	4200cbee <__sflush_r+0x12e>
4200cb2d:	061382        	l16ui	a8, a3, 12
4200cb30:	094c      	movi.n	a9, 64
4200cb32:	208890        	or	a8, a8, a9
4200cb35:	238880        	sext	a8, a8, 15
4200cb38:	065382        	s16i	a8, a3, 12
4200cb3b:	f27c      	movi.n	a2, -1
4200cb3d:	002bc6        	j	4200cbf0 <__sflush_r+0x130>
4200cb40:	00          	.byte	00
4200cb41:	061382        	l16ui	a8, a3, 12
4200cb44:	0e6827        	bbci	a8, 2, 4200cb56 <__sflush_r+0x96>
4200cb47:	1388      	l32i.n	a8, a3, 4
4200cb49:	c0cc80        	sub	a12, a12, a8
4200cb4c:	d388      	l32i.n	a8, a3, 52
4200cb4e:	488c      	beqz.n	a8, 4200cb56 <__sflush_r+0x96>
4200cb50:	102382        	l32i	a8, a3, 64
4200cb53:	c0cc80        	sub	a12, a12, a8
4200cb56:	b388      	l32i.n	a8, a3, 44
4200cb58:	83b8      	l32i.n	a11, a3, 32
4200cb5a:	0d0c      	movi.n	a13, 0
4200cb5c:	02ad      	mov.n	a10, a2
4200cb5e:	0008e0        	callx8	a8
4200cb61:	069382        	l16si	a8, a3, 12
4200cb64:	0c0a66        	bnei	a10, -1, 4200cb74 <__sflush_r+0xb4>
4200cb67:	0298      	l32i.n	a9, a2, 0
4200cb69:	db1c      	movi.n	a11, 29
4200cb6b:	413b97        	bltu	a11, a9, 4200cbb0 <__sflush_r+0xf0>
4200cb6e:	d0abb1        	l32r	a11, 42000e1c <_stext+0xdfc> (20400001 <UserFrameTotalSize+0x203fff01>)
4200cb71:	3b5b97        	bbc	a11, a9, 4200cbb0 <__sflush_r+0xf0>
4200cb74:	f97c      	movi.n	a9, -1
4200cb76:	f8d992        	addmi	a9, a9, 0xfffff800
4200cb79:	109890        	and	a9, a8, a9
4200cb7c:	065392        	s16i	a9, a3, 12
4200cb7f:	090c      	movi.n	a9, 0
4200cb81:	1399      	s32i.n	a9, a3, 4
4200cb83:	4398      	l32i.n	a9, a3, 16
4200cb85:	0399      	s32i.n	a9, a3, 0
4200cb87:	0968c7        	bbci	a8, 12, 4200cb94 <__sflush_r+0xd4>
4200cb8a:	030a66        	bnei	a10, -1, 4200cb91 <__sflush_r+0xd1>
4200cb8d:	0288      	l32i.n	a8, a2, 0
4200cb8f:	18cc      	bnez.n	a8, 4200cb94 <__sflush_r+0xd4>
4200cb91:	1563a2        	s32i	a10, a3, 84
4200cb94:	d3b8      	l32i.n	a11, a3, 52
4200cb96:	0279      	s32i.n	a7, a2, 0
4200cb98:	052b16        	beqz	a11, 4200cbee <__sflush_r+0x12e>
4200cb9b:	44c382        	addi	a8, a3, 68
4200cb9e:	071b87        	beq	a11, a8, 4200cba9 <__sflush_r+0xe9>
4200cba1:	02ad      	mov.n	a10, a2
4200cba3:	d09b81        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200cba6:	0008e0        	callx8	a8
4200cba9:	080c      	movi.n	a8, 0
4200cbab:	d389      	s32i.n	a8, a3, 52
4200cbad:	000f46        	j	4200cbee <__sflush_r+0x12e>
4200cbb0:	094c      	movi.n	a9, 64
4200cbb2:	208890        	or	a8, a8, a9
4200cbb5:	ffdfc6        	j	4200cb38 <__sflush_r+0x78>
4200cbb8:	4368      	l32i.n	a6, a3, 16
4200cbba:	06bc      	beqz.n	a6, 4200cbee <__sflush_r+0x12e>
4200cbbc:	0378      	l32i.n	a7, a3, 0
4200cbbe:	148080        	extui	a8, a8, 0, 2
4200cbc1:	0369      	s32i.n	a6, a3, 0
4200cbc3:	c07760        	sub	a7, a7, a6
4200cbc6:	090c      	movi.n	a9, 0
4200cbc8:	08cc      	bnez.n	a8, 4200cbcc <__sflush_r+0x10c>
4200cbca:	5398      	l32i.n	a9, a3, 20
4200cbcc:	2399      	s32i.n	a9, a3, 8
4200cbce:	000646        	j	4200cbeb <__sflush_r+0x12b>
4200cbd1:	a388      	l32i.n	a8, a3, 40
4200cbd3:	83b8      	l32i.n	a11, a3, 32
4200cbd5:	07dd      	mov.n	a13, a7
4200cbd7:	20c660        	or	a12, a6, a6
4200cbda:	20a220        	or	a10, a2, a2
4200cbdd:	0008e0        	callx8	a8
4200cbe0:	021ae6        	bgei	a10, 1, 4200cbe6 <__sflush_r+0x126>
4200cbe3:	ffd186        	j	4200cb2d <__sflush_r+0x6d>
4200cbe6:	66aa      	add.n	a6, a6, a10
4200cbe8:	c077a0        	sub	a7, a7, a10
4200cbeb:	e217e6        	bgei	a7, 1, 4200cbd1 <__sflush_r+0x111>
4200cbee:	020c      	movi.n	a2, 0
4200cbf0:	f01d      	retw.n
	...

4200cbf4 <_fflush_r>:
4200cbf4:	004136        	entry	a1, 32
4200cbf7:	4388      	l32i.n	a8, a3, 16
4200cbf9:	005856        	bnez	a8, 4200cc02 <_fflush_r+0xe>
4200cbfc:	020c      	movi.n	a2, 0
4200cbfe:	001186        	j	4200cc48 <_fflush_r+0x54>
4200cc01:	b28c00        	mulsh	a8, a12, a0
4200cc04:	a288      	l32i.n	a8, a2, 40
4200cc06:	78cc      	bnez.n	a8, 4200cc11 <_fflush_r+0x1d>
4200cc08:	20a220        	or	a10, a2, a2
4200cc0b:	201110        	or	a1, a1, a1
4200cc0e:	0024e5        	call8	4200ce5c <__sinit>
4200cc11:	069382        	l16si	a8, a3, 12
4200cc14:	fe4816        	beqz	a8, 4200cbfc <_fflush_r+0x8>
4200cc17:	192392        	l32i	a9, a3, 100
4200cc1a:	0be907        	bbsi	a9, 0, 4200cc29 <_fflush_r+0x35>
4200cc1d:	08e897        	bbsi	a8, 9, 4200cc29 <_fflush_r+0x35>
4200cc20:	1623a2        	l32i	a10, a3, 88
4200cc23:	d07981        	l32r	a8, 42000e08 <_stext+0xde8> (40376b04 <__retarget_lock_acquire_recursive>)
4200cc26:	0008e0        	callx8	a8
4200cc29:	02ad      	mov.n	a10, a2
4200cc2b:	20b330        	or	a11, a3, a3
4200cc2e:	ffe925        	call8	4200cac0 <__sflush_r>
4200cc31:	192382        	l32i	a8, a3, 100
4200cc34:	0a2d      	mov.n	a2, a10
4200cc36:	0ee807        	bbsi	a8, 0, 4200cc48 <_fflush_r+0x54>
4200cc39:	061382        	l16ui	a8, a3, 12
4200cc3c:	08e897        	bbsi	a8, 9, 4200cc48 <_fflush_r+0x54>
4200cc3f:	1623a2        	l32i	a10, a3, 88
4200cc42:	d07281        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200cc45:	0008e0        	callx8	a8
4200cc48:	f01d      	retw.n
	...

4200cc4c <fflush>:
4200cc4c:	004136        	entry	a1, 32
4200cc4f:	02dc      	bnez.n	a2, 4200cc63 <fflush+0x17>
4200cc51:	ced6c1        	l32r	a12, 420007ac <_stext+0x78c> (3fc92aa4 <__sglue>)
4200cc54:	d073b1        	l32r	a11, 42000e20 <_stext+0xe00> (4200cbf4 <_fflush_r>)
4200cc57:	ced2a1        	l32r	a10, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
4200cc5a:	201110        	or	a1, a1, a1
4200cc5d:	0a87e5        	call8	420174dc <_fwalk_sglue>
4200cc60:	000286        	j	4200cc6e <fflush+0x22>
4200cc63:	d06d81        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200cc66:	0008e0        	callx8	a8
4200cc69:	02bd      	mov.n	a11, a2
4200cc6b:	fff8a5        	call8	4200cbf4 <_fflush_r>
4200cc6e:	0a2d      	mov.n	a2, a10
4200cc70:	f01d      	retw.n
	...

4200cc74 <std>:
4200cc74:	004136        	entry	a1, 32
4200cc77:	070c      	movi.n	a7, 0
4200cc79:	0279      	s32i.n	a7, a2, 0
4200cc7b:	1279      	s32i.n	a7, a2, 4
4200cc7d:	2279      	s32i.n	a7, a2, 8
4200cc7f:	196272        	s32i	a7, a2, 100
4200cc82:	4279      	s32i.n	a7, a2, 16
4200cc84:	5279      	s32i.n	a7, a2, 20
4200cc86:	6279      	s32i.n	a7, a2, 24
4200cc88:	065232        	s16i	a3, a2, 12
4200cc8b:	075242        	s16i	a4, a2, 14
4200cc8e:	8c0c      	movi.n	a12, 8
4200cc90:	00a0b2        	movi	a11, 0
4200cc93:	5cc2a2        	addi	a10, a2, 92
4200cc96:	cd9b81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200cc99:	0008e0        	callx8	a8
4200cc9c:	d06281        	l32r	a8, 42000e24 <_stext+0xe04> (4200d1b8 <__sread>)
4200cc9f:	d065a1        	l32r	a10, 42000e34 <_stext+0xe14> (3fc95464 <__sf+0x68>)
4200cca2:	9289      	s32i.n	a8, a2, 36
4200cca4:	d06181        	l32r	a8, 42000e28 <_stext+0xe08> (4200d1f4 <__swrite>)
4200cca7:	c0a2a0        	sub	a10, a2, a10
4200ccaa:	a289      	s32i.n	a8, a2, 40
4200ccac:	d06081        	l32r	a8, 42000e2c <_stext+0xe0c> (4200d230 <__sseek>)
4200ccaf:	079d      	mov.n	a9, a7
4200ccb1:	b289      	s32i.n	a8, a2, 44
4200ccb3:	d05f81        	l32r	a8, 42000e30 <_stext+0xe10> (4200d26c <__sclose>)
4200ccb6:	8229      	s32i.n	a2, a2, 32
4200ccb8:	c289      	s32i.n	a8, a2, 48
4200ccba:	180c      	movi.n	a8, 1
4200ccbc:	8398a0        	moveqz	a9, a8, a10
4200ccbf:	d05ea1        	l32r	a10, 42000e38 <_stext+0xe18> (3fc953fc <__sf>)
4200ccc2:	c0a2a0        	sub	a10, a2, a10
4200ccc5:	8378a0        	moveqz	a7, a8, a10
4200ccc8:	209970        	or	a9, a9, a7
4200cccb:	99cc      	bnez.n	a9, 4200ccd8 <std+0x64>
4200cccd:	d05ba1        	l32r	a10, 42000e3c <_stext+0xe1c> (3fc954cc <__sf+0xd0>)
4200ccd0:	c0a2a0        	sub	a10, a2, a10
4200ccd3:	9389a0        	movnez	a8, a9, a10
4200ccd6:	788c      	beqz.n	a8, 4200cce1 <std+0x6d>
4200ccd8:	58c2a2        	addi	a10, a2, 88
4200ccdb:	d05981        	l32r	a8, 42000e40 <_stext+0xe20> (40376ab0 <__retarget_lock_init_recursive>)
4200ccde:	0008e0        	callx8	a8
4200cce1:	f01d      	retw.n
	...

4200cce4 <stdio_exit_handler>:
4200cce4:	004136        	entry	a1, 32
4200cce7:	ceb1c1        	l32r	a12, 420007ac <_stext+0x78c> (3fc92aa4 <__sglue>)
4200ccea:	d056b1        	l32r	a11, 42000e44 <_stext+0xe24> (4200c9e4 <_fclose_r>)
4200cced:	ceaca1        	l32r	a10, 420007a0 <_stext+0x780> (3fc92ab4 <_impure_data>)
4200ccf0:	201110        	or	a1, a1, a1
4200ccf3:	0a7ea5        	call8	420174dc <_fwalk_sglue>
4200ccf6:	f01d      	retw.n

4200ccf8 <cleanup_stdio>:
4200ccf8:	004136        	entry	a1, 32
4200ccfb:	12b8      	l32i.n	a11, a2, 4
4200ccfd:	d04e81        	l32r	a8, 42000e38 <_stext+0xe18> (3fc953fc <__sf>)
4200cd00:	081b87        	beq	a11, a8, 4200cd0c <cleanup_stdio+0x14>
4200cd03:	20a220        	or	a10, a2, a2
4200cd06:	201110        	or	a1, a1, a1
4200cd09:	ffcda5        	call8	4200c9e4 <_fclose_r>
4200cd0c:	22b8      	l32i.n	a11, a2, 8
4200cd0e:	d04981        	l32r	a8, 42000e34 <_stext+0xe14> (3fc95464 <__sf+0x68>)
4200cd11:	071b87        	beq	a11, a8, 4200cd1c <cleanup_stdio+0x24>
4200cd14:	02ad      	mov.n	a10, a2
4200cd16:	201110        	or	a1, a1, a1
4200cd19:	ffcca5        	call8	4200c9e4 <_fclose_r>
4200cd1c:	32b8      	l32i.n	a11, a2, 12
4200cd1e:	d04781        	l32r	a8, 42000e3c <_stext+0xe1c> (3fc954cc <__sf+0xd0>)
4200cd21:	071b87        	beq	a11, a8, 4200cd2c <cleanup_stdio+0x34>
4200cd24:	02ad      	mov.n	a10, a2
4200cd26:	201110        	or	a1, a1, a1
4200cd29:	ffcba5        	call8	4200c9e4 <_fclose_r>
4200cd2c:	f01d      	retw.n
	...

4200cd30 <__fp_lock>:
4200cd30:	004136        	entry	a1, 32
4200cd33:	192382        	l32i	a8, a3, 100
4200cd36:	0ee807        	bbsi	a8, 0, 4200cd48 <__fp_lock+0x18>
4200cd39:	061382        	l16ui	a8, a3, 12
4200cd3c:	08e897        	bbsi	a8, 9, 4200cd48 <__fp_lock+0x18>
4200cd3f:	1623a2        	l32i	a10, a3, 88
4200cd42:	d03181        	l32r	a8, 42000e08 <_stext+0xde8> (40376b04 <__retarget_lock_acquire_recursive>)
4200cd45:	0008e0        	callx8	a8
4200cd48:	020c      	movi.n	a2, 0
4200cd4a:	f01d      	retw.n

4200cd4c <__fp_unlock>:
4200cd4c:	004136        	entry	a1, 32
4200cd4f:	192382        	l32i	a8, a3, 100
4200cd52:	0ee807        	bbsi	a8, 0, 4200cd64 <__fp_unlock+0x18>
4200cd55:	061382        	l16ui	a8, a3, 12
4200cd58:	08e897        	bbsi	a8, 9, 4200cd64 <__fp_unlock+0x18>
4200cd5b:	1623a2        	l32i	a10, a3, 88
4200cd5e:	d02b81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200cd61:	0008e0        	callx8	a8
4200cd64:	020c      	movi.n	a2, 0
4200cd66:	f01d      	retw.n

4200cd68 <global_stdio_init$part$0>:
4200cd68:	004136        	entry	a1, 32
4200cd6b:	d03781        	l32r	a8, 42000e48 <_stext+0xe28> (3fc95534 <__stdio_exit_handler>)
4200cd6e:	d03791        	l32r	a9, 42000e4c <_stext+0xe2c> (4200cce4 <stdio_exit_handler>)
4200cd71:	d031a1        	l32r	a10, 42000e38 <_stext+0xe18> (3fc953fc <__sf>)
4200cd74:	0899      	s32i.n	a9, a8, 0
4200cd76:	0c0c      	movi.n	a12, 0
4200cd78:	4b0c      	movi.n	a11, 4
4200cd7a:	ffefa5        	call8	4200cc74 <std>
4200cd7d:	d02da1        	l32r	a10, 42000e34 <_stext+0xe14> (3fc95464 <__sf+0x68>)
4200cd80:	01a0c2        	movi	a12, 1
4200cd83:	8b0c      	movi.n	a11, 8
4200cd85:	ffeee5        	call8	4200cc74 <std>
4200cd88:	d02da1        	l32r	a10, 42000e3c <_stext+0xe1c> (3fc954cc <__sf+0xd0>)
4200cd8b:	2c0c      	movi.n	a12, 2
4200cd8d:	2b1c      	movi.n	a11, 18
4200cd8f:	ffee65        	call8	4200cc74 <std>
4200cd92:	f01d      	retw.n

4200cd94 <__sfp_lock_acquire>:
4200cd94:	004136        	entry	a1, 32
4200cd97:	ce74a1        	l32r	a10, 42000768 <_stext+0x748> (3fc95294 <__lock___atexit_recursive_mutex>)
4200cd9a:	d01b81        	l32r	a8, 42000e08 <_stext+0xde8> (40376b04 <__retarget_lock_acquire_recursive>)
4200cd9d:	0008e0        	callx8	a8
4200cda0:	f01d      	retw.n
	...

4200cda4 <__sfp_lock_release>:
4200cda4:	004136        	entry	a1, 32
4200cda7:	ce70a1        	l32r	a10, 42000768 <_stext+0x748> (3fc95294 <__lock___atexit_recursive_mutex>)
4200cdaa:	d01881        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200cdad:	0008e0        	callx8	a8
4200cdb0:	f01d      	retw.n
	...

4200cdb4 <__sfp>:
4200cdb4:	004136        	entry	a1, 32
4200cdb7:	fffde5        	call8	4200cd94 <__sfp_lock_acquire>
4200cdba:	d02381        	l32r	a8, 42000e48 <_stext+0xe28> (3fc95534 <__stdio_exit_handler>)
4200cdbd:	025d      	mov.n	a5, a2
4200cdbf:	002882        	l32i	a8, a8, 0
4200cdc2:	002856        	bnez	a8, 4200cdc8 <__sfp+0x14>
4200cdc5:	fffa25        	call8	4200cd68 <global_stdio_init$part$0>
4200cdc8:	ce7961        	l32r	a6, 420007ac <_stext+0x78c> (3fc92aa4 <__sglue>)
4200cdcb:	2628      	l32i.n	a2, a6, 8
4200cdcd:	1688      	l32i.n	a8, a6, 4
4200cdcf:	001146        	j	4200ce18 <__sfp+0x64>
4200cdd2:	720000        	salt	a0, a0, a0
4200cdd5:	fc0692        	l8ui	a9, a6, 252
4200cdd8:	1d81a7        	bany	a1, a10, 4200cdf9 <__sfp+0x45>
4200cddb:	c2a2d0        	quou	a10, a2, a13
4200cdde:	8958      	l32i.n	a5, a9, 32
4200cde0:	32          	.byte	0x32
4200cde1:	196272        	s32i	a7, a2, 100
4200cde4:	d01781        	l32r	a8, 42000e40 <_stext+0xe20> (40376ab0 <__retarget_lock_init_recursive>)
4200cde7:	0008e0        	callx8	a8
4200cdea:	fffba5        	call8	4200cda4 <__sfp_lock_release>
4200cded:	8c0c      	movi.n	a12, 8
4200cdef:	0279      	s32i.n	a7, a2, 0
4200cdf1:	2279      	s32i.n	a7, a2, 8
4200cdf3:	1279      	s32i.n	a7, a2, 4
4200cdf5:	4279      	s32i.n	a7, a2, 16
4200cdf7:	5279      	s32i.n	a7, a2, 20
4200cdf9:	6279      	s32i.n	a7, a2, 24
4200cdfb:	0b0c      	movi.n	a11, 0
4200cdfd:	5cc2a2        	addi	a10, a2, 92
4200ce00:	cd4181        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200ce03:	0008e0        	callx8	a8
4200ce06:	d279      	s32i.n	a7, a2, 52
4200ce08:	e279      	s32i.n	a7, a2, 56
4200ce0a:	126272        	s32i	a7, a2, 72
4200ce0d:	136272        	s32i	a7, a2, 76
4200ce10:	001186        	j	4200ce5a <__sfp+0xa6>
4200ce13:	220000        	orb	b0, b0, b0
4200ce16:	0b68c2        	s32i	a12, a8, 44
4200ce19:	d688      	l32i.n	a8, a6, 52
4200ce1b:	fb68      	l32i.n	a6, a11, 60
4200ce1d:	0678      	l32i.n	a7, a6, 0
4200ce1f:	27fc      	bnez.n	a7, 4200ce55 <__sfp+0xa1>
4200ce21:	aca1b2        	movi	a11, 0x1ac
4200ce24:	05ad      	mov.n	a10, a5
4200ce26:	d00b81        	l32r	a8, 42000e54 <_stext+0xe34> (4037fee8 <_malloc_r>)
4200ce29:	0008e0        	callx8	a8
4200ce2c:	0a2d      	mov.n	a2, a10
4200ce2e:	aacc      	bnez.n	a10, 4200ce3c <__sfp+0x88>
4200ce30:	06a9      	s32i.n	a10, a6, 0
4200ce32:	fff725        	call8	4200cda4 <__sfp_lock_release>
4200ce35:	c80c      	movi.n	a8, 12
4200ce37:	0589      	s32i.n	a8, a5, 0
4200ce39:	000746        	j	4200ce5a <__sfp+0xa6>
4200ce3c:	480c      	movi.n	a8, 4
4200ce3e:	0a79      	s32i.n	a7, a10, 0
4200ce40:	1a89      	s32i.n	a8, a10, 4
4200ce42:	aacb      	addi.n	a10, a10, 12
4200ce44:	22a9      	s32i.n	a10, a2, 8
4200ce46:	a0a1c2        	movi	a12, 0x1a0
4200ce49:	0b0c      	movi.n	a11, 0
4200ce4b:	cd2e81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200ce4e:	0008e0        	callx8	a8
4200ce51:	027d      	mov.n	a7, a2
4200ce53:	0629      	s32i.n	a2, a6, 0
4200ce55:	076d      	mov.n	a6, a7
4200ce57:	ffdc06        	j	4200cdcb <__sfp+0x17>
4200ce5a:	f01d      	retw.n

4200ce5c <__sinit>:
4200ce5c:	004136        	entry	a1, 32
4200ce5f:	fff365        	call8	4200cd94 <__sfp_lock_acquire>
4200ce62:	0a2282        	l32i	a8, a2, 40
4200ce65:	004816        	beqz	a8, 4200ce6d <__sinit+0x11>
4200ce68:	fff3a5        	call8	4200cda4 <__sfp_lock_release>
4200ce6b:	f01d      	retw.n
4200ce6d:	cffa81        	l32r	a8, 42000e58 <_stext+0xe38> (4200ccf8 <cleanup_stdio>)
4200ce70:	a289      	s32i.n	a8, a2, 40
4200ce72:	cff581        	l32r	a8, 42000e48 <_stext+0xe28> (3fc95534 <__stdio_exit_handler>)
4200ce75:	0888      	l32i.n	a8, a8, 0
4200ce77:	fed856        	bnez	a8, 4200ce68 <__sinit+0xc>
4200ce7a:	ffeee5        	call8	4200cd68 <global_stdio_init$part$0>
4200ce7d:	fff9c6        	j	4200ce68 <__sinit+0xc>

4200ce80 <__fp_lock_all>:
4200ce80:	004136        	entry	a1, 32
4200ce83:	fff125        	call8	4200cd94 <__sfp_lock_acquire>
4200ce86:	ce49c1        	l32r	a12, 420007ac <_stext+0x78c> (3fc92aa4 <__sglue>)
4200ce89:	cff4b1        	l32r	a11, 42000e5c <_stext+0xe3c> (4200cd30 <__fp_lock>)
4200ce8c:	0a0c      	movi.n	a10, 0
4200ce8e:	201110        	or	a1, a1, a1
4200ce91:	0a64a5        	call8	420174dc <_fwalk_sglue>
4200ce94:	f01d      	retw.n
	...

4200ce98 <__fp_unlock_all>:
4200ce98:	004136        	entry	a1, 32
4200ce9b:	ce44c1        	l32r	a12, 420007ac <_stext+0x78c> (3fc92aa4 <__sglue>)
4200ce9e:	cff0b1        	l32r	a11, 42000e60 <_stext+0xe40> (4200cd4c <__fp_unlock>)
4200cea1:	0a0c      	movi.n	a10, 0
4200cea3:	0a63a5        	call8	420174dc <_fwalk_sglue>
4200cea6:	ffefe5        	call8	4200cda4 <__sfp_lock_release>
4200cea9:	f01d      	retw.n
	...

4200ceac <__sfvwrite_r>:
4200ceac:	006136        	entry	a1, 48
4200ceaf:	2498      	l32i.n	a9, a4, 8
4200ceb1:	0129      	s32i.n	a2, a1, 0
4200ceb3:	032d      	mov.n	a2, a3
4200ceb5:	39cc      	bnez.n	a9, 4200cebc <__sfvwrite_r+0x10>
4200ceb7:	020c      	movi.n	a2, 0
4200ceb9:	00a606        	j	4200d155 <__sfvwrite_r+0x2a9>
4200cebc:	061392        	l16ui	a9, a3, 12
4200cebf:	136937        	bbci	a9, 3, 4200ced6 <__sfvwrite_r+0x2a>
4200cec2:	042392        	l32i	a9, a3, 16
4200cec5:	00d916        	beqz	a9, 4200ced6 <__sfvwrite_r+0x2a>
4200cec8:	069292        	l16si	a9, a2, 12
4200cecb:	0478      	l32i.n	a7, a4, 0
4200cecd:	20e917        	bbsi	a9, 1, 4200cef1 <__sfvwrite_r+0x45>
4200ced0:	001346        	j	4200cf21 <__sfvwrite_r+0x75>
4200ced3:	000000        	ill
4200ced6:	01a8      	l32i.n	a10, a1, 0
4200ced8:	02bd      	mov.n	a11, a2
4200ceda:	201110        	or	a1, a1, a1
4200cedd:	003e25        	call8	4200d2c0 <__swsetup_r>
4200cee0:	fe4a16        	beqz	a10, 4200cec8 <__sfvwrite_r+0x1c>
4200cee3:	009b06        	j	4200d153 <__sfvwrite_r+0x2a7>
4200cee6:	0738      	l32i.n	a3, a7, 0
4200cee8:	1768      	l32i.n	a6, a7, 4
4200ceea:	778b      	addi.n	a7, a7, 8
4200ceec:	000206        	j	4200cef8 <__sfvwrite_r+0x4c>
4200ceef:	00          	.byte	00
4200cef0:	00          	.byte	00
4200cef1:	cfdc51        	l32r	a5, 42000e64 <_stext+0xe44> (7fffff80 <_rtc_reserved_end+0x1fefff80>)
4200cef4:	030c      	movi.n	a3, 0
4200cef6:	060c      	movi.n	a6, 0
4200cef8:	fea616        	beqz	a6, 4200cee6 <__sfvwrite_r+0x3a>
4200cefb:	a298      	l32i.n	a9, a2, 40
4200cefd:	82b8      	l32i.n	a11, a2, 32
4200ceff:	01a8      	l32i.n	a10, a1, 0
4200cf01:	63d650        	minu	a13, a6, a5
4200cf04:	03cd      	mov.n	a12, a3
4200cf06:	0009e0        	callx8	a9
4200cf09:	021ae6        	bgei	a10, 1, 4200cf0f <__sfvwrite_r+0x63>
4200cf0c:	008e06        	j	4200d148 <__sfvwrite_r+0x29c>
4200cf0f:	2498      	l32i.n	a9, a4, 8
4200cf11:	33aa      	add.n	a3, a3, a10
4200cf13:	c099a0        	sub	a9, a9, a10
4200cf16:	2499      	s32i.n	a9, a4, 8
4200cf18:	c066a0        	sub	a6, a6, a10
4200cf1b:	fd9956        	bnez	a9, 4200cef8 <__sfvwrite_r+0x4c>
4200cf1e:	ffe546        	j	4200ceb7 <__sfvwrite_r+0xb>
4200cf21:	146907        	bbci	a9, 0, 4200cf39 <__sfvwrite_r+0x8d>
4200cf24:	030c      	movi.n	a3, 0
4200cf26:	0a0c      	movi.n	a10, 0
4200cf28:	060c      	movi.n	a6, 0
4200cf2a:	050c      	movi.n	a5, 0
4200cf2c:	005a06        	j	4200d098 <__sfvwrite_r+0x1ec>
4200cf2f:	075800        	ee.stf.64.xp	f5, f0, a0, a8
4200cf32:	1738      	l32i.n	a3, a7, 4
4200cf34:	778b      	addi.n	a7, a7, 8
4200cf36:	0000c6        	j	4200cf3d <__sfvwrite_r+0x91>
4200cf39:	050c      	movi.n	a5, 0
4200cf3b:	030c      	movi.n	a3, 0
4200cf3d:	fef316        	beqz	a3, 4200cf30 <__sfvwrite_r+0x84>
4200cf40:	0692f2        	l16si	a15, a2, 12
4200cf43:	02a8      	l32i.n	a10, a2, 0
4200cf45:	22e8      	l32i.n	a14, a2, 8
4200cf47:	02ef97        	bbsi	a15, 9, 4200cf4d <__sfvwrite_r+0xa1>
4200cf4a:	003606        	j	4200d026 <__sfvwrite_r+0x17a>
4200cf4d:	0ecd      	mov.n	a12, a14
4200cf4f:	05b3e7        	bgeu	a3, a14, 4200cf58 <__sfvwrite_r+0xac>
4200cf52:	03ed      	mov.n	a14, a3
4200cf54:	002886        	j	4200cffa <__sfvwrite_r+0x14e>
4200cf57:	a4b200        	extui	a11, a0, 2, 11
4200cf5a:	80          	.byte	0x80
4200cf5b:	028fb7        	bany	a15, a11, 4200cf61 <__sfvwrite_r+0xb5>
4200cf5e:	0027c6        	j	4200d001 <__sfvwrite_r+0x155>
4200cf61:	42b8      	l32i.n	a11, a2, 16
4200cf63:	c08ab0        	sub	a8, a10, a11
4200cf66:	52a8      	l32i.n	a10, a2, 20
4200cf68:	1189      	s32i.n	a8, a1, 4
4200cf6a:	90aaa0        	addx2	a10, a10, a10
4200cf6d:	05dfa0        	extui	a13, a10, 31, 1
4200cf70:	ddaa      	add.n	a13, a13, a10
4200cf72:	a81b      	addi.n	a10, a8, 1
4200cf74:	2161d0        	srai	a6, a13, 1
4200cf77:	aa3a      	add.n	a10, a10, a3
4200cf79:	20c660        	or	a12, a6, a6
4200cf7c:	04b6a7        	bgeu	a6, a10, 4200cf84 <__sfvwrite_r+0xd8>
4200cf7f:	0a6d      	mov.n	a6, a10
4200cf81:	20caa0        	or	a12, a10, a10
4200cf84:	366fa7        	bbci	a15, 10, 4200cfbe <__sfvwrite_r+0x112>
4200cf87:	01a8      	l32i.n	a10, a1, 0
4200cf89:	0cbd      	mov.n	a11, a12
4200cf8b:	cfb281        	l32r	a8, 42000e54 <_stext+0xe34> (4037fee8 <_malloc_r>)
4200cf8e:	0008e0        	callx8	a8
4200cf91:	1acc      	bnez.n	a10, 4200cf96 <__sfvwrite_r+0xea>
4200cf93:	001246        	j	4200cfe0 <__sfvwrite_r+0x134>
4200cf96:	42b8      	l32i.n	a11, a2, 16
4200cf98:	0121c2        	l32i	a12, a1, 4
4200cf9b:	0261a2        	s32i	a10, a1, 8
4200cf9e:	cc2281        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
4200cfa1:	0008e0        	callx8	a8
4200cfa4:	0612a2        	l16ui	a10, a2, 12
4200cfa7:	7fabb2        	movi	a11, 0xfffffb7f
4200cfaa:	10aab0        	and	a10, a10, a11
4200cfad:	80a0b2        	movi	a11, 128
4200cfb0:	20aab0        	or	a10, a10, a11
4200cfb3:	21e8      	l32i.n	a14, a1, 8
4200cfb5:	0652a2        	s16i	a10, a2, 12
4200cfb8:	000b46        	j	4200cfe9 <__sfvwrite_r+0x13d>
4200cfbb:	000000        	ill
4200cfbe:	01a8      	l32i.n	a10, a1, 0
4200cfc0:	cfaa81        	l32r	a8, 42000e68 <_stext+0xe48> (4037fed4 <_realloc_r>)
4200cfc3:	0008e0        	callx8	a8
4200cfc6:	0aed      	mov.n	a14, a10
4200cfc8:	dadc      	bnez.n	a10, 4200cfe9 <__sfvwrite_r+0x13d>
4200cfca:	01a8      	l32i.n	a10, a1, 0
4200cfcc:	42b8      	l32i.n	a11, a2, 16
4200cfce:	cf9081        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200cfd1:	0008e0        	callx8	a8
4200cfd4:	061292        	l16ui	a9, a2, 12
4200cfd7:	7fafa2        	movi	a10, -129
4200cfda:	1099a0        	and	a9, a9, a10
4200cfdd:	065292        	s16i	a9, a2, 12
4200cfe0:	0188      	l32i.n	a8, a1, 0
4200cfe2:	c90c      	movi.n	a9, 12
4200cfe4:	0899      	s32i.n	a9, a8, 0
4200cfe6:	005786        	j	4200d148 <__sfvwrite_r+0x29c>
4200cfe9:	1188      	l32i.n	a8, a1, 4
4200cfeb:	42e9      	s32i.n	a14, a2, 16
4200cfed:	c0d680        	sub	a13, a6, a8
4200cff0:	ee8a      	add.n	a14, a14, a8
4200cff2:	02e9      	s32i.n	a14, a2, 0
4200cff4:	5269      	s32i.n	a6, a2, 20
4200cff6:	03ed      	mov.n	a14, a3
4200cff8:	22d9      	s32i.n	a13, a2, 8
4200cffa:	036d      	mov.n	a6, a3
4200cffc:	03cd      	mov.n	a12, a3
4200cffe:	000046        	j	4200d003 <__sfvwrite_r+0x157>
4200d001:	036d      	mov.n	a6, a3
4200d003:	02a8      	l32i.n	a10, a2, 0
4200d005:	05bd      	mov.n	a11, a5
4200d007:	21e9      	s32i.n	a14, a1, 8
4200d009:	11c9      	s32i.n	a12, a1, 4
4200d00b:	cf9881        	l32r	a8, 42000e6c <_stext+0xe4c> (40001200 <memmove>)
4200d00e:	0008e0        	callx8	a8
4200d011:	22a8      	l32i.n	a10, a2, 8
4200d013:	21e8      	l32i.n	a14, a1, 8
4200d015:	11c8      	l32i.n	a12, a1, 4
4200d017:	c0aae0        	sub	a10, a10, a14
4200d01a:	22a9      	s32i.n	a10, a2, 8
4200d01c:	02a8      	l32i.n	a10, a2, 0
4200d01e:	aaca      	add.n	a10, a10, a12
4200d020:	02a9      	s32i.n	a10, a2, 0
4200d022:	0015c6        	j	4200d07d <__sfvwrite_r+0x1d1>
4200d025:	42b800        	xorb	b11, b8, b0
4200d028:	043ba7        	bltu	a11, a10, 4200d030 <__sfvwrite_r+0x184>
4200d02b:	52b8      	l32i.n	a11, a2, 20
4200d02d:	2bb3b7        	bgeu	a3, a11, 4200d05c <__sfvwrite_r+0x1b0>
4200d030:	636e30        	minu	a6, a14, a3
4200d033:	05bd      	mov.n	a11, a5
4200d035:	06cd      	mov.n	a12, a6
4200d037:	cf8d81        	l32r	a8, 42000e6c <_stext+0xe4c> (40001200 <memmove>)
4200d03a:	0008e0        	callx8	a8
4200d03d:	22a8      	l32i.n	a10, a2, 8
4200d03f:	02b8      	l32i.n	a11, a2, 0
4200d041:	c0aa60        	sub	a10, a10, a6
4200d044:	bb6a      	add.n	a11, a11, a6
4200d046:	22a9      	s32i.n	a10, a2, 8
4200d048:	02b9      	s32i.n	a11, a2, 0
4200d04a:	faec      	bnez.n	a10, 4200d07d <__sfvwrite_r+0x1d1>
4200d04c:	01a8      	l32i.n	a10, a1, 0
4200d04e:	02bd      	mov.n	a11, a2
4200d050:	201110        	or	a1, a1, a1
4200d053:	ffba25        	call8	4200cbf4 <_fflush_r>
4200d056:	3aac      	beqz.n	a10, 4200d07d <__sfvwrite_r+0x1d1>
4200d058:	003b06        	j	4200d148 <__sfvwrite_r+0x29c>
4200d05b:	00          	.byte	00
4200d05c:	f87c      	movi.n	a8, -1
4200d05e:	418180        	srli	a8, a8, 1
4200d061:	63d380        	minu	a13, a3, a8
4200d064:	f2bdb0        	rems	a11, a13, a11
4200d067:	c0ddb0        	sub	a13, a13, a11
4200d06a:	a2e8      	l32i.n	a14, a2, 40
4200d06c:	82b8      	l32i.n	a11, a2, 32
4200d06e:	01a8      	l32i.n	a10, a1, 0
4200d070:	05cd      	mov.n	a12, a5
4200d072:	000ee0        	callx8	a14
4200d075:	0a6d      	mov.n	a6, a10
4200d077:	021ae6        	bgei	a10, 1, 4200d07d <__sfvwrite_r+0x1d1>
4200d07a:	003286        	j	4200d148 <__sfvwrite_r+0x29c>
4200d07d:	24a8      	l32i.n	a10, a4, 8
4200d07f:	556a      	add.n	a5, a5, a6
4200d081:	c0aa60        	sub	a10, a10, a6
4200d084:	24a9      	s32i.n	a10, a4, 8
4200d086:	c03360        	sub	a3, a3, a6
4200d089:	eb0a56        	bnez	a10, 4200cf3d <__sfvwrite_r+0x91>
4200d08c:	ff89c6        	j	4200ceb7 <__sfvwrite_r+0xb>
4200d08f:	076800        	ee.stf.64.xp	f6, f0, a0, a8
4200d092:	1758      	l32i.n	a5, a7, 4
4200d094:	0a0c      	movi.n	a10, 0
4200d096:	778b      	addi.n	a7, a7, 8
4200d098:	ff4516        	beqz	a5, 4200d090 <__sfvwrite_r+0x1e4>
4200d09b:	3adc      	bnez.n	a10, 4200d0b2 <__sfvwrite_r+0x206>
4200d09d:	05cd      	mov.n	a12, a5
4200d09f:	ab0c      	movi.n	a11, 10
4200d0a1:	06ad      	mov.n	a10, a6
4200d0a3:	cf7381        	l32r	a8, 42000e70 <_stext+0xe50> (40001344 <memchr>)
4200d0a6:	0008e0        	callx8	a8
4200d0a9:	351b      	addi.n	a3, a5, 1
4200d0ab:	3a8c      	beqz.n	a10, 4200d0b2 <__sfvwrite_r+0x206>
4200d0ad:	aa1b      	addi.n	a10, a10, 1
4200d0af:	c03a60        	sub	a3, a10, a6
4200d0b2:	52d8      	l32i.n	a13, a2, 20
4200d0b4:	22c8      	l32i.n	a12, a2, 8
4200d0b6:	02a8      	l32i.n	a10, a2, 0
4200d0b8:	42b8      	l32i.n	a11, a2, 16
4200d0ba:	639350        	minu	a9, a3, a5
4200d0bd:	cdca      	add.n	a12, a13, a12
4200d0bf:	26bba7        	bgeu	a11, a10, 4200d0e9 <__sfvwrite_r+0x23d>
4200d0c2:	23ac97        	bge	a12, a9, 4200d0e9 <__sfvwrite_r+0x23d>
4200d0c5:	20b660        	or	a11, a6, a6
4200d0c8:	11c9      	s32i.n	a12, a1, 4
4200d0ca:	cf6881        	l32r	a8, 42000e6c <_stext+0xe4c> (40001200 <memmove>)
4200d0cd:	0008e0        	callx8	a8
4200d0d0:	0298      	l32i.n	a9, a2, 0
4200d0d2:	11c8      	l32i.n	a12, a1, 4
4200d0d4:	01a8      	l32i.n	a10, a1, 0
4200d0d6:	99ca      	add.n	a9, a9, a12
4200d0d8:	0299      	s32i.n	a9, a2, 0
4200d0da:	02bd      	mov.n	a11, a2
4200d0dc:	201110        	or	a1, a1, a1
4200d0df:	ffb165        	call8	4200cbf4 <_fflush_r>
4200d0e2:	11c8      	l32i.n	a12, a1, 4
4200d0e4:	5abc      	beqz.n	a10, 4200d11d <__sfvwrite_r+0x271>
4200d0e6:	001786        	j	4200d148 <__sfvwrite_r+0x29c>
4200d0e9:	1329d7        	blt	a9, a13, 4200d100 <__sfvwrite_r+0x254>
4200d0ec:	a298      	l32i.n	a9, a2, 40
4200d0ee:	82b8      	l32i.n	a11, a2, 32
4200d0f0:	01a8      	l32i.n	a10, a1, 0
4200d0f2:	20c660        	or	a12, a6, a6
4200d0f5:	0009e0        	callx8	a9
4200d0f8:	0acd      	mov.n	a12, a10
4200d0fa:	1f1ae6        	bgei	a10, 1, 4200d11d <__sfvwrite_r+0x271>
4200d0fd:	0011c6        	j	4200d148 <__sfvwrite_r+0x29c>
4200d100:	09cd      	mov.n	a12, a9
4200d102:	06bd      	mov.n	a11, a6
4200d104:	1199      	s32i.n	a9, a1, 4
4200d106:	cf5981        	l32r	a8, 42000e6c <_stext+0xe4c> (40001200 <memmove>)
4200d109:	0008e0        	callx8	a8
4200d10c:	1198      	l32i.n	a9, a1, 4
4200d10e:	22a8      	l32i.n	a10, a2, 8
4200d110:	09cd      	mov.n	a12, a9
4200d112:	c0aa90        	sub	a10, a10, a9
4200d115:	22a9      	s32i.n	a10, a2, 8
4200d117:	02a8      	l32i.n	a10, a2, 0
4200d119:	aa9a      	add.n	a10, a10, a9
4200d11b:	02a9      	s32i.n	a10, a2, 0
4200d11d:	c033c0        	sub	a3, a3, a12
4200d120:	1a0c      	movi.n	a10, 1
4200d122:	e3cc      	bnez.n	a3, 4200d134 <__sfvwrite_r+0x288>
4200d124:	01a8      	l32i.n	a10, a1, 0
4200d126:	02bd      	mov.n	a11, a2
4200d128:	11c9      	s32i.n	a12, a1, 4
4200d12a:	201110        	or	a1, a1, a1
4200d12d:	ffac65        	call8	4200cbf4 <_fflush_r>
4200d130:	11c8      	l32i.n	a12, a1, 4
4200d132:	2adc      	bnez.n	a10, 4200d148 <__sfvwrite_r+0x29c>
4200d134:	2498      	l32i.n	a9, a4, 8
4200d136:	66ca      	add.n	a6, a6, a12
4200d138:	c099c0        	sub	a9, a9, a12
4200d13b:	2499      	s32i.n	a9, a4, 8
4200d13d:	c055c0        	sub	a5, a5, a12
4200d140:	f54956        	bnez	a9, 4200d098 <__sfvwrite_r+0x1ec>
4200d143:	ff5c06        	j	4200ceb7 <__sfvwrite_r+0xb>
4200d146:	00          	.byte	00
4200d147:	129200        	andbc	b9, b2, b0
4200d14a:	0a4c06        	j	4200fa7e <_vfprintf_r+0x213a>
4200d14d:	2099a0        	or	a9, a9, a10
4200d150:	065292        	s16i	a9, a2, 12
4200d153:	f27c      	movi.n	a2, -1
4200d155:	f01d      	retw.n
	...

4200d158 <_printf_r>:
4200d158:	00a136        	entry	a1, 80
4200d15b:	6149      	s32i.n	a4, a1, 24
4200d15d:	7159      	s32i.n	a5, a1, 28
4200d15f:	8169      	s32i.n	a6, a1, 32
4200d161:	9179      	s32i.n	a7, a1, 36
4200d163:	22b8      	l32i.n	a11, a2, 8
4200d165:	10c1e2        	addi	a14, a1, 16
4200d168:	30c1d2        	addi	a13, a1, 48
4200d16b:	880c      	movi.n	a8, 8
4200d16d:	02ad      	mov.n	a10, a2
4200d16f:	03cd      	mov.n	a12, a3
4200d171:	8f0c      	movi.n	a15, 8
4200d173:	11e9      	s32i.n	a14, a1, 4
4200d175:	01d9      	s32i.n	a13, a1, 0
4200d177:	026182        	s32i	a8, a1, 8
4200d17a:	201110        	or	a1, a1, a1
4200d17d:	007c65        	call8	4200d944 <_vfprintf_r>
4200d180:	0a2d      	mov.n	a2, a10
4200d182:	f01d      	retw.n

4200d184 <printf>:
4200d184:	00a136        	entry	a1, 80
4200d187:	5139      	s32i.n	a3, a1, 20
4200d189:	6149      	s32i.n	a4, a1, 24
4200d18b:	7159      	s32i.n	a5, a1, 28
4200d18d:	086162        	s32i	a6, a1, 32
4200d190:	9179      	s32i.n	a7, a1, 36
4200d192:	cf2181        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200d195:	0008e0        	callx8	a8
4200d198:	2ab8      	l32i.n	a11, a10, 8
4200d19a:	10c1e2        	addi	a14, a1, 16
4200d19d:	30c1d2        	addi	a13, a1, 48
4200d1a0:	480c      	movi.n	a8, 4
4200d1a2:	02cd      	mov.n	a12, a2
4200d1a4:	4f0c      	movi.n	a15, 4
4200d1a6:	11e9      	s32i.n	a14, a1, 4
4200d1a8:	01d9      	s32i.n	a13, a1, 0
4200d1aa:	2189      	s32i.n	a8, a1, 8
4200d1ac:	201110        	or	a1, a1, a1
4200d1af:	007965        	call8	4200d944 <_vfprintf_r>
4200d1b2:	0a2d      	mov.n	a2, a10
4200d1b4:	f01d      	retw.n
	...

4200d1b8 <__sread>:
4200d1b8:	004136        	entry	a1, 32
4200d1bb:	0793b2        	l16si	a11, a3, 14
4200d1be:	02ad      	mov.n	a10, a2
4200d1c0:	04cd      	mov.n	a12, a4
4200d1c2:	05dd      	mov.n	a13, a5
4200d1c4:	201110        	or	a1, a1, a1
4200d1c7:	f8fb65        	call8	4200617c <_read_r_console>
4200d1ca:	0a2d      	mov.n	a2, a10
4200d1cc:	00ca96        	bltz	a10, 4200d1dc <__sread+0x24>
4200d1cf:	152382        	l32i	a8, a3, 84
4200d1d2:	88aa      	add.n	a8, a8, a10
4200d1d4:	156382        	s32i	a8, a3, 84
4200d1d7:	0003c6        	j	4200d1ea <__sread+0x32>
4200d1da:	820000        	mull	a0, a0, a0
4200d1dd:	7c0613        	lsi	f1, a6, 0x1f0
4200d1e0:	92f9      	s32i.n	a15, a2, 36
4200d1e2:	f0d9      	s32i.n	a13, a0, 60
4200d1e4:	108890        	and	a8, a8, a9
4200d1e7:	065382        	s16i	a8, a3, 12
4200d1ea:	f01d      	retw.n

4200d1ec <__seofread>:
4200d1ec:	004136        	entry	a1, 32
4200d1ef:	020c      	movi.n	a2, 0
4200d1f1:	f01d      	retw.n
	...

4200d1f4 <__swrite>:
4200d1f4:	004136        	entry	a1, 32
4200d1f7:	061382        	l16ui	a8, a3, 12
4200d1fa:	0e6887        	bbci	a8, 8, 4200d20c <__swrite+0x18>
4200d1fd:	0793b2        	l16si	a11, a3, 14
4200d200:	2d0c      	movi.n	a13, 2
4200d202:	0c0c      	movi.n	a12, 0
4200d204:	02ad      	mov.n	a10, a2
4200d206:	201110        	or	a1, a1, a1
4200d209:	094125        	call8	4201661c <_getpid_r>
4200d20c:	061382        	l16ui	a8, a3, 12
4200d20f:	f97c      	movi.n	a9, -1
4200d211:	f0d992        	addmi	a9, a9, 0xfffff000
4200d214:	108890        	and	a8, a8, a9
4200d217:	0793b2        	l16si	a11, a3, 14
4200d21a:	065382        	s16i	a8, a3, 12
4200d21d:	05dd      	mov.n	a13, a5
4200d21f:	04cd      	mov.n	a12, a4
4200d221:	02ad      	mov.n	a10, a2
4200d223:	201110        	or	a1, a1, a1
4200d226:	f8f1e5        	call8	42006144 <_write_r_console>
4200d229:	0a2d      	mov.n	a2, a10
4200d22b:	f01d      	retw.n
4200d22d:	000000        	ill

4200d230 <__sseek>:
4200d230:	004136        	entry	a1, 32
4200d233:	0793b2        	l16si	a11, a3, 14
4200d236:	02ad      	mov.n	a10, a2
4200d238:	20c440        	or	a12, a4, a4
4200d23b:	20d550        	or	a13, a5, a5
4200d23e:	201110        	or	a1, a1, a1
4200d241:	093da5        	call8	4201661c <_getpid_r>
4200d244:	069382        	l16si	a8, a3, 12
4200d247:	0a2d      	mov.n	a2, a10
4200d249:	0d0a66        	bnei	a10, -1, 4200d25a <__sseek+0x2a>
4200d24c:	f97c      	movi.n	a9, -1
4200d24e:	f0d992        	addmi	a9, a9, 0xfffff000
4200d251:	108890        	and	a8, a8, a9
4200d254:	065382        	s16i	a8, a3, 12
4200d257:	000346        	j	4200d268 <__sseek+0x38>
4200d25a:	190c      	movi.n	a9, 1
4200d25c:	119940        	slli	a9, a9, 12
4200d25f:	208890        	or	a8, a8, a9
4200d262:	065382        	s16i	a8, a3, 12
4200d265:	1563a2        	s32i	a10, a3, 84
4200d268:	f01d      	retw.n
	...

4200d26c <__sclose>:
4200d26c:	004136        	entry	a1, 32
4200d26f:	0793b2        	l16si	a11, a3, 14
4200d272:	02ad      	mov.n	a10, a2
4200d274:	201110        	or	a1, a1, a1
4200d277:	093a65        	call8	4201661c <_getpid_r>
4200d27a:	0a2d      	mov.n	a2, a10
4200d27c:	f01d      	retw.n
	...

4200d280 <vprintf>:
4200d280:	006136        	entry	a1, 48
4200d283:	0139      	s32i.n	a3, a1, 0
4200d285:	1149      	s32i.n	a4, a1, 4
4200d287:	026152        	s32i	a5, a1, 8
4200d28a:	cee381        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200d28d:	0008e0        	callx8	a8
4200d290:	01d8      	l32i.n	a13, a1, 0
4200d292:	11e8      	l32i.n	a14, a1, 4
4200d294:	21f8      	l32i.n	a15, a1, 8
4200d296:	2ab8      	l32i.n	a11, a10, 8
4200d298:	02cd      	mov.n	a12, a2
4200d29a:	201110        	or	a1, a1, a1
4200d29d:	006a65        	call8	4200d944 <_vfprintf_r>
4200d2a0:	0a2d      	mov.n	a2, a10
4200d2a2:	f01d      	retw.n

4200d2a4 <_vprintf_r>:
4200d2a4:	006136        	entry	a1, 48
4200d2a7:	22b8      	l32i.n	a11, a2, 8
4200d2a9:	02ad      	mov.n	a10, a2
4200d2ab:	03cd      	mov.n	a12, a3
4200d2ad:	04dd      	mov.n	a13, a4
4200d2af:	05ed      	mov.n	a14, a5
4200d2b1:	06fd      	mov.n	a15, a6
4200d2b3:	201110        	or	a1, a1, a1
4200d2b6:	0068e5        	call8	4200d944 <_vfprintf_r>
4200d2b9:	0a2d      	mov.n	a2, a10
4200d2bb:	f01d      	retw.n
4200d2bd:	000000        	ill

4200d2c0 <__swsetup_r>:
4200d2c0:	004136        	entry	a1, 32
4200d2c3:	ced581        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200d2c6:	0008e0        	callx8	a8
4200d2c9:	8a8c      	beqz.n	a10, 4200d2d5 <__swsetup_r+0x15>
4200d2cb:	aa88      	l32i.n	a8, a10, 40
4200d2cd:	48cc      	bnez.n	a8, 4200d2d5 <__swsetup_r+0x15>
4200d2cf:	201110        	or	a1, a1, a1
4200d2d2:	ffb8a5        	call8	4200ce5c <__sinit>
4200d2d5:	069382        	l16si	a8, a3, 12
4200d2d8:	3ee837        	bbsi	a8, 3, 4200d31a <__swsetup_r+0x5a>
4200d2db:	06e847        	bbsi	a8, 4, 4200d2e5 <__swsetup_r+0x25>
4200d2de:	990c      	movi.n	a9, 9
4200d2e0:	0299      	s32i.n	a9, a2, 0
4200d2e2:	001c86        	j	4200d358 <__swsetup_r+0x98>
4200d2e5:	296827        	bbci	a8, 2, 4200d312 <__swsetup_r+0x52>
4200d2e8:	d3b8      	l32i.n	a11, a3, 52
4200d2ea:	0b9c      	beqz.n	a11, 4200d2fe <__swsetup_r+0x3e>
4200d2ec:	44c382        	addi	a8, a3, 68
4200d2ef:	071b87        	beq	a11, a8, 4200d2fa <__swsetup_r+0x3a>
4200d2f2:	02ad      	mov.n	a10, a2
4200d2f4:	cec781        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d2f7:	0008e0        	callx8	a8
4200d2fa:	080c      	movi.n	a8, 0
4200d2fc:	d389      	s32i.n	a8, a3, 52
4200d2fe:	061382        	l16ui	a8, a3, 12
4200d301:	dbaf92        	movi	a9, -37
4200d304:	108890        	and	a8, a8, a9
4200d307:	090c      	movi.n	a9, 0
4200d309:	1399      	s32i.n	a9, a3, 4
4200d30b:	4398      	l32i.n	a9, a3, 16
4200d30d:	238880        	sext	a8, a8, 15
4200d310:	0399      	s32i.n	a9, a3, 0
4200d312:	890c      	movi.n	a9, 8
4200d314:	208890        	or	a8, a8, a9
4200d317:	065382        	s16i	a8, a3, 12
4200d31a:	4398      	l32i.n	a9, a3, 16
4200d31c:	49dc      	bnez.n	a9, 4200d334 <__swsetup_r+0x74>
4200d31e:	80a292        	movi	a9, 0x280
4200d321:	108890        	and	a8, a8, a9
4200d324:	00a292        	movi	a9, 0x200
4200d327:	091897        	beq	a8, a9, 4200d334 <__swsetup_r+0x74>
4200d32a:	03bd      	mov.n	a11, a3
4200d32c:	02ad      	mov.n	a10, a2
4200d32e:	201110        	or	a1, a1, a1
4200d331:	055765        	call8	420128a8 <__smakebuf_r>
4200d334:	069382        	l16si	a8, a3, 12
4200d337:	090c      	movi.n	a9, 0
4200d339:	0b6807        	bbci	a8, 0, 4200d348 <__swsetup_r+0x88>
4200d33c:	2399      	s32i.n	a9, a3, 8
4200d33e:	5398      	l32i.n	a9, a3, 20
4200d340:	609090        	neg	a9, a9
4200d343:	6399      	s32i.n	a9, a3, 24
4200d345:	000186        	j	4200d34f <__swsetup_r+0x8f>
4200d348:	01e817        	bbsi	a8, 1, 4200d34d <__swsetup_r+0x8d>
4200d34b:	5398      	l32i.n	a9, a3, 20
4200d34d:	2399      	s32i.n	a9, a3, 8
4200d34f:	4398      	l32i.n	a9, a3, 16
4200d351:	020c      	movi.n	a2, 0
4200d353:	b9cc      	bnez.n	a9, 4200d362 <__swsetup_r+0xa2>
4200d355:	096877        	bbci	a8, 7, 4200d362 <__swsetup_r+0xa2>
4200d358:	094c      	movi.n	a9, 64
4200d35a:	208890        	or	a8, a8, a9
4200d35d:	065382        	s16i	a8, a3, 12
4200d360:	f27c      	movi.n	a2, -1
4200d362:	f01d      	retw.n

4200d364 <time>:
4200d364:	006136        	entry	a1, 48
4200d367:	027d      	mov.n	a7, a2
4200d369:	f37c      	movi.n	a3, -1
4200d36b:	ffaf22        	movi	a2, -1
4200d36e:	006122        	s32i	a2, a1, 0
4200d371:	016132        	s32i	a3, a1, 4
4200d374:	cea981        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200d377:	0008e0        	callx8	a8
4200d37a:	0c0c      	movi.n	a12, 0
4200d37c:	20b110        	or	a11, a1, a1
4200d37f:	201110        	or	a1, a1, a1
4200d382:	f8cf65        	call8	42006078 <_gettimeofday_r>
4200d385:	003ad6        	bgez	a10, 4200d38c <time+0x28>
4200d388:	0129      	s32i.n	a2, a1, 0
4200d38a:	1139      	s32i.n	a3, a1, 4
4200d38c:	0128      	l32i.n	a2, a1, 0
4200d38e:	1138      	l32i.n	a3, a1, 4
4200d390:	278c      	beqz.n	a7, 4200d396 <time+0x32>
4200d392:	0729      	s32i.n	a2, a7, 0
4200d394:	1739      	s32i.n	a3, a7, 4
4200d396:	f01d      	retw.n

4200d398 <_reclaim_reent>:
4200d398:	004136        	entry	a1, 32
4200d39b:	ceb681        	l32r	a8, 42000e74 <_stext+0xe54> (3fc92ab0 <_impure_ptr>)
4200d39e:	0888      	l32i.n	a8, a8, 0
4200d3a0:	029827        	bne	a8, a2, 4200d3a6 <_reclaim_reent+0xe>
4200d3a3:	002cc6        	j	4200d45a <_reclaim_reent+0xc2>
4200d3a6:	9288      	l32i.n	a8, a2, 36
4200d3a8:	e8bc      	beqz.n	a8, 4200d3ea <_reclaim_reent+0x52>
4200d3aa:	3888      	l32i.n	a8, a8, 12
4200d3ac:	c8ac      	beqz.n	a8, 4200d3dc <_reclaim_reent+0x44>
4200d3ae:	070c      	movi.n	a7, 0
4200d3b0:	9288      	l32i.n	a8, a2, 36
4200d3b2:	3888      	l32i.n	a8, a8, 12
4200d3b4:	887a      	add.n	a8, a8, a7
4200d3b6:	08b8      	l32i.n	a11, a8, 0
4200d3b8:	000306        	j	4200d3c8 <_reclaim_reent+0x30>
4200d3bb:	00          	.byte	00
4200d3bc:	0b68      	l32i.n	a6, a11, 0
4200d3be:	02ad      	mov.n	a10, a2
4200d3c0:	ce9481        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d3c3:	0008e0        	callx8	a8
4200d3c6:	06bd      	mov.n	a11, a6
4200d3c8:	ff0b56        	bnez	a11, 4200d3bc <_reclaim_reent+0x24>
4200d3cb:	774b      	addi.n	a7, a7, 4
4200d3cd:	dfe766        	bnei	a7, 128, 4200d3b0 <_reclaim_reent+0x18>
4200d3d0:	9288      	l32i.n	a8, a2, 36
4200d3d2:	02ad      	mov.n	a10, a2
4200d3d4:	38b8      	l32i.n	a11, a8, 12
4200d3d6:	ce8e81        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d3d9:	0008e0        	callx8	a8
4200d3dc:	9288      	l32i.n	a8, a2, 36
4200d3de:	08b8      	l32i.n	a11, a8, 0
4200d3e0:	6b8c      	beqz.n	a11, 4200d3ea <_reclaim_reent+0x52>
4200d3e2:	02ad      	mov.n	a10, a2
4200d3e4:	ce8b81        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d3e7:	0008e0        	callx8	a8
4200d3ea:	52b8      	l32i.n	a11, a2, 20
4200d3ec:	6b8c      	beqz.n	a11, 4200d3f6 <_reclaim_reent+0x5e>
4200d3ee:	02ad      	mov.n	a10, a2
4200d3f0:	ce8881        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d3f3:	0008e0        	callx8	a8
4200d3f6:	92b8      	l32i.n	a11, a2, 36
4200d3f8:	6b8c      	beqz.n	a11, 4200d402 <_reclaim_reent+0x6a>
4200d3fa:	02ad      	mov.n	a10, a2
4200d3fc:	ce8581        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d3ff:	0008e0        	callx8	a8
4200d402:	e2b8      	l32i.n	a11, a2, 56
4200d404:	6b8c      	beqz.n	a11, 4200d40e <_reclaim_reent+0x76>
4200d406:	02ad      	mov.n	a10, a2
4200d408:	ce8281        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d40b:	0008e0        	callx8	a8
4200d40e:	f2b8      	l32i.n	a11, a2, 60
4200d410:	008b16        	beqz	a11, 4200d41c <_reclaim_reent+0x84>
4200d413:	20a220        	or	a10, a2, a2
4200d416:	ce7e81        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d419:	0008e0        	callx8	a8
4200d41c:	1022b2        	l32i	a11, a2, 64
4200d41f:	6b8c      	beqz.n	a11, 4200d429 <_reclaim_reent+0x91>
4200d421:	02ad      	mov.n	a10, a2
4200d423:	ce7b81        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d426:	0008e0        	callx8	a8
4200d429:	3b22b2        	l32i	a11, a2, 236
4200d42c:	008b16        	beqz	a11, 4200d438 <_reclaim_reent+0xa0>
4200d42f:	20a220        	or	a10, a2, a2
4200d432:	ce7781        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d435:	0008e0        	callx8	a8
4200d438:	3a22b2        	l32i	a11, a2, 232
4200d43b:	6b8c      	beqz.n	a11, 4200d445 <_reclaim_reent+0xad>
4200d43d:	02ad      	mov.n	a10, a2
4200d43f:	ce7481        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d442:	0008e0        	callx8	a8
4200d445:	d2b8      	l32i.n	a11, a2, 52
4200d447:	6b8c      	beqz.n	a11, 4200d451 <_reclaim_reent+0xb9>
4200d449:	02ad      	mov.n	a10, a2
4200d44b:	ce7181        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
4200d44e:	0008e0        	callx8	a8
4200d451:	a288      	l32i.n	a8, a2, 40
4200d453:	388c      	beqz.n	a8, 4200d45a <_reclaim_reent+0xc2>
4200d455:	02ad      	mov.n	a10, a2
4200d457:	0008e0        	callx8	a8
4200d45a:	f01d      	retw.n

4200d45c <gettimeofday>:
4200d45c:	004136        	entry	a1, 32
4200d45f:	ce6e81        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
4200d462:	0008e0        	callx8	a8
4200d465:	02bd      	mov.n	a11, a2
4200d467:	20c330        	or	a12, a3, a3
4200d46a:	201110        	or	a1, a1, a1
4200d46d:	f8c0a5        	call8	42006078 <_gettimeofday_r>
4200d470:	0a2d      	mov.n	a2, a10
4200d472:	f01d      	retw.n

4200d474 <get_arg$isra$0>:
4200d474:	008136        	entry	a1, 64
4200d477:	102182        	l32i	a8, a1, 64
4200d47a:	1179      	s32i.n	a7, a1, 4
4200d47c:	0878      	l32i.n	a7, a8, 0
4200d47e:	2129      	s32i.n	a2, a1, 8
4200d480:	21e8      	l32i.n	a14, a1, 8
4200d482:	0528      	l32i.n	a2, a5, 0
4200d484:	4159      	s32i.n	a5, a1, 16
4200d486:	0169      	s32i.n	a6, a1, 0
4200d488:	837370        	moveqz	a7, a3, a7
4200d48b:	00e306        	j	4200d81b <get_arg$isra$0+0x3a7>
4200d48e:	771b      	addi.n	a7, a7, 1
4200d490:	000782        	l8ui	a8, a7, 0
4200d493:	42f816        	beqz	a8, 4200d8c6 <get_arg$isra$0+0x452>
4200d496:	dbc8a2        	addi	a10, a8, -37
4200d499:	ff1a56        	bnez	a10, 4200d48e <get_arg$isra$0+0x1a>
4200d49c:	426816        	beqz	a8, 4200d8c6 <get_arg$isra$0+0x452>
4200d49f:	080c      	movi.n	a8, 0
4200d4a1:	a71b      	addi.n	a10, a7, 1
4200d4a3:	050c      	movi.n	a5, 0
4200d4a5:	0d0c      	movi.n	a13, 0
4200d4a7:	f37c      	movi.n	a3, -1
4200d4a9:	060c      	movi.n	a6, 0
4200d4ab:	3189      	s32i.n	a8, a1, 12
4200d4ad:	000046        	j	4200d4b2 <get_arg$isra$0+0x3e>
4200d4b0:	07ad      	mov.n	a10, a7
4200d4b2:	ce7191        	l32r	a9, 42000e78 <_stext+0xe58> (3c028e7c <__chclass>)
4200d4b5:	000a82        	l8ui	a8, a10, 0
4200d4b8:	7a1b      	addi.n	a7, a10, 1
4200d4ba:	b98a      	add.n	a11, a9, a8
4200d4bc:	3198      	l32i.n	a9, a1, 12
4200d4be:	000bc2        	l8ui	a12, a11, 0
4200d4c1:	ce6eb1        	l32r	a11, 42000e7c <_stext+0xe5c> (3c028e10 <__state_table>)
4200d4c4:	b0f990        	addx8	a15, a9, a9
4200d4c7:	bbfa      	add.n	a11, a11, a15
4200d4c9:	bbca      	add.n	a11, a11, a12
4200d4cb:	000b92        	l8ui	a9, a11, 0
4200d4ce:	ce6cb1        	l32r	a11, 42000e80 <_stext+0xe60> (3c028da4 <__action_table>)
4200d4d1:	3199      	s32i.n	a9, a1, 12
4200d4d3:	bbfa      	add.n	a11, a11, a15
4200d4d5:	bbca      	add.n	a11, a11, a12
4200d4d7:	000bb2        	l8ui	a11, a11, 0
4200d4da:	bb0b      	addi.n	a11, a11, -1
4200d4dc:	74b0b0        	extui	a11, a11, 0, 8
4200d4df:	028bb6        	bltui	a11, 8, 4200d4e5 <get_arg$isra$0+0x71>
4200d4e2:	00cac6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d4e5:	ce67c1        	l32r	a12, 42000e84 <_stext+0xe64> (3c0284a8 <Xthal_intlevel+0x20>)
4200d4e8:	a0bbc0        	addx4	a11, a11, a12
4200d4eb:	0bb8      	l32i.n	a11, a11, 0
4200d4ed:	000ba0        	jx	a11
4200d4f0:	00          	.byte	00
4200d4f1:	9a0c00        	trunc.s	a0, f12, 0
4200d4f4:	00c206        	j	4200d800 <get_arg$isra$0+0x38c>
4200d4f7:	07ad      	mov.n	a10, a7
4200d4f9:	00ac46        	j	4200d7ae <get_arg$isra$0+0x33a>
4200d4fc:	6aa0b2        	movi	a11, 106
4200d4ff:	3318b7        	beq	a8, a11, 4200d536 <get_arg$isra$0+0xc2>
4200d502:	0a3b87        	bltu	a11, a8, 4200d510 <get_arg$isra$0+0x9c>
4200d505:	cb4c      	movi.n	a11, 76
4200d507:	2618b7        	beq	a8, a11, 4200d531 <get_arg$isra$0+0xbd>
4200d50a:	68a0b2        	movi	a11, 104
4200d50d:	0005c6        	j	4200d528 <get_arg$isra$0+0xb4>
4200d510:	71a0b2        	movi	a11, 113
4200d513:	1f18b7        	beq	a8, a11, 4200d536 <get_arg$isra$0+0xc2>
4200d516:	70a0b2        	movi	a11, 112
4200d519:	23bb87        	bgeu	a11, a8, 4200d540 <get_arg$isra$0+0xcc>
4200d51c:	74a0b2        	movi	a11, 116
4200d51f:	0298b7        	bne	a8, a11, 4200d525 <get_arg$isra$0+0xb1>
4200d522:	00bac6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d525:	7aa0b2        	movi	a11, 122
4200d528:	0298b7        	bne	a8, a11, 4200d52e <get_arg$isra$0+0xba>
4200d52b:	00b886        	j	4200d811 <get_arg$isra$0+0x39d>
4200d52e:	000386        	j	4200d540 <get_arg$isra$0+0xcc>
4200d531:	880c      	movi.n	a8, 8
4200d533:	000046        	j	4200d538 <get_arg$isra$0+0xc4>
4200d536:	082c      	movi.n	a8, 32
4200d538:	206680        	or	a6, a6, a8
4200d53b:	00b486        	j	4200d811 <get_arg$isra$0+0x39d>
4200d53e:	b20000        	mulsh	a0, a0, a0
4200d541:	010a      	add.n	a0, a1, a0
4200d543:	6ca082        	movi	a8, 108
4200d546:	0a9b87        	bne	a11, a8, 4200d554 <get_arg$isra$0+0xe0>
4200d549:	082c      	movi.n	a8, 32
4200d54b:	206680        	or	a6, a6, a8
4200d54e:	7a2b      	addi.n	a7, a10, 2
4200d550:	00af46        	j	4200d811 <get_arg$isra$0+0x39d>
4200d553:	081c00        	lsx	f1, a12, a0
4200d556:	fff786        	j	4200d538 <get_arg$isra$0+0xc4>
4200d559:	61a0b2        	movi	a11, 97
4200d55c:	44a020        	extui	a10, a2, 0, 5
4200d55f:	0298b7        	bne	a8, a11, 4200d565 <get_arg$isra$0+0xf1>
4200d562:	00e506        	j	4200d8fa <get_arg$isra$0+0x486>
4200d565:	3b3b87        	bltu	a11, a8, 4200d5a4 <get_arg$isra$0+0x130>
4200d568:	bfc882        	addi	a8, a8, -65
4200d56b:	748080        	extui	a8, a8, 0, 8
4200d56e:	7b1c      	movi.n	a11, 23
4200d570:	24bb87        	bgeu	a11, a8, 4200d598 <get_arg$isra$0+0x124>
4200d573:	001686        	j	4200d5d1 <get_arg$isra$0+0x15d>
4200d576:	180c      	movi.n	a8, 1
4200d578:	401b00        	ssl	a11
4200d57b:	a18800        	sll	a8, a8
4200d57e:	ce42b1        	l32r	a11, 42000e88 <_stext+0xe68> (120821 <UserFrameTotalSize+0x120721>)
4200d581:	3388b7        	bany	a8, a11, 4200d5b8 <get_arg$isra$0+0x144>
4200d584:	5b2c      	movi.n	a11, 37
4200d586:	11bb60        	slli	a11, a11, 10
4200d589:	0208b7        	bnone	a8, a11, 4200d58f <get_arg$isra$0+0x11b>
4200d58c:	00dd46        	j	4200d905 <get_arg$isra$0+0x491>
4200d58f:	248180        	extui	a8, a8, 1, 3
4200d592:	364856        	bnez	a8, 4200d8fa <get_arg$isra$0+0x486>
4200d595:	000e06        	j	4200d5d1 <get_arg$isra$0+0x15d>
4200d598:	ce3db1        	l32r	a11, 42000e8c <_stext+0xe6c> (3c0284c8 <Xthal_intlevel+0x40>)
4200d59b:	a088b0        	addx4	a8, a8, a11
4200d59e:	0888      	l32i.n	a8, a8, 0
4200d5a0:	0008a0        	jx	a8
4200d5a3:	a0b200        	addx4	a11, a2, a0
4200d5a6:	63          	.byte	0x63
4200d5a7:	1918b7        	beq	a8, a11, 4200d5c4 <get_arg$isra$0+0x150>
4200d5aa:	9cc882        	addi	a8, a8, -100
4200d5ad:	74b080        	extui	a11, a8, 0, 8
4200d5b0:	481c      	movi.n	a8, 20
4200d5b2:	c0b8b7        	bgeu	a8, a11, 4200d576 <get_arg$isra$0+0x102>
4200d5b5:	000606        	j	4200d5d1 <get_arg$isra$0+0x15d>
4200d5b8:	045560        	extui	a5, a6, 5, 1
4200d5bb:	555a      	add.n	a5, a5, a5
4200d5bd:	106647        	bbci	a6, 4, 4200d5d1 <get_arg$isra$0+0x15d>
4200d5c0:	00d806        	j	4200d924 <get_arg$isra$0+0x4b0>
4200d5c3:	051c00        	extui	a1, a0, 28, 1
4200d5c6:	105650        	and	a5, a6, a5
4200d5c9:	34c556        	bnez	a5, 4200d919 <get_arg$isra$0+0x4a5>
4200d5cc:	00d006        	j	4200d910 <get_arg$isra$0+0x49c>
4200d5cf:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
4200d5d2:	880b03        	lsi	f0, a11, 0x220
4200d5d5:	0a2d11        	l32r	a1, 41fcfe8c <_iram_bss_end+0x1c4da8c>
4200d5d8:	a08380        	addx4	a8, a3, a8
4200d5db:	0859      	s32i.n	a5, a8, 0
4200d5dd:	008c06        	j	4200d811 <get_arg$isra$0+0x39d>
4200d5e0:	b50b      	addi.n	a11, a5, -1
4200d5e2:	2488      	l32i.n	a8, a4, 8
4200d5e4:	2a1b      	addi.n	a2, a10, 1
4200d5e6:	026bb6        	bltui	a11, 6, 4200d5ec <get_arg$isra$0+0x178>
4200d5e9:	002806        	j	4200d68d <get_arg$isra$0+0x219>
4200d5ec:	ce29c1        	l32r	a12, 42000e90 <_stext+0xe70> (3c028528 <Xthal_intlevel+0xa0>)
4200d5ef:	a0bbc0        	addx4	a11, a11, a12
4200d5f2:	0bc8      	l32i.n	a12, a11, 0
4200d5f4:	f4b0a0        	extui	a11, a10, 0, 16
4200d5f7:	000ca0        	jx	a12
4200d5fa:	0188      	l32i.n	a8, a1, 0
4200d5fc:	24b8      	l32i.n	a11, a4, 8
4200d5fe:	2a1b      	addi.n	a2, a10, 1
4200d600:	b0aa80        	addx8	a10, a10, a8
4200d603:	8b4b      	addi.n	a8, a11, 4
4200d605:	2489      	s32i.n	a8, a4, 8
4200d607:	8c1c      	movi.n	a12, 24
4200d609:	042c87        	blt	a12, a8, 4200d611 <get_arg$isra$0+0x19d>
4200d60c:	14b8      	l32i.n	a11, a4, 4
4200d60e:	000206        	j	4200d61a <get_arg$isra$0+0x1a6>
4200d611:	012cb7        	blt	a12, a11, 4200d616 <get_arg$isra$0+0x1a2>
4200d614:	482c      	movi.n	a8, 36
4200d616:	04b8      	l32i.n	a11, a4, 0
4200d618:	2489      	s32i.n	a8, a4, 8
4200d61a:	bb8a      	add.n	a11, a11, a8
4200d61c:	fccbb2        	addi	a11, a11, -4
4200d61f:	0b88      	l32i.n	a8, a11, 0
4200d621:	f37c      	movi.n	a3, -1
4200d623:	0a89      	s32i.n	a8, a10, 0
4200d625:	150c      	movi.n	a5, 1
4200d627:	007986        	j	4200d811 <get_arg$isra$0+0x39d>
4200d62a:	8a7c      	movi.n	a10, -8
4200d62c:	887b      	addi.n	a8, a8, 7
4200d62e:	1088a0        	and	a8, a8, a10
4200d631:	0198      	l32i.n	a9, a1, 0
4200d633:	a88b      	addi.n	a10, a8, 8
4200d635:	24a9      	s32i.n	a10, a4, 8
4200d637:	8c1c      	movi.n	a12, 24
4200d639:	b0bb90        	addx8	a11, a11, a9
4200d63c:	042ca7        	blt	a12, a10, 4200d644 <get_arg$isra$0+0x1d0>
4200d63f:	1488      	l32i.n	a8, a4, 4
4200d641:	000206        	j	4200d64d <get_arg$isra$0+0x1d9>
4200d644:	012c87        	blt	a12, a8, 4200d649 <get_arg$isra$0+0x1d5>
4200d647:	8a2c      	movi.n	a10, 40
4200d649:	0488      	l32i.n	a8, a4, 0
4200d64b:	24a9      	s32i.n	a10, a4, 8
4200d64d:	88aa      	add.n	a8, a8, a10
4200d64f:	f8c882        	addi	a8, a8, -8
4200d652:	1898      	l32i.n	a9, a8, 4
4200d654:	0888      	l32i.n	a8, a8, 0
4200d656:	1b99      	s32i.n	a9, a11, 4
4200d658:	0b89      	s32i.n	a8, a11, 0
4200d65a:	006cc6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d65d:	0188      	l32i.n	a8, a1, 0
4200d65f:	24b8      	l32i.n	a11, a4, 8
4200d661:	2a1b      	addi.n	a2, a10, 1
4200d663:	b0aa80        	addx8	a10, a10, a8
4200d666:	8b4b      	addi.n	a8, a11, 4
4200d668:	2489      	s32i.n	a8, a4, 8
4200d66a:	8c1c      	movi.n	a12, 24
4200d66c:	042c87        	blt	a12, a8, 4200d674 <get_arg$isra$0+0x200>
4200d66f:	14b8      	l32i.n	a11, a4, 4
4200d671:	000206        	j	4200d67d <get_arg$isra$0+0x209>
4200d674:	012cb7        	blt	a12, a11, 4200d679 <get_arg$isra$0+0x205>
4200d677:	482c      	movi.n	a8, 36
4200d679:	04b8      	l32i.n	a11, a4, 0
4200d67b:	2489      	s32i.n	a8, a4, 8
4200d67d:	bb8a      	add.n	a11, a11, a8
4200d67f:	fccbb2        	addi	a11, a11, -4
4200d682:	0b88      	l32i.n	a8, a11, 0
4200d684:	f37c      	movi.n	a3, -1
4200d686:	0a89      	s32i.n	a8, a10, 0
4200d688:	650c      	movi.n	a5, 6
4200d68a:	0060c6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d68d:	0188      	l32i.n	a8, a1, 0
4200d68f:	24b8      	l32i.n	a11, a4, 8
4200d691:	2a1b      	addi.n	a2, a10, 1
4200d693:	b0aa80        	addx8	a10, a10, a8
4200d696:	8b4b      	addi.n	a8, a11, 4
4200d698:	2489      	s32i.n	a8, a4, 8
4200d69a:	8c1c      	movi.n	a12, 24
4200d69c:	042c87        	blt	a12, a8, 4200d6a4 <get_arg$isra$0+0x230>
4200d69f:	14b8      	l32i.n	a11, a4, 4
4200d6a1:	000206        	j	4200d6ad <get_arg$isra$0+0x239>
4200d6a4:	012cb7        	blt	a12, a11, 4200d6a9 <get_arg$isra$0+0x235>
4200d6a7:	482c      	movi.n	a8, 36
4200d6a9:	04b8      	l32i.n	a11, a4, 0
4200d6ab:	2489      	s32i.n	a8, a4, 8
4200d6ad:	bb8a      	add.n	a11, a11, a8
4200d6af:	fccbb2        	addi	a11, a11, -4
4200d6b2:	0b88      	l32i.n	a8, a11, 0
4200d6b4:	f37c      	movi.n	a3, -1
4200d6b6:	0a89      	s32i.n	a8, a10, 0
4200d6b8:	050c      	movi.n	a5, 0
4200d6ba:	0054c6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d6bd:	0188      	l32i.n	a8, a1, 0
4200d6bf:	24b8      	l32i.n	a11, a4, 8
4200d6c1:	2a1b      	addi.n	a2, a10, 1
4200d6c3:	b0aa80        	addx8	a10, a10, a8
4200d6c6:	8b4b      	addi.n	a8, a11, 4
4200d6c8:	2489      	s32i.n	a8, a4, 8
4200d6ca:	8c1c      	movi.n	a12, 24
4200d6cc:	042c87        	blt	a12, a8, 4200d6d4 <get_arg$isra$0+0x260>
4200d6cf:	14b8      	l32i.n	a11, a4, 4
4200d6d1:	000206        	j	4200d6dd <get_arg$isra$0+0x269>
4200d6d4:	012cb7        	blt	a12, a11, 4200d6d9 <get_arg$isra$0+0x265>
4200d6d7:	482c      	movi.n	a8, 36
4200d6d9:	04b8      	l32i.n	a11, a4, 0
4200d6db:	2489      	s32i.n	a8, a4, 8
4200d6dd:	bb8a      	add.n	a11, a11, a8
4200d6df:	fccbb2        	addi	a11, a11, -4
4200d6e2:	0b88      	l32i.n	a8, a11, 0
4200d6e4:	f37c      	movi.n	a3, -1
4200d6e6:	0a89      	s32i.n	a8, a10, 0
4200d6e8:	350c      	movi.n	a5, 3
4200d6ea:	0048c6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d6ed:	0188      	l32i.n	a8, a1, 0
4200d6ef:	2a1b      	addi.n	a2, a10, 1
4200d6f1:	b0aa80        	addx8	a10, a10, a8
4200d6f4:	2488      	l32i.n	a8, a4, 8
4200d6f6:	8b7c      	movi.n	a11, -8
4200d6f8:	887b      	addi.n	a8, a8, 7
4200d6fa:	1088b0        	and	a8, a8, a11
4200d6fd:	b88b      	addi.n	a11, a8, 8
4200d6ff:	24b9      	s32i.n	a11, a4, 8
4200d701:	8c1c      	movi.n	a12, 24
4200d703:	052cb7        	blt	a12, a11, 4200d70c <get_arg$isra$0+0x298>
4200d706:	1488      	l32i.n	a8, a4, 4
4200d708:	000246        	j	4200d715 <get_arg$isra$0+0x2a1>
4200d70b:	00          	.byte	00
4200d70c:	012c87        	blt	a12, a8, 4200d711 <get_arg$isra$0+0x29d>
4200d70f:	8b2c      	movi.n	a11, 40
4200d711:	0488      	l32i.n	a8, a4, 0
4200d713:	24b9      	s32i.n	a11, a4, 8
4200d715:	88ba      	add.n	a8, a8, a11
4200d717:	f8c882        	addi	a8, a8, -8
4200d71a:	1898      	l32i.n	a9, a8, 4
4200d71c:	0888      	l32i.n	a8, a8, 0
4200d71e:	f37c      	movi.n	a3, -1
4200d720:	0a89      	s32i.n	a8, a10, 0
4200d722:	1a99      	s32i.n	a9, a10, 4
4200d724:	450c      	movi.n	a5, 4
4200d726:	0039c6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d729:	8a7c      	movi.n	a10, -8
4200d72b:	887b      	addi.n	a8, a8, 7
4200d72d:	1088a0        	and	a8, a8, a10
4200d730:	0198      	l32i.n	a9, a1, 0
4200d732:	a88b      	addi.n	a10, a8, 8
4200d734:	24a9      	s32i.n	a10, a4, 8
4200d736:	8c1c      	movi.n	a12, 24
4200d738:	b0bb90        	addx8	a11, a11, a9
4200d73b:	052ca7        	blt	a12, a10, 4200d744 <get_arg$isra$0+0x2d0>
4200d73e:	1488      	l32i.n	a8, a4, 4
4200d740:	000246        	j	4200d74d <get_arg$isra$0+0x2d9>
4200d743:	00          	.byte	00
4200d744:	012c87        	blt	a12, a8, 4200d749 <get_arg$isra$0+0x2d5>
4200d747:	8a2c      	movi.n	a10, 40
4200d749:	0488      	l32i.n	a8, a4, 0
4200d74b:	24a9      	s32i.n	a10, a4, 8
4200d74d:	88aa      	add.n	a8, a8, a10
4200d74f:	f8c882        	addi	a8, a8, -8
4200d752:	1898      	l32i.n	a9, a8, 4
4200d754:	0888      	l32i.n	a8, a8, 0
4200d756:	1b99      	s32i.n	a9, a11, 4
4200d758:	0b89      	s32i.n	a8, a11, 0
4200d75a:	002cc6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d75d:	1188      	l32i.n	a8, a1, 4
4200d75f:	0888      	l32i.n	a8, a8, 0
4200d761:	140866        	bnei	a8, -1, 4200d779 <get_arg$isra$0+0x305>
4200d764:	11a8      	l32i.n	a10, a1, 4
4200d766:	80a0c2        	movi	a12, 128
4200d769:	0b0c      	movi.n	a11, 0
4200d76b:	61d9      	s32i.n	a13, a1, 24
4200d76d:	51e9      	s32i.n	a14, a1, 20
4200d76f:	cae581        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200d772:	0008e0        	callx8	a8
4200d775:	61d8      	l32i.n	a13, a1, 24
4200d777:	51e8      	l32i.n	a14, a1, 20
4200d779:	3d0b      	addi.n	a3, a13, -1
4200d77b:	53ee30        	max	a14, a14, a3
4200d77e:	0023c6        	j	4200d811 <get_arg$isra$0+0x39d>
4200d781:	1188      	l32i.n	a8, a1, 4
4200d783:	0888      	l32i.n	a8, a8, 0
4200d785:	140866        	bnei	a8, -1, 4200d79d <get_arg$isra$0+0x329>
4200d788:	11a8      	l32i.n	a10, a1, 4
4200d78a:	80a0c2        	movi	a12, 128
4200d78d:	0b0c      	movi.n	a11, 0
4200d78f:	61d9      	s32i.n	a13, a1, 24
4200d791:	51e9      	s32i.n	a14, a1, 20
4200d793:	cadc81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4200d796:	0008e0        	callx8	a8
4200d799:	61d8      	l32i.n	a13, a1, 24
4200d79b:	51e8      	l32i.n	a14, a1, 20
4200d79d:	1188      	l32i.n	a8, a1, 4
4200d79f:	dd0b      	addi.n	a13, a13, -1
4200d7a1:	a08d80        	addx4	a8, a13, a8
4200d7a4:	0a0c      	movi.n	a10, 0
4200d7a6:	08a9      	s32i.n	a10, a8, 0
4200d7a8:	53eed0        	max	a14, a14, a13
4200d7ab:	001886        	j	4200d811 <get_arg$isra$0+0x39d>
4200d7ae:	0188      	l32i.n	a8, a1, 0
4200d7b0:	24b8      	l32i.n	a11, a4, 8
4200d7b2:	f21b      	addi.n	a15, a2, 1
4200d7b4:	b02280        	addx8	a2, a2, a8
4200d7b7:	8b4b      	addi.n	a8, a11, 4
4200d7b9:	2489      	s32i.n	a8, a4, 8
4200d7bb:	8c1c      	movi.n	a12, 24
4200d7bd:	042c87        	blt	a12, a8, 4200d7c5 <get_arg$isra$0+0x351>
4200d7c0:	14b8      	l32i.n	a11, a4, 4
4200d7c2:	000206        	j	4200d7ce <get_arg$isra$0+0x35a>
4200d7c5:	012cb7        	blt	a12, a11, 4200d7ca <get_arg$isra$0+0x356>
4200d7c8:	482c      	movi.n	a8, 36
4200d7ca:	04b8      	l32i.n	a11, a4, 0
4200d7cc:	2489      	s32i.n	a8, a4, 8
4200d7ce:	bb8a      	add.n	a11, a11, a8
4200d7d0:	fccbb2        	addi	a11, a11, -4
4200d7d3:	0b88      	l32i.n	a8, a11, 0
4200d7d5:	0a7d      	mov.n	a7, a10
4200d7d7:	0289      	s32i.n	a8, a2, 0
4200d7d9:	0f2d      	mov.n	a2, a15
4200d7db:	000c86        	j	4200d811 <get_arg$isra$0+0x39d>
4200d7de:	d20000        	quos	a0, a0, a0
4200d7e1:	d0c8      	l32i.n	a12, a0, 52
4200d7e3:	9a0c      	movi.n	a10, 9
4200d7e5:	0001c6        	j	4200d7f0 <get_arg$isra$0+0x37c>
4200d7e8:	a0ddd0        	addx4	a13, a13, a13
4200d7eb:	90dd80        	addx2	a13, a13, a8
4200d7ee:	771b      	addi.n	a7, a7, 1
4200d7f0:	000782        	l8ui	a8, a7, 0
4200d7f3:	a89c      	beqz.n	a8, 4200d811 <get_arg$isra$0+0x39d>
4200d7f5:	d0c882        	addi	a8, a8, -48
4200d7f8:	ecba87        	bgeu	a10, a8, 4200d7e8 <get_arg$isra$0+0x374>
4200d7fb:	000486        	j	4200d811 <get_arg$isra$0+0x39d>
4200d7fe:	820000        	mull	a0, a0, a0
4200d801:	820007        	bnone	a0, a0, 4200d787 <get_arg$isra$0+0x313>
4200d804:	d0c8      	l32i.n	a12, a0, 52
4200d806:	748080        	extui	a8, a8, 0, 8
4200d809:	043a87        	bltu	a10, a8, 4200d811 <get_arg$isra$0+0x39d>
4200d80c:	771b      	addi.n	a7, a7, 1
4200d80e:	fffb86        	j	4200d800 <get_arg$isra$0+0x38c>
4200d811:	3198      	l32i.n	a9, a1, 12
4200d813:	b80c      	movi.n	a8, 11
4200d815:	021987        	beq	a9, a8, 4200d81b <get_arg$isra$0+0x3a7>
4200d818:	ff2506        	j	4200d4b0 <get_arg$isra$0+0x3c>
4200d81b:	0007a2        	l8ui	a10, a7, 0
4200d81e:	ea8c      	beqz.n	a10, 4200d830 <get_arg$isra$0+0x3bc>
4200d820:	2188      	l32i.n	a8, a1, 8
4200d822:	728820        	salt	a8, a8, a2
4200d825:	880b      	addi.n	a8, a8, -1
4200d827:	608080        	neg	a8, a8
4200d82a:	748080        	extui	a8, a8, 0, 8
4200d82d:	c5f856        	bnez	a8, 4200d490 <get_arg$isra$0+0x1c>
4200d830:	2188      	l32i.n	a8, a1, 8
4200d832:	93e8a0        	movnez	a14, a8, a10
4200d835:	002346        	j	4200d8c6 <get_arg$isra$0+0x452>
4200d838:	1188      	l32i.n	a8, a1, 4
4200d83a:	a08d80        	addx4	a8, a13, a8
4200d83d:	08c8      	l32i.n	a12, a8, 0
4200d83f:	dd1b      	addi.n	a13, a13, 1
4200d841:	cc0b      	addi.n	a12, a12, -1
4200d843:	2488      	l32i.n	a8, a4, 8
4200d845:	5c6cf6        	bgeui	a12, 6, 4200d8a5 <get_arg$isra$0+0x431>
4200d848:	a0cc60        	addx4	a12, a12, a6
4200d84b:	0cc8      	l32i.n	a12, a12, 0
4200d84d:	000ca0        	jx	a12
4200d850:	887b      	addi.n	a8, a8, 7
4200d852:	1088f0        	and	a8, a8, a15
4200d855:	c88b      	addi.n	a12, a8, 8
4200d857:	24c9      	s32i.n	a12, a4, 8
4200d859:	042ac7        	blt	a10, a12, 4200d861 <get_arg$isra$0+0x3ed>
4200d85c:	1488      	l32i.n	a8, a4, 4
4200d85e:	000206        	j	4200d86a <get_arg$isra$0+0x3f6>
4200d861:	012a87        	blt	a10, a8, 4200d866 <get_arg$isra$0+0x3f2>
4200d864:	8c2c      	movi.n	a12, 40
4200d866:	0488      	l32i.n	a8, a4, 0
4200d868:	24c9      	s32i.n	a12, a4, 8
4200d86a:	88ca      	add.n	a8, a8, a12
4200d86c:	f8c882        	addi	a8, a8, -8
4200d86f:	1898      	l32i.n	a9, a8, 4
4200d871:	0888      	l32i.n	a8, a8, 0
4200d873:	1b99      	s32i.n	a9, a11, 4
4200d875:	0b89      	s32i.n	a8, a11, 0
4200d877:	001706        	j	4200d8d7 <get_arg$isra$0+0x463>
4200d87a:	887b      	addi.n	a8, a8, 7
4200d87c:	1088f0        	and	a8, a8, a15
4200d87f:	c88b      	addi.n	a12, a8, 8
4200d881:	24c9      	s32i.n	a12, a4, 8
4200d883:	052ac7        	blt	a10, a12, 4200d88c <get_arg$isra$0+0x418>
4200d886:	1488      	l32i.n	a8, a4, 4
4200d888:	000246        	j	4200d895 <get_arg$isra$0+0x421>
4200d88b:	2a8700        	mul.s	f8, f7, f0
4200d88e:	8c2c01        	l32r	a0, 41ff0940 <_iram_bss_end+0x1c6e540>
4200d891:	0488      	l32i.n	a8, a4, 0
4200d893:	24c9      	s32i.n	a12, a4, 8
4200d895:	88ca      	add.n	a8, a8, a12
4200d897:	f8c882        	addi	a8, a8, -8
4200d89a:	1898      	l32i.n	a9, a8, 4
4200d89c:	0888      	l32i.n	a8, a8, 0
4200d89e:	1b99      	s32i.n	a9, a11, 4
4200d8a0:	0b89      	s32i.n	a8, a11, 0
4200d8a2:	000c46        	j	4200d8d7 <get_arg$isra$0+0x463>
4200d8a5:	c84b      	addi.n	a12, a8, 4
4200d8a7:	24c9      	s32i.n	a12, a4, 8
4200d8a9:	042ac7        	blt	a10, a12, 4200d8b1 <get_arg$isra$0+0x43d>
4200d8ac:	1488      	l32i.n	a8, a4, 4
4200d8ae:	000206        	j	4200d8ba <get_arg$isra$0+0x446>
4200d8b1:	012a87        	blt	a10, a8, 4200d8b6 <get_arg$isra$0+0x442>
4200d8b4:	4c2c      	movi.n	a12, 36
4200d8b6:	0488      	l32i.n	a8, a4, 0
4200d8b8:	24c9      	s32i.n	a12, a4, 8
4200d8ba:	88ca      	add.n	a8, a8, a12
4200d8bc:	fcc882        	addi	a8, a8, -4
4200d8bf:	0888      	l32i.n	a8, a8, 0
4200d8c1:	0b89      	s32i.n	a8, a11, 0
4200d8c3:	000406        	j	4200d8d7 <get_arg$isra$0+0x463>
4200d8c6:	0188      	l32i.n	a8, a1, 0
4200d8c8:	cd7361        	l32r	a6, 42000e94 <_stext+0xe74> (3c028540 <Xthal_intlevel+0xb8>)
4200d8cb:	b0b280        	addx8	a11, a2, a8
4200d8ce:	02dd      	mov.n	a13, a2
4200d8d0:	8a1c      	movi.n	a10, 24
4200d8d2:	8f7c      	movi.n	a15, -8
4200d8d4:	000046        	j	4200d8d9 <get_arg$isra$0+0x465>
4200d8d7:	bb8b      	addi.n	a11, a11, 8
4200d8d9:	022ed7        	blt	a14, a13, 4200d8df <get_arg$isra$0+0x46b>
4200d8dc:	ffd606        	j	4200d838 <get_arg$isra$0+0x3c4>
4200d8df:	8e1b      	addi.n	a8, a14, 1
4200d8e1:	728820        	salt	a8, a8, a2
4200d8e4:	880b      	addi.n	a8, a8, -1
4200d8e6:	608080        	neg	a8, a8
4200d8e9:	748080        	extui	a8, a8, 0, 8
4200d8ec:	0a0c      	movi.n	a10, 0
4200d8ee:	d8bc      	beqz.n	a8, 4200d92f <get_arg$isra$0+0x4bb>
4200d8f0:	820b      	addi.n	a8, a2, -1
4200d8f2:	608080        	neg	a8, a8
4200d8f5:	a8ea      	add.n	a10, a8, a14
4200d8f7:	000d06        	j	4200d92f <get_arg$isra$0+0x4bb>
4200d8fa:	450c      	movi.n	a5, 4
4200d8fc:	020326        	beqi	a3, -1, 4200d902 <get_arg$isra$0+0x48e>
4200d8ff:	ff3446        	j	4200d5d4 <get_arg$isra$0+0x160>
4200d902:	ff79c6        	j	4200d6ed <get_arg$isra$0+0x279>
4200d905:	350c      	movi.n	a5, 3
4200d907:	020326        	beqi	a3, -1, 4200d90d <get_arg$isra$0+0x499>
4200d90a:	ff3186        	j	4200d5d4 <get_arg$isra$0+0x160>
4200d90d:	ff6b06        	j	4200d6bd <get_arg$isra$0+0x249>
4200d910:	020326        	beqi	a3, -1, 4200d916 <get_arg$isra$0+0x4a2>
4200d913:	ff2f46        	j	4200d5d4 <get_arg$isra$0+0x160>
4200d916:	ff5cc6        	j	4200d68d <get_arg$isra$0+0x219>
4200d919:	650c      	movi.n	a5, 6
4200d91b:	020326        	beqi	a3, -1, 4200d921 <get_arg$isra$0+0x4ad>
4200d91e:	ff2c86        	j	4200d5d4 <get_arg$isra$0+0x160>
4200d921:	ff4e06        	j	4200d65d <get_arg$isra$0+0x1e9>
4200d924:	150c      	movi.n	a5, 1
4200d926:	020326        	beqi	a3, -1, 4200d92c <get_arg$isra$0+0x4b8>
4200d929:	ff29c6        	j	4200d5d4 <get_arg$isra$0+0x160>
4200d92c:	ff3286        	j	4200d5fa <get_arg$isra$0+0x186>
4200d92f:	4198      	l32i.n	a9, a1, 16
4200d931:	8a2a      	add.n	a8, a10, a2
4200d933:	0989      	s32i.n	a8, a9, 0
4200d935:	102182        	l32i	a8, a1, 64
4200d938:	0198      	l32i.n	a9, a1, 0
4200d93a:	0879      	s32i.n	a7, a8, 0
4200d93c:	2188      	l32i.n	a8, a1, 8
4200d93e:	b02890        	addx8	a2, a8, a9
4200d941:	f01d      	retw.n
	...

4200d944 <_vfprintf_r>:
4200d944:	064136        	entry	a1, 0x320
4200d947:	9f6142        	s32i	a4, a1, 0x27c
4200d94a:	02ad      	mov.n	a10, a2
4200d94c:	9c6152        	s32i	a5, a1, 0x270
4200d94f:	9d6162        	s32i	a6, a1, 0x274
4200d952:	9e6172        	s32i	a7, a1, 0x278
4200d955:	a16122        	s32i	a2, a1, 0x284
4200d958:	a06132        	s32i	a3, a1, 0x280
4200d95b:	201110        	or	a1, a1, a1
4200d95e:	04fde5        	call8	4201293c <_localeconv_r>
4200d961:	0a88      	l32i.n	a8, a10, 0
4200d963:	10c142        	addi	a4, a1, 16
4200d966:	08ad      	mov.n	a10, a8
4200d968:	b16182        	s32i	a8, a1, 0x2c4
4200d96b:	ca5e81        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
4200d96e:	0008e0        	callx8	a8
4200d971:	a12182        	l32i	a8, a1, 0x284
4200d974:	ad61a2        	s32i	a10, a1, 0x2b4
4200d977:	00d816        	beqz	a8, 4200d988 <_vfprintf_r+0x44>
4200d97a:	0a2882        	l32i	a8, a8, 40
4200d97d:	78cc      	bnez.n	a8, 4200d988 <_vfprintf_r+0x44>
4200d97f:	a121a2        	l32i	a10, a1, 0x284
4200d982:	201110        	or	a1, a1, a1
4200d985:	ff4d65        	call8	4200ce5c <__sinit>
4200d988:	a02182        	l32i	a8, a1, 0x280
4200d98b:	192882        	l32i	a8, a8, 100
4200d98e:	14e807        	bbsi	a8, 0, 4200d9a6 <_vfprintf_r+0x62>
4200d991:	a02182        	l32i	a8, a1, 0x280
4200d994:	061882        	l16ui	a8, a8, 12
4200d997:	0be897        	bbsi	a8, 9, 4200d9a6 <_vfprintf_r+0x62>
4200d99a:	a02182        	l32i	a8, a1, 0x280
4200d99d:	1628a2        	l32i	a10, a8, 88
4200d9a0:	cd1a81        	l32r	a8, 42000e08 <_stext+0xde8> (40376b04 <__retarget_lock_acquire_recursive>)
4200d9a3:	0008e0        	callx8	a8
4200d9a6:	a02182        	l32i	a8, a1, 0x280
4200d9a9:	061882        	l16ui	a8, a8, 12
4200d9ac:	066837        	bbci	a8, 3, 4200d9b6 <_vfprintf_r+0x72>
4200d9af:	a02182        	l32i	a8, a1, 0x280
4200d9b2:	4888      	l32i.n	a8, a8, 16
4200d9b4:	58fc      	bnez.n	a8, 4200d9ed <_vfprintf_r+0xa9>
4200d9b6:	a021b2        	l32i	a11, a1, 0x280
4200d9b9:	a121a2        	l32i	a10, a1, 0x284
4200d9bc:	201110        	or	a1, a1, a1
4200d9bf:	ff9025        	call8	4200d2c0 <__swsetup_r>
4200d9c2:	7aac      	beqz.n	a10, 4200d9ed <_vfprintf_r+0xa9>
4200d9c4:	a02182        	l32i	a8, a1, 0x280
4200d9c7:	192882        	l32i	a8, a8, 100
4200d9ca:	076807        	bbci	a8, 0, 4200d9d5 <_vfprintf_r+0x91>
4200d9cd:	f87c      	movi.n	a8, -1
4200d9cf:	ae6182        	s32i	a8, a1, 0x2b8
4200d9d2:	0ae586        	j	4201056c <_vfprintf_r+0x2c28>
4200d9d5:	a02182        	l32i	a8, a1, 0x280
4200d9d8:	061882        	l16ui	a8, a8, 12
4200d9db:	eee897        	bbsi	a8, 9, 4200d9cd <_vfprintf_r+0x89>
4200d9de:	a02182        	l32i	a8, a1, 0x280
4200d9e1:	1628a2        	l32i	a10, a8, 88
4200d9e4:	cd0a81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200d9e7:	0008e0        	callx8	a8
4200d9ea:	fff7c6        	j	4200d9cd <_vfprintf_r+0x89>
4200d9ed:	a02182        	l32i	a8, a1, 0x280
4200d9f0:	069892        	l16si	a9, a8, 12
4200d9f3:	1aa082        	movi	a8, 26
4200d9f6:	108980        	and	a8, a9, a8
4200d9f9:	439866        	bnei	a8, 10, 4200da40 <_vfprintf_r+0xfc>
4200d9fc:	a02182        	l32i	a8, a1, 0x280
4200d9ff:	079882        	l16si	a8, a8, 14
4200da02:	03a896        	bltz	a8, 4200da40 <_vfprintf_r+0xfc>
4200da05:	a02182        	l32i	a8, a1, 0x280
4200da08:	192882        	l32i	a8, a8, 100
4200da0b:	0ee807        	bbsi	a8, 0, 4200da1d <_vfprintf_r+0xd9>
4200da0e:	0be997        	bbsi	a9, 9, 4200da1d <_vfprintf_r+0xd9>
4200da11:	a02182        	l32i	a8, a1, 0x280
4200da14:	1628a2        	l32i	a10, a8, 88
4200da17:	ccfd81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4200da1a:	0008e0        	callx8	a8
4200da1d:	9824d2        	l32i	a13, a4, 0x260
4200da20:	9924e2        	l32i	a14, a4, 0x264
4200da23:	9a24f2        	l32i	a15, a4, 0x268
4200da26:	9f21c2        	l32i	a12, a1, 0x27c
4200da29:	a021b2        	l32i	a11, a1, 0x280
4200da2c:	a121a2        	l32i	a10, a1, 0x284
4200da2f:	02d442        	addmi	a4, a4, 0x200
4200da32:	201110        	or	a1, a1, a1
4200da35:	02b625        	call8	42010598 <__sbprintf>
4200da38:	ae61a2        	s32i	a10, a1, 0x2b8
4200da3b:	0acb46        	j	4201056c <_vfprintf_r+0x2c28>
4200da3e:	820000        	mull	a0, a0, a0
4200da41:	8ae4a1        	l32r	a10, 41ff05d4 <_iram_bss_end+0x1c6e1d4>
4200da44:	84          	.byte	0x84
4200da45:	090c      	movi.n	a9, 0
4200da47:	896482        	s32i	a8, a4, 0x224
4200da4a:	082d      	mov.n	a2, a8
4200da4c:	080c      	movi.n	a8, 0
4200da4e:	fa7c      	movi.n	a10, -1
4200da50:	8b6492        	s32i	a9, a4, 0x22c
4200da53:	8a6492        	s32i	a9, a4, 0x228
4200da56:	966192        	s32i	a9, a1, 0x258
4200da59:	976192        	s32i	a9, a1, 0x25c
4200da5c:	a46192        	s32i	a9, a1, 0x290
4200da5f:	b86182        	s32i	a8, a1, 0x2e0
4200da62:	b76182        	s32i	a8, a1, 0x2dc
4200da65:	aa6182        	s32i	a8, a1, 0x2a8
4200da68:	b06182        	s32i	a8, a1, 0x2c0
4200da6b:	b66182        	s32i	a8, a1, 0x2d8
4200da6e:	ae6182        	s32i	a8, a1, 0x2b8
4200da71:	10c192        	addi	a9, a1, 16
4200da74:	e4a182        	movi	a8, 0x1e4
4200da77:	4064a2        	s32i	a10, a4, 0x100
4200da7a:	0b0c      	movi.n	a11, 0
4200da7c:	0a0c      	movi.n	a10, 0
4200da7e:	898a      	add.n	a8, a9, a8
4200da80:	a661a2        	s32i	a10, a1, 0x298
4200da83:	a761b2        	s32i	a11, a1, 0x29c
4200da86:	070c      	movi.n	a7, 0
4200da88:	bb6182        	s32i	a8, a1, 0x2ec
4200da8b:	000346        	j	4200da9c <_vfprintf_r+0x158>
4200da8e:	e4a182        	movi	a8, 0x1e4
4200da91:	10c192        	addi	a9, a1, 16
4200da94:	298a      	add.n	a2, a9, a8
4200da96:	a82182        	l32i	a8, a1, 0x2a0
4200da99:	9f6182        	s32i	a8, a1, 0x27c
4200da9c:	9f2152        	l32i	a5, a1, 0x27c
4200da9f:	000046        	j	4200daa4 <_vfprintf_r+0x160>
4200daa2:	551b      	addi.n	a5, a5, 1
4200daa4:	000582        	l8ui	a8, a5, 0
4200daa7:	005816        	beqz	a8, 4200dab0 <_vfprintf_r+0x16c>
4200daaa:	dbc882        	addi	a8, a8, -37
4200daad:	ff1856        	bnez	a8, 4200daa2 <_vfprintf_r+0x15e>
4200dab0:	9f2182        	l32i	a8, a1, 0x27c
4200dab3:	c06580        	sub	a6, a5, a8
4200dab6:	044616        	beqz	a6, 4200dafe <_vfprintf_r+0x1ba>
4200dab9:	0289      	s32i.n	a8, a2, 0
4200dabb:	10c182        	addi	a8, a1, 16
4200dabe:	02d892        	addmi	a9, a8, 0x200
4200dac1:	8f2182        	l32i	a8, a1, 0x23c
4200dac4:	1269      	s32i.n	a6, a2, 4
4200dac6:	886a      	add.n	a8, a8, a6
4200dac8:	b989      	s32i.n	a8, a9, 44
4200daca:	a988      	l32i.n	a8, a9, 40
4200dacc:	228b      	addi.n	a2, a2, 8
4200dace:	881b      	addi.n	a8, a8, 1
4200dad0:	a989      	s32i.n	a8, a9, 40
4200dad2:	2088a6        	blti	a8, 8, 4200daf6 <_vfprintf_r+0x1b2>
4200dad5:	24a2c2        	movi	a12, 0x224
4200dad8:	10c182        	addi	a8, a1, 16
4200dadb:	a021b2        	l32i	a11, a1, 0x280
4200dade:	a121a2        	l32i	a10, a1, 0x284
4200dae1:	c8ca      	add.n	a12, a8, a12
4200dae3:	201110        	or	a1, a1, a1
4200dae6:	030165        	call8	42010afc <__sprint_r>
4200dae9:	1a8c      	beqz.n	a10, 4200daee <_vfprintf_r+0x1aa>
4200daeb:	0a9046        	j	42010530 <_vfprintf_r+0x2bec>
4200daee:	e4a182        	movi	a8, 0x1e4
4200daf1:	10c192        	addi	a9, a1, 16
4200daf4:	298a      	add.n	a2, a9, a8
4200daf6:	ae2182        	l32i	a8, a1, 0x2b8
4200daf9:	886a      	add.n	a8, a8, a6
4200dafb:	ae6182        	s32i	a8, a1, 0x2b8
4200dafe:	000582        	l8ui	a8, a5, 0
4200db01:	18cc      	bnez.n	a8, 4200db06 <_vfprintf_r+0x1c2>
4200db03:	0a7b46        	j	420104f4 <_vfprintf_r+0x2bb0>
4200db06:	10c192        	addi	a9, a1, 16
4200db09:	02d992        	addmi	a9, a9, 0x200
4200db0c:	0a0c      	movi.n	a10, 0
4200db0e:	5249a2        	s8i	a10, a9, 82
4200db11:	f97c      	movi.n	a9, -1
4200db13:	a26192        	s32i	a9, a1, 0x288
4200db16:	090c      	movi.n	a9, 0
4200db18:	851b      	addi.n	a8, a5, 1
4200db1a:	076d      	mov.n	a6, a7
4200db1c:	ac6192        	s32i	a9, a1, 0x2b0
4200db1f:	040c      	movi.n	a4, 0
4200db21:	030c      	movi.n	a3, 0
4200db23:	000286        	j	4200db31 <_vfprintf_r+0x1ed>
4200db26:	000000        	ill
4200db29:	a86192        	s32i	a9, a1, 0x2a0
4200db2c:	040c      	movi.n	a4, 0
4200db2e:	a82182        	l32i	a8, a1, 0x2a0
4200db31:	981b      	addi.n	a9, a8, 1
4200db33:	000882        	l8ui	a8, a8, 0
4200db36:	a86192        	s32i	a9, a1, 0x2a0
4200db39:	a36182        	s32i	a8, a1, 0x28c
4200db3c:	aa5c      	movi.n	a10, 90
4200db3e:	000086        	j	4200db44 <_vfprintf_r+0x200>
4200db41:	ac6182        	s32i	a8, a1, 0x2b0
4200db44:	a32182        	l32i	a8, a1, 0x28c
4200db47:	e0c882        	addi	a8, a8, -32
4200db4a:	02ba87        	bgeu	a10, a8, 4200db50 <_vfprintf_r+0x20c>
4200db4d:	07a8c6        	j	4200f9f4 <_vfprintf_r+0x20b0>
4200db50:	ccd891        	l32r	a9, 42000eb0 <_stext+0xe90> (3c028558 <Xthal_intlevel+0xd0>)
4200db53:	a08890        	addx4	a8, a8, a9
4200db56:	0888      	l32i.n	a8, a8, 0
4200db58:	0008a0        	jx	a8
4200db5b:	ccd381        	l32r	a8, 42000ea8 <_stext+0xe88> (3c0286f4 <blanks$1+0x20>)
4200db5e:	066846        	j	4200f503 <_vfprintf_r+0x1bbf>
4200db61:	a121a2        	l32i	a10, a1, 0x284
4200db64:	201110        	or	a1, a1, a1
4200db67:	04dd65        	call8	4201293c <_localeconv_r>
4200db6a:	1a88      	l32i.n	a8, a10, 4
4200db6c:	20a880        	or	a10, a8, a8
4200db6f:	b66182        	s32i	a8, a1, 0x2d8
4200db72:	c9dc81        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
4200db75:	0008e0        	callx8	a8
4200db78:	b061a2        	s32i	a10, a1, 0x2c0
4200db7b:	a121a2        	l32i	a10, a1, 0x284
4200db7e:	201110        	or	a1, a1, a1
4200db81:	04dba5        	call8	4201293c <_localeconv_r>
4200db84:	2a88      	l32i.n	a8, a10, 8
4200db86:	aa6182        	s32i	a8, a1, 0x2a8
4200db89:	b02182        	l32i	a8, a1, 0x2c0
4200db8c:	f9e816        	beqz	a8, 4200db2e <_vfprintf_r+0x1ea>
4200db8f:	aa2182        	l32i	a8, a1, 0x2a8
4200db92:	f98816        	beqz	a8, 4200db2e <_vfprintf_r+0x1ea>
4200db95:	000882        	l8ui	a8, a8, 0
4200db98:	f92816        	beqz	a8, 4200db2e <_vfprintf_r+0x1ea>
4200db9b:	00a482        	movi	a8, 0x400
4200db9e:	00c946        	j	4200dec7 <_vfprintf_r+0x583>
4200dba1:	10c182        	addi	a8, a1, 16
4200dba4:	02d882        	addmi	a8, a8, 0x200
4200dba7:	520892        	l8ui	a9, a8, 82
4200dbaa:	f80956        	bnez	a9, 4200db2e <_vfprintf_r+0x1ea>
4200dbad:	092c      	movi.n	a9, 32
4200dbaf:	004ac6        	j	4200dcde <_vfprintf_r+0x39a>
4200dbb2:	180c      	movi.n	a8, 1
4200dbb4:	00c3c6        	j	4200dec7 <_vfprintf_r+0x583>
4200dbb7:	a82182        	l32i	a8, a1, 0x2a0
4200dbba:	9a0c      	movi.n	a10, 9
4200dbbc:	000882        	l8ui	a8, a8, 0
4200dbbf:	d0c892        	addi	a9, a8, -48
4200dbc2:	463a97        	bltu	a10, a9, 4200dc0c <_vfprintf_r+0x2c8>
4200dbc5:	a82192        	l32i	a9, a1, 0x2a0
4200dbc8:	0a0c      	movi.n	a10, 0
4200dbca:	991b      	addi.n	a9, a9, 1
4200dbcc:	a36192        	s32i	a9, a1, 0x28c
4200dbcf:	9b0c      	movi.n	a11, 9
4200dbd1:	d0c882        	addi	a8, a8, -48
4200dbd4:	a0aaa0        	addx4	a10, a10, a10
4200dbd7:	90aa80        	addx2	a10, a10, a8
4200dbda:	a32182        	l32i	a8, a1, 0x28c
4200dbdd:	a32192        	l32i	a9, a1, 0x28c
4200dbe0:	000882        	l8ui	a8, a8, 0
4200dbe3:	991b      	addi.n	a9, a9, 1
4200dbe5:	a36192        	s32i	a9, a1, 0x28c
4200dbe8:	d0c892        	addi	a9, a8, -48
4200dbeb:	e2bb97        	bgeu	a11, a9, 4200dbd1 <_vfprintf_r+0x28d>
4200dbee:	492c      	movi.n	a9, 36
4200dbf0:	021897        	beq	a8, a9, 4200dbf6 <_vfprintf_r+0x2b2>
4200dbf3:	ffcd46        	j	4200db2c <_vfprintf_r+0x1e8>
4200dbf6:	082c      	movi.n	a8, 32
4200dbf8:	02a8a7        	bge	a8, a10, 4200dbfe <_vfprintf_r+0x2ba>
4200dbfb:	0a4c46        	j	42010530 <_vfprintf_r+0x2bec>
4200dbfe:	972182        	l32i	a8, a1, 0x25c
4200dc01:	aa0b      	addi.n	a10, a10, -1
4200dc03:	10c1e2        	addi	a14, a1, 16
4200dc06:	122a87        	blt	a10, a8, 4200dc1c <_vfprintf_r+0x2d8>
4200dc09:	0005c6        	j	4200dc24 <_vfprintf_r+0x2e0>
4200dc0c:	9721b2        	l32i	a11, a1, 0x25c
4200dc0f:	a71b      	addi.n	a10, a7, 1
4200dc11:	10c192        	addi	a9, a1, 16
4200dc14:	3527b7        	blt	a7, a11, 4200dc4d <_vfprintf_r+0x309>
4200dc17:	000e06        	j	4200dc53 <_vfprintf_r+0x30f>
4200dc1a:	e00000        	subx4	a0, a0, a0
4200dc1d:	b0ea      	add.n	a11, a0, a14
4200dc1f:	0e88      	l32i.n	a8, a14, 0
4200dc21:	000686        	j	4200dc3f <_vfprintf_r+0x2fb>
4200dc24:	48a282        	movi	a8, 0x248
4200dc27:	8e8a      	add.n	a8, a14, a8
4200dc29:	4ca2d2        	movi	a13, 0x24c
4200dc2c:	60a2c2        	movi	a12, 0x260
4200dc2f:	0189      	s32i.n	a8, a1, 0
4200dc31:	01def2        	addmi	a15, a14, 0x100
4200dc34:	deda      	add.n	a13, a14, a13
4200dc36:	ceca      	add.n	a12, a14, a12
4200dc38:	05bd      	mov.n	a11, a5
4200dc3a:	ff83a5        	call8	4200d474 <get_arg$isra$0>
4200dc3d:	0a88      	l32i.n	a8, a10, 0
4200dc3f:	ac6182        	s32i	a8, a1, 0x2b0
4200dc42:	a32182        	l32i	a8, a1, 0x28c
4200dc45:	07ad      	mov.n	a10, a7
4200dc47:	a86182        	s32i	a8, a1, 0x2a0
4200dc4a:	001d46        	j	4200dcc3 <_vfprintf_r+0x37f>
4200dc4d:	b09690        	addx8	a9, a6, a9
4200dc50:	001a86        	j	4200dcbe <_vfprintf_r+0x37a>
4200dc53:	9a29c2        	l32i	a12, a9, 0x268
4200dc56:	fd1c      	movi.n	a13, 31
4200dc58:	02d992        	addmi	a9, a9, 0x200
4200dc5b:	8c4b      	addi.n	a8, a12, 4
4200dc5d:	372db7        	blt	a13, a11, 4200dc98 <_vfprintf_r+0x354>
4200dc60:	db1b      	addi.n	a13, a11, 1
4200dc62:	9761d2        	s32i	a13, a1, 0x25c
4200dc65:	1a6982        	s32i	a8, a9, 104
4200dc68:	8d1c      	movi.n	a13, 24
4200dc6a:	062d87        	blt	a13, a8, 4200dc74 <_vfprintf_r+0x330>
4200dc6d:	192992        	l32i	a9, a9, 100
4200dc70:	000446        	j	4200dc85 <_vfprintf_r+0x341>
4200dc73:	00          	.byte	00
4200dc74:	012dc7        	blt	a13, a12, 4200dc79 <_vfprintf_r+0x335>
4200dc77:	482c      	movi.n	a8, 36
4200dc79:	10c192        	addi	a9, a1, 16
4200dc7c:	02d992        	addmi	a9, a9, 0x200
4200dc7f:	182992        	l32i	a9, a9, 96
4200dc82:	9e6182        	s32i	a8, a1, 0x278
4200dc85:	998a      	add.n	a9, a9, a8
4200dc87:	fcc992        	addi	a9, a9, -4
4200dc8a:	0988      	l32i.n	a8, a9, 0
4200dc8c:	b0bb10        	addx8	a11, a11, a1
4200dc8f:	ac6182        	s32i	a8, a1, 0x2b0
4200dc92:	4b89      	s32i.n	a8, a11, 16
4200dc94:	000ac6        	j	4200dcc3 <_vfprintf_r+0x37f>
4200dc97:	00          	.byte	00
4200dc98:	1a6982        	s32i	a8, a9, 104
4200dc9b:	8b1c      	movi.n	a11, 24
4200dc9d:	072b87        	blt	a11, a8, 4200dca8 <_vfprintf_r+0x364>
4200dca0:	192992        	l32i	a9, a9, 100
4200dca3:	000486        	j	4200dcb9 <_vfprintf_r+0x375>
4200dca6:	c70000        	ee.stf.64.xp	f0, f12, a0, a0
4200dca9:	012b      	addi.n	a0, a1, 2
4200dcab:	482c      	movi.n	a8, 36
4200dcad:	10c192        	addi	a9, a1, 16
4200dcb0:	02d992        	addmi	a9, a9, 0x200
4200dcb3:	182992        	l32i	a9, a9, 96
4200dcb6:	9e6182        	s32i	a8, a1, 0x278
4200dcb9:	998a      	add.n	a9, a9, a8
4200dcbb:	fcc992        	addi	a9, a9, -4
4200dcbe:	0988      	l32i.n	a8, a9, 0
4200dcc0:	ac6182        	s32i	a8, a1, 0x2b0
4200dcc3:	ac2182        	l32i	a8, a1, 0x2b0
4200dcc6:	0a7d      	mov.n	a7, a10
4200dcc8:	e628d6        	bgez	a8, 4200db2e <_vfprintf_r+0x1ea>
4200dccb:	608080        	neg	a8, a8
4200dcce:	ac6182        	s32i	a8, a1, 0x2b0
4200dcd1:	480c      	movi.n	a8, 4
4200dcd3:	007c06        	j	4200dec7 <_vfprintf_r+0x583>
4200dcd6:	10c182        	addi	a8, a1, 16
4200dcd9:	02d882        	addmi	a8, a8, 0x200
4200dcdc:	b92c      	movi.n	a9, 43
4200dcde:	524892        	s8i	a9, a8, 82
4200dce1:	ff9246        	j	4200db2e <_vfprintf_r+0x1ea>
4200dce4:	a82182        	l32i	a8, a1, 0x2a0
4200dce7:	981b      	addi.n	a9, a8, 1
4200dce9:	000882        	l8ui	a8, a8, 0
4200dcec:	a36182        	s32i	a8, a1, 0x28c
4200dcef:	a321b2        	l32i	a11, a1, 0x28c
4200dcf2:	a82c      	movi.n	a8, 42
4200dcf4:	081b87        	beq	a11, a8, 4200dd00 <_vfprintf_r+0x3bc>
4200dcf7:	080c      	movi.n	a8, 0
4200dcf9:	9c0c      	movi.n	a12, 9
4200dcfb:	0047c6        	j	4200de1e <_vfprintf_r+0x4da>
4200dcfe:	820000        	mull	a0, a0, a0
4200dd01:	0ca821        	l32r	a2, 41fd0fa4 <_iram_bss_end+0x1c4eba4>
4200dd04:	829b      	addi.n	a8, a2, 9
4200dd06:	0108      	l32i.n	a0, a1, 0
4200dd08:	d0c8a2        	addi	a10, a8, -48
4200dd0b:	453ba7        	bltu	a11, a10, 4200dd54 <_vfprintf_r+0x410>
4200dd0e:	a821a2        	l32i	a10, a1, 0x2a0
4200dd11:	aa2b      	addi.n	a10, a10, 2
4200dd13:	a361a2        	s32i	a10, a1, 0x28c
4200dd16:	0a0c      	movi.n	a10, 0
4200dd18:	d0c882        	addi	a8, a8, -48
4200dd1b:	a0aaa0        	addx4	a10, a10, a10
4200dd1e:	90aa80        	addx2	a10, a10, a8
4200dd21:	a32182        	l32i	a8, a1, 0x28c
4200dd24:	a321c2        	l32i	a12, a1, 0x28c
4200dd27:	000882        	l8ui	a8, a8, 0
4200dd2a:	cc1b      	addi.n	a12, a12, 1
4200dd2c:	a361c2        	s32i	a12, a1, 0x28c
4200dd2f:	d0c8c2        	addi	a12, a8, -48
4200dd32:	e2bbc7        	bgeu	a11, a12, 4200dd18 <_vfprintf_r+0x3d4>
4200dd35:	4b2c      	movi.n	a11, 36
4200dd37:	0218b7        	beq	a8, a11, 4200dd3d <_vfprintf_r+0x3f9>
4200dd3a:	ff7ac6        	j	4200db29 <_vfprintf_r+0x1e5>
4200dd3d:	082c      	movi.n	a8, 32
4200dd3f:	02a8a7        	bge	a8, a10, 4200dd45 <_vfprintf_r+0x401>
4200dd42:	09fa86        	j	42010530 <_vfprintf_r+0x2bec>
4200dd45:	972182        	l32i	a8, a1, 0x25c
4200dd48:	aa0b      	addi.n	a10, a10, -1
4200dd4a:	10c1e2        	addi	a14, a1, 16
4200dd4d:	132a87        	blt	a10, a8, 4200dd64 <_vfprintf_r+0x420>
4200dd50:	000606        	j	4200dd6c <_vfprintf_r+0x428>
4200dd53:	21a200        	srai	a10, a0, 2
4200dd56:	c71b97        	beq	a11, a9, 4200dd21 <_vfprintf_r+0x3dd>
4200dd59:	10c182        	addi	a8, a1, 16
4200dd5c:	3027a7        	blt	a7, a10, 4200dd90 <_vfprintf_r+0x44c>
4200dd5f:	000cc6        	j	4200dd96 <_vfprintf_r+0x452>
4200dd62:	e00000        	subx4	a0, a0, a0
4200dd65:	b0ea      	add.n	a11, a0, a14
4200dd67:	0e88      	l32i.n	a8, a14, 0
4200dd69:	000686        	j	4200dd87 <_vfprintf_r+0x443>
4200dd6c:	48a282        	movi	a8, 0x248
4200dd6f:	8e8a      	add.n	a8, a14, a8
4200dd71:	4ca2d2        	movi	a13, 0x24c
4200dd74:	60a2c2        	movi	a12, 0x260
4200dd77:	0189      	s32i.n	a8, a1, 0
4200dd79:	01def2        	addmi	a15, a14, 0x100
4200dd7c:	deda      	add.n	a13, a14, a13
4200dd7e:	ceca      	add.n	a12, a14, a12
4200dd80:	05bd      	mov.n	a11, a5
4200dd82:	ff6f25        	call8	4200d474 <get_arg$isra$0>
4200dd85:	0a88      	l32i.n	a8, a10, 0
4200dd87:	a32192        	l32i	a9, a1, 0x28c
4200dd8a:	07cd      	mov.n	a12, a7
4200dd8c:	001c06        	j	4200de00 <_vfprintf_r+0x4bc>
4200dd8f:	868000        	ee.ldf.64.xp	f8, f8, a0, a0
4200dd92:	b0          	.byte	0xb0
4200dd93:	0019c6        	j	4200ddfe <_vfprintf_r+0x4ba>
4200dd96:	fb1c      	movi.n	a11, 31
4200dd98:	352ba7        	blt	a11, a10, 4200ddd1 <_vfprintf_r+0x48d>
4200dd9b:	9a28e2        	l32i	a14, a8, 0x268
4200dd9e:	ba1b      	addi.n	a11, a10, 1
4200dda0:	9761b2        	s32i	a11, a1, 0x25c
4200dda3:	be4b      	addi.n	a11, a14, 4
4200dda5:	9a68b2        	s32i	a11, a8, 0x268
4200dda8:	8f1c      	movi.n	a15, 24
4200ddaa:	062fb7        	blt	a15, a11, 4200ddb4 <_vfprintf_r+0x470>
4200ddad:	992882        	l32i	a8, a8, 0x264
4200ddb0:	000386        	j	4200ddc2 <_vfprintf_r+0x47e>
4200ddb3:	00          	.byte	00
4200ddb4:	012fe7        	blt	a15, a14, 4200ddb9 <_vfprintf_r+0x475>
4200ddb7:	4b2c      	movi.n	a11, 36
4200ddb9:	9a68b2        	s32i	a11, a8, 0x268
4200ddbc:	02d882        	addmi	a8, a8, 0x200
4200ddbf:	182882        	l32i	a8, a8, 96
4200ddc2:	88ba      	add.n	a8, a8, a11
4200ddc4:	fcc882        	addi	a8, a8, -4
4200ddc7:	0888      	l32i.n	a8, a8, 0
4200ddc9:	b0aa10        	addx8	a10, a10, a1
4200ddcc:	4a89      	s32i.n	a8, a10, 16
4200ddce:	000b86        	j	4200de00 <_vfprintf_r+0x4bc>
4200ddd1:	9a28b2        	l32i	a11, a8, 0x268
4200ddd4:	8d1c      	movi.n	a13, 24
4200ddd6:	ab4b      	addi.n	a10, a11, 4
4200ddd8:	9a68a2        	s32i	a10, a8, 0x268
4200dddb:	02d882        	addmi	a8, a8, 0x200
4200ddde:	062da7        	blt	a13, a10, 4200dde8 <_vfprintf_r+0x4a4>
4200dde1:	192882        	l32i	a8, a8, 100
4200dde4:	000446        	j	4200ddf9 <_vfprintf_r+0x4b5>
4200dde7:	00          	.byte	00
4200dde8:	012db7        	blt	a13, a11, 4200dded <_vfprintf_r+0x4a9>
4200ddeb:	4a2c      	movi.n	a10, 36
4200dded:	10c182        	addi	a8, a1, 16
4200ddf0:	02d882        	addmi	a8, a8, 0x200
4200ddf3:	182882        	l32i	a8, a8, 96
4200ddf6:	9e61a2        	s32i	a10, a1, 0x278
4200ddf9:	88aa      	add.n	a8, a8, a10
4200ddfb:	fcc882        	addi	a8, a8, -4
4200ddfe:	0888      	l32i.n	a8, a8, 0
4200de00:	fa7c      	movi.n	a10, -1
4200de02:	5388a0        	max	a8, a8, a10
4200de05:	a26182        	s32i	a8, a1, 0x288
4200de08:	0c7d      	mov.n	a7, a12
4200de0a:	a86192        	s32i	a9, a1, 0x2a0
4200de0d:	ff4746        	j	4200db2e <_vfprintf_r+0x1ea>
4200de10:	a08880        	addx4	a8, a8, a8
4200de13:	9088b0        	addx2	a8, a8, a11
4200de16:	0009b2        	l8ui	a11, a9, 0
4200de19:	991b      	addi.n	a9, a9, 1
4200de1b:	a361b2        	s32i	a11, a1, 0x28c
4200de1e:	a321b2        	l32i	a11, a1, 0x28c
4200de21:	a86192        	s32i	a9, a1, 0x2a0
4200de24:	d0cbb2        	addi	a11, a11, -48
4200de27:	e5bcb7        	bgeu	a12, a11, 4200de10 <_vfprintf_r+0x4cc>
4200de2a:	f97c      	movi.n	a9, -1
4200de2c:	538890        	max	a8, a8, a9
4200de2f:	a26182        	s32i	a8, a1, 0x288
4200de32:	ac2182        	l32i	a8, a1, 0x2b0
4200de35:	ff4206        	j	4200db41 <_vfprintf_r+0x1fd>
4200de38:	820000        	mull	a0, a0, a0
4200de3b:	8680a0        	ee.ldf.64.xp	f8, f8, a10, a0
4200de3e:	0c0021        	l32r	a2, 41fd0e40 <_iram_bss_end+0x1c4ea40>
4200de41:	0c08      	l32i.n	a0, a12, 0
4200de43:	929b      	addi.n	a9, a2, 9
4200de45:	80a321        	l32r	a2, 41fee0d4 <_iram_bss_end+0x1c6bcd4>
4200de48:	a088      	l32i.n	a8, a0, 40
4200de4a:	d0c992        	addi	a9, a9, -48
4200de4d:	908890        	addx2	a8, a8, a9
4200de50:	a82192        	l32i	a9, a1, 0x2a0
4200de53:	000992        	l8ui	a9, a9, 0
4200de56:	a36192        	s32i	a9, a1, 0x28c
4200de59:	a82192        	l32i	a9, a1, 0x2a0
4200de5c:	991b      	addi.n	a9, a9, 1
4200de5e:	a86192        	s32i	a9, a1, 0x2a0
4200de61:	a32192        	l32i	a9, a1, 0x28c
4200de64:	d0c992        	addi	a9, a9, -48
4200de67:	d9bb97        	bgeu	a11, a9, 4200de44 <_vfprintf_r+0x500>
4200de6a:	a321b2        	l32i	a11, a1, 0x28c
4200de6d:	492c      	movi.n	a9, 36
4200de6f:	021b97        	beq	a11, a9, 4200de75 <_vfprintf_r+0x531>
4200de72:	ff32c6        	j	4200db41 <_vfprintf_r+0x1fd>
4200de75:	092c      	movi.n	a9, 32
4200de77:	02a987        	bge	a9, a8, 4200de7d <_vfprintf_r+0x539>
4200de7a:	09ac86        	j	42010530 <_vfprintf_r+0x2bec>
4200de7d:	680b      	addi.n	a6, a8, -1
4200de7f:	140c      	movi.n	a4, 1
4200de81:	ff2a46        	j	4200db2e <_vfprintf_r+0x1ea>
4200de84:	00          	.byte	00
4200de85:	880c      	movi.n	a8, 8
4200de87:	000f06        	j	4200dec7 <_vfprintf_r+0x583>
4200de8a:	a82182        	l32i	a8, a1, 0x2a0
4200de8d:	000892        	l8ui	a9, a8, 0
4200de90:	68a082        	movi	a8, 104
4200de93:	0d9987        	bne	a9, a8, 4200dea4 <_vfprintf_r+0x560>
4200de96:	a82182        	l32i	a8, a1, 0x2a0
4200de99:	881b      	addi.n	a8, a8, 1
4200de9b:	a86182        	s32i	a8, a1, 0x2a0
4200de9e:	00a282        	movi	a8, 0x200
4200dea1:	000886        	j	4200dec7 <_vfprintf_r+0x583>
4200dea4:	084c      	movi.n	a8, 64
4200dea6:	000746        	j	4200dec7 <_vfprintf_r+0x583>
4200dea9:	a82182        	l32i	a8, a1, 0x2a0
4200deac:	000892        	l8ui	a9, a8, 0
4200deaf:	6ca082        	movi	a8, 108
4200deb2:	0a9987        	bne	a9, a8, 4200dec0 <_vfprintf_r+0x57c>
4200deb5:	a82182        	l32i	a8, a1, 0x2a0
4200deb8:	881b      	addi.n	a8, a8, 1
4200deba:	a86182        	s32i	a8, a1, 0x2a0
4200debd:	000106        	j	4200dec5 <_vfprintf_r+0x581>
4200dec0:	081c      	movi.n	a8, 16
4200dec2:	000046        	j	4200dec7 <_vfprintf_r+0x583>
4200dec5:	082c      	movi.n	a8, 32
4200dec7:	203380        	or	a3, a3, a8
4200deca:	ff1806        	j	4200db2e <_vfprintf_r+0x1ea>
4200decd:	972192        	l32i	a9, a1, 0x25c
4200ded0:	10c1e2        	addi	a14, a1, 16
4200ded3:	d4ac      	beqz.n	a4, 4200df04 <_vfprintf_r+0x5c0>
4200ded5:	08a697        	bge	a6, a9, 4200dee1 <_vfprintf_r+0x59d>
4200ded8:	b0e6e0        	addx8	a14, a6, a14
4200dedb:	000e82        	l8ui	a8, a14, 0
4200dede:	000746        	j	4200deff <_vfprintf_r+0x5bb>
4200dee1:	48a282        	movi	a8, 0x248
4200dee4:	8e8a      	add.n	a8, a14, a8
4200dee6:	4ca2d2        	movi	a13, 0x24c
4200dee9:	60a2c2        	movi	a12, 0x260
4200deec:	0189      	s32i.n	a8, a1, 0
4200deee:	01def2        	addmi	a15, a14, 0x100
4200def1:	deda      	add.n	a13, a14, a13
4200def3:	ceca      	add.n	a12, a14, a12
4200def5:	05bd      	mov.n	a11, a5
4200def7:	06ad      	mov.n	a10, a6
4200def9:	ff57a5        	call8	4200d474 <get_arg$isra$0>
4200defc:	000a82        	l8ui	a8, a10, 0
4200deff:	07ad      	mov.n	a10, a7
4200df01:	001f06        	j	4200df81 <_vfprintf_r+0x63d>
4200df04:	a71b      	addi.n	a10, a7, 1
4200df06:	0aa797        	bge	a7, a9, 4200df14 <_vfprintf_r+0x5d0>
4200df09:	b0e6e0        	addx8	a14, a6, a14
4200df0c:	000e82        	l8ui	a8, a14, 0
4200df0f:	001b86        	j	4200df81 <_vfprintf_r+0x63d>
4200df12:	b20000        	mulsh	a0, a0, a0
4200df15:	2e          	.byte	0x2e
4200df16:	1c9a      	add.n	a1, a12, a9
4200df18:	e2fc      	bnez.n	a2, 4200df5a <_vfprintf_r+0x616>
4200df1a:	8b4b02de 	ee.ldf.128.xp	f7, f6, f0, f4, a13, a2
4200df1e:	362c97        	blt	a12, a9, 4200df58 <_vfprintf_r+0x614>
4200df21:	c91b      	addi.n	a12, a9, 1
4200df23:	9761c2        	s32i	a12, a1, 0x25c
4200df26:	1a6e82        	s32i	a8, a14, 104
4200df29:	8c1c      	movi.n	a12, 24
4200df2b:	052c87        	blt	a12, a8, 4200df34 <_vfprintf_r+0x5f0>
4200df2e:	192eb2        	l32i	a11, a14, 100
4200df31:	000406        	j	4200df45 <_vfprintf_r+0x601>
4200df34:	012cb7        	blt	a12, a11, 4200df39 <_vfprintf_r+0x5f5>
4200df37:	482c      	movi.n	a8, 36
4200df39:	10c1b2        	addi	a11, a1, 16
4200df3c:	02dbb2        	addmi	a11, a11, 0x200
4200df3f:	182bb2        	l32i	a11, a11, 96
4200df42:	9e6182        	s32i	a8, a1, 0x278
4200df45:	bb8a      	add.n	a11, a11, a8
4200df47:	fccbb2        	addi	a11, a11, -4
4200df4a:	0b88      	l32i.n	a8, a11, 0
4200df4c:	b09910        	addx8	a9, a9, a1
4200df4f:	4989      	s32i.n	a8, a9, 16
4200df51:	748080        	extui	a8, a8, 0, 8
4200df54:	000a46        	j	4200df81 <_vfprintf_r+0x63d>
4200df57:	00          	.byte	00
4200df58:	1a6e82        	s32i	a8, a14, 104
4200df5b:	891c      	movi.n	a9, 24
4200df5d:	072987        	blt	a9, a8, 4200df68 <_vfprintf_r+0x624>
4200df60:	192e92        	l32i	a9, a14, 100
4200df63:	000486        	j	4200df79 <_vfprintf_r+0x635>
4200df66:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200df69:	0129      	s32i.n	a2, a1, 0
4200df6b:	482c      	movi.n	a8, 36
4200df6d:	10c192        	addi	a9, a1, 16
4200df70:	02d992        	addmi	a9, a9, 0x200
4200df73:	182992        	l32i	a9, a9, 96
4200df76:	9e6182        	s32i	a8, a1, 0x278
4200df79:	998a      	add.n	a9, a9, a8
4200df7b:	fcc992        	addi	a9, a9, -4
4200df7e:	000982        	l8ui	a8, a9, 0
4200df81:	10c192        	addi	a9, a1, 16
4200df84:	01d9b2        	addmi	a11, a9, 0x100
4200df87:	804b82        	s8i	a8, a11, 128
4200df8a:	02d982        	addmi	a8, a9, 0x200
4200df8d:	0b0c      	movi.n	a11, 0
4200df8f:	5248b2        	s8i	a11, a8, 82
4200df92:	080c      	movi.n	a8, 0
4200df94:	a96182        	s32i	a8, a1, 0x2a4
4200df97:	180c      	movi.n	a8, 1
4200df99:	a26182        	s32i	a8, a1, 0x288
4200df9c:	080c      	movi.n	a8, 0
4200df9e:	ab6182        	s32i	a8, a1, 0x2ac
4200dfa1:	0a7d      	mov.n	a7, a10
4200dfa3:	040c      	movi.n	a4, 0
4200dfa5:	050c      	movi.n	a5, 0
4200dfa7:	060c      	movi.n	a6, 0
4200dfa9:	80a182        	movi	a8, 0x180
4200dfac:	069e06        	j	4200fa28 <_vfprintf_r+0x20e4>
4200dfaf:	00          	.byte	00
4200dfb0:	081c00        	lsx	f1, a12, a0
4200dfb3:	203380        	or	a3, a3, a8
4200dfb6:	972182        	l32i	a8, a1, 0x25c
4200dfb9:	10c1e2        	addi	a14, a1, 16
4200dfbc:	02e357        	bbsi	a3, 5, 4200dfc2 <_vfprintf_r+0x67e>
4200dfbf:	002f46        	j	4200e080 <_vfprintf_r+0x73c>
4200dfc2:	f4ac      	beqz.n	a4, 4200dff5 <_vfprintf_r+0x6b1>
4200dfc4:	09a687        	bge	a6, a8, 4200dfd1 <_vfprintf_r+0x68d>
4200dfc7:	b0e6e0        	addx8	a14, a6, a14
4200dfca:	0e58      	l32i.n	a5, a14, 0
4200dfcc:	1e48      	l32i.n	a4, a14, 4
4200dfce:	000786        	j	4200dff0 <_vfprintf_r+0x6ac>
4200dfd1:	48a282        	movi	a8, 0x248
4200dfd4:	8e8a      	add.n	a8, a14, a8
4200dfd6:	4ca2d2        	movi	a13, 0x24c
4200dfd9:	60a2c2        	movi	a12, 0x260
4200dfdc:	05bd      	mov.n	a11, a5
4200dfde:	0189      	s32i.n	a8, a1, 0
4200dfe0:	01def2        	addmi	a15, a14, 0x100
4200dfe3:	deda      	add.n	a13, a14, a13
4200dfe5:	ceca      	add.n	a12, a14, a12
4200dfe7:	06ad      	mov.n	a10, a6
4200dfe9:	ff48a5        	call8	4200d474 <get_arg$isra$0>
4200dfec:	0a58      	l32i.n	a5, a10, 0
4200dfee:	1a48      	l32i.n	a4, a10, 4
4200dff0:	07ad      	mov.n	a10, a7
4200dff2:	00ab46        	j	4200e2a3 <_vfprintf_r+0x95f>
4200dff5:	a71b      	addi.n	a10, a7, 1
4200dff7:	09a787        	bge	a7, a8, 4200e004 <_vfprintf_r+0x6c0>
4200dffa:	b0e6e0        	addx8	a14, a6, a14
4200dffd:	0e58      	l32i.n	a5, a14, 0
4200dfff:	1e48      	l32i.n	a4, a14, 4
4200e001:	00a786        	j	4200e2a3 <_vfprintf_r+0x95f>
4200e004:	9a2eb2        	l32i	a11, a14, 0x268
4200e007:	897c      	movi.n	a9, -8
4200e009:	bb7b      	addi.n	a11, a11, 7
4200e00b:	10bb90        	and	a11, a11, a9
4200e00e:	fc1c      	movi.n	a12, 31
4200e010:	02dee2        	addmi	a14, a14, 0x200
4200e013:	9b8b      	addi.n	a9, a11, 8
4200e015:	3b2c87        	blt	a12, a8, 4200e054 <_vfprintf_r+0x710>
4200e018:	c81b      	addi.n	a12, a8, 1
4200e01a:	9761c2        	s32i	a12, a1, 0x25c
4200e01d:	1a6e92        	s32i	a9, a14, 104
4200e020:	8c1c      	movi.n	a12, 24
4200e022:	062c97        	blt	a12, a9, 4200e02c <_vfprintf_r+0x6e8>
4200e025:	192eb2        	l32i	a11, a14, 100
4200e028:	000446        	j	4200e03d <_vfprintf_r+0x6f9>
4200e02b:	00          	.byte	00
4200e02c:	012cb7        	blt	a12, a11, 4200e031 <_vfprintf_r+0x6ed>
4200e02f:	892c      	movi.n	a9, 40
4200e031:	10c1b2        	addi	a11, a1, 16
4200e034:	02dbb2        	addmi	a11, a11, 0x200
4200e037:	182bb2        	l32i	a11, a11, 96
4200e03a:	9e6192        	s32i	a9, a1, 0x278
4200e03d:	9b9a      	add.n	a9, a11, a9
4200e03f:	f8c992        	addi	a9, a9, -8
4200e042:	0958      	l32i.n	a5, a9, 0
4200e044:	1948      	l32i.n	a4, a9, 4
4200e046:	10c192        	addi	a9, a1, 16
4200e049:	b08890        	addx8	a8, a8, a9
4200e04c:	0859      	s32i.n	a5, a8, 0
4200e04e:	1849      	s32i.n	a4, a8, 4
4200e050:	0093c6        	j	4200e2a3 <_vfprintf_r+0x95f>
4200e053:	00          	.byte	00
4200e054:	1a6e92        	s32i	a9, a14, 104
4200e057:	881c      	movi.n	a8, 24
4200e059:	052897        	blt	a8, a9, 4200e062 <_vfprintf_r+0x71e>
4200e05c:	192e82        	l32i	a8, a14, 100
4200e05f:	000446        	j	4200e074 <_vfprintf_r+0x730>
4200e062:	0228b7        	blt	a8, a11, 4200e068 <_vfprintf_r+0x724>
4200e065:	28a092        	movi	a9, 40
4200e068:	10c182        	addi	a8, a1, 16
4200e06b:	02d882        	addmi	a8, a8, 0x200
4200e06e:	182882        	l32i	a8, a8, 96
4200e071:	9e6192        	s32i	a9, a1, 0x278
4200e074:	889a      	add.n	a8, a8, a9
4200e076:	f8c882        	addi	a8, a8, -8
4200e079:	0858      	l32i.n	a5, a8, 0
4200e07b:	1848      	l32i.n	a4, a8, 4
4200e07d:	008886        	j	4200e2a3 <_vfprintf_r+0x95f>
4200e080:	02e347        	bbsi	a3, 4, 4200e086 <_vfprintf_r+0x742>
4200e083:	002a46        	j	4200e130 <_vfprintf_r+0x7ec>
4200e086:	b4ac      	beqz.n	a4, 4200e0b5 <_vfprintf_r+0x771>
4200e088:	09a687        	bge	a6, a8, 4200e095 <_vfprintf_r+0x751>
4200e08b:	b0e6e0        	addx8	a14, a6, a14
4200e08e:	0e58      	l32i.n	a5, a14, 0
4200e090:	0033c6        	j	4200e163 <_vfprintf_r+0x81f>
4200e093:	820000        	mull	a0, a0, a0
4200e096:	8a48a2        	s8i	a10, a8, 138
4200e099:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200e09d:	60a2c2        	movi	a12, 0x260
4200e0a0:	05bd      	mov.n	a11, a5
4200e0a2:	0189      	s32i.n	a8, a1, 0
4200e0a4:	01def2        	addmi	a15, a14, 0x100
4200e0a7:	deda      	add.n	a13, a14, a13
4200e0a9:	ceca      	add.n	a12, a14, a12
4200e0ab:	06ad      	mov.n	a10, a6
4200e0ad:	ff3c65        	call8	4200d474 <get_arg$isra$0>
4200e0b0:	0a58      	l32i.n	a5, a10, 0
4200e0b2:	002b46        	j	4200e163 <_vfprintf_r+0x81f>
4200e0b5:	a71b      	addi.n	a10, a7, 1
4200e0b7:	09a787        	bge	a7, a8, 4200e0c4 <_vfprintf_r+0x780>
4200e0ba:	b0e6e0        	addx8	a14, a6, a14
4200e0bd:	0e58      	l32i.n	a5, a14, 0
4200e0bf:	007746        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e0c2:	b20000        	mulsh	a0, a0, a0
4200e0c5:	2e          	.byte	0x2e
4200e0c6:	1c9a      	add.n	a1, a12, a9
4200e0c8:	e2fc      	bnez.n	a2, 4200e10a <_vfprintf_r+0x7c6>
4200e0ca:	9b4b02de 	ee.stf.128.xp	f7, f6, f0, f4, a13, a2
4200e0ce:	322c87        	blt	a12, a8, 4200e104 <_vfprintf_r+0x7c0>
4200e0d1:	c81b      	addi.n	a12, a8, 1
4200e0d3:	9761c2        	s32i	a12, a1, 0x25c
4200e0d6:	1a6e92        	s32i	a9, a14, 104
4200e0d9:	8c1c      	movi.n	a12, 24
4200e0db:	052c97        	blt	a12, a9, 4200e0e4 <_vfprintf_r+0x7a0>
4200e0de:	192eb2        	l32i	a11, a14, 100
4200e0e1:	000406        	j	4200e0f5 <_vfprintf_r+0x7b1>
4200e0e4:	012cb7        	blt	a12, a11, 4200e0e9 <_vfprintf_r+0x7a5>
4200e0e7:	492c      	movi.n	a9, 36
4200e0e9:	10c1b2        	addi	a11, a1, 16
4200e0ec:	02dbb2        	addmi	a11, a11, 0x200
4200e0ef:	182bb2        	l32i	a11, a11, 96
4200e0f2:	9e6192        	s32i	a9, a1, 0x278
4200e0f5:	bb9a      	add.n	a11, a11, a9
4200e0f7:	fccbb2        	addi	a11, a11, -4
4200e0fa:	0b58      	l32i.n	a5, a11, 0
4200e0fc:	b08810        	addx8	a8, a8, a1
4200e0ff:	4859      	s32i.n	a5, a8, 16
4200e101:	0066c6        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e104:	1a6e92        	s32i	a9, a14, 104
4200e107:	881c      	movi.n	a8, 24
4200e109:	072897        	blt	a8, a9, 4200e114 <_vfprintf_r+0x7d0>
4200e10c:	192e82        	l32i	a8, a14, 100
4200e10f:	000486        	j	4200e125 <_vfprintf_r+0x7e1>
4200e112:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200e115:	0128      	l32i.n	a2, a1, 0
4200e117:	492c      	movi.n	a9, 36
4200e119:	10c182        	addi	a8, a1, 16
4200e11c:	02d882        	addmi	a8, a8, 0x200
4200e11f:	182882        	l32i	a8, a8, 96
4200e122:	9e6192        	s32i	a9, a1, 0x278
4200e125:	889a      	add.n	a8, a8, a9
4200e127:	fcc882        	addi	a8, a8, -4
4200e12a:	0858      	l32i.n	a5, a8, 0
4200e12c:	005c06        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e12f:	00          	.byte	00
4200e130:	02e367        	bbsi	a3, 6, 4200e136 <_vfprintf_r+0x7f2>
4200e133:	002c46        	j	4200e1e8 <_vfprintf_r+0x8a4>
4200e136:	e4ac      	beqz.n	a4, 4200e168 <_vfprintf_r+0x824>
4200e138:	09a687        	bge	a6, a8, 4200e145 <_vfprintf_r+0x801>
4200e13b:	b0e6e0        	addx8	a14, a6, a14
4200e13e:	009e52        	l16si	a5, a14, 0
4200e141:	000786        	j	4200e163 <_vfprintf_r+0x81f>
4200e144:	a28200        	muluh	a8, a2, a0
4200e147:	8a48      	l32i.n	a4, a10, 32
4200e149:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200e14d:	60a2c2        	movi	a12, 0x260
4200e150:	05bd      	mov.n	a11, a5
4200e152:	0189      	s32i.n	a8, a1, 0
4200e154:	01def2        	addmi	a15, a14, 0x100
4200e157:	deda      	add.n	a13, a14, a13
4200e159:	ceca      	add.n	a12, a14, a12
4200e15b:	06ad      	mov.n	a10, a6
4200e15d:	ff3165        	call8	4200d474 <get_arg$isra$0>
4200e160:	009a52        	l16si	a5, a10, 0
4200e163:	07ad      	mov.n	a10, a7
4200e165:	004dc6        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e168:	a71b      	addi.n	a10, a7, 1
4200e16a:	08a787        	bge	a7, a8, 4200e176 <_vfprintf_r+0x832>
4200e16d:	b0e6e0        	addx8	a14, a6, a14
4200e170:	009e52        	l16si	a5, a14, 0
4200e173:	004a46        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e176:	9a2eb2        	l32i	a11, a14, 0x268
4200e179:	fc1c      	movi.n	a12, 31
4200e17b:	02dee2        	addmi	a14, a14, 0x200
4200e17e:	9b4b      	addi.n	a9, a11, 4
4200e180:	382c87        	blt	a12, a8, 4200e1bc <_vfprintf_r+0x878>
4200e183:	c81b      	addi.n	a12, a8, 1
4200e185:	9761c2        	s32i	a12, a1, 0x25c
4200e188:	1a6e92        	s32i	a9, a14, 104
4200e18b:	8c1c      	movi.n	a12, 24
4200e18d:	072c97        	blt	a12, a9, 4200e198 <_vfprintf_r+0x854>
4200e190:	192eb2        	l32i	a11, a14, 100
4200e193:	000486        	j	4200e1a9 <_vfprintf_r+0x865>
4200e196:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200e199:	012c      	movi.n	a1, 32
4200e19b:	492c      	movi.n	a9, 36
4200e19d:	10c1b2        	addi	a11, a1, 16
4200e1a0:	02dbb2        	addmi	a11, a11, 0x200
4200e1a3:	182bb2        	l32i	a11, a11, 96
4200e1a6:	9e6192        	s32i	a9, a1, 0x278
4200e1a9:	bb9a      	add.n	a11, a11, a9
4200e1ab:	fccbb2        	addi	a11, a11, -4
4200e1ae:	0b58      	l32i.n	a5, a11, 0
4200e1b0:	b08810        	addx8	a8, a8, a1
4200e1b3:	4859      	s32i.n	a5, a8, 16
4200e1b5:	235580        	sext	a5, a5, 15
4200e1b8:	003906        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e1bb:	00          	.byte	00
4200e1bc:	1a6e92        	s32i	a9, a14, 104
4200e1bf:	881c      	movi.n	a8, 24
4200e1c1:	072897        	blt	a8, a9, 4200e1cc <_vfprintf_r+0x888>
4200e1c4:	192e82        	l32i	a8, a14, 100
4200e1c7:	000486        	j	4200e1dd <_vfprintf_r+0x899>
4200e1ca:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200e1cd:	0128      	l32i.n	a2, a1, 0
4200e1cf:	492c      	movi.n	a9, 36
4200e1d1:	10c182        	addi	a8, a1, 16
4200e1d4:	02d882        	addmi	a8, a8, 0x200
4200e1d7:	182882        	l32i	a8, a8, 96
4200e1da:	9e6192        	s32i	a9, a1, 0x278
4200e1dd:	889a      	add.n	a8, a8, a9
4200e1df:	fcc882        	addi	a8, a8, -4
4200e1e2:	009852        	l16si	a5, a8, 0
4200e1e5:	002dc6        	j	4200e2a0 <_vfprintf_r+0x95c>
4200e1e8:	02e397        	bbsi	a3, 9, 4200e1ee <_vfprintf_r+0x8aa>
4200e1eb:	002e46        	j	4200e2a8 <_vfprintf_r+0x964>
4200e1ee:	e4ac      	beqz.n	a4, 4200e220 <_vfprintf_r+0x8dc>
4200e1f0:	09a687        	bge	a6, a8, 4200e1fd <_vfprintf_r+0x8b9>
4200e1f3:	b0e6e0        	addx8	a14, a6, a14
4200e1f6:	000e52        	l8ui	a5, a14, 0
4200e1f9:	000786        	j	4200e21b <_vfprintf_r+0x8d7>
4200e1fc:	a28200        	muluh	a8, a2, a0
4200e1ff:	8a48      	l32i.n	a4, a10, 32
4200e201:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200e205:	60a2c2        	movi	a12, 0x260
4200e208:	05bd      	mov.n	a11, a5
4200e20a:	0189      	s32i.n	a8, a1, 0
4200e20c:	01def2        	addmi	a15, a14, 0x100
4200e20f:	deda      	add.n	a13, a14, a13
4200e211:	ceca      	add.n	a12, a14, a12
4200e213:	06ad      	mov.n	a10, a6
4200e215:	ff25e5        	call8	4200d474 <get_arg$isra$0>
4200e218:	000a52        	l8ui	a5, a10, 0
4200e21b:	07ad      	mov.n	a10, a7
4200e21d:	001f06        	j	4200e29d <_vfprintf_r+0x959>
4200e220:	a71b      	addi.n	a10, a7, 1
4200e222:	0aa787        	bge	a7, a8, 4200e230 <_vfprintf_r+0x8ec>
4200e225:	b0e6e0        	addx8	a14, a6, a14
4200e228:	000e52        	l8ui	a5, a14, 0
4200e22b:	001b86        	j	4200e29d <_vfprintf_r+0x959>
4200e22e:	b20000        	mulsh	a0, a0, a0
4200e231:	2e          	.byte	0x2e
4200e232:	1c9a      	add.n	a1, a12, a9
4200e234:	e2fc      	bnez.n	a2, 4200e276 <_vfprintf_r+0x932>
4200e236:	9b4b02de 	ee.stf.128.xp	f7, f6, f0, f4, a13, a2
4200e23a:	362c87        	blt	a12, a8, 4200e274 <_vfprintf_r+0x930>
4200e23d:	c81b      	addi.n	a12, a8, 1
4200e23f:	9761c2        	s32i	a12, a1, 0x25c
4200e242:	1a6e92        	s32i	a9, a14, 104
4200e245:	8c1c      	movi.n	a12, 24
4200e247:	052c97        	blt	a12, a9, 4200e250 <_vfprintf_r+0x90c>
4200e24a:	192eb2        	l32i	a11, a14, 100
4200e24d:	000406        	j	4200e261 <_vfprintf_r+0x91d>
4200e250:	012cb7        	blt	a12, a11, 4200e255 <_vfprintf_r+0x911>
4200e253:	492c      	movi.n	a9, 36
4200e255:	10c1b2        	addi	a11, a1, 16
4200e258:	02dbb2        	addmi	a11, a11, 0x200
4200e25b:	182bb2        	l32i	a11, a11, 96
4200e25e:	9e6192        	s32i	a9, a1, 0x278
4200e261:	bb9a      	add.n	a11, a11, a9
4200e263:	fccbb2        	addi	a11, a11, -4
4200e266:	0b58      	l32i.n	a5, a11, 0
4200e268:	b08810        	addx8	a8, a8, a1
4200e26b:	4859      	s32i.n	a5, a8, 16
4200e26d:	745050        	extui	a5, a5, 0, 8
4200e270:	000a46        	j	4200e29d <_vfprintf_r+0x959>
4200e273:	00          	.byte	00
4200e274:	1a6e92        	s32i	a9, a14, 104
4200e277:	881c      	movi.n	a8, 24
4200e279:	072897        	blt	a8, a9, 4200e284 <_vfprintf_r+0x940>
4200e27c:	192e82        	l32i	a8, a14, 100
4200e27f:	000486        	j	4200e295 <_vfprintf_r+0x951>
4200e282:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200e285:	0128      	l32i.n	a2, a1, 0
4200e287:	492c      	movi.n	a9, 36
4200e289:	10c182        	addi	a8, a1, 16
4200e28c:	02d882        	addmi	a8, a8, 0x200
4200e28f:	182882        	l32i	a8, a8, 96
4200e292:	9e6192        	s32i	a9, a1, 0x278
4200e295:	889a      	add.n	a8, a8, a9
4200e297:	fcc882        	addi	a8, a8, -4
4200e29a:	000852        	l8ui	a5, a8, 0
4200e29d:	235500        	sext	a5, a5, 7
4200e2a0:	314f50        	srai	a4, a5, 31
4200e2a3:	0a7d      	mov.n	a7, a10
4200e2a5:	002a06        	j	4200e351 <_vfprintf_r+0xa0d>
4200e2a8:	c4ac      	beqz.n	a4, 4200e2d8 <_vfprintf_r+0x994>
4200e2aa:	07a687        	bge	a6, a8, 4200e2b5 <_vfprintf_r+0x971>
4200e2ad:	b0e6e0        	addx8	a14, a6, a14
4200e2b0:	0e58      	l32i.n	a5, a14, 0
4200e2b2:	000706        	j	4200e2d2 <_vfprintf_r+0x98e>
4200e2b5:	48a282        	movi	a8, 0x248
4200e2b8:	8e8a      	add.n	a8, a14, a8
4200e2ba:	4ca2d2        	movi	a13, 0x24c
4200e2bd:	60a2c2        	movi	a12, 0x260
4200e2c0:	05bd      	mov.n	a11, a5
4200e2c2:	0189      	s32i.n	a8, a1, 0
4200e2c4:	01def2        	addmi	a15, a14, 0x100
4200e2c7:	deda      	add.n	a13, a14, a13
4200e2c9:	ceca      	add.n	a12, a14, a12
4200e2cb:	06ad      	mov.n	a10, a6
4200e2cd:	ff1a65        	call8	4200d474 <get_arg$isra$0>
4200e2d0:	0a58      	l32i.n	a5, a10, 0
4200e2d2:	079d      	mov.n	a9, a7
4200e2d4:	001d06        	j	4200e34c <_vfprintf_r+0xa08>
4200e2d7:	971b00        	ee.stf.64.xp	f1, f9, a0, a11
4200e2da:	07a787        	bge	a7, a8, 4200e2e5 <_vfprintf_r+0x9a1>
4200e2dd:	b0e6e0        	addx8	a14, a6, a14
4200e2e0:	0e58      	l32i.n	a5, a14, 0
4200e2e2:	001986        	j	4200e34c <_vfprintf_r+0xa08>
4200e2e5:	9a2eb2        	l32i	a11, a14, 0x268
4200e2e8:	fc1c      	movi.n	a12, 31
4200e2ea:	02dee2        	addmi	a14, a14, 0x200
4200e2ed:	ab4b      	addi.n	a10, a11, 4
4200e2ef:	322c87        	blt	a12, a8, 4200e325 <_vfprintf_r+0x9e1>
4200e2f2:	c81b      	addi.n	a12, a8, 1
4200e2f4:	9761c2        	s32i	a12, a1, 0x25c
4200e2f7:	1a6ea2        	s32i	a10, a14, 104
4200e2fa:	8c1c      	movi.n	a12, 24
4200e2fc:	052ca7        	blt	a12, a10, 4200e305 <_vfprintf_r+0x9c1>
4200e2ff:	192eb2        	l32i	a11, a14, 100
4200e302:	000406        	j	4200e316 <_vfprintf_r+0x9d2>
4200e305:	012cb7        	blt	a12, a11, 4200e30a <_vfprintf_r+0x9c6>
4200e308:	4a2c      	movi.n	a10, 36
4200e30a:	10c1b2        	addi	a11, a1, 16
4200e30d:	02dbb2        	addmi	a11, a11, 0x200
4200e310:	182bb2        	l32i	a11, a11, 96
4200e313:	9e61a2        	s32i	a10, a1, 0x278
4200e316:	bbaa      	add.n	a11, a11, a10
4200e318:	fccbb2        	addi	a11, a11, -4
4200e31b:	0b58      	l32i.n	a5, a11, 0
4200e31d:	b08810        	addx8	a8, a8, a1
4200e320:	4859      	s32i.n	a5, a8, 16
4200e322:	000986        	j	4200e34c <_vfprintf_r+0xa08>
4200e325:	1a6ea2        	s32i	a10, a14, 104
4200e328:	881c      	movi.n	a8, 24
4200e32a:	0628a7        	blt	a8, a10, 4200e334 <_vfprintf_r+0x9f0>
4200e32d:	192e82        	l32i	a8, a14, 100
4200e330:	000446        	j	4200e345 <_vfprintf_r+0xa01>
4200e333:	00          	.byte	00
4200e334:	0128b7        	blt	a8, a11, 4200e339 <_vfprintf_r+0x9f5>
4200e337:	4a2c      	movi.n	a10, 36
4200e339:	10c182        	addi	a8, a1, 16
4200e33c:	02d882        	addmi	a8, a8, 0x200
4200e33f:	182882        	l32i	a8, a8, 96
4200e342:	9e61a2        	s32i	a10, a1, 0x278
4200e345:	88aa      	add.n	a8, a8, a10
4200e347:	fcc882        	addi	a8, a8, -4
4200e34a:	0858      	l32i.n	a5, a8, 0
4200e34c:	314f50        	srai	a4, a5, 31
4200e34f:	097d      	mov.n	a7, a9
4200e351:	002496        	bltz	a4, 4200e357 <_vfprintf_r+0xa13>
4200e354:	088106        	j	4201055c <_vfprintf_r+0x2c18>
4200e357:	604040        	neg	a4, a4
4200e35a:	002516        	beqz	a5, 4200e360 <_vfprintf_r+0xa1c>
4200e35d:	ffc442        	addi	a4, a4, -1
4200e360:	605050        	neg	a5, a5
4200e363:	d82c      	movi.n	a8, 45
4200e365:	190c      	movi.n	a9, 1
4200e367:	052d46        	j	4200f820 <_vfprintf_r+0x1edc>
4200e36a:	972182        	l32i	a8, a1, 0x25c
4200e36d:	10c1e2        	addi	a14, a1, 16
4200e370:	44bc      	beqz.n	a4, 4200e3a8 <_vfprintf_r+0xa64>
4200e372:	0fa687        	bge	a6, a8, 4200e385 <_vfprintf_r+0xa41>
4200e375:	b0e6e0        	addx8	a14, a6, a14
4200e378:	0e88      	l32i.n	a8, a14, 0
4200e37a:	1e98      	l32i.n	a9, a14, 4
4200e37c:	a66182        	s32i	a8, a1, 0x298
4200e37f:	a76192        	s32i	a9, a1, 0x29c
4200e382:	002d06        	j	4200e43a <_vfprintf_r+0xaf6>
4200e385:	48a282        	movi	a8, 0x248
4200e388:	8e8a      	add.n	a8, a14, a8
4200e38a:	4ca2d2        	movi	a13, 0x24c
4200e38d:	60a2c2        	movi	a12, 0x260
4200e390:	0189      	s32i.n	a8, a1, 0
4200e392:	01def2        	addmi	a15, a14, 0x100
4200e395:	deda      	add.n	a13, a14, a13
4200e397:	ceca      	add.n	a12, a14, a12
4200e399:	05bd      	mov.n	a11, a5
4200e39b:	06ad      	mov.n	a10, a6
4200e39d:	ff0d65        	call8	4200d474 <get_arg$isra$0>
4200e3a0:	0a88      	l32i.n	a8, a10, 0
4200e3a2:	1a98      	l32i.n	a9, a10, 4
4200e3a4:	fff506        	j	4200e37c <_vfprintf_r+0xa38>
4200e3a7:	b71b00        	ee.stf.64.xp	f1, f11, a0, a11
4200e3aa:	0aa787        	bge	a7, a8, 4200e3b8 <_vfprintf_r+0xa74>
4200e3ad:	b0e6e0        	addx8	a14, a6, a14
4200e3b0:	0e88      	l32i.n	a8, a14, 0
4200e3b2:	1e98      	l32i.n	a9, a14, 4
4200e3b4:	001e86        	j	4200e432 <_vfprintf_r+0xaee>
4200e3b7:	00          	.byte	00
4200e3b8:	9a2ea2        	l32i	a10, a14, 0x268
4200e3bb:	897c      	movi.n	a9, -8
4200e3bd:	aa7b      	addi.n	a10, a10, 7
4200e3bf:	10aa90        	and	a10, a10, a9
4200e3c2:	fc1c      	movi.n	a12, 31
4200e3c4:	02dee2        	addmi	a14, a14, 0x200
4200e3c7:	9a8b      	addi.n	a9, a10, 8
4200e3c9:	3c2c87        	blt	a12, a8, 4200e409 <_vfprintf_r+0xac5>
4200e3cc:	c81b      	addi.n	a12, a8, 1
4200e3ce:	9761c2        	s32i	a12, a1, 0x25c
4200e3d1:	1a6e92        	s32i	a9, a14, 104
4200e3d4:	8c1c      	movi.n	a12, 24
4200e3d6:	052c97        	blt	a12, a9, 4200e3df <_vfprintf_r+0xa9b>
4200e3d9:	192ea2        	l32i	a10, a14, 100
4200e3dc:	000406        	j	4200e3f0 <_vfprintf_r+0xaac>
4200e3df:	012ca7        	blt	a12, a10, 4200e3e4 <_vfprintf_r+0xaa0>
4200e3e2:	892c      	movi.n	a9, 40
4200e3e4:	10c1a2        	addi	a10, a1, 16
4200e3e7:	02daa2        	addmi	a10, a10, 0x200
4200e3ea:	182aa2        	l32i	a10, a10, 96
4200e3ed:	9e6192        	s32i	a9, a1, 0x278
4200e3f0:	aa9a      	add.n	a10, a10, a9
4200e3f2:	f8caa2        	addi	a10, a10, -8
4200e3f5:	0ac8      	l32i.n	a12, a10, 0
4200e3f7:	1ad8      	l32i.n	a13, a10, 4
4200e3f9:	b08810        	addx8	a8, a8, a1
4200e3fc:	a661c2        	s32i	a12, a1, 0x298
4200e3ff:	a761d2        	s32i	a13, a1, 0x29c
4200e402:	48c9      	s32i.n	a12, a8, 16
4200e404:	58d9      	s32i.n	a13, a8, 20
4200e406:	000b86        	j	4200e438 <_vfprintf_r+0xaf4>
4200e409:	1a6e92        	s32i	a9, a14, 104
4200e40c:	881c      	movi.n	a8, 24
4200e40e:	062897        	blt	a8, a9, 4200e418 <_vfprintf_r+0xad4>
4200e411:	192e82        	l32i	a8, a14, 100
4200e414:	000446        	j	4200e429 <_vfprintf_r+0xae5>
4200e417:	00          	.byte	00
4200e418:	0128a7        	blt	a8, a10, 4200e41d <_vfprintf_r+0xad9>
4200e41b:	892c      	movi.n	a9, 40
4200e41d:	10c182        	addi	a8, a1, 16
4200e420:	02d882        	addmi	a8, a8, 0x200
4200e423:	182882        	l32i	a8, a8, 96
4200e426:	9e6192        	s32i	a9, a1, 0x278
4200e429:	889a      	add.n	a8, a8, a9
4200e42b:	f8c882        	addi	a8, a8, -8
4200e42e:	1898      	l32i.n	a9, a8, 4
4200e430:	0888      	l32i.n	a8, a8, 0
4200e432:	a66182        	s32i	a8, a1, 0x298
4200e435:	a76192        	s32i	a9, a1, 0x29c
4200e438:	0b7d      	mov.n	a7, a11
4200e43a:	a62182        	l32i	a8, a1, 0x298
4200e43d:	caa1d1        	l32r	a13, 42000ec4 <_stext+0xea4> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
4200e440:	b46182        	s32i	a8, a1, 0x2d0
4200e443:	a72182        	l32i	a8, a1, 0x29c
4200e446:	fc7c      	movi.n	a12, -1
4200e448:	888a      	add.n	a8, a8, a8
4200e44a:	418180        	srli	a8, a8, 1
4200e44d:	b56182        	s32i	a8, a1, 0x2d4
4200e450:	d0a282        	movi	a8, 0x2d0
4200e453:	881a      	add.n	a8, a8, a1
4200e455:	0028a2        	l32i	a10, a8, 0
4200e458:	18b8      	l32i.n	a11, a8, 4
4200e45a:	ca9b81        	l32r	a8, 42000ec8 <_stext+0xea8> (4000258c <__unorddf2>)
4200e45d:	0008e0        	callx8	a8
4200e460:	8adc      	bnez.n	a10, 4200e47c <_vfprintf_r+0xb38>
4200e462:	d0a282        	movi	a8, 0x2d0
4200e465:	881a      	add.n	a8, a8, a1
4200e467:	ca97d1        	l32r	a13, 42000ec4 <_stext+0xea4> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
4200e46a:	0028a2        	l32i	a10, a8, 0
4200e46d:	0128b2        	l32i	a11, a8, 4
4200e470:	ffafc2        	movi	a12, -1
4200e473:	ca9681        	l32r	a8, 42000ecc <_stext+0xeac> (400023b8 <__ledf2>)
4200e476:	0008e0        	callx8	a8
4200e479:	1c1ae6        	bgei	a10, 1, 4200e499 <_vfprintf_r+0xb55>
4200e47c:	98a282        	movi	a8, 0x298
4200e47f:	881a      	add.n	a8, a8, a1
4200e481:	08c8      	l32i.n	a12, a8, 0
4200e483:	18d8      	l32i.n	a13, a8, 4
4200e485:	0cad      	mov.n	a10, a12
4200e487:	20bdd0        	or	a11, a13, a13
4200e48a:	ca8f81        	l32r	a8, 42000ec8 <_stext+0xea8> (4000258c <__unorddf2>)
4200e48d:	0008e0        	callx8	a8
4200e490:	075a16        	beqz	a10, 4200e509 <_vfprintf_r+0xbc5>
4200e493:	000e06        	j	4200e4cf <_vfprintf_r+0xb8b>
4200e496:	000000        	ill
4200e499:	98a282        	movi	a8, 0x298
4200e49c:	881a      	add.n	a8, a8, a1
4200e49e:	08a8      	l32i.n	a10, a8, 0
4200e4a0:	18b8      	l32i.n	a11, a8, 4
4200e4a2:	0c0c      	movi.n	a12, 0
4200e4a4:	0d0c      	movi.n	a13, 0
4200e4a6:	ca8a81        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
4200e4a9:	0008e0        	callx8	a8
4200e4ac:	00aad6        	bgez	a10, 4200e4ba <_vfprintf_r+0xb76>
4200e4af:	10c182        	addi	a8, a1, 16
4200e4b2:	02d882        	addmi	a8, a8, 0x200
4200e4b5:	d92c      	movi.n	a9, 45
4200e4b7:	524892        	s8i	a9, a8, 82
4200e4ba:	ca7891        	l32r	a9, 42000e9c <_stext+0xe7c> (3c0286e8 <blanks$1+0x14>)
4200e4bd:	784c      	movi.n	a8, 71
4200e4bf:	9f6192        	s32i	a9, a1, 0x27c
4200e4c2:	a32192        	l32i	a9, a1, 0x28c
4200e4c5:	2b2897        	blt	a8, a9, 4200e4f4 <_vfprintf_r+0xbb0>
4200e4c8:	ca7481        	l32r	a8, 42000e98 <_stext+0xe78> (3c0286e4 <blanks$1+0x10>)
4200e4cb:	000886        	j	4200e4f1 <_vfprintf_r+0xbad>
4200e4ce:	218200        	srai	a8, a0, 2
4200e4d1:	a8d6a7        	bbs	a6, a10, 4200e47d <_vfprintf_r+0xb39>
4200e4d4:	c18200        	mul16u	a8, a2, a0
4200e4d7:	10          	.byte	0x10
4200e4d8:	02d882        	addmi	a8, a8, 0x200
4200e4db:	d92c      	movi.n	a9, 45
4200e4dd:	524892        	s8i	a9, a8, 82
4200e4e0:	ca7191        	l32r	a9, 42000ea4 <_stext+0xe84> (3c0286f0 <blanks$1+0x1c>)
4200e4e3:	784c      	movi.n	a8, 71
4200e4e5:	9f6192        	s32i	a9, a1, 0x27c
4200e4e8:	a32192        	l32i	a9, a1, 0x28c
4200e4eb:	052897        	blt	a8, a9, 4200e4f4 <_vfprintf_r+0xbb0>
4200e4ee:	ca6c81        	l32r	a8, 42000ea0 <_stext+0xe80> (3c0286ec <blanks$1+0x18>)
4200e4f1:	9f6182        	s32i	a8, a1, 0x27c
4200e4f4:	7faf82        	movi	a8, -129
4200e4f7:	103380        	and	a3, a3, a8
4200e4fa:	080c      	movi.n	a8, 0
4200e4fc:	a96182        	s32i	a8, a1, 0x2a4
4200e4ff:	380c      	movi.n	a8, 3
4200e501:	a26182        	s32i	a8, a1, 0x288
4200e504:	054a86        	j	4200fa32 <_vfprintf_r+0x20ee>
4200e507:	00          	.byte	00
4200e508:	219200        	srai	a9, a0, 2
4200e50b:	af82a3        	lsip	f10, a2, 0x2bc
4200e50e:	104980df 	ee.vmulas.s16.qacc.ld.ip.qup	q1, a13, 0, q6, q0, q4, q1
4200e512:	184c      	movi.n	a8, 65
4200e514:	5d9487        	bne	a4, a8, 4200e575 <_vfprintf_r+0xc31>
4200e517:	10c182        	addi	a8, a1, 16
4200e51a:	02d892        	addmi	a9, a8, 0x200
4200e51d:	0a3c      	movi.n	a10, 48
4200e51f:	a321b2        	l32i	a11, a1, 0x28c
4200e522:	5049a2        	s8i	a10, a9, 80
4200e525:	61a0a2        	movi	a10, 97
4200e528:	895c      	movi.n	a9, 88
4200e52a:	029ba7        	bne	a11, a10, 4200e530 <_vfprintf_r+0xbec>
4200e52d:	78a092        	movi	a9, 120
4200e530:	02d8a2        	addmi	a10, a8, 0x200
4200e533:	514a92        	s8i	a9, a10, 81
4200e536:	0a0c      	movi.n	a10, 0
4200e538:	a961a2        	s32i	a10, a1, 0x2a4
4200e53b:	80a1a2        	movi	a10, 0x180
4200e53e:	88aa      	add.n	a8, a8, a10
4200e540:	290c      	movi.n	a9, 2
4200e542:	9f6182        	s32i	a8, a1, 0x27c
4200e545:	a22182        	l32i	a8, a1, 0x288
4200e548:	203390        	or	a3, a3, a9
4200e54b:	63a092        	movi	a9, 99
4200e54e:	53a987        	bge	a9, a8, 4200e5a5 <_vfprintf_r+0xc61>
4200e551:	a121a2        	l32i	a10, a1, 0x284
4200e554:	b81b      	addi.n	a11, a8, 1
4200e556:	ca3f81        	l32r	a8, 42000e54 <_stext+0xe34> (4037fee8 <_malloc_r>)
4200e559:	0008e0        	callx8	a8
4200e55c:	9f61a2        	s32i	a10, a1, 0x27c
4200e55f:	9aec      	bnez.n	a10, 4200e58c <_vfprintf_r+0xc48>
4200e561:	a02182        	l32i	a8, a1, 0x280
4200e564:	094c      	movi.n	a9, 64
4200e566:	061882        	l16ui	a8, a8, 12
4200e569:	208890        	or	a8, a8, a9
4200e56c:	a02192        	l32i	a9, a1, 0x280
4200e56f:	065982        	s16i	a8, a9, 12
4200e572:	07ee86        	j	42010530 <_vfprintf_r+0x2bec>
4200e575:	a22182        	l32i	a8, a1, 0x288
4200e578:	160826        	beqi	a8, -1, 4200e592 <_vfprintf_r+0xc4e>
4200e57b:	18ec      	bnez.n	a8, 4200e5a0 <_vfprintf_r+0xc5c>
4200e57d:	b9c482        	addi	a8, a4, -71
4200e580:	c8dc      	bnez.n	a8, 4200e5a0 <_vfprintf_r+0xc5c>
4200e582:	a96182        	s32i	a8, a1, 0x2a4
4200e585:	180c      	movi.n	a8, 1
4200e587:	000386        	j	4200e599 <_vfprintf_r+0xc55>
4200e58a:	820000        	mull	a0, a0, a0
4200e58d:	c69f21        	l32r	a2, 4200000c <_iram_bss_end+0x1c7dc0c>
4200e590:	0c0003        	lsi	f0, a0, 48
4200e593:	8208      	l32i.n	a0, a2, 32
4200e595:	0ca961        	l32r	a6, 41fd183c <_iram_bss_end+0x1c4f43c>
4200e598:	8268      	l32i.n	a6, a2, 32
4200e59a:	46a261        	l32r	a6, 41fe0024 <_iram_bss_end+0x1c5dc24>
4200e59d:	000001        	l32r	a0, 41fce5a0 <_iram_bss_end+0x1c4c1a0>
4200e5a0:	080c      	movi.n	a8, 0
4200e5a2:	a96182        	s32i	a8, a1, 0x2a4
4200e5a5:	00a182        	movi	a8, 0x100
4200e5a8:	208380        	or	a8, a3, a8
4200e5ab:	af6182        	s32i	a8, a1, 0x2bc
4200e5ae:	a72182        	l32i	a8, a1, 0x29c
4200e5b1:	0188d6        	bgez	a8, 4200e5cd <_vfprintf_r+0xc89>
4200e5b4:	a62182        	l32i	a8, a1, 0x298
4200e5b7:	a72192        	l32i	a9, a1, 0x29c
4200e5ba:	b26182        	s32i	a8, a1, 0x2c8
4200e5bd:	f87c      	movi.n	a8, -1
4200e5bf:	018810        	slli	a8, a8, 31
4200e5c2:	308980        	xor	a8, a9, a8
4200e5c5:	b36182        	s32i	a8, a1, 0x2cc
4200e5c8:	d82c      	movi.n	a8, 45
4200e5ca:	000406        	j	4200e5de <_vfprintf_r+0xc9a>
4200e5cd:	98a282        	movi	a8, 0x298
4200e5d0:	881a      	add.n	a8, a8, a1
4200e5d2:	1898      	l32i.n	a9, a8, 4
4200e5d4:	0888      	l32i.n	a8, a8, 0
4200e5d6:	b36192        	s32i	a9, a1, 0x2cc
4200e5d9:	b26182        	s32i	a8, a1, 0x2c8
4200e5dc:	080c      	movi.n	a8, 0
4200e5de:	b96182        	s32i	a8, a1, 0x2e4
4200e5e1:	184c      	movi.n	a8, 65
4200e5e3:	021487        	beq	a4, a8, 4200e5e9 <_vfprintf_r+0xca5>
4200e5e6:	005e06        	j	4200e762 <_vfprintf_r+0xe1e>
4200e5e9:	c8a282        	movi	a8, 0x2c8
4200e5ec:	881a      	add.n	a8, a8, a1
4200e5ee:	08a8      	l32i.n	a10, a8, 0
4200e5f0:	18b8      	l32i.n	a11, a8, 4
4200e5f2:	54a2c2        	movi	a12, 0x254
4200e5f5:	c1ca      	add.n	a12, a1, a12
4200e5f7:	201110        	or	a1, a1, a1
4200e5fa:	043625        	call8	4201295c <frexp>
4200e5fd:	ffa0d2        	movi	a13, 255
4200e600:	00a0c2        	movi	a12, 0
4200e603:	01dda0        	slli	a13, a13, 22
4200e606:	ca3381        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
4200e609:	0008e0        	callx8	a8
4200e60c:	a461a2        	s32i	a10, a1, 0x290
4200e60f:	a561b2        	s32i	a11, a1, 0x294
4200e612:	0c0c      	movi.n	a12, 0
4200e614:	00a0d2        	movi	a13, 0
4200e617:	ca3081        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
4200e61a:	0008e0        	callx8	a8
4200e61d:	3acc      	bnez.n	a10, 4200e624 <_vfprintf_r+0xce0>
4200e61f:	180c      	movi.n	a8, 1
4200e621:	956182        	s32i	a8, a1, 0x254
4200e624:	ca2291        	l32r	a9, 42000eac <_stext+0xe8c> (3c028705 <blanks$1+0x31>)
4200e627:	61a082        	movi	a8, 97
4200e62a:	ab6192        	s32i	a9, a1, 0x2ac
4200e62d:	a32192        	l32i	a9, a1, 0x28c
4200e630:	059987        	bne	a9, a8, 4200e639 <_vfprintf_r+0xcf5>
4200e633:	ca1d81        	l32r	a8, 42000ea8 <_stext+0xe88> (3c0286f4 <blanks$1+0x20>)
4200e636:	ab6182        	s32i	a8, a1, 0x2ac
4200e639:	a22182        	l32i	a8, a1, 0x288
4200e63c:	9f2162        	l32i	a6, a1, 0x27c
4200e63f:	880b      	addi.n	a8, a8, -1
4200e641:	000046        	j	4200e646 <_vfprintf_r+0xd02>
4200e644:	058d      	mov.n	a8, a5
4200e646:	ba6182        	s32i	a8, a1, 0x2e8
4200e649:	90a282        	movi	a8, 0x290
4200e64c:	881a      	add.n	a8, a8, a1
4200e64e:	08a8      	l32i.n	a10, a8, 0
4200e650:	18b8      	l32i.n	a11, a8, 4
4200e652:	03a4d2        	movi	a13, 0x403
4200e655:	00a0c2        	movi	a12, 0
4200e658:	01ddc0        	slli	a13, a13, 20
4200e65b:	ca1e81        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
4200e65e:	0008e0        	callx8	a8
4200e661:	a561b2        	s32i	a11, a1, 0x294
4200e664:	a461a2        	s32i	a10, a1, 0x290
4200e667:	ca1d81        	l32r	a8, 42000edc <_stext+0xebc> (400022d4 <__fixdfsi>)
4200e66a:	0008e0        	callx8	a8
4200e66d:	0a5d      	mov.n	a5, a10
4200e66f:	ca1c81        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
4200e672:	0008e0        	callx8	a8
4200e675:	90a282        	movi	a8, 0x290
4200e678:	881a      	add.n	a8, a8, a1
4200e67a:	0acd      	mov.n	a12, a10
4200e67c:	0bdd      	mov.n	a13, a11
4200e67e:	08a8      	l32i.n	a10, a8, 0
4200e680:	18b8      	l32i.n	a11, a8, 4
4200e682:	ca1881        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
4200e685:	0008e0        	callx8	a8
4200e688:	ab2182        	l32i	a8, a1, 0x2ac
4200e68b:	a461a2        	s32i	a10, a1, 0x290
4200e68e:	a85a      	add.n	a10, a8, a5
4200e690:	000aa2        	l8ui	a10, a10, 0
4200e693:	ba2182        	l32i	a8, a1, 0x2e8
4200e696:	0046a2        	s8i	a10, a6, 0
4200e699:	a561b2        	s32i	a11, a1, 0x294
4200e69c:	661b      	addi.n	a6, a6, 1
4200e69e:	1f0826        	beqi	a8, -1, 4200e6c1 <_vfprintf_r+0xd7d>
4200e6a1:	580b      	addi.n	a5, a8, -1
4200e6a3:	90a282        	movi	a8, 0x290
4200e6a6:	881a      	add.n	a8, a8, a1
4200e6a8:	08a8      	l32i.n	a10, a8, 0
4200e6aa:	18b8      	l32i.n	a11, a8, 4
4200e6ac:	00a0c2        	movi	a12, 0
4200e6af:	00a0d2        	movi	a13, 0
4200e6b2:	ca0d81        	l32r	a8, 42000ee8 <_stext+0xec8> (4000246c <__nedf2>)
4200e6b5:	0008e0        	callx8	a8
4200e6b8:	ba2182        	l32i	a8, a1, 0x2e8
4200e6bb:	f85a56        	bnez	a10, 4200e644 <_vfprintf_r+0xd00>
4200e6be:	001c06        	j	4200e732 <_vfprintf_r+0xdee>
4200e6c1:	90a282        	movi	a8, 0x290
4200e6c4:	881a      	add.n	a8, a8, a1
4200e6c6:	c9fed1        	l32r	a13, 42000ec0 <_stext+0xea0> (3fe00000 <ets_ops_table_ptr+0x110004>)
4200e6c9:	08a8      	l32i.n	a10, a8, 0
4200e6cb:	18b8      	l32i.n	a11, a8, 4
4200e6cd:	0c0c      	movi.n	a12, 0
4200e6cf:	ca0781        	l32r	a8, 42000eec <_stext+0xecc> (400023a0 <__gtdf2>)
4200e6d2:	0008e0        	callx8	a8
4200e6d5:	191ae6        	bgei	a10, 1, 4200e6f2 <_vfprintf_r+0xdae>
4200e6d8:	90a282        	movi	a8, 0x290
4200e6db:	881a      	add.n	a8, a8, a1
4200e6dd:	c9f8d1        	l32r	a13, 42000ec0 <_stext+0xea0> (3fe00000 <ets_ops_table_ptr+0x110004>)
4200e6e0:	08a8      	l32i.n	a10, a8, 0
4200e6e2:	18b8      	l32i.n	a11, a8, 4
4200e6e4:	0c0c      	movi.n	a12, 0
4200e6e6:	c9fc81        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
4200e6e9:	0008e0        	callx8	a8
4200e6ec:	040a56        	bnez	a10, 4200e730 <_vfprintf_r+0xdec>
4200e6ef:	3d6507        	bbci	a5, 0, 4200e730 <_vfprintf_r+0xdec>
4200e6f2:	ab2182        	l32i	a8, a1, 0x2ac
4200e6f5:	906162        	s32i	a6, a1, 0x240
4200e6f8:	0f0882        	l8ui	a8, a8, 15
4200e6fb:	0b3c      	movi.n	a11, 48
4200e6fd:	000086        	j	4200e703 <_vfprintf_r+0xdbf>
4200e700:	0049b2        	s8i	a11, a9, 0
4200e703:	902192        	l32i	a9, a1, 0x240
4200e706:	990b      	addi.n	a9, a9, -1
4200e708:	906192        	s32i	a9, a1, 0x240
4200e70b:	0009a2        	l8ui	a10, a9, 0
4200e70e:	ee1a87        	beq	a10, a8, 4200e700 <_vfprintf_r+0xdbc>
4200e711:	8a1b      	addi.n	a8, a10, 1
4200e713:	9b3c      	movi.n	a11, 57
4200e715:	748080        	extui	a8, a8, 0, 8
4200e718:	059ab7        	bne	a10, a11, 4200e721 <_vfprintf_r+0xddd>
4200e71b:	ab2182        	l32i	a8, a1, 0x2ac
4200e71e:	0a0882        	l8ui	a8, a8, 10
4200e721:	004982        	s8i	a8, a9, 0
4200e724:	000ac6        	j	4200e753 <_vfprintf_r+0xe0f>
4200e727:	49c200        	s32e	a0, a2, -16
4200e72a:	00          	.byte	00
4200e72b:	991b      	addi.n	a9, a9, 1
4200e72d:	0001c6        	j	4200e738 <_vfprintf_r+0xdf4>
4200e730:	f87c      	movi.n	a8, -1
4200e732:	069d      	mov.n	a9, a6
4200e734:	b68a      	add.n	a11, a6, a8
4200e736:	0c3c      	movi.n	a12, 48
4200e738:	c0ab90        	sub	a10, a11, a9
4200e73b:	fe9ad6        	bgez	a10, 4200e728 <_vfprintf_r+0xde4>
4200e73e:	f97c      	movi.n	a9, -1
4200e740:	729890        	salt	a9, a8, a9
4200e743:	990b      	addi.n	a9, a9, -1
4200e745:	609090        	neg	a9, a9
4200e748:	749090        	extui	a9, a9, 0, 8
4200e74b:	0a0c      	movi.n	a10, 0
4200e74d:	098c      	beqz.n	a9, 4200e751 <_vfprintf_r+0xe0d>
4200e74f:	a81b      	addi.n	a10, a8, 1
4200e751:	66aa      	add.n	a6, a6, a10
4200e753:	9f2182        	l32i	a8, a1, 0x27c
4200e756:	c08680        	sub	a8, a6, a8
4200e759:	a46182        	s32i	a8, a1, 0x290
4200e75c:	952162        	l32i	a6, a1, 0x254
4200e75f:	003e46        	j	4200e85c <_vfprintf_r+0xf18>
4200e762:	684c      	movi.n	a8, 70
4200e764:	a22162        	l32i	a6, a1, 0x288
4200e767:	3e0c      	movi.n	a14, 3
4200e769:	0f1487        	beq	a4, a8, 4200e77c <_vfprintf_r+0xe38>
4200e76c:	bbc462        	addi	a6, a4, -69
4200e76f:	a22182        	l32i	a8, a1, 0x288
4200e772:	40f660        	nsau	a6, a6
4200e775:	416560        	srli	a6, a6, 5
4200e778:	668a      	add.n	a6, a6, a8
4200e77a:	2e0c      	movi.n	a14, 2
4200e77c:	10c182        	addi	a8, a1, 16
4200e77f:	30a292        	movi	a9, 0x230
4200e782:	989a      	add.n	a9, a8, a9
4200e784:	2199      	s32i.n	a9, a1, 8
4200e786:	40a292        	movi	a9, 0x240
4200e789:	989a      	add.n	a9, a8, a9
4200e78b:	1199      	s32i.n	a9, a1, 4
4200e78d:	44a292        	movi	a9, 0x244
4200e790:	889a      	add.n	a8, a8, a9
4200e792:	0189      	s32i.n	a8, a1, 0
4200e794:	c8a282        	movi	a8, 0x2c8
4200e797:	881a      	add.n	a8, a8, a1
4200e799:	08c8      	l32i.n	a12, a8, 0
4200e79b:	18d8      	l32i.n	a13, a8, 4
4200e79d:	a121a2        	l32i	a10, a1, 0x284
4200e7a0:	06fd      	mov.n	a15, a6
4200e7a2:	201110        	or	a1, a1, a1
4200e7a5:	0434e5        	call8	42012af4 <_dtoa_r>
4200e7a8:	9f61a2        	s32i	a10, a1, 0x27c
4200e7ab:	784c      	movi.n	a8, 71
4200e7ad:	239487        	bne	a4, a8, 4200e7d4 <_vfprintf_r+0xe90>
4200e7b0:	18e307        	bbsi	a3, 0, 4200e7cc <_vfprintf_r+0xe88>
4200e7b3:	902182        	l32i	a8, a1, 0x240
4200e7b6:	9f2192        	l32i	a9, a1, 0x27c
4200e7b9:	952162        	l32i	a6, a1, 0x254
4200e7bc:	c08890        	sub	a8, a8, a9
4200e7bf:	a46182        	s32i	a8, a1, 0x290
4200e7c2:	784c      	movi.n	a8, 71
4200e7c4:	7a1487        	beq	a4, a8, 4200e842 <_vfprintf_r+0xefe>
4200e7c7:	002446        	j	4200e85c <_vfprintf_r+0xf18>
4200e7ca:	820000        	mull	a0, a0, a0
4200e7cd:	6a9f21        	l32r	a2, 41fe924c <_iram_bss_end+0x1c66e4c>
4200e7d0:	0658      	l32i.n	a5, a6, 0
4200e7d2:	2182000e 	ee.vmulas.s8.accx.ld.ip.qup	q2, a0, 0, q0, q1, q0, q2
4200e7d6:	4c586a9f 	ee.vmulas.u16.accx.ld.ip.qup	q1, a9, -96, q5, q4, q5, q0
4200e7da:	8768      	l32i.n	a6, a7, 32
4200e7dc:	822e94        	ee.vldbc.32.ip	q0, a9, 184
4200e7df:	829f21        	l32r	a2, 41fef25c <_iram_bss_end+0x1c6ce5c>
4200e7e2:	0008      	l32i.n	a0, a0, 0
4200e7e4:	d0c882        	addi	a8, a8, -48
4200e7e7:	d8dc      	bnez.n	a8, 4200e808 <_vfprintf_r+0xec4>
4200e7e9:	c8a282        	movi	a8, 0x2c8
4200e7ec:	881a      	add.n	a8, a8, a1
4200e7ee:	08a8      	l32i.n	a10, a8, 0
4200e7f0:	18b8      	l32i.n	a11, a8, 4
4200e7f2:	00a0c2        	movi	a12, 0
4200e7f5:	00a0d2        	movi	a13, 0
4200e7f8:	c9bc81        	l32r	a8, 42000ee8 <_stext+0xec8> (4000246c <__nedf2>)
4200e7fb:	0008e0        	callx8	a8
4200e7fe:	6a8c      	beqz.n	a10, 4200e808 <_vfprintf_r+0xec4>
4200e800:	660b      	addi.n	a6, a6, -1
4200e802:	606060        	neg	a6, a6
4200e805:	956162        	s32i	a6, a1, 0x254
4200e808:	952182        	l32i	a8, a1, 0x254
4200e80b:	558a      	add.n	a5, a5, a8
4200e80d:	c8a282        	movi	a8, 0x2c8
4200e810:	881a      	add.n	a8, a8, a1
4200e812:	08a8      	l32i.n	a10, a8, 0
4200e814:	18b8      	l32i.n	a11, a8, 4
4200e816:	0c0c      	movi.n	a12, 0
4200e818:	0d0c      	movi.n	a13, 0
4200e81a:	c9af81        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
4200e81d:	0008e0        	callx8	a8
4200e820:	0adc      	bnez.n	a10, 4200e834 <_vfprintf_r+0xef0>
4200e822:	906152        	s32i	a5, a1, 0x240
4200e825:	0002c6        	j	4200e834 <_vfprintf_r+0xef0>
4200e828:	a81b      	addi.n	a10, a8, 1
4200e82a:	9061a2        	s32i	a10, a1, 0x240
4200e82d:	004892        	s8i	a9, a8, 0
4200e830:	000086        	j	4200e836 <_vfprintf_r+0xef2>
4200e833:	093c00        	l32e	a0, a12, -52
4200e836:	902182        	l32i	a8, a1, 0x240
4200e839:	eb3857        	bltu	a8, a5, 4200e828 <_vfprintf_r+0xee4>
4200e83c:	ffdcc6        	j	4200e7b3 <_vfprintf_r+0xe6f>
4200e83f:	000000        	ill
4200e842:	d87c      	movi.n	a8, -3
4200e844:	082687        	blt	a6, a8, 4200e850 <_vfprintf_r+0xf0c>
4200e847:	a22182        	l32i	a8, a1, 0x288
4200e84a:	022867        	blt	a8, a6, 4200e850 <_vfprintf_r+0xf0c>
4200e84d:	0048c6        	j	4200e974 <_vfprintf_r+0x1030>
4200e850:	a32182        	l32i	a8, a1, 0x28c
4200e853:	fec882        	addi	a8, a8, -2
4200e856:	a36182        	s32i	a8, a1, 0x28c
4200e859:	0001c6        	j	4200e864 <_vfprintf_r+0xf20>
4200e85c:	684c      	movi.n	a8, 70
4200e85e:	029487        	bne	a4, a8, 4200e864 <_vfprintf_r+0xf20>
4200e861:	004606        	j	4200e97d <_vfprintf_r+0x1039>
4200e864:	a32192        	l32i	a9, a1, 0x28c
4200e867:	dfafb2        	movi	a11, -33
4200e86a:	10b9b0        	and	a11, a9, a11
4200e86d:	8ca292        	movi	a9, 0x28c
4200e870:	991a      	add.n	a9, a9, a1
4200e872:	860b      	addi.n	a8, a6, -1
4200e874:	0009a2        	l8ui	a10, a9, 0
4200e877:	956182        	s32i	a8, a1, 0x254
4200e87a:	194c      	movi.n	a9, 65
4200e87c:	049b97        	bne	a11, a9, 4200e884 <_vfprintf_r+0xf40>
4200e87f:	aafb      	addi.n	a10, a10, 15
4200e881:	74a0a0        	extui	a10, a10, 0, 8
4200e884:	10c192        	addi	a9, a1, 16
4200e887:	02d9c2        	addmi	a12, a9, 0x200
4200e88a:	374ca2        	s8i	a10, a12, 55
4200e88d:	ba2c      	movi.n	a10, 43
4200e88f:	0068d6        	bgez	a8, 4200e899 <_vfprintf_r+0xf55>
4200e892:	860b      	addi.n	a8, a6, -1
4200e894:	608080        	neg	a8, a8
4200e897:	da2c      	movi.n	a10, 45
4200e899:	02d9c2        	addmi	a12, a9, 0x200
4200e89c:	384ca2        	s8i	a10, a12, 56
4200e89f:	9a0c      	movi.n	a10, 9
4200e8a1:	70aa87        	bge	a10, a8, 4200e915 <_vfprintf_r+0xfd1>
4200e8a4:	37a2a2        	movi	a10, 0x237
4200e8a7:	c715e1        	l32r	a14, 420004fc <_stext+0x4dc> (cccccccd <_rtc_reserved_end+0x6cbccccd>)
4200e8aa:	8099a0        	add	a9, a9, a10
4200e8ad:	63a0d2        	movi	a13, 99
4200e8b0:	a2b8e0        	muluh	a11, a8, a14
4200e8b3:	09cd      	mov.n	a12, a9
4200e8b5:	41b3b0        	srli	a11, a11, 3
4200e8b8:	a0abb0        	addx4	a10, a11, a11
4200e8bb:	aaaa      	add.n	a10, a10, a10
4200e8bd:	c0a8a0        	sub	a10, a8, a10
4200e8c0:	30caa2        	addi	a10, a10, 48
4200e8c3:	990b      	addi.n	a9, a9, -1
4200e8c5:	0049a2        	s8i	a10, a9, 0
4200e8c8:	08ad      	mov.n	a10, a8
4200e8ca:	0b8d      	mov.n	a8, a11
4200e8cc:	e02da7        	blt	a13, a10, 4200e8b0 <_vfprintf_r+0xf6c>
4200e8cf:	30cb82        	addi	a8, a11, 48
4200e8d2:	fecc92        	addi	a9, a12, -2
4200e8d5:	10c1a2        	addi	a10, a1, 16
4200e8d8:	004982        	s8i	a8, a9, 0
4200e8db:	39a2b2        	movi	a11, 0x239
4200e8de:	30a282        	movi	a8, 0x230
4200e8e1:	baba      	add.n	a11, a10, a11
4200e8e3:	aa8a      	add.n	a10, a10, a8
4200e8e5:	0bdd      	mov.n	a13, a11
4200e8e7:	8a7b      	addi.n	a8, a10, 7
4200e8e9:	000246        	j	4200e8f6 <_vfprintf_r+0xfb2>
4200e8ec:	0009e2        	l8ui	a14, a9, 0
4200e8ef:	991b      	addi.n	a9, a9, 1
4200e8f1:	004de2        	s8i	a14, a13, 0
4200e8f4:	dd1b      	addi.n	a13, a13, 1
4200e8f6:	f23987        	bltu	a9, a8, 4200e8ec <_vfprintf_r+0xfa8>
4200e8f9:	fecc92        	addi	a9, a12, -2
4200e8fc:	628890        	saltu	a8, a8, a9
4200e8ff:	880b      	addi.n	a8, a8, -1
4200e901:	608080        	neg	a8, a8
4200e904:	748080        	extui	a8, a8, 0, 8
4200e907:	090c      	movi.n	a9, 0
4200e909:	388c      	beqz.n	a8, 4200e910 <_vfprintf_r+0xfcc>
4200e90b:	aa9b      	addi.n	a10, a10, 9
4200e90d:	c09ac0        	sub	a9, a10, a12
4200e910:	99ba      	add.n	a9, a9, a11
4200e912:	000706        	j	4200e932 <_vfprintf_r+0xfee>
4200e915:	39a2a2        	movi	a10, 0x239
4200e918:	1d4c      	movi.n	a13, 65
4200e91a:	a9aa      	add.n	a10, a9, a10
4200e91c:	091bd7        	beq	a11, a13, 4200e929 <_vfprintf_r+0xfe5>
4200e91f:	0a3c      	movi.n	a10, 48
4200e921:	394ca2        	s8i	a10, a12, 57
4200e924:	3aa2a2        	movi	a10, 0x23a
4200e927:	a9aa      	add.n	a10, a9, a10
4200e929:	30c882        	addi	a8, a8, 48
4200e92c:	01ca92        	addi	a9, a10, 1
4200e92f:	004a82        	s8i	a8, a10, 0
4200e932:	47a282        	movi	a8, 0x247
4200e935:	808180        	add	a8, a1, a8
4200e938:	c08980        	sub	a8, a9, a8
4200e93b:	a42192        	l32i	a9, a1, 0x290
4200e93e:	b76182        	s32i	a8, a1, 0x2dc
4200e941:	808890        	add	a8, a8, a9
4200e944:	a26182        	s32i	a8, a1, 0x288
4200e947:	0229e6        	bgei	a9, 2, 4200e94d <_vfprintf_r+0x1009>
4200e94a:	0a6307        	bbci	a3, 0, 4200e958 <_vfprintf_r+0x1014>
4200e94d:	a22182        	l32i	a8, a1, 0x288
4200e950:	ad2192        	l32i	a9, a1, 0x2b4
4200e953:	889a      	add.n	a8, a8, a9
4200e955:	a26182        	s32i	a8, a1, 0x288
4200e958:	ffab82        	movi	a8, 0xfffffbff
4200e95b:	108380        	and	a8, a3, a8
4200e95e:	00a192        	movi	a9, 0x100
4200e961:	208890        	or	a8, a8, a9
4200e964:	af6182        	s32i	a8, a1, 0x2bc
4200e967:	080c      	movi.n	a8, 0
4200e969:	ab6182        	s32i	a8, a1, 0x2ac
4200e96c:	050c      	movi.n	a5, 0
4200e96e:	060c      	movi.n	a6, 0
4200e970:	003806        	j	4200ea54 <_vfprintf_r+0x1110>
4200e973:	218200        	srai	a8, a0, 2
4200e976:	a687a4        	ee.slcxxp.2q	q5, q0, a10, a7
4200e979:	2d          	.byte	0x2d
4200e97a:	000f86        	j	4200e9bc <_vfprintf_r+0x1078>
4200e97d:	a22192        	l32i	a9, a1, 0x288
4200e980:	048030        	extui	a8, a3, 0, 1
4200e983:	208890        	or	a8, a8, a9
4200e986:	0a16a6        	blti	a6, 1, 4200e994 <_vfprintf_r+0x1050>
4200e989:	050816        	beqz	a8, 4200e9dd <_vfprintf_r+0x1099>
4200e98c:	ad2182        	l32i	a8, a1, 0x2b4
4200e98f:	868a      	add.n	a8, a6, a8
4200e991:	000286        	j	4200e99f <_vfprintf_r+0x105b>
4200e994:	051816        	beqz	a8, 4200e9e9 <_vfprintf_r+0x10a5>
4200e997:	ad2182        	l32i	a8, a1, 0x2b4
4200e99a:	a22192        	l32i	a9, a1, 0x288
4200e99d:	881b      	addi.n	a8, a8, 1
4200e99f:	898a      	add.n	a8, a9, a8
4200e9a1:	a26182        	s32i	a8, a1, 0x288
4200e9a4:	000e06        	j	4200e9e0 <_vfprintf_r+0x109c>
4200e9a7:	a08200        	addx4	a8, a2, a0
4200e9aa:	618267        	bany	a2, a6, 4200ea0f <_vfprintf_r+0x10cb>
4200e9ad:	a3          	.byte	0xa3
4200e9ae:	a26162        	s32i	a6, a1, 0x288
4200e9b1:	ad2192        	l32i	a9, a1, 0x2b4
4200e9b4:	068d      	mov.n	a8, a6
4200e9b6:	1ee307        	bbsi	a3, 0, 4200e9d8 <_vfprintf_r+0x1094>
4200e9b9:	000dc6        	j	4200e9f4 <_vfprintf_r+0x10b0>
4200e9bc:	a42182        	l32i	a8, a1, 0x290
4200e9bf:	ad2192        	l32i	a9, a1, 0x2b4
4200e9c2:	889a      	add.n	a8, a8, a9
4200e9c4:	a26182        	s32i	a8, a1, 0x288
4200e9c7:	67a082        	movi	a8, 103
4200e9ca:	a36182        	s32i	a8, a1, 0x28c
4200e9cd:	2316e6        	bgei	a6, 1, 4200e9f4 <_vfprintf_r+0x10b0>
4200e9d0:	860b      	addi.n	a8, a6, -1
4200e9d2:	a22192        	l32i	a9, a1, 0x288
4200e9d5:	608080        	neg	a8, a8
4200e9d8:	898a      	add.n	a8, a9, a8
4200e9da:	0004c6        	j	4200e9f1 <_vfprintf_r+0x10ad>
4200e9dd:	a26162        	s32i	a6, a1, 0x288
4200e9e0:	66a082        	movi	a8, 102
4200e9e3:	a36182        	s32i	a8, a1, 0x28c
4200e9e6:	000286        	j	4200e9f4 <_vfprintf_r+0x10b0>
4200e9e9:	66a082        	movi	a8, 102
4200e9ec:	a36182        	s32i	a8, a1, 0x28c
4200e9ef:	180c      	movi.n	a8, 1
4200e9f1:	a26182        	s32i	a8, a1, 0x288
4200e9f4:	00a452        	movi	a5, 0x400
4200e9f7:	080c      	movi.n	a8, 0
4200e9f9:	105350        	and	a5, a3, a5
4200e9fc:	ab6182        	s32i	a8, a1, 0x2ac
4200e9ff:	051516        	beqz	a5, 4200ea54 <_vfprintf_r+0x1110>
4200ea02:	050c      	movi.n	a5, 0
4200ea04:	2d16e6        	bgei	a6, 1, 4200ea35 <_vfprintf_r+0x10f1>
4200ea07:	001246        	j	4200ea54 <_vfprintf_r+0x1110>
4200ea0a:	670000        	ee.stf.64.xp	f0, f6, a0, a0
4200ea0d:	31a8      	l32i.n	a10, a1, 12
4200ea0f:	c06680        	sub	a6, a6, a8
4200ea12:	aa2182        	l32i	a8, a1, 0x2a8
4200ea15:	010882        	l8ui	a8, a8, 1
4200ea18:	b88c      	beqz.n	a8, 4200ea27 <_vfprintf_r+0x10e3>
4200ea1a:	aa2182        	l32i	a8, a1, 0x2a8
4200ea1d:	551b      	addi.n	a5, a5, 1
4200ea1f:	881b      	addi.n	a8, a8, 1
4200ea21:	aa6182        	s32i	a8, a1, 0x2a8
4200ea24:	000406        	j	4200ea38 <_vfprintf_r+0x10f4>
4200ea27:	ab2182        	l32i	a8, a1, 0x2ac
4200ea2a:	881b      	addi.n	a8, a8, 1
4200ea2c:	ab6182        	s32i	a8, a1, 0x2ac
4200ea2f:	000146        	j	4200ea38 <_vfprintf_r+0x10f4>
4200ea32:	000000        	ill
4200ea35:	ffa092        	movi	a9, 255
4200ea38:	aa2182        	l32i	a8, a1, 0x2a8
4200ea3b:	000882        	l8ui	a8, a8, 0
4200ea3e:	ca9897        	bne	a8, a9, 4200ea0c <_vfprintf_r+0x10c8>
4200ea41:	ab2182        	l32i	a8, a1, 0x2ac
4200ea44:	b02192        	l32i	a9, a1, 0x2c0
4200ea47:	858a      	add.n	a8, a5, a8
4200ea49:	828890        	mull	a8, a8, a9
4200ea4c:	a22192        	l32i	a9, a1, 0x288
4200ea4f:	889a      	add.n	a8, a8, a9
4200ea51:	a26182        	s32i	a8, a1, 0x288
4200ea54:	b92182        	l32i	a8, a1, 0x2e4
4200ea57:	68cc      	bnez.n	a8, 4200ea61 <_vfprintf_r+0x111d>
4200ea59:	af2132        	l32i	a3, a1, 0x2bc
4200ea5c:	040c      	movi.n	a4, 0
4200ea5e:	03f6c6        	j	4200fa3d <_vfprintf_r+0x20f9>
4200ea61:	10c182        	addi	a8, a1, 16
4200ea64:	02d882        	addmi	a8, a8, 0x200
4200ea67:	d92c      	movi.n	a9, 45
4200ea69:	524892        	s8i	a9, a8, 82
4200ea6c:	fffa46        	j	4200ea59 <_vfprintf_r+0x1115>
4200ea6f:	218200        	srai	a8, a0, 2
4200ea72:	c1e297        	bbsi	a2, 9, 4200ea37 <_vfprintf_r+0x10f3>
4200ea75:	10          	.byte	0x10
4200ea76:	02e357        	bbsi	a3, 5, 4200ea7c <_vfprintf_r+0x1138>
4200ea79:	002c06        	j	4200eb2d <_vfprintf_r+0x11e9>
4200ea7c:	c4ac      	beqz.n	a4, 4200eaac <_vfprintf_r+0x1168>
4200ea7e:	07a687        	bge	a6, a8, 4200ea89 <_vfprintf_r+0x1145>
4200ea81:	b0e6e0        	addx8	a14, a6, a14
4200ea84:	0e98      	l32i.n	a9, a14, 0
4200ea86:	000706        	j	4200eaa6 <_vfprintf_r+0x1162>
4200ea89:	48a282        	movi	a8, 0x248
4200ea8c:	8e8a      	add.n	a8, a14, a8
4200ea8e:	4ca2d2        	movi	a13, 0x24c
4200ea91:	60a2c2        	movi	a12, 0x260
4200ea94:	0189      	s32i.n	a8, a1, 0
4200ea96:	01def2        	addmi	a15, a14, 0x100
4200ea99:	deda      	add.n	a13, a14, a13
4200ea9b:	ceca      	add.n	a12, a14, a12
4200ea9d:	05bd      	mov.n	a11, a5
4200ea9f:	06ad      	mov.n	a10, a6
4200eaa1:	fe9d25        	call8	4200d474 <get_arg$isra$0>
4200eaa4:	0a98      	l32i.n	a9, a10, 0
4200eaa6:	07ad      	mov.n	a10, a7
4200eaa8:	001d06        	j	4200eb20 <_vfprintf_r+0x11dc>
4200eaab:	a71b00        	ee.stf.64.xp	f1, f10, a0, a11
4200eaae:	07a787        	bge	a7, a8, 4200eab9 <_vfprintf_r+0x1175>
4200eab1:	b0e6e0        	addx8	a14, a6, a14
4200eab4:	0e98      	l32i.n	a9, a14, 0
4200eab6:	001986        	j	4200eb20 <_vfprintf_r+0x11dc>
4200eab9:	9a2eb2        	l32i	a11, a14, 0x268
4200eabc:	fc1c      	movi.n	a12, 31
4200eabe:	02dee2        	addmi	a14, a14, 0x200
4200eac1:	9b4b      	addi.n	a9, a11, 4
4200eac3:	322c87        	blt	a12, a8, 4200eaf9 <_vfprintf_r+0x11b5>
4200eac6:	c81b      	addi.n	a12, a8, 1
4200eac8:	9761c2        	s32i	a12, a1, 0x25c
4200eacb:	1a6e92        	s32i	a9, a14, 104
4200eace:	8c1c      	movi.n	a12, 24
4200ead0:	052c97        	blt	a12, a9, 4200ead9 <_vfprintf_r+0x1195>
4200ead3:	192eb2        	l32i	a11, a14, 100
4200ead6:	000406        	j	4200eaea <_vfprintf_r+0x11a6>
4200ead9:	012cb7        	blt	a12, a11, 4200eade <_vfprintf_r+0x119a>
4200eadc:	492c      	movi.n	a9, 36
4200eade:	10c1b2        	addi	a11, a1, 16
4200eae1:	02dbb2        	addmi	a11, a11, 0x200
4200eae4:	182bb2        	l32i	a11, a11, 96
4200eae7:	9e6192        	s32i	a9, a1, 0x278
4200eaea:	bb9a      	add.n	a11, a11, a9
4200eaec:	fccbb2        	addi	a11, a11, -4
4200eaef:	0b98      	l32i.n	a9, a11, 0
4200eaf1:	b08810        	addx8	a8, a8, a1
4200eaf4:	4899      	s32i.n	a9, a8, 16
4200eaf6:	000986        	j	4200eb20 <_vfprintf_r+0x11dc>
4200eaf9:	1a6e92        	s32i	a9, a14, 104
4200eafc:	881c      	movi.n	a8, 24
4200eafe:	062897        	blt	a8, a9, 4200eb08 <_vfprintf_r+0x11c4>
4200eb01:	192e82        	l32i	a8, a14, 100
4200eb04:	000446        	j	4200eb19 <_vfprintf_r+0x11d5>
4200eb07:	00          	.byte	00
4200eb08:	0128b7        	blt	a8, a11, 4200eb0d <_vfprintf_r+0x11c9>
4200eb0b:	492c      	movi.n	a9, 36
4200eb0d:	10c182        	addi	a8, a1, 16
4200eb10:	02d882        	addmi	a8, a8, 0x200
4200eb13:	182882        	l32i	a8, a8, 96
4200eb16:	9e6192        	s32i	a9, a1, 0x278
4200eb19:	889a      	add.n	a8, a8, a9
4200eb1b:	fcc882        	addi	a8, a8, -4
4200eb1e:	0898      	l32i.n	a9, a8, 0
4200eb20:	ae2182        	l32i	a8, a1, 0x2b8
4200eb23:	0989      	s32i.n	a8, a9, 0
4200eb25:	318f80        	srai	a8, a8, 31
4200eb28:	1989      	s32i.n	a8, a9, 4
4200eb2a:	002e06        	j	4200ebe6 <_vfprintf_r+0x12a2>
4200eb2d:	026347        	bbci	a3, 4, 4200eb33 <_vfprintf_r+0x11ef>
4200eb30:	005b46        	j	4200eca1 <_vfprintf_r+0x135d>
4200eb33:	02e367        	bbsi	a3, 6, 4200eb39 <_vfprintf_r+0x11f5>
4200eb36:	002c86        	j	4200ebec <_vfprintf_r+0x12a8>
4200eb39:	f4ac      	beqz.n	a4, 4200eb6c <_vfprintf_r+0x1228>
4200eb3b:	0aa687        	bge	a6, a8, 4200eb49 <_vfprintf_r+0x1205>
4200eb3e:	b0e6e0        	addx8	a14, a6, a14
4200eb41:	0e98      	l32i.n	a9, a14, 0
4200eb43:	0007c6        	j	4200eb66 <_vfprintf_r+0x1222>
4200eb46:	000000        	ill
4200eb49:	48a282        	movi	a8, 0x248
4200eb4c:	8e8a      	add.n	a8, a14, a8
4200eb4e:	4ca2d2        	movi	a13, 0x24c
4200eb51:	60a2c2        	movi	a12, 0x260
4200eb54:	0189      	s32i.n	a8, a1, 0
4200eb56:	01def2        	addmi	a15, a14, 0x100
4200eb59:	deda      	add.n	a13, a14, a13
4200eb5b:	ceca      	add.n	a12, a14, a12
4200eb5d:	05bd      	mov.n	a11, a5
4200eb5f:	06ad      	mov.n	a10, a6
4200eb61:	fe9125        	call8	4200d474 <get_arg$isra$0>
4200eb64:	0a98      	l32i.n	a9, a10, 0
4200eb66:	07ad      	mov.n	a10, a7
4200eb68:	001d06        	j	4200ebe0 <_vfprintf_r+0x129c>
4200eb6b:	a71b00        	ee.stf.64.xp	f1, f10, a0, a11
4200eb6e:	07a787        	bge	a7, a8, 4200eb79 <_vfprintf_r+0x1235>
4200eb71:	b0e6e0        	addx8	a14, a6, a14
4200eb74:	0e98      	l32i.n	a9, a14, 0
4200eb76:	001986        	j	4200ebe0 <_vfprintf_r+0x129c>
4200eb79:	9a2eb2        	l32i	a11, a14, 0x268
4200eb7c:	fc1c      	movi.n	a12, 31
4200eb7e:	02dee2        	addmi	a14, a14, 0x200
4200eb81:	9b4b      	addi.n	a9, a11, 4
4200eb83:	322c87        	blt	a12, a8, 4200ebb9 <_vfprintf_r+0x1275>
4200eb86:	c81b      	addi.n	a12, a8, 1
4200eb88:	9761c2        	s32i	a12, a1, 0x25c
4200eb8b:	1a6e92        	s32i	a9, a14, 104
4200eb8e:	8c1c      	movi.n	a12, 24
4200eb90:	052c97        	blt	a12, a9, 4200eb99 <_vfprintf_r+0x1255>
4200eb93:	192eb2        	l32i	a11, a14, 100
4200eb96:	000406        	j	4200ebaa <_vfprintf_r+0x1266>
4200eb99:	012cb7        	blt	a12, a11, 4200eb9e <_vfprintf_r+0x125a>
4200eb9c:	492c      	movi.n	a9, 36
4200eb9e:	10c1b2        	addi	a11, a1, 16
4200eba1:	02dbb2        	addmi	a11, a11, 0x200
4200eba4:	182bb2        	l32i	a11, a11, 96
4200eba7:	9e6192        	s32i	a9, a1, 0x278
4200ebaa:	bb9a      	add.n	a11, a11, a9
4200ebac:	fccbb2        	addi	a11, a11, -4
4200ebaf:	0b98      	l32i.n	a9, a11, 0
4200ebb1:	b08810        	addx8	a8, a8, a1
4200ebb4:	4899      	s32i.n	a9, a8, 16
4200ebb6:	000986        	j	4200ebe0 <_vfprintf_r+0x129c>
4200ebb9:	1a6e92        	s32i	a9, a14, 104
4200ebbc:	881c      	movi.n	a8, 24
4200ebbe:	062897        	blt	a8, a9, 4200ebc8 <_vfprintf_r+0x1284>
4200ebc1:	192e82        	l32i	a8, a14, 100
4200ebc4:	000446        	j	4200ebd9 <_vfprintf_r+0x1295>
4200ebc7:	00          	.byte	00
4200ebc8:	0128b7        	blt	a8, a11, 4200ebcd <_vfprintf_r+0x1289>
4200ebcb:	492c      	movi.n	a9, 36
4200ebcd:	10c182        	addi	a8, a1, 16
4200ebd0:	02d882        	addmi	a8, a8, 0x200
4200ebd3:	182882        	l32i	a8, a8, 96
4200ebd6:	9e6192        	s32i	a9, a1, 0x278
4200ebd9:	889a      	add.n	a8, a8, a9
4200ebdb:	fcc882        	addi	a8, a8, -4
4200ebde:	0898      	l32i.n	a9, a8, 0
4200ebe0:	ae2182        	l32i	a8, a1, 0x2b8
4200ebe3:	005982        	s16i	a8, a9, 0
4200ebe6:	0a7d      	mov.n	a7, a10
4200ebe8:	fbaa86        	j	4200da96 <_vfprintf_r+0x152>
4200ebeb:	00          	.byte	00
4200ebec:	02e397        	bbsi	a3, 9, 4200ebf2 <_vfprintf_r+0x12ae>
4200ebef:	002b86        	j	4200eca1 <_vfprintf_r+0x135d>
4200ebf2:	e4ac      	beqz.n	a4, 4200ec24 <_vfprintf_r+0x12e0>
4200ebf4:	09a687        	bge	a6, a8, 4200ec01 <_vfprintf_r+0x12bd>
4200ebf7:	b0e6e0        	addx8	a14, a6, a14
4200ebfa:	0e98      	l32i.n	a9, a14, 0
4200ebfc:	000786        	j	4200ec1e <_vfprintf_r+0x12da>
4200ebff:	820000        	mull	a0, a0, a0
4200ec02:	8a48a2        	s8i	a10, a8, 138
4200ec05:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200ec09:	60a2c2        	movi	a12, 0x260
4200ec0c:	0189      	s32i.n	a8, a1, 0
4200ec0e:	01def2        	addmi	a15, a14, 0x100
4200ec11:	deda      	add.n	a13, a14, a13
4200ec13:	ceca      	add.n	a12, a14, a12
4200ec15:	05bd      	mov.n	a11, a5
4200ec17:	06ad      	mov.n	a10, a6
4200ec19:	fe85a5        	call8	4200d474 <get_arg$isra$0>
4200ec1c:	0a98      	l32i.n	a9, a10, 0
4200ec1e:	07ad      	mov.n	a10, a7
4200ec20:	001d06        	j	4200ec98 <_vfprintf_r+0x1354>
4200ec23:	a71b00        	ee.stf.64.xp	f1, f10, a0, a11
4200ec26:	07a787        	bge	a7, a8, 4200ec31 <_vfprintf_r+0x12ed>
4200ec29:	b0e6e0        	addx8	a14, a6, a14
4200ec2c:	0e98      	l32i.n	a9, a14, 0
4200ec2e:	001986        	j	4200ec98 <_vfprintf_r+0x1354>
4200ec31:	9a2eb2        	l32i	a11, a14, 0x268
4200ec34:	fc1c      	movi.n	a12, 31
4200ec36:	02dee2        	addmi	a14, a14, 0x200
4200ec39:	9b4b      	addi.n	a9, a11, 4
4200ec3b:	322c87        	blt	a12, a8, 4200ec71 <_vfprintf_r+0x132d>
4200ec3e:	c81b      	addi.n	a12, a8, 1
4200ec40:	9761c2        	s32i	a12, a1, 0x25c
4200ec43:	1a6e92        	s32i	a9, a14, 104
4200ec46:	8c1c      	movi.n	a12, 24
4200ec48:	052c97        	blt	a12, a9, 4200ec51 <_vfprintf_r+0x130d>
4200ec4b:	192eb2        	l32i	a11, a14, 100
4200ec4e:	000406        	j	4200ec62 <_vfprintf_r+0x131e>
4200ec51:	012cb7        	blt	a12, a11, 4200ec56 <_vfprintf_r+0x1312>
4200ec54:	492c      	movi.n	a9, 36
4200ec56:	10c1b2        	addi	a11, a1, 16
4200ec59:	02dbb2        	addmi	a11, a11, 0x200
4200ec5c:	182bb2        	l32i	a11, a11, 96
4200ec5f:	9e6192        	s32i	a9, a1, 0x278
4200ec62:	bb9a      	add.n	a11, a11, a9
4200ec64:	fccbb2        	addi	a11, a11, -4
4200ec67:	0b98      	l32i.n	a9, a11, 0
4200ec69:	b08810        	addx8	a8, a8, a1
4200ec6c:	4899      	s32i.n	a9, a8, 16
4200ec6e:	000986        	j	4200ec98 <_vfprintf_r+0x1354>
4200ec71:	1a6e92        	s32i	a9, a14, 104
4200ec74:	881c      	movi.n	a8, 24
4200ec76:	062897        	blt	a8, a9, 4200ec80 <_vfprintf_r+0x133c>
4200ec79:	192e82        	l32i	a8, a14, 100
4200ec7c:	000446        	j	4200ec91 <_vfprintf_r+0x134d>
4200ec7f:	00          	.byte	00
4200ec80:	0128b7        	blt	a8, a11, 4200ec85 <_vfprintf_r+0x1341>
4200ec83:	492c      	movi.n	a9, 36
4200ec85:	10c182        	addi	a8, a1, 16
4200ec88:	02d882        	addmi	a8, a8, 0x200
4200ec8b:	182882        	l32i	a8, a8, 96
4200ec8e:	9e6192        	s32i	a9, a1, 0x278
4200ec91:	889a      	add.n	a8, a8, a9
4200ec93:	fcc882        	addi	a8, a8, -4
4200ec96:	0898      	l32i.n	a9, a8, 0
4200ec98:	ae2182        	l32i	a8, a1, 0x2b8
4200ec9b:	004982        	s8i	a8, a9, 0
4200ec9e:	ffd106        	j	4200ebe6 <_vfprintf_r+0x12a2>
4200eca1:	f4ac      	beqz.n	a4, 4200ecd4 <_vfprintf_r+0x1390>
4200eca3:	0aa687        	bge	a6, a8, 4200ecb1 <_vfprintf_r+0x136d>
4200eca6:	b0e6e0        	addx8	a14, a6, a14
4200eca9:	0e98      	l32i.n	a9, a14, 0
4200ecab:	0007c6        	j	4200ecce <_vfprintf_r+0x138a>
4200ecae:	000000        	ill
4200ecb1:	48a282        	movi	a8, 0x248
4200ecb4:	8e8a      	add.n	a8, a14, a8
4200ecb6:	4ca2d2        	movi	a13, 0x24c
4200ecb9:	60a2c2        	movi	a12, 0x260
4200ecbc:	0189      	s32i.n	a8, a1, 0
4200ecbe:	01def2        	addmi	a15, a14, 0x100
4200ecc1:	deda      	add.n	a13, a14, a13
4200ecc3:	ceca      	add.n	a12, a14, a12
4200ecc5:	05bd      	mov.n	a11, a5
4200ecc7:	06ad      	mov.n	a10, a6
4200ecc9:	fe7aa5        	call8	4200d474 <get_arg$isra$0>
4200eccc:	0a98      	l32i.n	a9, a10, 0
4200ecce:	07ad      	mov.n	a10, a7
4200ecd0:	001d06        	j	4200ed48 <_vfprintf_r+0x1404>
4200ecd3:	a71b00        	ee.stf.64.xp	f1, f10, a0, a11
4200ecd6:	07a787        	bge	a7, a8, 4200ece1 <_vfprintf_r+0x139d>
4200ecd9:	b0e6e0        	addx8	a14, a6, a14
4200ecdc:	0e98      	l32i.n	a9, a14, 0
4200ecde:	001986        	j	4200ed48 <_vfprintf_r+0x1404>
4200ece1:	9a2eb2        	l32i	a11, a14, 0x268
4200ece4:	fc1c      	movi.n	a12, 31
4200ece6:	02dee2        	addmi	a14, a14, 0x200
4200ece9:	9b4b      	addi.n	a9, a11, 4
4200eceb:	322c87        	blt	a12, a8, 4200ed21 <_vfprintf_r+0x13dd>
4200ecee:	c81b      	addi.n	a12, a8, 1
4200ecf0:	9761c2        	s32i	a12, a1, 0x25c
4200ecf3:	1a6e92        	s32i	a9, a14, 104
4200ecf6:	8c1c      	movi.n	a12, 24
4200ecf8:	052c97        	blt	a12, a9, 4200ed01 <_vfprintf_r+0x13bd>
4200ecfb:	192eb2        	l32i	a11, a14, 100
4200ecfe:	000406        	j	4200ed12 <_vfprintf_r+0x13ce>
4200ed01:	012cb7        	blt	a12, a11, 4200ed06 <_vfprintf_r+0x13c2>
4200ed04:	492c      	movi.n	a9, 36
4200ed06:	10c1b2        	addi	a11, a1, 16
4200ed09:	02dbb2        	addmi	a11, a11, 0x200
4200ed0c:	182bb2        	l32i	a11, a11, 96
4200ed0f:	9e6192        	s32i	a9, a1, 0x278
4200ed12:	bb9a      	add.n	a11, a11, a9
4200ed14:	fccbb2        	addi	a11, a11, -4
4200ed17:	0b98      	l32i.n	a9, a11, 0
4200ed19:	b08810        	addx8	a8, a8, a1
4200ed1c:	4899      	s32i.n	a9, a8, 16
4200ed1e:	000986        	j	4200ed48 <_vfprintf_r+0x1404>
4200ed21:	1a6e92        	s32i	a9, a14, 104
4200ed24:	881c      	movi.n	a8, 24
4200ed26:	062897        	blt	a8, a9, 4200ed30 <_vfprintf_r+0x13ec>
4200ed29:	192e82        	l32i	a8, a14, 100
4200ed2c:	000446        	j	4200ed41 <_vfprintf_r+0x13fd>
4200ed2f:	00          	.byte	00
4200ed30:	0128b7        	blt	a8, a11, 4200ed35 <_vfprintf_r+0x13f1>
4200ed33:	492c      	movi.n	a9, 36
4200ed35:	10c182        	addi	a8, a1, 16
4200ed38:	02d882        	addmi	a8, a8, 0x200
4200ed3b:	182882        	l32i	a8, a8, 96
4200ed3e:	9e6192        	s32i	a9, a1, 0x278
4200ed41:	889a      	add.n	a8, a8, a9
4200ed43:	fcc882        	addi	a8, a8, -4
4200ed46:	0898      	l32i.n	a9, a8, 0
4200ed48:	ae2182        	l32i	a8, a1, 0x2b8
4200ed4b:	0989      	s32i.n	a8, a9, 0
4200ed4d:	ffa546        	j	4200ebe6 <_vfprintf_r+0x12a2>
4200ed50:	081c      	movi.n	a8, 16
4200ed52:	203380        	or	a3, a3, a8
4200ed55:	972192        	l32i	a9, a1, 0x25c
4200ed58:	10c1e2        	addi	a14, a1, 16
4200ed5b:	02e357        	bbsi	a3, 5, 4200ed61 <_vfprintf_r+0x141d>
4200ed5e:	002fc6        	j	4200ee21 <_vfprintf_r+0x14dd>
4200ed61:	04bc      	beqz.n	a4, 4200ed95 <_vfprintf_r+0x1451>
4200ed63:	09a697        	bge	a6, a9, 4200ed70 <_vfprintf_r+0x142c>
4200ed66:	b0e6e0        	addx8	a14, a6, a14
4200ed69:	0e58      	l32i.n	a5, a14, 0
4200ed6b:	1e48      	l32i.n	a4, a14, 4
4200ed6d:	0007c6        	j	4200ed90 <_vfprintf_r+0x144c>
4200ed70:	48a282        	movi	a8, 0x248
4200ed73:	8e8a      	add.n	a8, a14, a8
4200ed75:	4ca2d2        	movi	a13, 0x24c
4200ed78:	60a2c2        	movi	a12, 0x260
4200ed7b:	05bd      	mov.n	a11, a5
4200ed7d:	0189      	s32i.n	a8, a1, 0
4200ed7f:	01def2        	addmi	a15, a14, 0x100
4200ed82:	deda      	add.n	a13, a14, a13
4200ed84:	ceca      	add.n	a12, a14, a12
4200ed86:	20a660        	or	a10, a6, a6
4200ed89:	fe6ea5        	call8	4200d474 <get_arg$isra$0>
4200ed8c:	0a58      	l32i.n	a5, a10, 0
4200ed8e:	1a48      	l32i.n	a4, a10, 4
4200ed90:	078d      	mov.n	a8, a7
4200ed92:	00a806        	j	4200f036 <_vfprintf_r+0x16f2>
4200ed95:	871b      	addi.n	a8, a7, 1
4200ed97:	09a797        	bge	a7, a9, 4200eda4 <_vfprintf_r+0x1460>
4200ed9a:	b0e6e0        	addx8	a14, a6, a14
4200ed9d:	0e58      	l32i.n	a5, a14, 0
4200ed9f:	1e48      	l32i.n	a4, a14, 4
4200eda1:	00a446        	j	4200f036 <_vfprintf_r+0x16f2>
4200eda4:	9a2eb2        	l32i	a11, a14, 0x268
4200eda7:	8a7c      	movi.n	a10, -8
4200eda9:	bb7b      	addi.n	a11, a11, 7
4200edab:	10bba0        	and	a11, a11, a10
4200edae:	fc1c      	movi.n	a12, 31
4200edb0:	02dee2        	addmi	a14, a14, 0x200
4200edb3:	ab8b      	addi.n	a10, a11, 8
4200edb5:	3b2c97        	blt	a12, a9, 4200edf4 <_vfprintf_r+0x14b0>
4200edb8:	c91b      	addi.n	a12, a9, 1
4200edba:	9761c2        	s32i	a12, a1, 0x25c
4200edbd:	1a6ea2        	s32i	a10, a14, 104
4200edc0:	8c1c      	movi.n	a12, 24
4200edc2:	062ca7        	blt	a12, a10, 4200edcc <_vfprintf_r+0x1488>
4200edc5:	192eb2        	l32i	a11, a14, 100
4200edc8:	000446        	j	4200eddd <_vfprintf_r+0x1499>
4200edcb:	00          	.byte	00
4200edcc:	012cb7        	blt	a12, a11, 4200edd1 <_vfprintf_r+0x148d>
4200edcf:	8a2c      	movi.n	a10, 40
4200edd1:	10c1b2        	addi	a11, a1, 16
4200edd4:	02dbb2        	addmi	a11, a11, 0x200
4200edd7:	182bb2        	l32i	a11, a11, 96
4200edda:	9e61a2        	s32i	a10, a1, 0x278
4200eddd:	abaa      	add.n	a10, a11, a10
4200eddf:	f8caa2        	addi	a10, a10, -8
4200ede2:	0a58      	l32i.n	a5, a10, 0
4200ede4:	1a48      	l32i.n	a4, a10, 4
4200ede6:	10c1a2        	addi	a10, a1, 16
4200ede9:	b099a0        	addx8	a9, a9, a10
4200edec:	0959      	s32i.n	a5, a9, 0
4200edee:	1949      	s32i.n	a4, a9, 4
4200edf0:	009086        	j	4200f036 <_vfprintf_r+0x16f2>
4200edf3:	00          	.byte	00
4200edf4:	1a6ea2        	s32i	a10, a14, 104
4200edf7:	891c      	movi.n	a9, 24
4200edf9:	0729a7        	blt	a9, a10, 4200ee04 <_vfprintf_r+0x14c0>
4200edfc:	192e92        	l32i	a9, a14, 100
4200edff:	000486        	j	4200ee15 <_vfprintf_r+0x14d1>
4200ee02:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200ee05:	0129      	s32i.n	a2, a1, 0
4200ee07:	8a2c      	movi.n	a10, 40
4200ee09:	10c192        	addi	a9, a1, 16
4200ee0c:	02d992        	addmi	a9, a9, 0x200
4200ee0f:	182992        	l32i	a9, a9, 96
4200ee12:	9e61a2        	s32i	a10, a1, 0x278
4200ee15:	99aa      	add.n	a9, a9, a10
4200ee17:	f8c992        	addi	a9, a9, -8
4200ee1a:	0958      	l32i.n	a5, a9, 0
4200ee1c:	1948      	l32i.n	a4, a9, 4
4200ee1e:	008506        	j	4200f036 <_vfprintf_r+0x16f2>
4200ee21:	036347        	bbci	a3, 4, 4200ee28 <_vfprintf_r+0x14e4>
4200ee24:	005a06        	j	4200ef90 <_vfprintf_r+0x164c>
4200ee27:	00          	.byte	00
4200ee28:	02e367        	bbsi	a3, 6, 4200ee2e <_vfprintf_r+0x14ea>
4200ee2b:	002b46        	j	4200eedc <_vfprintf_r+0x1598>
4200ee2e:	c4ac      	beqz.n	a4, 4200ee5e <_vfprintf_r+0x151a>
4200ee30:	09a697        	bge	a6, a9, 4200ee3d <_vfprintf_r+0x14f9>
4200ee33:	b0e6e0        	addx8	a14, a6, a14
4200ee36:	001e52        	l16ui	a5, a14, 0
4200ee39:	005f46        	j	4200efba <_vfprintf_r+0x1676>
4200ee3c:	a28200        	muluh	a8, a2, a0
4200ee3f:	8a48      	l32i.n	a4, a10, 32
4200ee41:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200ee45:	60a2c2        	movi	a12, 0x260
4200ee48:	05bd      	mov.n	a11, a5
4200ee4a:	0189      	s32i.n	a8, a1, 0
4200ee4c:	01def2        	addmi	a15, a14, 0x100
4200ee4f:	deda      	add.n	a13, a14, a13
4200ee51:	ceca      	add.n	a12, a14, a12
4200ee53:	06ad      	mov.n	a10, a6
4200ee55:	fe61e5        	call8	4200d474 <get_arg$isra$0>
4200ee58:	001a52        	l16ui	a5, a10, 0
4200ee5b:	0056c6        	j	4200efba <_vfprintf_r+0x1676>
4200ee5e:	871b      	addi.n	a8, a7, 1
4200ee60:	08a797        	bge	a7, a9, 4200ee6c <_vfprintf_r+0x1528>
4200ee63:	b0e6e0        	addx8	a14, a6, a14
4200ee66:	001e52        	l16ui	a5, a14, 0
4200ee69:	0071c6        	j	4200f034 <_vfprintf_r+0x16f0>
4200ee6c:	9a2eb2        	l32i	a11, a14, 0x268
4200ee6f:	fc1c      	movi.n	a12, 31
4200ee71:	02dee2        	addmi	a14, a14, 0x200
4200ee74:	ab4b      	addi.n	a10, a11, 4
4200ee76:	362c97        	blt	a12, a9, 4200eeb0 <_vfprintf_r+0x156c>
4200ee79:	c91b      	addi.n	a12, a9, 1
4200ee7b:	9761c2        	s32i	a12, a1, 0x25c
4200ee7e:	1a6ea2        	s32i	a10, a14, 104
4200ee81:	8c1c      	movi.n	a12, 24
4200ee83:	052ca7        	blt	a12, a10, 4200ee8c <_vfprintf_r+0x1548>
4200ee86:	192eb2        	l32i	a11, a14, 100
4200ee89:	000406        	j	4200ee9d <_vfprintf_r+0x1559>
4200ee8c:	012cb7        	blt	a12, a11, 4200ee91 <_vfprintf_r+0x154d>
4200ee8f:	4a2c      	movi.n	a10, 36
4200ee91:	10c1b2        	addi	a11, a1, 16
4200ee94:	02dbb2        	addmi	a11, a11, 0x200
4200ee97:	182bb2        	l32i	a11, a11, 96
4200ee9a:	9e61a2        	s32i	a10, a1, 0x278
4200ee9d:	bbaa      	add.n	a11, a11, a10
4200ee9f:	fccbb2        	addi	a11, a11, -4
4200eea2:	0b58      	l32i.n	a5, a11, 0
4200eea4:	b09910        	addx8	a9, a9, a1
4200eea7:	4959      	s32i.n	a5, a9, 16
4200eea9:	f45050        	extui	a5, a5, 0, 16
4200eeac:	006106        	j	4200f034 <_vfprintf_r+0x16f0>
4200eeaf:	00          	.byte	00
4200eeb0:	1a6ea2        	s32i	a10, a14, 104
4200eeb3:	891c      	movi.n	a9, 24
4200eeb5:	0729a7        	blt	a9, a10, 4200eec0 <_vfprintf_r+0x157c>
4200eeb8:	192e92        	l32i	a9, a14, 100
4200eebb:	000486        	j	4200eed1 <_vfprintf_r+0x158d>
4200eebe:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200eec1:	0129      	s32i.n	a2, a1, 0
4200eec3:	4a2c      	movi.n	a10, 36
4200eec5:	10c192        	addi	a9, a1, 16
4200eec8:	02d992        	addmi	a9, a9, 0x200
4200eecb:	182992        	l32i	a9, a9, 96
4200eece:	9e61a2        	s32i	a10, a1, 0x278
4200eed1:	99aa      	add.n	a9, a9, a10
4200eed3:	fcc992        	addi	a9, a9, -4
4200eed6:	001952        	l16ui	a5, a9, 0
4200eed9:	0055c6        	j	4200f034 <_vfprintf_r+0x16f0>
4200eedc:	02e397        	bbsi	a3, 9, 4200eee2 <_vfprintf_r+0x159e>
4200eedf:	002b46        	j	4200ef90 <_vfprintf_r+0x164c>
4200eee2:	c4ac      	beqz.n	a4, 4200ef12 <_vfprintf_r+0x15ce>
4200eee4:	09a697        	bge	a6, a9, 4200eef1 <_vfprintf_r+0x15ad>
4200eee7:	b0e6e0        	addx8	a14, a6, a14
4200eeea:	000e52        	l8ui	a5, a14, 0
4200eeed:	003246        	j	4200efba <_vfprintf_r+0x1676>
4200eef0:	a28200        	muluh	a8, a2, a0
4200eef3:	8a48      	l32i.n	a4, a10, 32
4200eef5:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200eef9:	60a2c2        	movi	a12, 0x260
4200eefc:	05bd      	mov.n	a11, a5
4200eefe:	0189      	s32i.n	a8, a1, 0
4200ef00:	01def2        	addmi	a15, a14, 0x100
4200ef03:	deda      	add.n	a13, a14, a13
4200ef05:	ceca      	add.n	a12, a14, a12
4200ef07:	06ad      	mov.n	a10, a6
4200ef09:	fe56a5        	call8	4200d474 <get_arg$isra$0>
4200ef0c:	000a52        	l8ui	a5, a10, 0
4200ef0f:	0029c6        	j	4200efba <_vfprintf_r+0x1676>
4200ef12:	871b      	addi.n	a8, a7, 1
4200ef14:	08a797        	bge	a7, a9, 4200ef20 <_vfprintf_r+0x15dc>
4200ef17:	b0e6e0        	addx8	a14, a6, a14
4200ef1a:	000e52        	l8ui	a5, a14, 0
4200ef1d:	0044c6        	j	4200f034 <_vfprintf_r+0x16f0>
4200ef20:	9a2eb2        	l32i	a11, a14, 0x268
4200ef23:	fc1c      	movi.n	a12, 31
4200ef25:	02dee2        	addmi	a14, a14, 0x200
4200ef28:	ab4b      	addi.n	a10, a11, 4
4200ef2a:	362c97        	blt	a12, a9, 4200ef64 <_vfprintf_r+0x1620>
4200ef2d:	c91b      	addi.n	a12, a9, 1
4200ef2f:	9761c2        	s32i	a12, a1, 0x25c
4200ef32:	1a6ea2        	s32i	a10, a14, 104
4200ef35:	8c1c      	movi.n	a12, 24
4200ef37:	052ca7        	blt	a12, a10, 4200ef40 <_vfprintf_r+0x15fc>
4200ef3a:	192eb2        	l32i	a11, a14, 100
4200ef3d:	000406        	j	4200ef51 <_vfprintf_r+0x160d>
4200ef40:	012cb7        	blt	a12, a11, 4200ef45 <_vfprintf_r+0x1601>
4200ef43:	4a2c      	movi.n	a10, 36
4200ef45:	10c1b2        	addi	a11, a1, 16
4200ef48:	02dbb2        	addmi	a11, a11, 0x200
4200ef4b:	182bb2        	l32i	a11, a11, 96
4200ef4e:	9e61a2        	s32i	a10, a1, 0x278
4200ef51:	bbaa      	add.n	a11, a11, a10
4200ef53:	fccbb2        	addi	a11, a11, -4
4200ef56:	0b58      	l32i.n	a5, a11, 0
4200ef58:	b09910        	addx8	a9, a9, a1
4200ef5b:	4959      	s32i.n	a5, a9, 16
4200ef5d:	745050        	extui	a5, a5, 0, 8
4200ef60:	003406        	j	4200f034 <_vfprintf_r+0x16f0>
4200ef63:	00          	.byte	00
4200ef64:	1a6ea2        	s32i	a10, a14, 104
4200ef67:	891c      	movi.n	a9, 24
4200ef69:	0729a7        	blt	a9, a10, 4200ef74 <_vfprintf_r+0x1630>
4200ef6c:	192e92        	l32i	a9, a14, 100
4200ef6f:	000486        	j	4200ef85 <_vfprintf_r+0x1641>
4200ef72:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200ef75:	0129      	s32i.n	a2, a1, 0
4200ef77:	4a2c      	movi.n	a10, 36
4200ef79:	10c192        	addi	a9, a1, 16
4200ef7c:	02d992        	addmi	a9, a9, 0x200
4200ef7f:	182992        	l32i	a9, a9, 96
4200ef82:	9e61a2        	s32i	a10, a1, 0x278
4200ef85:	99aa      	add.n	a9, a9, a10
4200ef87:	fcc992        	addi	a9, a9, -4
4200ef8a:	000952        	l8ui	a5, a9, 0
4200ef8d:	0028c6        	j	4200f034 <_vfprintf_r+0x16f0>
4200ef90:	c4ac      	beqz.n	a4, 4200efc0 <_vfprintf_r+0x167c>
4200ef92:	07a697        	bge	a6, a9, 4200ef9d <_vfprintf_r+0x1659>
4200ef95:	b0e6e0        	addx8	a14, a6, a14
4200ef98:	0e58      	l32i.n	a5, a14, 0
4200ef9a:	000706        	j	4200efba <_vfprintf_r+0x1676>
4200ef9d:	48a282        	movi	a8, 0x248
4200efa0:	8e8a      	add.n	a8, a14, a8
4200efa2:	4ca2d2        	movi	a13, 0x24c
4200efa5:	60a2c2        	movi	a12, 0x260
4200efa8:	05bd      	mov.n	a11, a5
4200efaa:	0189      	s32i.n	a8, a1, 0
4200efac:	01def2        	addmi	a15, a14, 0x100
4200efaf:	deda      	add.n	a13, a14, a13
4200efb1:	ceca      	add.n	a12, a14, a12
4200efb3:	06ad      	mov.n	a10, a6
4200efb5:	fe4be5        	call8	4200d474 <get_arg$isra$0>
4200efb8:	0a58      	l32i.n	a5, a10, 0
4200efba:	078d      	mov.n	a8, a7
4200efbc:	001d06        	j	4200f034 <_vfprintf_r+0x16f0>
4200efbf:	871b00        	ee.stf.64.xp	f1, f8, a0, a11
4200efc2:	07a797        	bge	a7, a9, 4200efcd <_vfprintf_r+0x1689>
4200efc5:	b0e6e0        	addx8	a14, a6, a14
4200efc8:	0e58      	l32i.n	a5, a14, 0
4200efca:	001986        	j	4200f034 <_vfprintf_r+0x16f0>
4200efcd:	9a2eb2        	l32i	a11, a14, 0x268
4200efd0:	fc1c      	movi.n	a12, 31
4200efd2:	02dee2        	addmi	a14, a14, 0x200
4200efd5:	ab4b      	addi.n	a10, a11, 4
4200efd7:	322c97        	blt	a12, a9, 4200f00d <_vfprintf_r+0x16c9>
4200efda:	c91b      	addi.n	a12, a9, 1
4200efdc:	9761c2        	s32i	a12, a1, 0x25c
4200efdf:	1a6ea2        	s32i	a10, a14, 104
4200efe2:	8c1c      	movi.n	a12, 24
4200efe4:	052ca7        	blt	a12, a10, 4200efed <_vfprintf_r+0x16a9>
4200efe7:	192eb2        	l32i	a11, a14, 100
4200efea:	000406        	j	4200effe <_vfprintf_r+0x16ba>
4200efed:	012cb7        	blt	a12, a11, 4200eff2 <_vfprintf_r+0x16ae>
4200eff0:	4a2c      	movi.n	a10, 36
4200eff2:	10c1b2        	addi	a11, a1, 16
4200eff5:	02dbb2        	addmi	a11, a11, 0x200
4200eff8:	182bb2        	l32i	a11, a11, 96
4200effb:	9e61a2        	s32i	a10, a1, 0x278
4200effe:	bbaa      	add.n	a11, a11, a10
4200f000:	fccbb2        	addi	a11, a11, -4
4200f003:	0b58      	l32i.n	a5, a11, 0
4200f005:	b09910        	addx8	a9, a9, a1
4200f008:	4959      	s32i.n	a5, a9, 16
4200f00a:	000986        	j	4200f034 <_vfprintf_r+0x16f0>
4200f00d:	1a6ea2        	s32i	a10, a14, 104
4200f010:	891c      	movi.n	a9, 24
4200f012:	0629a7        	blt	a9, a10, 4200f01c <_vfprintf_r+0x16d8>
4200f015:	192e92        	l32i	a9, a14, 100
4200f018:	000446        	j	4200f02d <_vfprintf_r+0x16e9>
4200f01b:	00          	.byte	00
4200f01c:	0129b7        	blt	a9, a11, 4200f021 <_vfprintf_r+0x16dd>
4200f01f:	4a2c      	movi.n	a10, 36
4200f021:	10c192        	addi	a9, a1, 16
4200f024:	02d992        	addmi	a9, a9, 0x200
4200f027:	182992        	l32i	a9, a9, 96
4200f02a:	9e61a2        	s32i	a10, a1, 0x278
4200f02d:	99aa      	add.n	a9, a9, a10
4200f02f:	fcc992        	addi	a9, a9, -4
4200f032:	0958      	l32i.n	a5, a9, 0
4200f034:	040c      	movi.n	a4, 0
4200f036:	ffab92        	movi	a9, 0xfffffbff
4200f039:	103390        	and	a3, a3, a9
4200f03c:	090c      	movi.n	a9, 0
4200f03e:	01f686        	j	4200f81c <_vfprintf_r+0x1ed8>
4200f041:	21a200        	srai	a10, a0, 2
4200f044:	c1e297        	bbsi	a2, 9, 4200f009 <_vfprintf_r+0x16c5>
4200f047:	c4ac10        	extui	a10, a1, 12, 13
4200f04a:	07a6a7        	bge	a6, a10, 4200f055 <_vfprintf_r+0x1711>
4200f04d:	b0e6e0        	addx8	a14, a6, a14
4200f050:	0e58      	l32i.n	a5, a14, 0
4200f052:	000706        	j	4200f072 <_vfprintf_r+0x172e>
4200f055:	48a282        	movi	a8, 0x248
4200f058:	8e8a      	add.n	a8, a14, a8
4200f05a:	4ca2d2        	movi	a13, 0x24c
4200f05d:	60a2c2        	movi	a12, 0x260
4200f060:	05bd      	mov.n	a11, a5
4200f062:	0189      	s32i.n	a8, a1, 0
4200f064:	01def2        	addmi	a15, a14, 0x100
4200f067:	deda      	add.n	a13, a14, a13
4200f069:	ceca      	add.n	a12, a14, a12
4200f06b:	06ad      	mov.n	a10, a6
4200f06d:	fe4065        	call8	4200d474 <get_arg$isra$0>
4200f070:	0a58      	l32i.n	a5, a10, 0
4200f072:	078d      	mov.n	a8, a7
4200f074:	001d06        	j	4200f0ec <_vfprintf_r+0x17a8>
4200f077:	871b00        	ee.stf.64.xp	f1, f8, a0, a11
4200f07a:	07a7a7        	bge	a7, a10, 4200f085 <_vfprintf_r+0x1741>
4200f07d:	b0e6e0        	addx8	a14, a6, a14
4200f080:	0e58      	l32i.n	a5, a14, 0
4200f082:	001986        	j	4200f0ec <_vfprintf_r+0x17a8>
4200f085:	9a2eb2        	l32i	a11, a14, 0x268
4200f088:	fc1c      	movi.n	a12, 31
4200f08a:	02dee2        	addmi	a14, a14, 0x200
4200f08d:	9b4b      	addi.n	a9, a11, 4
4200f08f:	322ca7        	blt	a12, a10, 4200f0c5 <_vfprintf_r+0x1781>
4200f092:	ca1b      	addi.n	a12, a10, 1
4200f094:	9761c2        	s32i	a12, a1, 0x25c
4200f097:	1a6e92        	s32i	a9, a14, 104
4200f09a:	8c1c      	movi.n	a12, 24
4200f09c:	052c97        	blt	a12, a9, 4200f0a5 <_vfprintf_r+0x1761>
4200f09f:	192eb2        	l32i	a11, a14, 100
4200f0a2:	000406        	j	4200f0b6 <_vfprintf_r+0x1772>
4200f0a5:	012cb7        	blt	a12, a11, 4200f0aa <_vfprintf_r+0x1766>
4200f0a8:	492c      	movi.n	a9, 36
4200f0aa:	10c1b2        	addi	a11, a1, 16
4200f0ad:	02dbb2        	addmi	a11, a11, 0x200
4200f0b0:	182bb2        	l32i	a11, a11, 96
4200f0b3:	9e6192        	s32i	a9, a1, 0x278
4200f0b6:	bb9a      	add.n	a11, a11, a9
4200f0b8:	fccbb2        	addi	a11, a11, -4
4200f0bb:	0b58      	l32i.n	a5, a11, 0
4200f0bd:	b09a10        	addx8	a9, a10, a1
4200f0c0:	4959      	s32i.n	a5, a9, 16
4200f0c2:	000986        	j	4200f0ec <_vfprintf_r+0x17a8>
4200f0c5:	1a6e92        	s32i	a9, a14, 104
4200f0c8:	8a1c      	movi.n	a10, 24
4200f0ca:	062a97        	blt	a10, a9, 4200f0d4 <_vfprintf_r+0x1790>
4200f0cd:	192ea2        	l32i	a10, a14, 100
4200f0d0:	000446        	j	4200f0e5 <_vfprintf_r+0x17a1>
4200f0d3:	2ab700        	mul.s	f11, f7, f0
4200f0d6:	492c01        	l32r	a0, 41fe1588 <_iram_bss_end+0x1c5f188>
4200f0d9:	10c1a2        	addi	a10, a1, 16
4200f0dc:	02daa2        	addmi	a10, a10, 0x200
4200f0df:	182aa2        	l32i	a10, a10, 96
4200f0e2:	9e6192        	s32i	a9, a1, 0x278
4200f0e5:	aa9a      	add.n	a10, a10, a9
4200f0e7:	fccaa2        	addi	a10, a10, -4
4200f0ea:	0a58      	l32i.n	a5, a10, 0
4200f0ec:	290c      	movi.n	a9, 2
4200f0ee:	203390        	or	a3, a3, a9
4200f0f1:	10c192        	addi	a9, a1, 16
4200f0f4:	02d992        	addmi	a9, a9, 0x200
4200f0f7:	0a3c      	movi.n	a10, 48
4200f0f9:	5049a2        	s8i	a10, a9, 80
4200f0fc:	78a0a2        	movi	a10, 120
4200f0ff:	5149a2        	s8i	a10, a9, 81
4200f102:	c76991        	l32r	a9, 42000ea8 <_stext+0xe88> (3c0286f4 <blanks$1+0x20>)
4200f105:	78a0a2        	movi	a10, 120
4200f108:	b86192        	s32i	a9, a1, 0x2e0
4200f10b:	040c      	movi.n	a4, 0
4200f10d:	290c      	movi.n	a9, 2
4200f10f:	a361a2        	s32i	a10, a1, 0x28c
4200f112:	01c186        	j	4200f81c <_vfprintf_r+0x1ed8>
4200f115:	219200        	srai	a9, a0, 2
4200f118:	c1e297        	bbsi	a2, 9, 4200f0dd <_vfprintf_r+0x1799>
4200f11b:	c4ac10        	extui	a10, a1, 12, 13
4200f11e:	07a697        	bge	a6, a9, 4200f129 <_vfprintf_r+0x17e5>
4200f121:	b0e6e0        	addx8	a14, a6, a14
4200f124:	0e88      	l32i.n	a8, a14, 0
4200f126:	000706        	j	4200f146 <_vfprintf_r+0x1802>
4200f129:	48a282        	movi	a8, 0x248
4200f12c:	8e8a      	add.n	a8, a14, a8
4200f12e:	4ca2d2        	movi	a13, 0x24c
4200f131:	60a2c2        	movi	a12, 0x260
4200f134:	0189      	s32i.n	a8, a1, 0
4200f136:	01def2        	addmi	a15, a14, 0x100
4200f139:	deda      	add.n	a13, a14, a13
4200f13b:	ceca      	add.n	a12, a14, a12
4200f13d:	05bd      	mov.n	a11, a5
4200f13f:	06ad      	mov.n	a10, a6
4200f141:	fe3325        	call8	4200d474 <get_arg$isra$0>
4200f144:	0a88      	l32i.n	a8, a10, 0
4200f146:	9f6182        	s32i	a8, a1, 0x27c
4200f149:	002006        	j	4200f1cd <_vfprintf_r+0x1889>
4200f14c:	a71b      	addi.n	a10, a7, 1
4200f14e:	07a797        	bge	a7, a9, 4200f159 <_vfprintf_r+0x1815>
4200f151:	b0e6e0        	addx8	a14, a6, a14
4200f154:	0e88      	l32i.n	a8, a14, 0
4200f156:	001b86        	j	4200f1c8 <_vfprintf_r+0x1884>
4200f159:	9a2eb2        	l32i	a11, a14, 0x268
4200f15c:	fc1c      	movi.n	a12, 31
4200f15e:	02dee2        	addmi	a14, a14, 0x200
4200f161:	8b4b      	addi.n	a8, a11, 4
4200f163:	392c97        	blt	a12, a9, 4200f1a0 <_vfprintf_r+0x185c>
4200f166:	c91b      	addi.n	a12, a9, 1
4200f168:	9761c2        	s32i	a12, a1, 0x25c
4200f16b:	1a6e82        	s32i	a8, a14, 104
4200f16e:	8c1c      	movi.n	a12, 24
4200f170:	052c87        	blt	a12, a8, 4200f179 <_vfprintf_r+0x1835>
4200f173:	192eb2        	l32i	a11, a14, 100
4200f176:	000406        	j	4200f18a <_vfprintf_r+0x1846>
4200f179:	012cb7        	blt	a12, a11, 4200f17e <_vfprintf_r+0x183a>
4200f17c:	482c      	movi.n	a8, 36
4200f17e:	10c1b2        	addi	a11, a1, 16
4200f181:	02dbb2        	addmi	a11, a11, 0x200
4200f184:	182bb2        	l32i	a11, a11, 96
4200f187:	9e6182        	s32i	a8, a1, 0x278
4200f18a:	bb8a      	add.n	a11, a11, a8
4200f18c:	fccbb2        	addi	a11, a11, -4
4200f18f:	0b88      	l32i.n	a8, a11, 0
4200f191:	9f6182        	s32i	a8, a1, 0x27c
4200f194:	b08910        	addx8	a8, a9, a1
4200f197:	9f2192        	l32i	a9, a1, 0x27c
4200f19a:	4899      	s32i.n	a9, a8, 16
4200f19c:	000ac6        	j	4200f1cb <_vfprintf_r+0x1887>
4200f19f:	00          	.byte	00
4200f1a0:	1a6e82        	s32i	a8, a14, 104
4200f1a3:	891c      	movi.n	a9, 24
4200f1a5:	072987        	blt	a9, a8, 4200f1b0 <_vfprintf_r+0x186c>
4200f1a8:	192e92        	l32i	a9, a14, 100
4200f1ab:	000486        	j	4200f1c1 <_vfprintf_r+0x187d>
4200f1ae:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200f1b1:	0129      	s32i.n	a2, a1, 0
4200f1b3:	482c      	movi.n	a8, 36
4200f1b5:	10c192        	addi	a9, a1, 16
4200f1b8:	02d992        	addmi	a9, a9, 0x200
4200f1bb:	182992        	l32i	a9, a9, 96
4200f1be:	9e6182        	s32i	a8, a1, 0x278
4200f1c1:	998a      	add.n	a9, a9, a8
4200f1c3:	fcc992        	addi	a9, a9, -4
4200f1c6:	0988      	l32i.n	a8, a9, 0
4200f1c8:	9f6182        	s32i	a8, a1, 0x27c
4200f1cb:	0a7d      	mov.n	a7, a10
4200f1cd:	10c182        	addi	a8, a1, 16
4200f1d0:	02d882        	addmi	a8, a8, 0x200
4200f1d3:	090c      	movi.n	a9, 0
4200f1d5:	524892        	s8i	a9, a8, 82
4200f1d8:	a22182        	l32i	a8, a1, 0x288
4200f1db:	021896        	bltz	a8, 4200f200 <_vfprintf_r+0x18bc>
4200f1de:	9f21a2        	l32i	a10, a1, 0x27c
4200f1e1:	08cd      	mov.n	a12, a8
4200f1e3:	00a0b2        	movi	a11, 0
4200f1e6:	c72281        	l32r	a8, 42000e70 <_stext+0xe50> (40001344 <memchr>)
4200f1e9:	0008e0        	callx8	a8
4200f1ec:	a961a2        	s32i	a10, a1, 0x2a4
4200f1ef:	1acc      	bnez.n	a10, 4200f1f4 <_vfprintf_r+0x18b0>
4200f1f1:	020f46        	j	4200fa32 <_vfprintf_r+0x20ee>
4200f1f4:	9f2192        	l32i	a9, a1, 0x27c
4200f1f7:	c08a90        	sub	a8, a10, a9
4200f1fa:	a26182        	s32i	a8, a1, 0x288
4200f1fd:	0002c6        	j	4200f20c <_vfprintf_r+0x18c8>
4200f200:	9f21a2        	l32i	a10, a1, 0x27c
4200f203:	c43881        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
4200f206:	0008e0        	callx8	a8
4200f209:	a261a2        	s32i	a10, a1, 0x288
4200f20c:	080c      	movi.n	a8, 0
4200f20e:	a96182        	s32i	a8, a1, 0x2a4
4200f211:	040c      	movi.n	a4, 0
4200f213:	0207c6        	j	4200fa36 <_vfprintf_r+0x20f2>
4200f216:	081c      	movi.n	a8, 16
4200f218:	203380        	or	a3, a3, a8
4200f21b:	972192        	l32i	a9, a1, 0x25c
4200f21e:	10c1e2        	addi	a14, a1, 16
4200f221:	02e357        	bbsi	a3, 5, 4200f227 <_vfprintf_r+0x18e3>
4200f224:	002f46        	j	4200f2e5 <_vfprintf_r+0x19a1>
4200f227:	f4ac      	beqz.n	a4, 4200f25a <_vfprintf_r+0x1916>
4200f229:	09a697        	bge	a6, a9, 4200f236 <_vfprintf_r+0x18f2>
4200f22c:	b0e6e0        	addx8	a14, a6, a14
4200f22f:	0e58      	l32i.n	a5, a14, 0
4200f231:	1e48      	l32i.n	a4, a14, 4
4200f233:	000786        	j	4200f255 <_vfprintf_r+0x1911>
4200f236:	48a282        	movi	a8, 0x248
4200f239:	8e8a      	add.n	a8, a14, a8
4200f23b:	4ca2d2        	movi	a13, 0x24c
4200f23e:	60a2c2        	movi	a12, 0x260
4200f241:	05bd      	mov.n	a11, a5
4200f243:	0189      	s32i.n	a8, a1, 0
4200f245:	01def2        	addmi	a15, a14, 0x100
4200f248:	deda      	add.n	a13, a14, a13
4200f24a:	ceca      	add.n	a12, a14, a12
4200f24c:	06ad      	mov.n	a10, a6
4200f24e:	fe2265        	call8	4200d474 <get_arg$isra$0>
4200f251:	0a58      	l32i.n	a5, a10, 0
4200f253:	1a48      	l32i.n	a4, a10, 4
4200f255:	078d      	mov.n	a8, a7
4200f257:	007e06        	j	4200f453 <_vfprintf_r+0x1b0f>
4200f25a:	871b      	addi.n	a8, a7, 1
4200f25c:	09a797        	bge	a7, a9, 4200f269 <_vfprintf_r+0x1925>
4200f25f:	b0e6e0        	addx8	a14, a6, a14
4200f262:	0e58      	l32i.n	a5, a14, 0
4200f264:	1e48      	l32i.n	a4, a14, 4
4200f266:	007a46        	j	4200f453 <_vfprintf_r+0x1b0f>
4200f269:	9a2eb2        	l32i	a11, a14, 0x268
4200f26c:	8a7c      	movi.n	a10, -8
4200f26e:	bb7b      	addi.n	a11, a11, 7
4200f270:	10bba0        	and	a11, a11, a10
4200f273:	fc1c      	movi.n	a12, 31
4200f275:	02dee2        	addmi	a14, a14, 0x200
4200f278:	ab8b      	addi.n	a10, a11, 8
4200f27a:	3a2c97        	blt	a12, a9, 4200f2b8 <_vfprintf_r+0x1974>
4200f27d:	c91b      	addi.n	a12, a9, 1
4200f27f:	9761c2        	s32i	a12, a1, 0x25c
4200f282:	1a6ea2        	s32i	a10, a14, 104
4200f285:	8c1c      	movi.n	a12, 24
4200f287:	052ca7        	blt	a12, a10, 4200f290 <_vfprintf_r+0x194c>
4200f28a:	192eb2        	l32i	a11, a14, 100
4200f28d:	000406        	j	4200f2a1 <_vfprintf_r+0x195d>
4200f290:	012cb7        	blt	a12, a11, 4200f295 <_vfprintf_r+0x1951>
4200f293:	8a2c      	movi.n	a10, 40
4200f295:	10c1b2        	addi	a11, a1, 16
4200f298:	02dbb2        	addmi	a11, a11, 0x200
4200f29b:	182bb2        	l32i	a11, a11, 96
4200f29e:	9e61a2        	s32i	a10, a1, 0x278
4200f2a1:	abaa      	add.n	a10, a11, a10
4200f2a3:	f8caa2        	addi	a10, a10, -8
4200f2a6:	0a58      	l32i.n	a5, a10, 0
4200f2a8:	1a48      	l32i.n	a4, a10, 4
4200f2aa:	10c1a2        	addi	a10, a1, 16
4200f2ad:	b099a0        	addx8	a9, a9, a10
4200f2b0:	0959      	s32i.n	a5, a9, 0
4200f2b2:	1949      	s32i.n	a4, a9, 4
4200f2b4:	0066c6        	j	4200f453 <_vfprintf_r+0x1b0f>
4200f2b7:	00          	.byte	00
4200f2b8:	1a6ea2        	s32i	a10, a14, 104
4200f2bb:	891c      	movi.n	a9, 24
4200f2bd:	0729a7        	blt	a9, a10, 4200f2c8 <_vfprintf_r+0x1984>
4200f2c0:	192e92        	l32i	a9, a14, 100
4200f2c3:	000486        	j	4200f2d9 <_vfprintf_r+0x1995>
4200f2c6:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200f2c9:	0129      	s32i.n	a2, a1, 0
4200f2cb:	8a2c      	movi.n	a10, 40
4200f2cd:	10c192        	addi	a9, a1, 16
4200f2d0:	02d992        	addmi	a9, a9, 0x200
4200f2d3:	182992        	l32i	a9, a9, 96
4200f2d6:	9e61a2        	s32i	a10, a1, 0x278
4200f2d9:	99aa      	add.n	a9, a9, a10
4200f2db:	f8c992        	addi	a9, a9, -8
4200f2de:	0958      	l32i.n	a5, a9, 0
4200f2e0:	1948      	l32i.n	a4, a9, 4
4200f2e2:	005b46        	j	4200f453 <_vfprintf_r+0x1b0f>
4200f2e5:	036347        	bbci	a3, 4, 4200f2ec <_vfprintf_r+0x19a8>
4200f2e8:	005b06        	j	4200f458 <_vfprintf_r+0x1b14>
4200f2eb:	00          	.byte	00
4200f2ec:	02e367        	bbsi	a3, 6, 4200f2f2 <_vfprintf_r+0x19ae>
4200f2ef:	002b46        	j	4200f3a0 <_vfprintf_r+0x1a5c>
4200f2f2:	c4ac      	beqz.n	a4, 4200f322 <_vfprintf_r+0x19de>
4200f2f4:	09a697        	bge	a6, a9, 4200f301 <_vfprintf_r+0x19bd>
4200f2f7:	b0e6e0        	addx8	a14, a6, a14
4200f2fa:	001e52        	l16ui	a5, a14, 0
4200f2fd:	006046        	j	4200f482 <_vfprintf_r+0x1b3e>
4200f300:	a28200        	muluh	a8, a2, a0
4200f303:	8a48      	l32i.n	a4, a10, 32
4200f305:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200f309:	60a2c2        	movi	a12, 0x260
4200f30c:	05bd      	mov.n	a11, a5
4200f30e:	0189      	s32i.n	a8, a1, 0
4200f310:	01def2        	addmi	a15, a14, 0x100
4200f313:	deda      	add.n	a13, a14, a13
4200f315:	ceca      	add.n	a12, a14, a12
4200f317:	06ad      	mov.n	a10, a6
4200f319:	fe15a5        	call8	4200d474 <get_arg$isra$0>
4200f31c:	001a52        	l16ui	a5, a10, 0
4200f31f:	0057c6        	j	4200f482 <_vfprintf_r+0x1b3e>
4200f322:	871b      	addi.n	a8, a7, 1
4200f324:	08a797        	bge	a7, a9, 4200f330 <_vfprintf_r+0x19ec>
4200f327:	b0e6e0        	addx8	a14, a6, a14
4200f32a:	001e52        	l16ui	a5, a14, 0
4200f32d:	004806        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f330:	9a2eb2        	l32i	a11, a14, 0x268
4200f333:	fc1c      	movi.n	a12, 31
4200f335:	02dee2        	addmi	a14, a14, 0x200
4200f338:	ab4b      	addi.n	a10, a11, 4
4200f33a:	362c97        	blt	a12, a9, 4200f374 <_vfprintf_r+0x1a30>
4200f33d:	c91b      	addi.n	a12, a9, 1
4200f33f:	9761c2        	s32i	a12, a1, 0x25c
4200f342:	1a6ea2        	s32i	a10, a14, 104
4200f345:	8c1c      	movi.n	a12, 24
4200f347:	052ca7        	blt	a12, a10, 4200f350 <_vfprintf_r+0x1a0c>
4200f34a:	192eb2        	l32i	a11, a14, 100
4200f34d:	000406        	j	4200f361 <_vfprintf_r+0x1a1d>
4200f350:	012cb7        	blt	a12, a11, 4200f355 <_vfprintf_r+0x1a11>
4200f353:	4a2c      	movi.n	a10, 36
4200f355:	10c1b2        	addi	a11, a1, 16
4200f358:	02dbb2        	addmi	a11, a11, 0x200
4200f35b:	182bb2        	l32i	a11, a11, 96
4200f35e:	9e61a2        	s32i	a10, a1, 0x278
4200f361:	bbaa      	add.n	a11, a11, a10
4200f363:	fccbb2        	addi	a11, a11, -4
4200f366:	0b58      	l32i.n	a5, a11, 0
4200f368:	b09910        	addx8	a9, a9, a1
4200f36b:	4959      	s32i.n	a5, a9, 16
4200f36d:	f45050        	extui	a5, a5, 0, 16
4200f370:	003746        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f373:	00          	.byte	00
4200f374:	1a6ea2        	s32i	a10, a14, 104
4200f377:	891c      	movi.n	a9, 24
4200f379:	0729a7        	blt	a9, a10, 4200f384 <_vfprintf_r+0x1a40>
4200f37c:	192e92        	l32i	a9, a14, 100
4200f37f:	000486        	j	4200f395 <_vfprintf_r+0x1a51>
4200f382:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200f385:	0129      	s32i.n	a2, a1, 0
4200f387:	4a2c      	movi.n	a10, 36
4200f389:	10c192        	addi	a9, a1, 16
4200f38c:	02d992        	addmi	a9, a9, 0x200
4200f38f:	182992        	l32i	a9, a9, 96
4200f392:	9e61a2        	s32i	a10, a1, 0x278
4200f395:	99aa      	add.n	a9, a9, a10
4200f397:	fcc992        	addi	a9, a9, -4
4200f39a:	001952        	l16ui	a5, a9, 0
4200f39d:	002c06        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f3a0:	02e397        	bbsi	a3, 9, 4200f3a6 <_vfprintf_r+0x1a62>
4200f3a3:	002c46        	j	4200f458 <_vfprintf_r+0x1b14>
4200f3a6:	c4ac      	beqz.n	a4, 4200f3d6 <_vfprintf_r+0x1a92>
4200f3a8:	09a697        	bge	a6, a9, 4200f3b5 <_vfprintf_r+0x1a71>
4200f3ab:	b0e6e0        	addx8	a14, a6, a14
4200f3ae:	000e52        	l8ui	a5, a14, 0
4200f3b1:	003346        	j	4200f482 <_vfprintf_r+0x1b3e>
4200f3b4:	a28200        	muluh	a8, a2, a0
4200f3b7:	8a48      	l32i.n	a4, a10, 32
4200f3b9:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200f3bd:	60a2c2        	movi	a12, 0x260
4200f3c0:	05bd      	mov.n	a11, a5
4200f3c2:	0189      	s32i.n	a8, a1, 0
4200f3c4:	01def2        	addmi	a15, a14, 0x100
4200f3c7:	deda      	add.n	a13, a14, a13
4200f3c9:	ceca      	add.n	a12, a14, a12
4200f3cb:	06ad      	mov.n	a10, a6
4200f3cd:	fe0a65        	call8	4200d474 <get_arg$isra$0>
4200f3d0:	000a52        	l8ui	a5, a10, 0
4200f3d3:	002ac6        	j	4200f482 <_vfprintf_r+0x1b3e>
4200f3d6:	871b      	addi.n	a8, a7, 1
4200f3d8:	08a797        	bge	a7, a9, 4200f3e4 <_vfprintf_r+0x1aa0>
4200f3db:	b0e6e0        	addx8	a14, a6, a14
4200f3de:	000e52        	l8ui	a5, a14, 0
4200f3e1:	001b06        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f3e4:	9a2eb2        	l32i	a11, a14, 0x268
4200f3e7:	fc1c      	movi.n	a12, 31
4200f3e9:	02dee2        	addmi	a14, a14, 0x200
4200f3ec:	ab4b      	addi.n	a10, a11, 4
4200f3ee:	362c97        	blt	a12, a9, 4200f428 <_vfprintf_r+0x1ae4>
4200f3f1:	c91b      	addi.n	a12, a9, 1
4200f3f3:	9761c2        	s32i	a12, a1, 0x25c
4200f3f6:	1a6ea2        	s32i	a10, a14, 104
4200f3f9:	8c1c      	movi.n	a12, 24
4200f3fb:	052ca7        	blt	a12, a10, 4200f404 <_vfprintf_r+0x1ac0>
4200f3fe:	192eb2        	l32i	a11, a14, 100
4200f401:	000406        	j	4200f415 <_vfprintf_r+0x1ad1>
4200f404:	012cb7        	blt	a12, a11, 4200f409 <_vfprintf_r+0x1ac5>
4200f407:	4a2c      	movi.n	a10, 36
4200f409:	10c1b2        	addi	a11, a1, 16
4200f40c:	02dbb2        	addmi	a11, a11, 0x200
4200f40f:	182bb2        	l32i	a11, a11, 96
4200f412:	9e61a2        	s32i	a10, a1, 0x278
4200f415:	bbaa      	add.n	a11, a11, a10
4200f417:	fccbb2        	addi	a11, a11, -4
4200f41a:	0b58      	l32i.n	a5, a11, 0
4200f41c:	b09910        	addx8	a9, a9, a1
4200f41f:	4959      	s32i.n	a5, a9, 16
4200f421:	745050        	extui	a5, a5, 0, 8
4200f424:	000a46        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f427:	00          	.byte	00
4200f428:	1a6ea2        	s32i	a10, a14, 104
4200f42b:	891c      	movi.n	a9, 24
4200f42d:	0729a7        	blt	a9, a10, 4200f438 <_vfprintf_r+0x1af4>
4200f430:	192e92        	l32i	a9, a14, 100
4200f433:	000486        	j	4200f449 <_vfprintf_r+0x1b05>
4200f436:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200f439:	0129      	s32i.n	a2, a1, 0
4200f43b:	4a2c      	movi.n	a10, 36
4200f43d:	10c192        	addi	a9, a1, 16
4200f440:	02d992        	addmi	a9, a9, 0x200
4200f443:	182992        	l32i	a9, a9, 96
4200f446:	9e61a2        	s32i	a10, a1, 0x278
4200f449:	99aa      	add.n	a9, a9, a10
4200f44b:	fcc992        	addi	a9, a9, -4
4200f44e:	000952        	l8ui	a5, a9, 0
4200f451:	040c      	movi.n	a4, 0
4200f453:	190c      	movi.n	a9, 1
4200f455:	00f0c6        	j	4200f81c <_vfprintf_r+0x1ed8>
4200f458:	c4ac      	beqz.n	a4, 4200f488 <_vfprintf_r+0x1b44>
4200f45a:	07a697        	bge	a6, a9, 4200f465 <_vfprintf_r+0x1b21>
4200f45d:	b0e6e0        	addx8	a14, a6, a14
4200f460:	0e58      	l32i.n	a5, a14, 0
4200f462:	000706        	j	4200f482 <_vfprintf_r+0x1b3e>
4200f465:	48a282        	movi	a8, 0x248
4200f468:	8e8a      	add.n	a8, a14, a8
4200f46a:	4ca2d2        	movi	a13, 0x24c
4200f46d:	60a2c2        	movi	a12, 0x260
4200f470:	05bd      	mov.n	a11, a5
4200f472:	0189      	s32i.n	a8, a1, 0
4200f474:	01def2        	addmi	a15, a14, 0x100
4200f477:	deda      	add.n	a13, a14, a13
4200f479:	ceca      	add.n	a12, a14, a12
4200f47b:	06ad      	mov.n	a10, a6
4200f47d:	fdff65        	call8	4200d474 <get_arg$isra$0>
4200f480:	0a58      	l32i.n	a5, a10, 0
4200f482:	078d      	mov.n	a8, a7
4200f484:	fff246        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f487:	871b00        	ee.stf.64.xp	f1, f8, a0, a11
4200f48a:	07a797        	bge	a7, a9, 4200f495 <_vfprintf_r+0x1b51>
4200f48d:	b0e6e0        	addx8	a14, a6, a14
4200f490:	0e58      	l32i.n	a5, a14, 0
4200f492:	ffeec6        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f495:	9a2eb2        	l32i	a11, a14, 0x268
4200f498:	fc1c      	movi.n	a12, 31
4200f49a:	02dee2        	addmi	a14, a14, 0x200
4200f49d:	ab4b      	addi.n	a10, a11, 4
4200f49f:	322c97        	blt	a12, a9, 4200f4d5 <_vfprintf_r+0x1b91>
4200f4a2:	c91b      	addi.n	a12, a9, 1
4200f4a4:	9761c2        	s32i	a12, a1, 0x25c
4200f4a7:	1a6ea2        	s32i	a10, a14, 104
4200f4aa:	8c1c      	movi.n	a12, 24
4200f4ac:	052ca7        	blt	a12, a10, 4200f4b5 <_vfprintf_r+0x1b71>
4200f4af:	192eb2        	l32i	a11, a14, 100
4200f4b2:	000406        	j	4200f4c6 <_vfprintf_r+0x1b82>
4200f4b5:	012cb7        	blt	a12, a11, 4200f4ba <_vfprintf_r+0x1b76>
4200f4b8:	4a2c      	movi.n	a10, 36
4200f4ba:	10c1b2        	addi	a11, a1, 16
4200f4bd:	02dbb2        	addmi	a11, a11, 0x200
4200f4c0:	182bb2        	l32i	a11, a11, 96
4200f4c3:	9e61a2        	s32i	a10, a1, 0x278
4200f4c6:	bbaa      	add.n	a11, a11, a10
4200f4c8:	fccbb2        	addi	a11, a11, -4
4200f4cb:	0b58      	l32i.n	a5, a11, 0
4200f4cd:	b09910        	addx8	a9, a9, a1
4200f4d0:	4959      	s32i.n	a5, a9, 16
4200f4d2:	ffdec6        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f4d5:	1a6ea2        	s32i	a10, a14, 104
4200f4d8:	891c      	movi.n	a9, 24
4200f4da:	0629a7        	blt	a9, a10, 4200f4e4 <_vfprintf_r+0x1ba0>
4200f4dd:	192e92        	l32i	a9, a14, 100
4200f4e0:	000446        	j	4200f4f5 <_vfprintf_r+0x1bb1>
4200f4e3:	00          	.byte	00
4200f4e4:	0129b7        	blt	a9, a11, 4200f4e9 <_vfprintf_r+0x1ba5>
4200f4e7:	4a2c      	movi.n	a10, 36
4200f4e9:	10c192        	addi	a9, a1, 16
4200f4ec:	02d992        	addmi	a9, a9, 0x200
4200f4ef:	182992        	l32i	a9, a9, 96
4200f4f2:	9e61a2        	s32i	a10, a1, 0x278
4200f4f5:	99aa      	add.n	a9, a9, a10
4200f4f7:	fcc992        	addi	a9, a9, -4
4200f4fa:	0958      	l32i.n	a5, a9, 0
4200f4fc:	ffd446        	j	4200f451 <_vfprintf_r+0x1b0d>
4200f4ff:	6b8100        	ole.s	b8, f1, f0
4200f502:	6182c6        	j	42027b11 <_etext+0xe3db>
4200f505:	92b8      	l32i.n	a11, a2, 36
4200f507:	e29721        	l32r	a2, 42007f64 <vector_test_mul_shift+0x124> (6881e245 <_rtc_reserved_end+0x871e245>)
4200f50a:	5710c1        	l32r	a12, 41fe514c <_iram_bss_end+0x1c62d4c>
4200f50d:	4602e3        	lsi	f14, a2, 0x118
4200f510:	2f          	.byte	0x2f
4200f511:	f4ac00        	extui	a10, a0, 12, 16
4200f514:	09a697        	bge	a6, a9, 4200f521 <_vfprintf_r+0x1bdd>
4200f517:	b0e6e0        	addx8	a14, a6, a14
4200f51a:	0e58      	l32i.n	a5, a14, 0
4200f51c:	1e48      	l32i.n	a4, a14, 4
4200f51e:	000786        	j	4200f540 <_vfprintf_r+0x1bfc>
4200f521:	48a282        	movi	a8, 0x248
4200f524:	8e8a      	add.n	a8, a14, a8
4200f526:	4ca2d2        	movi	a13, 0x24c
4200f529:	60a2c2        	movi	a12, 0x260
4200f52c:	05bd      	mov.n	a11, a5
4200f52e:	0189      	s32i.n	a8, a1, 0
4200f530:	01def2        	addmi	a15, a14, 0x100
4200f533:	deda      	add.n	a13, a14, a13
4200f535:	ceca      	add.n	a12, a14, a12
4200f537:	06ad      	mov.n	a10, a6
4200f539:	fdf3a5        	call8	4200d474 <get_arg$isra$0>
4200f53c:	0a58      	l32i.n	a5, a10, 0
4200f53e:	1a48      	l32i.n	a4, a10, 4
4200f540:	078d      	mov.n	a8, a7
4200f542:	00ac06        	j	4200f7f6 <_vfprintf_r+0x1eb2>
4200f545:	871b      	addi.n	a8, a7, 1
4200f547:	09a797        	bge	a7, a9, 4200f554 <_vfprintf_r+0x1c10>
4200f54a:	b0e6e0        	addx8	a14, a6, a14
4200f54d:	0e58      	l32i.n	a5, a14, 0
4200f54f:	1e48      	l32i.n	a4, a14, 4
4200f551:	00a846        	j	4200f7f6 <_vfprintf_r+0x1eb2>
4200f554:	9a2eb2        	l32i	a11, a14, 0x268
4200f557:	8a7c      	movi.n	a10, -8
4200f559:	bb7b      	addi.n	a11, a11, 7
4200f55b:	10bba0        	and	a11, a11, a10
4200f55e:	fc1c      	movi.n	a12, 31
4200f560:	02dee2        	addmi	a14, a14, 0x200
4200f563:	ab8b      	addi.n	a10, a11, 8
4200f565:	3a2c97        	blt	a12, a9, 4200f5a3 <_vfprintf_r+0x1c5f>
4200f568:	c91b      	addi.n	a12, a9, 1
4200f56a:	9761c2        	s32i	a12, a1, 0x25c
4200f56d:	1a6ea2        	s32i	a10, a14, 104
4200f570:	8c1c      	movi.n	a12, 24
4200f572:	062ca7        	blt	a12, a10, 4200f57c <_vfprintf_r+0x1c38>
4200f575:	192eb2        	l32i	a11, a14, 100
4200f578:	000446        	j	4200f58d <_vfprintf_r+0x1c49>
4200f57b:	00          	.byte	00
4200f57c:	012cb7        	blt	a12, a11, 4200f581 <_vfprintf_r+0x1c3d>
4200f57f:	8a2c      	movi.n	a10, 40
4200f581:	10c1b2        	addi	a11, a1, 16
4200f584:	02dbb2        	addmi	a11, a11, 0x200
4200f587:	182bb2        	l32i	a11, a11, 96
4200f58a:	9e61a2        	s32i	a10, a1, 0x278
4200f58d:	abaa      	add.n	a10, a11, a10
4200f58f:	f8caa2        	addi	a10, a10, -8
4200f592:	0a58      	l32i.n	a5, a10, 0
4200f594:	1a48      	l32i.n	a4, a10, 4
4200f596:	10c1a2        	addi	a10, a1, 16
4200f599:	b099a0        	addx8	a9, a9, a10
4200f59c:	0959      	s32i.n	a5, a9, 0
4200f59e:	1949      	s32i.n	a4, a9, 4
4200f5a0:	009486        	j	4200f7f6 <_vfprintf_r+0x1eb2>
4200f5a3:	1a6ea2        	s32i	a10, a14, 104
4200f5a6:	891c      	movi.n	a9, 24
4200f5a8:	0529a7        	blt	a9, a10, 4200f5b1 <_vfprintf_r+0x1c6d>
4200f5ab:	192e92        	l32i	a9, a14, 100
4200f5ae:	000406        	j	4200f5c2 <_vfprintf_r+0x1c7e>
4200f5b1:	0129b7        	blt	a9, a11, 4200f5b6 <_vfprintf_r+0x1c72>
4200f5b4:	8a2c      	movi.n	a10, 40
4200f5b6:	10c192        	addi	a9, a1, 16
4200f5b9:	02d992        	addmi	a9, a9, 0x200
4200f5bc:	182992        	l32i	a9, a9, 96
4200f5bf:	9e61a2        	s32i	a10, a1, 0x278
4200f5c2:	99aa      	add.n	a9, a9, a10
4200f5c4:	f8c992        	addi	a9, a9, -8
4200f5c7:	0958      	l32i.n	a5, a9, 0
4200f5c9:	1948      	l32i.n	a4, a9, 4
4200f5cb:	0089c6        	j	4200f7f6 <_vfprintf_r+0x1eb2>
4200f5ce:	470000        	ee.stf.64.xp	f0, f4, a0, a0
4200f5d1:	63          	.byte	0x63
4200f5d2:	14          	.byte	0x14
4200f5d3:	148c      	beqz.n	a4, 4200f5d8 <_vfprintf_r+0x1c94>
4200f5d5:	005e46        	j	4200f752 <_vfprintf_r+0x1e0e>
4200f5d8:	871b      	addi.n	a8, a7, 1
4200f5da:	022797        	blt	a7, a9, 4200f5e0 <_vfprintf_r+0x1c9c>
4200f5dd:	006b06        	j	4200f78d <_vfprintf_r+0x1e49>
4200f5e0:	b0e6e0        	addx8	a14, a6, a14
4200f5e3:	0e58      	l32i.n	a5, a14, 0
4200f5e5:	0082c6        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f5e8:	02e367        	bbsi	a3, 6, 4200f5ee <_vfprintf_r+0x1caa>
4200f5eb:	002b46        	j	4200f69c <_vfprintf_r+0x1d58>
4200f5ee:	c4ac      	beqz.n	a4, 4200f61e <_vfprintf_r+0x1cda>
4200f5f0:	09a697        	bge	a6, a9, 4200f5fd <_vfprintf_r+0x1cb9>
4200f5f3:	b0e6e0        	addx8	a14, a6, a14
4200f5f6:	001e52        	l16ui	a5, a14, 0
4200f5f9:	005f46        	j	4200f77a <_vfprintf_r+0x1e36>
4200f5fc:	a28200        	muluh	a8, a2, a0
4200f5ff:	8a48      	l32i.n	a4, a10, 32
4200f601:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200f605:	60a2c2        	movi	a12, 0x260
4200f608:	05bd      	mov.n	a11, a5
4200f60a:	0189      	s32i.n	a8, a1, 0
4200f60c:	01def2        	addmi	a15, a14, 0x100
4200f60f:	deda      	add.n	a13, a14, a13
4200f611:	ceca      	add.n	a12, a14, a12
4200f613:	06ad      	mov.n	a10, a6
4200f615:	fde5e5        	call8	4200d474 <get_arg$isra$0>
4200f618:	001a52        	l16ui	a5, a10, 0
4200f61b:	0056c6        	j	4200f77a <_vfprintf_r+0x1e36>
4200f61e:	871b      	addi.n	a8, a7, 1
4200f620:	08a797        	bge	a7, a9, 4200f62c <_vfprintf_r+0x1ce8>
4200f623:	b0e6e0        	addx8	a14, a6, a14
4200f626:	001e52        	l16ui	a5, a14, 0
4200f629:	0071c6        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f62c:	9a2eb2        	l32i	a11, a14, 0x268
4200f62f:	fc1c      	movi.n	a12, 31
4200f631:	02dee2        	addmi	a14, a14, 0x200
4200f634:	ab4b      	addi.n	a10, a11, 4
4200f636:	362c97        	blt	a12, a9, 4200f670 <_vfprintf_r+0x1d2c>
4200f639:	c91b      	addi.n	a12, a9, 1
4200f63b:	9761c2        	s32i	a12, a1, 0x25c
4200f63e:	1a6ea2        	s32i	a10, a14, 104
4200f641:	8c1c      	movi.n	a12, 24
4200f643:	052ca7        	blt	a12, a10, 4200f64c <_vfprintf_r+0x1d08>
4200f646:	192eb2        	l32i	a11, a14, 100
4200f649:	000406        	j	4200f65d <_vfprintf_r+0x1d19>
4200f64c:	012cb7        	blt	a12, a11, 4200f651 <_vfprintf_r+0x1d0d>
4200f64f:	4a2c      	movi.n	a10, 36
4200f651:	10c1b2        	addi	a11, a1, 16
4200f654:	02dbb2        	addmi	a11, a11, 0x200
4200f657:	182bb2        	l32i	a11, a11, 96
4200f65a:	9e61a2        	s32i	a10, a1, 0x278
4200f65d:	bbaa      	add.n	a11, a11, a10
4200f65f:	fccbb2        	addi	a11, a11, -4
4200f662:	0b58      	l32i.n	a5, a11, 0
4200f664:	b09910        	addx8	a9, a9, a1
4200f667:	4959      	s32i.n	a5, a9, 16
4200f669:	f45050        	extui	a5, a5, 0, 16
4200f66c:	006106        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f66f:	00          	.byte	00
4200f670:	1a6ea2        	s32i	a10, a14, 104
4200f673:	891c      	movi.n	a9, 24
4200f675:	0729a7        	blt	a9, a10, 4200f680 <_vfprintf_r+0x1d3c>
4200f678:	192e92        	l32i	a9, a14, 100
4200f67b:	000486        	j	4200f691 <_vfprintf_r+0x1d4d>
4200f67e:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200f681:	0129      	s32i.n	a2, a1, 0
4200f683:	4a2c      	movi.n	a10, 36
4200f685:	10c192        	addi	a9, a1, 16
4200f688:	02d992        	addmi	a9, a9, 0x200
4200f68b:	182992        	l32i	a9, a9, 96
4200f68e:	9e61a2        	s32i	a10, a1, 0x278
4200f691:	99aa      	add.n	a9, a9, a10
4200f693:	fcc992        	addi	a9, a9, -4
4200f696:	001952        	l16ui	a5, a9, 0
4200f699:	0055c6        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f69c:	02e397        	bbsi	a3, 9, 4200f6a2 <_vfprintf_r+0x1d5e>
4200f69f:	002b46        	j	4200f750 <_vfprintf_r+0x1e0c>
4200f6a2:	c4ac      	beqz.n	a4, 4200f6d2 <_vfprintf_r+0x1d8e>
4200f6a4:	09a697        	bge	a6, a9, 4200f6b1 <_vfprintf_r+0x1d6d>
4200f6a7:	b0e6e0        	addx8	a14, a6, a14
4200f6aa:	000e52        	l8ui	a5, a14, 0
4200f6ad:	003246        	j	4200f77a <_vfprintf_r+0x1e36>
4200f6b0:	a28200        	muluh	a8, a2, a0
4200f6b3:	8a48      	l32i.n	a4, a10, 32
4200f6b5:	4ca2d28e 	ee.vmulas.u16.accx.ld.ip.qup	q0, a8, -224, q3, q3, q2, q2
4200f6b9:	60a2c2        	movi	a12, 0x260
4200f6bc:	05bd      	mov.n	a11, a5
4200f6be:	0189      	s32i.n	a8, a1, 0
4200f6c0:	01def2        	addmi	a15, a14, 0x100
4200f6c3:	deda      	add.n	a13, a14, a13
4200f6c5:	ceca      	add.n	a12, a14, a12
4200f6c7:	06ad      	mov.n	a10, a6
4200f6c9:	fddaa5        	call8	4200d474 <get_arg$isra$0>
4200f6cc:	000a52        	l8ui	a5, a10, 0
4200f6cf:	0029c6        	j	4200f77a <_vfprintf_r+0x1e36>
4200f6d2:	871b      	addi.n	a8, a7, 1
4200f6d4:	08a797        	bge	a7, a9, 4200f6e0 <_vfprintf_r+0x1d9c>
4200f6d7:	b0e6e0        	addx8	a14, a6, a14
4200f6da:	000e52        	l8ui	a5, a14, 0
4200f6dd:	0044c6        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f6e0:	9a2eb2        	l32i	a11, a14, 0x268
4200f6e3:	fc1c      	movi.n	a12, 31
4200f6e5:	02dee2        	addmi	a14, a14, 0x200
4200f6e8:	ab4b      	addi.n	a10, a11, 4
4200f6ea:	362c97        	blt	a12, a9, 4200f724 <_vfprintf_r+0x1de0>
4200f6ed:	c91b      	addi.n	a12, a9, 1
4200f6ef:	9761c2        	s32i	a12, a1, 0x25c
4200f6f2:	1a6ea2        	s32i	a10, a14, 104
4200f6f5:	8c1c      	movi.n	a12, 24
4200f6f7:	052ca7        	blt	a12, a10, 4200f700 <_vfprintf_r+0x1dbc>
4200f6fa:	192eb2        	l32i	a11, a14, 100
4200f6fd:	000406        	j	4200f711 <_vfprintf_r+0x1dcd>
4200f700:	012cb7        	blt	a12, a11, 4200f705 <_vfprintf_r+0x1dc1>
4200f703:	4a2c      	movi.n	a10, 36
4200f705:	10c1b2        	addi	a11, a1, 16
4200f708:	02dbb2        	addmi	a11, a11, 0x200
4200f70b:	182bb2        	l32i	a11, a11, 96
4200f70e:	9e61a2        	s32i	a10, a1, 0x278
4200f711:	bbaa      	add.n	a11, a11, a10
4200f713:	fccbb2        	addi	a11, a11, -4
4200f716:	0b58      	l32i.n	a5, a11, 0
4200f718:	b09910        	addx8	a9, a9, a1
4200f71b:	4959      	s32i.n	a5, a9, 16
4200f71d:	745050        	extui	a5, a5, 0, 8
4200f720:	003406        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f723:	00          	.byte	00
4200f724:	1a6ea2        	s32i	a10, a14, 104
4200f727:	891c      	movi.n	a9, 24
4200f729:	0729a7        	blt	a9, a10, 4200f734 <_vfprintf_r+0x1df0>
4200f72c:	192e92        	l32i	a9, a14, 100
4200f72f:	000486        	j	4200f745 <_vfprintf_r+0x1e01>
4200f732:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
4200f735:	0129      	s32i.n	a2, a1, 0
4200f737:	4a2c      	movi.n	a10, 36
4200f739:	10c192        	addi	a9, a1, 16
4200f73c:	02d992        	addmi	a9, a9, 0x200
4200f73f:	182992        	l32i	a9, a9, 96
4200f742:	9e61a2        	s32i	a10, a1, 0x278
4200f745:	99aa      	add.n	a9, a9, a10
4200f747:	fcc992        	addi	a9, a9, -4
4200f74a:	000952        	l8ui	a5, a9, 0
4200f74d:	0028c6        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f750:	c4ac      	beqz.n	a4, 4200f780 <_vfprintf_r+0x1e3c>
4200f752:	07a697        	bge	a6, a9, 4200f75d <_vfprintf_r+0x1e19>
4200f755:	b0e6e0        	addx8	a14, a6, a14
4200f758:	0e58      	l32i.n	a5, a14, 0
4200f75a:	000706        	j	4200f77a <_vfprintf_r+0x1e36>
4200f75d:	48a282        	movi	a8, 0x248
4200f760:	8e8a      	add.n	a8, a14, a8
4200f762:	4ca2d2        	movi	a13, 0x24c
4200f765:	60a2c2        	movi	a12, 0x260
4200f768:	05bd      	mov.n	a11, a5
4200f76a:	0189      	s32i.n	a8, a1, 0
4200f76c:	01def2        	addmi	a15, a14, 0x100
4200f76f:	deda      	add.n	a13, a14, a13
4200f771:	ceca      	add.n	a12, a14, a12
4200f773:	06ad      	mov.n	a10, a6
4200f775:	fdcfe5        	call8	4200d474 <get_arg$isra$0>
4200f778:	0a58      	l32i.n	a5, a10, 0
4200f77a:	078d      	mov.n	a8, a7
4200f77c:	001d06        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f77f:	871b00        	ee.stf.64.xp	f1, f8, a0, a11
4200f782:	07a797        	bge	a7, a9, 4200f78d <_vfprintf_r+0x1e49>
4200f785:	b066e0        	addx8	a6, a6, a14
4200f788:	0658      	l32i.n	a5, a6, 0
4200f78a:	001986        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f78d:	9a2eb2        	l32i	a11, a14, 0x268
4200f790:	fc1c      	movi.n	a12, 31
4200f792:	02dee2        	addmi	a14, a14, 0x200
4200f795:	ab4b      	addi.n	a10, a11, 4
4200f797:	322c97        	blt	a12, a9, 4200f7cd <_vfprintf_r+0x1e89>
4200f79a:	c91b      	addi.n	a12, a9, 1
4200f79c:	9761c2        	s32i	a12, a1, 0x25c
4200f79f:	1a6ea2        	s32i	a10, a14, 104
4200f7a2:	8c1c      	movi.n	a12, 24
4200f7a4:	052ca7        	blt	a12, a10, 4200f7ad <_vfprintf_r+0x1e69>
4200f7a7:	192eb2        	l32i	a11, a14, 100
4200f7aa:	000406        	j	4200f7be <_vfprintf_r+0x1e7a>
4200f7ad:	012cb7        	blt	a12, a11, 4200f7b2 <_vfprintf_r+0x1e6e>
4200f7b0:	4a2c      	movi.n	a10, 36
4200f7b2:	10c1b2        	addi	a11, a1, 16
4200f7b5:	02dbb2        	addmi	a11, a11, 0x200
4200f7b8:	182bb2        	l32i	a11, a11, 96
4200f7bb:	9e61a2        	s32i	a10, a1, 0x278
4200f7be:	bbaa      	add.n	a11, a11, a10
4200f7c0:	fccbb2        	addi	a11, a11, -4
4200f7c3:	0b58      	l32i.n	a5, a11, 0
4200f7c5:	b09910        	addx8	a9, a9, a1
4200f7c8:	4959      	s32i.n	a5, a9, 16
4200f7ca:	000986        	j	4200f7f4 <_vfprintf_r+0x1eb0>
4200f7cd:	1a6ea2        	s32i	a10, a14, 104
4200f7d0:	891c      	movi.n	a9, 24
4200f7d2:	0629a7        	blt	a9, a10, 4200f7dc <_vfprintf_r+0x1e98>
4200f7d5:	192e92        	l32i	a9, a14, 100
4200f7d8:	000446        	j	4200f7ed <_vfprintf_r+0x1ea9>
4200f7db:	00          	.byte	00
4200f7dc:	0129b7        	blt	a9, a11, 4200f7e1 <_vfprintf_r+0x1e9d>
4200f7df:	4a2c      	movi.n	a10, 36
4200f7e1:	10c192        	addi	a9, a1, 16
4200f7e4:	02d992        	addmi	a9, a9, 0x200
4200f7e7:	182992        	l32i	a9, a9, 96
4200f7ea:	9e61a2        	s32i	a10, a1, 0x278
4200f7ed:	99aa      	add.n	a9, a9, a10
4200f7ef:	fcc992        	addi	a9, a9, -4
4200f7f2:	0958      	l32i.n	a5, a9, 0
4200f7f4:	040c      	movi.n	a4, 0
4200f7f6:	209540        	or	a9, a5, a4
4200f7f9:	799c      	beqz.n	a9, 4200f814 <_vfprintf_r+0x1ed0>
4200f7fb:	156307        	bbci	a3, 0, 4200f814 <_vfprintf_r+0x1ed0>
4200f7fe:	10c192        	addi	a9, a1, 16
4200f801:	02d992        	addmi	a9, a9, 0x200
4200f804:	0a3c      	movi.n	a10, 48
4200f806:	5049a2        	s8i	a10, a9, 80
4200f809:	a321a2        	l32i	a10, a1, 0x28c
4200f80c:	5149a2        	s8i	a10, a9, 81
4200f80f:	290c      	movi.n	a9, 2
4200f811:	203390        	or	a3, a3, a9
4200f814:	ffab92        	movi	a9, 0xfffffbff
4200f817:	103390        	and	a3, a3, a9
4200f81a:	290c      	movi.n	a9, 2
4200f81c:	087d      	mov.n	a7, a8
4200f81e:	080c      	movi.n	a8, 0
4200f820:	10c1a2        	addi	a10, a1, 16
4200f823:	02daa2        	addmi	a10, a10, 0x200
4200f826:	524a82        	s8i	a8, a10, 82
4200f829:	a22182        	l32i	a8, a1, 0x288
4200f82c:	01c896        	bltz	a8, 4200f84c <_vfprintf_r+0x1f08>
4200f82f:	03ad      	mov.n	a10, a3
4200f831:	7faf82        	movi	a8, -129
4200f834:	103380        	and	a3, a3, a8
4200f837:	1b0c      	movi.n	a11, 1
4200f839:	208540        	or	a8, a5, a4
4200f83c:	83b880        	moveqz	a11, a8, a8
4200f83f:	98cc      	bnez.n	a8, 4200f84c <_vfprintf_r+0x1f08>
4200f841:	a221c2        	l32i	a12, a1, 0x288
4200f844:	180c      	movi.n	a8, 1
4200f846:	838bc0        	moveqz	a8, a11, a12
4200f849:	15b816        	beqz	a8, 4200f9a8 <_vfprintf_r+0x2064>
4200f84c:	501926        	beqi	a9, 1, 4200f8a0 <_vfprintf_r+0x1f5c>
4200f84f:	10c182        	addi	a8, a1, 16
4200f852:	022966        	bnei	a9, 2, 4200f858 <_vfprintf_r+0x1f14>
4200f855:	0046c6        	j	4200f974 <_vfprintf_r+0x2030>
4200f858:	e4a192        	movi	a9, 0x1e4
4200f85b:	889a      	add.n	a8, a8, a9
4200f85d:	9f6182        	s32i	a8, a1, 0x27c
4200f860:	9f2192        	l32i	a9, a1, 0x27c
4200f863:	890b      	addi.n	a8, a9, -1
4200f865:	9f6182        	s32i	a8, a1, 0x27c
4200f868:	9f21a2        	l32i	a10, a1, 0x27c
4200f86b:	248050        	extui	a8, a5, 0, 3
4200f86e:	30c882        	addi	a8, a8, 48
4200f871:	404300        	ssai	3
4200f874:	815450        	src	a5, a4, a5
4200f877:	414340        	srli	a4, a4, 3
4200f87a:	004a82        	s8i	a8, a10, 0
4200f87d:	20a540        	or	a10, a5, a4
4200f880:	fdca56        	bnez	a10, 4200f860 <_vfprintf_r+0x1f1c>
4200f883:	d0c882        	addi	a8, a8, -48
4200f886:	152816        	beqz	a8, 4200f9dc <_vfprintf_r+0x2098>
4200f889:	02e307        	bbsi	a3, 0, 4200f88f <_vfprintf_r+0x1f4b>
4200f88c:	005306        	j	4200f9dc <_vfprintf_r+0x2098>
4200f88f:	9f2182        	l32i	a8, a1, 0x27c
4200f892:	0a3c      	movi.n	a10, 48
4200f894:	880b      	addi.n	a8, a8, -1
4200f896:	0048a2        	s8i	a10, a8, 0
4200f899:	fec982        	addi	a8, a9, -2
4200f89c:	004e46        	j	4200f9d9 <_vfprintf_r+0x2095>
4200f89f:	54dc00        	extui	a13, a0, 12, 6
4200f8a2:	980c      	movi.n	a8, 9
4200f8a4:	113857        	bltu	a8, a5, 4200f8b9 <_vfprintf_r+0x1f75>
4200f8a7:	10c182        	addi	a8, a1, 16
4200f8aa:	01d892        	addmi	a9, a8, 0x100
4200f8ad:	30c552        	addi	a5, a5, 48
4200f8b0:	e34952        	s8i	a5, a9, 227
4200f8b3:	e3a192        	movi	a9, 0x1e3
4200f8b6:	004746        	j	4200f9d7 <_vfprintf_r+0x2093>
4200f8b9:	080c      	movi.n	a8, 0
4200f8bb:	a46182        	s32i	a8, a1, 0x290
4200f8be:	00a462        	movi	a6, 0x400
4200f8c1:	f4a182        	movi	a8, 0x1f4
4200f8c4:	818a      	add.n	a8, a1, a8
4200f8c6:	106360        	and	a6, a3, a6
4200f8c9:	880b      	addi.n	a8, a8, -1
4200f8cb:	9f6182        	s32i	a8, a1, 0x27c
4200f8ce:	ac0c      	movi.n	a12, 10
4200f8d0:	0d0c      	movi.n	a13, 0
4200f8d2:	05ad      	mov.n	a10, a5
4200f8d4:	04bd      	mov.n	a11, a4
4200f8d6:	c3ad81        	l32r	a8, 4200078c <_stext+0x76c> (40002574 <__umoddi3>)
4200f8d9:	0008e0        	callx8	a8
4200f8dc:	9f2182        	l32i	a8, a1, 0x27c
4200f8df:	30caa2        	addi	a10, a10, 48
4200f8e2:	0048a2        	s8i	a10, a8, 0
4200f8e5:	a42182        	l32i	a8, a1, 0x290
4200f8e8:	881b      	addi.n	a8, a8, 1
4200f8ea:	a46182        	s32i	a8, a1, 0x290
4200f8ed:	061616        	beqz	a6, 4200f952 <_vfprintf_r+0x200e>
4200f8f0:	aa2182        	l32i	a8, a1, 0x2a8
4200f8f3:	000892        	l8ui	a9, a8, 0
4200f8f6:	01af82        	movi	a8, -255
4200f8f9:	808980        	add	a8, a9, a8
4200f8fc:	052816        	beqz	a8, 4200f952 <_vfprintf_r+0x200e>
4200f8ff:	a42182        	l32i	a8, a1, 0x290
4200f902:	4c9987        	bne	a9, a8, 4200f952 <_vfprintf_r+0x200e>
4200f905:	74cc      	bnez.n	a4, 4200f910 <_vfprintf_r+0x1fcc>
4200f907:	09a082        	movi	a8, 9
4200f90a:	023857        	bltu	a8, a5, 4200f910 <_vfprintf_r+0x1fcc>
4200f90d:	0032c6        	j	4200f9dc <_vfprintf_r+0x2098>
4200f910:	9f2182        	l32i	a8, a1, 0x27c
4200f913:	b02192        	l32i	a9, a1, 0x2c0
4200f916:	b621b2        	l32i	a11, a1, 0x2d8
4200f919:	c08890        	sub	a8, a8, a9
4200f91c:	08ad      	mov.n	a10, a8
4200f91e:	09cd      	mov.n	a12, a9
4200f920:	9f6182        	s32i	a8, a1, 0x27c
4200f923:	c52981        	l32r	a8, 42000dc8 <_stext+0xda8> (40001224 <strncpy>)
4200f926:	0008e0        	callx8	a8
4200f929:	aa2182        	l32i	a8, a1, 0x2a8
4200f92c:	010882        	l8ui	a8, a8, 1
4200f92f:	18cc      	bnez.n	a8, 4200f934 <_vfprintf_r+0x1ff0>
4200f931:	0001c6        	j	4200f93c <_vfprintf_r+0x1ff8>
4200f934:	aa2182        	l32i	a8, a1, 0x2a8
4200f937:	881b      	addi.n	a8, a8, 1
4200f939:	aa6182        	s32i	a8, a1, 0x2a8
4200f93c:	ac0c      	movi.n	a12, 10
4200f93e:	0d0c      	movi.n	a13, 0
4200f940:	05ad      	mov.n	a10, a5
4200f942:	04bd      	mov.n	a11, a4
4200f944:	c21881        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
4200f947:	0008e0        	callx8	a8
4200f94a:	080c      	movi.n	a8, 0
4200f94c:	a46182        	s32i	a8, a1, 0x290
4200f94f:	000546        	j	4200f968 <_vfprintf_r+0x2024>
4200f952:	ac0c      	movi.n	a12, 10
4200f954:	0d0c      	movi.n	a13, 0
4200f956:	05ad      	mov.n	a10, a5
4200f958:	20b440        	or	a11, a4, a4
4200f95b:	c21281        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
4200f95e:	0008e0        	callx8	a8
4200f961:	34cc      	bnez.n	a4, 4200f968 <_vfprintf_r+0x2024>
4200f963:	980c      	movi.n	a8, 9
4200f965:	73b857        	bgeu	a8, a5, 4200f9dc <_vfprintf_r+0x2098>
4200f968:	9f2182        	l32i	a8, a1, 0x27c
4200f96b:	0a5d      	mov.n	a5, a10
4200f96d:	0b4d      	mov.n	a4, a11
4200f96f:	ffd586        	j	4200f8c9 <_vfprintf_r+0x1f85>
4200f972:	00          	.byte	00
4200f973:	a19200        	sll	a9, a2
4200f976:	889ae4        	ee.vld.h.64.ip	q1, a14, 208
4200f979:	9f6182        	s32i	a8, a1, 0x27c
4200f97c:	9f2182        	l32i	a8, a1, 0x27c
4200f97f:	b82192        	l32i	a9, a1, 0x2e0
4200f982:	880b      	addi.n	a8, a8, -1
4200f984:	9f6182        	s32i	a8, a1, 0x27c
4200f987:	348050        	extui	a8, a5, 0, 4
4200f98a:	898a      	add.n	a8, a9, a8
4200f98c:	000882        	l8ui	a8, a8, 0
4200f98f:	9f2192        	l32i	a9, a1, 0x27c
4200f992:	404400        	ssai	4
4200f995:	815450        	src	a5, a4, a5
4200f998:	414440        	srli	a4, a4, 4
4200f99b:	004982        	s8i	a8, a9, 0
4200f99e:	208540        	or	a8, a5, a4
4200f9a1:	fd7856        	bnez	a8, 4200f97c <_vfprintf_r+0x2038>
4200f9a4:	000d06        	j	4200f9dc <_vfprintf_r+0x2098>
4200f9a7:	080c00        	lsx	f0, a12, a0
4200f9aa:	a26182        	s32i	a8, a1, 0x288
4200f9ad:	10c1b2        	addi	a11, a1, 16
4200f9b0:	e4a182        	movi	a8, 0x1e4
4200f9b3:	8b8a      	add.n	a8, a11, a8
4200f9b5:	9f6182        	s32i	a8, a1, 0x27c
4200f9b8:	09ec      	bnez.n	a9, 4200f9dc <_vfprintf_r+0x2098>
4200f9ba:	0480a0        	extui	a8, a10, 0, 1
4200f9bd:	a26182        	s32i	a8, a1, 0x288
4200f9c0:	a22182        	l32i	a8, a1, 0x288
4200f9c3:	589c      	beqz.n	a8, 4200f9dc <_vfprintf_r+0x2098>
4200f9c5:	01db82        	addmi	a8, a11, 0x100
4200f9c8:	093c      	movi.n	a9, 48
4200f9ca:	e34892        	s8i	a9, a8, 227
4200f9cd:	080c      	movi.n	a8, 0
4200f9cf:	a26182        	s32i	a8, a1, 0x288
4200f9d2:	0b9d      	mov.n	a9, a11
4200f9d4:	e3a182        	movi	a8, 0x1e3
4200f9d7:	898a      	add.n	a8, a9, a8
4200f9d9:	9f6182        	s32i	a8, a1, 0x27c
4200f9dc:	bb2182        	l32i	a8, a1, 0x2ec
4200f9df:	9f2192        	l32i	a9, a1, 0x27c
4200f9e2:	a22142        	l32i	a4, a1, 0x288
4200f9e5:	c08890        	sub	a8, a8, a9
4200f9e8:	a26182        	s32i	a8, a1, 0x288
4200f9eb:	080c      	movi.n	a8, 0
4200f9ed:	a96182        	s32i	a8, a1, 0x2a4
4200f9f0:	001086        	j	4200fa36 <_vfprintf_r+0x20f2>
4200f9f3:	218200        	srai	a8, a0, 2
4200f9f6:	18cca3        	ssip	f10, a12, 96
4200f9f9:	02bdc6        	j	420104f4 <_vfprintf_r+0x2bb0>
4200f9fc:	a321a2        	l32i	a10, a1, 0x28c
4200f9ff:	10c182        	addi	a8, a1, 16
4200fa02:	01d892        	addmi	a9, a8, 0x100
4200fa05:	8049a2        	s8i	a10, a9, 128
4200fa08:	02d892        	addmi	a9, a8, 0x200
4200fa0b:	0a0c      	movi.n	a10, 0
4200fa0d:	5249a2        	s8i	a10, a9, 82
4200fa10:	090c      	movi.n	a9, 0
4200fa12:	a96192        	s32i	a9, a1, 0x2a4
4200fa15:	190c      	movi.n	a9, 1
4200fa17:	a26192        	s32i	a9, a1, 0x288
4200fa1a:	090c      	movi.n	a9, 0
4200fa1c:	ab6192        	s32i	a9, a1, 0x2ac
4200fa1f:	040c      	movi.n	a4, 0
4200fa21:	050c      	movi.n	a5, 0
4200fa23:	060c      	movi.n	a6, 0
4200fa25:	80a192        	movi	a9, 0x180
4200fa28:	889a      	add.n	a8, a8, a9
4200fa2a:	9f6182        	s32i	a8, a1, 0x27c
4200fa2d:	000306        	j	4200fa3d <_vfprintf_r+0x20f9>
4200fa30:	00          	.byte	00
4200fa31:	040c00        	extui	a0, a0, 12, 1
4200fa34:	080c      	movi.n	a8, 0
4200fa36:	ab6182        	s32i	a8, a1, 0x2ac
4200fa39:	050c      	movi.n	a5, 0
4200fa3b:	060c      	movi.n	a6, 0
4200fa3d:	a22182        	l32i	a8, a1, 0x288
4200fa40:	538480        	max	a8, a4, a8
4200fa43:	af6182        	s32i	a8, a1, 0x2bc
4200fa46:	10c182        	addi	a8, a1, 16
4200fa49:	02d882        	addmi	a8, a8, 0x200
4200fa4c:	520882        	l8ui	a8, a8, 82
4200fa4f:	788c      	beqz.n	a8, 4200fa5a <_vfprintf_r+0x2116>
4200fa51:	af2182        	l32i	a8, a1, 0x2bc
4200fa54:	01c882        	addi	a8, a8, 1
4200fa57:	af6182        	s32i	a8, a1, 0x2bc
4200fa5a:	280c      	movi.n	a8, 2
4200fa5c:	108380        	and	a8, a3, a8
4200fa5f:	b96182        	s32i	a8, a1, 0x2e4
4200fa62:	688c      	beqz.n	a8, 4200fa6c <_vfprintf_r+0x2128>
4200fa64:	af2182        	l32i	a8, a1, 0x2bc
4200fa67:	882b      	addi.n	a8, a8, 2
4200fa69:	af6182        	s32i	a8, a1, 0x2bc
4200fa6c:	84a082        	movi	a8, 132
4200fa6f:	108380        	and	a8, a3, a8
4200fa72:	ba6182        	s32i	a8, a1, 0x2e8
4200fa75:	089856        	bnez	a8, 4200fb02 <_vfprintf_r+0x21be>
4200fa78:	ac2182        	l32i	a8, a1, 0x2b0
4200fa7b:	af2192        	l32i	a9, a1, 0x2bc
4200fa7e:	10c1d2        	addi	a13, a1, 16
4200fa81:	c0f890        	sub	a15, a8, a9
4200fa84:	391fe6        	bgei	a15, 1, 4200fac1 <_vfprintf_r+0x217d>
4200fa87:	001dc6        	j	4200fb02 <_vfprintf_r+0x21be>
4200fa8a:	10cbb2        	addi	a11, a11, 16
4200fa8d:	12e9      	s32i.n	a14, a2, 4
4200fa8f:	0b69b2        	s32i	a11, a9, 44
4200fa92:	a989      	s32i.n	a8, a9, 40
4200fa94:	2488a6        	blti	a8, 8, 4200fabc <_vfprintf_r+0x2178>
4200fa97:	24a2c2        	movi	a12, 0x224
4200fa9a:	a021b2        	l32i	a11, a1, 0x280
4200fa9d:	a121a2        	l32i	a10, a1, 0x284
4200faa0:	80cdc0        	add	a12, a13, a12
4200faa3:	bc61f2        	s32i	a15, a1, 0x2f0
4200faa6:	201110        	or	a1, a1, a1
4200faa9:	010525        	call8	42010afc <__sprint_r>
4200faac:	1a8c      	beqz.n	a10, 4200fab1 <_vfprintf_r+0x216d>
4200faae:	029b86        	j	42010520 <_vfprintf_r+0x2bdc>
4200fab1:	e4a1a2        	movi	a10, 0x1e4
4200fab4:	10c1d2        	addi	a13, a1, 16
4200fab7:	bc21f2        	l32i	a15, a1, 0x2f0
4200faba:	adaa      	add.n	a10, a13, a10
4200fabc:	f0cff2        	addi	a15, a15, -16
4200fabf:	0a2d      	mov.n	a2, a10
4200fac1:	c4fcc1        	l32r	a12, 42000eb4 <_stext+0xe94> (3c0286d4 <blanks$1>)
4200fac4:	8a2d82        	l32i	a8, a13, 0x228
4200fac7:	0e1c      	movi.n	a14, 16
4200fac9:	02c9      	s32i.n	a12, a2, 0
4200facb:	02dd92        	addmi	a9, a13, 0x200
4200face:	881b      	addi.n	a8, a8, 1
4200fad0:	a28b      	addi.n	a10, a2, 8
4200fad2:	b9b8      	l32i.n	a11, a9, 44
4200fad4:	b22ef7        	blt	a14, a15, 4200fa8a <_vfprintf_r+0x2146>
4200fad7:	12f9      	s32i.n	a15, a2, 4
4200fad9:	2fba      	add.n	a2, a15, a11
4200fadb:	b929      	s32i.n	a2, a9, 44
4200fadd:	a989      	s32i.n	a8, a9, 40
4200fadf:	0a2d      	mov.n	a2, a10
4200fae1:	1d88a6        	blti	a8, 8, 4200fb02 <_vfprintf_r+0x21be>
4200fae4:	24a2c2        	movi	a12, 0x224
4200fae7:	a021b2        	l32i	a11, a1, 0x280
4200faea:	a121a2        	l32i	a10, a1, 0x284
4200faed:	cdca      	add.n	a12, a13, a12
4200faef:	201110        	or	a1, a1, a1
4200faf2:	0100a5        	call8	42010afc <__sprint_r>
4200faf5:	1a8c      	beqz.n	a10, 4200fafa <_vfprintf_r+0x21b6>
4200faf7:	028946        	j	42010520 <_vfprintf_r+0x2bdc>
4200fafa:	e4a182        	movi	a8, 0x1e4
4200fafd:	10c1d2        	addi	a13, a1, 16
4200fb00:	2d8a      	add.n	a2, a13, a8
4200fb02:	10c182        	addi	a8, a1, 16
4200fb05:	02d892        	addmi	a9, a8, 0x200
4200fb08:	520982        	l8ui	a8, a9, 82
4200fb0b:	e8bc      	beqz.n	a8, 4200fb4d <_vfprintf_r+0x2209>
4200fb0d:	b988      	l32i.n	a8, a9, 44
4200fb0f:	52a2a2        	movi	a10, 0x252
4200fb12:	881b      	addi.n	a8, a8, 1
4200fb14:	10c1b2        	addi	a11, a1, 16
4200fb17:	b989      	s32i.n	a8, a9, 44
4200fb19:	a988      	l32i.n	a8, a9, 40
4200fb1b:	abaa      	add.n	a10, a11, a10
4200fb1d:	02a9      	s32i.n	a10, a2, 0
4200fb1f:	881b      	addi.n	a8, a8, 1
4200fb21:	1a0c      	movi.n	a10, 1
4200fb23:	12a9      	s32i.n	a10, a2, 4
4200fb25:	a989      	s32i.n	a8, a9, 40
4200fb27:	228b      	addi.n	a2, a2, 8
4200fb29:	2088a6        	blti	a8, 8, 4200fb4d <_vfprintf_r+0x2209>
4200fb2c:	24a2c2        	movi	a12, 0x224
4200fb2f:	10c182        	addi	a8, a1, 16
4200fb32:	a021b2        	l32i	a11, a1, 0x280
4200fb35:	a121a2        	l32i	a10, a1, 0x284
4200fb38:	c8ca      	add.n	a12, a8, a12
4200fb3a:	201110        	or	a1, a1, a1
4200fb3d:	00fbe5        	call8	42010afc <__sprint_r>
4200fb40:	1a8c      	beqz.n	a10, 4200fb45 <_vfprintf_r+0x2201>
4200fb42:	027686        	j	42010520 <_vfprintf_r+0x2bdc>
4200fb45:	e4a182        	movi	a8, 0x1e4
4200fb48:	10c192        	addi	a9, a1, 16
4200fb4b:	298a      	add.n	a2, a9, a8
4200fb4d:	b92182        	l32i	a8, a1, 0x2e4
4200fb50:	046816        	beqz	a8, 4200fb9a <_vfprintf_r+0x2256>
4200fb53:	10c182        	addi	a8, a1, 16
4200fb56:	02d892        	addmi	a9, a8, 0x200
4200fb59:	8f2182        	l32i	a8, a1, 0x23c
4200fb5c:	50a2a2        	movi	a10, 0x250
4200fb5f:	882b      	addi.n	a8, a8, 2
4200fb61:	10c1b2        	addi	a11, a1, 16
4200fb64:	b989      	s32i.n	a8, a9, 44
4200fb66:	a988      	l32i.n	a8, a9, 40
4200fb68:	abaa      	add.n	a10, a11, a10
4200fb6a:	02a9      	s32i.n	a10, a2, 0
4200fb6c:	881b      	addi.n	a8, a8, 1
4200fb6e:	2a0c      	movi.n	a10, 2
4200fb70:	12a9      	s32i.n	a10, a2, 4
4200fb72:	a989      	s32i.n	a8, a9, 40
4200fb74:	228b      	addi.n	a2, a2, 8
4200fb76:	2088a6        	blti	a8, 8, 4200fb9a <_vfprintf_r+0x2256>
4200fb79:	24a2c2        	movi	a12, 0x224
4200fb7c:	10c182        	addi	a8, a1, 16
4200fb7f:	a021b2        	l32i	a11, a1, 0x280
4200fb82:	a121a2        	l32i	a10, a1, 0x284
4200fb85:	c8ca      	add.n	a12, a8, a12
4200fb87:	201110        	or	a1, a1, a1
4200fb8a:	00f725        	call8	42010afc <__sprint_r>
4200fb8d:	1a8c      	beqz.n	a10, 4200fb92 <_vfprintf_r+0x224e>
4200fb8f:	026346        	j	42010520 <_vfprintf_r+0x2bdc>
4200fb92:	e4a182        	movi	a8, 0x1e4
4200fb95:	10c192        	addi	a9, a1, 16
4200fb98:	298a      	add.n	a2, a9, a8
4200fb9a:	ba2182        	l32i	a8, a1, 0x2e8
4200fb9d:	02e826        	beqi	a8, 128, 4200fba3 <_vfprintf_r+0x225f>
4200fba0:	002246        	j	4200fc2d <_vfprintf_r+0x22e9>
4200fba3:	ac2182        	l32i	a8, a1, 0x2b0
4200fba6:	af2192        	l32i	a9, a1, 0x2bc
4200fba9:	10c1e2        	addi	a14, a1, 16
4200fbac:	c0f890        	sub	a15, a8, a9
4200fbaf:	371fe6        	bgei	a15, 1, 4200fbea <_vfprintf_r+0x22a6>
4200fbb2:	001dc6        	j	4200fc2d <_vfprintf_r+0x22e9>
4200fbb5:	10cbb2        	addi	a11, a11, 16
4200fbb8:	12d9      	s32i.n	a13, a2, 4
4200fbba:	b9b9      	s32i.n	a11, a9, 44
4200fbbc:	a989      	s32i.n	a8, a9, 40
4200fbbe:	2388a6        	blti	a8, 8, 4200fbe5 <_vfprintf_r+0x22a1>
4200fbc1:	24a2c2        	movi	a12, 0x224
4200fbc4:	a021b2        	l32i	a11, a1, 0x280
4200fbc7:	a121a2        	l32i	a10, a1, 0x284
4200fbca:	ceca      	add.n	a12, a14, a12
4200fbcc:	b961f2        	s32i	a15, a1, 0x2e4
4200fbcf:	201110        	or	a1, a1, a1
4200fbd2:	00f2a5        	call8	42010afc <__sprint_r>
4200fbd5:	1a8c      	beqz.n	a10, 4200fbda <_vfprintf_r+0x2296>
4200fbd7:	025146        	j	42010520 <_vfprintf_r+0x2bdc>
4200fbda:	e4a1a2        	movi	a10, 0x1e4
4200fbdd:	10c1e2        	addi	a14, a1, 16
4200fbe0:	b921f2        	l32i	a15, a1, 0x2e4
4200fbe3:	aeaa      	add.n	a10, a14, a10
4200fbe5:	f0cff2        	addi	a15, a15, -16
4200fbe8:	0a2d      	mov.n	a2, a10
4200fbea:	c4b3c1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
4200fbed:	8a2e82        	l32i	a8, a14, 0x228
4200fbf0:	0d1c      	movi.n	a13, 16
4200fbf2:	02c9      	s32i.n	a12, a2, 0
4200fbf4:	02de92        	addmi	a9, a14, 0x200
4200fbf7:	881b      	addi.n	a8, a8, 1
4200fbf9:	a28b      	addi.n	a10, a2, 8
4200fbfb:	b9b8      	l32i.n	a11, a9, 44
4200fbfd:	b42df7        	blt	a13, a15, 4200fbb5 <_vfprintf_r+0x2271>
4200fc00:	bfba      	add.n	a11, a15, a11
4200fc02:	12f9      	s32i.n	a15, a2, 4
4200fc04:	b9b9      	s32i.n	a11, a9, 44
4200fc06:	0a6982        	s32i	a8, a9, 40
4200fc09:	0a2d      	mov.n	a2, a10
4200fc0b:	1e88a6        	blti	a8, 8, 4200fc2d <_vfprintf_r+0x22e9>
4200fc0e:	24a2c2        	movi	a12, 0x224
4200fc11:	a021b2        	l32i	a11, a1, 0x280
4200fc14:	a121a2        	l32i	a10, a1, 0x284
4200fc17:	80cec0        	add	a12, a14, a12
4200fc1a:	201110        	or	a1, a1, a1
4200fc1d:	00ede5        	call8	42010afc <__sprint_r>
4200fc20:	1a8c      	beqz.n	a10, 4200fc25 <_vfprintf_r+0x22e1>
4200fc22:	023e86        	j	42010520 <_vfprintf_r+0x2bdc>
4200fc25:	e4a182        	movi	a8, 0x1e4
4200fc28:	10c1e2        	addi	a14, a1, 16
4200fc2b:	2e8a      	add.n	a2, a14, a8
4200fc2d:	a22182        	l32i	a8, a1, 0x288
4200fc30:	c04480        	sub	a4, a4, a8
4200fc33:	7b14a6        	blti	a4, 1, 4200fcb2 <_vfprintf_r+0x236e>
4200fc36:	000c46        	j	4200fc6b <_vfprintf_r+0x2327>
4200fc39:	10cbb2        	addi	a11, a11, 16
4200fc3c:	12d9      	s32i.n	a13, a2, 4
4200fc3e:	b9b9      	s32i.n	a11, a9, 44
4200fc40:	a989      	s32i.n	a8, a9, 40
4200fc42:	2088a6        	blti	a8, 8, 4200fc66 <_vfprintf_r+0x2322>
4200fc45:	24a2c2        	movi	a12, 0x224
4200fc48:	10c182        	addi	a8, a1, 16
4200fc4b:	a021b2        	l32i	a11, a1, 0x280
4200fc4e:	a121a2        	l32i	a10, a1, 0x284
4200fc51:	c8ca      	add.n	a12, a8, a12
4200fc53:	201110        	or	a1, a1, a1
4200fc56:	00ea65        	call8	42010afc <__sprint_r>
4200fc59:	1a8c      	beqz.n	a10, 4200fc5e <_vfprintf_r+0x231a>
4200fc5b:	023046        	j	42010520 <_vfprintf_r+0x2bdc>
4200fc5e:	e4a1a2        	movi	a10, 0x1e4
4200fc61:	10c182        	addi	a8, a1, 16
4200fc64:	a8aa      	add.n	a10, a8, a10
4200fc66:	f0c442        	addi	a4, a4, -16
4200fc69:	0a2d      	mov.n	a2, a10
4200fc6b:	10c182        	addi	a8, a1, 16
4200fc6e:	02d892        	addmi	a9, a8, 0x200
4200fc71:	c491c1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
4200fc74:	a988      	l32i.n	a8, a9, 40
4200fc76:	0d1c      	movi.n	a13, 16
4200fc78:	02c9      	s32i.n	a12, a2, 0
4200fc7a:	881b      	addi.n	a8, a8, 1
4200fc7c:	a28b      	addi.n	a10, a2, 8
4200fc7e:	b9b8      	l32i.n	a11, a9, 44
4200fc80:	b52d47        	blt	a13, a4, 4200fc39 <_vfprintf_r+0x22f5>
4200fc83:	1249      	s32i.n	a4, a2, 4
4200fc85:	44ba      	add.n	a4, a4, a11
4200fc87:	b949      	s32i.n	a4, a9, 44
4200fc89:	a989      	s32i.n	a8, a9, 40
4200fc8b:	0a2d      	mov.n	a2, a10
4200fc8d:	2188a6        	blti	a8, 8, 4200fcb2 <_vfprintf_r+0x236e>
4200fc90:	24a2c2        	movi	a12, 0x224
4200fc93:	10c182        	addi	a8, a1, 16
4200fc96:	a021b2        	l32i	a11, a1, 0x280
4200fc99:	a121a2        	l32i	a10, a1, 0x284
4200fc9c:	80c8c0        	add	a12, a8, a12
4200fc9f:	201110        	or	a1, a1, a1
4200fca2:	00e5a5        	call8	42010afc <__sprint_r>
4200fca5:	1a8c      	beqz.n	a10, 4200fcaa <_vfprintf_r+0x2366>
4200fca7:	021d46        	j	42010520 <_vfprintf_r+0x2bdc>
4200fcaa:	e4a182        	movi	a8, 0x1e4
4200fcad:	10c192        	addi	a9, a1, 16
4200fcb0:	298a      	add.n	a2, a9, a8
4200fcb2:	10c182        	addi	a8, a1, 16
4200fcb5:	02d8e2        	addmi	a14, a8, 0x200
4200fcb8:	be98      	l32i.n	a9, a14, 44
4200fcba:	3fe387        	bbsi	a3, 8, 4200fcfd <_vfprintf_r+0x23b9>
4200fcbd:	9f2182        	l32i	a8, a1, 0x27c
4200fcc0:	0289      	s32i.n	a8, a2, 0
4200fcc2:	a22182        	l32i	a8, a1, 0x288
4200fcc5:	1289      	s32i.n	a8, a2, 4
4200fcc7:	889a      	add.n	a8, a8, a9
4200fcc9:	be89      	s32i.n	a8, a14, 44
4200fccb:	ae88      	l32i.n	a8, a14, 40
4200fccd:	228b      	addi.n	a2, a2, 8
4200fccf:	881b      	addi.n	a8, a8, 1
4200fcd1:	ae89      	s32i.n	a8, a14, 40
4200fcd3:	0288e6        	bgei	a8, 8, 4200fcd9 <_vfprintf_r+0x2395>
4200fcd6:	01d3c6        	j	42010429 <_vfprintf_r+0x2ae5>
4200fcd9:	24a2c2        	movi	a12, 0x224
4200fcdc:	10c182        	addi	a8, a1, 16
4200fcdf:	a021b2        	l32i	a11, a1, 0x280
4200fce2:	a121a2        	l32i	a10, a1, 0x284
4200fce5:	c8ca      	add.n	a12, a8, a12
4200fce7:	201110        	or	a1, a1, a1
4200fcea:	00e125        	call8	42010afc <__sprint_r>
4200fced:	1a8c      	beqz.n	a10, 4200fcf2 <_vfprintf_r+0x23ae>
4200fcef:	020b46        	j	42010520 <_vfprintf_r+0x2bdc>
4200fcf2:	e4a182        	movi	a8, 0x1e4
4200fcf5:	10c192        	addi	a9, a1, 16
4200fcf8:	298a      	add.n	a2, a9, a8
4200fcfa:	01cac6        	j	42010429 <_vfprintf_r+0x2ae5>
4200fcfd:	a321a2        	l32i	a10, a1, 0x28c
4200fd00:	65a082        	movi	a8, 101
4200fd03:	0228a7        	blt	a8, a10, 4200fd09 <_vfprintf_r+0x23c5>
4200fd06:	015d86        	j	42010280 <_vfprintf_r+0x293c>
4200fd09:	98a282        	movi	a8, 0x298
4200fd0c:	881a      	add.n	a8, a8, a1
4200fd0e:	08a8      	l32i.n	a10, a8, 0
4200fd10:	0128b2        	l32i	a11, a8, 4
4200fd13:	a361e2        	s32i	a14, a1, 0x28c
4200fd16:	a26192        	s32i	a9, a1, 0x288
4200fd19:	0c0c      	movi.n	a12, 0
4200fd1b:	00a0d2        	movi	a13, 0
4200fd1e:	c46e81        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
4200fd21:	0008e0        	callx8	a8
4200fd24:	a22192        	l32i	a9, a1, 0x288
4200fd27:	a321e2        	l32i	a14, a1, 0x28c
4200fd2a:	0dea56        	bnez	a10, 4200fe0c <_vfprintf_r+0x24c8>
4200fd2d:	c46381        	l32r	a8, 42000ebc <_stext+0xe9c> (3c028716 <blanks$1+0x42>)
4200fd30:	0289      	s32i.n	a8, a2, 0
4200fd32:	180c      	movi.n	a8, 1
4200fd34:	1289      	s32i.n	a8, a2, 4
4200fd36:	891b      	addi.n	a8, a9, 1
4200fd38:	be89      	s32i.n	a8, a14, 44
4200fd3a:	ae88      	l32i.n	a8, a14, 40
4200fd3c:	228b      	addi.n	a2, a2, 8
4200fd3e:	881b      	addi.n	a8, a8, 1
4200fd40:	ae89      	s32i.n	a8, a14, 40
4200fd42:	1f88a6        	blti	a8, 8, 4200fd65 <_vfprintf_r+0x2421>
4200fd45:	24a2c2        	movi	a12, 0x224
4200fd48:	10c182        	addi	a8, a1, 16
4200fd4b:	a021b2        	l32i	a11, a1, 0x280
4200fd4e:	a121a2        	l32i	a10, a1, 0x284
4200fd51:	c8ca      	add.n	a12, a8, a12
4200fd53:	201110        	or	a1, a1, a1
4200fd56:	00da65        	call8	42010afc <__sprint_r>
4200fd59:	7c3a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fd5c:	e4a182        	movi	a8, 0x1e4
4200fd5f:	10c192        	addi	a9, a1, 16
4200fd62:	802980        	add	a2, a9, a8
4200fd65:	952182        	l32i	a8, a1, 0x254
4200fd68:	a42192        	l32i	a9, a1, 0x290
4200fd6b:	052897        	blt	a8, a9, 4200fd74 <_vfprintf_r+0x2430>
4200fd6e:	02e307        	bbsi	a3, 0, 4200fd74 <_vfprintf_r+0x2430>
4200fd71:	01ad06        	j	42010429 <_vfprintf_r+0x2ae5>
4200fd74:	b12182        	l32i	a8, a1, 0x2c4
4200fd77:	10c162        	addi	a6, a1, 16
4200fd7a:	0289      	s32i.n	a8, a2, 0
4200fd7c:	ad2182        	l32i	a8, a1, 0x2b4
4200fd7f:	ad21a2        	l32i	a10, a1, 0x2b4
4200fd82:	1289      	s32i.n	a8, a2, 4
4200fd84:	8b2682        	l32i	a8, a6, 0x22c
4200fd87:	228b      	addi.n	a2, a2, 8
4200fd89:	88aa      	add.n	a8, a8, a10
4200fd8b:	8b6682        	s32i	a8, a6, 0x22c
4200fd8e:	8a2682        	l32i	a8, a6, 0x228
4200fd91:	01c882        	addi	a8, a8, 1
4200fd94:	8a6682        	s32i	a8, a6, 0x228
4200fd97:	1988a6        	blti	a8, 8, 4200fdb4 <_vfprintf_r+0x2470>
4200fd9a:	24a2c2        	movi	a12, 0x224
4200fd9d:	a021b2        	l32i	a11, a1, 0x280
4200fda0:	a121a2        	l32i	a10, a1, 0x284
4200fda3:	80c6c0        	add	a12, a6, a12
4200fda6:	201110        	or	a1, a1, a1
4200fda9:	00d525        	call8	42010afc <__sprint_r>
4200fdac:	770a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fdaf:	e4a182        	movi	a8, 0x1e4
4200fdb2:	268a      	add.n	a2, a6, a8
4200fdb4:	a42182        	l32i	a8, a1, 0x290
4200fdb7:	680b      	addi.n	a6, a8, -1
4200fdb9:	0216e6        	bgei	a6, 1, 4200fdbf <_vfprintf_r+0x247b>
4200fdbc:	019a46        	j	42010429 <_vfprintf_r+0x2ae5>
4200fdbf:	10c152        	addi	a5, a1, 16
4200fdc2:	000ac6        	j	4200fdf1 <_vfprintf_r+0x24ad>
4200fdc5:	10cbb2        	addi	a11, a11, 16
4200fdc8:	12d9      	s32i.n	a13, a2, 4
4200fdca:	b9b9      	s32i.n	a11, a9, 44
4200fdcc:	0a6982        	s32i	a8, a9, 40
4200fdcf:	1988a6        	blti	a8, 8, 4200fdec <_vfprintf_r+0x24a8>
4200fdd2:	24a2c2        	movi	a12, 0x224
4200fdd5:	a021b2        	l32i	a11, a1, 0x280
4200fdd8:	a121a2        	l32i	a10, a1, 0x284
4200fddb:	80c5c0        	add	a12, a5, a12
4200fdde:	201110        	or	a1, a1, a1
4200fde1:	00d1a5        	call8	42010afc <__sprint_r>
4200fde4:	738a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fde7:	e4a1a2        	movi	a10, 0x1e4
4200fdea:	a5aa      	add.n	a10, a5, a10
4200fdec:	f0c662        	addi	a6, a6, -16
4200fdef:	0a2d      	mov.n	a2, a10
4200fdf1:	c431c1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
4200fdf4:	8a2582        	l32i	a8, a5, 0x228
4200fdf7:	0d1c      	movi.n	a13, 16
4200fdf9:	02c9      	s32i.n	a12, a2, 0
4200fdfb:	02d592        	addmi	a9, a5, 0x200
4200fdfe:	881b      	addi.n	a8, a8, 1
4200fe00:	a28b      	addi.n	a10, a2, 8
4200fe02:	b9b8      	l32i.n	a11, a9, 44
4200fe04:	bd2d67        	blt	a13, a6, 4200fdc5 <_vfprintf_r+0x2481>
4200fe07:	011206        	j	42010253 <_vfprintf_r+0x290f>
4200fe0a:	820000        	mull	a0, a0, a0
4200fe0d:	a69521        	l32r	a2, 41ff9864 <_iram_bss_end+0x1c77464>
4200fe10:	0218      	l32i.n	a1, a2, 0
4200fe12:	004ac6        	j	4200ff41 <_vfprintf_r+0x25fd>
4200fe15:	c42981        	l32r	a8, 42000ebc <_stext+0xe9c> (3c028716 <blanks$1+0x42>)
4200fe18:	0289      	s32i.n	a8, a2, 0
4200fe1a:	180c      	movi.n	a8, 1
4200fe1c:	1289      	s32i.n	a8, a2, 4
4200fe1e:	891b      	addi.n	a8, a9, 1
4200fe20:	be89      	s32i.n	a8, a14, 44
4200fe22:	ae88      	l32i.n	a8, a14, 40
4200fe24:	228b      	addi.n	a2, a2, 8
4200fe26:	881b      	addi.n	a8, a8, 1
4200fe28:	ae89      	s32i.n	a8, a14, 40
4200fe2a:	1e88a6        	blti	a8, 8, 4200fe4c <_vfprintf_r+0x2508>
4200fe2d:	24a2c2        	movi	a12, 0x224
4200fe30:	10c182        	addi	a8, a1, 16
4200fe33:	a021b2        	l32i	a11, a1, 0x280
4200fe36:	a121a2        	l32i	a10, a1, 0x284
4200fe39:	c8ca      	add.n	a12, a8, a12
4200fe3b:	201110        	or	a1, a1, a1
4200fe3e:	00cbe5        	call8	42010afc <__sprint_r>
4200fe41:	6dba56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fe44:	e4a182        	movi	a8, 0x1e4
4200fe47:	10c192        	addi	a9, a1, 16
4200fe4a:	298a      	add.n	a2, a9, a8
4200fe4c:	a421b2        	l32i	a11, a1, 0x290
4200fe4f:	952192        	l32i	a9, a1, 0x254
4200fe52:	10c162        	addi	a6, a1, 16
4200fe55:	209b90        	or	a9, a11, a9
4200fe58:	04b030        	extui	a11, a3, 0, 1
4200fe5b:	2099b0        	or	a9, a9, a11
4200fe5e:	8b2682        	l32i	a8, a6, 0x22c
4200fe61:	5c4916        	beqz	a9, 42010429 <_vfprintf_r+0x2ae5>
4200fe64:	b12192        	l32i	a9, a1, 0x2c4
4200fe67:	0299      	s32i.n	a9, a2, 0
4200fe69:	ad2192        	l32i	a9, a1, 0x2b4
4200fe6c:	898a      	add.n	a8, a9, a8
4200fe6e:	8b6682        	s32i	a8, a6, 0x22c
4200fe71:	8a2682        	l32i	a8, a6, 0x228
4200fe74:	1299      	s32i.n	a9, a2, 4
4200fe76:	881b      	addi.n	a8, a8, 1
4200fe78:	8a6682        	s32i	a8, a6, 0x228
4200fe7b:	0588e6        	bgei	a8, 8, 4200fe84 <_vfprintf_r+0x2540>
4200fe7e:	828b      	addi.n	a8, a2, 8
4200fe80:	000646        	j	4200fe9d <_vfprintf_r+0x2559>
4200fe83:	a2c200        	muluh	a12, a2, a0
4200fe86:	24          	.byte	0x24
4200fe87:	a021b2        	l32i	a11, a1, 0x280
4200fe8a:	a121a2        	l32i	a10, a1, 0x284
4200fe8d:	c6ca      	add.n	a12, a6, a12
4200fe8f:	201110        	or	a1, a1, a1
4200fe92:	00c6a5        	call8	42010afc <__sprint_r>
4200fe95:	687a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fe98:	e4a182        	movi	a8, 0x1e4
4200fe9b:	868a      	add.n	a8, a6, a8
4200fe9d:	952162        	l32i	a6, a1, 0x254
4200fea0:	0706d6        	bgez	a6, 4200ff14 <_vfprintf_r+0x25d0>
4200fea3:	606060        	neg	a6, a6
4200fea6:	08bd      	mov.n	a11, a8
4200fea8:	10c152        	addi	a5, a1, 16
4200feab:	000ac6        	j	4200feda <_vfprintf_r+0x2596>
4200feae:	c20000        	quou	a0, a0, a0
4200feb1:	10cc      	bnez.n	a0, 4200feb6 <_vfprintf_r+0x2572>
4200feb3:	1be9      	s32i.n	a14, a11, 4
4200feb5:	bac9      	s32i.n	a12, a10, 44
4200feb7:	aa99      	s32i.n	a9, a10, 40
4200feb9:	1889a6        	blti	a9, 8, 4200fed5 <_vfprintf_r+0x2591>
4200febc:	24a2c2        	movi	a12, 0x224
4200febf:	a021b2        	l32i	a11, a1, 0x280
4200fec2:	a121a2        	l32i	a10, a1, 0x284
4200fec5:	c5ca      	add.n	a12, a5, a12
4200fec7:	201110        	or	a1, a1, a1
4200feca:	00c325        	call8	42010afc <__sprint_r>
4200fecd:	64fa56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fed0:	e4a182        	movi	a8, 0x1e4
4200fed3:	858a      	add.n	a8, a5, a8
4200fed5:	f0c662        	addi	a6, a6, -16
4200fed8:	08bd      	mov.n	a11, a8
4200feda:	c3f7d1        	l32r	a13, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
4200fedd:	8a2592        	l32i	a9, a5, 0x228
4200fee0:	0e1c      	movi.n	a14, 16
4200fee2:	0bd9      	s32i.n	a13, a11, 0
4200fee4:	02d5a2        	addmi	a10, a5, 0x200
4200fee7:	991b      	addi.n	a9, a9, 1
4200fee9:	888b      	addi.n	a8, a8, 8
4200feeb:	bac8      	l32i.n	a12, a10, 44
4200feed:	bf2e67        	blt	a14, a6, 4200feb0 <_vfprintf_r+0x256c>
4200fef0:	1b69      	s32i.n	a6, a11, 4
4200fef2:	66ca      	add.n	a6, a6, a12
4200fef4:	ba69      	s32i.n	a6, a10, 44
4200fef6:	aa99      	s32i.n	a9, a10, 40
4200fef8:	1889a6        	blti	a9, 8, 4200ff14 <_vfprintf_r+0x25d0>
4200fefb:	24a2c2        	movi	a12, 0x224
4200fefe:	a021b2        	l32i	a11, a1, 0x280
4200ff01:	a121a2        	l32i	a10, a1, 0x284
4200ff04:	c5ca      	add.n	a12, a5, a12
4200ff06:	201110        	or	a1, a1, a1
4200ff09:	00bf25        	call8	42010afc <__sprint_r>
4200ff0c:	610a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200ff0f:	e4a182        	movi	a8, 0x1e4
4200ff12:	858a      	add.n	a8, a5, a8
4200ff14:	9f2192        	l32i	a9, a1, 0x27c
4200ff17:	10c122        	addi	a2, a1, 16
4200ff1a:	0899      	s32i.n	a9, a8, 0
4200ff1c:	a42192        	l32i	a9, a1, 0x290
4200ff1f:	a421b2        	l32i	a11, a1, 0x290
4200ff22:	1899      	s32i.n	a9, a8, 4
4200ff24:	8b2292        	l32i	a9, a2, 0x22c
4200ff27:	99ba      	add.n	a9, a9, a11
4200ff29:	8b6292        	s32i	a9, a2, 0x22c
4200ff2c:	8a2292        	l32i	a9, a2, 0x228
4200ff2f:	991b      	addi.n	a9, a9, 1
4200ff31:	8a6292        	s32i	a9, a2, 0x228
4200ff34:	0289a6        	blti	a9, 8, 4200ff3a <_vfprintf_r+0x25f6>
4200ff37:	013546        	j	42010410 <_vfprintf_r+0x2acc>
4200ff3a:	288b      	addi.n	a2, a8, 8
4200ff3c:	013a46        	j	42010429 <_vfprintf_r+0x2ae5>
4200ff3f:	820000        	mull	a0, a0, a0
4200ff42:	80a421        	l32r	a2, 41ff01d4 <_iram_bss_end+0x1c6ddd4>
4200ff45:	a64346        	j	41ff9856 <_iram_bss_end+0x1c77456>
4200ff48:	823514        	ee.vldbc.32.ip	q0, a1, 212
4200ff4b:	499f21        	l32r	a2, 41fe25c8 <_iram_bss_end+0x1c601c8>
4200ff4e:	12          	.byte	0x12
4200ff4f:	0289      	s32i.n	a8, a2, 0
4200ff51:	849a      	add.n	a8, a4, a9
4200ff53:	be89      	s32i.n	a8, a14, 44
4200ff55:	ae88      	l32i.n	a8, a14, 40
4200ff57:	228b      	addi.n	a2, a2, 8
4200ff59:	881b      	addi.n	a8, a8, 1
4200ff5b:	ae89      	s32i.n	a8, a14, 40
4200ff5d:	1f88a6        	blti	a8, 8, 4200ff80 <_vfprintf_r+0x263c>
4200ff60:	24a2c2        	movi	a12, 0x224
4200ff63:	10c182        	addi	a8, a1, 16
4200ff66:	a021b2        	l32i	a11, a1, 0x280
4200ff69:	a121a2        	l32i	a10, a1, 0x284
4200ff6c:	80c8c0        	add	a12, a8, a12
4200ff6f:	201110        	or	a1, a1, a1
4200ff72:	00b8a5        	call8	42010afc <__sprint_r>
4200ff75:	5a7a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200ff78:	e4a182        	movi	a8, 0x1e4
4200ff7b:	10c192        	addi	a9, a1, 16
4200ff7e:	298a      	add.n	a2, a9, a8
4200ff80:	080c      	movi.n	a8, 0
4200ff82:	534480        	max	a4, a4, a8
4200ff85:	c04640        	sub	a4, a6, a4
4200ff88:	10c1e2        	addi	a14, a1, 16
4200ff8b:	3214e6        	bgei	a4, 1, 4200ffc1 <_vfprintf_r+0x267d>
4200ff8e:	001b86        	j	42010000 <_vfprintf_r+0x26bc>
4200ff91:	10cbb2        	addi	a11, a11, 16
4200ff94:	12d9      	s32i.n	a13, a2, 4
4200ff96:	0b69b2        	s32i	a11, a9, 44
4200ff99:	0a6982        	s32i	a8, a9, 40
4200ff9c:	1c88a6        	blti	a8, 8, 4200ffbc <_vfprintf_r+0x2678>
4200ff9f:	24a2c2        	movi	a12, 0x224
4200ffa2:	a021b2        	l32i	a11, a1, 0x280
4200ffa5:	a121a2        	l32i	a10, a1, 0x284
4200ffa8:	80cec0        	add	a12, a14, a12
4200ffab:	201110        	or	a1, a1, a1
4200ffae:	00b4e5        	call8	42010afc <__sprint_r>
4200ffb1:	56ba56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200ffb4:	e4a1a2        	movi	a10, 0x1e4
4200ffb7:	10c1e2        	addi	a14, a1, 16
4200ffba:	aeaa      	add.n	a10, a14, a10
4200ffbc:	f0c442        	addi	a4, a4, -16
4200ffbf:	0a2d      	mov.n	a2, a10
4200ffc1:	c3bdc1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
4200ffc4:	8a2e82        	l32i	a8, a14, 0x228
4200ffc7:	0d1c      	movi.n	a13, 16
4200ffc9:	02c9      	s32i.n	a12, a2, 0
4200ffcb:	02de92        	addmi	a9, a14, 0x200
4200ffce:	881b      	addi.n	a8, a8, 1
4200ffd0:	a28b      	addi.n	a10, a2, 8
4200ffd2:	b9b8      	l32i.n	a11, a9, 44
4200ffd4:	b92d47        	blt	a13, a4, 4200ff91 <_vfprintf_r+0x264d>
4200ffd7:	1249      	s32i.n	a4, a2, 4
4200ffd9:	44ba      	add.n	a4, a4, a11
4200ffdb:	b949      	s32i.n	a4, a9, 44
4200ffdd:	a989      	s32i.n	a8, a9, 40
4200ffdf:	0a2d      	mov.n	a2, a10
4200ffe1:	1b88a6        	blti	a8, 8, 42010000 <_vfprintf_r+0x26bc>
4200ffe4:	24a2c2        	movi	a12, 0x224
4200ffe7:	a021b2        	l32i	a11, a1, 0x280
4200ffea:	a121a2        	l32i	a10, a1, 0x284
4200ffed:	ceca      	add.n	a12, a14, a12
4200ffef:	201110        	or	a1, a1, a1
4200fff2:	00b0a5        	call8	42010afc <__sprint_r>
4200fff5:	527a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4200fff8:	e4a182        	movi	a8, 0x1e4
4200fffb:	10c1e2        	addi	a14, a1, 16
4200fffe:	2e8a      	add.n	a2, a14, a8
42010000:	9f2182        	l32i	a8, a1, 0x27c
42010003:	686a      	add.n	a6, a8, a6
42010005:	02e3a7        	bbsi	a3, 10, 4201000b <_vfprintf_r+0x26c7>
42010008:	005346        	j	42010159 <_vfprintf_r+0x2815>
4201000b:	10c142        	addi	a4, a1, 16
4201000e:	004ac6        	j	4201013d <_vfprintf_r+0x27f9>
42010011:	ab2182        	l32i	a8, a1, 0x2ac
42010014:	0718a6        	blti	a8, 1, 4201001f <_vfprintf_r+0x26db>
42010017:	880b      	addi.n	a8, a8, -1
42010019:	ab6182        	s32i	a8, a1, 0x2ac
4201001c:	000246        	j	42010029 <_vfprintf_r+0x26e5>
4201001f:	aa2182        	l32i	a8, a1, 0x2a8
42010022:	550b      	addi.n	a5, a5, -1
42010024:	880b      	addi.n	a8, a8, -1
42010026:	aa6182        	s32i	a8, a1, 0x2a8
42010029:	b62182        	l32i	a8, a1, 0x2d8
4201002c:	b021a2        	l32i	a10, a1, 0x2c0
4201002f:	0289      	s32i.n	a8, a2, 0
42010031:	b02182        	l32i	a8, a1, 0x2c0
42010034:	1289      	s32i.n	a8, a2, 4
42010036:	8b2482        	l32i	a8, a4, 0x22c
42010039:	228b      	addi.n	a2, a2, 8
4201003b:	88aa      	add.n	a8, a8, a10
4201003d:	8b6482        	s32i	a8, a4, 0x22c
42010040:	8a2482        	l32i	a8, a4, 0x228
42010043:	881b      	addi.n	a8, a8, 1
42010045:	8a6482        	s32i	a8, a4, 0x228
42010048:	1888a6        	blti	a8, 8, 42010064 <_vfprintf_r+0x2720>
4201004b:	24a2c2        	movi	a12, 0x224
4201004e:	a021b2        	l32i	a11, a1, 0x280
42010051:	a121a2        	l32i	a10, a1, 0x284
42010054:	c4ca      	add.n	a12, a4, a12
42010056:	201110        	or	a1, a1, a1
42010059:	00aa25        	call8	42010afc <__sprint_r>
4201005c:	4c0a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4201005f:	e4a182        	movi	a8, 0x1e4
42010062:	248a      	add.n	a2, a4, a8
42010064:	a42192        	l32i	a9, a1, 0x290
42010067:	9f2182        	l32i	a8, a1, 0x27c
4201006a:	889a      	add.n	a8, a8, a9
4201006c:	c09860        	sub	a9, a8, a6
4201006f:	aa2182        	l32i	a8, a1, 0x2a8
42010072:	000882        	l8ui	a8, a8, 0
42010075:	43d980        	min	a13, a9, a8
42010078:	381da6        	blti	a13, 1, 420100b4 <_vfprintf_r+0x2770>
4201007b:	8b2482        	l32i	a8, a4, 0x22c
4201007e:	0269      	s32i.n	a6, a2, 0
42010080:	8d8a      	add.n	a8, a13, a8
42010082:	8b6482        	s32i	a8, a4, 0x22c
42010085:	8a2482        	l32i	a8, a4, 0x228
42010088:	12d9      	s32i.n	a13, a2, 4
4201008a:	881b      	addi.n	a8, a8, 1
4201008c:	8a6482        	s32i	a8, a4, 0x228
4201008f:	228b      	addi.n	a2, a2, 8
42010091:	1f88a6        	blti	a8, 8, 420100b4 <_vfprintf_r+0x2770>
42010094:	24a2c2        	movi	a12, 0x224
42010097:	a021b2        	l32i	a11, a1, 0x280
4201009a:	a121a2        	l32i	a10, a1, 0x284
4201009d:	80c4c0        	add	a12, a4, a12
420100a0:	a261d2        	s32i	a13, a1, 0x288
420100a3:	201110        	or	a1, a1, a1
420100a6:	00a565        	call8	42010afc <__sprint_r>
420100a9:	473a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
420100ac:	e4a182        	movi	a8, 0x1e4
420100af:	a221d2        	l32i	a13, a1, 0x288
420100b2:	248a      	add.n	a2, a4, a8
420100b4:	aa2182        	l32i	a8, a1, 0x2a8
420100b7:	000892        	l8ui	a9, a8, 0
420100ba:	080c      	movi.n	a8, 0
420100bc:	538d80        	max	a8, a13, a8
420100bf:	c0e980        	sub	a14, a9, a8
420100c2:	6f1ea6        	blti	a14, 1, 42010135 <_vfprintf_r+0x27f1>
420100c5:	000c06        	j	420100f9 <_vfprintf_r+0x27b5>
420100c8:	10cbb2        	addi	a11, a11, 16
420100cb:	12d9      	s32i.n	a13, a2, 4
420100cd:	b9b9      	s32i.n	a11, a9, 44
420100cf:	a989      	s32i.n	a8, a9, 40
420100d1:	1f88a6        	blti	a8, 8, 420100f4 <_vfprintf_r+0x27b0>
420100d4:	24a2c2        	movi	a12, 0x224
420100d7:	a021b2        	l32i	a11, a1, 0x280
420100da:	a121a2        	l32i	a10, a1, 0x284
420100dd:	80c4c0        	add	a12, a4, a12
420100e0:	a261e2        	s32i	a14, a1, 0x288
420100e3:	201110        	or	a1, a1, a1
420100e6:	00a165        	call8	42010afc <__sprint_r>
420100e9:	433a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
420100ec:	e4a1a2        	movi	a10, 0x1e4
420100ef:	a221e2        	l32i	a14, a1, 0x288
420100f2:	a4aa      	add.n	a10, a4, a10
420100f4:	f0cee2        	addi	a14, a14, -16
420100f7:	0a2d      	mov.n	a2, a10
420100f9:	c36fc1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
420100fc:	8a2482        	l32i	a8, a4, 0x228
420100ff:	0d1c      	movi.n	a13, 16
42010101:	02c9      	s32i.n	a12, a2, 0
42010103:	02d492        	addmi	a9, a4, 0x200
42010106:	881b      	addi.n	a8, a8, 1
42010108:	a28b      	addi.n	a10, a2, 8
4201010a:	b9b8      	l32i.n	a11, a9, 44
4201010c:	b82de7        	blt	a13, a14, 420100c8 <_vfprintf_r+0x2784>
4201010f:	beba      	add.n	a11, a14, a11
42010111:	12e9      	s32i.n	a14, a2, 4
42010113:	b9b9      	s32i.n	a11, a9, 44
42010115:	a989      	s32i.n	a8, a9, 40
42010117:	0a2d      	mov.n	a2, a10
42010119:	1888a6        	blti	a8, 8, 42010135 <_vfprintf_r+0x27f1>
4201011c:	24a2c2        	movi	a12, 0x224
4201011f:	a021b2        	l32i	a11, a1, 0x280
42010122:	a121a2        	l32i	a10, a1, 0x284
42010125:	c4ca      	add.n	a12, a4, a12
42010127:	201110        	or	a1, a1, a1
4201012a:	009d25        	call8	42010afc <__sprint_r>
4201012d:	3efa56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
42010130:	e4a182        	movi	a8, 0x1e4
42010133:	248a      	add.n	a2, a4, a8
42010135:	aa2182        	l32i	a8, a1, 0x2a8
42010138:	000882        	l8ui	a8, a8, 0
4201013b:	668a      	add.n	a6, a6, a8
4201013d:	080c      	movi.n	a8, 0
4201013f:	728850        	salt	a8, a8, a5
42010142:	ecb856        	bnez	a8, 42010011 <_vfprintf_r+0x26cd>
42010145:	ab2192        	l32i	a9, a1, 0x2ac
42010148:	02a897        	bge	a8, a9, 4201014e <_vfprintf_r+0x280a>
4201014b:	ffb086        	j	42010011 <_vfprintf_r+0x26cd>
4201014e:	9f2182        	l32i	a8, a1, 0x27c
42010151:	a42192        	l32i	a9, a1, 0x290
42010154:	889a      	add.n	a8, a8, a9
42010156:	636680        	minu	a6, a6, a8
42010159:	952182        	l32i	a8, a1, 0x254
4201015c:	a42192        	l32i	a9, a1, 0x290
4201015f:	022897        	blt	a8, a9, 42010165 <_vfprintf_r+0x2821>
42010162:	3f6307        	bbci	a3, 0, 420101a5 <_vfprintf_r+0x2861>
42010165:	b12182        	l32i	a8, a1, 0x2c4
42010168:	10c152        	addi	a5, a1, 16
4201016b:	0289      	s32i.n	a8, a2, 0
4201016d:	ad2182        	l32i	a8, a1, 0x2b4
42010170:	ad21a2        	l32i	a10, a1, 0x2b4
42010173:	1289      	s32i.n	a8, a2, 4
42010175:	8b2582        	l32i	a8, a5, 0x22c
42010178:	228b      	addi.n	a2, a2, 8
4201017a:	88aa      	add.n	a8, a8, a10
4201017c:	8b6582        	s32i	a8, a5, 0x22c
4201017f:	8a2582        	l32i	a8, a5, 0x228
42010182:	881b      	addi.n	a8, a8, 1
42010184:	8a6582        	s32i	a8, a5, 0x228
42010187:	1a88a6        	blti	a8, 8, 420101a5 <_vfprintf_r+0x2861>
4201018a:	24a2c2        	movi	a12, 0x224
4201018d:	a021b2        	l32i	a11, a1, 0x280
42010190:	a121a2        	l32i	a10, a1, 0x284
42010193:	80c5c0        	add	a12, a5, a12
42010196:	201110        	or	a1, a1, a1
42010199:	009625        	call8	42010afc <__sprint_r>
4201019c:	380a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4201019f:	e4a182        	movi	a8, 0x1e4
420101a2:	802580        	add	a2, a5, a8
420101a5:	a42182        	l32i	a8, a1, 0x290
420101a8:	952152        	l32i	a5, a1, 0x254
420101ab:	a42192        	l32i	a9, a1, 0x290
420101ae:	c05850        	sub	a5, a8, a5
420101b1:	9f2182        	l32i	a8, a1, 0x27c
420101b4:	889a      	add.n	a8, a8, a9
420101b6:	c08860        	sub	a8, a8, a6
420101b9:	435580        	min	a5, a5, a8
420101bc:	3415a6        	blti	a5, 1, 420101f4 <_vfprintf_r+0x28b0>
420101bf:	8f2182        	l32i	a8, a1, 0x23c
420101c2:	0269      	s32i.n	a6, a2, 0
420101c4:	858a      	add.n	a8, a5, a8
420101c6:	8f6182        	s32i	a8, a1, 0x23c
420101c9:	8e2182        	l32i	a8, a1, 0x238
420101cc:	1259      	s32i.n	a5, a2, 4
420101ce:	881b      	addi.n	a8, a8, 1
420101d0:	8e6182        	s32i	a8, a1, 0x238
420101d3:	10c142        	addi	a4, a1, 16
420101d6:	228b      	addi.n	a2, a2, 8
420101d8:	1888a6        	blti	a8, 8, 420101f4 <_vfprintf_r+0x28b0>
420101db:	24a2c2        	movi	a12, 0x224
420101de:	a021b2        	l32i	a11, a1, 0x280
420101e1:	a121a2        	l32i	a10, a1, 0x284
420101e4:	c4ca      	add.n	a12, a4, a12
420101e6:	201110        	or	a1, a1, a1
420101e9:	009125        	call8	42010afc <__sprint_r>
420101ec:	330a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
420101ef:	e4a182        	movi	a8, 0x1e4
420101f2:	248a      	add.n	a2, a4, a8
420101f4:	a42182        	l32i	a8, a1, 0x290
420101f7:	952162        	l32i	a6, a1, 0x254
420101fa:	c06860        	sub	a6, a8, a6
420101fd:	080c      	movi.n	a8, 0
420101ff:	535580        	max	a5, a5, a8
42010202:	c06650        	sub	a6, a6, a5
42010205:	0216e6        	bgei	a6, 1, 4201020b <_vfprintf_r+0x28c7>
42010208:	008746        	j	42010429 <_vfprintf_r+0x2ae5>
4201020b:	10c152        	addi	a5, a1, 16
4201020e:	000ac6        	j	4201023d <_vfprintf_r+0x28f9>
42010211:	10cbb2        	addi	a11, a11, 16
42010214:	12d9      	s32i.n	a13, a2, 4
42010216:	b9b9      	s32i.n	a11, a9, 44
42010218:	0a6982        	s32i	a8, a9, 40
4201021b:	1988a6        	blti	a8, 8, 42010238 <_vfprintf_r+0x28f4>
4201021e:	24a2c2        	movi	a12, 0x224
42010221:	a021b2        	l32i	a11, a1, 0x280
42010224:	a121a2        	l32i	a10, a1, 0x284
42010227:	80c5c0        	add	a12, a5, a12
4201022a:	201110        	or	a1, a1, a1
4201022d:	008ce5        	call8	42010afc <__sprint_r>
42010230:	2eca56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
42010233:	e4a1a2        	movi	a10, 0x1e4
42010236:	a5aa      	add.n	a10, a5, a10
42010238:	f0c662        	addi	a6, a6, -16
4201023b:	0a2d      	mov.n	a2, a10
4201023d:	c31ec1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
42010240:	8a2582        	l32i	a8, a5, 0x228
42010243:	0d1c      	movi.n	a13, 16
42010245:	02c9      	s32i.n	a12, a2, 0
42010247:	02d592        	addmi	a9, a5, 0x200
4201024a:	881b      	addi.n	a8, a8, 1
4201024c:	a28b      	addi.n	a10, a2, 8
4201024e:	b9b8      	l32i.n	a11, a9, 44
42010250:	bd2d67        	blt	a13, a6, 42010211 <_vfprintf_r+0x28cd>
42010253:	1269      	s32i.n	a6, a2, 4
42010255:	66ba      	add.n	a6, a6, a11
42010257:	b969      	s32i.n	a6, a9, 44
42010259:	a989      	s32i.n	a8, a9, 40
4201025b:	0a2d      	mov.n	a2, a10
4201025d:	0288e6        	bgei	a8, 8, 42010263 <_vfprintf_r+0x291f>
42010260:	007146        	j	42010429 <_vfprintf_r+0x2ae5>
42010263:	24a2c2        	movi	a12, 0x224
42010266:	a021b2        	l32i	a11, a1, 0x280
42010269:	a121a2        	l32i	a10, a1, 0x284
4201026c:	c5ca      	add.n	a12, a5, a12
4201026e:	201110        	or	a1, a1, a1
42010271:	0088a5        	call8	42010afc <__sprint_r>
42010274:	2a8a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
42010277:	e4a182        	movi	a8, 0x1e4
4201027a:	258a      	add.n	a2, a5, a8
4201027c:	006a46        	j	42010429 <_vfprintf_r+0x2ae5>
4201027f:	00          	.byte	00
42010280:	ae88      	l32i.n	a8, a14, 40
42010282:	a91b      	addi.n	a10, a9, 1
42010284:	a42192        	l32i	a9, a1, 0x290
42010287:	881b      	addi.n	a8, a8, 1
42010289:	628b      	addi.n	a6, a2, 8
4201028b:	0529e6        	bgei	a9, 2, 42010294 <_vfprintf_r+0x2950>
4201028e:	02e307        	bbsi	a3, 0, 42010294 <_vfprintf_r+0x2950>
42010291:	004d06        	j	420103c9 <_vfprintf_r+0x2a85>
42010294:	9f2192        	l32i	a9, a1, 0x27c
42010297:	8f61a2        	s32i	a10, a1, 0x23c
4201029a:	0299      	s32i.n	a9, a2, 0
4201029c:	190c      	movi.n	a9, 1
4201029e:	016292        	s32i	a9, a2, 4
420102a1:	8e6182        	s32i	a8, a1, 0x238
420102a4:	10c152        	addi	a5, a1, 16
420102a7:	1988a6        	blti	a8, 8, 420102c4 <_vfprintf_r+0x2980>
420102aa:	24a2c2        	movi	a12, 0x224
420102ad:	a021b2        	l32i	a11, a1, 0x280
420102b0:	a121a2        	l32i	a10, a1, 0x284
420102b3:	80c5c0        	add	a12, a5, a12
420102b6:	201110        	or	a1, a1, a1
420102b9:	008425        	call8	42010afc <__sprint_r>
420102bc:	260a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
420102bf:	e4a162        	movi	a6, 0x1e4
420102c2:	656a      	add.n	a6, a5, a6
420102c4:	b12182        	l32i	a8, a1, 0x2c4
420102c7:	10c152        	addi	a5, a1, 16
420102ca:	0689      	s32i.n	a8, a6, 0
420102cc:	ad2182        	l32i	a8, a1, 0x2b4
420102cf:	ad21a2        	l32i	a10, a1, 0x2b4
420102d2:	1689      	s32i.n	a8, a6, 4
420102d4:	8b2582        	l32i	a8, a5, 0x22c
420102d7:	88aa      	add.n	a8, a8, a10
420102d9:	8b6582        	s32i	a8, a5, 0x22c
420102dc:	8a2582        	l32i	a8, a5, 0x228
420102df:	881b      	addi.n	a8, a8, 1
420102e1:	8a6582        	s32i	a8, a5, 0x228
420102e4:	0488e6        	bgei	a8, 8, 420102ec <_vfprintf_r+0x29a8>
420102e7:	668b      	addi.n	a6, a6, 8
420102e9:	000606        	j	42010305 <_vfprintf_r+0x29c1>
420102ec:	24a2c2        	movi	a12, 0x224
420102ef:	a021b2        	l32i	a11, a1, 0x280
420102f2:	a121a2        	l32i	a10, a1, 0x284
420102f5:	c5ca      	add.n	a12, a5, a12
420102f7:	201110        	or	a1, a1, a1
420102fa:	008025        	call8	42010afc <__sprint_r>
420102fd:	21fa56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
42010300:	e4a162        	movi	a6, 0x1e4
42010303:	656a      	add.n	a6, a5, a6
42010305:	a42182        	l32i	a8, a1, 0x290
42010308:	0c0c      	movi.n	a12, 0
4201030a:	580b      	addi.n	a5, a8, -1
4201030c:	98a282        	movi	a8, 0x298
4201030f:	881a      	add.n	a8, a8, a1
42010311:	08a8      	l32i.n	a10, a8, 0
42010313:	18b8      	l32i.n	a11, a8, 4
42010315:	0d0c      	movi.n	a13, 0
42010317:	c2f481        	l32r	a8, 42000ee8 <_stext+0xec8> (4000246c <__nedf2>)
4201031a:	0008e0        	callx8	a8
4201031d:	047a16        	beqz	a10, 42010368 <_vfprintf_r+0x2a24>
42010320:	9f21b2        	l32i	a11, a1, 0x27c
42010323:	8f21c2        	l32i	a12, a1, 0x23c
42010326:	bb1b      	addi.n	a11, a11, 1
42010328:	8e2182        	l32i	a8, a1, 0x238
4201032b:	06b9      	s32i.n	a11, a6, 0
4201032d:	a421b2        	l32i	a11, a1, 0x290
42010330:	cc0b      	addi.n	a12, a12, -1
42010332:	881b      	addi.n	a8, a8, 1
42010334:	ccba      	add.n	a12, a12, a11
42010336:	1659      	s32i.n	a5, a6, 4
42010338:	8f61c2        	s32i	a12, a1, 0x23c
4201033b:	8e6182        	s32i	a8, a1, 0x238
4201033e:	10c1a2        	addi	a10, a1, 16
42010341:	08c662        	addi	a6, a6, 8
42010344:	0288e6        	bgei	a8, 8, 4201034a <_vfprintf_r+0x2a06>
42010347:	002646        	j	420103e4 <_vfprintf_r+0x2aa0>
4201034a:	24a2c2        	movi	a12, 0x224
4201034d:	80cac0        	add	a12, a10, a12
42010350:	a021b2        	l32i	a11, a1, 0x280
42010353:	a121a2        	l32i	a10, a1, 0x284
42010356:	201110        	or	a1, a1, a1
42010359:	007a25        	call8	42010afc <__sprint_r>
4201035c:	1c0a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4201035f:	f4a162        	movi	a6, 0x1f4
42010362:	616a      	add.n	a6, a1, a6
42010364:	001f06        	j	420103e4 <_vfprintf_r+0x2aa0>
42010367:	218200        	srai	a8, a0, 2
4201036a:	a4          	.byte	0xa4
4201036b:	7528a6        	blti	a8, 2, 420103e4 <_vfprintf_r+0x2aa0>
4201036e:	10c142        	addi	a4, a1, 16
42010371:	000a46        	j	4201039e <_vfprintf_r+0x2a5a>
42010374:	10cbb2        	addi	a11, a11, 16
42010377:	16d9      	s32i.n	a13, a6, 4
42010379:	b9b9      	s32i.n	a11, a9, 44
4201037b:	a989      	s32i.n	a8, a9, 40
4201037d:	1888a6        	blti	a8, 8, 42010399 <_vfprintf_r+0x2a55>
42010380:	24a2c2        	movi	a12, 0x224
42010383:	a021b2        	l32i	a11, a1, 0x280
42010386:	a121a2        	l32i	a10, a1, 0x284
42010389:	c4ca      	add.n	a12, a4, a12
4201038b:	201110        	or	a1, a1, a1
4201038e:	0076e5        	call8	42010afc <__sprint_r>
42010391:	18ba56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
42010394:	e4a1a2        	movi	a10, 0x1e4
42010397:	a4aa      	add.n	a10, a4, a10
42010399:	f0c552        	addi	a5, a5, -16
4201039c:	0a6d      	mov.n	a6, a10
4201039e:	c2c6c1        	l32r	a12, 42000eb8 <_stext+0xe98> (3c0286c4 <zeroes$0>)
420103a1:	8a2482        	l32i	a8, a4, 0x228
420103a4:	0d1c      	movi.n	a13, 16
420103a6:	06c9      	s32i.n	a12, a6, 0
420103a8:	02d492        	addmi	a9, a4, 0x200
420103ab:	881b      	addi.n	a8, a8, 1
420103ad:	a68b      	addi.n	a10, a6, 8
420103af:	b9b8      	l32i.n	a11, a9, 44
420103b1:	bf2d57        	blt	a13, a5, 42010374 <_vfprintf_r+0x2a30>
420103b4:	1659      	s32i.n	a5, a6, 4
420103b6:	55ba      	add.n	a5, a5, a11
420103b8:	24a2c2        	movi	a12, 0x224
420103bb:	b959      	s32i.n	a5, a9, 44
420103bd:	a989      	s32i.n	a8, a9, 40
420103bf:	0a6d      	mov.n	a6, a10
420103c1:	c4ca      	add.n	a12, a4, a12
420103c3:	8988e6        	bgei	a8, 8, 42010350 <_vfprintf_r+0x2a0c>
420103c6:	000686        	j	420103e4 <_vfprintf_r+0x2aa0>
420103c9:	9f2192        	l32i	a9, a1, 0x27c
420103cc:	bea9      	s32i.n	a10, a14, 44
420103ce:	0299      	s32i.n	a9, a2, 0
420103d0:	190c      	movi.n	a9, 1
420103d2:	1299      	s32i.n	a9, a2, 4
420103d4:	ae89      	s32i.n	a8, a14, 40
420103d6:	0a88a6        	blti	a8, 8, 420103e4 <_vfprintf_r+0x2aa0>
420103d9:	24a2c2        	movi	a12, 0x224
420103dc:	10c182        	addi	a8, a1, 16
420103df:	c8ca      	add.n	a12, a8, a12
420103e1:	ffdac6        	j	42010350 <_vfprintf_r+0x2a0c>
420103e4:	10c122        	addi	a2, a1, 16
420103e7:	37a282        	movi	a8, 0x237
420103ea:	828a      	add.n	a8, a2, a8
420103ec:	0689      	s32i.n	a8, a6, 0
420103ee:	b72182        	l32i	a8, a1, 0x2dc
420103f1:	b721a2        	l32i	a10, a1, 0x2dc
420103f4:	1689      	s32i.n	a8, a6, 4
420103f6:	8b2282        	l32i	a8, a2, 0x22c
420103f9:	88aa      	add.n	a8, a8, a10
420103fb:	8b6282        	s32i	a8, a2, 0x22c
420103fe:	8a2282        	l32i	a8, a2, 0x228
42010401:	881b      	addi.n	a8, a8, 1
42010403:	8a6282        	s32i	a8, a2, 0x228
42010406:	0688e6        	bgei	a8, 8, 42010410 <_vfprintf_r+0x2acc>
42010409:	268b      	addi.n	a2, a6, 8
4201040b:	000686        	j	42010429 <_vfprintf_r+0x2ae5>
4201040e:	c20000        	quou	a0, a0, a0
42010411:	b224a2        	l32i	a10, a4, 0x2c8
42010414:	a2a021        	l32r	a2, 41ff8e94 <_iram_bss_end+0x1c76a94>
42010417:	caa121        	l32r	a2, 42002e9c <heap_caps_init+0x10> (84800fc8 <_rtc_reserved_end+0x24700fc8>)
4201041a:	1110c2        	l16ui	a12, a0, 34
4201041d:	20          	.byte	0x20
4201041e:	006de5        	call8	42010afc <__sprint_r>
42010421:	0fba56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
42010424:	e4a182        	movi	a8, 0x1e4
42010427:	228a      	add.n	a2, a2, a8
42010429:	1be327        	bbsi	a3, 2, 42010448 <_vfprintf_r+0x2b04>
4201042c:	af2192        	l32i	a9, a1, 0x2bc
4201042f:	ac2182        	l32i	a8, a1, 0x2b0
42010432:	538890        	max	a8, a8, a9
42010435:	ae2192        	l32i	a9, a1, 0x2b8
42010438:	898a      	add.n	a8, a9, a8
4201043a:	ae6182        	s32i	a8, a1, 0x2b8
4201043d:	8f2182        	l32i	a8, a1, 0x23c
42010440:	076816        	beqz	a8, 420104ba <_vfprintf_r+0x2b76>
42010443:	002046        	j	420104c8 <_vfprintf_r+0x2b84>
42010446:	820000        	mull	a0, a0, a0
42010449:	92ac21        	l32r	a2, 41ff4efc <_iram_bss_end+0x1c72afc>
4201044c:	90af21        	l32r	a2, 41ff4708 <_iram_bss_end+0x1c72308>
4201044f:	c068      	l32i.n	a6, a0, 48
42010451:	d716a6        	blti	a6, 1, 4201042c <_vfprintf_r+0x2ae8>
42010454:	10c152        	addi	a5, a1, 16
42010457:	000a46        	j	42010484 <_vfprintf_r+0x2b40>
4201045a:	10caa2        	addi	a10, a10, 16
4201045d:	12c9      	s32i.n	a12, a2, 4
4201045f:	b9a9      	s32i.n	a10, a9, 44
42010461:	a989      	s32i.n	a8, a9, 40
42010463:	228b      	addi.n	a2, a2, 8
42010465:	1888a6        	blti	a8, 8, 42010481 <_vfprintf_r+0x2b3d>
42010468:	24a2c2        	movi	a12, 0x224
4201046b:	a021b2        	l32i	a11, a1, 0x280
4201046e:	a121a2        	l32i	a10, a1, 0x284
42010471:	c5ca      	add.n	a12, a5, a12
42010473:	201110        	or	a1, a1, a1
42010476:	006865        	call8	42010afc <__sprint_r>
42010479:	0a3a56        	bnez	a10, 42010520 <_vfprintf_r+0x2bdc>
4201047c:	e4a182        	movi	a8, 0x1e4
4201047f:	258a      	add.n	a2, a5, a8
42010481:	f0c662        	addi	a6, a6, -16
42010484:	c28cb1        	l32r	a11, 42000eb4 <_stext+0xe94> (3c0286d4 <blanks$1>)
42010487:	8a2582        	l32i	a8, a5, 0x228
4201048a:	0c1c      	movi.n	a12, 16
4201048c:	02b9      	s32i.n	a11, a2, 0
4201048e:	02d592        	addmi	a9, a5, 0x200
42010491:	881b      	addi.n	a8, a8, 1
42010493:	b9a8      	l32i.n	a10, a9, 44
42010495:	c12c67        	blt	a12, a6, 4201045a <_vfprintf_r+0x2b16>
42010498:	1269      	s32i.n	a6, a2, 4
4201049a:	66aa      	add.n	a6, a6, a10
4201049c:	b969      	s32i.n	a6, a9, 44
4201049e:	a989      	s32i.n	a8, a9, 40
420104a0:	8888a6        	blti	a8, 8, 4201042c <_vfprintf_r+0x2ae8>
420104a3:	24a2c2        	movi	a12, 0x224
420104a6:	a021b2        	l32i	a11, a1, 0x280
420104a9:	a121a2        	l32i	a10, a1, 0x284
420104ac:	c5ca      	add.n	a12, a5, a12
420104ae:	201110        	or	a1, a1, a1
420104b1:	0064a5        	call8	42010afc <__sprint_r>
420104b4:	f74a16        	beqz	a10, 4201042c <_vfprintf_r+0x2ae8>
420104b7:	001946        	j	42010520 <_vfprintf_r+0x2bdc>
420104ba:	090c      	movi.n	a9, 0
420104bc:	a92182        	l32i	a8, a1, 0x2a4
420104bf:	8e6192        	s32i	a9, a1, 0x238
420104c2:	e8dc      	bnez.n	a8, 420104e4 <_vfprintf_r+0x2ba0>
420104c4:	f57186        	j	4200da8e <_vfprintf_r+0x14a>
420104c7:	a2c200        	muluh	a12, a2, a0
420104ca:	c18224        	ee.ld.128.usar.ip	q1, a2, 0xfffff820
420104cd:	21b210        	srai	a11, a1, 2
420104d0:	21a2a0        	srai	a10, a10, 2
420104d3:	c8caa1        	l32r	a10, 420027fc <esp_ipc_call_and_wait+0x40> (80f6ed81 <_rtc_reserved_end+0x20e6ed81>)
420104d6:	201110        	or	a1, a1, a1
420104d9:	006225        	call8	42010afc <__sprint_r>
420104dc:	fdaa16        	beqz	a10, 420104ba <_vfprintf_r+0x2b76>
420104df:	000f46        	j	42010520 <_vfprintf_r+0x2bdc>
420104e2:	b20000        	mulsh	a0, a0, a0
420104e5:	a2a921        	l32r	a2, 41ff8f8c <_iram_bss_end+0x1c76b8c>
420104e8:	81a121        	l32r	a2, 41ff0b6c <_iram_bss_end+0x1c6e76c>
420104eb:	c249      	s32i.n	a4, a2, 48
420104ed:	0008e0        	callx8	a8
420104f0:	f56686        	j	4200da8e <_vfprintf_r+0x14a>
420104f3:	218200        	srai	a8, a0, 2
420104f6:	10c1728f 	ee.vmulas.s16.qacc.ld.ip.qup	q0, a8, 32, q5, q7, q4, q1
420104fa:	a8cc      	bnez.n	a8, 42010508 <_vfprintf_r+0x2bc4>
420104fc:	080c      	movi.n	a8, 0
420104fe:	8a6782        	s32i	a8, a7, 0x228
42010501:	02d772        	addmi	a7, a7, 0x200
42010504:	000a06        	j	42010530 <_vfprintf_r+0x2bec>
42010507:	a2c200        	muluh	a12, a2, a0
4201050a:	24          	.byte	0x24
4201050b:	a021b2        	l32i	a11, a1, 0x280
4201050e:	a121a2        	l32i	a10, a1, 0x284
42010511:	c7ca      	add.n	a12, a7, a12
42010513:	201110        	or	a1, a1, a1
42010516:	005e65        	call8	42010afc <__sprint_r>
42010519:	fdfa16        	beqz	a10, 420104fc <_vfprintf_r+0x2bb8>
4201051c:	000406        	j	42010530 <_vfprintf_r+0x2bec>
4201051f:	218200        	srai	a8, a0, 2
42010522:	8ca9      	s32i.n	a10, a12, 32
42010524:	a298      	l32i.n	a9, a2, 40
42010526:	bda121        	l32r	a2, 41fffbac <_iram_bss_end+0x1c7d7ac>
42010529:	8108      	l32i.n	a0, a1, 32
4201052b:	c239      	s32i.n	a3, a2, 48
4201052d:	0008e0        	callx8	a8
42010530:	a02182        	l32i	a8, a1, 0x280
42010533:	192882        	l32i	a8, a8, 100
42010536:	14e807        	bbsi	a8, 0, 4201054e <_vfprintf_r+0x2c0a>
42010539:	a02182        	l32i	a8, a1, 0x280
4201053c:	061882        	l16ui	a8, a8, 12
4201053f:	0be897        	bbsi	a8, 9, 4201054e <_vfprintf_r+0x2c0a>
42010542:	a02182        	l32i	a8, a1, 0x280
42010545:	1628a2        	l32i	a10, a8, 88
42010548:	c23181        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
4201054b:	0008e0        	callx8	a8
4201054e:	a02182        	l32i	a8, a1, 0x280
42010551:	061882        	l16ui	a8, a8, 12
42010554:	146867        	bbci	a8, 6, 4201056c <_vfprintf_r+0x2c28>
42010557:	f51c86        	j	4200d9cd <_vfprintf_r+0x89>
4201055a:	820000        	mull	a0, a0, a0
4201055d:	ada221        	l32r	a2, 41ffbbe8 <_iram_bss_end+0x1c797e8>
42010560:	190c03        	lsi	f0, a12, 100
42010563:	002896        	bltz	a8, 42010569 <_vfprintf_r+0x2c25>
42010566:	fcb1c6        	j	4200f831 <_vfprintf_r+0x1eed>
42010569:	fcccc6        	j	4200f8a0 <_vfprintf_r+0x1f5c>
4201056c:	ae2122        	l32i	a2, a1, 0x2b8
4201056f:	f01d      	retw.n
42010571:	000000        	ill

42010574 <vfprintf>:
42010574:	006136        	entry	a1, 48
42010577:	0149      	s32i.n	a4, a1, 0
42010579:	1159      	s32i.n	a5, a1, 4
4201057b:	026162        	s32i	a6, a1, 8
4201057e:	c22681        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
42010581:	0008e0        	callx8	a8
42010584:	01d8      	l32i.n	a13, a1, 0
42010586:	11e8      	l32i.n	a14, a1, 4
42010588:	21f8      	l32i.n	a15, a1, 8
4201058a:	02bd      	mov.n	a11, a2
4201058c:	03cd      	mov.n	a12, a3
4201058e:	fd3b65        	call8	4200d944 <_vfprintf_r>
42010591:	0a2d      	mov.n	a2, a10
42010593:	f01d      	retw.n
42010595:	000000        	ill

42010598 <__sbprintf>:
42010598:	024136        	entry	a1, 0x120
4201059b:	078d      	mov.n	a8, a7
4201059d:	027d      	mov.n	a7, a2
4201059f:	f0a022        	movi	a2, 240
420105a2:	212a      	add.n	a2, a1, a2
420105a4:	2289      	s32i.n	a8, a2, 8
420105a6:	061382        	l16ui	a8, a3, 12
420105a9:	d97c      	movi.n	a9, -3
420105ab:	108890        	and	a8, a8, a9
420105ae:	465182        	s16i	a8, a1, 140
420105b1:	192382        	l32i	a8, a3, 100
420105b4:	1269      	s32i.n	a6, a2, 4
420105b6:	396182        	s32i	a8, a1, 228
420105b9:	071382        	l16ui	a8, a3, 14
420105bc:	80a062        	movi	a6, 128
420105bf:	475182        	s16i	a8, a1, 142
420105c2:	8388      	l32i.n	a8, a3, 32
420105c4:	226162        	s32i	a6, a1, 136
420105c7:	286182        	s32i	a8, a1, 160
420105ca:	a388      	l32i.n	a8, a3, 40
420105cc:	256162        	s32i	a6, a1, 148
420105cf:	616a      	add.n	a6, a1, a6
420105d1:	0259      	s32i.n	a5, a2, 0
420105d3:	2a6182        	s32i	a8, a1, 168
420105d6:	58c6a2        	addi	a10, a6, 88
420105d9:	080c      	movi.n	a8, 0
420105db:	266182        	s32i	a8, a1, 152
420105de:	206112        	s32i	a1, a1, 128
420105e1:	246112        	s32i	a1, a1, 144
420105e4:	c21781        	l32r	a8, 42000e40 <_stext+0xe20> (40376ab0 <__retarget_lock_init_recursive>)
420105e7:	0008e0        	callx8	a8
420105ea:	02d8      	l32i.n	a13, a2, 0
420105ec:	12e8      	l32i.n	a14, a2, 4
420105ee:	22f8      	l32i.n	a15, a2, 8
420105f0:	04cd      	mov.n	a12, a4
420105f2:	06bd      	mov.n	a11, a6
420105f4:	07ad      	mov.n	a10, a7
420105f6:	fd34e5        	call8	4200d944 <_vfprintf_r>
420105f9:	0a2d      	mov.n	a2, a10
420105fb:	00ea96        	bltz	a10, 4201060d <__sbprintf+0x75>
420105fe:	06bd      	mov.n	a11, a6
42010600:	07ad      	mov.n	a10, a7
42010602:	201110        	or	a1, a1, a1
42010605:	fc5ee5        	call8	4200cbf4 <_fflush_r>
42010608:	f87c      	movi.n	a8, -1
4201060a:	9328a0        	movnez	a2, a8, a10
4201060d:	461182        	l16ui	a8, a1, 140
42010610:	094c      	movi.n	a9, 64
42010612:	080897        	bnone	a8, a9, 4201061e <__sbprintf+0x86>
42010615:	061382        	l16ui	a8, a3, 12
42010618:	208890        	or	a8, a8, a9
4201061b:	065382        	s16i	a8, a3, 12
4201061e:	3621a2        	l32i	a10, a1, 216
42010621:	c1fc81        	l32r	a8, 42000e14 <_stext+0xdf4> (40376ad4 <__retarget_lock_close_recursive>)
42010624:	0008e0        	callx8	a8
42010627:	f01d      	retw.n
42010629:	000000        	ill

4201062c <get_arg$isra$0>:
4201062c:	008136        	entry	a1, 64
4201062f:	102182        	l32i	a8, a1, 64
42010632:	1179      	s32i.n	a7, a1, 4
42010634:	0878      	l32i.n	a7, a8, 0
42010636:	2129      	s32i.n	a2, a1, 8
42010638:	21e8      	l32i.n	a14, a1, 8
4201063a:	0528      	l32i.n	a2, a5, 0
4201063c:	4159      	s32i.n	a5, a1, 16
4201063e:	0169      	s32i.n	a6, a1, 0
42010640:	837370        	moveqz	a7, a3, a7
42010643:	00e306        	j	420109d3 <get_arg$isra$0+0x3a7>
42010646:	771b      	addi.n	a7, a7, 1
42010648:	000782        	l8ui	a8, a7, 0
4201064b:	42f816        	beqz	a8, 42010a7e <get_arg$isra$0+0x452>
4201064e:	dbc8a2        	addi	a10, a8, -37
42010651:	ff1a56        	bnez	a10, 42010646 <get_arg$isra$0+0x1a>
42010654:	426816        	beqz	a8, 42010a7e <get_arg$isra$0+0x452>
42010657:	080c      	movi.n	a8, 0
42010659:	a71b      	addi.n	a10, a7, 1
4201065b:	050c      	movi.n	a5, 0
4201065d:	0d0c      	movi.n	a13, 0
4201065f:	f37c      	movi.n	a3, -1
42010661:	060c      	movi.n	a6, 0
42010663:	3189      	s32i.n	a8, a1, 12
42010665:	000046        	j	4201066a <get_arg$isra$0+0x3e>
42010668:	07ad      	mov.n	a10, a7
4201066a:	c20391        	l32r	a9, 42000e78 <_stext+0xe58> (3c028e7c <__chclass>)
4201066d:	000a82        	l8ui	a8, a10, 0
42010670:	7a1b      	addi.n	a7, a10, 1
42010672:	b98a      	add.n	a11, a9, a8
42010674:	3198      	l32i.n	a9, a1, 12
42010676:	000bc2        	l8ui	a12, a11, 0
42010679:	c200b1        	l32r	a11, 42000e7c <_stext+0xe5c> (3c028e10 <__state_table>)
4201067c:	b0f990        	addx8	a15, a9, a9
4201067f:	bbfa      	add.n	a11, a11, a15
42010681:	bbca      	add.n	a11, a11, a12
42010683:	000b92        	l8ui	a9, a11, 0
42010686:	c1feb1        	l32r	a11, 42000e80 <_stext+0xe60> (3c028da4 <__action_table>)
42010689:	3199      	s32i.n	a9, a1, 12
4201068b:	bbfa      	add.n	a11, a11, a15
4201068d:	bbca      	add.n	a11, a11, a12
4201068f:	000bb2        	l8ui	a11, a11, 0
42010692:	bb0b      	addi.n	a11, a11, -1
42010694:	74b0b0        	extui	a11, a11, 0, 8
42010697:	028bb6        	bltui	a11, 8, 4201069d <get_arg$isra$0+0x71>
4201069a:	00cac6        	j	420109c9 <get_arg$isra$0+0x39d>
4201069d:	c214c1        	l32r	a12, 42000ef0 <_stext+0xed0> (3c028800 <blanks$1+0x12c>)
420106a0:	a0bbc0        	addx4	a11, a11, a12
420106a3:	0bb8      	l32i.n	a11, a11, 0
420106a5:	000ba0        	jx	a11
420106a8:	00          	.byte	00
420106a9:	9a0c00        	trunc.s	a0, f12, 0
420106ac:	00c206        	j	420109b8 <get_arg$isra$0+0x38c>
420106af:	07ad      	mov.n	a10, a7
420106b1:	00ac46        	j	42010966 <get_arg$isra$0+0x33a>
420106b4:	6aa0b2        	movi	a11, 106
420106b7:	3318b7        	beq	a8, a11, 420106ee <get_arg$isra$0+0xc2>
420106ba:	0a3b87        	bltu	a11, a8, 420106c8 <get_arg$isra$0+0x9c>
420106bd:	cb4c      	movi.n	a11, 76
420106bf:	2618b7        	beq	a8, a11, 420106e9 <get_arg$isra$0+0xbd>
420106c2:	68a0b2        	movi	a11, 104
420106c5:	0005c6        	j	420106e0 <get_arg$isra$0+0xb4>
420106c8:	71a0b2        	movi	a11, 113
420106cb:	1f18b7        	beq	a8, a11, 420106ee <get_arg$isra$0+0xc2>
420106ce:	70a0b2        	movi	a11, 112
420106d1:	23bb87        	bgeu	a11, a8, 420106f8 <get_arg$isra$0+0xcc>
420106d4:	74a0b2        	movi	a11, 116
420106d7:	0298b7        	bne	a8, a11, 420106dd <get_arg$isra$0+0xb1>
420106da:	00bac6        	j	420109c9 <get_arg$isra$0+0x39d>
420106dd:	7aa0b2        	movi	a11, 122
420106e0:	0298b7        	bne	a8, a11, 420106e6 <get_arg$isra$0+0xba>
420106e3:	00b886        	j	420109c9 <get_arg$isra$0+0x39d>
420106e6:	000386        	j	420106f8 <get_arg$isra$0+0xcc>
420106e9:	880c      	movi.n	a8, 8
420106eb:	000046        	j	420106f0 <get_arg$isra$0+0xc4>
420106ee:	082c      	movi.n	a8, 32
420106f0:	206680        	or	a6, a6, a8
420106f3:	00b486        	j	420109c9 <get_arg$isra$0+0x39d>
420106f6:	b20000        	mulsh	a0, a0, a0
420106f9:	010a      	add.n	a0, a1, a0
420106fb:	6ca082        	movi	a8, 108
420106fe:	0a9b87        	bne	a11, a8, 4201070c <get_arg$isra$0+0xe0>
42010701:	082c      	movi.n	a8, 32
42010703:	206680        	or	a6, a6, a8
42010706:	7a2b      	addi.n	a7, a10, 2
42010708:	00af46        	j	420109c9 <get_arg$isra$0+0x39d>
4201070b:	081c00        	lsx	f1, a12, a0
4201070e:	fff786        	j	420106f0 <get_arg$isra$0+0xc4>
42010711:	61a0b2        	movi	a11, 97
42010714:	44a020        	extui	a10, a2, 0, 5
42010717:	0298b7        	bne	a8, a11, 4201071d <get_arg$isra$0+0xf1>
4201071a:	00e506        	j	42010ab2 <get_arg$isra$0+0x486>
4201071d:	3b3b87        	bltu	a11, a8, 4201075c <get_arg$isra$0+0x130>
42010720:	bfc882        	addi	a8, a8, -65
42010723:	748080        	extui	a8, a8, 0, 8
42010726:	7b1c      	movi.n	a11, 23
42010728:	24bb87        	bgeu	a11, a8, 42010750 <get_arg$isra$0+0x124>
4201072b:	001686        	j	42010789 <get_arg$isra$0+0x15d>
4201072e:	180c      	movi.n	a8, 1
42010730:	401b00        	ssl	a11
42010733:	a18800        	sll	a8, a8
42010736:	c1d4b1        	l32r	a11, 42000e88 <_stext+0xe68> (120821 <UserFrameTotalSize+0x120721>)
42010739:	3388b7        	bany	a8, a11, 42010770 <get_arg$isra$0+0x144>
4201073c:	5b2c      	movi.n	a11, 37
4201073e:	11bb60        	slli	a11, a11, 10
42010741:	0208b7        	bnone	a8, a11, 42010747 <get_arg$isra$0+0x11b>
42010744:	00dd46        	j	42010abd <get_arg$isra$0+0x491>
42010747:	248180        	extui	a8, a8, 1, 3
4201074a:	364856        	bnez	a8, 42010ab2 <get_arg$isra$0+0x486>
4201074d:	000e06        	j	42010789 <get_arg$isra$0+0x15d>
42010750:	c1e9b1        	l32r	a11, 42000ef4 <_stext+0xed4> (3c028820 <blanks$1+0x14c>)
42010753:	a088b0        	addx4	a8, a8, a11
42010756:	0888      	l32i.n	a8, a8, 0
42010758:	0008a0        	jx	a8
4201075b:	a0b200        	addx4	a11, a2, a0
4201075e:	63          	.byte	0x63
4201075f:	1918b7        	beq	a8, a11, 4201077c <get_arg$isra$0+0x150>
42010762:	9cc882        	addi	a8, a8, -100
42010765:	74b080        	extui	a11, a8, 0, 8
42010768:	481c      	movi.n	a8, 20
4201076a:	c0b8b7        	bgeu	a8, a11, 4201072e <get_arg$isra$0+0x102>
4201076d:	000606        	j	42010789 <get_arg$isra$0+0x15d>
42010770:	045560        	extui	a5, a6, 5, 1
42010773:	555a      	add.n	a5, a5, a5
42010775:	106647        	bbci	a6, 4, 42010789 <get_arg$isra$0+0x15d>
42010778:	00d806        	j	42010adc <get_arg$isra$0+0x4b0>
4201077b:	051c00        	extui	a1, a0, 28, 1
4201077e:	105650        	and	a5, a6, a5
42010781:	34c556        	bnez	a5, 42010ad1 <get_arg$isra$0+0x4a5>
42010784:	00d006        	j	42010ac8 <get_arg$isra$0+0x49c>
42010787:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
4201078a:	880b03        	lsi	f0, a11, 0x220
4201078d:	0a2d11        	l32r	a1, 41fd3044 <_iram_bss_end+0x1c50c44>
42010790:	a08380        	addx4	a8, a3, a8
42010793:	0859      	s32i.n	a5, a8, 0
42010795:	008c06        	j	420109c9 <get_arg$isra$0+0x39d>
42010798:	b50b      	addi.n	a11, a5, -1
4201079a:	2488      	l32i.n	a8, a4, 8
4201079c:	2a1b      	addi.n	a2, a10, 1
4201079e:	026bb6        	bltui	a11, 6, 420107a4 <get_arg$isra$0+0x178>
420107a1:	002806        	j	42010845 <get_arg$isra$0+0x219>
420107a4:	c1d5c1        	l32r	a12, 42000ef8 <_stext+0xed8> (3c028880 <blanks$1+0x1ac>)
420107a7:	a0bbc0        	addx4	a11, a11, a12
420107aa:	0bc8      	l32i.n	a12, a11, 0
420107ac:	f4b0a0        	extui	a11, a10, 0, 16
420107af:	000ca0        	jx	a12
420107b2:	0188      	l32i.n	a8, a1, 0
420107b4:	24b8      	l32i.n	a11, a4, 8
420107b6:	2a1b      	addi.n	a2, a10, 1
420107b8:	b0aa80        	addx8	a10, a10, a8
420107bb:	8b4b      	addi.n	a8, a11, 4
420107bd:	2489      	s32i.n	a8, a4, 8
420107bf:	8c1c      	movi.n	a12, 24
420107c1:	042c87        	blt	a12, a8, 420107c9 <get_arg$isra$0+0x19d>
420107c4:	14b8      	l32i.n	a11, a4, 4
420107c6:	000206        	j	420107d2 <get_arg$isra$0+0x1a6>
420107c9:	012cb7        	blt	a12, a11, 420107ce <get_arg$isra$0+0x1a2>
420107cc:	482c      	movi.n	a8, 36
420107ce:	04b8      	l32i.n	a11, a4, 0
420107d0:	2489      	s32i.n	a8, a4, 8
420107d2:	bb8a      	add.n	a11, a11, a8
420107d4:	fccbb2        	addi	a11, a11, -4
420107d7:	0b88      	l32i.n	a8, a11, 0
420107d9:	f37c      	movi.n	a3, -1
420107db:	0a89      	s32i.n	a8, a10, 0
420107dd:	150c      	movi.n	a5, 1
420107df:	007986        	j	420109c9 <get_arg$isra$0+0x39d>
420107e2:	8a7c      	movi.n	a10, -8
420107e4:	887b      	addi.n	a8, a8, 7
420107e6:	1088a0        	and	a8, a8, a10
420107e9:	0198      	l32i.n	a9, a1, 0
420107eb:	a88b      	addi.n	a10, a8, 8
420107ed:	24a9      	s32i.n	a10, a4, 8
420107ef:	8c1c      	movi.n	a12, 24
420107f1:	b0bb90        	addx8	a11, a11, a9
420107f4:	042ca7        	blt	a12, a10, 420107fc <get_arg$isra$0+0x1d0>
420107f7:	1488      	l32i.n	a8, a4, 4
420107f9:	000206        	j	42010805 <get_arg$isra$0+0x1d9>
420107fc:	012c87        	blt	a12, a8, 42010801 <get_arg$isra$0+0x1d5>
420107ff:	8a2c      	movi.n	a10, 40
42010801:	0488      	l32i.n	a8, a4, 0
42010803:	24a9      	s32i.n	a10, a4, 8
42010805:	88aa      	add.n	a8, a8, a10
42010807:	f8c882        	addi	a8, a8, -8
4201080a:	1898      	l32i.n	a9, a8, 4
4201080c:	0888      	l32i.n	a8, a8, 0
4201080e:	1b99      	s32i.n	a9, a11, 4
42010810:	0b89      	s32i.n	a8, a11, 0
42010812:	006cc6        	j	420109c9 <get_arg$isra$0+0x39d>
42010815:	0188      	l32i.n	a8, a1, 0
42010817:	24b8      	l32i.n	a11, a4, 8
42010819:	2a1b      	addi.n	a2, a10, 1
4201081b:	b0aa80        	addx8	a10, a10, a8
4201081e:	8b4b      	addi.n	a8, a11, 4
42010820:	2489      	s32i.n	a8, a4, 8
42010822:	8c1c      	movi.n	a12, 24
42010824:	042c87        	blt	a12, a8, 4201082c <get_arg$isra$0+0x200>
42010827:	14b8      	l32i.n	a11, a4, 4
42010829:	000206        	j	42010835 <get_arg$isra$0+0x209>
4201082c:	012cb7        	blt	a12, a11, 42010831 <get_arg$isra$0+0x205>
4201082f:	482c      	movi.n	a8, 36
42010831:	04b8      	l32i.n	a11, a4, 0
42010833:	2489      	s32i.n	a8, a4, 8
42010835:	bb8a      	add.n	a11, a11, a8
42010837:	fccbb2        	addi	a11, a11, -4
4201083a:	0b88      	l32i.n	a8, a11, 0
4201083c:	f37c      	movi.n	a3, -1
4201083e:	0a89      	s32i.n	a8, a10, 0
42010840:	650c      	movi.n	a5, 6
42010842:	0060c6        	j	420109c9 <get_arg$isra$0+0x39d>
42010845:	0188      	l32i.n	a8, a1, 0
42010847:	24b8      	l32i.n	a11, a4, 8
42010849:	2a1b      	addi.n	a2, a10, 1
4201084b:	b0aa80        	addx8	a10, a10, a8
4201084e:	8b4b      	addi.n	a8, a11, 4
42010850:	2489      	s32i.n	a8, a4, 8
42010852:	8c1c      	movi.n	a12, 24
42010854:	042c87        	blt	a12, a8, 4201085c <get_arg$isra$0+0x230>
42010857:	14b8      	l32i.n	a11, a4, 4
42010859:	000206        	j	42010865 <get_arg$isra$0+0x239>
4201085c:	012cb7        	blt	a12, a11, 42010861 <get_arg$isra$0+0x235>
4201085f:	482c      	movi.n	a8, 36
42010861:	04b8      	l32i.n	a11, a4, 0
42010863:	2489      	s32i.n	a8, a4, 8
42010865:	bb8a      	add.n	a11, a11, a8
42010867:	fccbb2        	addi	a11, a11, -4
4201086a:	0b88      	l32i.n	a8, a11, 0
4201086c:	f37c      	movi.n	a3, -1
4201086e:	0a89      	s32i.n	a8, a10, 0
42010870:	050c      	movi.n	a5, 0
42010872:	0054c6        	j	420109c9 <get_arg$isra$0+0x39d>
42010875:	0188      	l32i.n	a8, a1, 0
42010877:	24b8      	l32i.n	a11, a4, 8
42010879:	2a1b      	addi.n	a2, a10, 1
4201087b:	b0aa80        	addx8	a10, a10, a8
4201087e:	8b4b      	addi.n	a8, a11, 4
42010880:	2489      	s32i.n	a8, a4, 8
42010882:	8c1c      	movi.n	a12, 24
42010884:	042c87        	blt	a12, a8, 4201088c <get_arg$isra$0+0x260>
42010887:	14b8      	l32i.n	a11, a4, 4
42010889:	000206        	j	42010895 <get_arg$isra$0+0x269>
4201088c:	012cb7        	blt	a12, a11, 42010891 <get_arg$isra$0+0x265>
4201088f:	482c      	movi.n	a8, 36
42010891:	04b8      	l32i.n	a11, a4, 0
42010893:	2489      	s32i.n	a8, a4, 8
42010895:	bb8a      	add.n	a11, a11, a8
42010897:	fccbb2        	addi	a11, a11, -4
4201089a:	0b88      	l32i.n	a8, a11, 0
4201089c:	f37c      	movi.n	a3, -1
4201089e:	0a89      	s32i.n	a8, a10, 0
420108a0:	350c      	movi.n	a5, 3
420108a2:	0048c6        	j	420109c9 <get_arg$isra$0+0x39d>
420108a5:	0188      	l32i.n	a8, a1, 0
420108a7:	2a1b      	addi.n	a2, a10, 1
420108a9:	b0aa80        	addx8	a10, a10, a8
420108ac:	2488      	l32i.n	a8, a4, 8
420108ae:	8b7c      	movi.n	a11, -8
420108b0:	887b      	addi.n	a8, a8, 7
420108b2:	1088b0        	and	a8, a8, a11
420108b5:	b88b      	addi.n	a11, a8, 8
420108b7:	24b9      	s32i.n	a11, a4, 8
420108b9:	8c1c      	movi.n	a12, 24
420108bb:	052cb7        	blt	a12, a11, 420108c4 <get_arg$isra$0+0x298>
420108be:	1488      	l32i.n	a8, a4, 4
420108c0:	000246        	j	420108cd <get_arg$isra$0+0x2a1>
420108c3:	00          	.byte	00
420108c4:	012c87        	blt	a12, a8, 420108c9 <get_arg$isra$0+0x29d>
420108c7:	8b2c      	movi.n	a11, 40
420108c9:	0488      	l32i.n	a8, a4, 0
420108cb:	24b9      	s32i.n	a11, a4, 8
420108cd:	88ba      	add.n	a8, a8, a11
420108cf:	f8c882        	addi	a8, a8, -8
420108d2:	1898      	l32i.n	a9, a8, 4
420108d4:	0888      	l32i.n	a8, a8, 0
420108d6:	f37c      	movi.n	a3, -1
420108d8:	0a89      	s32i.n	a8, a10, 0
420108da:	1a99      	s32i.n	a9, a10, 4
420108dc:	450c      	movi.n	a5, 4
420108de:	0039c6        	j	420109c9 <get_arg$isra$0+0x39d>
420108e1:	8a7c      	movi.n	a10, -8
420108e3:	887b      	addi.n	a8, a8, 7
420108e5:	1088a0        	and	a8, a8, a10
420108e8:	0198      	l32i.n	a9, a1, 0
420108ea:	a88b      	addi.n	a10, a8, 8
420108ec:	24a9      	s32i.n	a10, a4, 8
420108ee:	8c1c      	movi.n	a12, 24
420108f0:	b0bb90        	addx8	a11, a11, a9
420108f3:	052ca7        	blt	a12, a10, 420108fc <get_arg$isra$0+0x2d0>
420108f6:	1488      	l32i.n	a8, a4, 4
420108f8:	000246        	j	42010905 <get_arg$isra$0+0x2d9>
420108fb:	00          	.byte	00
420108fc:	012c87        	blt	a12, a8, 42010901 <get_arg$isra$0+0x2d5>
420108ff:	8a2c      	movi.n	a10, 40
42010901:	0488      	l32i.n	a8, a4, 0
42010903:	24a9      	s32i.n	a10, a4, 8
42010905:	88aa      	add.n	a8, a8, a10
42010907:	f8c882        	addi	a8, a8, -8
4201090a:	1898      	l32i.n	a9, a8, 4
4201090c:	0888      	l32i.n	a8, a8, 0
4201090e:	1b99      	s32i.n	a9, a11, 4
42010910:	0b89      	s32i.n	a8, a11, 0
42010912:	002cc6        	j	420109c9 <get_arg$isra$0+0x39d>
42010915:	1188      	l32i.n	a8, a1, 4
42010917:	0888      	l32i.n	a8, a8, 0
42010919:	140866        	bnei	a8, -1, 42010931 <get_arg$isra$0+0x305>
4201091c:	11a8      	l32i.n	a10, a1, 4
4201091e:	80a0c2        	movi	a12, 128
42010921:	0b0c      	movi.n	a11, 0
42010923:	61d9      	s32i.n	a13, a1, 24
42010925:	51e9      	s32i.n	a14, a1, 20
42010927:	be7781        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4201092a:	0008e0        	callx8	a8
4201092d:	61d8      	l32i.n	a13, a1, 24
4201092f:	51e8      	l32i.n	a14, a1, 20
42010931:	3d0b      	addi.n	a3, a13, -1
42010933:	53ee30        	max	a14, a14, a3
42010936:	0023c6        	j	420109c9 <get_arg$isra$0+0x39d>
42010939:	1188      	l32i.n	a8, a1, 4
4201093b:	0888      	l32i.n	a8, a8, 0
4201093d:	140866        	bnei	a8, -1, 42010955 <get_arg$isra$0+0x329>
42010940:	11a8      	l32i.n	a10, a1, 4
42010942:	80a0c2        	movi	a12, 128
42010945:	0b0c      	movi.n	a11, 0
42010947:	61d9      	s32i.n	a13, a1, 24
42010949:	51e9      	s32i.n	a14, a1, 20
4201094b:	be6e81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
4201094e:	0008e0        	callx8	a8
42010951:	61d8      	l32i.n	a13, a1, 24
42010953:	51e8      	l32i.n	a14, a1, 20
42010955:	1188      	l32i.n	a8, a1, 4
42010957:	dd0b      	addi.n	a13, a13, -1
42010959:	a08d80        	addx4	a8, a13, a8
4201095c:	0a0c      	movi.n	a10, 0
4201095e:	08a9      	s32i.n	a10, a8, 0
42010960:	53eed0        	max	a14, a14, a13
42010963:	001886        	j	420109c9 <get_arg$isra$0+0x39d>
42010966:	0188      	l32i.n	a8, a1, 0
42010968:	24b8      	l32i.n	a11, a4, 8
4201096a:	f21b      	addi.n	a15, a2, 1
4201096c:	b02280        	addx8	a2, a2, a8
4201096f:	8b4b      	addi.n	a8, a11, 4
42010971:	2489      	s32i.n	a8, a4, 8
42010973:	8c1c      	movi.n	a12, 24
42010975:	042c87        	blt	a12, a8, 4201097d <get_arg$isra$0+0x351>
42010978:	14b8      	l32i.n	a11, a4, 4
4201097a:	000206        	j	42010986 <get_arg$isra$0+0x35a>
4201097d:	012cb7        	blt	a12, a11, 42010982 <get_arg$isra$0+0x356>
42010980:	482c      	movi.n	a8, 36
42010982:	04b8      	l32i.n	a11, a4, 0
42010984:	2489      	s32i.n	a8, a4, 8
42010986:	bb8a      	add.n	a11, a11, a8
42010988:	fccbb2        	addi	a11, a11, -4
4201098b:	0b88      	l32i.n	a8, a11, 0
4201098d:	0a7d      	mov.n	a7, a10
4201098f:	0289      	s32i.n	a8, a2, 0
42010991:	0f2d      	mov.n	a2, a15
42010993:	000c86        	j	420109c9 <get_arg$isra$0+0x39d>
42010996:	d20000        	quos	a0, a0, a0
42010999:	d0c8      	l32i.n	a12, a0, 52
4201099b:	9a0c      	movi.n	a10, 9
4201099d:	0001c6        	j	420109a8 <get_arg$isra$0+0x37c>
420109a0:	a0ddd0        	addx4	a13, a13, a13
420109a3:	90dd80        	addx2	a13, a13, a8
420109a6:	771b      	addi.n	a7, a7, 1
420109a8:	000782        	l8ui	a8, a7, 0
420109ab:	a89c      	beqz.n	a8, 420109c9 <get_arg$isra$0+0x39d>
420109ad:	d0c882        	addi	a8, a8, -48
420109b0:	ecba87        	bgeu	a10, a8, 420109a0 <get_arg$isra$0+0x374>
420109b3:	000486        	j	420109c9 <get_arg$isra$0+0x39d>
420109b6:	820000        	mull	a0, a0, a0
420109b9:	820007        	bnone	a0, a0, 4201093f <get_arg$isra$0+0x313>
420109bc:	d0c8      	l32i.n	a12, a0, 52
420109be:	748080        	extui	a8, a8, 0, 8
420109c1:	043a87        	bltu	a10, a8, 420109c9 <get_arg$isra$0+0x39d>
420109c4:	771b      	addi.n	a7, a7, 1
420109c6:	fffb86        	j	420109b8 <get_arg$isra$0+0x38c>
420109c9:	3198      	l32i.n	a9, a1, 12
420109cb:	b80c      	movi.n	a8, 11
420109cd:	021987        	beq	a9, a8, 420109d3 <get_arg$isra$0+0x3a7>
420109d0:	ff2506        	j	42010668 <get_arg$isra$0+0x3c>
420109d3:	0007a2        	l8ui	a10, a7, 0
420109d6:	ea8c      	beqz.n	a10, 420109e8 <get_arg$isra$0+0x3bc>
420109d8:	2188      	l32i.n	a8, a1, 8
420109da:	728820        	salt	a8, a8, a2
420109dd:	880b      	addi.n	a8, a8, -1
420109df:	608080        	neg	a8, a8
420109e2:	748080        	extui	a8, a8, 0, 8
420109e5:	c5f856        	bnez	a8, 42010648 <get_arg$isra$0+0x1c>
420109e8:	2188      	l32i.n	a8, a1, 8
420109ea:	93e8a0        	movnez	a14, a8, a10
420109ed:	002346        	j	42010a7e <get_arg$isra$0+0x452>
420109f0:	1188      	l32i.n	a8, a1, 4
420109f2:	a08d80        	addx4	a8, a13, a8
420109f5:	08c8      	l32i.n	a12, a8, 0
420109f7:	dd1b      	addi.n	a13, a13, 1
420109f9:	cc0b      	addi.n	a12, a12, -1
420109fb:	2488      	l32i.n	a8, a4, 8
420109fd:	5c6cf6        	bgeui	a12, 6, 42010a5d <get_arg$isra$0+0x431>
42010a00:	a0cc60        	addx4	a12, a12, a6
42010a03:	0cc8      	l32i.n	a12, a12, 0
42010a05:	000ca0        	jx	a12
42010a08:	887b      	addi.n	a8, a8, 7
42010a0a:	1088f0        	and	a8, a8, a15
42010a0d:	c88b      	addi.n	a12, a8, 8
42010a0f:	24c9      	s32i.n	a12, a4, 8
42010a11:	042ac7        	blt	a10, a12, 42010a19 <get_arg$isra$0+0x3ed>
42010a14:	1488      	l32i.n	a8, a4, 4
42010a16:	000206        	j	42010a22 <get_arg$isra$0+0x3f6>
42010a19:	012a87        	blt	a10, a8, 42010a1e <get_arg$isra$0+0x3f2>
42010a1c:	8c2c      	movi.n	a12, 40
42010a1e:	0488      	l32i.n	a8, a4, 0
42010a20:	24c9      	s32i.n	a12, a4, 8
42010a22:	88ca      	add.n	a8, a8, a12
42010a24:	f8c882        	addi	a8, a8, -8
42010a27:	1898      	l32i.n	a9, a8, 4
42010a29:	0888      	l32i.n	a8, a8, 0
42010a2b:	1b99      	s32i.n	a9, a11, 4
42010a2d:	0b89      	s32i.n	a8, a11, 0
42010a2f:	001706        	j	42010a8f <get_arg$isra$0+0x463>
42010a32:	887b      	addi.n	a8, a8, 7
42010a34:	1088f0        	and	a8, a8, a15
42010a37:	c88b      	addi.n	a12, a8, 8
42010a39:	24c9      	s32i.n	a12, a4, 8
42010a3b:	052ac7        	blt	a10, a12, 42010a44 <get_arg$isra$0+0x418>
42010a3e:	1488      	l32i.n	a8, a4, 4
42010a40:	000246        	j	42010a4d <get_arg$isra$0+0x421>
42010a43:	2a8700        	mul.s	f8, f7, f0
42010a46:	8c2c01        	l32r	a0, 41ff3af8 <_iram_bss_end+0x1c716f8>
42010a49:	0488      	l32i.n	a8, a4, 0
42010a4b:	24c9      	s32i.n	a12, a4, 8
42010a4d:	88ca      	add.n	a8, a8, a12
42010a4f:	f8c882        	addi	a8, a8, -8
42010a52:	1898      	l32i.n	a9, a8, 4
42010a54:	0888      	l32i.n	a8, a8, 0
42010a56:	1b99      	s32i.n	a9, a11, 4
42010a58:	0b89      	s32i.n	a8, a11, 0
42010a5a:	000c46        	j	42010a8f <get_arg$isra$0+0x463>
42010a5d:	c84b      	addi.n	a12, a8, 4
42010a5f:	24c9      	s32i.n	a12, a4, 8
42010a61:	042ac7        	blt	a10, a12, 42010a69 <get_arg$isra$0+0x43d>
42010a64:	1488      	l32i.n	a8, a4, 4
42010a66:	000206        	j	42010a72 <get_arg$isra$0+0x446>
42010a69:	012a87        	blt	a10, a8, 42010a6e <get_arg$isra$0+0x442>
42010a6c:	4c2c      	movi.n	a12, 36
42010a6e:	0488      	l32i.n	a8, a4, 0
42010a70:	24c9      	s32i.n	a12, a4, 8
42010a72:	88ca      	add.n	a8, a8, a12
42010a74:	fcc882        	addi	a8, a8, -4
42010a77:	0888      	l32i.n	a8, a8, 0
42010a79:	0b89      	s32i.n	a8, a11, 0
42010a7b:	000406        	j	42010a8f <get_arg$isra$0+0x463>
42010a7e:	0188      	l32i.n	a8, a1, 0
42010a80:	c11f61        	l32r	a6, 42000efc <_stext+0xedc> (3c028898 <blanks$1+0x1c4>)
42010a83:	b0b280        	addx8	a11, a2, a8
42010a86:	02dd      	mov.n	a13, a2
42010a88:	8a1c      	movi.n	a10, 24
42010a8a:	8f7c      	movi.n	a15, -8
42010a8c:	000046        	j	42010a91 <get_arg$isra$0+0x465>
42010a8f:	bb8b      	addi.n	a11, a11, 8
42010a91:	022ed7        	blt	a14, a13, 42010a97 <get_arg$isra$0+0x46b>
42010a94:	ffd606        	j	420109f0 <get_arg$isra$0+0x3c4>
42010a97:	8e1b      	addi.n	a8, a14, 1
42010a99:	728820        	salt	a8, a8, a2
42010a9c:	880b      	addi.n	a8, a8, -1
42010a9e:	608080        	neg	a8, a8
42010aa1:	748080        	extui	a8, a8, 0, 8
42010aa4:	0a0c      	movi.n	a10, 0
42010aa6:	d8bc      	beqz.n	a8, 42010ae7 <get_arg$isra$0+0x4bb>
42010aa8:	820b      	addi.n	a8, a2, -1
42010aaa:	608080        	neg	a8, a8
42010aad:	a8ea      	add.n	a10, a8, a14
42010aaf:	000d06        	j	42010ae7 <get_arg$isra$0+0x4bb>
42010ab2:	450c      	movi.n	a5, 4
42010ab4:	020326        	beqi	a3, -1, 42010aba <get_arg$isra$0+0x48e>
42010ab7:	ff3446        	j	4201078c <get_arg$isra$0+0x160>
42010aba:	ff79c6        	j	420108a5 <get_arg$isra$0+0x279>
42010abd:	350c      	movi.n	a5, 3
42010abf:	020326        	beqi	a3, -1, 42010ac5 <get_arg$isra$0+0x499>
42010ac2:	ff3186        	j	4201078c <get_arg$isra$0+0x160>
42010ac5:	ff6b06        	j	42010875 <get_arg$isra$0+0x249>
42010ac8:	020326        	beqi	a3, -1, 42010ace <get_arg$isra$0+0x4a2>
42010acb:	ff2f46        	j	4201078c <get_arg$isra$0+0x160>
42010ace:	ff5cc6        	j	42010845 <get_arg$isra$0+0x219>
42010ad1:	650c      	movi.n	a5, 6
42010ad3:	020326        	beqi	a3, -1, 42010ad9 <get_arg$isra$0+0x4ad>
42010ad6:	ff2c86        	j	4201078c <get_arg$isra$0+0x160>
42010ad9:	ff4e06        	j	42010815 <get_arg$isra$0+0x1e9>
42010adc:	150c      	movi.n	a5, 1
42010ade:	020326        	beqi	a3, -1, 42010ae4 <get_arg$isra$0+0x4b8>
42010ae1:	ff29c6        	j	4201078c <get_arg$isra$0+0x160>
42010ae4:	ff3286        	j	420107b2 <get_arg$isra$0+0x186>
42010ae7:	4198      	l32i.n	a9, a1, 16
42010ae9:	8a2a      	add.n	a8, a10, a2
42010aeb:	0989      	s32i.n	a8, a9, 0
42010aed:	102182        	l32i	a8, a1, 64
42010af0:	0198      	l32i.n	a9, a1, 0
42010af2:	0879      	s32i.n	a7, a8, 0
42010af4:	2188      	l32i.n	a8, a1, 8
42010af6:	b02890        	addx8	a2, a8, a9
42010af9:	f01d      	retw.n
	...

42010afc <__sprint_r>:
42010afc:	004136        	entry	a1, 32
42010aff:	2488      	l32i.n	a8, a4, 8
42010b01:	02ad      	mov.n	a10, a2
42010b03:	03bd      	mov.n	a11, a3
42010b05:	020c      	movi.n	a2, 0
42010b07:	d88c      	beqz.n	a8, 42010b18 <__sprint_r+0x1c>
42010b09:	20c440        	or	a12, a4, a4
42010b0c:	201110        	or	a1, a1, a1
42010b0f:	fc39e5        	call8	4200ceac <__sfvwrite_r>
42010b12:	080c      	movi.n	a8, 0
42010b14:	0a2d      	mov.n	a2, a10
42010b16:	2489      	s32i.n	a8, a4, 8
42010b18:	080c      	movi.n	a8, 0
42010b1a:	1489      	s32i.n	a8, a4, 4
42010b1c:	f01d      	retw.n
	...

42010b20 <_vfiprintf_r>:
42010b20:	058136        	entry	a1, 0x2c0
42010b23:	996142        	s32i	a4, a1, 0x264
42010b26:	9b6122        	s32i	a2, a1, 0x26c
42010b29:	986132        	s32i	a3, a1, 0x260
42010b2c:	946152        	s32i	a5, a1, 0x250
42010b2f:	956162        	s32i	a6, a1, 0x254
42010b32:	966172        	s32i	a7, a1, 0x258
42010b35:	10c142        	addi	a4, a1, 16
42010b38:	c28c      	beqz.n	a2, 42010b48 <_vfiprintf_r+0x28>
42010b3a:	0a2282        	l32i	a8, a2, 40
42010b3d:	007856        	bnez	a8, 42010b48 <_vfiprintf_r+0x28>
42010b40:	02ad      	mov.n	a10, a2
42010b42:	201110        	or	a1, a1, a1
42010b45:	fc3165        	call8	4200ce5c <__sinit>
42010b48:	982182        	l32i	a8, a1, 0x260
42010b4b:	192882        	l32i	a8, a8, 100
42010b4e:	14e807        	bbsi	a8, 0, 42010b66 <_vfiprintf_r+0x46>
42010b51:	982182        	l32i	a8, a1, 0x260
42010b54:	061882        	l16ui	a8, a8, 12
42010b57:	0be897        	bbsi	a8, 9, 42010b66 <_vfiprintf_r+0x46>
42010b5a:	982182        	l32i	a8, a1, 0x260
42010b5d:	1628a2        	l32i	a10, a8, 88
42010b60:	c0aa81        	l32r	a8, 42000e08 <_stext+0xde8> (40376b04 <__retarget_lock_acquire_recursive>)
42010b63:	0008e0        	callx8	a8
42010b66:	982182        	l32i	a8, a1, 0x260
42010b69:	061882        	l16ui	a8, a8, 12
42010b6c:	066837        	bbci	a8, 3, 42010b76 <_vfiprintf_r+0x56>
42010b6f:	982182        	l32i	a8, a1, 0x260
42010b72:	4888      	l32i.n	a8, a8, 16
42010b74:	58fc      	bnez.n	a8, 42010bad <_vfiprintf_r+0x8d>
42010b76:	9821b2        	l32i	a11, a1, 0x260
42010b79:	9b21a2        	l32i	a10, a1, 0x26c
42010b7c:	201110        	or	a1, a1, a1
42010b7f:	fc7425        	call8	4200d2c0 <__swsetup_r>
42010b82:	7aac      	beqz.n	a10, 42010bad <_vfiprintf_r+0x8d>
42010b84:	982182        	l32i	a8, a1, 0x260
42010b87:	192882        	l32i	a8, a8, 100
42010b8a:	076807        	bbci	a8, 0, 42010b95 <_vfiprintf_r+0x75>
42010b8d:	f87c      	movi.n	a8, -1
42010b8f:	9d6182        	s32i	a8, a1, 0x274
42010b92:	06f986        	j	4201277c <_vfiprintf_r+0x1c5c>
42010b95:	982182        	l32i	a8, a1, 0x260
42010b98:	061882        	l16ui	a8, a8, 12
42010b9b:	eee897        	bbsi	a8, 9, 42010b8d <_vfiprintf_r+0x6d>
42010b9e:	982182        	l32i	a8, a1, 0x260
42010ba1:	1628a2        	l32i	a10, a8, 88
42010ba4:	c09a81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
42010ba7:	0008e0        	callx8	a8
42010baa:	fff7c6        	j	42010b8d <_vfiprintf_r+0x6d>
42010bad:	982182        	l32i	a8, a1, 0x260
42010bb0:	069892        	l16si	a9, a8, 12
42010bb3:	1aa082        	movi	a8, 26
42010bb6:	108980        	and	a8, a9, a8
42010bb9:	439866        	bnei	a8, 10, 42010c00 <_vfiprintf_r+0xe0>
42010bbc:	982182        	l32i	a8, a1, 0x260
42010bbf:	079882        	l16si	a8, a8, 14
42010bc2:	03a896        	bltz	a8, 42010c00 <_vfiprintf_r+0xe0>
42010bc5:	982182        	l32i	a8, a1, 0x260
42010bc8:	192882        	l32i	a8, a8, 100
42010bcb:	0ee807        	bbsi	a8, 0, 42010bdd <_vfiprintf_r+0xbd>
42010bce:	0be997        	bbsi	a9, 9, 42010bdd <_vfiprintf_r+0xbd>
42010bd1:	982182        	l32i	a8, a1, 0x260
42010bd4:	1628a2        	l32i	a10, a8, 88
42010bd7:	c08d81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
42010bda:	0008e0        	callx8	a8
42010bdd:	9024d2        	l32i	a13, a4, 0x240
42010be0:	9124e2        	l32i	a14, a4, 0x244
42010be3:	9224f2        	l32i	a15, a4, 0x248
42010be6:	9921c2        	l32i	a12, a1, 0x264
42010be9:	9821b2        	l32i	a11, a1, 0x260
42010bec:	9b21a2        	l32i	a10, a1, 0x26c
42010bef:	02d442        	addmi	a4, a4, 0x200
42010bf2:	201110        	or	a1, a1, a1
42010bf5:	01bb25        	call8	420127a8 <__sbprintf>
42010bf8:	9d61a2        	s32i	a10, a1, 0x274
42010bfb:	06df46        	j	4201277c <_vfiprintf_r+0x1c5c>
42010bfe:	820000        	mull	a0, a0, a0
42010c01:	8ae4a1        	l32r	a10, 41ff3794 <_iram_bss_end+0x1c71394>
42010c04:	84          	.byte	0x84
42010c05:	090c      	movi.n	a9, 0
42010c07:	896482        	s32i	a8, a4, 0x224
42010c0a:	976182        	s32i	a8, a1, 0x25c
42010c0d:	080c      	movi.n	a8, 0
42010c0f:	8b6492        	s32i	a9, a4, 0x22c
42010c12:	8a6492        	s32i	a9, a4, 0x228
42010c15:	906192        	s32i	a9, a1, 0x240
42010c18:	916192        	s32i	a9, a1, 0x244
42010c1b:	a16182        	s32i	a8, a1, 0x284
42010c1e:	9f6182        	s32i	a8, a1, 0x27c
42010c21:	a06182        	s32i	a8, a1, 0x280
42010c24:	a26182        	s32i	a8, a1, 0x288
42010c27:	9d6182        	s32i	a8, a1, 0x274
42010c2a:	10c192        	addi	a9, a1, 16
42010c2d:	e4a182        	movi	a8, 0x1e4
42010c30:	fa7c      	movi.n	a10, -1
42010c32:	898a      	add.n	a8, a9, a8
42010c34:	4064a2        	s32i	a10, a4, 0x100
42010c37:	050c      	movi.n	a5, 0
42010c39:	a46182        	s32i	a8, a1, 0x290
42010c3c:	992172        	l32i	a7, a1, 0x264
42010c3f:	000046        	j	42010c44 <_vfiprintf_r+0x124>
42010c42:	771b      	addi.n	a7, a7, 1
42010c44:	000782        	l8ui	a8, a7, 0
42010c47:	005816        	beqz	a8, 42010c50 <_vfiprintf_r+0x130>
42010c4a:	dbc882        	addi	a8, a8, -37
42010c4d:	ff1856        	bnez	a8, 42010c42 <_vfiprintf_r+0x122>
42010c50:	992182        	l32i	a8, a1, 0x264
42010c53:	c06780        	sub	a6, a7, a8
42010c56:	052616        	beqz	a6, 42010cac <_vfiprintf_r+0x18c>
42010c59:	992192        	l32i	a9, a1, 0x264
42010c5c:	972182        	l32i	a8, a1, 0x25c
42010c5f:	0899      	s32i.n	a9, a8, 0
42010c61:	1869      	s32i.n	a6, a8, 4
42010c63:	10c182        	addi	a8, a1, 16
42010c66:	02d892        	addmi	a9, a8, 0x200
42010c69:	8f2182        	l32i	a8, a1, 0x23c
42010c6c:	886a      	add.n	a8, a8, a6
42010c6e:	b989      	s32i.n	a8, a9, 44
42010c70:	a988      	l32i.n	a8, a9, 40
42010c72:	881b      	addi.n	a8, a8, 1
42010c74:	a989      	s32i.n	a8, a9, 40
42010c76:	0788e6        	bgei	a8, 8, 42010c81 <_vfiprintf_r+0x161>
42010c79:	972182        	l32i	a8, a1, 0x25c
42010c7c:	888b      	addi.n	a8, a8, 8
42010c7e:	000786        	j	42010ca0 <_vfiprintf_r+0x180>
42010c81:	24a2c2        	movi	a12, 0x224
42010c84:	10c182        	addi	a8, a1, 16
42010c87:	9821b2        	l32i	a11, a1, 0x260
42010c8a:	9b21a2        	l32i	a10, a1, 0x26c
42010c8d:	c8ca      	add.n	a12, a8, a12
42010c8f:	ffe6e5        	call8	42010afc <__sprint_r>
42010c92:	1a8c      	beqz.n	a10, 42010c97 <_vfiprintf_r+0x177>
42010c94:	06ab46        	j	42012745 <_vfiprintf_r+0x1c25>
42010c97:	e4a182        	movi	a8, 0x1e4
42010c9a:	10c192        	addi	a9, a1, 16
42010c9d:	808980        	add	a8, a9, a8
42010ca0:	976182        	s32i	a8, a1, 0x25c
42010ca3:	9d2182        	l32i	a8, a1, 0x274
42010ca6:	808860        	add	a8, a8, a6
42010ca9:	9d6182        	s32i	a8, a1, 0x274
42010cac:	000782        	l8ui	a8, a7, 0
42010caf:	18cc      	bnez.n	a8, 42010cb4 <_vfiprintf_r+0x194>
42010cb1:	069ac6        	j	42012720 <_vfiprintf_r+0x1c00>
42010cb4:	10c192        	addi	a9, a1, 16
42010cb7:	02d992        	addmi	a9, a9, 0x200
42010cba:	0a0c      	movi.n	a10, 0
42010cbc:	3a49a2        	s8i	a10, a9, 58
42010cbf:	f97c      	movi.n	a9, -1
42010cc1:	9a6192        	s32i	a9, a1, 0x268
42010cc4:	090c      	movi.n	a9, 0
42010cc6:	871b      	addi.n	a8, a7, 1
42010cc8:	056d      	mov.n	a6, a5
42010cca:	9c6192        	s32i	a9, a1, 0x270
42010ccd:	040c      	movi.n	a4, 0
42010ccf:	030c      	movi.n	a3, 0
42010cd1:	000206        	j	42010cdd <_vfiprintf_r+0x1bd>
42010cd4:	00          	.byte	00
42010cd5:	996192        	s32i	a9, a1, 0x264
42010cd8:	040c      	movi.n	a4, 0
42010cda:	992182        	l32i	a8, a1, 0x264
42010cdd:	981b      	addi.n	a9, a8, 1
42010cdf:	000882        	l8ui	a8, a8, 0
42010ce2:	996192        	s32i	a9, a1, 0x264
42010ce5:	9e6182        	s32i	a8, a1, 0x278
42010ce8:	aa5c      	movi.n	a10, 90
42010cea:	000086        	j	42010cf0 <_vfiprintf_r+0x1d0>
42010ced:	9c6182        	s32i	a8, a1, 0x270
42010cf0:	9e2182        	l32i	a8, a1, 0x278
42010cf3:	e0c882        	addi	a8, a8, -32
42010cf6:	02ba87        	bgeu	a10, a8, 42010cfc <_vfiprintf_r+0x1dc>
42010cf9:	05a286        	j	42012387 <_vfiprintf_r+0x1867>
42010cfc:	c08391        	l32r	a9, 42000f08 <_stext+0xee8> (3c0288b0 <blanks$1+0x1dc>)
42010cff:	a08890        	addx4	a8, a8, a9
42010d02:	0888      	l32i.n	a8, a8, 0
42010d04:	0008a0        	jx	a8
42010d07:	c07f81        	l32r	a8, 42000f04 <_stext+0xee4> (3c0286f4 <blanks$1+0x20>)
42010d0a:	046f46        	j	42011ecb <_vfiprintf_r+0x13ab>
42010d0d:	9b21a2        	l32i	a10, a1, 0x26c
42010d10:	201110        	or	a1, a1, a1
42010d13:	01c2a5        	call8	4201293c <_localeconv_r>
42010d16:	012a82        	l32i	a8, a10, 4
42010d19:	08ad      	mov.n	a10, a8
42010d1b:	a26182        	s32i	a8, a1, 0x288
42010d1e:	bd7181        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
42010d21:	0008e0        	callx8	a8
42010d24:	a061a2        	s32i	a10, a1, 0x280
42010d27:	9b21a2        	l32i	a10, a1, 0x26c
42010d2a:	201110        	or	a1, a1, a1
42010d2d:	01c0e5        	call8	4201293c <_localeconv_r>
42010d30:	2a88      	l32i.n	a8, a10, 8
42010d32:	9f6182        	s32i	a8, a1, 0x27c
42010d35:	a02182        	l32i	a8, a1, 0x280
42010d38:	f9e816        	beqz	a8, 42010cda <_vfiprintf_r+0x1ba>
42010d3b:	9f2182        	l32i	a8, a1, 0x27c
42010d3e:	f98816        	beqz	a8, 42010cda <_vfiprintf_r+0x1ba>
42010d41:	000882        	l8ui	a8, a8, 0
42010d44:	f92816        	beqz	a8, 42010cda <_vfiprintf_r+0x1ba>
42010d47:	00a482        	movi	a8, 0x400
42010d4a:	00c246        	j	42011057 <_vfiprintf_r+0x537>
42010d4d:	10c182        	addi	a8, a1, 16
42010d50:	02d882        	addmi	a8, a8, 0x200
42010d53:	3a0892        	l8ui	a9, a8, 58
42010d56:	f80956        	bnez	a9, 42010cda <_vfiprintf_r+0x1ba>
42010d59:	092c      	movi.n	a9, 32
42010d5b:	004786        	j	42010e7d <_vfiprintf_r+0x35d>
42010d5e:	180c      	movi.n	a8, 1
42010d60:	00bcc6        	j	42011057 <_vfiprintf_r+0x537>
42010d63:	992182        	l32i	a8, a1, 0x264
42010d66:	9a0c      	movi.n	a10, 9
42010d68:	000882        	l8ui	a8, a8, 0
42010d6b:	d0c892        	addi	a9, a8, -48
42010d6e:	3e3a97        	bltu	a10, a9, 42010db0 <_vfiprintf_r+0x290>
42010d71:	992192        	l32i	a9, a1, 0x264
42010d74:	0a0c      	movi.n	a10, 0
42010d76:	01c922        	addi	a2, a9, 1
42010d79:	09a0b2        	movi	a11, 9
42010d7c:	d0c882        	addi	a8, a8, -48
42010d7f:	a0aaa0        	addx4	a10, a10, a10
42010d82:	90aa80        	addx2	a10, a10, a8
42010d85:	000282        	l8ui	a8, a2, 0
42010d88:	221b      	addi.n	a2, a2, 1
42010d8a:	d0c892        	addi	a9, a8, -48
42010d8d:	ebbb97        	bgeu	a11, a9, 42010d7c <_vfiprintf_r+0x25c>
42010d90:	492c      	movi.n	a9, 36
42010d92:	021897        	beq	a8, a9, 42010d98 <_vfiprintf_r+0x278>
42010d95:	ffcfc6        	j	42010cd8 <_vfiprintf_r+0x1b8>
42010d98:	082c      	movi.n	a8, 32
42010d9a:	02a8a7        	bge	a8, a10, 42010da0 <_vfiprintf_r+0x280>
42010d9d:	066906        	j	42012745 <_vfiprintf_r+0x1c25>
42010da0:	912182        	l32i	a8, a1, 0x244
42010da3:	aa0b      	addi.n	a10, a10, -1
42010da5:	10c1e2        	addi	a14, a1, 16
42010da8:	142a87        	blt	a10, a8, 42010dc0 <_vfiprintf_r+0x2a0>
42010dab:	000646        	j	42010dc8 <_vfiprintf_r+0x2a8>
42010dae:	b20000        	mulsh	a0, a0, a0
42010db1:	1b9121        	l32r	a2, 41fd7bf8 <_iram_bss_end+0x1c557f8>
42010db4:	c18295        	call4	41fd25e0 <_iram_bss_end+0x1c501e0>
42010db7:	25b710        	extui	a11, a1, 23, 3
42010dba:	34          	.byte	0x34
42010dbb:	000dc6        	j	42010df6 <_vfiprintf_r+0x2d6>
42010dbe:	e00000        	subx4	a0, a0, a0
42010dc1:	b0ea      	add.n	a11, a0, a14
42010dc3:	0e88      	l32i.n	a8, a14, 0
42010dc5:	000686        	j	42010de3 <_vfiprintf_r+0x2c3>
42010dc8:	30a282        	movi	a8, 0x230
42010dcb:	8e8a      	add.n	a8, a14, a8
42010dcd:	34a2d2        	movi	a13, 0x234
42010dd0:	40a2c2        	movi	a12, 0x240
42010dd3:	0189      	s32i.n	a8, a1, 0
42010dd5:	01def2        	addmi	a15, a14, 0x100
42010dd8:	deda      	add.n	a13, a14, a13
42010dda:	ceca      	add.n	a12, a14, a12
42010ddc:	07bd      	mov.n	a11, a7
42010dde:	ff84e5        	call8	4201062c <get_arg$isra$0>
42010de1:	0a88      	l32i.n	a8, a10, 0
42010de3:	9c6182        	s32i	a8, a1, 0x270
42010de6:	996122        	s32i	a2, a1, 0x264
42010de9:	059d      	mov.n	a9, a5
42010deb:	001cc6        	j	42010e62 <_vfiprintf_r+0x342>
42010dee:	800000        	add	a0, a0, a0
42010df1:	86b086        	j	41ff28b7 <_iram_bss_end+0x1c704b7>
42010df4:	0019      	s32i.n	a1, a0, 0
42010df6:	9228a2        	l32i	a10, a8, 0x248
42010df9:	fd1c      	movi.n	a13, 31
42010dfb:	02d882        	addmi	a8, a8, 0x200
42010dfe:	ca4b      	addi.n	a12, a10, 4
42010e00:	342db7        	blt	a13, a11, 42010e38 <_vfiprintf_r+0x318>
42010e03:	db1b      	addi.n	a13, a11, 1
42010e05:	9161d2        	s32i	a13, a1, 0x244
42010e08:	1268c2        	s32i	a12, a8, 72
42010e0b:	8d1c      	movi.n	a13, 24
42010e0d:	072dc7        	blt	a13, a12, 42010e18 <_vfiprintf_r+0x2f8>
42010e10:	1128a2        	l32i	a10, a8, 68
42010e13:	000306        	j	42010e23 <_vfiprintf_r+0x303>
42010e16:	a70000        	ee.stf.64.xp	f0, f10, a0, a0
42010e19:	012d      	mov.n	a2, a1
42010e1b:	4c2c      	movi.n	a12, 36
42010e1d:	9421a2        	l32i	a10, a1, 0x250
42010e20:	9661c2        	s32i	a12, a1, 0x258
42010e23:	aaca      	add.n	a10, a10, a12
42010e25:	fccaa2        	addi	a10, a10, -4
42010e28:	0a88      	l32i.n	a8, a10, 0
42010e2a:	9c6182        	s32i	a8, a1, 0x270
42010e2d:	9c21a2        	l32i	a10, a1, 0x270
42010e30:	b08b10        	addx8	a8, a11, a1
42010e33:	48a9      	s32i.n	a10, a8, 16
42010e35:	000a46        	j	42010e62 <_vfiprintf_r+0x342>
42010e38:	1268c2        	s32i	a12, a8, 72
42010e3b:	8b1c      	movi.n	a11, 24
42010e3d:	052bc7        	blt	a11, a12, 42010e46 <_vfiprintf_r+0x326>
42010e40:	112882        	l32i	a8, a8, 68
42010e43:	000446        	j	42010e58 <_vfiprintf_r+0x338>
42010e46:	022ba7        	blt	a11, a10, 42010e4c <_vfiprintf_r+0x32c>
42010e49:	24a0c2        	movi	a12, 36
42010e4c:	10c182        	addi	a8, a1, 16
42010e4f:	02d882        	addmi	a8, a8, 0x200
42010e52:	102882        	l32i	a8, a8, 64
42010e55:	9661c2        	s32i	a12, a1, 0x258
42010e58:	88ca      	add.n	a8, a8, a12
42010e5a:	fcc882        	addi	a8, a8, -4
42010e5d:	0888      	l32i.n	a8, a8, 0
42010e5f:	9c6182        	s32i	a8, a1, 0x270
42010e62:	9c2182        	l32i	a8, a1, 0x270
42010e65:	095d      	mov.n	a5, a9
42010e67:	e6f8d6        	bgez	a8, 42010cda <_vfiprintf_r+0x1ba>
42010e6a:	608080        	neg	a8, a8
42010e6d:	9c6182        	s32i	a8, a1, 0x270
42010e70:	480c      	movi.n	a8, 4
42010e72:	007846        	j	42011057 <_vfiprintf_r+0x537>
42010e75:	10c182        	addi	a8, a1, 16
42010e78:	02d882        	addmi	a8, a8, 0x200
42010e7b:	b92c      	movi.n	a9, 43
42010e7d:	3a4892        	s8i	a9, a8, 58
42010e80:	ff9586        	j	42010cda <_vfiprintf_r+0x1ba>
42010e83:	992182        	l32i	a8, a1, 0x264
42010e86:	981b      	addi.n	a9, a8, 1
42010e88:	000882        	l8ui	a8, a8, 0
42010e8b:	9e6182        	s32i	a8, a1, 0x278
42010e8e:	9e21b2        	l32i	a11, a1, 0x278
42010e91:	a82c      	movi.n	a8, 42
42010e93:	061b87        	beq	a11, a8, 42010e9d <_vfiprintf_r+0x37d>
42010e96:	080c      	movi.n	a8, 0
42010e98:	9c0c      	movi.n	a12, 9
42010e9a:	004506        	j	42010fb2 <_vfiprintf_r+0x492>
42010e9d:	992182        	l32i	a8, a1, 0x264
42010ea0:	9b0c      	movi.n	a11, 9
42010ea2:	010882        	l8ui	a8, a8, 1
42010ea5:	d0c8a2        	addi	a10, a8, -48
42010ea8:	3c3ba7        	bltu	a11, a10, 42010ee8 <_vfiprintf_r+0x3c8>
42010eab:	9921a2        	l32i	a10, a1, 0x264
42010eae:	02ca22        	addi	a2, a10, 2
42010eb1:	00a0a2        	movi	a10, 0
42010eb4:	d0c882        	addi	a8, a8, -48
42010eb7:	a0aaa0        	addx4	a10, a10, a10
42010eba:	90aa80        	addx2	a10, a10, a8
42010ebd:	000282        	l8ui	a8, a2, 0
42010ec0:	221b      	addi.n	a2, a2, 1
42010ec2:	d0c8c2        	addi	a12, a8, -48
42010ec5:	ebbbc7        	bgeu	a11, a12, 42010eb4 <_vfiprintf_r+0x394>
42010ec8:	4b2c      	movi.n	a11, 36
42010eca:	0218b7        	beq	a8, a11, 42010ed0 <_vfiprintf_r+0x3b0>
42010ecd:	ff8106        	j	42010cd5 <_vfiprintf_r+0x1b5>
42010ed0:	082c      	movi.n	a8, 32
42010ed2:	02a8a7        	bge	a8, a10, 42010ed8 <_vfiprintf_r+0x3b8>
42010ed5:	061b06        	j	42012745 <_vfiprintf_r+0x1c25>
42010ed8:	912182        	l32i	a8, a1, 0x244
42010edb:	aa0b      	addi.n	a10, a10, -1
42010edd:	10c1e2        	addi	a14, a1, 16
42010ee0:	142a87        	blt	a10, a8, 42010ef8 <_vfiprintf_r+0x3d8>
42010ee3:	000646        	j	42010f00 <_vfiprintf_r+0x3e0>
42010ee6:	a20000        	muluh	a0, a0, a0
42010ee9:	1b9121        	l32r	a2, 41fd7d30 <_iram_bss_end+0x1c55930>
42010eec:	c182c5        	call0	41fd271c <_iram_bss_end+0x1c5031c>
42010eef:	25a710        	extui	a10, a1, 23, 3
42010ef2:	30          	.byte	0x30
42010ef3:	000cc6        	j	42010f2a <_vfiprintf_r+0x40a>
42010ef6:	e00000        	subx4	a0, a0, a0
42010ef9:	b0ea      	add.n	a11, a0, a14
42010efb:	0e88      	l32i.n	a8, a14, 0
42010efd:	000686        	j	42010f1b <_vfiprintf_r+0x3fb>
42010f00:	30a282        	movi	a8, 0x230
42010f03:	8e8a      	add.n	a8, a14, a8
42010f05:	34a2d2        	movi	a13, 0x234
42010f08:	40a2c2        	movi	a12, 0x240
42010f0b:	0189      	s32i.n	a8, a1, 0
42010f0d:	01def2        	addmi	a15, a14, 0x100
42010f10:	deda      	add.n	a13, a14, a13
42010f12:	ceca      	add.n	a12, a14, a12
42010f14:	07bd      	mov.n	a11, a7
42010f16:	ff7165        	call8	4201062c <get_arg$isra$0>
42010f19:	0a88      	l32i.n	a8, a10, 0
42010f1b:	029d      	mov.n	a9, a2
42010f1d:	05cd      	mov.n	a12, a5
42010f1f:	001c06        	j	42010f93 <_vfiprintf_r+0x473>
42010f22:	800000        	add	a0, a0, a0
42010f25:	86b086        	j	41ff29eb <_iram_bss_end+0x1c705eb>
42010f28:	0019      	s32i.n	a1, a0, 0
42010f2a:	fb1c      	movi.n	a11, 31
42010f2c:	352ba7        	blt	a11, a10, 42010f65 <_vfiprintf_r+0x445>
42010f2f:	9228e2        	l32i	a14, a8, 0x248
42010f32:	ba1b      	addi.n	a11, a10, 1
42010f34:	9161b2        	s32i	a11, a1, 0x244
42010f37:	be4b      	addi.n	a11, a14, 4
42010f39:	9268b2        	s32i	a11, a8, 0x248
42010f3c:	8f1c      	movi.n	a15, 24
42010f3e:	062fb7        	blt	a15, a11, 42010f48 <_vfiprintf_r+0x428>
42010f41:	912882        	l32i	a8, a8, 0x244
42010f44:	000386        	j	42010f56 <_vfiprintf_r+0x436>
42010f47:	00          	.byte	00
42010f48:	012fe7        	blt	a15, a14, 42010f4d <_vfiprintf_r+0x42d>
42010f4b:	4b2c      	movi.n	a11, 36
42010f4d:	9268b2        	s32i	a11, a8, 0x248
42010f50:	02d882        	addmi	a8, a8, 0x200
42010f53:	102882        	l32i	a8, a8, 64
42010f56:	88ba      	add.n	a8, a8, a11
42010f58:	fcc882        	addi	a8, a8, -4
42010f5b:	0888      	l32i.n	a8, a8, 0
42010f5d:	b0aa10        	addx8	a10, a10, a1
42010f60:	4a89      	s32i.n	a8, a10, 16
42010f62:	000b46        	j	42010f93 <_vfiprintf_r+0x473>
42010f65:	9228b2        	l32i	a11, a8, 0x248
42010f68:	8d1c      	movi.n	a13, 24
42010f6a:	ab4b      	addi.n	a10, a11, 4
42010f6c:	9268a2        	s32i	a10, a8, 0x248
42010f6f:	02d882        	addmi	a8, a8, 0x200
42010f72:	052da7        	blt	a13, a10, 42010f7b <_vfiprintf_r+0x45b>
42010f75:	112882        	l32i	a8, a8, 68
42010f78:	000406        	j	42010f8c <_vfiprintf_r+0x46c>
42010f7b:	012db7        	blt	a13, a11, 42010f80 <_vfiprintf_r+0x460>
42010f7e:	4a2c      	movi.n	a10, 36
42010f80:	10c182        	addi	a8, a1, 16
42010f83:	02d882        	addmi	a8, a8, 0x200
42010f86:	102882        	l32i	a8, a8, 64
42010f89:	9661a2        	s32i	a10, a1, 0x258
42010f8c:	88aa      	add.n	a8, a8, a10
42010f8e:	fcc882        	addi	a8, a8, -4
42010f91:	0888      	l32i.n	a8, a8, 0
42010f93:	fa7c      	movi.n	a10, -1
42010f95:	5388a0        	max	a8, a8, a10
42010f98:	9a6182        	s32i	a8, a1, 0x268
42010f9b:	0c5d      	mov.n	a5, a12
42010f9d:	996192        	s32i	a9, a1, 0x264
42010fa0:	ff4d86        	j	42010cda <_vfiprintf_r+0x1ba>
42010fa3:	00          	.byte	00
42010fa4:	a08880        	addx4	a8, a8, a8
42010fa7:	9088b0        	addx2	a8, a8, a11
42010faa:	0009b2        	l8ui	a11, a9, 0
42010fad:	991b      	addi.n	a9, a9, 1
42010faf:	9e61b2        	s32i	a11, a1, 0x278
42010fb2:	9e21b2        	l32i	a11, a1, 0x278
42010fb5:	996192        	s32i	a9, a1, 0x264
42010fb8:	d0cbb2        	addi	a11, a11, -48
42010fbb:	e5bcb7        	bgeu	a12, a11, 42010fa4 <_vfiprintf_r+0x484>
42010fbe:	f97c      	movi.n	a9, -1
42010fc0:	538890        	max	a8, a8, a9
42010fc3:	9a6182        	s32i	a8, a1, 0x268
42010fc6:	9c2182        	l32i	a8, a1, 0x270
42010fc9:	ff4806        	j	42010ced <_vfiprintf_r+0x1cd>
42010fcc:	820000        	mull	a0, a0, a0
42010fcf:	8680a0        	ee.ldf.64.xp	f8, f8, a10, a0
42010fd2:	20          	.byte	0x20
42010fd3:	080c00        	lsx	f0, a12, a0
42010fd6:	9b0c      	movi.n	a11, 9
42010fd8:	9e2192        	l32i	a9, a1, 0x278
42010fdb:	a08880        	addx4	a8, a8, a8
42010fde:	d0c992        	addi	a9, a9, -48
42010fe1:	908890        	addx2	a8, a8, a9
42010fe4:	992192        	l32i	a9, a1, 0x264
42010fe7:	000992        	l8ui	a9, a9, 0
42010fea:	9e6192        	s32i	a9, a1, 0x278
42010fed:	992192        	l32i	a9, a1, 0x264
42010ff0:	991b      	addi.n	a9, a9, 1
42010ff2:	996192        	s32i	a9, a1, 0x264
42010ff5:	9e2192        	l32i	a9, a1, 0x278
42010ff8:	d0c992        	addi	a9, a9, -48
42010ffb:	d9bb97        	bgeu	a11, a9, 42010fd8 <_vfiprintf_r+0x4b8>
42010ffe:	9e21b2        	l32i	a11, a1, 0x278
42011001:	492c      	movi.n	a9, 36
42011003:	021b97        	beq	a11, a9, 42011009 <_vfiprintf_r+0x4e9>
42011006:	ff38c6        	j	42010ced <_vfiprintf_r+0x1cd>
42011009:	092c      	movi.n	a9, 32
4201100b:	02a987        	bge	a9, a8, 42011011 <_vfiprintf_r+0x4f1>
4201100e:	05ccc6        	j	42012745 <_vfiprintf_r+0x1c25>
42011011:	680b      	addi.n	a6, a8, -1
42011013:	140c      	movi.n	a4, 1
42011015:	ff3046        	j	42010cda <_vfiprintf_r+0x1ba>
42011018:	992182        	l32i	a8, a1, 0x264
4201101b:	000892        	l8ui	a9, a8, 0
4201101e:	68a082        	movi	a8, 104
42011021:	0d9987        	bne	a9, a8, 42011032 <_vfiprintf_r+0x512>
42011024:	992182        	l32i	a8, a1, 0x264
42011027:	881b      	addi.n	a8, a8, 1
42011029:	996182        	s32i	a8, a1, 0x264
4201102c:	00a282        	movi	a8, 0x200
4201102f:	000906        	j	42011057 <_vfiprintf_r+0x537>
42011032:	084c      	movi.n	a8, 64
42011034:	0007c6        	j	42011057 <_vfiprintf_r+0x537>
42011037:	992182        	l32i	a8, a1, 0x264
4201103a:	000892        	l8ui	a9, a8, 0
4201103d:	6ca082        	movi	a8, 108
42011040:	0a9987        	bne	a9, a8, 4201104e <_vfiprintf_r+0x52e>
42011043:	992182        	l32i	a8, a1, 0x264
42011046:	881b      	addi.n	a8, a8, 1
42011048:	996182        	s32i	a8, a1, 0x264
4201104b:	000186        	j	42011055 <_vfiprintf_r+0x535>
4201104e:	081c      	movi.n	a8, 16
42011050:	0000c6        	j	42011057 <_vfiprintf_r+0x537>
42011053:	00          	.byte	00
42011054:	082c00        	lsx	f2, a12, a0
42011057:	203380        	or	a3, a3, a8
4201105a:	ff1f06        	j	42010cda <_vfiprintf_r+0x1ba>
4201105d:	912192        	l32i	a9, a1, 0x244
42011060:	10c1e2        	addi	a14, a1, 16
42011063:	d4ac      	beqz.n	a4, 42011094 <_vfiprintf_r+0x574>
42011065:	08a697        	bge	a6, a9, 42011071 <_vfiprintf_r+0x551>
42011068:	b0e6e0        	addx8	a14, a6, a14
4201106b:	000e82        	l8ui	a8, a14, 0
4201106e:	000746        	j	4201108f <_vfiprintf_r+0x56f>
42011071:	30a282        	movi	a8, 0x230
42011074:	8e8a      	add.n	a8, a14, a8
42011076:	34a2d2        	movi	a13, 0x234
42011079:	40a2c2        	movi	a12, 0x240
4201107c:	0189      	s32i.n	a8, a1, 0
4201107e:	01def2        	addmi	a15, a14, 0x100
42011081:	deda      	add.n	a13, a14, a13
42011083:	ceca      	add.n	a12, a14, a12
42011085:	07bd      	mov.n	a11, a7
42011087:	06ad      	mov.n	a10, a6
42011089:	ff5a25        	call8	4201062c <get_arg$isra$0>
4201108c:	000a82        	l8ui	a8, a10, 0
4201108f:	057d      	mov.n	a7, a5
42011091:	001f06        	j	42011111 <_vfiprintf_r+0x5f1>
42011094:	751b      	addi.n	a7, a5, 1
42011096:	0aa597        	bge	a5, a9, 420110a4 <_vfiprintf_r+0x584>
42011099:	b0e6e0        	addx8	a14, a6, a14
4201109c:	000e82        	l8ui	a8, a14, 0
4201109f:	001b86        	j	42011111 <_vfiprintf_r+0x5f1>
420110a2:	820000        	mull	a0, a0, a0
420110a5:	2e          	.byte	0x2e
420110a6:	fb1c92        	l16ui	a9, a12, 0x1f6
420110a9:	02dee2        	addmi	a14, a14, 0x200
420110ac:	a84b      	addi.n	a10, a8, 4
420110ae:	362b97        	blt	a11, a9, 420110e8 <_vfiprintf_r+0x5c8>
420110b1:	b91b      	addi.n	a11, a9, 1
420110b3:	9161b2        	s32i	a11, a1, 0x244
420110b6:	126ea2        	s32i	a10, a14, 72
420110b9:	8b1c      	movi.n	a11, 24
420110bb:	052ba7        	blt	a11, a10, 420110c4 <_vfiprintf_r+0x5a4>
420110be:	112e82        	l32i	a8, a14, 68
420110c1:	000406        	j	420110d5 <_vfiprintf_r+0x5b5>
420110c4:	012b87        	blt	a11, a8, 420110c9 <_vfiprintf_r+0x5a9>
420110c7:	4a2c      	movi.n	a10, 36
420110c9:	10c182        	addi	a8, a1, 16
420110cc:	02d882        	addmi	a8, a8, 0x200
420110cf:	102882        	l32i	a8, a8, 64
420110d2:	9661a2        	s32i	a10, a1, 0x258
420110d5:	88aa      	add.n	a8, a8, a10
420110d7:	fcc882        	addi	a8, a8, -4
420110da:	0888      	l32i.n	a8, a8, 0
420110dc:	b09910        	addx8	a9, a9, a1
420110df:	4989      	s32i.n	a8, a9, 16
420110e1:	748080        	extui	a8, a8, 0, 8
420110e4:	000a46        	j	42011111 <_vfiprintf_r+0x5f1>
420110e7:	00          	.byte	00
420110e8:	126ea2        	s32i	a10, a14, 72
420110eb:	891c      	movi.n	a9, 24
420110ed:	0729a7        	blt	a9, a10, 420110f8 <_vfiprintf_r+0x5d8>
420110f0:	112e82        	l32i	a8, a14, 68
420110f3:	000486        	j	42011109 <_vfiprintf_r+0x5e9>
420110f6:	870000        	ee.stf.64.xp	f0, f8, a0, a0
420110f9:	0129      	s32i.n	a2, a1, 0
420110fb:	4a2c      	movi.n	a10, 36
420110fd:	10c182        	addi	a8, a1, 16
42011100:	02d882        	addmi	a8, a8, 0x200
42011103:	102882        	l32i	a8, a8, 64
42011106:	9661a2        	s32i	a10, a1, 0x258
42011109:	88aa      	add.n	a8, a8, a10
4201110b:	fcc882        	addi	a8, a8, -4
4201110e:	000882        	l8ui	a8, a8, 0
42011111:	10c162        	addi	a6, a1, 16
42011114:	01d692        	addmi	a9, a6, 0x100
42011117:	804982        	s8i	a8, a9, 128
4201111a:	02d682        	addmi	a8, a6, 0x200
4201111d:	090c      	movi.n	a9, 0
4201111f:	3a4892        	s8i	a9, a8, 58
42011122:	049f46        	j	420123a3 <_vfiprintf_r+0x1883>
42011125:	081c      	movi.n	a8, 16
42011127:	203380        	or	a3, a3, a8
4201112a:	912182        	l32i	a8, a1, 0x244
4201112d:	10c1e2        	addi	a14, a1, 16
42011130:	02e357        	bbsi	a3, 5, 42011136 <_vfiprintf_r+0x616>
42011133:	002f46        	j	420111f4 <_vfiprintf_r+0x6d4>
42011136:	f4ac      	beqz.n	a4, 42011169 <_vfiprintf_r+0x649>
42011138:	09a687        	bge	a6, a8, 42011145 <_vfiprintf_r+0x625>
4201113b:	b0e6e0        	addx8	a14, a6, a14
4201113e:	0e48      	l32i.n	a4, a14, 0
42011140:	1e28      	l32i.n	a2, a14, 4
42011142:	000786        	j	42011164 <_vfiprintf_r+0x644>
42011145:	30a282        	movi	a8, 0x230
42011148:	8e8a      	add.n	a8, a14, a8
4201114a:	34a2d2        	movi	a13, 0x234
4201114d:	40a2c2        	movi	a12, 0x240
42011150:	0189      	s32i.n	a8, a1, 0
42011152:	01def2        	addmi	a15, a14, 0x100
42011155:	deda      	add.n	a13, a14, a13
42011157:	ceca      	add.n	a12, a14, a12
42011159:	07bd      	mov.n	a11, a7
4201115b:	06ad      	mov.n	a10, a6
4201115d:	ff4ce5        	call8	4201062c <get_arg$isra$0>
42011160:	0a48      	l32i.n	a4, a10, 0
42011162:	1a28      	l32i.n	a2, a10, 4
42011164:	057d      	mov.n	a7, a5
42011166:	00aa46        	j	42011413 <_vfiprintf_r+0x8f3>
42011169:	751b      	addi.n	a7, a5, 1
4201116b:	09a587        	bge	a5, a8, 42011178 <_vfiprintf_r+0x658>
4201116e:	b0e6e0        	addx8	a14, a6, a14
42011171:	0e48      	l32i.n	a4, a14, 0
42011173:	1e28      	l32i.n	a2, a14, 4
42011175:	00a686        	j	42011413 <_vfiprintf_r+0x8f3>
42011178:	922e92        	l32i	a9, a14, 0x248
4201117b:	8a7c      	movi.n	a10, -8
4201117d:	997b      	addi.n	a9, a9, 7
4201117f:	1099a0        	and	a9, a9, a10
42011182:	fb1c      	movi.n	a11, 31
42011184:	02dee2        	addmi	a14, a14, 0x200
42011187:	a98b      	addi.n	a10, a9, 8
42011189:	3b2b87        	blt	a11, a8, 420111c8 <_vfiprintf_r+0x6a8>
4201118c:	b81b      	addi.n	a11, a8, 1
4201118e:	9161b2        	s32i	a11, a1, 0x244
42011191:	126ea2        	s32i	a10, a14, 72
42011194:	8b1c      	movi.n	a11, 24
42011196:	062ba7        	blt	a11, a10, 420111a0 <_vfiprintf_r+0x680>
42011199:	112e92        	l32i	a9, a14, 68
4201119c:	000446        	j	420111b1 <_vfiprintf_r+0x691>
4201119f:	2b9700        	oeq.s	b9, f7, f0
420111a2:	8a2c01        	l32r	a0, 41ff3a54 <_iram_bss_end+0x1c71654>
420111a5:	10c192        	addi	a9, a1, 16
420111a8:	02d992        	addmi	a9, a9, 0x200
420111ab:	102992        	l32i	a9, a9, 64
420111ae:	9661a2        	s32i	a10, a1, 0x258
420111b1:	99aa      	add.n	a9, a9, a10
420111b3:	f8c992        	addi	a9, a9, -8
420111b6:	0948      	l32i.n	a4, a9, 0
420111b8:	1928      	l32i.n	a2, a9, 4
420111ba:	10c192        	addi	a9, a1, 16
420111bd:	b08890        	addx8	a8, a8, a9
420111c0:	0849      	s32i.n	a4, a8, 0
420111c2:	1829      	s32i.n	a2, a8, 4
420111c4:	0092c6        	j	42011413 <_vfiprintf_r+0x8f3>
420111c7:	00          	.byte	00
420111c8:	126ea2        	s32i	a10, a14, 72
420111cb:	881c      	movi.n	a8, 24
420111cd:	0528a7        	blt	a8, a10, 420111d6 <_vfiprintf_r+0x6b6>
420111d0:	112e82        	l32i	a8, a14, 68
420111d3:	000446        	j	420111e8 <_vfiprintf_r+0x6c8>
420111d6:	022897        	blt	a8, a9, 420111dc <_vfiprintf_r+0x6bc>
420111d9:	28a0a2        	movi	a10, 40
420111dc:	10c182        	addi	a8, a1, 16
420111df:	02d882        	addmi	a8, a8, 0x200
420111e2:	102882        	l32i	a8, a8, 64
420111e5:	9661a2        	s32i	a10, a1, 0x258
420111e8:	88aa      	add.n	a8, a8, a10
420111ea:	f8c882        	addi	a8, a8, -8
420111ed:	0848      	l32i.n	a4, a8, 0
420111ef:	1828      	l32i.n	a2, a8, 4
420111f1:	008786        	j	42011413 <_vfiprintf_r+0x8f3>
420111f4:	046347        	bbci	a3, 4, 420111fc <_vfiprintf_r+0x6dc>
420111f7:	005c46        	j	4201136c <_vfiprintf_r+0x84c>
420111fa:	670000        	ee.stf.64.xp	f0, f6, a0, a0
420111fd:	4602e3        	lsi	f14, a2, 0x118
42011200:	002b      	addi.n	a0, a0, 2
42011202:	c4ac      	beqz.n	a4, 42011232 <_vfiprintf_r+0x712>
42011204:	09a687        	bge	a6, a8, 42011211 <_vfiprintf_r+0x6f1>
42011207:	b0e6e0        	addx8	a14, a6, a14
4201120a:	009e42        	l16si	a4, a14, 0
4201120d:	006146        	j	42011396 <_vfiprintf_r+0x876>
42011210:	a28200        	muluh	a8, a2, a0
42011213:	30          	.byte	0x30
42011214:	8e8a      	add.n	a8, a14, a8
42011216:	34a2d2        	movi	a13, 0x234
42011219:	40a2c2        	movi	a12, 0x240
4201121c:	0189      	s32i.n	a8, a1, 0
4201121e:	01def2        	addmi	a15, a14, 0x100
42011221:	deda      	add.n	a13, a14, a13
42011223:	ceca      	add.n	a12, a14, a12
42011225:	07bd      	mov.n	a11, a7
42011227:	06ad      	mov.n	a10, a6
42011229:	ff4025        	call8	4201062c <get_arg$isra$0>
4201122c:	009a42        	l16si	a4, a10, 0
4201122f:	0058c6        	j	42011396 <_vfiprintf_r+0x876>
42011232:	751b      	addi.n	a7, a5, 1
42011234:	08a587        	bge	a5, a8, 42011240 <_vfiprintf_r+0x720>
42011237:	b0e6e0        	addx8	a14, a6, a14
4201123a:	009e42        	l16si	a4, a14, 0
4201123d:	0073c6        	j	42011410 <_vfiprintf_r+0x8f0>
42011240:	922e92        	l32i	a9, a14, 0x248
42011243:	fb1c      	movi.n	a11, 31
42011245:	02dee2        	addmi	a14, a14, 0x200
42011248:	a94b      	addi.n	a10, a9, 4
4201124a:	362b87        	blt	a11, a8, 42011284 <_vfiprintf_r+0x764>
4201124d:	b81b      	addi.n	a11, a8, 1
4201124f:	9161b2        	s32i	a11, a1, 0x244
42011252:	126ea2        	s32i	a10, a14, 72
42011255:	8b1c      	movi.n	a11, 24
42011257:	052ba7        	blt	a11, a10, 42011260 <_vfiprintf_r+0x740>
4201125a:	112e92        	l32i	a9, a14, 68
4201125d:	000406        	j	42011271 <_vfiprintf_r+0x751>
42011260:	012b97        	blt	a11, a9, 42011265 <_vfiprintf_r+0x745>
42011263:	4a2c      	movi.n	a10, 36
42011265:	10c192        	addi	a9, a1, 16
42011268:	02d992        	addmi	a9, a9, 0x200
4201126b:	102992        	l32i	a9, a9, 64
4201126e:	9661a2        	s32i	a10, a1, 0x258
42011271:	99aa      	add.n	a9, a9, a10
42011273:	fcc992        	addi	a9, a9, -4
42011276:	0948      	l32i.n	a4, a9, 0
42011278:	b08810        	addx8	a8, a8, a1
4201127b:	4849      	s32i.n	a4, a8, 16
4201127d:	234480        	sext	a4, a4, 15
42011280:	006306        	j	42011410 <_vfiprintf_r+0x8f0>
42011283:	00          	.byte	00
42011284:	126ea2        	s32i	a10, a14, 72
42011287:	881c      	movi.n	a8, 24
42011289:	0728a7        	blt	a8, a10, 42011294 <_vfiprintf_r+0x774>
4201128c:	112e82        	l32i	a8, a14, 68
4201128f:	000486        	j	420112a5 <_vfiprintf_r+0x785>
42011292:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42011295:	0128      	l32i.n	a2, a1, 0
42011297:	4a2c      	movi.n	a10, 36
42011299:	10c182        	addi	a8, a1, 16
4201129c:	02d882        	addmi	a8, a8, 0x200
4201129f:	102882        	l32i	a8, a8, 64
420112a2:	9661a2        	s32i	a10, a1, 0x258
420112a5:	88aa      	add.n	a8, a8, a10
420112a7:	fcc882        	addi	a8, a8, -4
420112aa:	009842        	l16si	a4, a8, 0
420112ad:	0057c6        	j	42011410 <_vfiprintf_r+0x8f0>
420112b0:	02e397        	bbsi	a3, 9, 420112b6 <_vfiprintf_r+0x796>
420112b3:	002d46        	j	4201136c <_vfiprintf_r+0x84c>
420112b6:	e4ac      	beqz.n	a4, 420112e8 <_vfiprintf_r+0x7c8>
420112b8:	09a687        	bge	a6, a8, 420112c5 <_vfiprintf_r+0x7a5>
420112bb:	b0e6e0        	addx8	a14, a6, a14
420112be:	000e42        	l8ui	a4, a14, 0
420112c1:	000786        	j	420112e3 <_vfiprintf_r+0x7c3>
420112c4:	a28200        	muluh	a8, a2, a0
420112c7:	30          	.byte	0x30
420112c8:	8e8a      	add.n	a8, a14, a8
420112ca:	34a2d2        	movi	a13, 0x234
420112cd:	40a2c2        	movi	a12, 0x240
420112d0:	0189      	s32i.n	a8, a1, 0
420112d2:	01def2        	addmi	a15, a14, 0x100
420112d5:	deda      	add.n	a13, a14, a13
420112d7:	ceca      	add.n	a12, a14, a12
420112d9:	07bd      	mov.n	a11, a7
420112db:	06ad      	mov.n	a10, a6
420112dd:	ff34e5        	call8	4201062c <get_arg$isra$0>
420112e0:	000a42        	l8ui	a4, a10, 0
420112e3:	057d      	mov.n	a7, a5
420112e5:	001f06        	j	42011365 <_vfiprintf_r+0x845>
420112e8:	751b      	addi.n	a7, a5, 1
420112ea:	0aa587        	bge	a5, a8, 420112f8 <_vfiprintf_r+0x7d8>
420112ed:	b0e6e0        	addx8	a14, a6, a14
420112f0:	000e42        	l8ui	a4, a14, 0
420112f3:	001b86        	j	42011365 <_vfiprintf_r+0x845>
420112f6:	00          	.byte	00
420112f7:	00          	.byte	00
420112f8:	922e92        	l32i	a9, a14, 0x248
420112fb:	fb1c      	movi.n	a11, 31
420112fd:	02dee2        	addmi	a14, a14, 0x200
42011300:	a94b      	addi.n	a10, a9, 4
42011302:	362b87        	blt	a11, a8, 4201133c <_vfiprintf_r+0x81c>
42011305:	b81b      	addi.n	a11, a8, 1
42011307:	9161b2        	s32i	a11, a1, 0x244
4201130a:	126ea2        	s32i	a10, a14, 72
4201130d:	8b1c      	movi.n	a11, 24
4201130f:	052ba7        	blt	a11, a10, 42011318 <_vfiprintf_r+0x7f8>
42011312:	112e92        	l32i	a9, a14, 68
42011315:	000406        	j	42011329 <_vfiprintf_r+0x809>
42011318:	012b97        	blt	a11, a9, 4201131d <_vfiprintf_r+0x7fd>
4201131b:	4a2c      	movi.n	a10, 36
4201131d:	10c192        	addi	a9, a1, 16
42011320:	02d992        	addmi	a9, a9, 0x200
42011323:	102992        	l32i	a9, a9, 64
42011326:	9661a2        	s32i	a10, a1, 0x258
42011329:	99aa      	add.n	a9, a9, a10
4201132b:	fcc992        	addi	a9, a9, -4
4201132e:	0948      	l32i.n	a4, a9, 0
42011330:	b08810        	addx8	a8, a8, a1
42011333:	4849      	s32i.n	a4, a8, 16
42011335:	744040        	extui	a4, a4, 0, 8
42011338:	000a46        	j	42011365 <_vfiprintf_r+0x845>
4201133b:	00          	.byte	00
4201133c:	126ea2        	s32i	a10, a14, 72
4201133f:	881c      	movi.n	a8, 24
42011341:	0728a7        	blt	a8, a10, 4201134c <_vfiprintf_r+0x82c>
42011344:	112e82        	l32i	a8, a14, 68
42011347:	000486        	j	4201135d <_vfiprintf_r+0x83d>
4201134a:	970000        	ee.stf.64.xp	f0, f9, a0, a0
4201134d:	0128      	l32i.n	a2, a1, 0
4201134f:	4a2c      	movi.n	a10, 36
42011351:	10c182        	addi	a8, a1, 16
42011354:	02d882        	addmi	a8, a8, 0x200
42011357:	102882        	l32i	a8, a8, 64
4201135a:	9661a2        	s32i	a10, a1, 0x258
4201135d:	88aa      	add.n	a8, a8, a10
4201135f:	fcc882        	addi	a8, a8, -4
42011362:	000842        	l8ui	a4, a8, 0
42011365:	234400        	sext	a4, a4, 7
42011368:	002906        	j	42011410 <_vfiprintf_r+0x8f0>
4201136b:	c4ac00        	extui	a10, a0, 12, 13
4201136e:	07a687        	bge	a6, a8, 42011379 <_vfiprintf_r+0x859>
42011371:	b0e6e0        	addx8	a14, a6, a14
42011374:	0e48      	l32i.n	a4, a14, 0
42011376:	000706        	j	42011396 <_vfiprintf_r+0x876>
42011379:	30a282        	movi	a8, 0x230
4201137c:	8e8a      	add.n	a8, a14, a8
4201137e:	34a2d2        	movi	a13, 0x234
42011381:	40a2c2        	movi	a12, 0x240
42011384:	0189      	s32i.n	a8, a1, 0
42011386:	01def2        	addmi	a15, a14, 0x100
42011389:	deda      	add.n	a13, a14, a13
4201138b:	ceca      	add.n	a12, a14, a12
4201138d:	07bd      	mov.n	a11, a7
4201138f:	06ad      	mov.n	a10, a6
42011391:	ff29a5        	call8	4201062c <get_arg$isra$0>
42011394:	0a48      	l32i.n	a4, a10, 0
42011396:	057d      	mov.n	a7, a5
42011398:	001d06        	j	42011410 <_vfiprintf_r+0x8f0>
4201139b:	751b00        	extui	a1, a0, 27, 8
4201139e:	07a587        	bge	a5, a8, 420113a9 <_vfiprintf_r+0x889>
420113a1:	b0e6e0        	addx8	a14, a6, a14
420113a4:	0e48      	l32i.n	a4, a14, 0
420113a6:	001986        	j	42011410 <_vfiprintf_r+0x8f0>
420113a9:	922e92        	l32i	a9, a14, 0x248
420113ac:	fb1c      	movi.n	a11, 31
420113ae:	02dee2        	addmi	a14, a14, 0x200
420113b1:	a94b      	addi.n	a10, a9, 4
420113b3:	322b87        	blt	a11, a8, 420113e9 <_vfiprintf_r+0x8c9>
420113b6:	b81b      	addi.n	a11, a8, 1
420113b8:	9161b2        	s32i	a11, a1, 0x244
420113bb:	126ea2        	s32i	a10, a14, 72
420113be:	8b1c      	movi.n	a11, 24
420113c0:	052ba7        	blt	a11, a10, 420113c9 <_vfiprintf_r+0x8a9>
420113c3:	112e92        	l32i	a9, a14, 68
420113c6:	000406        	j	420113da <_vfiprintf_r+0x8ba>
420113c9:	012b97        	blt	a11, a9, 420113ce <_vfiprintf_r+0x8ae>
420113cc:	4a2c      	movi.n	a10, 36
420113ce:	10c192        	addi	a9, a1, 16
420113d1:	02d992        	addmi	a9, a9, 0x200
420113d4:	102992        	l32i	a9, a9, 64
420113d7:	9661a2        	s32i	a10, a1, 0x258
420113da:	99aa      	add.n	a9, a9, a10
420113dc:	fcc992        	addi	a9, a9, -4
420113df:	0948      	l32i.n	a4, a9, 0
420113e1:	b08810        	addx8	a8, a8, a1
420113e4:	4849      	s32i.n	a4, a8, 16
420113e6:	000986        	j	42011410 <_vfiprintf_r+0x8f0>
420113e9:	126ea2        	s32i	a10, a14, 72
420113ec:	881c      	movi.n	a8, 24
420113ee:	0528a7        	blt	a8, a10, 420113f7 <_vfiprintf_r+0x8d7>
420113f1:	112e82        	l32i	a8, a14, 68
420113f4:	000446        	j	42011409 <_vfiprintf_r+0x8e9>
420113f7:	022897        	blt	a8, a9, 420113fd <_vfiprintf_r+0x8dd>
420113fa:	24a0a2        	movi	a10, 36
420113fd:	10c182        	addi	a8, a1, 16
42011400:	02d882        	addmi	a8, a8, 0x200
42011403:	102882        	l32i	a8, a8, 64
42011406:	9661a2        	s32i	a10, a1, 0x258
42011409:	88aa      	add.n	a8, a8, a10
4201140b:	fcc882        	addi	a8, a8, -4
4201140e:	0848      	l32i.n	a4, a8, 0
42011410:	312f40        	srai	a2, a4, 31
42011413:	002296        	bltz	a2, 42011419 <_vfiprintf_r+0x8f9>
42011416:	04d546        	j	4201276f <_vfiprintf_r+0x1c4f>
42011419:	602020        	neg	a2, a2
4201141c:	048c      	beqz.n	a4, 42011420 <_vfiprintf_r+0x900>
4201141e:	220b      	addi.n	a2, a2, -1
42011420:	604040        	neg	a4, a4
42011423:	d92c      	movi.n	a9, 45
42011425:	180c      	movi.n	a8, 1
42011427:	036f06        	j	420121e7 <_vfiprintf_r+0x16c7>
4201142a:	820000        	mull	a0, a0, a0
4201142d:	e29121        	l32r	a2, 42009e74 <gptimer_release_group_handle+0xb8> (8e0d9 <UserFrameTotalSize+0x8dfd9>)
42011430:	5710c1        	l32r	a12, 41fe7070 <_iram_bss_end+0x1c64c70>
42011433:	c602e3        	lsi	f14, a2, 0x318
42011436:	0029      	s32i.n	a2, a0, 0
42011438:	c4ac      	beqz.n	a4, 42011468 <_vfiprintf_r+0x948>
4201143a:	07a687        	bge	a6, a8, 42011445 <_vfiprintf_r+0x925>
4201143d:	b0e6e0        	addx8	a14, a6, a14
42011440:	0e98      	l32i.n	a9, a14, 0
42011442:	000706        	j	42011462 <_vfiprintf_r+0x942>
42011445:	30a282        	movi	a8, 0x230
42011448:	8e8a      	add.n	a8, a14, a8
4201144a:	34a2d2        	movi	a13, 0x234
4201144d:	40a2c2        	movi	a12, 0x240
42011450:	0189      	s32i.n	a8, a1, 0
42011452:	01def2        	addmi	a15, a14, 0x100
42011455:	deda      	add.n	a13, a14, a13
42011457:	ceca      	add.n	a12, a14, a12
42011459:	07bd      	mov.n	a11, a7
4201145b:	06ad      	mov.n	a10, a6
4201145d:	ff1ce5        	call8	4201062c <get_arg$isra$0>
42011460:	0a98      	l32i.n	a9, a10, 0
42011462:	05ad      	mov.n	a10, a5
42011464:	001a86        	j	420114d2 <_vfiprintf_r+0x9b2>
42011467:	a51b00        	extui	a1, a0, 27, 11
4201146a:	07a587        	bge	a5, a8, 42011475 <_vfiprintf_r+0x955>
4201146d:	b0e6e0        	addx8	a14, a6, a14
42011470:	0e98      	l32i.n	a9, a14, 0
42011472:	001706        	j	420114d2 <_vfiprintf_r+0x9b2>
42011475:	922ec2        	l32i	a12, a14, 0x248
42011478:	fd1c      	movi.n	a13, 31
4201147a:	02deb2        	addmi	a11, a14, 0x200
4201147d:	9c4b      	addi.n	a9, a12, 4
4201147f:	2d2d87        	blt	a13, a8, 420114b0 <_vfiprintf_r+0x990>
42011482:	d81b      	addi.n	a13, a8, 1
42011484:	9161d2        	s32i	a13, a1, 0x244
42011487:	126b92        	s32i	a9, a11, 72
4201148a:	8d1c      	movi.n	a13, 24
4201148c:	052d97        	blt	a13, a9, 42011495 <_vfiprintf_r+0x975>
4201148f:	112bb2        	l32i	a11, a11, 68
42011492:	000286        	j	420114a0 <_vfiprintf_r+0x980>
42011495:	012dc7        	blt	a13, a12, 4201149a <_vfiprintf_r+0x97a>
42011498:	492c      	movi.n	a9, 36
4201149a:	902eb2        	l32i	a11, a14, 0x240
4201149d:	926e92        	s32i	a9, a14, 0x248
420114a0:	bb9a      	add.n	a11, a11, a9
420114a2:	fccbb2        	addi	a11, a11, -4
420114a5:	0b98      	l32i.n	a9, a11, 0
420114a7:	b088e0        	addx8	a8, a8, a14
420114aa:	0899      	s32i.n	a9, a8, 0
420114ac:	000886        	j	420114d2 <_vfiprintf_r+0x9b2>
420114af:	6b9200        	ole.s	b9, f2, f0
420114b2:	881c12        	l16ui	a1, a12, 0x110
420114b5:	072897        	blt	a8, a9, 420114c0 <_vfiprintf_r+0x9a0>
420114b8:	112b82        	l32i	a8, a11, 68
420114bb:	000306        	j	420114cb <_vfiprintf_r+0x9ab>
420114be:	c70000        	ee.stf.64.xp	f0, f12, a0, a0
420114c1:	0128      	l32i.n	a2, a1, 0
420114c3:	492c      	movi.n	a9, 36
420114c5:	902e82        	l32i	a8, a14, 0x240
420114c8:	926e92        	s32i	a9, a14, 0x248
420114cb:	889a      	add.n	a8, a8, a9
420114cd:	fcc882        	addi	a8, a8, -4
420114d0:	0898      	l32i.n	a9, a8, 0
420114d2:	9d2182        	l32i	a8, a1, 0x274
420114d5:	0989      	s32i.n	a8, a9, 0
420114d7:	318f80        	srai	a8, a8, 31
420114da:	1989      	s32i.n	a8, a9, 4
420114dc:	009606        	j	42011738 <_vfiprintf_r+0xc18>
420114df:	634700        	minu	a4, a7, a0
420114e2:	148c60        	extui	a8, a6, 12, 2
420114e5:	006d46        	j	4201169e <_vfiprintf_r+0xb7e>
420114e8:	a51b      	addi.n	a10, a5, 1
420114ea:	02a587        	bge	a5, a8, 420114f0 <_vfiprintf_r+0x9d0>
420114ed:	007806        	j	420116d1 <_vfiprintf_r+0xbb1>
420114f0:	922ec2        	l32i	a12, a14, 0x248
420114f3:	fd1c      	movi.n	a13, 31
420114f5:	02deb2        	addmi	a11, a14, 0x200
420114f8:	9c4b      	addi.n	a9, a12, 4
420114fa:	272d87        	blt	a13, a8, 42011525 <_vfiprintf_r+0xa05>
420114fd:	d81b      	addi.n	a13, a8, 1
420114ff:	9161d2        	s32i	a13, a1, 0x244
42011502:	126b92        	s32i	a9, a11, 72
42011505:	8d1c      	movi.n	a13, 24
42011507:	052d97        	blt	a13, a9, 42011510 <_vfiprintf_r+0x9f0>
4201150a:	112bb2        	l32i	a11, a11, 68
4201150d:	000286        	j	4201151b <_vfiprintf_r+0x9fb>
42011510:	012dc7        	blt	a13, a12, 42011515 <_vfiprintf_r+0x9f5>
42011513:	492c      	movi.n	a9, 36
42011515:	902eb2        	l32i	a11, a14, 0x240
42011518:	926e92        	s32i	a9, a14, 0x248
4201151b:	bb9a      	add.n	a11, a11, a9
4201151d:	fccbb2        	addi	a11, a11, -4
42011520:	0b98      	l32i.n	a9, a11, 0
42011522:	007946        	j	4201170b <_vfiprintf_r+0xbeb>
42011525:	126b92        	s32i	a9, a11, 72
42011528:	881c      	movi.n	a8, 24
4201152a:	062897        	blt	a8, a9, 42011534 <_vfiprintf_r+0xa14>
4201152d:	112b82        	l32i	a8, a11, 68
42011530:	0002c6        	j	4201153f <_vfiprintf_r+0xa1f>
42011533:	00          	.byte	00
42011534:	0128c7        	blt	a8, a12, 42011539 <_vfiprintf_r+0xa19>
42011537:	492c      	movi.n	a9, 36
42011539:	902e82        	l32i	a8, a14, 0x240
4201153c:	926e92        	s32i	a9, a14, 0x248
4201153f:	889a      	add.n	a8, a8, a9
42011541:	007a46        	j	4201172e <_vfiprintf_r+0xc0e>
42011544:	02e367        	bbsi	a3, 6, 4201154a <_vfiprintf_r+0xa2a>
42011547:	002946        	j	420115f0 <_vfiprintf_r+0xad0>
4201154a:	e4ac      	beqz.n	a4, 4201157c <_vfiprintf_r+0xa5c>
4201154c:	09a687        	bge	a6, a8, 42011559 <_vfiprintf_r+0xa39>
4201154f:	b0e6e0        	addx8	a14, a6, a14
42011552:	0e98      	l32i.n	a9, a14, 0
42011554:	000786        	j	42011576 <_vfiprintf_r+0xa56>
42011557:	820000        	mull	a0, a0, a0
4201155a:	a2          	.byte	0xa2
4201155b:	30          	.byte	0x30
4201155c:	8e8a      	add.n	a8, a14, a8
4201155e:	34a2d2        	movi	a13, 0x234
42011561:	40a2c2        	movi	a12, 0x240
42011564:	0189      	s32i.n	a8, a1, 0
42011566:	01def2        	addmi	a15, a14, 0x100
42011569:	deda      	add.n	a13, a14, a13
4201156b:	ceca      	add.n	a12, a14, a12
4201156d:	07bd      	mov.n	a11, a7
4201156f:	06ad      	mov.n	a10, a6
42011571:	ff0ba5        	call8	4201062c <get_arg$isra$0>
42011574:	0a98      	l32i.n	a9, a10, 0
42011576:	05ad      	mov.n	a10, a5
42011578:	001a86        	j	420115e6 <_vfiprintf_r+0xac6>
4201157b:	a51b00        	extui	a1, a0, 27, 11
4201157e:	07a587        	bge	a5, a8, 42011589 <_vfiprintf_r+0xa69>
42011581:	b0e6e0        	addx8	a14, a6, a14
42011584:	0e98      	l32i.n	a9, a14, 0
42011586:	001706        	j	420115e6 <_vfiprintf_r+0xac6>
42011589:	922ec2        	l32i	a12, a14, 0x248
4201158c:	fd1c      	movi.n	a13, 31
4201158e:	02deb2        	addmi	a11, a14, 0x200
42011591:	9c4b      	addi.n	a9, a12, 4
42011593:	2d2d87        	blt	a13, a8, 420115c4 <_vfiprintf_r+0xaa4>
42011596:	d81b      	addi.n	a13, a8, 1
42011598:	9161d2        	s32i	a13, a1, 0x244
4201159b:	126b92        	s32i	a9, a11, 72
4201159e:	8d1c      	movi.n	a13, 24
420115a0:	052d97        	blt	a13, a9, 420115a9 <_vfiprintf_r+0xa89>
420115a3:	112bb2        	l32i	a11, a11, 68
420115a6:	000286        	j	420115b4 <_vfiprintf_r+0xa94>
420115a9:	012dc7        	blt	a13, a12, 420115ae <_vfiprintf_r+0xa8e>
420115ac:	492c      	movi.n	a9, 36
420115ae:	902eb2        	l32i	a11, a14, 0x240
420115b1:	926e92        	s32i	a9, a14, 0x248
420115b4:	bb9a      	add.n	a11, a11, a9
420115b6:	fccbb2        	addi	a11, a11, -4
420115b9:	0b98      	l32i.n	a9, a11, 0
420115bb:	b088e0        	addx8	a8, a8, a14
420115be:	0899      	s32i.n	a9, a8, 0
420115c0:	000886        	j	420115e6 <_vfiprintf_r+0xac6>
420115c3:	6b9200        	ole.s	b9, f2, f0
420115c6:	881c12        	l16ui	a1, a12, 0x110
420115c9:	072897        	blt	a8, a9, 420115d4 <_vfiprintf_r+0xab4>
420115cc:	112b82        	l32i	a8, a11, 68
420115cf:	000306        	j	420115df <_vfiprintf_r+0xabf>
420115d2:	c70000        	ee.stf.64.xp	f0, f12, a0, a0
420115d5:	0128      	l32i.n	a2, a1, 0
420115d7:	492c      	movi.n	a9, 36
420115d9:	902e82        	l32i	a8, a14, 0x240
420115dc:	926e92        	s32i	a9, a14, 0x248
420115df:	889a      	add.n	a8, a8, a9
420115e1:	fcc882        	addi	a8, a8, -4
420115e4:	0898      	l32i.n	a9, a8, 0
420115e6:	9d2182        	l32i	a8, a1, 0x274
420115e9:	005982        	s16i	a8, a9, 0
420115ec:	005206        	j	42011738 <_vfiprintf_r+0xc18>
420115ef:	00          	.byte	00
420115f0:	02e397        	bbsi	a3, 9, 420115f6 <_vfiprintf_r+0xad6>
420115f3:	002946        	j	4201169c <_vfiprintf_r+0xb7c>
420115f6:	b4ac      	beqz.n	a4, 42011625 <_vfiprintf_r+0xb05>
420115f8:	07a687        	bge	a6, a8, 42011603 <_vfiprintf_r+0xae3>
420115fb:	b0e6e0        	addx8	a14, a6, a14
420115fe:	0e98      	l32i.n	a9, a14, 0
42011600:	000706        	j	42011620 <_vfiprintf_r+0xb00>
42011603:	30a282        	movi	a8, 0x230
42011606:	8e8a      	add.n	a8, a14, a8
42011608:	34a2d2        	movi	a13, 0x234
4201160b:	40a2c2        	movi	a12, 0x240
4201160e:	0189      	s32i.n	a8, a1, 0
42011610:	01def2        	addmi	a15, a14, 0x100
42011613:	deda      	add.n	a13, a14, a13
42011615:	ceca      	add.n	a12, a14, a12
42011617:	07bd      	mov.n	a11, a7
42011619:	06ad      	mov.n	a10, a6
4201161b:	ff0125        	call8	4201062c <get_arg$isra$0>
4201161e:	0a98      	l32i.n	a9, a10, 0
42011620:	05ad      	mov.n	a10, a5
42011622:	001b06        	j	42011692 <_vfiprintf_r+0xb72>
42011625:	a51b      	addi.n	a10, a5, 1
42011627:	09a587        	bge	a5, a8, 42011634 <_vfiprintf_r+0xb14>
4201162a:	b0e6e0        	addx8	a14, a6, a14
4201162d:	0e98      	l32i.n	a9, a14, 0
4201162f:	0017c6        	j	42011692 <_vfiprintf_r+0xb72>
42011632:	c20000        	quou	a0, a0, a0
42011635:	2e          	.byte	0x2e
42011636:	fd1c92        	l16ui	a9, a12, 0x1fa
42011639:	02deb2        	addmi	a11, a14, 0x200
4201163c:	9c4b      	addi.n	a9, a12, 4
4201163e:	2e2d87        	blt	a13, a8, 42011670 <_vfiprintf_r+0xb50>
42011641:	d81b      	addi.n	a13, a8, 1
42011643:	9161d2        	s32i	a13, a1, 0x244
42011646:	126b92        	s32i	a9, a11, 72
42011649:	8d1c      	movi.n	a13, 24
4201164b:	052d97        	blt	a13, a9, 42011654 <_vfiprintf_r+0xb34>
4201164e:	112bb2        	l32i	a11, a11, 68
42011651:	000286        	j	4201165f <_vfiprintf_r+0xb3f>
42011654:	012dc7        	blt	a13, a12, 42011659 <_vfiprintf_r+0xb39>
42011657:	492c      	movi.n	a9, 36
42011659:	902eb2        	l32i	a11, a14, 0x240
4201165c:	926e92        	s32i	a9, a14, 0x248
4201165f:	bb9a      	add.n	a11, a11, a9
42011661:	fccbb2        	addi	a11, a11, -4
42011664:	0b98      	l32i.n	a9, a11, 0
42011666:	b088e0        	addx8	a8, a8, a14
42011669:	0899      	s32i.n	a9, a8, 0
4201166b:	0008c6        	j	42011692 <_vfiprintf_r+0xb72>
4201166e:	00          	.byte	00
4201166f:	6b9200        	ole.s	b9, f2, f0
42011672:	881c12        	l16ui	a1, a12, 0x110
42011675:	072897        	blt	a8, a9, 42011680 <_vfiprintf_r+0xb60>
42011678:	112b82        	l32i	a8, a11, 68
4201167b:	000306        	j	4201168b <_vfiprintf_r+0xb6b>
4201167e:	c70000        	ee.stf.64.xp	f0, f12, a0, a0
42011681:	0128      	l32i.n	a2, a1, 0
42011683:	492c      	movi.n	a9, 36
42011685:	902e82        	l32i	a8, a14, 0x240
42011688:	926e92        	s32i	a9, a14, 0x248
4201168b:	889a      	add.n	a8, a8, a9
4201168d:	fcc882        	addi	a8, a8, -4
42011690:	0898      	l32i.n	a9, a8, 0
42011692:	9d2182        	l32i	a8, a1, 0x274
42011695:	004982        	s8i	a8, a9, 0
42011698:	002706        	j	42011738 <_vfiprintf_r+0xc18>
4201169b:	c4ac00        	extui	a10, a0, 12, 13
4201169e:	07a687        	bge	a6, a8, 420116a9 <_vfiprintf_r+0xb89>
420116a1:	b0e6e0        	addx8	a14, a6, a14
420116a4:	0e98      	l32i.n	a9, a14, 0
420116a6:	000706        	j	420116c6 <_vfiprintf_r+0xba6>
420116a9:	30a282        	movi	a8, 0x230
420116ac:	8e8a      	add.n	a8, a14, a8
420116ae:	34a2d2        	movi	a13, 0x234
420116b1:	40a2c2        	movi	a12, 0x240
420116b4:	0189      	s32i.n	a8, a1, 0
420116b6:	01def2        	addmi	a15, a14, 0x100
420116b9:	deda      	add.n	a13, a14, a13
420116bb:	ceca      	add.n	a12, a14, a12
420116bd:	07bd      	mov.n	a11, a7
420116bf:	06ad      	mov.n	a10, a6
420116c1:	fef6a5        	call8	4201062c <get_arg$isra$0>
420116c4:	0a98      	l32i.n	a9, a10, 0
420116c6:	05ad      	mov.n	a10, a5
420116c8:	0019c6        	j	42011733 <_vfiprintf_r+0xc13>
420116cb:	a51b00        	extui	a1, a0, 27, 11
420116ce:	07a587        	bge	a5, a8, 420116d9 <_vfiprintf_r+0xbb9>
420116d1:	b0e6e0        	addx8	a14, a6, a14
420116d4:	0e98      	l32i.n	a9, a14, 0
420116d6:	001646        	j	42011733 <_vfiprintf_r+0xc13>
420116d9:	922ec2        	l32i	a12, a14, 0x248
420116dc:	fd1c      	movi.n	a13, 31
420116de:	02de92        	addmi	a9, a14, 0x200
420116e1:	bc4b      	addi.n	a11, a12, 4
420116e3:	2c2d87        	blt	a13, a8, 42011713 <_vfiprintf_r+0xbf3>
420116e6:	d81b      	addi.n	a13, a8, 1
420116e8:	9161d2        	s32i	a13, a1, 0x244
420116eb:	1269b2        	s32i	a11, a9, 72
420116ee:	8d1c      	movi.n	a13, 24
420116f0:	052db7        	blt	a13, a11, 420116f9 <_vfiprintf_r+0xbd9>
420116f3:	112992        	l32i	a9, a9, 68
420116f6:	000286        	j	42011704 <_vfiprintf_r+0xbe4>
420116f9:	012dc7        	blt	a13, a12, 420116fe <_vfiprintf_r+0xbde>
420116fc:	4b2c      	movi.n	a11, 36
420116fe:	902e92        	l32i	a9, a14, 0x240
42011701:	926eb2        	s32i	a11, a14, 0x248
42011704:	99ba      	add.n	a9, a9, a11
42011706:	fcc992        	addi	a9, a9, -4
42011709:	0998      	l32i.n	a9, a9, 0
4201170b:	b088e0        	addx8	a8, a8, a14
4201170e:	0899      	s32i.n	a9, a8, 0
42011710:	0007c6        	j	42011733 <_vfiprintf_r+0xc13>
42011713:	1269b2        	s32i	a11, a9, 72
42011716:	881c      	movi.n	a8, 24
42011718:	0528b7        	blt	a8, a11, 42011721 <_vfiprintf_r+0xc01>
4201171b:	112982        	l32i	a8, a9, 68
4201171e:	000286        	j	4201172c <_vfiprintf_r+0xc0c>
42011721:	0128c7        	blt	a8, a12, 42011726 <_vfiprintf_r+0xc06>
42011724:	4b2c      	movi.n	a11, 36
42011726:	902e82        	l32i	a8, a14, 0x240
42011729:	926eb2        	s32i	a11, a14, 0x248
4201172c:	88ba      	add.n	a8, a8, a11
4201172e:	fcc882        	addi	a8, a8, -4
42011731:	0898      	l32i.n	a9, a8, 0
42011733:	9d2182        	l32i	a8, a1, 0x274
42011736:	0989      	s32i.n	a8, a9, 0
42011738:	0a5d      	mov.n	a5, a10
4201173a:	fd3f86        	j	42010c3c <_vfiprintf_r+0x11c>
4201173d:	081c      	movi.n	a8, 16
4201173f:	203380        	or	a3, a3, a8
42011742:	912182        	l32i	a8, a1, 0x244
42011745:	10c1e2        	addi	a14, a1, 16
42011748:	02e357        	bbsi	a3, 5, 4201174e <_vfiprintf_r+0xc2e>
4201174b:	002f86        	j	4201180d <_vfiprintf_r+0xced>
4201174e:	f4ac      	beqz.n	a4, 42011781 <_vfiprintf_r+0xc61>
42011750:	09a687        	bge	a6, a8, 4201175d <_vfiprintf_r+0xc3d>
42011753:	b0e6e0        	addx8	a14, a6, a14
42011756:	0e48      	l32i.n	a4, a14, 0
42011758:	1e28      	l32i.n	a2, a14, 4
4201175a:	000786        	j	4201177c <_vfiprintf_r+0xc5c>
4201175d:	30a282        	movi	a8, 0x230
42011760:	8e8a      	add.n	a8, a14, a8
42011762:	34a2d2        	movi	a13, 0x234
42011765:	40a2c2        	movi	a12, 0x240
42011768:	0189      	s32i.n	a8, a1, 0
4201176a:	01def2        	addmi	a15, a14, 0x100
4201176d:	deda      	add.n	a13, a14, a13
4201176f:	ceca      	add.n	a12, a14, a12
42011771:	07bd      	mov.n	a11, a7
42011773:	06ad      	mov.n	a10, a6
42011775:	feeb65        	call8	4201062c <get_arg$isra$0>
42011778:	0a48      	l32i.n	a4, a10, 0
4201177a:	1a28      	l32i.n	a2, a10, 4
4201177c:	057d      	mov.n	a7, a5
4201177e:	00a806        	j	42011a22 <_vfiprintf_r+0xf02>
42011781:	751b      	addi.n	a7, a5, 1
42011783:	09a587        	bge	a5, a8, 42011790 <_vfiprintf_r+0xc70>
42011786:	b0e6e0        	addx8	a14, a6, a14
42011789:	0e48      	l32i.n	a4, a14, 0
4201178b:	1e28      	l32i.n	a2, a14, 4
4201178d:	00a446        	j	42011a22 <_vfiprintf_r+0xf02>
42011790:	922e92        	l32i	a9, a14, 0x248
42011793:	8a7c      	movi.n	a10, -8
42011795:	997b      	addi.n	a9, a9, 7
42011797:	1099a0        	and	a9, a9, a10
4201179a:	fb1c      	movi.n	a11, 31
4201179c:	02dee2        	addmi	a14, a14, 0x200
4201179f:	a98b      	addi.n	a10, a9, 8
420117a1:	3b2b87        	blt	a11, a8, 420117e0 <_vfiprintf_r+0xcc0>
420117a4:	b81b      	addi.n	a11, a8, 1
420117a6:	9161b2        	s32i	a11, a1, 0x244
420117a9:	126ea2        	s32i	a10, a14, 72
420117ac:	8b1c      	movi.n	a11, 24
420117ae:	062ba7        	blt	a11, a10, 420117b8 <_vfiprintf_r+0xc98>
420117b1:	112e92        	l32i	a9, a14, 68
420117b4:	000446        	j	420117c9 <_vfiprintf_r+0xca9>
420117b7:	2b9700        	oeq.s	b9, f7, f0
420117ba:	8a2c01        	l32r	a0, 41ff406c <_iram_bss_end+0x1c71c6c>
420117bd:	10c192        	addi	a9, a1, 16
420117c0:	02d992        	addmi	a9, a9, 0x200
420117c3:	102992        	l32i	a9, a9, 64
420117c6:	9661a2        	s32i	a10, a1, 0x258
420117c9:	99aa      	add.n	a9, a9, a10
420117cb:	f8c992        	addi	a9, a9, -8
420117ce:	0948      	l32i.n	a4, a9, 0
420117d0:	1928      	l32i.n	a2, a9, 4
420117d2:	10c192        	addi	a9, a1, 16
420117d5:	b08890        	addx8	a8, a8, a9
420117d8:	0849      	s32i.n	a4, a8, 0
420117da:	1829      	s32i.n	a2, a8, 4
420117dc:	009086        	j	42011a22 <_vfiprintf_r+0xf02>
420117df:	00          	.byte	00
420117e0:	126ea2        	s32i	a10, a14, 72
420117e3:	881c      	movi.n	a8, 24
420117e5:	0728a7        	blt	a8, a10, 420117f0 <_vfiprintf_r+0xcd0>
420117e8:	112e82        	l32i	a8, a14, 68
420117eb:	000486        	j	42011801 <_vfiprintf_r+0xce1>
420117ee:	970000        	ee.stf.64.xp	f0, f9, a0, a0
420117f1:	0128      	l32i.n	a2, a1, 0
420117f3:	8a2c      	movi.n	a10, 40
420117f5:	10c182        	addi	a8, a1, 16
420117f8:	02d882        	addmi	a8, a8, 0x200
420117fb:	102882        	l32i	a8, a8, 64
420117fe:	9661a2        	s32i	a10, a1, 0x258
42011801:	88aa      	add.n	a8, a8, a10
42011803:	f8c882        	addi	a8, a8, -8
42011806:	0848      	l32i.n	a4, a8, 0
42011808:	1828      	l32i.n	a2, a8, 4
4201180a:	008506        	j	42011a22 <_vfiprintf_r+0xf02>
4201180d:	036347        	bbci	a3, 4, 42011814 <_vfiprintf_r+0xcf4>
42011810:	005946        	j	42011979 <_vfiprintf_r+0xe59>
42011813:	00          	.byte	00
42011814:	02e367        	bbsi	a3, 6, 4201181a <_vfiprintf_r+0xcfa>
42011817:	002b46        	j	420118c8 <_vfiprintf_r+0xda8>
4201181a:	c4ac      	beqz.n	a4, 4201184a <_vfiprintf_r+0xd2a>
4201181c:	08a687        	bge	a6, a8, 42011828 <_vfiprintf_r+0xd08>
4201181f:	b0e6e0        	addx8	a14, a6, a14
42011822:	001e42        	l16ui	a4, a14, 0
42011825:	005f46        	j	420119a6 <_vfiprintf_r+0xe86>
42011828:	30a282        	movi	a8, 0x230
4201182b:	8e8a      	add.n	a8, a14, a8
4201182d:	34a2d2        	movi	a13, 0x234
42011830:	40a2c2        	movi	a12, 0x240
42011833:	0189      	s32i.n	a8, a1, 0
42011835:	01def2        	addmi	a15, a14, 0x100
42011838:	deda      	add.n	a13, a14, a13
4201183a:	ceca      	add.n	a12, a14, a12
4201183c:	07bd      	mov.n	a11, a7
4201183e:	20a660        	or	a10, a6, a6
42011841:	fedea5        	call8	4201062c <get_arg$isra$0>
42011844:	001a42        	l16ui	a4, a10, 0
42011847:	0056c6        	j	420119a6 <_vfiprintf_r+0xe86>
4201184a:	751b      	addi.n	a7, a5, 1
4201184c:	08a587        	bge	a5, a8, 42011858 <_vfiprintf_r+0xd38>
4201184f:	b0e6e0        	addx8	a14, a6, a14
42011852:	001e42        	l16ui	a4, a14, 0
42011855:	0071c6        	j	42011a20 <_vfiprintf_r+0xf00>
42011858:	922e92        	l32i	a9, a14, 0x248
4201185b:	fb1c      	movi.n	a11, 31
4201185d:	02dee2        	addmi	a14, a14, 0x200
42011860:	a94b      	addi.n	a10, a9, 4
42011862:	362b87        	blt	a11, a8, 4201189c <_vfiprintf_r+0xd7c>
42011865:	b81b      	addi.n	a11, a8, 1
42011867:	9161b2        	s32i	a11, a1, 0x244
4201186a:	126ea2        	s32i	a10, a14, 72
4201186d:	8b1c      	movi.n	a11, 24
4201186f:	052ba7        	blt	a11, a10, 42011878 <_vfiprintf_r+0xd58>
42011872:	112e92        	l32i	a9, a14, 68
42011875:	000406        	j	42011889 <_vfiprintf_r+0xd69>
42011878:	012b97        	blt	a11, a9, 4201187d <_vfiprintf_r+0xd5d>
4201187b:	4a2c      	movi.n	a10, 36
4201187d:	10c192        	addi	a9, a1, 16
42011880:	02d992        	addmi	a9, a9, 0x200
42011883:	102992        	l32i	a9, a9, 64
42011886:	9661a2        	s32i	a10, a1, 0x258
42011889:	99aa      	add.n	a9, a9, a10
4201188b:	fcc992        	addi	a9, a9, -4
4201188e:	0948      	l32i.n	a4, a9, 0
42011890:	b08810        	addx8	a8, a8, a1
42011893:	4849      	s32i.n	a4, a8, 16
42011895:	f44040        	extui	a4, a4, 0, 16
42011898:	006106        	j	42011a20 <_vfiprintf_r+0xf00>
4201189b:	00          	.byte	00
4201189c:	126ea2        	s32i	a10, a14, 72
4201189f:	881c      	movi.n	a8, 24
420118a1:	0728a7        	blt	a8, a10, 420118ac <_vfiprintf_r+0xd8c>
420118a4:	112e82        	l32i	a8, a14, 68
420118a7:	000486        	j	420118bd <_vfiprintf_r+0xd9d>
420118aa:	970000        	ee.stf.64.xp	f0, f9, a0, a0
420118ad:	0128      	l32i.n	a2, a1, 0
420118af:	4a2c      	movi.n	a10, 36
420118b1:	10c182        	addi	a8, a1, 16
420118b4:	02d882        	addmi	a8, a8, 0x200
420118b7:	102882        	l32i	a8, a8, 64
420118ba:	9661a2        	s32i	a10, a1, 0x258
420118bd:	88aa      	add.n	a8, a8, a10
420118bf:	fcc882        	addi	a8, a8, -4
420118c2:	001842        	l16ui	a4, a8, 0
420118c5:	0055c6        	j	42011a20 <_vfiprintf_r+0xf00>
420118c8:	02e397        	bbsi	a3, 9, 420118ce <_vfiprintf_r+0xdae>
420118cb:	002a86        	j	42011979 <_vfiprintf_r+0xe59>
420118ce:	c4ac      	beqz.n	a4, 420118fe <_vfiprintf_r+0xdde>
420118d0:	09a687        	bge	a6, a8, 420118dd <_vfiprintf_r+0xdbd>
420118d3:	b0e6e0        	addx8	a14, a6, a14
420118d6:	000e42        	l8ui	a4, a14, 0
420118d9:	003246        	j	420119a6 <_vfiprintf_r+0xe86>
420118dc:	a28200        	muluh	a8, a2, a0
420118df:	30          	.byte	0x30
420118e0:	8e8a      	add.n	a8, a14, a8
420118e2:	34a2d2        	movi	a13, 0x234
420118e5:	40a2c2        	movi	a12, 0x240
420118e8:	0189      	s32i.n	a8, a1, 0
420118ea:	01def2        	addmi	a15, a14, 0x100
420118ed:	deda      	add.n	a13, a14, a13
420118ef:	ceca      	add.n	a12, a14, a12
420118f1:	07bd      	mov.n	a11, a7
420118f3:	06ad      	mov.n	a10, a6
420118f5:	fed365        	call8	4201062c <get_arg$isra$0>
420118f8:	000a42        	l8ui	a4, a10, 0
420118fb:	0029c6        	j	420119a6 <_vfiprintf_r+0xe86>
420118fe:	751b      	addi.n	a7, a5, 1
42011900:	08a587        	bge	a5, a8, 4201190c <_vfiprintf_r+0xdec>
42011903:	b0e6e0        	addx8	a14, a6, a14
42011906:	000e42        	l8ui	a4, a14, 0
42011909:	0044c6        	j	42011a20 <_vfiprintf_r+0xf00>
4201190c:	922e92        	l32i	a9, a14, 0x248
4201190f:	fb1c      	movi.n	a11, 31
42011911:	02dee2        	addmi	a14, a14, 0x200
42011914:	a94b      	addi.n	a10, a9, 4
42011916:	352b87        	blt	a11, a8, 4201194f <_vfiprintf_r+0xe2f>
42011919:	b81b      	addi.n	a11, a8, 1
4201191b:	9161b2        	s32i	a11, a1, 0x244
4201191e:	126ea2        	s32i	a10, a14, 72
42011921:	8b1c      	movi.n	a11, 24
42011923:	052ba7        	blt	a11, a10, 4201192c <_vfiprintf_r+0xe0c>
42011926:	112e92        	l32i	a9, a14, 68
42011929:	000406        	j	4201193d <_vfiprintf_r+0xe1d>
4201192c:	012b97        	blt	a11, a9, 42011931 <_vfiprintf_r+0xe11>
4201192f:	4a2c      	movi.n	a10, 36
42011931:	10c192        	addi	a9, a1, 16
42011934:	02d992        	addmi	a9, a9, 0x200
42011937:	102992        	l32i	a9, a9, 64
4201193a:	9661a2        	s32i	a10, a1, 0x258
4201193d:	99aa      	add.n	a9, a9, a10
4201193f:	fcc992        	addi	a9, a9, -4
42011942:	0948      	l32i.n	a4, a9, 0
42011944:	b08810        	addx8	a8, a8, a1
42011947:	4849      	s32i.n	a4, a8, 16
42011949:	744040        	extui	a4, a4, 0, 8
4201194c:	003406        	j	42011a20 <_vfiprintf_r+0xf00>
4201194f:	126ea2        	s32i	a10, a14, 72
42011952:	881c      	movi.n	a8, 24
42011954:	0528a7        	blt	a8, a10, 4201195d <_vfiprintf_r+0xe3d>
42011957:	112e82        	l32i	a8, a14, 68
4201195a:	000406        	j	4201196e <_vfiprintf_r+0xe4e>
4201195d:	012897        	blt	a8, a9, 42011962 <_vfiprintf_r+0xe42>
42011960:	4a2c      	movi.n	a10, 36
42011962:	10c182        	addi	a8, a1, 16
42011965:	02d882        	addmi	a8, a8, 0x200
42011968:	102882        	l32i	a8, a8, 64
4201196b:	9661a2        	s32i	a10, a1, 0x258
4201196e:	88aa      	add.n	a8, a8, a10
42011970:	fcc882        	addi	a8, a8, -4
42011973:	000842        	l8ui	a4, a8, 0
42011976:	002986        	j	42011a20 <_vfiprintf_r+0xf00>
42011979:	f4ac      	beqz.n	a4, 420119ac <_vfiprintf_r+0xe8c>
4201197b:	0aa687        	bge	a6, a8, 42011989 <_vfiprintf_r+0xe69>
4201197e:	b0e6e0        	addx8	a14, a6, a14
42011981:	0e48      	l32i.n	a4, a14, 0
42011983:	0007c6        	j	420119a6 <_vfiprintf_r+0xe86>
42011986:	000000        	ill
42011989:	30a282        	movi	a8, 0x230
4201198c:	8e8a      	add.n	a8, a14, a8
4201198e:	34a2d2        	movi	a13, 0x234
42011991:	40a2c2        	movi	a12, 0x240
42011994:	0189      	s32i.n	a8, a1, 0
42011996:	01def2        	addmi	a15, a14, 0x100
42011999:	deda      	add.n	a13, a14, a13
4201199b:	ceca      	add.n	a12, a14, a12
4201199d:	07bd      	mov.n	a11, a7
4201199f:	06ad      	mov.n	a10, a6
420119a1:	fec8a5        	call8	4201062c <get_arg$isra$0>
420119a4:	0a48      	l32i.n	a4, a10, 0
420119a6:	057d      	mov.n	a7, a5
420119a8:	001d06        	j	42011a20 <_vfiprintf_r+0xf00>
420119ab:	751b00        	extui	a1, a0, 27, 8
420119ae:	07a587        	bge	a5, a8, 420119b9 <_vfiprintf_r+0xe99>
420119b1:	b0e6e0        	addx8	a14, a6, a14
420119b4:	0e48      	l32i.n	a4, a14, 0
420119b6:	001986        	j	42011a20 <_vfiprintf_r+0xf00>
420119b9:	922e92        	l32i	a9, a14, 0x248
420119bc:	fb1c      	movi.n	a11, 31
420119be:	02dee2        	addmi	a14, a14, 0x200
420119c1:	a94b      	addi.n	a10, a9, 4
420119c3:	322b87        	blt	a11, a8, 420119f9 <_vfiprintf_r+0xed9>
420119c6:	b81b      	addi.n	a11, a8, 1
420119c8:	9161b2        	s32i	a11, a1, 0x244
420119cb:	126ea2        	s32i	a10, a14, 72
420119ce:	8b1c      	movi.n	a11, 24
420119d0:	052ba7        	blt	a11, a10, 420119d9 <_vfiprintf_r+0xeb9>
420119d3:	112e92        	l32i	a9, a14, 68
420119d6:	000406        	j	420119ea <_vfiprintf_r+0xeca>
420119d9:	012b97        	blt	a11, a9, 420119de <_vfiprintf_r+0xebe>
420119dc:	4a2c      	movi.n	a10, 36
420119de:	10c192        	addi	a9, a1, 16
420119e1:	02d992        	addmi	a9, a9, 0x200
420119e4:	102992        	l32i	a9, a9, 64
420119e7:	9661a2        	s32i	a10, a1, 0x258
420119ea:	99aa      	add.n	a9, a9, a10
420119ec:	fcc992        	addi	a9, a9, -4
420119ef:	0948      	l32i.n	a4, a9, 0
420119f1:	b08810        	addx8	a8, a8, a1
420119f4:	4849      	s32i.n	a4, a8, 16
420119f6:	000986        	j	42011a20 <_vfiprintf_r+0xf00>
420119f9:	126ea2        	s32i	a10, a14, 72
420119fc:	881c      	movi.n	a8, 24
420119fe:	0628a7        	blt	a8, a10, 42011a08 <_vfiprintf_r+0xee8>
42011a01:	112e82        	l32i	a8, a14, 68
42011a04:	000446        	j	42011a19 <_vfiprintf_r+0xef9>
42011a07:	00          	.byte	00
42011a08:	012897        	blt	a8, a9, 42011a0d <_vfiprintf_r+0xeed>
42011a0b:	4a2c      	movi.n	a10, 36
42011a0d:	10c182        	addi	a8, a1, 16
42011a10:	02d882        	addmi	a8, a8, 0x200
42011a13:	102882        	l32i	a8, a8, 64
42011a16:	9661a2        	s32i	a10, a1, 0x258
42011a19:	88aa      	add.n	a8, a8, a10
42011a1b:	fcc882        	addi	a8, a8, -4
42011a1e:	0848      	l32i.n	a4, a8, 0
42011a20:	020c      	movi.n	a2, 0
42011a22:	ffab82        	movi	a8, 0xfffffbff
42011a25:	103380        	and	a3, a3, a8
42011a28:	080c      	movi.n	a8, 0
42011a2a:	01edc6        	j	420121e5 <_vfiprintf_r+0x16c5>
42011a2d:	218200        	srai	a8, a0, 2
42011a30:	c1e291        	l32r	a9, 420021b8 <esp_panic_handler_feed_wdts+0x6c> (d98107ad <_rtc_reserved_end+0x797107ad>)
42011a33:	b4ac10        	extui	a10, a1, 12, 12
42011a36:	07a687        	bge	a6, a8, 42011a41 <_vfiprintf_r+0xf21>
42011a39:	b0e6e0        	addx8	a14, a6, a14
42011a3c:	0e48      	l32i.n	a4, a14, 0
42011a3e:	000706        	j	42011a5e <_vfiprintf_r+0xf3e>
42011a41:	30a282        	movi	a8, 0x230
42011a44:	8e8a      	add.n	a8, a14, a8
42011a46:	34a2d2        	movi	a13, 0x234
42011a49:	40a2c2        	movi	a12, 0x240
42011a4c:	0189      	s32i.n	a8, a1, 0
42011a4e:	01def2        	addmi	a15, a14, 0x100
42011a51:	deda      	add.n	a13, a14, a13
42011a53:	ceca      	add.n	a12, a14, a12
42011a55:	07bd      	mov.n	a11, a7
42011a57:	06ad      	mov.n	a10, a6
42011a59:	febd25        	call8	4201062c <get_arg$isra$0>
42011a5c:	0a48      	l32i.n	a4, a10, 0
42011a5e:	057d      	mov.n	a7, a5
42011a60:	001d06        	j	42011ad8 <_vfiprintf_r+0xfb8>
42011a63:	751b      	addi.n	a7, a5, 1
42011a65:	07a587        	bge	a5, a8, 42011a70 <_vfiprintf_r+0xf50>
42011a68:	b0e6e0        	addx8	a14, a6, a14
42011a6b:	0e48      	l32i.n	a4, a14, 0
42011a6d:	0019c6        	j	42011ad8 <_vfiprintf_r+0xfb8>
42011a70:	922e92        	l32i	a9, a14, 0x248
42011a73:	fb1c      	movi.n	a11, 31
42011a75:	02dee2        	addmi	a14, a14, 0x200
42011a78:	a94b      	addi.n	a10, a9, 4
42011a7a:	322b87        	blt	a11, a8, 42011ab0 <_vfiprintf_r+0xf90>
42011a7d:	b81b      	addi.n	a11, a8, 1
42011a7f:	9161b2        	s32i	a11, a1, 0x244
42011a82:	126ea2        	s32i	a10, a14, 72
42011a85:	8b1c      	movi.n	a11, 24
42011a87:	052ba7        	blt	a11, a10, 42011a90 <_vfiprintf_r+0xf70>
42011a8a:	112e92        	l32i	a9, a14, 68
42011a8d:	000406        	j	42011aa1 <_vfiprintf_r+0xf81>
42011a90:	012b97        	blt	a11, a9, 42011a95 <_vfiprintf_r+0xf75>
42011a93:	4a2c      	movi.n	a10, 36
42011a95:	10c192        	addi	a9, a1, 16
42011a98:	02d992        	addmi	a9, a9, 0x200
42011a9b:	102992        	l32i	a9, a9, 64
42011a9e:	9661a2        	s32i	a10, a1, 0x258
42011aa1:	99aa      	add.n	a9, a9, a10
42011aa3:	fcc992        	addi	a9, a9, -4
42011aa6:	0948      	l32i.n	a4, a9, 0
42011aa8:	b08810        	addx8	a8, a8, a1
42011aab:	4849      	s32i.n	a4, a8, 16
42011aad:	0009c6        	j	42011ad8 <_vfiprintf_r+0xfb8>
42011ab0:	126ea2        	s32i	a10, a14, 72
42011ab3:	881c      	movi.n	a8, 24
42011ab5:	0728a7        	blt	a8, a10, 42011ac0 <_vfiprintf_r+0xfa0>
42011ab8:	112e82        	l32i	a8, a14, 68
42011abb:	000486        	j	42011ad1 <_vfiprintf_r+0xfb1>
42011abe:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42011ac1:	0128      	l32i.n	a2, a1, 0
42011ac3:	4a2c      	movi.n	a10, 36
42011ac5:	10c182        	addi	a8, a1, 16
42011ac8:	02d882        	addmi	a8, a8, 0x200
42011acb:	102882        	l32i	a8, a8, 64
42011ace:	9661a2        	s32i	a10, a1, 0x258
42011ad1:	88aa      	add.n	a8, a8, a10
42011ad3:	fcc882        	addi	a8, a8, -4
42011ad6:	0848      	l32i.n	a4, a8, 0
42011ad8:	280c      	movi.n	a8, 2
42011ada:	203380        	or	a3, a3, a8
42011add:	10c182        	addi	a8, a1, 16
42011ae0:	02d882        	addmi	a8, a8, 0x200
42011ae3:	093c      	movi.n	a9, 48
42011ae5:	384892        	s8i	a9, a8, 56
42011ae8:	78a092        	movi	a9, 120
42011aeb:	394892        	s8i	a9, a8, 57
42011aee:	bd0581        	l32r	a8, 42000f04 <_stext+0xee4> (3c0286f4 <blanks$1+0x20>)
42011af1:	020c      	movi.n	a2, 0
42011af3:	a16182        	s32i	a8, a1, 0x284
42011af6:	01ba46        	j	420121e3 <_vfiprintf_r+0x16c3>
42011af9:	218200        	srai	a8, a0, 2
42011afc:	c1e291        	l32r	a9, 42002284 <esp_panic_handler+0x74> (388c2007 <UserFrameTotalSize+0x388c1f07>)
42011aff:	c4ac10        	extui	a10, a1, 12, 13
42011b02:	07a687        	bge	a6, a8, 42011b0d <_vfiprintf_r+0xfed>
42011b05:	b0e6e0        	addx8	a14, a6, a14
42011b08:	0e68      	l32i.n	a6, a14, 0
42011b0a:	000706        	j	42011b2a <_vfiprintf_r+0x100a>
42011b0d:	30a282        	movi	a8, 0x230
42011b10:	8e8a      	add.n	a8, a14, a8
42011b12:	34a2d2        	movi	a13, 0x234
42011b15:	40a2c2        	movi	a12, 0x240
42011b18:	06ad      	mov.n	a10, a6
42011b1a:	0189      	s32i.n	a8, a1, 0
42011b1c:	01def2        	addmi	a15, a14, 0x100
42011b1f:	deda      	add.n	a13, a14, a13
42011b21:	ceca      	add.n	a12, a14, a12
42011b23:	07bd      	mov.n	a11, a7
42011b25:	feb065        	call8	4201062c <get_arg$isra$0>
42011b28:	0a68      	l32i.n	a6, a10, 0
42011b2a:	057d      	mov.n	a7, a5
42011b2c:	001cc6        	j	42011ba3 <_vfiprintf_r+0x1083>
42011b2f:	751b00        	extui	a1, a0, 27, 8
42011b32:	07a587        	bge	a5, a8, 42011b3d <_vfiprintf_r+0x101d>
42011b35:	b0e6e0        	addx8	a14, a6, a14
42011b38:	0e68      	l32i.n	a6, a14, 0
42011b3a:	001946        	j	42011ba3 <_vfiprintf_r+0x1083>
42011b3d:	922e92        	l32i	a9, a14, 0x248
42011b40:	fb1c      	movi.n	a11, 31
42011b42:	02dee2        	addmi	a14, a14, 0x200
42011b45:	a94b      	addi.n	a10, a9, 4
42011b47:	322b87        	blt	a11, a8, 42011b7d <_vfiprintf_r+0x105d>
42011b4a:	b81b      	addi.n	a11, a8, 1
42011b4c:	9161b2        	s32i	a11, a1, 0x244
42011b4f:	126ea2        	s32i	a10, a14, 72
42011b52:	8b1c      	movi.n	a11, 24
42011b54:	052ba7        	blt	a11, a10, 42011b5d <_vfiprintf_r+0x103d>
42011b57:	112e92        	l32i	a9, a14, 68
42011b5a:	000406        	j	42011b6e <_vfiprintf_r+0x104e>
42011b5d:	012b97        	blt	a11, a9, 42011b62 <_vfiprintf_r+0x1042>
42011b60:	4a2c      	movi.n	a10, 36
42011b62:	10c192        	addi	a9, a1, 16
42011b65:	02d992        	addmi	a9, a9, 0x200
42011b68:	102992        	l32i	a9, a9, 64
42011b6b:	9661a2        	s32i	a10, a1, 0x258
42011b6e:	99aa      	add.n	a9, a9, a10
42011b70:	fcc992        	addi	a9, a9, -4
42011b73:	0968      	l32i.n	a6, a9, 0
42011b75:	b08810        	addx8	a8, a8, a1
42011b78:	4869      	s32i.n	a6, a8, 16
42011b7a:	000946        	j	42011ba3 <_vfiprintf_r+0x1083>
42011b7d:	126ea2        	s32i	a10, a14, 72
42011b80:	881c      	movi.n	a8, 24
42011b82:	0528a7        	blt	a8, a10, 42011b8b <_vfiprintf_r+0x106b>
42011b85:	112e82        	l32i	a8, a14, 68
42011b88:	000406        	j	42011b9c <_vfiprintf_r+0x107c>
42011b8b:	012897        	blt	a8, a9, 42011b90 <_vfiprintf_r+0x1070>
42011b8e:	4a2c      	movi.n	a10, 36
42011b90:	10c182        	addi	a8, a1, 16
42011b93:	02d882        	addmi	a8, a8, 0x200
42011b96:	102882        	l32i	a8, a8, 64
42011b99:	9661a2        	s32i	a10, a1, 0x258
42011b9c:	88aa      	add.n	a8, a8, a10
42011b9e:	fcc882        	addi	a8, a8, -4
42011ba1:	0868      	l32i.n	a6, a8, 0
42011ba3:	10c182        	addi	a8, a1, 16
42011ba6:	02d882        	addmi	a8, a8, 0x200
42011ba9:	090c      	movi.n	a9, 0
42011bab:	3a4892        	s8i	a9, a8, 58
42011bae:	9a2182        	l32i	a8, a1, 0x268
42011bb1:	017896        	bltz	a8, 42011bcc <_vfiprintf_r+0x10ac>
42011bb4:	08cd      	mov.n	a12, a8
42011bb6:	0b0c      	movi.n	a11, 0
42011bb8:	06ad      	mov.n	a10, a6
42011bba:	bcad81        	l32r	a8, 42000e70 <_stext+0xe50> (40001344 <memchr>)
42011bbd:	0008e0        	callx8	a8
42011bc0:	050c      	movi.n	a5, 0
42011bc2:	c08a60        	sub	a8, a10, a6
42011bc5:	7b8a56        	bnez	a10, 42012381 <_vfiprintf_r+0x1861>
42011bc8:	01f8c6        	j	420123af <_vfiprintf_r+0x188f>
42011bcb:	06ad00        	ee.ldf.64.xp	f10, f0, a0, a13
42011bce:	b9c581        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
42011bd1:	0008e0        	callx8	a8
42011bd4:	9a61a2        	s32i	a10, a1, 0x268
42011bd7:	050c      	movi.n	a5, 0
42011bd9:	01f486        	j	420123af <_vfiprintf_r+0x188f>
42011bdc:	081c00        	lsx	f1, a12, a0
42011bdf:	203380        	or	a3, a3, a8
42011be2:	912182        	l32i	a8, a1, 0x244
42011be5:	10c1e2        	addi	a14, a1, 16
42011be8:	02e357        	bbsi	a3, 5, 42011bee <_vfiprintf_r+0x10ce>
42011beb:	002f86        	j	42011cad <_vfiprintf_r+0x118d>
42011bee:	f4ac      	beqz.n	a4, 42011c21 <_vfiprintf_r+0x1101>
42011bf0:	09a687        	bge	a6, a8, 42011bfd <_vfiprintf_r+0x10dd>
42011bf3:	b0e6e0        	addx8	a14, a6, a14
42011bf6:	0e48      	l32i.n	a4, a14, 0
42011bf8:	1e28      	l32i.n	a2, a14, 4
42011bfa:	000786        	j	42011c1c <_vfiprintf_r+0x10fc>
42011bfd:	30a282        	movi	a8, 0x230
42011c00:	8e8a      	add.n	a8, a14, a8
42011c02:	34a2d2        	movi	a13, 0x234
42011c05:	40a2c2        	movi	a12, 0x240
42011c08:	0189      	s32i.n	a8, a1, 0
42011c0a:	01def2        	addmi	a15, a14, 0x100
42011c0d:	deda      	add.n	a13, a14, a13
42011c0f:	ceca      	add.n	a12, a14, a12
42011c11:	07bd      	mov.n	a11, a7
42011c13:	06ad      	mov.n	a10, a6
42011c15:	fea165        	call8	4201062c <get_arg$isra$0>
42011c18:	0a48      	l32i.n	a4, a10, 0
42011c1a:	1a28      	l32i.n	a2, a10, 4
42011c1c:	057d      	mov.n	a7, a5
42011c1e:	007d86        	j	42011e18 <_vfiprintf_r+0x12f8>
42011c21:	751b      	addi.n	a7, a5, 1
42011c23:	09a587        	bge	a5, a8, 42011c30 <_vfiprintf_r+0x1110>
42011c26:	b0e6e0        	addx8	a14, a6, a14
42011c29:	0e48      	l32i.n	a4, a14, 0
42011c2b:	1e28      	l32i.n	a2, a14, 4
42011c2d:	0079c6        	j	42011e18 <_vfiprintf_r+0x12f8>
42011c30:	922e92        	l32i	a9, a14, 0x248
42011c33:	8a7c      	movi.n	a10, -8
42011c35:	997b      	addi.n	a9, a9, 7
42011c37:	1099a0        	and	a9, a9, a10
42011c3a:	fb1c      	movi.n	a11, 31
42011c3c:	02dee2        	addmi	a14, a14, 0x200
42011c3f:	a98b      	addi.n	a10, a9, 8
42011c41:	3b2b87        	blt	a11, a8, 42011c80 <_vfiprintf_r+0x1160>
42011c44:	b81b      	addi.n	a11, a8, 1
42011c46:	9161b2        	s32i	a11, a1, 0x244
42011c49:	126ea2        	s32i	a10, a14, 72
42011c4c:	8b1c      	movi.n	a11, 24
42011c4e:	062ba7        	blt	a11, a10, 42011c58 <_vfiprintf_r+0x1138>
42011c51:	112e92        	l32i	a9, a14, 68
42011c54:	000446        	j	42011c69 <_vfiprintf_r+0x1149>
42011c57:	2b9700        	oeq.s	b9, f7, f0
42011c5a:	8a2c01        	l32r	a0, 41ff450c <_iram_bss_end+0x1c7210c>
42011c5d:	10c192        	addi	a9, a1, 16
42011c60:	02d992        	addmi	a9, a9, 0x200
42011c63:	102992        	l32i	a9, a9, 64
42011c66:	9661a2        	s32i	a10, a1, 0x258
42011c69:	99aa      	add.n	a9, a9, a10
42011c6b:	f8c992        	addi	a9, a9, -8
42011c6e:	0948      	l32i.n	a4, a9, 0
42011c70:	1928      	l32i.n	a2, a9, 4
42011c72:	10c192        	addi	a9, a1, 16
42011c75:	b08890        	addx8	a8, a8, a9
42011c78:	0849      	s32i.n	a4, a8, 0
42011c7a:	1829      	s32i.n	a2, a8, 4
42011c7c:	006606        	j	42011e18 <_vfiprintf_r+0x12f8>
42011c7f:	00          	.byte	00
42011c80:	126ea2        	s32i	a10, a14, 72
42011c83:	881c      	movi.n	a8, 24
42011c85:	0728a7        	blt	a8, a10, 42011c90 <_vfiprintf_r+0x1170>
42011c88:	112e82        	l32i	a8, a14, 68
42011c8b:	000486        	j	42011ca1 <_vfiprintf_r+0x1181>
42011c8e:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42011c91:	0128      	l32i.n	a2, a1, 0
42011c93:	8a2c      	movi.n	a10, 40
42011c95:	10c182        	addi	a8, a1, 16
42011c98:	02d882        	addmi	a8, a8, 0x200
42011c9b:	102882        	l32i	a8, a8, 64
42011c9e:	9661a2        	s32i	a10, a1, 0x258
42011ca1:	88aa      	add.n	a8, a8, a10
42011ca3:	f8c882        	addi	a8, a8, -8
42011ca6:	0848      	l32i.n	a4, a8, 0
42011ca8:	1828      	l32i.n	a2, a8, 4
42011caa:	005a86        	j	42011e18 <_vfiprintf_r+0x12f8>
42011cad:	036347        	bbci	a3, 4, 42011cb4 <_vfiprintf_r+0x1194>
42011cb0:	005a46        	j	42011e1d <_vfiprintf_r+0x12fd>
42011cb3:	00          	.byte	00
42011cb4:	02e367        	bbsi	a3, 6, 42011cba <_vfiprintf_r+0x119a>
42011cb7:	002b46        	j	42011d68 <_vfiprintf_r+0x1248>
42011cba:	c4ac      	beqz.n	a4, 42011cea <_vfiprintf_r+0x11ca>
42011cbc:	08a687        	bge	a6, a8, 42011cc8 <_vfiprintf_r+0x11a8>
42011cbf:	b0e6e0        	addx8	a14, a6, a14
42011cc2:	001e42        	l16ui	a4, a14, 0
42011cc5:	006046        	j	42011e4a <_vfiprintf_r+0x132a>
42011cc8:	30a282        	movi	a8, 0x230
42011ccb:	8e8a      	add.n	a8, a14, a8
42011ccd:	34a2d2        	movi	a13, 0x234
42011cd0:	40a2c2        	movi	a12, 0x240
42011cd3:	0189      	s32i.n	a8, a1, 0
42011cd5:	01def2        	addmi	a15, a14, 0x100
42011cd8:	deda      	add.n	a13, a14, a13
42011cda:	ceca      	add.n	a12, a14, a12
42011cdc:	07bd      	mov.n	a11, a7
42011cde:	20a660        	or	a10, a6, a6
42011ce1:	fe94a5        	call8	4201062c <get_arg$isra$0>
42011ce4:	001a42        	l16ui	a4, a10, 0
42011ce7:	0057c6        	j	42011e4a <_vfiprintf_r+0x132a>
42011cea:	751b      	addi.n	a7, a5, 1
42011cec:	08a587        	bge	a5, a8, 42011cf8 <_vfiprintf_r+0x11d8>
42011cef:	b0e6e0        	addx8	a14, a6, a14
42011cf2:	001e42        	l16ui	a4, a14, 0
42011cf5:	004746        	j	42011e16 <_vfiprintf_r+0x12f6>
42011cf8:	922e92        	l32i	a9, a14, 0x248
42011cfb:	fb1c      	movi.n	a11, 31
42011cfd:	02dee2        	addmi	a14, a14, 0x200
42011d00:	a94b      	addi.n	a10, a9, 4
42011d02:	362b87        	blt	a11, a8, 42011d3c <_vfiprintf_r+0x121c>
42011d05:	b81b      	addi.n	a11, a8, 1
42011d07:	9161b2        	s32i	a11, a1, 0x244
42011d0a:	126ea2        	s32i	a10, a14, 72
42011d0d:	8b1c      	movi.n	a11, 24
42011d0f:	052ba7        	blt	a11, a10, 42011d18 <_vfiprintf_r+0x11f8>
42011d12:	112e92        	l32i	a9, a14, 68
42011d15:	000406        	j	42011d29 <_vfiprintf_r+0x1209>
42011d18:	012b97        	blt	a11, a9, 42011d1d <_vfiprintf_r+0x11fd>
42011d1b:	4a2c      	movi.n	a10, 36
42011d1d:	10c192        	addi	a9, a1, 16
42011d20:	02d992        	addmi	a9, a9, 0x200
42011d23:	102992        	l32i	a9, a9, 64
42011d26:	9661a2        	s32i	a10, a1, 0x258
42011d29:	99aa      	add.n	a9, a9, a10
42011d2b:	fcc992        	addi	a9, a9, -4
42011d2e:	0948      	l32i.n	a4, a9, 0
42011d30:	b08810        	addx8	a8, a8, a1
42011d33:	4849      	s32i.n	a4, a8, 16
42011d35:	f44040        	extui	a4, a4, 0, 16
42011d38:	003686        	j	42011e16 <_vfiprintf_r+0x12f6>
42011d3b:	00          	.byte	00
42011d3c:	126ea2        	s32i	a10, a14, 72
42011d3f:	881c      	movi.n	a8, 24
42011d41:	0728a7        	blt	a8, a10, 42011d4c <_vfiprintf_r+0x122c>
42011d44:	112e82        	l32i	a8, a14, 68
42011d47:	000486        	j	42011d5d <_vfiprintf_r+0x123d>
42011d4a:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42011d4d:	0128      	l32i.n	a2, a1, 0
42011d4f:	4a2c      	movi.n	a10, 36
42011d51:	10c182        	addi	a8, a1, 16
42011d54:	02d882        	addmi	a8, a8, 0x200
42011d57:	102882        	l32i	a8, a8, 64
42011d5a:	9661a2        	s32i	a10, a1, 0x258
42011d5d:	88aa      	add.n	a8, a8, a10
42011d5f:	fcc882        	addi	a8, a8, -4
42011d62:	001842        	l16ui	a4, a8, 0
42011d65:	002b46        	j	42011e16 <_vfiprintf_r+0x12f6>
42011d68:	02e397        	bbsi	a3, 9, 42011d6e <_vfiprintf_r+0x124e>
42011d6b:	002b86        	j	42011e1d <_vfiprintf_r+0x12fd>
42011d6e:	c4ac      	beqz.n	a4, 42011d9e <_vfiprintf_r+0x127e>
42011d70:	09a687        	bge	a6, a8, 42011d7d <_vfiprintf_r+0x125d>
42011d73:	b0e6e0        	addx8	a14, a6, a14
42011d76:	000e42        	l8ui	a4, a14, 0
42011d79:	003346        	j	42011e4a <_vfiprintf_r+0x132a>
42011d7c:	a28200        	muluh	a8, a2, a0
42011d7f:	30          	.byte	0x30
42011d80:	8e8a      	add.n	a8, a14, a8
42011d82:	34a2d2        	movi	a13, 0x234
42011d85:	40a2c2        	movi	a12, 0x240
42011d88:	0189      	s32i.n	a8, a1, 0
42011d8a:	01def2        	addmi	a15, a14, 0x100
42011d8d:	deda      	add.n	a13, a14, a13
42011d8f:	ceca      	add.n	a12, a14, a12
42011d91:	07bd      	mov.n	a11, a7
42011d93:	06ad      	mov.n	a10, a6
42011d95:	fe8965        	call8	4201062c <get_arg$isra$0>
42011d98:	000a42        	l8ui	a4, a10, 0
42011d9b:	002ac6        	j	42011e4a <_vfiprintf_r+0x132a>
42011d9e:	751b      	addi.n	a7, a5, 1
42011da0:	08a587        	bge	a5, a8, 42011dac <_vfiprintf_r+0x128c>
42011da3:	b0e6e0        	addx8	a14, a6, a14
42011da6:	000e42        	l8ui	a4, a14, 0
42011da9:	001a46        	j	42011e16 <_vfiprintf_r+0x12f6>
42011dac:	922e92        	l32i	a9, a14, 0x248
42011daf:	fb1c      	movi.n	a11, 31
42011db1:	02dee2        	addmi	a14, a14, 0x200
42011db4:	a94b      	addi.n	a10, a9, 4
42011db6:	352b87        	blt	a11, a8, 42011def <_vfiprintf_r+0x12cf>
42011db9:	b81b      	addi.n	a11, a8, 1
42011dbb:	9161b2        	s32i	a11, a1, 0x244
42011dbe:	126ea2        	s32i	a10, a14, 72
42011dc1:	8b1c      	movi.n	a11, 24
42011dc3:	052ba7        	blt	a11, a10, 42011dcc <_vfiprintf_r+0x12ac>
42011dc6:	112e92        	l32i	a9, a14, 68
42011dc9:	000406        	j	42011ddd <_vfiprintf_r+0x12bd>
42011dcc:	012b97        	blt	a11, a9, 42011dd1 <_vfiprintf_r+0x12b1>
42011dcf:	4a2c      	movi.n	a10, 36
42011dd1:	10c192        	addi	a9, a1, 16
42011dd4:	02d992        	addmi	a9, a9, 0x200
42011dd7:	102992        	l32i	a9, a9, 64
42011dda:	9661a2        	s32i	a10, a1, 0x258
42011ddd:	99aa      	add.n	a9, a9, a10
42011ddf:	fcc992        	addi	a9, a9, -4
42011de2:	0948      	l32i.n	a4, a9, 0
42011de4:	b08810        	addx8	a8, a8, a1
42011de7:	4849      	s32i.n	a4, a8, 16
42011de9:	744040        	extui	a4, a4, 0, 8
42011dec:	000986        	j	42011e16 <_vfiprintf_r+0x12f6>
42011def:	126ea2        	s32i	a10, a14, 72
42011df2:	881c      	movi.n	a8, 24
42011df4:	0528a7        	blt	a8, a10, 42011dfd <_vfiprintf_r+0x12dd>
42011df7:	112e82        	l32i	a8, a14, 68
42011dfa:	000406        	j	42011e0e <_vfiprintf_r+0x12ee>
42011dfd:	012897        	blt	a8, a9, 42011e02 <_vfiprintf_r+0x12e2>
42011e00:	4a2c      	movi.n	a10, 36
42011e02:	10c182        	addi	a8, a1, 16
42011e05:	02d882        	addmi	a8, a8, 0x200
42011e08:	102882        	l32i	a8, a8, 64
42011e0b:	9661a2        	s32i	a10, a1, 0x258
42011e0e:	88aa      	add.n	a8, a8, a10
42011e10:	fcc882        	addi	a8, a8, -4
42011e13:	000842        	l8ui	a4, a8, 0
42011e16:	020c      	movi.n	a2, 0
42011e18:	180c      	movi.n	a8, 1
42011e1a:	00f1c6        	j	420121e5 <_vfiprintf_r+0x16c5>
42011e1d:	f4ac      	beqz.n	a4, 42011e50 <_vfiprintf_r+0x1330>
42011e1f:	0aa687        	bge	a6, a8, 42011e2d <_vfiprintf_r+0x130d>
42011e22:	b0e6e0        	addx8	a14, a6, a14
42011e25:	0e48      	l32i.n	a4, a14, 0
42011e27:	0007c6        	j	42011e4a <_vfiprintf_r+0x132a>
42011e2a:	000000        	ill
42011e2d:	30a282        	movi	a8, 0x230
42011e30:	8e8a      	add.n	a8, a14, a8
42011e32:	34a2d2        	movi	a13, 0x234
42011e35:	40a2c2        	movi	a12, 0x240
42011e38:	0189      	s32i.n	a8, a1, 0
42011e3a:	01def2        	addmi	a15, a14, 0x100
42011e3d:	deda      	add.n	a13, a14, a13
42011e3f:	ceca      	add.n	a12, a14, a12
42011e41:	07bd      	mov.n	a11, a7
42011e43:	06ad      	mov.n	a10, a6
42011e45:	fe7e65        	call8	4201062c <get_arg$isra$0>
42011e48:	0a48      	l32i.n	a4, a10, 0
42011e4a:	057d      	mov.n	a7, a5
42011e4c:	fff186        	j	42011e16 <_vfiprintf_r+0x12f6>
42011e4f:	751b00        	extui	a1, a0, 27, 8
42011e52:	07a587        	bge	a5, a8, 42011e5d <_vfiprintf_r+0x133d>
42011e55:	b0e6e0        	addx8	a14, a6, a14
42011e58:	0e48      	l32i.n	a4, a14, 0
42011e5a:	ffee06        	j	42011e16 <_vfiprintf_r+0x12f6>
42011e5d:	922e92        	l32i	a9, a14, 0x248
42011e60:	fb1c      	movi.n	a11, 31
42011e62:	02dee2        	addmi	a14, a14, 0x200
42011e65:	a94b      	addi.n	a10, a9, 4
42011e67:	322b87        	blt	a11, a8, 42011e9d <_vfiprintf_r+0x137d>
42011e6a:	b81b      	addi.n	a11, a8, 1
42011e6c:	9161b2        	s32i	a11, a1, 0x244
42011e6f:	126ea2        	s32i	a10, a14, 72
42011e72:	8b1c      	movi.n	a11, 24
42011e74:	052ba7        	blt	a11, a10, 42011e7d <_vfiprintf_r+0x135d>
42011e77:	112e92        	l32i	a9, a14, 68
42011e7a:	000406        	j	42011e8e <_vfiprintf_r+0x136e>
42011e7d:	012b97        	blt	a11, a9, 42011e82 <_vfiprintf_r+0x1362>
42011e80:	4a2c      	movi.n	a10, 36
42011e82:	10c192        	addi	a9, a1, 16
42011e85:	02d992        	addmi	a9, a9, 0x200
42011e88:	102992        	l32i	a9, a9, 64
42011e8b:	9661a2        	s32i	a10, a1, 0x258
42011e8e:	99aa      	add.n	a9, a9, a10
42011e90:	fcc992        	addi	a9, a9, -4
42011e93:	0948      	l32i.n	a4, a9, 0
42011e95:	b08810        	addx8	a8, a8, a1
42011e98:	4849      	s32i.n	a4, a8, 16
42011e9a:	ffde06        	j	42011e16 <_vfiprintf_r+0x12f6>
42011e9d:	126ea2        	s32i	a10, a14, 72
42011ea0:	881c      	movi.n	a8, 24
42011ea2:	0628a7        	blt	a8, a10, 42011eac <_vfiprintf_r+0x138c>
42011ea5:	112e82        	l32i	a8, a14, 68
42011ea8:	000446        	j	42011ebd <_vfiprintf_r+0x139d>
42011eab:	00          	.byte	00
42011eac:	012897        	blt	a8, a9, 42011eb1 <_vfiprintf_r+0x1391>
42011eaf:	4a2c      	movi.n	a10, 36
42011eb1:	10c182        	addi	a8, a1, 16
42011eb4:	02d882        	addmi	a8, a8, 0x200
42011eb7:	102882        	l32i	a8, a8, 64
42011eba:	9661a2        	s32i	a10, a1, 0x258
42011ebd:	88aa      	add.n	a8, a8, a10
42011ebf:	fcc882        	addi	a8, a8, -4
42011ec2:	0848      	l32i.n	a4, a8, 0
42011ec4:	ffd386        	j	42011e16 <_vfiprintf_r+0x12f6>
42011ec7:	00          	.byte	00
42011ec8:	bc0e81        	l32r	a8, 42000f00 <_stext+0xee0> (3c028705 <blanks$1+0x31>)
42011ecb:	a16182        	s32i	a8, a1, 0x284
42011ece:	10c1e2        	addi	a14, a1, 16
42011ed1:	912182        	l32i	a8, a1, 0x244
42011ed4:	02e357        	bbsi	a3, 5, 42011eda <_vfiprintf_r+0x13ba>
42011ed7:	002f86        	j	42011f99 <_vfiprintf_r+0x1479>
42011eda:	f4ac      	beqz.n	a4, 42011f0d <_vfiprintf_r+0x13ed>
42011edc:	09a687        	bge	a6, a8, 42011ee9 <_vfiprintf_r+0x13c9>
42011edf:	b0e6e0        	addx8	a14, a6, a14
42011ee2:	0e48      	l32i.n	a4, a14, 0
42011ee4:	1e28      	l32i.n	a2, a14, 4
42011ee6:	000786        	j	42011f08 <_vfiprintf_r+0x13e8>
42011ee9:	30a282        	movi	a8, 0x230
42011eec:	8e8a      	add.n	a8, a14, a8
42011eee:	34a2d2        	movi	a13, 0x234
42011ef1:	40a2c2        	movi	a12, 0x240
42011ef4:	0189      	s32i.n	a8, a1, 0
42011ef6:	01def2        	addmi	a15, a14, 0x100
42011ef9:	deda      	add.n	a13, a14, a13
42011efb:	ceca      	add.n	a12, a14, a12
42011efd:	07bd      	mov.n	a11, a7
42011eff:	06ad      	mov.n	a10, a6
42011f01:	fe72a5        	call8	4201062c <get_arg$isra$0>
42011f04:	0a48      	l32i.n	a4, a10, 0
42011f06:	1a28      	l32i.n	a2, a10, 4
42011f08:	057d      	mov.n	a7, a5
42011f0a:	00ac06        	j	420121be <_vfiprintf_r+0x169e>
42011f0d:	751b      	addi.n	a7, a5, 1
42011f0f:	09a587        	bge	a5, a8, 42011f1c <_vfiprintf_r+0x13fc>
42011f12:	b0e6e0        	addx8	a14, a6, a14
42011f15:	0e48      	l32i.n	a4, a14, 0
42011f17:	1e28      	l32i.n	a2, a14, 4
42011f19:	00a846        	j	420121be <_vfiprintf_r+0x169e>
42011f1c:	922e92        	l32i	a9, a14, 0x248
42011f1f:	8a7c      	movi.n	a10, -8
42011f21:	997b      	addi.n	a9, a9, 7
42011f23:	1099a0        	and	a9, a9, a10
42011f26:	fb1c      	movi.n	a11, 31
42011f28:	02dee2        	addmi	a14, a14, 0x200
42011f2b:	a98b      	addi.n	a10, a9, 8
42011f2d:	3b2b87        	blt	a11, a8, 42011f6c <_vfiprintf_r+0x144c>
42011f30:	b81b      	addi.n	a11, a8, 1
42011f32:	9161b2        	s32i	a11, a1, 0x244
42011f35:	126ea2        	s32i	a10, a14, 72
42011f38:	8b1c      	movi.n	a11, 24
42011f3a:	062ba7        	blt	a11, a10, 42011f44 <_vfiprintf_r+0x1424>
42011f3d:	112e92        	l32i	a9, a14, 68
42011f40:	000446        	j	42011f55 <_vfiprintf_r+0x1435>
42011f43:	2b9700        	oeq.s	b9, f7, f0
42011f46:	8a2c01        	l32r	a0, 41ff47f8 <_iram_bss_end+0x1c723f8>
42011f49:	10c192        	addi	a9, a1, 16
42011f4c:	02d992        	addmi	a9, a9, 0x200
42011f4f:	102992        	l32i	a9, a9, 64
42011f52:	9661a2        	s32i	a10, a1, 0x258
42011f55:	99aa      	add.n	a9, a9, a10
42011f57:	f8c992        	addi	a9, a9, -8
42011f5a:	0948      	l32i.n	a4, a9, 0
42011f5c:	1928      	l32i.n	a2, a9, 4
42011f5e:	10c192        	addi	a9, a1, 16
42011f61:	b08890        	addx8	a8, a8, a9
42011f64:	0849      	s32i.n	a4, a8, 0
42011f66:	1829      	s32i.n	a2, a8, 4
42011f68:	009486        	j	420121be <_vfiprintf_r+0x169e>
42011f6b:	00          	.byte	00
42011f6c:	126ea2        	s32i	a10, a14, 72
42011f6f:	881c      	movi.n	a8, 24
42011f71:	0728a7        	blt	a8, a10, 42011f7c <_vfiprintf_r+0x145c>
42011f74:	112e82        	l32i	a8, a14, 68
42011f77:	000486        	j	42011f8d <_vfiprintf_r+0x146d>
42011f7a:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42011f7d:	0128      	l32i.n	a2, a1, 0
42011f7f:	8a2c      	movi.n	a10, 40
42011f81:	10c182        	addi	a8, a1, 16
42011f84:	02d882        	addmi	a8, a8, 0x200
42011f87:	102882        	l32i	a8, a8, 64
42011f8a:	9661a2        	s32i	a10, a1, 0x258
42011f8d:	88aa      	add.n	a8, a8, a10
42011f8f:	f8c882        	addi	a8, a8, -8
42011f92:	0848      	l32i.n	a4, a8, 0
42011f94:	1828      	l32i.n	a2, a8, 4
42011f96:	008906        	j	420121be <_vfiprintf_r+0x169e>
42011f99:	146347        	bbci	a3, 4, 42011fb1 <_vfiprintf_r+0x1491>
42011f9c:	148c      	beqz.n	a4, 42011fa1 <_vfiprintf_r+0x1481>
42011f9e:	005e06        	j	4201211a <_vfiprintf_r+0x15fa>
42011fa1:	751b      	addi.n	a7, a5, 1
42011fa3:	022587        	blt	a5, a8, 42011fa9 <_vfiprintf_r+0x1489>
42011fa6:	006ac6        	j	42012155 <_vfiprintf_r+0x1635>
42011fa9:	b0e6e0        	addx8	a14, a6, a14
42011fac:	0e48      	l32i.n	a4, a14, 0
42011fae:	008286        	j	420121bc <_vfiprintf_r+0x169c>
42011fb1:	02e367        	bbsi	a3, 6, 42011fb7 <_vfiprintf_r+0x1497>
42011fb4:	002b06        	j	42012064 <_vfiprintf_r+0x1544>
42011fb7:	b4ac      	beqz.n	a4, 42011fe6 <_vfiprintf_r+0x14c6>
42011fb9:	08a687        	bge	a6, a8, 42011fc5 <_vfiprintf_r+0x14a5>
42011fbc:	b0e6e0        	addx8	a14, a6, a14
42011fbf:	001e42        	l16ui	a4, a14, 0
42011fc2:	005f06        	j	42012142 <_vfiprintf_r+0x1622>
42011fc5:	30a282        	movi	a8, 0x230
42011fc8:	8e8a      	add.n	a8, a14, a8
42011fca:	34a2d2        	movi	a13, 0x234
42011fcd:	40a2c2        	movi	a12, 0x240
42011fd0:	0189      	s32i.n	a8, a1, 0
42011fd2:	01def2        	addmi	a15, a14, 0x100
42011fd5:	deda      	add.n	a13, a14, a13
42011fd7:	ceca      	add.n	a12, a14, a12
42011fd9:	07bd      	mov.n	a11, a7
42011fdb:	06ad      	mov.n	a10, a6
42011fdd:	fe64e5        	call8	4201062c <get_arg$isra$0>
42011fe0:	001a42        	l16ui	a4, a10, 0
42011fe3:	0056c6        	j	42012142 <_vfiprintf_r+0x1622>
42011fe6:	751b      	addi.n	a7, a5, 1
42011fe8:	08a587        	bge	a5, a8, 42011ff4 <_vfiprintf_r+0x14d4>
42011feb:	b0e6e0        	addx8	a14, a6, a14
42011fee:	001e42        	l16ui	a4, a14, 0
42011ff1:	0071c6        	j	420121bc <_vfiprintf_r+0x169c>
42011ff4:	922e92        	l32i	a9, a14, 0x248
42011ff7:	fb1c      	movi.n	a11, 31
42011ff9:	02dee2        	addmi	a14, a14, 0x200
42011ffc:	a94b      	addi.n	a10, a9, 4
42011ffe:	362b87        	blt	a11, a8, 42012038 <_vfiprintf_r+0x1518>
42012001:	b81b      	addi.n	a11, a8, 1
42012003:	9161b2        	s32i	a11, a1, 0x244
42012006:	126ea2        	s32i	a10, a14, 72
42012009:	8b1c      	movi.n	a11, 24
4201200b:	052ba7        	blt	a11, a10, 42012014 <_vfiprintf_r+0x14f4>
4201200e:	112e92        	l32i	a9, a14, 68
42012011:	000406        	j	42012025 <_vfiprintf_r+0x1505>
42012014:	012b97        	blt	a11, a9, 42012019 <_vfiprintf_r+0x14f9>
42012017:	4a2c      	movi.n	a10, 36
42012019:	10c192        	addi	a9, a1, 16
4201201c:	02d992        	addmi	a9, a9, 0x200
4201201f:	102992        	l32i	a9, a9, 64
42012022:	9661a2        	s32i	a10, a1, 0x258
42012025:	99aa      	add.n	a9, a9, a10
42012027:	fcc992        	addi	a9, a9, -4
4201202a:	0948      	l32i.n	a4, a9, 0
4201202c:	b08810        	addx8	a8, a8, a1
4201202f:	4849      	s32i.n	a4, a8, 16
42012031:	f44040        	extui	a4, a4, 0, 16
42012034:	006106        	j	420121bc <_vfiprintf_r+0x169c>
42012037:	00          	.byte	00
42012038:	126ea2        	s32i	a10, a14, 72
4201203b:	881c      	movi.n	a8, 24
4201203d:	0728a7        	blt	a8, a10, 42012048 <_vfiprintf_r+0x1528>
42012040:	112e82        	l32i	a8, a14, 68
42012043:	000486        	j	42012059 <_vfiprintf_r+0x1539>
42012046:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42012049:	0128      	l32i.n	a2, a1, 0
4201204b:	4a2c      	movi.n	a10, 36
4201204d:	10c182        	addi	a8, a1, 16
42012050:	02d882        	addmi	a8, a8, 0x200
42012053:	102882        	l32i	a8, a8, 64
42012056:	9661a2        	s32i	a10, a1, 0x258
42012059:	88aa      	add.n	a8, a8, a10
4201205b:	fcc882        	addi	a8, a8, -4
4201205e:	001842        	l16ui	a4, a8, 0
42012061:	0055c6        	j	420121bc <_vfiprintf_r+0x169c>
42012064:	02e397        	bbsi	a3, 9, 4201206a <_vfiprintf_r+0x154a>
42012067:	002b46        	j	42012118 <_vfiprintf_r+0x15f8>
4201206a:	c4ac      	beqz.n	a4, 4201209a <_vfiprintf_r+0x157a>
4201206c:	09a687        	bge	a6, a8, 42012079 <_vfiprintf_r+0x1559>
4201206f:	b0e6e0        	addx8	a14, a6, a14
42012072:	000e42        	l8ui	a4, a14, 0
42012075:	003246        	j	42012142 <_vfiprintf_r+0x1622>
42012078:	a28200        	muluh	a8, a2, a0
4201207b:	30          	.byte	0x30
4201207c:	8e8a      	add.n	a8, a14, a8
4201207e:	34a2d2        	movi	a13, 0x234
42012081:	40a2c2        	movi	a12, 0x240
42012084:	0189      	s32i.n	a8, a1, 0
42012086:	01def2        	addmi	a15, a14, 0x100
42012089:	deda      	add.n	a13, a14, a13
4201208b:	ceca      	add.n	a12, a14, a12
4201208d:	07bd      	mov.n	a11, a7
4201208f:	06ad      	mov.n	a10, a6
42012091:	fe59a5        	call8	4201062c <get_arg$isra$0>
42012094:	000a42        	l8ui	a4, a10, 0
42012097:	0029c6        	j	42012142 <_vfiprintf_r+0x1622>
4201209a:	751b      	addi.n	a7, a5, 1
4201209c:	08a587        	bge	a5, a8, 420120a8 <_vfiprintf_r+0x1588>
4201209f:	b0e6e0        	addx8	a14, a6, a14
420120a2:	000e42        	l8ui	a4, a14, 0
420120a5:	0044c6        	j	420121bc <_vfiprintf_r+0x169c>
420120a8:	922e92        	l32i	a9, a14, 0x248
420120ab:	fb1c      	movi.n	a11, 31
420120ad:	02dee2        	addmi	a14, a14, 0x200
420120b0:	a94b      	addi.n	a10, a9, 4
420120b2:	362b87        	blt	a11, a8, 420120ec <_vfiprintf_r+0x15cc>
420120b5:	b81b      	addi.n	a11, a8, 1
420120b7:	9161b2        	s32i	a11, a1, 0x244
420120ba:	126ea2        	s32i	a10, a14, 72
420120bd:	8b1c      	movi.n	a11, 24
420120bf:	052ba7        	blt	a11, a10, 420120c8 <_vfiprintf_r+0x15a8>
420120c2:	112e92        	l32i	a9, a14, 68
420120c5:	000406        	j	420120d9 <_vfiprintf_r+0x15b9>
420120c8:	012b97        	blt	a11, a9, 420120cd <_vfiprintf_r+0x15ad>
420120cb:	4a2c      	movi.n	a10, 36
420120cd:	10c192        	addi	a9, a1, 16
420120d0:	02d992        	addmi	a9, a9, 0x200
420120d3:	102992        	l32i	a9, a9, 64
420120d6:	9661a2        	s32i	a10, a1, 0x258
420120d9:	99aa      	add.n	a9, a9, a10
420120db:	fcc992        	addi	a9, a9, -4
420120de:	0948      	l32i.n	a4, a9, 0
420120e0:	b08810        	addx8	a8, a8, a1
420120e3:	4849      	s32i.n	a4, a8, 16
420120e5:	744040        	extui	a4, a4, 0, 8
420120e8:	003406        	j	420121bc <_vfiprintf_r+0x169c>
420120eb:	00          	.byte	00
420120ec:	126ea2        	s32i	a10, a14, 72
420120ef:	881c      	movi.n	a8, 24
420120f1:	0728a7        	blt	a8, a10, 420120fc <_vfiprintf_r+0x15dc>
420120f4:	112e82        	l32i	a8, a14, 68
420120f7:	000486        	j	4201210d <_vfiprintf_r+0x15ed>
420120fa:	970000        	ee.stf.64.xp	f0, f9, a0, a0
420120fd:	0128      	l32i.n	a2, a1, 0
420120ff:	4a2c      	movi.n	a10, 36
42012101:	10c182        	addi	a8, a1, 16
42012104:	02d882        	addmi	a8, a8, 0x200
42012107:	102882        	l32i	a8, a8, 64
4201210a:	9661a2        	s32i	a10, a1, 0x258
4201210d:	88aa      	add.n	a8, a8, a10
4201210f:	fcc882        	addi	a8, a8, -4
42012112:	000842        	l8ui	a4, a8, 0
42012115:	0028c6        	j	420121bc <_vfiprintf_r+0x169c>
42012118:	c4ac      	beqz.n	a4, 42012148 <_vfiprintf_r+0x1628>
4201211a:	07a687        	bge	a6, a8, 42012125 <_vfiprintf_r+0x1605>
4201211d:	b0e6e0        	addx8	a14, a6, a14
42012120:	0e48      	l32i.n	a4, a14, 0
42012122:	000706        	j	42012142 <_vfiprintf_r+0x1622>
42012125:	30a282        	movi	a8, 0x230
42012128:	8e8a      	add.n	a8, a14, a8
4201212a:	34a2d2        	movi	a13, 0x234
4201212d:	40a2c2        	movi	a12, 0x240
42012130:	0189      	s32i.n	a8, a1, 0
42012132:	01def2        	addmi	a15, a14, 0x100
42012135:	deda      	add.n	a13, a14, a13
42012137:	ceca      	add.n	a12, a14, a12
42012139:	07bd      	mov.n	a11, a7
4201213b:	06ad      	mov.n	a10, a6
4201213d:	fe4ee5        	call8	4201062c <get_arg$isra$0>
42012140:	0a48      	l32i.n	a4, a10, 0
42012142:	057d      	mov.n	a7, a5
42012144:	001d06        	j	420121bc <_vfiprintf_r+0x169c>
42012147:	751b00        	extui	a1, a0, 27, 8
4201214a:	07a587        	bge	a5, a8, 42012155 <_vfiprintf_r+0x1635>
4201214d:	b066e0        	addx8	a6, a6, a14
42012150:	0648      	l32i.n	a4, a6, 0
42012152:	001986        	j	420121bc <_vfiprintf_r+0x169c>
42012155:	922e92        	l32i	a9, a14, 0x248
42012158:	fb1c      	movi.n	a11, 31
4201215a:	02dee2        	addmi	a14, a14, 0x200
4201215d:	a94b      	addi.n	a10, a9, 4
4201215f:	322b87        	blt	a11, a8, 42012195 <_vfiprintf_r+0x1675>
42012162:	b81b      	addi.n	a11, a8, 1
42012164:	9161b2        	s32i	a11, a1, 0x244
42012167:	126ea2        	s32i	a10, a14, 72
4201216a:	8b1c      	movi.n	a11, 24
4201216c:	052ba7        	blt	a11, a10, 42012175 <_vfiprintf_r+0x1655>
4201216f:	112e92        	l32i	a9, a14, 68
42012172:	000406        	j	42012186 <_vfiprintf_r+0x1666>
42012175:	012b97        	blt	a11, a9, 4201217a <_vfiprintf_r+0x165a>
42012178:	4a2c      	movi.n	a10, 36
4201217a:	10c192        	addi	a9, a1, 16
4201217d:	02d992        	addmi	a9, a9, 0x200
42012180:	102992        	l32i	a9, a9, 64
42012183:	9661a2        	s32i	a10, a1, 0x258
42012186:	99aa      	add.n	a9, a9, a10
42012188:	fcc992        	addi	a9, a9, -4
4201218b:	0948      	l32i.n	a4, a9, 0
4201218d:	b08810        	addx8	a8, a8, a1
42012190:	4849      	s32i.n	a4, a8, 16
42012192:	000986        	j	420121bc <_vfiprintf_r+0x169c>
42012195:	126ea2        	s32i	a10, a14, 72
42012198:	881c      	movi.n	a8, 24
4201219a:	0628a7        	blt	a8, a10, 420121a4 <_vfiprintf_r+0x1684>
4201219d:	112e82        	l32i	a8, a14, 68
420121a0:	000446        	j	420121b5 <_vfiprintf_r+0x1695>
420121a3:	00          	.byte	00
420121a4:	012897        	blt	a8, a9, 420121a9 <_vfiprintf_r+0x1689>
420121a7:	4a2c      	movi.n	a10, 36
420121a9:	10c182        	addi	a8, a1, 16
420121ac:	02d882        	addmi	a8, a8, 0x200
420121af:	102882        	l32i	a8, a8, 64
420121b2:	9661a2        	s32i	a10, a1, 0x258
420121b5:	88aa      	add.n	a8, a8, a10
420121b7:	fcc882        	addi	a8, a8, -4
420121ba:	0848      	l32i.n	a4, a8, 0
420121bc:	020c      	movi.n	a2, 0
420121be:	208420        	or	a8, a4, a2
420121c1:	889c      	beqz.n	a8, 420121dd <_vfiprintf_r+0x16bd>
420121c3:	166307        	bbci	a3, 0, 420121dd <_vfiprintf_r+0x16bd>
420121c6:	10c182        	addi	a8, a1, 16
420121c9:	02d882        	addmi	a8, a8, 0x200
420121cc:	093c      	movi.n	a9, 48
420121ce:	384892        	s8i	a9, a8, 56
420121d1:	9e2192        	l32i	a9, a1, 0x278
420121d4:	394892        	s8i	a9, a8, 57
420121d7:	02a082        	movi	a8, 2
420121da:	203380        	or	a3, a3, a8
420121dd:	ffab82        	movi	a8, 0xfffffbff
420121e0:	103380        	and	a3, a3, a8
420121e3:	280c      	movi.n	a8, 2
420121e5:	090c      	movi.n	a9, 0
420121e7:	10c1a2        	addi	a10, a1, 16
420121ea:	02daa2        	addmi	a10, a10, 0x200
420121ed:	3a4a92        	s8i	a9, a10, 58
420121f0:	9a2192        	l32i	a9, a1, 0x268
420121f3:	01d996        	bltz	a9, 42012214 <_vfiprintf_r+0x16f4>
420121f6:	20a330        	or	a10, a3, a3
420121f9:	7faf92        	movi	a9, -129
420121fc:	103390        	and	a3, a3, a9
420121ff:	1b0c      	movi.n	a11, 1
42012201:	209420        	or	a9, a4, a2
42012204:	83b990        	moveqz	a11, a9, a9
42012207:	99cc      	bnez.n	a9, 42012214 <_vfiprintf_r+0x16f4>
42012209:	9a21c2        	l32i	a12, a1, 0x268
4201220c:	190c      	movi.n	a9, 1
4201220e:	839bc0        	moveqz	a9, a11, a12
42012211:	12f916        	beqz	a9, 42012344 <_vfiprintf_r+0x1824>
42012214:	421826        	beqi	a8, 1, 4201225a <_vfiprintf_r+0x173a>
42012217:	e4a162        	movi	a6, 0x1e4
4201221a:	022866        	bnei	a8, 2, 42012220 <_vfiprintf_r+0x1700>
4201221d:	003ec6        	j	4201231c <_vfiprintf_r+0x17fc>
42012220:	10c182        	addi	a8, a1, 16
42012223:	686a      	add.n	a6, a8, a6
42012225:	248040        	extui	a8, a4, 0, 3
42012228:	069d      	mov.n	a9, a6
4201222a:	404300        	ssai	3
4201222d:	814240        	src	a4, a2, a4
42012230:	660b      	addi.n	a6, a6, -1
42012232:	30c882        	addi	a8, a8, 48
42012235:	412320        	srli	a2, a2, 3
42012238:	004682        	s8i	a8, a6, 0
4201223b:	20a420        	or	a10, a4, a2
4201223e:	fe3a56        	bnez	a10, 42012225 <_vfiprintf_r+0x1705>
42012241:	d0c882        	addi	a8, a8, -48
42012244:	130816        	beqz	a8, 42012378 <_vfiprintf_r+0x1858>
42012247:	02e307        	bbsi	a3, 0, 4201224d <_vfiprintf_r+0x172d>
4201224a:	004a86        	j	42012378 <_vfiprintf_r+0x1858>
4201224d:	660b      	addi.n	a6, a6, -1
4201224f:	083c      	movi.n	a8, 48
42012251:	004682        	s8i	a8, a6, 0
42012254:	fec962        	addi	a6, a9, -2
42012257:	004746        	j	42012378 <_vfiprintf_r+0x1858>
4201225a:	72dc      	bnez.n	a2, 42012275 <_vfiprintf_r+0x1755>
4201225c:	980c      	movi.n	a8, 9
4201225e:	133847        	bltu	a8, a4, 42012275 <_vfiprintf_r+0x1755>
42012261:	10c162        	addi	a6, a1, 16
42012264:	01d682        	addmi	a8, a6, 0x100
42012267:	30c442        	addi	a4, a4, 48
4201226a:	e34842        	s8i	a4, a8, 227
4201226d:	e3a182        	movi	a8, 0x1e3
42012270:	004086        	j	42012376 <_vfiprintf_r+0x1856>
42012273:	620000        	saltu	a0, a0, a0
42012276:	52f4a1        	l32r	a10, 41fe6e48 <_iram_bss_end+0x1c64a48>
42012279:	0c00a4        	ee.st.qacc_l.l.128.ip	a10, 0
4201227c:	50616a0e 	ee.vmulas.u16.qacc.ld.ip.qup	q0, a0, 160, q1, q4, q6, q1
42012280:	53          	.byte	0x53
42012281:	10          	.byte	0x10
42012282:	9e61e2        	s32i	a14, a1, 0x278
42012285:	ac0c      	movi.n	a12, 10
42012287:	0d0c      	movi.n	a13, 0
42012289:	04ad      	mov.n	a10, a4
4201228b:	20b220        	or	a11, a2, a2
4201228e:	b93f81        	l32r	a8, 4200078c <_stext+0x76c> (40002574 <__umoddi3>)
42012291:	0008e0        	callx8	a8
42012294:	9e21e2        	l32i	a14, a1, 0x278
42012297:	660b      	addi.n	a6, a6, -1
42012299:	30caa2        	addi	a10, a10, 48
4201229c:	0046a2        	s8i	a10, a6, 0
4201229f:	ee1b      	addi.n	a14, a14, 1
420122a1:	053516        	beqz	a5, 420122f8 <_vfiprintf_r+0x17d8>
420122a4:	9f2182        	l32i	a8, a1, 0x27c
420122a7:	000892        	l8ui	a9, a8, 0
420122aa:	01af82        	movi	a8, -255
420122ad:	808980        	add	a8, a9, a8
420122b0:	044816        	beqz	a8, 420122f8 <_vfiprintf_r+0x17d8>
420122b3:	4199e7        	bne	a9, a14, 420122f8 <_vfiprintf_r+0x17d8>
420122b6:	72cc      	bnez.n	a2, 420122c1 <_vfiprintf_r+0x17a1>
420122b8:	09a082        	movi	a8, 9
420122bb:	023847        	bltu	a8, a4, 420122c1 <_vfiprintf_r+0x17a1>
420122be:	002d86        	j	42012378 <_vfiprintf_r+0x1858>
420122c1:	a02182        	l32i	a8, a1, 0x280
420122c4:	a221b2        	l32i	a11, a1, 0x288
420122c7:	c06680        	sub	a6, a6, a8
420122ca:	08cd      	mov.n	a12, a8
420122cc:	06ad      	mov.n	a10, a6
420122ce:	babe81        	l32r	a8, 42000dc8 <_stext+0xda8> (40001224 <strncpy>)
420122d1:	0008e0        	callx8	a8
420122d4:	9f2182        	l32i	a8, a1, 0x27c
420122d7:	010882        	l8ui	a8, a8, 1
420122da:	688c      	beqz.n	a8, 420122e4 <_vfiprintf_r+0x17c4>
420122dc:	9f2182        	l32i	a8, a1, 0x27c
420122df:	881b      	addi.n	a8, a8, 1
420122e1:	9f6182        	s32i	a8, a1, 0x27c
420122e4:	ac0c      	movi.n	a12, 10
420122e6:	0d0c      	movi.n	a13, 0
420122e8:	04ad      	mov.n	a10, a4
420122ea:	02bd      	mov.n	a11, a2
420122ec:	b7ae81        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
420122ef:	0008e0        	callx8	a8
420122f2:	0e0c      	movi.n	a14, 0
420122f4:	000706        	j	42012314 <_vfiprintf_r+0x17f4>
420122f7:	00          	.byte	00
420122f8:	9e61e2        	s32i	a14, a1, 0x278
420122fb:	ac0c      	movi.n	a12, 10
420122fd:	0d0c      	movi.n	a13, 0
420122ff:	04ad      	mov.n	a10, a4
42012301:	02bd      	mov.n	a11, a2
42012303:	b7a881        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42012306:	0008e0        	callx8	a8
42012309:	9e21e2        	l32i	a14, a1, 0x278
4201230c:	42cc      	bnez.n	a2, 42012314 <_vfiprintf_r+0x17f4>
4201230e:	09a082        	movi	a8, 9
42012311:	63b847        	bgeu	a8, a4, 42012378 <_vfiprintf_r+0x1858>
42012314:	0a4d      	mov.n	a4, a10
42012316:	0b2d      	mov.n	a2, a11
42012318:	ffd986        	j	42012282 <_vfiprintf_r+0x1762>
4201231b:	c18200        	mul16u	a8, a2, a0
4201231e:	10          	.byte	0x10
4201231f:	686a      	add.n	a6, a8, a6
42012321:	a12192        	l32i	a9, a1, 0x284
42012324:	348040        	extui	a8, a4, 0, 4
42012327:	898a      	add.n	a8, a9, a8
42012329:	000882        	l8ui	a8, a8, 0
4201232c:	404400        	ssai	4
4201232f:	814240        	src	a4, a2, a4
42012332:	660b      	addi.n	a6, a6, -1
42012334:	412420        	srli	a2, a2, 4
42012337:	004682        	s8i	a8, a6, 0
4201233a:	208420        	or	a8, a4, a2
4201233d:	fe0856        	bnez	a8, 42012321 <_vfiprintf_r+0x1801>
42012340:	000d06        	j	42012378 <_vfiprintf_r+0x1858>
42012343:	090c00        	l32e	a0, a12, -64
42012346:	9a6192        	s32i	a9, a1, 0x268
42012349:	e4a162        	movi	a6, 0x1e4
4201234c:	10c192        	addi	a9, a1, 16
4201234f:	696a      	add.n	a6, a9, a6
42012351:	38ec      	bnez.n	a8, 42012378 <_vfiprintf_r+0x1858>
42012353:	0480a0        	extui	a8, a10, 0, 1
42012356:	9a6182        	s32i	a8, a1, 0x268
42012359:	9a2182        	l32i	a8, a1, 0x268
4201235c:	e4a162        	movi	a6, 0x1e4
4201235f:	696a      	add.n	a6, a9, a6
42012361:	389c      	beqz.n	a8, 42012378 <_vfiprintf_r+0x1858>
42012363:	01d982        	addmi	a8, a9, 0x100
42012366:	093c      	movi.n	a9, 48
42012368:	e34892        	s8i	a9, a8, 227
4201236b:	080c      	movi.n	a8, 0
4201236d:	9a6182        	s32i	a8, a1, 0x268
42012370:	e3a162        	movi	a6, 0x1e3
42012373:	10c182        	addi	a8, a1, 16
42012376:	686a      	add.n	a6, a8, a6
42012378:	a42182        	l32i	a8, a1, 0x290
4201237b:	9a2152        	l32i	a5, a1, 0x268
4201237e:	c08860        	sub	a8, a8, a6
42012381:	9a6182        	s32i	a8, a1, 0x268
42012384:	0009c6        	j	420123af <_vfiprintf_r+0x188f>
42012387:	9e2182        	l32i	a8, a1, 0x278
4201238a:	392816        	beqz	a8, 42012720 <_vfiprintf_r+0x1c00>
4201238d:	9e2192        	l32i	a9, a1, 0x278
42012390:	10c162        	addi	a6, a1, 16
42012393:	01d682        	addmi	a8, a6, 0x100
42012396:	804892        	s8i	a9, a8, 128
42012399:	02d682        	addmi	a8, a6, 0x200
4201239c:	090c      	movi.n	a9, 0
4201239e:	3a4892        	s8i	a9, a8, 58
420123a1:	057d      	mov.n	a7, a5
420123a3:	180c      	movi.n	a8, 1
420123a5:	9a6182        	s32i	a8, a1, 0x268
420123a8:	80a182        	movi	a8, 0x180
420123ab:	050c      	movi.n	a5, 0
420123ad:	668a      	add.n	a6, a6, a8
420123af:	9a2182        	l32i	a8, a1, 0x268
420123b2:	534580        	max	a4, a5, a8
420123b5:	10c182        	addi	a8, a1, 16
420123b8:	02d882        	addmi	a8, a8, 0x200
420123bb:	3a0882        	l8ui	a8, a8, 58
420123be:	088c      	beqz.n	a8, 420123c2 <_vfiprintf_r+0x18a2>
420123c0:	441b      	addi.n	a4, a4, 1
420123c2:	220c      	movi.n	a2, 2
420123c4:	108320        	and	a8, a3, a2
420123c7:	9e6182        	s32i	a8, a1, 0x278
420123ca:	002816        	beqz	a8, 420123d0 <_vfiprintf_r+0x18b0>
420123cd:	02c442        	addi	a4, a4, 2
420123d0:	84a082        	movi	a8, 132
420123d3:	108380        	and	a8, a3, a8
420123d6:	a36182        	s32i	a8, a1, 0x28c
420123d9:	084856        	bnez	a8, 42012461 <_vfiprintf_r+0x1941>
420123dc:	9c2182        	l32i	a8, a1, 0x270
420123df:	10c122        	addi	a2, a1, 16
420123e2:	c08840        	sub	a8, a8, a4
420123e5:	3218e6        	bgei	a8, 1, 4201241b <_vfiprintf_r+0x18fb>
420123e8:	001d46        	j	42012461 <_vfiprintf_r+0x1941>
420123eb:	00          	.byte	00
420123ec:	10ccc2        	addi	a12, a12, 16
420123ef:	1df9      	s32i.n	a15, a13, 4
420123f1:	bac9      	s32i.n	a12, a10, 44
420123f3:	aa99      	s32i.n	a9, a10, 40
420123f5:	1c89a6        	blti	a9, 8, 42012415 <_vfiprintf_r+0x18f5>
420123f8:	24a2c2        	movi	a12, 0x224
420123fb:	9821b2        	l32i	a11, a1, 0x260
420123fe:	9b21a2        	l32i	a10, a1, 0x26c
42012401:	c2ca      	add.n	a12, a2, a12
42012403:	976182        	s32i	a8, a1, 0x25c
42012406:	fe6f65        	call8	42010afc <__sprint_r>
42012409:	338a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
4201240c:	e4a1b2        	movi	a11, 0x1e4
4201240f:	972182        	l32i	a8, a1, 0x25c
42012412:	80b2b0        	add	a11, a2, a11
42012415:	f0c882        	addi	a8, a8, -16
42012418:	9761b2        	s32i	a11, a1, 0x25c
4201241b:	babce1        	l32r	a14, 42000f0c <_stext+0xeec> (3c028a2c <blanks$1>)
4201241e:	9721d2        	l32i	a13, a1, 0x25c
42012421:	9721b2        	l32i	a11, a1, 0x25c
42012424:	8a2292        	l32i	a9, a2, 0x228
42012427:	0f1c      	movi.n	a15, 16
42012429:	0de9      	s32i.n	a14, a13, 0
4201242b:	02d2a2        	addmi	a10, a2, 0x200
4201242e:	991b      	addi.n	a9, a9, 1
42012430:	bb8b      	addi.n	a11, a11, 8
42012432:	bac8      	l32i.n	a12, a10, 44
42012434:	b42f87        	blt	a15, a8, 420123ec <_vfiprintf_r+0x18cc>
42012437:	1d89      	s32i.n	a8, a13, 4
42012439:	88ca      	add.n	a8, a8, a12
4201243b:	ba89      	s32i.n	a8, a10, 44
4201243d:	0a6a92        	s32i	a9, a10, 40
42012440:	9761b2        	s32i	a11, a1, 0x25c
42012443:	1a89a6        	blti	a9, 8, 42012461 <_vfiprintf_r+0x1941>
42012446:	24a2c2        	movi	a12, 0x224
42012449:	9821b2        	l32i	a11, a1, 0x260
4201244c:	9b21a2        	l32i	a10, a1, 0x26c
4201244f:	80c2c0        	add	a12, a2, a12
42012452:	fe6aa5        	call8	42010afc <__sprint_r>
42012455:	2eca56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
42012458:	e4a182        	movi	a8, 0x1e4
4201245b:	808280        	add	a8, a2, a8
4201245e:	976182        	s32i	a8, a1, 0x25c
42012461:	10c182        	addi	a8, a1, 16
42012464:	02d8a2        	addmi	a10, a8, 0x200
42012467:	3a0a82        	l8ui	a8, a10, 58
4201246a:	042816        	beqz	a8, 420124b0 <_vfiprintf_r+0x1990>
4201246d:	10c1c2        	addi	a12, a1, 16
42012470:	3aa292        	movi	a9, 0x23a
42012473:	9c9a      	add.n	a9, a12, a9
42012475:	ba88      	l32i.n	a8, a10, 44
42012477:	9721c2        	l32i	a12, a1, 0x25c
4201247a:	aab8      	l32i.n	a11, a10, 40
4201247c:	881b      	addi.n	a8, a8, 1
4201247e:	bb1b      	addi.n	a11, a11, 1
42012480:	0c99      	s32i.n	a9, a12, 0
42012482:	190c      	movi.n	a9, 1
42012484:	ba89      	s32i.n	a8, a10, 44
42012486:	1c99      	s32i.n	a9, a12, 4
42012488:	aab9      	s32i.n	a11, a10, 40
4201248a:	8c8b      	addi.n	a8, a12, 8
4201248c:	1d8ba6        	blti	a11, 8, 420124ad <_vfiprintf_r+0x198d>
4201248f:	24a2c2        	movi	a12, 0x224
42012492:	10c182        	addi	a8, a1, 16
42012495:	9821b2        	l32i	a11, a1, 0x260
42012498:	9b21a2        	l32i	a10, a1, 0x26c
4201249b:	80c8c0        	add	a12, a8, a12
4201249e:	fe65e5        	call8	42010afc <__sprint_r>
420124a1:	2a0a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
420124a4:	e4a182        	movi	a8, 0x1e4
420124a7:	10c192        	addi	a9, a1, 16
420124aa:	808980        	add	a8, a9, a8
420124ad:	976182        	s32i	a8, a1, 0x25c
420124b0:	9e2182        	l32i	a8, a1, 0x278
420124b3:	049816        	beqz	a8, 42012500 <_vfiprintf_r+0x19e0>
420124b6:	10c182        	addi	a8, a1, 16
420124b9:	10c1c2        	addi	a12, a1, 16
420124bc:	38a292        	movi	a9, 0x238
420124bf:	02d8b2        	addmi	a11, a8, 0x200
420124c2:	9c9a      	add.n	a9, a12, a9
420124c4:	8f2182        	l32i	a8, a1, 0x23c
420124c7:	9721c2        	l32i	a12, a1, 0x25c
420124ca:	aba8      	l32i.n	a10, a11, 40
420124cc:	882b      	addi.n	a8, a8, 2
420124ce:	aa1b      	addi.n	a10, a10, 1
420124d0:	0c99      	s32i.n	a9, a12, 0
420124d2:	290c      	movi.n	a9, 2
420124d4:	bb89      	s32i.n	a8, a11, 44
420124d6:	1c99      	s32i.n	a9, a12, 4
420124d8:	aba9      	s32i.n	a10, a11, 40
420124da:	8c8b      	addi.n	a8, a12, 8
420124dc:	1d8aa6        	blti	a10, 8, 420124fd <_vfiprintf_r+0x19dd>
420124df:	24a2c2        	movi	a12, 0x224
420124e2:	10c182        	addi	a8, a1, 16
420124e5:	9821b2        	l32i	a11, a1, 0x260
420124e8:	9b21a2        	l32i	a10, a1, 0x26c
420124eb:	80c8c0        	add	a12, a8, a12
420124ee:	fe60e5        	call8	42010afc <__sprint_r>
420124f1:	250a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
420124f4:	e4a182        	movi	a8, 0x1e4
420124f7:	10c192        	addi	a9, a1, 16
420124fa:	808980        	add	a8, a9, a8
420124fd:	976182        	s32i	a8, a1, 0x25c
42012500:	a32182        	l32i	a8, a1, 0x28c
42012503:	02e826        	beqi	a8, 128, 42012509 <_vfiprintf_r+0x19e9>
42012506:	002286        	j	42012594 <_vfiprintf_r+0x1a74>
42012509:	9c2182        	l32i	a8, a1, 0x270
4201250c:	10c122        	addi	a2, a1, 16
4201250f:	c0e840        	sub	a14, a8, a4
42012512:	381ee6        	bgei	a14, 1, 4201254e <_vfiprintf_r+0x1a2e>
42012515:	001ec6        	j	42012594 <_vfiprintf_r+0x1a74>
42012518:	9721f2        	l32i	a15, a1, 0x25c
4201251b:	10cbb2        	addi	a11, a11, 16
4201251e:	0fc9      	s32i.n	a12, a15, 0
42012520:	1fd9      	s32i.n	a13, a15, 4
42012522:	0b69b2        	s32i	a11, a9, 44
42012525:	0a6982        	s32i	a8, a9, 40
42012528:	1c88a6        	blti	a8, 8, 42012548 <_vfiprintf_r+0x1a28>
4201252b:	24a2c2        	movi	a12, 0x224
4201252e:	9821b2        	l32i	a11, a1, 0x260
42012531:	9b21a2        	l32i	a10, a1, 0x26c
42012534:	80c2c0        	add	a12, a2, a12
42012537:	9761e2        	s32i	a14, a1, 0x25c
4201253a:	fe5c25        	call8	42010afc <__sprint_r>
4201253d:	204a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
42012540:	e4a1a2        	movi	a10, 0x1e4
42012543:	9721e2        	l32i	a14, a1, 0x25c
42012546:	a2aa      	add.n	a10, a2, a10
42012548:	f0cee2        	addi	a14, a14, -16
4201254b:	9761a2        	s32i	a10, a1, 0x25c
4201254e:	9721a2        	l32i	a10, a1, 0x25c
42012551:	8a2282        	l32i	a8, a2, 0x228
42012554:	0d1c      	movi.n	a13, 16
42012556:	02d292        	addmi	a9, a2, 0x200
42012559:	ba6dc1        	l32r	a12, 42000f10 <_stext+0xef0> (3c028a1c <zeroes$0>)
4201255c:	881b      	addi.n	a8, a8, 1
4201255e:	aa8b      	addi.n	a10, a10, 8
42012560:	b9b8      	l32i.n	a11, a9, 44
42012562:	b22de7        	blt	a13, a14, 42012518 <_vfiprintf_r+0x19f8>
42012565:	9721d2        	l32i	a13, a1, 0x25c
42012568:	beba      	add.n	a11, a14, a11
4201256a:	0dc9      	s32i.n	a12, a13, 0
4201256c:	1de9      	s32i.n	a14, a13, 4
4201256e:	0b69b2        	s32i	a11, a9, 44
42012571:	0a6982        	s32i	a8, a9, 40
42012574:	9761a2        	s32i	a10, a1, 0x25c
42012577:	1988a6        	blti	a8, 8, 42012594 <_vfiprintf_r+0x1a74>
4201257a:	24a2c2        	movi	a12, 0x224
4201257d:	9821b2        	l32i	a11, a1, 0x260
42012580:	9b21a2        	l32i	a10, a1, 0x26c
42012583:	80c2c0        	add	a12, a2, a12
42012586:	fe5765        	call8	42010afc <__sprint_r>
42012589:	1b8a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
4201258c:	e4a182        	movi	a8, 0x1e4
4201258f:	828a      	add.n	a8, a2, a8
42012591:	976182        	s32i	a8, a1, 0x25c
42012594:	9a2182        	l32i	a8, a1, 0x268
42012597:	c05580        	sub	a5, a5, a8
4201259a:	0215e6        	bgei	a5, 1, 420125a0 <_vfiprintf_r+0x1a80>
4201259d:	002146        	j	42012626 <_vfiprintf_r+0x1b06>
420125a0:	000dc6        	j	420125db <_vfiprintf_r+0x1abb>
420125a3:	e20000        	remu	a0, a0, a0
420125a6:	b29721        	l32r	a2, 41fff004 <_iram_bss_end+0x1c7cc04>
420125a9:	10cb      	addi.n	a1, a0, 12
420125ab:	0ec9      	s32i.n	a12, a14, 0
420125ad:	1ed9      	s32i.n	a13, a14, 4
420125af:	b9b9      	s32i.n	a11, a9, 44
420125b1:	0a6982        	s32i	a8, a9, 40
420125b4:	1d88a6        	blti	a8, 8, 420125d5 <_vfiprintf_r+0x1ab5>
420125b7:	24a2c2        	movi	a12, 0x224
420125ba:	10c182        	addi	a8, a1, 16
420125bd:	9821b2        	l32i	a11, a1, 0x260
420125c0:	9b21a2        	l32i	a10, a1, 0x26c
420125c3:	80c8c0        	add	a12, a8, a12
420125c6:	fe5365        	call8	42010afc <__sprint_r>
420125c9:	178a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
420125cc:	e4a1a2        	movi	a10, 0x1e4
420125cf:	10c182        	addi	a8, a1, 16
420125d2:	80a8a0        	add	a10, a8, a10
420125d5:	f0c552        	addi	a5, a5, -16
420125d8:	9761a2        	s32i	a10, a1, 0x25c
420125db:	10c182        	addi	a8, a1, 16
420125de:	02d892        	addmi	a9, a8, 0x200
420125e1:	a988      	l32i.n	a8, a9, 40
420125e3:	9721a2        	l32i	a10, a1, 0x25c
420125e6:	0d1c      	movi.n	a13, 16
420125e8:	ba4ac1        	l32r	a12, 42000f10 <_stext+0xef0> (3c028a1c <zeroes$0>)
420125eb:	881b      	addi.n	a8, a8, 1
420125ed:	aa8b      	addi.n	a10, a10, 8
420125ef:	b9b8      	l32i.n	a11, a9, 44
420125f1:	b02d57        	blt	a13, a5, 420125a5 <_vfiprintf_r+0x1a85>
420125f4:	9721d2        	l32i	a13, a1, 0x25c
420125f7:	a989      	s32i.n	a8, a9, 40
420125f9:	1d59      	s32i.n	a5, a13, 4
420125fb:	55ba      	add.n	a5, a5, a11
420125fd:	0dc9      	s32i.n	a12, a13, 0
420125ff:	b959      	s32i.n	a5, a9, 44
42012601:	9761a2        	s32i	a10, a1, 0x25c
42012604:	1e88a6        	blti	a8, 8, 42012626 <_vfiprintf_r+0x1b06>
42012607:	24a2c2        	movi	a12, 0x224
4201260a:	10c182        	addi	a8, a1, 16
4201260d:	9821b2        	l32i	a11, a1, 0x260
42012610:	9b21a2        	l32i	a10, a1, 0x26c
42012613:	c8ca      	add.n	a12, a8, a12
42012615:	fe4e65        	call8	42010afc <__sprint_r>
42012618:	129a56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
4201261b:	e4a182        	movi	a8, 0x1e4
4201261e:	10c192        	addi	a9, a1, 16
42012621:	898a      	add.n	a8, a9, a8
42012623:	976182        	s32i	a8, a1, 0x25c
42012626:	9a2192        	l32i	a9, a1, 0x268
42012629:	972182        	l32i	a8, a1, 0x25c
4201262c:	9a21a2        	l32i	a10, a1, 0x268
4201262f:	1899      	s32i.n	a9, a8, 4
42012631:	0869      	s32i.n	a6, a8, 0
42012633:	10c182        	addi	a8, a1, 16
42012636:	02d892        	addmi	a9, a8, 0x200
42012639:	8f2182        	l32i	a8, a1, 0x23c
4201263c:	88aa      	add.n	a8, a8, a10
4201263e:	b989      	s32i.n	a8, a9, 44
42012640:	a988      	l32i.n	a8, a9, 40
42012642:	881b      	addi.n	a8, a8, 1
42012644:	a989      	s32i.n	a8, a9, 40
42012646:	0788e6        	bgei	a8, 8, 42012651 <_vfiprintf_r+0x1b31>
42012649:	972182        	l32i	a8, a1, 0x25c
4201264c:	888b      	addi.n	a8, a8, 8
4201264e:	0006c6        	j	4201266d <_vfiprintf_r+0x1b4d>
42012651:	24a2c2        	movi	a12, 0x224
42012654:	10c182        	addi	a8, a1, 16
42012657:	9821b2        	l32i	a11, a1, 0x260
4201265a:	9b21a2        	l32i	a10, a1, 0x26c
4201265d:	c8ca      	add.n	a12, a8, a12
4201265f:	fe49e5        	call8	42010afc <__sprint_r>
42012662:	0dfa56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
42012665:	e4a182        	movi	a8, 0x1e4
42012668:	10c192        	addi	a9, a1, 16
4201266b:	898a      	add.n	a8, a9, a8
4201266d:	17e327        	bbsi	a3, 2, 42012688 <_vfiprintf_r+0x1b68>
42012670:	9c2182        	l32i	a8, a1, 0x270
42012673:	534840        	max	a4, a8, a4
42012676:	9d2182        	l32i	a8, a1, 0x274
42012679:	884a      	add.n	a8, a8, a4
4201267b:	9d6182        	s32i	a8, a1, 0x274
4201267e:	8f2182        	l32i	a8, a1, 0x23c
42012681:	06d816        	beqz	a8, 420126f2 <_vfiprintf_r+0x1bd2>
42012684:	001fc6        	j	42012707 <_vfiprintf_r+0x1be7>
42012687:	219200        	srai	a9, a0, 2
4201268a:	409c      	beqz.n	a0, 420126a2 <_vfiprintf_r+0x1b82>
4201268c:	c069      	s32i.n	a6, a0, 48
4201268e:	de16a6        	blti	a6, 1, 42012670 <_vfiprintf_r+0x1b50>
42012691:	10c152        	addi	a5, a1, 16
42012694:	0009c6        	j	420126bf <_vfiprintf_r+0x1b9f>
42012697:	cbb200        	movf.s	f11, f2, b0
4201269a:	18d910        	lsxp	f13, a9, a1
4201269d:	bab9      	s32i.n	a11, a10, 44
4201269f:	aa99      	s32i.n	a9, a10, 40
420126a1:	888b      	addi.n	a8, a8, 8
420126a3:	1589a6        	blti	a9, 8, 420126bc <_vfiprintf_r+0x1b9c>
420126a6:	24a2c2        	movi	a12, 0x224
420126a9:	9821b2        	l32i	a11, a1, 0x260
420126ac:	9b21a2        	l32i	a10, a1, 0x26c
420126af:	c5ca      	add.n	a12, a5, a12
420126b1:	fe44a5        	call8	42010afc <__sprint_r>
420126b4:	08da56        	bnez	a10, 42012745 <_vfiprintf_r+0x1c25>
420126b7:	e4a182        	movi	a8, 0x1e4
420126ba:	858a      	add.n	a8, a5, a8
420126bc:	f0c662        	addi	a6, a6, -16
420126bf:	ba13c1        	l32r	a12, 42000f0c <_stext+0xeec> (3c028a2c <blanks$1>)
420126c2:	8a2592        	l32i	a9, a5, 0x228
420126c5:	0d1c      	movi.n	a13, 16
420126c7:	08c9      	s32i.n	a12, a8, 0
420126c9:	02d5a2        	addmi	a10, a5, 0x200
420126cc:	991b      	addi.n	a9, a9, 1
420126ce:	bab8      	l32i.n	a11, a10, 44
420126d0:	c42d67        	blt	a13, a6, 42012698 <_vfiprintf_r+0x1b78>
420126d3:	1869      	s32i.n	a6, a8, 4
420126d5:	66ba      	add.n	a6, a6, a11
420126d7:	ba69      	s32i.n	a6, a10, 44
420126d9:	aa99      	s32i.n	a9, a10, 40
420126db:	9189a6        	blti	a9, 8, 42012670 <_vfiprintf_r+0x1b50>
420126de:	24a2c2        	movi	a12, 0x224
420126e1:	9821b2        	l32i	a11, a1, 0x260
420126e4:	9b21a2        	l32i	a10, a1, 0x26c
420126e7:	c5ca      	add.n	a12, a5, a12
420126e9:	fe4125        	call8	42010afc <__sprint_r>
420126ec:	f80a16        	beqz	a10, 42012670 <_vfiprintf_r+0x1b50>
420126ef:	001486        	j	42012745 <_vfiprintf_r+0x1c25>
420126f2:	090c      	movi.n	a9, 0
420126f4:	8e6192        	s32i	a9, a1, 0x238
420126f7:	e4a182        	movi	a8, 0x1e4
420126fa:	10c192        	addi	a9, a1, 16
420126fd:	898a      	add.n	a8, a9, a8
420126ff:	075d      	mov.n	a5, a7
42012701:	976182        	s32i	a8, a1, 0x25c
42012704:	f94d06        	j	42010c3c <_vfiprintf_r+0x11c>
42012707:	24a2c2        	movi	a12, 0x224
4201270a:	10c182        	addi	a8, a1, 16
4201270d:	9821b2        	l32i	a11, a1, 0x260
42012710:	9b21a2        	l32i	a10, a1, 0x26c
42012713:	c8ca      	add.n	a12, a8, a12
42012715:	fe3e65        	call8	42010afc <__sprint_r>
42012718:	fd6a16        	beqz	a10, 420126f2 <_vfiprintf_r+0x1bd2>
4201271b:	000986        	j	42012745 <_vfiprintf_r+0x1c25>
4201271e:	820000        	mull	a0, a0, a0
42012721:	728f21        	l32r	a2, 41fef160 <_iram_bss_end+0x1c6cd60>
42012724:	cc10c1        	l32r	a12, 42005764 <esp_mprot_set_prot+0x328> (2dffada5 <UserFrameTotalSize+0x2dffaca5>)
42012727:	0ca8      	l32i.n	a10, a12, 0
42012729:	8208      	l32i.n	a0, a2, 32
4201272b:	728a67        	bany	a10, a6, 420127a1 <vfiprintf+0x1d>
4201272e:	4602d7        	bnone	a2, a13, 42012778 <_vfiprintf_r+0x1c58>
42012731:	000004        	ee.ld.qacc_l.l.128.ip	a0, 0
42012734:	24a2c2        	movi	a12, 0x224
42012737:	9821b2        	l32i	a11, a1, 0x260
4201273a:	9b21a2        	l32i	a10, a1, 0x26c
4201273d:	c7ca      	add.n	a12, a7, a12
4201273f:	fe3be5        	call8	42010afc <__sprint_r>
42012742:	fe2a16        	beqz	a10, 42012728 <_vfiprintf_r+0x1c08>
42012745:	982182        	l32i	a8, a1, 0x260
42012748:	192882        	l32i	a8, a8, 100
4201274b:	14e807        	bbsi	a8, 0, 42012763 <_vfiprintf_r+0x1c43>
4201274e:	982182        	l32i	a8, a1, 0x260
42012751:	061882        	l16ui	a8, a8, 12
42012754:	0be897        	bbsi	a8, 9, 42012763 <_vfiprintf_r+0x1c43>
42012757:	982182        	l32i	a8, a1, 0x260
4201275a:	1628a2        	l32i	a10, a8, 88
4201275d:	b9ab81        	l32r	a8, 42000e0c <_stext+0xdec> (40376b88 <__retarget_lock_release_recursive>)
42012760:	0008e0        	callx8	a8
42012763:	982182        	l32i	a8, a1, 0x260
42012766:	061882        	l16ui	a8, a8, 12
42012769:	0f6867        	bbci	a8, 6, 4201277c <_vfiprintf_r+0x1c5c>
4201276c:	f90746        	j	42010b8d <_vfiprintf_r+0x6d>
4201276f:	9a2192        	l32i	a9, a1, 0x268
42012772:	03ad      	mov.n	a10, a3
42012774:	180c      	movi.n	a8, 1
42012776:	a7f9d6        	bgez	a9, 420121f9 <_vfiprintf_r+0x16d9>
42012779:	feb746        	j	4201225a <_vfiprintf_r+0x173a>
4201277c:	9d2122        	l32i	a2, a1, 0x274
4201277f:	f01d      	retw.n
42012781:	000000        	ill

42012784 <vfiprintf>:
42012784:	006136        	entry	a1, 48
42012787:	0149      	s32i.n	a4, a1, 0
42012789:	1159      	s32i.n	a5, a1, 4
4201278b:	026162        	s32i	a6, a1, 8
4201278e:	b9a281        	l32r	a8, 42000e18 <_stext+0xdf8> (4037c780 <__getreent>)
42012791:	0008e0        	callx8	a8
42012794:	01d8      	l32i.n	a13, a1, 0
42012796:	11e8      	l32i.n	a14, a1, 4
42012798:	21f8      	l32i.n	a15, a1, 8
4201279a:	02bd      	mov.n	a11, a2
4201279c:	03cd      	mov.n	a12, a3
4201279e:	fe3825        	call8	42010b20 <_vfiprintf_r>
420127a1:	0a2d      	mov.n	a2, a10
420127a3:	f01d      	retw.n
420127a5:	000000        	ill

420127a8 <__sbprintf>:
420127a8:	024136        	entry	a1, 0x120
420127ab:	078d      	mov.n	a8, a7
420127ad:	027d      	mov.n	a7, a2
420127af:	f0a022        	movi	a2, 240
420127b2:	212a      	add.n	a2, a1, a2
420127b4:	2289      	s32i.n	a8, a2, 8
420127b6:	061382        	l16ui	a8, a3, 12
420127b9:	d97c      	movi.n	a9, -3
420127bb:	108890        	and	a8, a8, a9
420127be:	465182        	s16i	a8, a1, 140
420127c1:	192382        	l32i	a8, a3, 100
420127c4:	1269      	s32i.n	a6, a2, 4
420127c6:	396182        	s32i	a8, a1, 228
420127c9:	071382        	l16ui	a8, a3, 14
420127cc:	80a062        	movi	a6, 128
420127cf:	475182        	s16i	a8, a1, 142
420127d2:	8388      	l32i.n	a8, a3, 32
420127d4:	226162        	s32i	a6, a1, 136
420127d7:	286182        	s32i	a8, a1, 160
420127da:	a388      	l32i.n	a8, a3, 40
420127dc:	256162        	s32i	a6, a1, 148
420127df:	616a      	add.n	a6, a1, a6
420127e1:	0259      	s32i.n	a5, a2, 0
420127e3:	2a6182        	s32i	a8, a1, 168
420127e6:	58c6a2        	addi	a10, a6, 88
420127e9:	080c      	movi.n	a8, 0
420127eb:	266182        	s32i	a8, a1, 152
420127ee:	206112        	s32i	a1, a1, 128
420127f1:	246112        	s32i	a1, a1, 144
420127f4:	b99381        	l32r	a8, 42000e40 <_stext+0xe20> (40376ab0 <__retarget_lock_init_recursive>)
420127f7:	0008e0        	callx8	a8
420127fa:	02d8      	l32i.n	a13, a2, 0
420127fc:	12e8      	l32i.n	a14, a2, 4
420127fe:	22f8      	l32i.n	a15, a2, 8
42012800:	04cd      	mov.n	a12, a4
42012802:	06bd      	mov.n	a11, a6
42012804:	07ad      	mov.n	a10, a7
42012806:	fe31a5        	call8	42010b20 <_vfiprintf_r>
42012809:	0a2d      	mov.n	a2, a10
4201280b:	00ea96        	bltz	a10, 4201281d <__sbprintf+0x75>
4201280e:	06bd      	mov.n	a11, a6
42012810:	07ad      	mov.n	a10, a7
42012812:	201110        	or	a1, a1, a1
42012815:	fa3de5        	call8	4200cbf4 <_fflush_r>
42012818:	f87c      	movi.n	a8, -1
4201281a:	9328a0        	movnez	a2, a8, a10
4201281d:	461182        	l16ui	a8, a1, 140
42012820:	094c      	movi.n	a9, 64
42012822:	080897        	bnone	a8, a9, 4201282e <__sbprintf+0x86>
42012825:	061382        	l16ui	a8, a3, 12
42012828:	208890        	or	a8, a8, a9
4201282b:	065382        	s16i	a8, a3, 12
4201282e:	3621a2        	l32i	a10, a1, 216
42012831:	b97881        	l32r	a8, 42000e14 <_stext+0xdf4> (40376ad4 <__retarget_lock_close_recursive>)
42012834:	0008e0        	callx8	a8
42012837:	f01d      	retw.n
42012839:	000000        	ill

4201283c <__swhatbuf_r>:
4201283c:	010136        	entry	a1, 128
4201283f:	0793b2        	l16si	a11, a3, 14
42012842:	20a220        	or	a10, a2, a2
42012845:	018bd6        	bgez	a11, 42012861 <__swhatbuf_r+0x25>
42012848:	061392        	l16ui	a9, a3, 12
4201284b:	080c      	movi.n	a8, 0
4201284d:	0589      	s32i.n	a8, a5, 0
4201284f:	049790        	extui	a9, a9, 7, 1
42012852:	0a4c      	movi.n	a10, 64
42012854:	80a082        	movi	a8, 128
42012857:	938a90        	movnez	a8, a10, a9
4201285a:	0489      	s32i.n	a8, a4, 0
4201285c:	020c      	movi.n	a2, 0
4201285e:	0010c6        	j	420128a5 <__swhatbuf_r+0x69>
42012861:	01cd      	mov.n	a12, a1
42012863:	201110        	or	a1, a1, a1
42012866:	f395a5        	call8	420061c0 <_fstat_r>
42012869:	fdba96        	bltz	a10, 42012848 <__swhatbuf_r+0xc>
4201286c:	1188      	l32i.n	a8, a1, 4
4201286e:	348c80        	extui	a8, a8, 12, 4
42012871:	118840        	slli	a8, a8, 12
42012874:	e0d892        	addmi	a9, a8, 0xffffe000
42012877:	40f990        	nsau	a9, a9
4201287a:	419590        	srli	a9, a9, 5
4201287d:	0599      	s32i.n	a9, a5, 0
4201287f:	122192        	l32i	a9, a1, 72
42012882:	1719a6        	blti	a9, 1, 4201289d <__swhatbuf_r+0x61>
42012885:	0499      	s32i.n	a9, a4, 0
42012887:	146392        	s32i	a9, a3, 80
4201288a:	190c      	movi.n	a9, 1
4201288c:	119910        	slli	a9, a9, 15
4201288f:	00a422        	movi	a2, 0x400
42012892:	0f1897        	beq	a8, a9, 420128a5 <__swhatbuf_r+0x69>
42012895:	120c      	movi.n	a2, 1
42012897:	112250        	slli	a2, a2, 11
4201289a:	0001c6        	j	420128a5 <__swhatbuf_r+0x69>
4201289d:	80a082        	movi	a8, 128
420128a0:	0489      	s32i.n	a8, a4, 0
420128a2:	fffbc6        	j	42012895 <__swhatbuf_r+0x59>
420128a5:	f01d      	retw.n
	...

420128a8 <__smakebuf_r>:
420128a8:	006136        	entry	a1, 48
420128ab:	061382        	l16ui	a8, a3, 12
420128ae:	250c      	movi.n	a5, 2
420128b0:	020857        	bnone	a8, a5, 420128b6 <__smakebuf_r+0xe>
420128b3:	000b06        	j	420128e3 <__smakebuf_r+0x3b>
420128b6:	01dd      	mov.n	a13, a1
420128b8:	c14b      	addi.n	a12, a1, 4
420128ba:	03bd      	mov.n	a11, a3
420128bc:	20a220        	or	a10, a2, a2
420128bf:	fff7e5        	call8	4201283c <__swhatbuf_r>
420128c2:	1168      	l32i.n	a6, a1, 4
420128c4:	0a7d      	mov.n	a7, a10
420128c6:	06bd      	mov.n	a11, a6
420128c8:	02ad      	mov.n	a10, a2
420128ca:	b96281        	l32r	a8, 42000e54 <_stext+0xe34> (4037fee8 <_malloc_r>)
420128cd:	0008e0        	callx8	a8
420128d0:	069382        	l16si	a8, a3, 12
420128d3:	aadc      	bnez.n	a10, 420128f1 <__smakebuf_r+0x49>
420128d5:	54e897        	bbsi	a8, 9, 4201292d <__smakebuf_r+0x85>
420128d8:	c97c      	movi.n	a9, -4
420128da:	108890        	and	a8, a8, a9
420128dd:	208850        	or	a8, a8, a5
420128e0:	065382        	s16i	a8, a3, 12
420128e3:	47c382        	addi	a8, a3, 71
420128e6:	0389      	s32i.n	a8, a3, 0
420128e8:	4389      	s32i.n	a8, a3, 16
420128ea:	180c      	movi.n	a8, 1
420128ec:	5389      	s32i.n	a8, a3, 20
420128ee:	000ec6        	j	4201292d <__smakebuf_r+0x85>
420128f1:	80a092        	movi	a9, 128
420128f4:	208890        	or	a8, a8, a9
420128f7:	065382        	s16i	a8, a3, 12
420128fa:	0188      	l32i.n	a8, a1, 0
420128fc:	03a9      	s32i.n	a10, a3, 0
420128fe:	43a9      	s32i.n	a10, a3, 16
42012900:	056362        	s32i	a6, a3, 20
42012903:	01d816        	beqz	a8, 42012924 <__smakebuf_r+0x7c>
42012906:	0793b2        	l16si	a11, a3, 14
42012909:	20a220        	or	a10, a2, a2
4201290c:	201110        	or	a1, a1, a1
4201290f:	03d0e5        	call8	4201661c <_getpid_r>
42012912:	ea8c      	beqz.n	a10, 42012924 <__smakebuf_r+0x7c>
42012914:	061382        	l16ui	a8, a3, 12
42012917:	c97c      	movi.n	a9, -4
42012919:	108890        	and	a8, a8, a9
4201291c:	190c      	movi.n	a9, 1
4201291e:	208890        	or	a8, a8, a9
42012921:	065382        	s16i	a8, a3, 12
42012924:	061382        	l16ui	a8, a3, 12
42012927:	207780        	or	a7, a7, a8
4201292a:	065372        	s16i	a7, a3, 12
4201292d:	f01d      	retw.n
	...

42012930 <__localeconv_l>:
42012930:	004136        	entry	a1, 32
42012933:	f0a082        	movi	a8, 240
42012936:	228a      	add.n	a2, a2, a8
42012938:	f01d      	retw.n
	...

4201293c <_localeconv_r>:
4201293c:	004136        	entry	a1, 32
4201293f:	b97581        	l32r	a8, 42000f14 <_stext+0xef4> (3fc92ba4 <__global_locale_ptr>)
42012942:	0828      	l32i.n	a2, a8, 0
42012944:	f0a082        	movi	a8, 240
42012947:	228a      	add.n	a2, a2, a8
42012949:	f01d      	retw.n
	...

4201294c <localeconv>:
4201294c:	004136        	entry	a1, 32
4201294f:	b97181        	l32r	a8, 42000f14 <_stext+0xef4> (3fc92ba4 <__global_locale_ptr>)
42012952:	0828      	l32i.n	a2, a8, 0
42012954:	f0a082        	movi	a8, 240
42012957:	228a      	add.n	a2, a2, a8
42012959:	f01d      	retw.n
	...

4201295c <frexp>:
4201295c:	004136        	entry	a1, 32
4201295f:	0c0c      	movi.n	a12, 0
42012961:	833a      	add.n	a8, a3, a3
42012963:	04c9      	s32i.n	a12, a4, 0
42012965:	b957c1        	l32r	a12, 42000ec4 <_stext+0xea4> (7fefffff <_rtc_reserved_end+0x1fdfffff>)
42012968:	418180        	srli	a8, a8, 1
4201296b:	02ad      	mov.n	a10, a2
4201296d:	03bd      	mov.n	a11, a3
4201296f:	039d      	mov.n	a9, a3
42012971:	403c87        	bltu	a12, a8, 420129b5 <frexp+0x59>
42012974:	20c820        	or	a12, a8, a2
42012977:	acbc      	beqz.n	a12, 420129b5 <frexp+0x59>
42012979:	a5c430        	extui	a12, a3, 20, 11
4201297c:	8cdc      	bnez.n	a12, 42012998 <frexp+0x3c>
4201297e:	35a4d2        	movi	a13, 0x435
42012981:	0c0c      	movi.n	a12, 0
42012983:	01ddc0        	slli	a13, a13, 20
42012986:	b95381        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012989:	0008e0        	callx8	a8
4201298c:	8bba      	add.n	a8, a11, a11
4201298e:	caafc2        	movi	a12, -54
42012991:	0b9d      	mov.n	a9, a11
42012993:	418180        	srli	a8, a8, 1
42012996:	04c9      	s32i.n	a12, a4, 0
42012998:	02acc2        	movi	a12, 0xfffffc02
4201299b:	318480        	srai	a8, a8, 20
4201299e:	88ca      	add.n	a8, a8, a12
420129a0:	04c8      	l32i.n	a12, a4, 0
420129a2:	8c8a      	add.n	a8, a12, a8
420129a4:	0489      	s32i.n	a8, a4, 0
420129a6:	b95c81        	l32r	a8, 42000f18 <_stext+0xef8> (800fffff <_rtc_reserved_end+0x1fffffff>)
420129a9:	109980        	and	a9, a9, a8
420129ac:	ffa182        	movi	a8, 0x1ff
420129af:	0188b0        	slli	a8, a8, 21
420129b2:	20b980        	or	a11, a9, a8
420129b5:	0a2d      	mov.n	a2, a10
420129b7:	0b3d      	mov.n	a3, a11
420129b9:	f01d      	retw.n
	...

420129bc <quorem>:
420129bc:	006136        	entry	a1, 48
420129bf:	4288      	l32i.n	a8, a2, 16
420129c1:	4378      	l32i.n	a7, a3, 16
420129c3:	025d      	mov.n	a5, a2
420129c5:	03bd      	mov.n	a11, a3
420129c7:	020c      	movi.n	a2, 0
420129c9:	02a877        	bge	a8, a7, 420129cf <quorem+0x13>
420129cc:	004886        	j	42012af2 <quorem+0x136>
420129cf:	770b      	addi.n	a7, a7, -1
420129d1:	1187e0        	slli	a8, a7, 2
420129d4:	14c362        	addi	a6, a3, 20
420129d7:	368a      	add.n	a3, a6, a8
420129d9:	14c542        	addi	a4, a5, 20
420129dc:	0398      	l32i.n	a9, a3, 0
420129de:	a48a      	add.n	a10, a4, a8
420129e0:	0ac8      	l32i.n	a12, a10, 0
420129e2:	991b      	addi.n	a9, a9, 1
420129e4:	c22c90        	quou	a2, a12, a9
420129e7:	02bc97        	bgeu	a12, a9, 420129ed <quorem+0x31>
420129ea:	002386        	j	42012a7c <quorem+0xc0>
420129ed:	090c      	movi.n	a9, 0
420129ef:	1199      	s32i.n	a9, a1, 4
420129f1:	0199      	s32i.n	a9, a1, 0
420129f3:	8b8a      	add.n	a8, a11, a8
420129f5:	c09360        	sub	a9, a3, a6
420129f8:	419290        	srli	a9, a9, 2
420129fb:	18cbc2        	addi	a12, a11, 24
420129fe:	18c882        	addi	a8, a8, 24
42012a01:	04dd      	mov.n	a13, a4
42012a03:	06ed      	mov.n	a14, a6
42012a05:	991b      	addi.n	a9, a9, 1
42012a07:	02b8c7        	bgeu	a8, a12, 42012a0d <quorem+0x51>
42012a0a:	01a092        	movi	a9, 1
42012a0d:	4e8976        	loop	a9, 42012a5f <quorem+0xa3>
42012a10:	0e88      	l32i.n	a8, a14, 0
42012a12:	11f8      	l32i.n	a15, a1, 4
42012a14:	f4c080        	extui	a12, a8, 0, 16
42012a17:	82cc20        	mull	a12, a12, a2
42012a1a:	f58080        	extui	a8, a8, 16, 16
42012a1d:	ccfa      	add.n	a12, a12, a15
42012a1f:	828820        	mull	a8, a8, a2
42012a22:	f5f0c0        	extui	a15, a12, 16, 16
42012a25:	88fa      	add.n	a8, a8, a15
42012a27:	f5f080        	extui	a15, a8, 16, 16
42012a2a:	11f9      	s32i.n	a15, a1, 4
42012a2c:	0df8      	l32i.n	a15, a13, 0
42012a2e:	f4c0c0        	extui	a12, a12, 0, 16
42012a31:	f4f0f0        	extui	a15, a15, 0, 16
42012a34:	c0ffc0        	sub	a15, a15, a12
42012a37:	01c8      	l32i.n	a12, a1, 0
42012a39:	f48080        	extui	a8, a8, 0, 16
42012a3c:	ffca      	add.n	a15, a15, a12
42012a3e:	0dc8      	l32i.n	a12, a13, 0
42012a40:	ee4b      	addi.n	a14, a14, 4
42012a42:	f5c0c0        	extui	a12, a12, 16, 16
42012a45:	c08c80        	sub	a8, a12, a8
42012a48:	31c0f0        	srai	a12, a15, 16
42012a4b:	88ca      	add.n	a8, a8, a12
42012a4d:	31c080        	srai	a12, a8, 16
42012a50:	f4f0f0        	extui	a15, a15, 0, 16
42012a53:	118800        	slli	a8, a8, 16
42012a56:	2088f0        	or	a8, a8, a15
42012a59:	0d89      	s32i.n	a8, a13, 0
42012a5b:	01c9      	s32i.n	a12, a1, 0
42012a5d:	dd4b      	addi.n	a13, a13, 4
42012a5f:	0a88      	l32i.n	a8, a10, 0
42012a61:	388c      	beqz.n	a8, 42012a68 <quorem+0xac>
42012a63:	000546        	j	42012a7c <quorem+0xc0>
42012a66:	770b      	addi.n	a7, a7, -1
42012a68:	fccaa2        	addi	a10, a10, -4
42012a6b:	0534a7        	bltu	a4, a10, 42012a74 <quorem+0xb8>
42012a6e:	4579      	s32i.n	a7, a5, 16
42012a70:	000206        	j	42012a7c <quorem+0xc0>
42012a73:	0a8800        	add.s	f8, f8, f0
42012a76:	fec816        	beqz	a8, 42012a66 <quorem+0xaa>
42012a79:	fffc46        	j	42012a6e <quorem+0xb2>
42012a7c:	05ad      	mov.n	a10, a5
42012a7e:	201110        	or	a1, a1, a1
42012a81:	012fe5        	call8	42013d80 <__mcmp>
42012a84:	06aa96        	bltz	a10, 42012af2 <quorem+0x136>
42012a87:	c09360        	sub	a9, a3, a6
42012a8a:	419290        	srli	a9, a9, 2
42012a8d:	864b      	addi.n	a8, a6, 4
42012a8f:	334b      	addi.n	a3, a3, 4
42012a91:	04ad      	mov.n	a10, a4
42012a93:	0c0c      	movi.n	a12, 0
42012a95:	991b      	addi.n	a9, a9, 1
42012a97:	02b387        	bgeu	a3, a8, 42012a9d <quorem+0xe1>
42012a9a:	01a092        	movi	a9, 1
42012a9d:	2e8976        	loop	a9, 42012acf <quorem+0x113>
42012aa0:	06d8      	l32i.n	a13, a6, 0
42012aa2:	0a88      	l32i.n	a8, a10, 0
42012aa4:	f4e0d0        	extui	a14, a13, 0, 16
42012aa7:	f4b080        	extui	a11, a8, 0, 16
42012aaa:	c0bbe0        	sub	a11, a11, a14
42012aad:	bbca      	add.n	a11, a11, a12
42012aaf:	f58080        	extui	a8, a8, 16, 16
42012ab2:	f5d0d0        	extui	a13, a13, 16, 16
42012ab5:	31c0b0        	srai	a12, a11, 16
42012ab8:	c088d0        	sub	a8, a8, a13
42012abb:	88ca      	add.n	a8, a8, a12
42012abd:	31c080        	srai	a12, a8, 16
42012ac0:	f4b0b0        	extui	a11, a11, 0, 16
42012ac3:	118800        	slli	a8, a8, 16
42012ac6:	2088b0        	or	a8, a8, a11
42012ac9:	0a89      	s32i.n	a8, a10, 0
42012acb:	664b      	addi.n	a6, a6, 4
42012acd:	aa4b      	addi.n	a10, a10, 4
42012acf:	a08740        	addx4	a8, a7, a4
42012ad2:	0898      	l32i.n	a9, a8, 0
42012ad4:	498c      	beqz.n	a9, 42012adc <quorem+0x120>
42012ad6:	000586        	j	42012af0 <quorem+0x134>
42012ad9:	770b00        	ee.stf.64.xp	f0, f7, a0, a11
42012adc:	fcc882        	addi	a8, a8, -4
42012adf:	053487        	bltu	a4, a8, 42012ae8 <quorem+0x12c>
42012ae2:	4579      	s32i.n	a7, a5, 16
42012ae4:	000206        	j	42012af0 <quorem+0x134>
42012ae7:	089800        	lsx	f9, a8, a0
42012aea:	fec916        	beqz	a9, 42012ada <quorem+0x11e>
42012aed:	fffc46        	j	42012ae2 <quorem+0x126>
42012af0:	221b      	addi.n	a2, a2, 1
42012af2:	f01d      	retw.n

42012af4 <_dtoa_r>:
42012af4:	012136        	entry	a1, 144
42012af7:	92a8      	l32i.n	a10, a2, 36
42012af9:	c169      	s32i.n	a6, a1, 48
42012afb:	4129      	s32i.n	a2, a1, 16
42012afd:	146172        	s32i	a7, a1, 80
42012b00:	126142        	s32i	a4, a1, 72
42012b03:	136152        	s32i	a5, a1, 76
42012b06:	252162        	l32i	a6, a1, 148
42012b09:	3aec      	bnez.n	a10, 42012b30 <_dtoa_r+0x3c>
42012b0b:	10a0a2        	movi	a10, 16
42012b0e:	b72b81        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
42012b11:	0008e0        	callx8	a8
42012b14:	4188      	l32i.n	a8, a1, 16
42012b16:	98a9      	s32i.n	a10, a8, 36
42012b18:	aacc      	bnez.n	a10, 42012b26 <_dtoa_r+0x32>
42012b1a:	b905d1        	l32r	a13, 42000f30 <_stext+0xf10> (3c028725 <blanks$1+0x51>)
42012b1d:	0c0c      	movi.n	a12, 0
42012b1f:	efa0b2        	movi	a11, 239
42012b22:	00ab86        	j	42012dd4 <_dtoa_r+0x2e0>
42012b25:	080c00        	lsx	f0, a12, a0
42012b28:	1a89      	s32i.n	a8, a10, 4
42012b2a:	2a89      	s32i.n	a8, a10, 8
42012b2c:	0a89      	s32i.n	a8, a10, 0
42012b2e:	3a89      	s32i.n	a8, a10, 12
42012b30:	0ab8      	l32i.n	a11, a10, 0
42012b32:	cb9c      	beqz.n	a11, 42012b52 <_dtoa_r+0x5e>
42012b34:	1a98      	l32i.n	a9, a10, 4
42012b36:	180c      	movi.n	a8, 1
42012b38:	401900        	ssl	a9
42012b3b:	a18800        	sll	a8, a8
42012b3e:	41a8      	l32i.n	a10, a1, 16
42012b40:	1b99      	s32i.n	a9, a11, 4
42012b42:	2b89      	s32i.n	a8, a11, 8
42012b44:	201110        	or	a1, a1, a1
42012b47:	00cca5        	call8	42013810 <_Bfree>
42012b4a:	4188      	l32i.n	a8, a1, 16
42012b4c:	090c      	movi.n	a9, 0
42012b4e:	9888      	l32i.n	a8, a8, 36
42012b50:	0899      	s32i.n	a9, a8, 0
42012b52:	053d      	mov.n	a3, a5
42012b54:	00e5d6        	bgez	a5, 42012b66 <_dtoa_r+0x72>
42012b57:	355a      	add.n	a3, a5, a5
42012b59:	180c      	movi.n	a8, 1
42012b5b:	413130        	srli	a3, a3, 1
42012b5e:	0689      	s32i.n	a8, a6, 0
42012b60:	136132        	s32i	a3, a1, 76
42012b63:	0000c6        	j	42012b6a <_dtoa_r+0x76>
42012b66:	080c      	movi.n	a8, 0
42012b68:	0689      	s32i.n	a8, a6, 0
42012b6a:	ffa782        	movi	a8, 0x7ff
42012b6d:	0188c0        	slli	a8, a8, 20
42012b70:	28c387        	bnall	a3, a8, 42012b9c <_dtoa_r+0xa8>
42012b73:	242192        	l32i	a9, a1, 144
42012b76:	f80c      	movi.n	a8, 15
42012b78:	113340        	slli	a3, a3, 12
42012b7b:	27d882        	addmi	a8, a8, 0x2700
42012b7e:	413c30        	srli	a3, a3, 12
42012b81:	0989      	s32i.n	a8, a9, 0
42012b83:	203340        	or	a3, a3, a4
42012b86:	13cc      	bnez.n	a3, 42012b8b <_dtoa_r+0x97>
42012b88:	02f206        	j	42013754 <_dtoa_r+0xc60>
42012b8b:	02f5c6        	j	42013766 <_dtoa_r+0xc72>
42012b8e:	000000        	ill
42012b91:	b8e581        	l32r	a8, 42000f28 <_stext+0xf08> (3c028724 <blanks$1+0x50>)
42012b94:	262192        	l32i	a9, a1, 152
42012b97:	0989      	s32i.n	a8, a9, 0
42012b99:	02fa06        	j	42013785 <_dtoa_r+0xc91>
42012b9c:	122182        	l32i	a8, a1, 72
42012b9f:	132192        	l32i	a9, a1, 76
42012ba2:	e189      	s32i.n	a8, a1, 56
42012ba4:	f199      	s32i.n	a9, a1, 60
42012ba6:	e1a8      	l32i.n	a10, a1, 56
42012ba8:	f1b8      	l32i.n	a11, a1, 60
42012baa:	00a0c2        	movi	a12, 0
42012bad:	00a0d2        	movi	a13, 0
42012bb0:	b8ca81        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
42012bb3:	0008e0        	callx8	a8
42012bb6:	8adc      	bnez.n	a10, 42012bd2 <_dtoa_r+0xde>
42012bb8:	242192        	l32i	a9, a1, 144
42012bbb:	180c      	movi.n	a8, 1
42012bbd:	0989      	s32i.n	a8, a9, 0
42012bbf:	262182        	l32i	a8, a1, 152
42012bc2:	688c      	beqz.n	a8, 42012bcc <_dtoa_r+0xd8>
42012bc4:	b8dd81        	l32r	a8, 42000f38 <_stext+0xf18> (3c028717 <blanks$1+0x43>)
42012bc7:	262192        	l32i	a9, a1, 152
42012bca:	0989      	s32i.n	a8, a9, 0
42012bcc:	b8d821        	l32r	a2, 42000f2c <_stext+0xf0c> (3c028716 <blanks$1+0x42>)
42012bcf:	02ec86        	j	42013785 <_dtoa_r+0xc91>
42012bd2:	e1c8      	l32i.n	a12, a1, 56
42012bd4:	f1d8      	l32i.n	a13, a1, 60
42012bd6:	41a8      	l32i.n	a10, a1, 16
42012bd8:	f14b      	addi.n	a15, a1, 4
42012bda:	01ed      	mov.n	a14, a1
42012bdc:	201110        	or	a1, a1, a1
42012bdf:	014025        	call8	42013fe0 <__d2b>
42012be2:	51a9      	s32i.n	a10, a1, 20
42012be4:	b59430        	extui	a9, a3, 20, 12
42012be7:	1168      	l32i.n	a6, a1, 4
42012be9:	899c      	beqz.n	a9, 42012c05 <_dtoa_r+0x111>
42012beb:	f188      	l32i.n	a8, a1, 60
42012bed:	b8d3a1        	l32r	a10, 42000f3c <_stext+0xf1c> (3ff00000 <ets_ops_table_ptr+0x210004>)
42012bf0:	118840        	slli	a8, a8, 12
42012bf3:	418c80        	srli	a8, a8, 12
42012bf6:	2088a0        	or	a8, a8, a10
42012bf9:	01aca2        	movi	a10, 0xfffffc01
42012bfc:	59aa      	add.n	a5, a9, a10
42012bfe:	e1a8      	l32i.n	a10, a1, 56
42012c00:	090c      	movi.n	a9, 0
42012c02:	0011c6        	j	42012c4d <_dtoa_r+0x159>
42012c05:	0128      	l32i.n	a2, a1, 0
42012c07:	32a4a2        	movi	a10, 0x432
42012c0a:	262a      	add.n	a2, a6, a2
42012c0c:	a2aa      	add.n	a10, a2, a10
42012c0e:	082c      	movi.n	a8, 32
42012c10:	1ca8a7        	bge	a8, a10, 42012c30 <_dtoa_r+0x13c>
42012c13:	c0caa2        	addi	a10, a10, -64
42012c16:	60a0a0        	neg	a10, a10
42012c19:	12c282        	addi	a8, a2, 18
42012c1c:	401a00        	ssl	a10
42012c1f:	a13300        	sll	a3, a3
42012c22:	400800        	ssr	a8
42012c25:	918040        	srl	a8, a4
42012c28:	20a380        	or	a10, a3, a8
42012c2b:	000346        	j	42012c3c <_dtoa_r+0x148>
42012c2e:	a20000        	muluh	a0, a0, a0
42012c31:	e0ca      	add.n	a14, a0, a12
42012c33:	60a0a0        	neg	a10, a10
42012c36:	401a00        	ssl	a10
42012c39:	a1a400        	sll	a10, a4
42012c3c:	b8cd81        	l32r	a8, 42000f70 <_stext+0xf50> (40002364 <__floatunsidf>)
42012c3f:	0008e0        	callx8	a8
42012c42:	186c      	movi.n	a8, -31
42012c44:	0188c0        	slli	a8, a8, 20
42012c47:	88ba      	add.n	a8, a8, a11
42012c49:	520b      	addi.n	a5, a2, -1
42012c4b:	190c      	movi.n	a9, 1
42012c4d:	ffa7d2        	movi	a13, 0x7ff
42012c50:	186192        	s32i	a9, a1, 96
42012c53:	08bd      	mov.n	a11, a8
42012c55:	0c0c      	movi.n	a12, 0
42012c57:	01ddd0        	slli	a13, a13, 19
42012c5a:	b8a281        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
42012c5d:	0008e0        	callx8	a8
42012c60:	b8bec1        	l32r	a12, 42000f58 <_stext+0xf38> (636f4361 <_rtc_reserved_end+0x35f4361>)
42012c63:	b8bed1        	l32r	a13, 42000f5c <_stext+0xf3c> (3fd287a7 <ets_ops_table_ptr+0x387ab>)
42012c66:	b89b81        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012c69:	0008e0        	callx8	a8
42012c6c:	b8bdc1        	l32r	a12, 42000f60 <_stext+0xf40> (8b60c8b3 <_rtc_reserved_end+0x2b50c8b3>)
42012c6f:	b8bdd1        	l32r	a13, 42000f64 <_stext+0xf44> (3fc68a28 <_esp_system_init_fn_array_end+0x3c3f784>)
42012c72:	b8c081        	l32r	a8, 42000f74 <_stext+0xf54> (40002184 <__adddf3>)
42012c75:	0008e0        	callx8	a8
42012c78:	0a2d      	mov.n	a2, a10
42012c7a:	05ad      	mov.n	a10, a5
42012c7c:	0b3d      	mov.n	a3, a11
42012c7e:	b89881        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
42012c81:	0008e0        	callx8	a8
42012c84:	b8b9c1        	l32r	a12, 42000f68 <_stext+0xf48> (509f79fb <_rtc_bss_end+0x9f79fb>)
42012c87:	b8b9d1        	l32r	a13, 42000f6c <_stext+0xf4c> (3fd34413 <ets_ops_table_ptr+0x44417>)
42012c8a:	b89281        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012c8d:	0008e0        	callx8	a8
42012c90:	0acd      	mov.n	a12, a10
42012c92:	0bdd      	mov.n	a13, a11
42012c94:	02ad      	mov.n	a10, a2
42012c96:	03bd      	mov.n	a11, a3
42012c98:	b8b781        	l32r	a8, 42000f74 <_stext+0xf54> (40002184 <__adddf3>)
42012c9b:	0008e0        	callx8	a8
42012c9e:	71b9      	s32i.n	a11, a1, 28
42012ca0:	61a9      	s32i.n	a10, a1, 24
42012ca2:	b88e81        	l32r	a8, 42000edc <_stext+0xebc> (400022d4 <__fixdfsi>)
42012ca5:	0008e0        	callx8	a8
42012ca8:	0a3d      	mov.n	a3, a10
42012caa:	71b8      	l32i.n	a11, a1, 28
42012cac:	61a8      	l32i.n	a10, a1, 24
42012cae:	0c0c      	movi.n	a12, 0
42012cb0:	00a0d2        	movi	a13, 0
42012cb3:	b88781        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
42012cb6:	0008e0        	callx8	a8
42012cb9:	015ad6        	bgez	a10, 42012cd2 <_dtoa_r+0x1de>
42012cbc:	03ad      	mov.n	a10, a3
42012cbe:	b88881        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
42012cc1:	0008e0        	callx8	a8
42012cc4:	61c8      	l32i.n	a12, a1, 24
42012cc6:	71d8      	l32i.n	a13, a1, 28
42012cc8:	b88881        	l32r	a8, 42000ee8 <_stext+0xec8> (4000246c <__nedf2>)
42012ccb:	0008e0        	callx8	a8
42012cce:	0a8c      	beqz.n	a10, 42012cd2 <_dtoa_r+0x1de>
42012cd0:	330b      	addi.n	a3, a3, -1
42012cd2:	190c      	movi.n	a9, 1
42012cd4:	681c      	movi.n	a8, 22
42012cd6:	156192        	s32i	a9, a1, 84
42012cd9:	1d3837        	bltu	a8, a3, 42012cfa <_dtoa_r+0x206>
42012cdc:	b89981        	l32r	a8, 42000f40 <_stext+0xf20> (3c028aa0 <__mprec_tens>)
42012cdf:	e1a8      	l32i.n	a10, a1, 56
42012ce1:	b08380        	addx8	a8, a3, a8
42012ce4:	08c8      	l32i.n	a12, a8, 0
42012ce6:	18d8      	l32i.n	a13, a8, 4
42012ce8:	f1b8      	l32i.n	a11, a1, 60
42012cea:	b87981        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
42012ced:	0008e0        	callx8	a8
42012cf0:	001ad6        	bgez	a10, 42012cf5 <_dtoa_r+0x201>
42012cf3:	330b      	addi.n	a3, a3, -1
42012cf5:	080c      	movi.n	a8, 0
42012cf7:	156182        	s32i	a8, a1, 84
42012cfa:	c06650        	sub	a6, a6, a5
42012cfd:	860b      	addi.n	a8, a6, -1
42012cff:	a189      	s32i.n	a8, a1, 40
42012d01:	040c      	movi.n	a4, 0
42012d03:	0068d6        	bgez	a8, 42012d0d <_dtoa_r+0x219>
42012d06:	604080        	neg	a4, a8
42012d09:	080c      	movi.n	a8, 0
42012d0b:	a189      	s32i.n	a8, a1, 40
42012d0d:	00f396        	bltz	a3, 42012d20 <_dtoa_r+0x22c>
42012d10:	a188      	l32i.n	a8, a1, 40
42012d12:	116132        	s32i	a3, a1, 68
42012d15:	883a      	add.n	a8, a8, a3
42012d17:	a189      	s32i.n	a8, a1, 40
42012d19:	080c      	movi.n	a8, 0
42012d1b:	d189      	s32i.n	a8, a1, 52
42012d1d:	000306        	j	42012d2d <_dtoa_r+0x239>
42012d20:	608030        	neg	a8, a3
42012d23:	d189      	s32i.n	a8, a1, 52
42012d25:	080c      	movi.n	a8, 0
42012d27:	c04430        	sub	a4, a4, a3
42012d2a:	116182        	s32i	a8, a1, 68
42012d2d:	c198      	l32i.n	a9, a1, 48
42012d2f:	980c      	movi.n	a8, 9
42012d31:	150c      	movi.n	a5, 1
42012d33:	4e3897        	bltu	a8, a9, 42012d85 <_dtoa_r+0x291>
42012d36:	0669a6        	blti	a9, 6, 42012d40 <_dtoa_r+0x24c>
42012d39:	fcc982        	addi	a8, a9, -4
42012d3c:	c189      	s32i.n	a8, a1, 48
42012d3e:	050c      	movi.n	a5, 0
42012d40:	c188      	l32i.n	a8, a1, 48
42012d42:	124826        	beqi	a8, 4, 42012d58 <_dtoa_r+0x264>
42012d45:	255826        	beqi	a8, 5, 42012d6e <_dtoa_r+0x27a>
42012d48:	112826        	beqi	a8, 2, 42012d5d <_dtoa_r+0x269>
42012d4b:	080c      	movi.n	a8, 0
42012d4d:	106182        	s32i	a8, a1, 64
42012d50:	c188      	l32i.n	a8, a1, 48
42012d52:	1d3826        	beqi	a8, 3, 42012d73 <_dtoa_r+0x27f>
42012d55:	000c06        	j	42012d89 <_dtoa_r+0x295>
42012d58:	180c      	movi.n	a8, 1
42012d5a:	000046        	j	42012d5f <_dtoa_r+0x26b>
42012d5d:	080c      	movi.n	a8, 0
42012d5f:	106182        	s32i	a8, a1, 64
42012d62:	3617a6        	blti	a7, 1, 42012d9c <_dtoa_r+0x2a8>
42012d65:	b179      	s32i.n	a7, a1, 44
42012d67:	078d      	mov.n	a8, a7
42012d69:	8179      	s32i.n	a7, a1, 32
42012d6b:	000e06        	j	42012da7 <_dtoa_r+0x2b3>
42012d6e:	180c      	movi.n	a8, 1
42012d70:	106182        	s32i	a8, a1, 64
42012d73:	837a      	add.n	a8, a3, a7
42012d75:	b189      	s32i.n	a8, a1, 44
42012d77:	881b      	addi.n	a8, a8, 1
42012d79:	8189      	s32i.n	a8, a1, 32
42012d7b:	8198      	l32i.n	a9, a1, 32
42012d7d:	180c      	movi.n	a8, 1
42012d7f:	538980        	max	a8, a9, a8
42012d82:	000846        	j	42012da7 <_dtoa_r+0x2b3>
42012d85:	080c      	movi.n	a8, 0
42012d87:	c189      	s32i.n	a8, a1, 48
42012d89:	180c      	movi.n	a8, 1
42012d8b:	106182        	s32i	a8, a1, 64
42012d8e:	f87c      	movi.n	a8, -1
42012d90:	b189      	s32i.n	a8, a1, 44
42012d92:	8189      	s32i.n	a8, a1, 32
42012d94:	090c      	movi.n	a9, 0
42012d96:	281c      	movi.n	a8, 18
42012d98:	000206        	j	42012da4 <_dtoa_r+0x2b0>
42012d9b:	180c00        	lsxp	f0, a12, a0
42012d9e:	b189      	s32i.n	a8, a1, 44
42012da0:	8189      	s32i.n	a8, a1, 32
42012da2:	190c      	movi.n	a9, 1
42012da4:	146192        	s32i	a9, a1, 80
42012da7:	4198      	l32i.n	a9, a1, 16
42012da9:	0b0c      	movi.n	a11, 0
42012dab:	99a8      	l32i.n	a10, a9, 36
42012dad:	490c      	movi.n	a9, 4
42012daf:	0000c6        	j	42012db6 <_dtoa_r+0x2c2>
42012db2:	999a      	add.n	a9, a9, a9
42012db4:	0dbd      	mov.n	a11, a13
42012db6:	14c9c2        	addi	a12, a9, 20
42012db9:	db1b      	addi.n	a13, a11, 1
42012dbb:	f3b8c7        	bgeu	a8, a12, 42012db2 <_dtoa_r+0x2be>
42012dbe:	1ab9      	s32i.n	a11, a10, 4
42012dc0:	41a8      	l32i.n	a10, a1, 16
42012dc2:	201110        	or	a1, a1, a1
42012dc5:	009c25        	call8	42013788 <_Balloc>
42012dc8:	0a2d      	mov.n	a2, a10
42012dca:	facc      	bnez.n	a10, 42012ddd <_dtoa_r+0x2e9>
42012dcc:	b85ed1        	l32r	a13, 42000f44 <_stext+0xf24> (3c028790 <blanks$1+0xbc>)
42012dcf:	0c0c      	movi.n	a12, 0
42012dd1:	afa1b2        	movi	a11, 0x1af
42012dd4:	b858a1        	l32r	a10, 42000f34 <_stext+0xf14> (3c02873c <blanks$1+0x68>)
42012dd7:	b4cc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42012dda:	0008e0        	callx8	a8
42012ddd:	4188      	l32i.n	a8, a1, 16
42012ddf:	e60c      	movi.n	a6, 14
42012de1:	9888      	l32i.n	a8, a8, 36
42012de3:	08a9      	s32i.n	a10, a8, 0
42012de5:	8188      	l32i.n	a8, a1, 32
42012de7:	626680        	saltu	a6, a6, a8
42012dea:	660b      	addi.n	a6, a6, -1
42012dec:	606060        	neg	a6, a6
42012def:	106650        	and	a6, a6, a5
42012df2:	348616        	beqz	a6, 4201313e <_dtoa_r+0x64a>
42012df5:	0213e6        	bgei	a3, 1, 42012dfb <_dtoa_r+0x307>
42012df8:	002086        	j	42012e7e <_dtoa_r+0x38a>
42012dfb:	b85191        	l32r	a9, 42000f40 <_stext+0xf20> (3c028aa0 <__mprec_tens>)
42012dfe:	348030        	extui	a8, a3, 0, 4
42012e01:	b08890        	addx8	a8, a8, a9
42012e04:	1898      	l32i.n	a9, a8, 4
42012e06:	e1e8      	l32i.n	a14, a1, 56
42012e08:	0888      	l32i.n	a8, a8, 0
42012e0a:	f1f8      	l32i.n	a15, a1, 60
42012e0c:	216430        	srai	a6, a3, 4
42012e0f:	270c      	movi.n	a7, 2
42012e11:	236387        	bbci	a3, 8, 42012e38 <_dtoa_r+0x344>
42012e14:	b84da1        	l32r	a10, 42000f48 <_stext+0xf28> (3c028a78 <__mprec_bigtens>)
42012e17:	6189      	s32i.n	a8, a1, 24
42012e19:	8ac8      	l32i.n	a12, a10, 32
42012e1b:	9ad8      	l32i.n	a13, a10, 36
42012e1d:	7199      	s32i.n	a9, a1, 28
42012e1f:	0ead      	mov.n	a10, a14
42012e21:	0fbd      	mov.n	a11, a15
42012e23:	b85581        	l32r	a8, 42000f78 <_stext+0xf58> (40002250 <__divdf3>)
42012e26:	0008e0        	callx8	a8
42012e29:	6188      	l32i.n	a8, a1, 24
42012e2b:	7198      	l32i.n	a9, a1, 28
42012e2d:	346060        	extui	a6, a6, 0, 4
42012e30:	0aed      	mov.n	a14, a10
42012e32:	20fbb0        	or	a15, a11, a11
42012e35:	03a072        	movi	a7, 3
42012e38:	b84451        	l32r	a5, 42000f48 <_stext+0xf28> (3c028a78 <__mprec_bigtens>)
42012e3b:	000986        	j	42012e65 <_dtoa_r+0x371>
42012e3e:	1e6607        	bbci	a6, 0, 42012e60 <_dtoa_r+0x36c>
42012e41:	05c8      	l32i.n	a12, a5, 0
42012e43:	15d8      	l32i.n	a13, a5, 4
42012e45:	61e9      	s32i.n	a14, a1, 24
42012e47:	71f9      	s32i.n	a15, a1, 28
42012e49:	20a880        	or	a10, a8, a8
42012e4c:	09bd      	mov.n	a11, a9
42012e4e:	b82181        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012e51:	0008e0        	callx8	a8
42012e54:	61e8      	l32i.n	a14, a1, 24
42012e56:	71f8      	l32i.n	a15, a1, 28
42012e58:	771b      	addi.n	a7, a7, 1
42012e5a:	208aa0        	or	a8, a10, a10
42012e5d:	209bb0        	or	a9, a11, a11
42012e60:	216160        	srai	a6, a6, 1
42012e63:	558b      	addi.n	a5, a5, 8
42012e65:	fd5656        	bnez	a6, 42012e3e <_dtoa_r+0x34a>
42012e68:	08cd      	mov.n	a12, a8
42012e6a:	09dd      	mov.n	a13, a9
42012e6c:	20aee0        	or	a10, a14, a14
42012e6f:	20bff0        	or	a11, a15, a15
42012e72:	b84181        	l32r	a8, 42000f78 <_stext+0xf58> (40002250 <__divdf3>)
42012e75:	0008e0        	callx8	a8
42012e78:	001686        	j	42012ed6 <_dtoa_r+0x3e2>
42012e7b:	000000        	ill
42012e7e:	e188      	l32i.n	a8, a1, 56
42012e80:	f198      	l32i.n	a9, a1, 60
42012e82:	6189      	s32i.n	a8, a1, 24
42012e84:	7199      	s32i.n	a9, a1, 28
42012e86:	270c      	movi.n	a7, 2
42012e88:	050316        	beqz	a3, 42012edc <_dtoa_r+0x3e8>
42012e8b:	b82d91        	l32r	a9, 42000f40 <_stext+0xf20> (3c028aa0 <__mprec_tens>)
42012e8e:	605030        	neg	a5, a3
42012e91:	348050        	extui	a8, a5, 0, 4
42012e94:	b08890        	addx8	a8, a8, a9
42012e97:	08c8      	l32i.n	a12, a8, 0
42012e99:	18d8      	l32i.n	a13, a8, 4
42012e9b:	e1a8      	l32i.n	a10, a1, 56
42012e9d:	f1b8      	l32i.n	a11, a1, 60
42012e9f:	215450        	srai	a5, a5, 4
42012ea2:	b80c81        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012ea5:	0008e0        	callx8	a8
42012ea8:	b82891        	l32r	a9, 42000f48 <_stext+0xf28> (3c028a78 <__mprec_bigtens>)
42012eab:	61a9      	s32i.n	a10, a1, 24
42012ead:	71b9      	s32i.n	a11, a1, 28
42012eaf:	080c      	movi.n	a8, 0
42012eb1:	000706        	j	42012ed1 <_dtoa_r+0x3dd>
42012eb4:	650700        	extui	a0, a0, 23, 7
42012eb7:	09c813        	ssip	f1, a8, 36
42012eba:	19d8      	l32i.n	a13, a9, 4
42012ebc:	166192        	s32i	a9, a1, 88
42012ebf:	b80581        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012ec2:	0008e0        	callx8	a8
42012ec5:	162192        	l32i	a9, a1, 88
42012ec8:	771b      	addi.n	a7, a7, 1
42012eca:	068d      	mov.n	a8, a6
42012ecc:	215150        	srai	a5, a5, 1
42012ecf:	998b      	addi.n	a9, a9, 8
42012ed1:	fe0556        	bnez	a5, 42012eb5 <_dtoa_r+0x3c1>
42012ed4:	488c      	beqz.n	a8, 42012edc <_dtoa_r+0x3e8>
42012ed6:	0661a2        	s32i	a10, a1, 24
42012ed9:	0761b2        	s32i	a11, a1, 28
42012edc:	152182        	l32i	a8, a1, 84
42012edf:	98bc      	beqz.n	a8, 42012f1c <_dtoa_r+0x428>
42012ee1:	b816d1        	l32r	a13, 42000f3c <_stext+0xf1c> (3ff00000 <ets_ops_table_ptr+0x210004>)
42012ee4:	61a8      	l32i.n	a10, a1, 24
42012ee6:	71b8      	l32i.n	a11, a1, 28
42012ee8:	0c0c      	movi.n	a12, 0
42012eea:	b7f981        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
42012eed:	0008e0        	callx8	a8
42012ef0:	028ad6        	bgez	a10, 42012f1c <_dtoa_r+0x428>
42012ef3:	8188      	l32i.n	a8, a1, 32
42012ef5:	d8ac      	beqz.n	a8, 42012f26 <_dtoa_r+0x432>
42012ef7:	b188      	l32i.n	a8, a1, 44
42012ef9:	0218e6        	bgei	a8, 1, 42012eff <_dtoa_r+0x40b>
42012efc:	008f86        	j	4201313e <_dtoa_r+0x64a>
42012eff:	61a8      	l32i.n	a10, a1, 24
42012f01:	71b8      	l32i.n	a11, a1, 28
42012f03:	b812d1        	l32r	a13, 42000f4c <_stext+0xf2c> (40240000 <rom_rx_gain_force+0x239bd4>)
42012f06:	0c0c      	movi.n	a12, 0
42012f08:	b7f381        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012f0b:	0008e0        	callx8	a8
42012f0e:	530b      	addi.n	a5, a3, -1
42012f10:	b168      	l32i.n	a6, a1, 44
42012f12:	61a9      	s32i.n	a10, a1, 24
42012f14:	71b9      	s32i.n	a11, a1, 28
42012f16:	771b      	addi.n	a7, a7, 1
42012f18:	000386        	j	42012f2a <_dtoa_r+0x436>
42012f1b:	816800        	src	a6, a8, a0
42012f1e:	035d      	mov.n	a5, a3
42012f20:	000186        	j	42012f2a <_dtoa_r+0x436>
42012f23:	000000        	ill
42012f26:	035d      	mov.n	a5, a3
42012f28:	060c      	movi.n	a6, 0
42012f2a:	07ad      	mov.n	a10, a7
42012f2c:	b7ed81        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
42012f2f:	0008e0        	callx8	a8
42012f32:	61c8      	l32i.n	a12, a1, 24
42012f34:	0721d2        	l32i	a13, a1, 28
42012f37:	b7e781        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42012f3a:	0008e0        	callx8	a8
42012f3d:	b805d1        	l32r	a13, 42000f54 <_stext+0xf34> (401c0000 <rom_rx_gain_force+0x1b9bd4>)
42012f40:	0c0c      	movi.n	a12, 0
42012f42:	b80c81        	l32r	a8, 42000f74 <_stext+0xf54> (40002184 <__adddf3>)
42012f45:	0008e0        	callx8	a8
42012f48:	387c      	movi.n	a8, -13
42012f4a:	0188a0        	slli	a8, a8, 22
42012f4d:	f8ba      	add.n	a15, a8, a11
42012f4f:	1661a2        	s32i	a10, a1, 88
42012f52:	1761f2        	s32i	a15, a1, 92
42012f55:	1a61a2        	s32i	a10, a1, 104
42012f58:	1b61f2        	s32i	a15, a1, 108
42012f5b:	046656        	bnez	a6, 42012fa5 <_dtoa_r+0x4b1>
42012f5e:	b7fcd1        	l32r	a13, 42000f50 <_stext+0xf30> (40140000 <rom_rx_gain_force+0x139bd4>)
42012f61:	61a8      	l32i.n	a10, a1, 24
42012f63:	71b8      	l32i.n	a11, a1, 28
42012f65:	0c0c      	movi.n	a12, 0
42012f67:	b7df81        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
42012f6a:	0008e0        	callx8	a8
42012f6d:	1621c2        	l32i	a12, a1, 88
42012f70:	1721d2        	l32i	a13, a1, 92
42012f73:	0a6d      	mov.n	a6, a10
42012f75:	0b7d      	mov.n	a7, a11
42012f77:	b7dd81        	l32r	a8, 42000eec <_stext+0xecc> (400023a0 <__gtdf2>)
42012f7a:	0008e0        	callx8	a8
42012f7d:	021aa6        	blti	a10, 1, 42012f83 <_dtoa_r+0x48f>
42012f80:	0151c6        	j	420134cb <_dtoa_r+0x9d7>
42012f83:	1b21f2        	l32i	a15, a1, 108
42012f86:	f87c      	movi.n	a8, -1
42012f88:	018810        	slli	a8, a8, 31
42012f8b:	1a21c2        	l32i	a12, a1, 104
42012f8e:	30d8f0        	xor	a13, a8, a15
42012f91:	06ad      	mov.n	a10, a6
42012f93:	20b770        	or	a11, a7, a7
42012f96:	b7ce81        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
42012f99:	0008e0        	callx8	a8
42012f9c:	20aa96        	bltz	a10, 420131aa <_dtoa_r+0x6b6>
42012f9f:	0066c6        	j	4201313e <_dtoa_r+0x64a>
42012fa2:	000000        	ill
42012fa5:	b7e691        	l32r	a9, 42000f40 <_stext+0xf20> (3c028aa0 <__mprec_tens>)
42012fa8:	860b      	addi.n	a8, a6, -1
42012faa:	b08890        	addx8	a8, a8, a9
42012fad:	08a8      	l32i.n	a10, a8, 0
42012faf:	18b8      	l32i.n	a11, a8, 4
42012fb1:	102182        	l32i	a8, a1, 64
42012fb4:	726a      	add.n	a7, a2, a6
42012fb6:	0bf816        	beqz	a8, 42013079 <_dtoa_r+0x585>
42012fb9:	0bdd      	mov.n	a13, a11
42012fbb:	b7c1b1        	l32r	a11, 42000ec0 <_stext+0xea0> (3fe00000 <ets_ops_table_ptr+0x110004>)
42012fbe:	0acd      	mov.n	a12, a10
42012fc0:	0a0c      	movi.n	a10, 0
42012fc2:	b7ed81        	l32r	a8, 42000f78 <_stext+0xf58> (40002250 <__divdf3>)
42012fc5:	0008e0        	callx8	a8
42012fc8:	1621c2        	l32i	a12, a1, 88
42012fcb:	1721d2        	l32i	a13, a1, 92
42012fce:	b7c581        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
42012fd1:	0008e0        	callx8	a8
42012fd4:	1661a2        	s32i	a10, a1, 88
42012fd7:	1761b2        	s32i	a11, a1, 92
42012fda:	028d      	mov.n	a8, a2
42012fdc:	71b8      	l32i.n	a11, a1, 28
42012fde:	61a8      	l32i.n	a10, a1, 24
42012fe0:	196182        	s32i	a8, a1, 100
42012fe3:	b7be81        	l32r	a8, 42000edc <_stext+0xebc> (400022d4 <__fixdfsi>)
42012fe6:	0008e0        	callx8	a8
42012fe9:	1a61a2        	s32i	a10, a1, 104
42012fec:	b7bd81        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
42012fef:	0008e0        	callx8	a8
42012ff2:	0acd      	mov.n	a12, a10
42012ff4:	0bdd      	mov.n	a13, a11
42012ff6:	61a8      	l32i.n	a10, a1, 24
42012ff8:	0721b2        	l32i	a11, a1, 28
42012ffb:	b7ba81        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
42012ffe:	0008e0        	callx8	a8
42013001:	1a2192        	l32i	a9, a1, 104
42013004:	192182        	l32i	a8, a1, 100
42013007:	30c992        	addi	a9, a9, 48
4201300a:	1621c2        	l32i	a12, a1, 88
4201300d:	1721d2        	l32i	a13, a1, 92
42013010:	61a9      	s32i.n	a10, a1, 24
42013012:	0761b2        	s32i	a11, a1, 28
42013015:	004892        	s8i	a9, a8, 0
42013018:	01c862        	addi	a6, a8, 1
4201301b:	b7ad81        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
4201301e:	0008e0        	callx8	a8
42013021:	70ba96        	bltz	a10, 42013730 <_dtoa_r+0xc3c>
42013024:	61c8      	l32i.n	a12, a1, 24
42013026:	71d8      	l32i.n	a13, a1, 28
42013028:	b7c5b1        	l32r	a11, 42000f3c <_stext+0xf1c> (3ff00000 <ets_ops_table_ptr+0x210004>)
4201302b:	00a0a2        	movi	a10, 0
4201302e:	b7ad81        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
42013031:	0008e0        	callx8	a8
42013034:	1621c2        	l32i	a12, a1, 88
42013037:	1721d2        	l32i	a13, a1, 92
4201303a:	b7a581        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
4201303d:	0008e0        	callx8	a8
42013040:	1faa96        	bltz	a10, 4201323e <_dtoa_r+0x74a>
42013043:	029677        	bne	a6, a7, 42013049 <_dtoa_r+0x555>
42013046:	003d06        	j	4201313e <_dtoa_r+0x64a>
42013049:	b7c0d1        	l32r	a13, 42000f4c <_stext+0xf2c> (40240000 <rom_rx_gain_force+0x239bd4>)
4201304c:	1621a2        	l32i	a10, a1, 88
4201304f:	1721b2        	l32i	a11, a1, 92
42013052:	0c0c      	movi.n	a12, 0
42013054:	b7a081        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42013057:	0008e0        	callx8	a8
4201305a:	1661a2        	s32i	a10, a1, 88
4201305d:	1761b2        	s32i	a11, a1, 92
42013060:	61a8      	l32i.n	a10, a1, 24
42013062:	71b8      	l32i.n	a11, a1, 28
42013064:	b7bad1        	l32r	a13, 42000f4c <_stext+0xf2c> (40240000 <rom_rx_gain_force+0x239bd4>)
42013067:	00a0c2        	movi	a12, 0
4201306a:	b79a81        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
4201306d:	0008e0        	callx8	a8
42013070:	61a9      	s32i.n	a10, a1, 24
42013072:	71b9      	s32i.n	a11, a1, 28
42013074:	068d      	mov.n	a8, a6
42013076:	ffd886        	j	42012fdc <_dtoa_r+0x4e8>
42013079:	1621c2        	l32i	a12, a1, 88
4201307c:	1721d2        	l32i	a13, a1, 92
4201307f:	b79581        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42013082:	0008e0        	callx8	a8
42013085:	1661a2        	s32i	a10, a1, 88
42013088:	1761b2        	s32i	a11, a1, 92
4201308b:	028d      	mov.n	a8, a2
4201308d:	71b8      	l32i.n	a11, a1, 28
4201308f:	61a8      	l32i.n	a10, a1, 24
42013091:	1a6182        	s32i	a8, a1, 104
42013094:	b79281        	l32r	a8, 42000edc <_stext+0xebc> (400022d4 <__fixdfsi>)
42013097:	0008e0        	callx8	a8
4201309a:	0a6d      	mov.n	a6, a10
4201309c:	b79181        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
4201309f:	0008e0        	callx8	a8
420130a2:	0acd      	mov.n	a12, a10
420130a4:	0bdd      	mov.n	a13, a11
420130a6:	61a8      	l32i.n	a10, a1, 24
420130a8:	0721b2        	l32i	a11, a1, 28
420130ab:	30c662        	addi	a6, a6, 48
420130ae:	b78d81        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
420130b1:	0008e0        	callx8	a8
420130b4:	1a2182        	l32i	a8, a1, 104
420130b7:	61a9      	s32i.n	a10, a1, 24
420130b9:	004862        	s8i	a6, a8, 0
420130bc:	71b9      	s32i.n	a11, a1, 28
420130be:	881b      	addi.n	a8, a8, 1
420130c0:	5e9787        	bne	a7, a8, 42013122 <_dtoa_r+0x62e>
420130c3:	b77fd1        	l32r	a13, 42000ec0 <_stext+0xea0> (3fe00000 <ets_ops_table_ptr+0x110004>)
420130c6:	1621a2        	l32i	a10, a1, 88
420130c9:	1721b2        	l32i	a11, a1, 92
420130cc:	0c0c      	movi.n	a12, 0
420130ce:	b7a981        	l32r	a8, 42000f74 <_stext+0xf54> (40002184 <__adddf3>)
420130d1:	0008e0        	callx8	a8
420130d4:	0acd      	mov.n	a12, a10
420130d6:	0bdd      	mov.n	a13, a11
420130d8:	61a8      	l32i.n	a10, a1, 24
420130da:	71b8      	l32i.n	a11, a1, 28
420130dc:	206770        	or	a6, a7, a7
420130df:	b78381        	l32r	a8, 42000eec <_stext+0xecc> (400023a0 <__gtdf2>)
420130e2:	0008e0        	callx8	a8
420130e5:	021aa6        	blti	a10, 1, 420130eb <_dtoa_r+0x5f7>
420130e8:	005486        	j	4201323e <_dtoa_r+0x74a>
420130eb:	1621c2        	l32i	a12, a1, 88
420130ee:	1721d2        	l32i	a13, a1, 92
420130f1:	b773b1        	l32r	a11, 42000ec0 <_stext+0xea0> (3fe00000 <ets_ops_table_ptr+0x110004>)
420130f4:	0a0c      	movi.n	a10, 0
420130f6:	b77b81        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
420130f9:	0008e0        	callx8	a8
420130fc:	0acd      	mov.n	a12, a10
420130fe:	20dbb0        	or	a13, a11, a11
42013101:	61a8      	l32i.n	a10, a1, 24
42013103:	0721b2        	l32i	a11, a1, 28
42013106:	b77281        	l32r	a8, 42000ed0 <_stext+0xeb0> (400023dc <__ltdf2>)
42013109:	0008e0        	callx8	a8
4201310c:	02ead6        	bgez	a10, 4201313e <_dtoa_r+0x64a>
4201310f:	093c      	movi.n	a9, 48
42013111:	068d      	mov.n	a8, a6
42013113:	660b      	addi.n	a6, a6, -1
42013115:	0006a2        	l8ui	a10, a6, 0
42013118:	f51a97        	beq	a10, a9, 42013111 <_dtoa_r+0x61d>
4201311b:	086d      	mov.n	a6, a8
4201311d:	0183c6        	j	42013730 <_dtoa_r+0xc3c>
42013120:	00          	.byte	00
42013121:	00          	.byte	00
42013122:	61a8      	l32i.n	a10, a1, 24
42013124:	71b8      	l32i.n	a11, a1, 28
42013126:	b789d1        	l32r	a13, 42000f4c <_stext+0xf2c> (40240000 <rom_rx_gain_force+0x239bd4>)
42013129:	1a6182        	s32i	a8, a1, 104
4201312c:	0c0c      	movi.n	a12, 0
4201312e:	b76981        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42013131:	0008e0        	callx8	a8
42013134:	1a2182        	l32i	a8, a1, 104
42013137:	61a9      	s32i.n	a10, a1, 24
42013139:	71b9      	s32i.n	a11, a1, 28
4201313b:	ffd386        	j	4201308d <_dtoa_r+0x599>
4201313e:	0188      	l32i.n	a8, a1, 0
42013140:	138896        	bltz	a8, 4201327c <_dtoa_r+0x788>
42013143:	e90c      	movi.n	a9, 14
42013145:	729930        	salt	a9, a9, a3
42013148:	990b      	addi.n	a9, a9, -1
4201314a:	609090        	neg	a9, a9
4201314d:	749090        	extui	a9, a9, 0, 8
42013150:	128916        	beqz	a9, 4201327c <_dtoa_r+0x788>
42013153:	b77b81        	l32r	a8, 42000f40 <_stext+0xf20> (3c028aa0 <__mprec_tens>)
42013156:	b08380        	addx8	a8, a3, a8
42013159:	0848      	l32i.n	a4, a8, 0
4201315b:	1858      	l32i.n	a5, a8, 4
4201315d:	142182        	l32i	a8, a1, 80
42013160:	0108d6        	bgez	a8, 42013174 <_dtoa_r+0x680>
42013163:	8198      	l32i.n	a9, a1, 32
42013165:	080c      	movi.n	a8, 0
42013167:	728890        	salt	a8, a8, a9
4201316a:	880b      	addi.n	a8, a8, -1
4201316c:	608080        	neg	a8, a8
4201316f:	748080        	extui	a8, a8, 0, 8
42013172:	c8cc      	bnez.n	a8, 42013182 <_dtoa_r+0x68e>
42013174:	8188      	l32i.n	a8, a1, 32
42013176:	721b      	addi.n	a7, a2, 1
42013178:	828a      	add.n	a8, a2, a8
4201317a:	8189      	s32i.n	a8, a1, 32
4201317c:	000d86        	j	420131b6 <_dtoa_r+0x6c2>
4201317f:	000000        	ill
42013182:	8188      	l32i.n	a8, a1, 32
42013184:	28ec      	bnez.n	a8, 420131aa <_dtoa_r+0x6b6>
42013186:	b772d1        	l32r	a13, 42000f50 <_stext+0xf30> (40140000 <rom_rx_gain_force+0x139bd4>)
42013189:	0c0c      	movi.n	a12, 0
4201318b:	04ad      	mov.n	a10, a4
4201318d:	20b550        	or	a11, a5, a5
42013190:	b75181        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42013193:	0008e0        	callx8	a8
42013196:	0acd      	mov.n	a12, a10
42013198:	0bdd      	mov.n	a13, a11
4201319a:	e1a8      	l32i.n	a10, a1, 56
4201319c:	f1b8      	l32i.n	a11, a1, 60
4201319e:	b74b81        	l32r	a8, 42000ecc <_stext+0xeac> (400023b8 <__ledf2>)
420131a1:	0008e0        	callx8	a8
420131a4:	021aa6        	blti	a10, 1, 420131aa <_dtoa_r+0x6b6>
420131a7:	00c786        	j	420134c9 <_dtoa_r+0x9d5>
420131aa:	080c      	movi.n	a8, 0
420131ac:	6189      	s32i.n	a8, a1, 24
420131ae:	070c      	movi.n	a7, 0
420131b0:	00c206        	j	420134bc <_dtoa_r+0x9c8>
420131b3:	000000        	ill
420131b6:	e1a8      	l32i.n	a10, a1, 56
420131b8:	f1b8      	l32i.n	a11, a1, 60
420131ba:	04cd      	mov.n	a12, a4
420131bc:	05dd      	mov.n	a13, a5
420131be:	b76e81        	l32r	a8, 42000f78 <_stext+0xf58> (40002250 <__divdf3>)
420131c1:	0008e0        	callx8	a8
420131c4:	b74681        	l32r	a8, 42000edc <_stext+0xebc> (400022d4 <__fixdfsi>)
420131c7:	0008e0        	callx8	a8
420131ca:	61a9      	s32i.n	a10, a1, 24
420131cc:	b74581        	l32r	a8, 42000ee0 <_stext+0xec0> (40002334 <__floatsidf>)
420131cf:	0008e0        	callx8	a8
420131d2:	04cd      	mov.n	a12, a4
420131d4:	20d550        	or	a13, a5, a5
420131d7:	b73f81        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
420131da:	0008e0        	callx8	a8
420131dd:	0acd      	mov.n	a12, a10
420131df:	0bdd      	mov.n	a13, a11
420131e1:	e1a8      	l32i.n	a10, a1, 56
420131e3:	f1b8      	l32i.n	a11, a1, 60
420131e5:	076d      	mov.n	a6, a7
420131e7:	b73f81        	l32r	a8, 42000ee4 <_stext+0xec4> (400024fc <__subdf3>)
420131ea:	0008e0        	callx8	a8
420131ed:	6198      	l32i.n	a9, a1, 24
420131ef:	870b      	addi.n	a8, a7, -1
420131f1:	30c992        	addi	a9, a9, 48
420131f4:	004892        	s8i	a9, a8, 0
420131f7:	8188      	l32i.n	a8, a1, 32
420131f9:	5c9877        	bne	a8, a7, 42013259 <_dtoa_r+0x765>
420131fc:	0acd      	mov.n	a12, a10
420131fe:	0bdd      	mov.n	a13, a11
42013200:	b75d81        	l32r	a8, 42000f74 <_stext+0xf54> (40002184 <__adddf3>)
42013203:	0008e0        	callx8	a8
42013206:	04cd      	mov.n	a12, a4
42013208:	05dd      	mov.n	a13, a5
4201320a:	81a9      	s32i.n	a10, a1, 32
4201320c:	91b9      	s32i.n	a11, a1, 36
4201320e:	b73781        	l32r	a8, 42000eec <_stext+0xecc> (400023a0 <__gtdf2>)
42013211:	0008e0        	callx8	a8
42013214:	241ae6        	bgei	a10, 1, 4201323c <_dtoa_r+0x748>
42013217:	81a8      	l32i.n	a10, a1, 32
42013219:	91b8      	l32i.n	a11, a1, 36
4201321b:	04cd      	mov.n	a12, a4
4201321d:	05dd      	mov.n	a13, a5
4201321f:	b72e81        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
42013222:	0008e0        	callx8	a8
42013225:	509a56        	bnez	a10, 42013732 <_dtoa_r+0xc3e>
42013228:	6188      	l32i.n	a8, a1, 24
4201322a:	0ee807        	bbsi	a8, 0, 4201323c <_dtoa_r+0x748>
4201322d:	014046        	j	42013732 <_dtoa_r+0xc3e>
42013230:	aa0b      	addi.n	a10, a10, -1
42013232:	facc      	bnez.n	a10, 42013245 <_dtoa_r+0x751>
42013234:	551b      	addi.n	a5, a5, 1
42013236:	093c      	movi.n	a9, 48
42013238:	0004c6        	j	4201324f <_dtoa_r+0x75b>
4201323b:	00          	.byte	00
4201323c:	035d      	mov.n	a5, a3
4201323e:	068d      	mov.n	a8, a6
42013240:	9b3c      	movi.n	a11, 57
42013242:	c0a620        	sub	a10, a6, a2
42013245:	086d      	mov.n	a6, a8
42013247:	880b      	addi.n	a8, a8, -1
42013249:	000892        	l8ui	a9, a8, 0
4201324c:	e019b7        	beq	a9, a11, 42013230 <_dtoa_r+0x73c>
4201324f:	991b      	addi.n	a9, a9, 1
42013251:	004892        	s8i	a9, a8, 0
42013254:	013606        	j	42013730 <_dtoa_r+0xc3c>
42013257:	d10000        	mul16s	a0, a0, a0
4201325a:	b73c      	movi.n	a7, 59
4201325c:	0c0c      	movi.n	a12, 0
4201325e:	b71d81        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42013261:	0008e0        	callx8	a8
42013264:	e1a9      	s32i.n	a10, a1, 56
42013266:	f1b9      	s32i.n	a11, a1, 60
42013268:	0c0c      	movi.n	a12, 0
4201326a:	0d0c      	movi.n	a13, 0
4201326c:	771b      	addi.n	a7, a7, 1
4201326e:	b71a81        	l32r	a8, 42000ed8 <_stext+0xeb8> (4000228c <__eqdf2>)
42013271:	0008e0        	callx8	a8
42013274:	f3ea56        	bnez	a10, 420131b6 <_dtoa_r+0x6c2>
42013277:	012dc6        	j	42013732 <_dtoa_r+0xc3e>
4201327a:	00          	.byte	00
4201327b:	219200        	srai	a9, a0, 2
4201327e:	d15810        	mul16s	a5, a8, a1
42013281:	046d      	mov.n	a6, a4
42013283:	070c      	movi.n	a7, 0
42013285:	069916        	beqz	a9, 420132f2 <_dtoa_r+0x7fe>
42013288:	c198      	l32i.n	a9, a1, 48
4201328a:	1a29e6        	bgei	a9, 2, 420132a8 <_dtoa_r+0x7b4>
4201328d:	182192        	l32i	a9, a1, 96
42013290:	698c      	beqz.n	a9, 4201329a <_dtoa_r+0x7a6>
42013292:	33a492        	movi	a9, 0x433
42013295:	889a      	add.n	a8, a8, a9
42013297:	0010c6        	j	420132de <_dtoa_r+0x7ea>
4201329a:	1188      	l32i.n	a8, a1, 4
4201329c:	d158      	l32i.n	a5, a1, 52
4201329e:	cac882        	addi	a8, a8, -54
420132a1:	608080        	neg	a8, a8
420132a4:	000d86        	j	420132de <_dtoa_r+0x7ea>
420132a7:	818800        	src	a8, a8, a0
420132aa:	580b      	addi.n	a5, a8, -1
420132ac:	d188      	l32i.n	a8, a1, 52
420132ae:	182857        	blt	a8, a5, 420132ca <_dtoa_r+0x7d6>
420132b1:	c05850        	sub	a5, a8, a5
420132b4:	8198      	l32i.n	a9, a1, 32
420132b6:	8188      	l32i.n	a8, a1, 32
420132b8:	c06480        	sub	a6, a4, a8
420132bb:	080c      	movi.n	a8, 0
420132bd:	01d996        	bltz	a9, 420132de <_dtoa_r+0x7ea>
420132c0:	046d      	mov.n	a6, a4
420132c2:	098d      	mov.n	a8, a9
420132c4:	000586        	j	420132de <_dtoa_r+0x7ea>
420132c7:	000000        	ill
420132ca:	d188      	l32i.n	a8, a1, 52
420132cc:	112192        	l32i	a9, a1, 68
420132cf:	c08580        	sub	a8, a5, a8
420132d2:	898a      	add.n	a8, a9, a8
420132d4:	116182        	s32i	a8, a1, 68
420132d7:	8188      	l32i.n	a8, a1, 32
420132d9:	d159      	s32i.n	a5, a1, 52
420132db:	00a052        	movi	a5, 0
420132de:	a198      	l32i.n	a9, a1, 40
420132e0:	41a8      	l32i.n	a10, a1, 16
420132e2:	448a      	add.n	a4, a4, a8
420132e4:	1b0c      	movi.n	a11, 1
420132e6:	898a      	add.n	a8, a9, a8
420132e8:	a189      	s32i.n	a8, a1, 40
420132ea:	201110        	or	a1, a1, a1
420132ed:	0073a5        	call8	42013a28 <__i2b>
420132f0:	0a7d      	mov.n	a7, a10
420132f2:	080c      	movi.n	a8, 0
420132f4:	269c      	beqz.n	a6, 4201330a <_dtoa_r+0x816>
420132f6:	a198      	l32i.n	a9, a1, 40
420132f8:	0ea897        	bge	a8, a9, 4201330a <_dtoa_r+0x816>
420132fb:	438690        	min	a8, a6, a9
420132fe:	c04480        	sub	a4, a4, a8
42013301:	c06680        	sub	a6, a6, a8
42013304:	c08980        	sub	a8, a9, a8
42013307:	0a6182        	s32i	a8, a1, 40
4201330a:	d188      	l32i.n	a8, a1, 52
4201330c:	056816        	beqz	a8, 42013366 <_dtoa_r+0x872>
4201330f:	102182        	l32i	a8, a1, 64
42013312:	042816        	beqz	a8, 42013358 <_dtoa_r+0x864>
42013315:	5188      	l32i.n	a8, a1, 20
42013317:	55bc      	beqz.n	a5, 42013350 <_dtoa_r+0x85c>
42013319:	41a8      	l32i.n	a10, a1, 16
4201331b:	07bd      	mov.n	a11, a7
4201331d:	20c550        	or	a12, a5, a5
42013320:	201110        	or	a1, a1, a1
42013323:	008aa5        	call8	42013bcc <__pow5mult>
42013326:	0abd      	mov.n	a11, a10
42013328:	51c8      	l32i.n	a12, a1, 20
4201332a:	0a7d      	mov.n	a7, a10
4201332c:	0421a2        	l32i	a10, a1, 16
4201332f:	201110        	or	a1, a1, a1
42013332:	0071e5        	call8	42013a50 <__multiply>
42013335:	61a9      	s32i.n	a10, a1, 24
42013337:	51b8      	l32i.n	a11, a1, 20
42013339:	41a8      	l32i.n	a10, a1, 16
4201333b:	201110        	or	a1, a1, a1
4201333e:	004d25        	call8	42013810 <_Bfree>
42013341:	d188      	l32i.n	a8, a1, 52
42013343:	c08850        	sub	a8, a8, a5
42013346:	d189      	s32i.n	a8, a1, 52
42013348:	6188      	l32i.n	a8, a1, 24
4201334a:	d198      	l32i.n	a9, a1, 52
4201334c:	5189      	s32i.n	a8, a1, 20
4201334e:	499c      	beqz.n	a9, 42013366 <_dtoa_r+0x872>
42013350:	d1c8      	l32i.n	a12, a1, 52
42013352:	08bd      	mov.n	a11, a8
42013354:	000106        	j	4201335c <_dtoa_r+0x868>
42013357:	d1c800        	mul16s	a12, a8, a0
4201335a:	51b8      	l32i.n	a11, a1, 20
4201335c:	41a8      	l32i.n	a10, a1, 16
4201335e:	201110        	or	a1, a1, a1
42013361:	0086a5        	call8	42013bcc <__pow5mult>
42013364:	51a9      	s32i.n	a10, a1, 20
42013366:	41a8      	l32i.n	a10, a1, 16
42013368:	01a0b2        	movi	a11, 1
4201336b:	201110        	or	a1, a1, a1
4201336e:	006ba5        	call8	42013a28 <__i2b>
42013371:	112182        	l32i	a8, a1, 68
42013374:	61a9      	s32i.n	a10, a1, 24
42013376:	3fa816        	beqz	a8, 42013774 <_dtoa_r+0xc80>
42013379:	0abd      	mov.n	a11, a10
4201337b:	41a8      	l32i.n	a10, a1, 16
4201337d:	08cd      	mov.n	a12, a8
4201337f:	201110        	or	a1, a1, a1
42013382:	0084a5        	call8	42013bcc <__pow5mult>
42013385:	080c      	movi.n	a8, 0
42013387:	e189      	s32i.n	a8, a1, 56
42013389:	0c2182        	l32i	a8, a1, 48
4201338c:	61a9      	s32i.n	a10, a1, 24
4201338e:	2e28e6        	bgei	a8, 2, 420133c0 <_dtoa_r+0x8cc>
42013391:	080c      	movi.n	a8, 0
42013393:	e189      	s32i.n	a8, a1, 56
42013395:	122182        	l32i	a8, a1, 72
42013398:	d8dc      	bnez.n	a8, 420133b9 <_dtoa_r+0x8c5>
4201339a:	132182        	l32i	a8, a1, 76
4201339d:	118840        	slli	a8, a8, 12
420133a0:	58dc      	bnez.n	a8, 420133b9 <_dtoa_r+0x8c5>
420133a2:	132182        	l32i	a8, a1, 76
420133a5:	a58480        	extui	a8, a8, 20, 11
420133a8:	d88c      	beqz.n	a8, 420133b9 <_dtoa_r+0x8c5>
420133aa:	a188      	l32i.n	a8, a1, 40
420133ac:	441b      	addi.n	a4, a4, 1
420133ae:	881b      	addi.n	a8, a8, 1
420133b0:	0a6182        	s32i	a8, a1, 40
420133b3:	01a082        	movi	a8, 1
420133b6:	0e6182        	s32i	a8, a1, 56
420133b9:	112182        	l32i	a8, a1, 68
420133bc:	1a0c      	movi.n	a10, 1
420133be:	589c      	beqz.n	a8, 420133d7 <_dtoa_r+0x8e3>
420133c0:	6188      	l32i.n	a8, a1, 24
420133c2:	6198      	l32i.n	a9, a1, 24
420133c4:	4888      	l32i.n	a8, a8, 16
420133c6:	a08890        	addx4	a8, a8, a9
420133c9:	48a8      	l32i.n	a10, a8, 16
420133cb:	201110        	or	a1, a1, a1
420133ce:	0059e5        	call8	4201396c <__hi0bits>
420133d1:	e0caa2        	addi	a10, a10, -32
420133d4:	60a0a0        	neg	a10, a10
420133d7:	a188      	l32i.n	a8, a1, 40
420133d9:	aa8a      	add.n	a10, a10, a8
420133db:	44a0a0        	extui	a10, a10, 0, 5
420133de:	0aac      	beqz.n	a10, 42013402 <_dtoa_r+0x90e>
420133e0:	e0ca82        	addi	a8, a10, -32
420133e3:	608080        	neg	a8, a8
420133e6:	1258a6        	blti	a8, 5, 420133fc <_dtoa_r+0x908>
420133e9:	a188      	l32i.n	a8, a1, 40
420133eb:	e4caa2        	addi	a10, a10, -28
420133ee:	60a0a0        	neg	a10, a10
420133f1:	44aa      	add.n	a4, a4, a10
420133f3:	66aa      	add.n	a6, a6, a10
420133f5:	88aa      	add.n	a8, a8, a10
420133f7:	000506        	j	4201340f <_dtoa_r+0x91b>
420133fa:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
420133fd:	1148      	l32i.n	a4, a1, 4
420133ff:	000046        	j	42013404 <_dtoa_r+0x910>
42013402:	080c      	movi.n	a8, 0
42013404:	a198      	l32i.n	a9, a1, 40
42013406:	1cc882        	addi	a8, a8, 28
42013409:	448a      	add.n	a4, a4, a8
4201340b:	668a      	add.n	a6, a6, a8
4201340d:	898a      	add.n	a8, a9, a8
4201340f:	a189      	s32i.n	a8, a1, 40
42013411:	0d14a6        	blti	a4, 1, 42013422 <_dtoa_r+0x92e>
42013414:	51b8      	l32i.n	a11, a1, 20
42013416:	41a8      	l32i.n	a10, a1, 16
42013418:	04cd      	mov.n	a12, a4
4201341a:	201110        	or	a1, a1, a1
4201341d:	0085a5        	call8	42013c78 <__lshift>
42013420:	51a9      	s32i.n	a10, a1, 20
42013422:	a188      	l32i.n	a8, a1, 40
42013424:	1118a6        	blti	a8, 1, 42013439 <_dtoa_r+0x945>
42013427:	0621b2        	l32i	a11, a1, 24
4201342a:	0421a2        	l32i	a10, a1, 16
4201342d:	20c880        	or	a12, a8, a8
42013430:	201110        	or	a1, a1, a1
42013433:	008465        	call8	42013c78 <__lshift>
42013436:	0661a2        	s32i	a10, a1, 24
42013439:	152182        	l32i	a8, a1, 84
4201343c:	c88c      	beqz.n	a8, 4201344c <_dtoa_r+0x958>
4201343e:	61b8      	l32i.n	a11, a1, 24
42013440:	0521a2        	l32i	a10, a1, 20
42013443:	201110        	or	a1, a1, a1
42013446:	0093a5        	call8	42013d80 <__mcmp>
42013449:	009a96        	bltz	a10, 42013456 <_dtoa_r+0x962>
4201344c:	8188      	l32i.n	a8, a1, 32
4201344e:	035d      	mov.n	a5, a3
42013450:	b189      	s32i.n	a8, a1, 44
42013452:	000ac6        	j	42013481 <_dtoa_r+0x98d>
42013455:	00          	.byte	00
42013456:	51b8      	l32i.n	a11, a1, 20
42013458:	41a8      	l32i.n	a10, a1, 16
4201345a:	0d0c      	movi.n	a13, 0
4201345c:	0aa0c2        	movi	a12, 10
4201345f:	201110        	or	a1, a1, a1
42013462:	003ee5        	call8	42013850 <__multadd>
42013465:	102182        	l32i	a8, a1, 64
42013468:	51a9      	s32i.n	a10, a1, 20
4201346a:	530b      	addi.n	a5, a3, -1
4201346c:	189c      	beqz.n	a8, 42013481 <_dtoa_r+0x98d>
4201346e:	41a8      	l32i.n	a10, a1, 16
42013470:	07bd      	mov.n	a11, a7
42013472:	00a0d2        	movi	a13, 0
42013475:	0aa0c2        	movi	a12, 10
42013478:	201110        	or	a1, a1, a1
4201347b:	003d65        	call8	42013850 <__multadd>
4201347e:	207aa0        	or	a7, a10, a10
42013481:	b198      	l32i.n	a9, a1, 44
42013483:	080c      	movi.n	a8, 0
42013485:	728890        	salt	a8, a8, a9
42013488:	880b      	addi.n	a8, a8, -1
4201348a:	608080        	neg	a8, a8
4201348d:	748080        	extui	a8, a8, 0, 8
42013490:	04d816        	beqz	a8, 420134e1 <_dtoa_r+0x9ed>
42013493:	c198      	l32i.n	a9, a1, 48
42013495:	280c      	movi.n	a8, 2
42013497:	46a897        	bge	a8, a9, 420134e1 <_dtoa_r+0x9ed>
4201349a:	b188      	l32i.n	a8, a1, 44
4201349c:	c8dc      	bnez.n	a8, 420134bc <_dtoa_r+0x9c8>
4201349e:	61b8      	l32i.n	a11, a1, 24
420134a0:	41a8      	l32i.n	a10, a1, 16
420134a2:	0d0c      	movi.n	a13, 0
420134a4:	05a0c2        	movi	a12, 5
420134a7:	201110        	or	a1, a1, a1
420134aa:	003a65        	call8	42013850 <__multadd>
420134ad:	61a9      	s32i.n	a10, a1, 24
420134af:	0abd      	mov.n	a11, a10
420134b1:	51a8      	l32i.n	a10, a1, 20
420134b3:	201110        	or	a1, a1, a1
420134b6:	008ca5        	call8	42013d80 <__mcmp>
420134b9:	141ae6        	bgei	a10, 1, 420134d1 <_dtoa_r+0x9dd>
420134bc:	142192        	l32i	a9, a1, 80
420134bf:	f87c      	movi.n	a8, -1
420134c1:	305980        	xor	a5, a9, a8
420134c4:	026d      	mov.n	a6, a2
420134c6:	000406        	j	420134da <_dtoa_r+0x9e6>
420134c9:	035d      	mov.n	a5, a3
420134cb:	080c      	movi.n	a8, 0
420134cd:	6189      	s32i.n	a8, a1, 24
420134cf:	070c      	movi.n	a7, 0
420134d1:	183c      	movi.n	a8, 49
420134d3:	621b      	addi.n	a6, a2, 1
420134d5:	004282        	s8i	a8, a2, 0
420134d8:	551b      	addi.n	a5, a5, 1
420134da:	074d      	mov.n	a4, a7
420134dc:	070c      	movi.n	a7, 0
420134de:	008a06        	j	4201370a <_dtoa_r+0xc16>
420134e1:	102182        	l32i	a8, a1, 64
420134e4:	189816        	beqz	a8, 42013671 <_dtoa_r+0xb7d>
420134e7:	0d16a6        	blti	a6, 1, 420134f8 <_dtoa_r+0xa04>
420134ea:	41a8      	l32i.n	a10, a1, 16
420134ec:	07bd      	mov.n	a11, a7
420134ee:	06cd      	mov.n	a12, a6
420134f0:	201110        	or	a1, a1, a1
420134f3:	007865        	call8	42013c78 <__lshift>
420134f6:	0a7d      	mov.n	a7, a10
420134f8:	e188      	l32i.n	a8, a1, 56
420134fa:	074d      	mov.n	a4, a7
420134fc:	88bc      	beqz.n	a8, 42013538 <_dtoa_r+0xa44>
420134fe:	17b8      	l32i.n	a11, a7, 4
42013500:	41a8      	l32i.n	a10, a1, 16
42013502:	201110        	or	a1, a1, a1
42013505:	002825        	call8	42013788 <_Balloc>
42013508:	0a6d      	mov.n	a6, a10
4201350a:	aacc      	bnez.n	a10, 42013518 <_dtoa_r+0xa24>
4201350c:	b68ed1        	l32r	a13, 42000f44 <_stext+0xf24> (3c028790 <blanks$1+0xbc>)
4201350f:	0c0c      	movi.n	a12, 0
42013511:	efa2b2        	movi	a11, 0x2ef
42013514:	fe2f06        	j	42012dd4 <_dtoa_r+0x2e0>
42013517:	47c800        	ee.stf.64.xp	f12, f4, a0, a8
4201351a:	b7cb      	addi.n	a11, a7, 12
4201351c:	cc2b      	addi.n	a12, a12, 2
4201351e:	11cce0        	slli	a12, a12, 2
42013521:	0ccaa2        	addi	a10, a10, 12
42013524:	b2c181        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42013527:	0008e0        	callx8	a8
4201352a:	41a8      	l32i.n	a10, a1, 16
4201352c:	1c0c      	movi.n	a12, 1
4201352e:	06bd      	mov.n	a11, a6
42013530:	201110        	or	a1, a1, a1
42013533:	007465        	call8	42013c78 <__lshift>
42013536:	0a4d      	mov.n	a4, a10
42013538:	b1a8      	l32i.n	a10, a1, 44
4201353a:	820b      	addi.n	a8, a2, -1
4201353c:	88aa      	add.n	a8, a8, a10
4201353e:	e189      	s32i.n	a8, a1, 56
42013540:	122182        	l32i	a8, a1, 72
42013543:	029d      	mov.n	a9, a2
42013545:	048080        	extui	a8, a8, 0, 1
42013548:	b189      	s32i.n	a8, a1, 44
4201354a:	61b8      	l32i.n	a11, a1, 24
4201354c:	0521a2        	l32i	a10, a1, 20
4201354f:	d199      	s32i.n	a9, a1, 52
42013551:	ff46a5        	call8	420129bc <quorem>
42013554:	81a9      	s32i.n	a10, a1, 32
42013556:	30ca32        	addi	a3, a10, 48
42013559:	0521a2        	l32i	a10, a1, 20
4201355c:	07bd      	mov.n	a11, a7
4201355e:	201110        	or	a1, a1, a1
42013561:	0081e5        	call8	42013d80 <__mcmp>
42013564:	a1a9      	s32i.n	a10, a1, 40
42013566:	61b8      	l32i.n	a11, a1, 24
42013568:	41a8      	l32i.n	a10, a1, 16
4201356a:	04cd      	mov.n	a12, a4
4201356c:	201110        	or	a1, a1, a1
4201356f:	0084e5        	call8	42013dbc <__mdiff>
42013572:	0a6d      	mov.n	a6, a10
42013574:	3aa8      	l32i.n	a10, a10, 12
42013576:	1021c2        	l32i	a12, a1, 64
42013579:	d198      	l32i.n	a9, a1, 52
4201357b:	eacc      	bnez.n	a10, 4201358d <_dtoa_r+0xa99>
4201357d:	51a8      	l32i.n	a10, a1, 20
4201357f:	20b660        	or	a11, a6, a6
42013582:	201110        	or	a1, a1, a1
42013585:	007fa5        	call8	42013d80 <__mcmp>
42013588:	d198      	l32i.n	a9, a1, 52
4201358a:	20caa0        	or	a12, a10, a10
4201358d:	41a8      	l32i.n	a10, a1, 16
4201358f:	06bd      	mov.n	a11, a6
42013591:	116192        	s32i	a9, a1, 68
42013594:	d1c9      	s32i.n	a12, a1, 52
42013596:	201110        	or	a1, a1, a1
42013599:	002765        	call8	42013810 <_Bfree>
4201359c:	c188      	l32i.n	a8, a1, 48
4201359e:	d1c8      	l32i.n	a12, a1, 52
420135a0:	112192        	l32i	a9, a1, 68
420135a3:	20a8c0        	or	a10, a8, a12
420135a6:	b188      	l32i.n	a8, a1, 44
420135a8:	691b      	addi.n	a6, a9, 1
420135aa:	20aa80        	or	a10, a10, a8
420135ad:	cacc      	bnez.n	a10, 420135bd <_dtoa_r+0xac9>
420135af:	9a3c      	movi.n	a10, 57
420135b1:	5b13a7        	beq	a3, a10, 42013610 <_dtoa_r+0xb1c>
420135b4:	a188      	l32i.n	a8, a1, 40
420135b6:	4618a6        	blti	a8, 1, 42013600 <_dtoa_r+0xb0c>
420135b9:	000f86        	j	420135fb <_dtoa_r+0xb07>
420135bc:	a18800        	sll	a8, a8
420135bf:	00d896        	bltz	a8, 420135d0 <_dtoa_r+0xadc>
420135c2:	a1a8      	l32i.n	a10, a1, 40
420135c4:	c188      	l32i.n	a8, a1, 48
420135c6:	2088a0        	or	a8, a8, a10
420135c9:	b1a8      	l32i.n	a10, a1, 44
420135cb:	2088a0        	or	a8, a8, a10
420135ce:	68fc      	bnez.n	a8, 42013608 <_dtoa_r+0xb14>
420135d0:	2c1ca6        	blti	a12, 1, 42013600 <_dtoa_r+0xb0c>
420135d3:	51b8      	l32i.n	a11, a1, 20
420135d5:	41a8      	l32i.n	a10, a1, 16
420135d7:	1c0c      	movi.n	a12, 1
420135d9:	0a6192        	s32i	a9, a1, 40
420135dc:	201110        	or	a1, a1, a1
420135df:	0069a5        	call8	42013c78 <__lshift>
420135e2:	61b8      	l32i.n	a11, a1, 24
420135e4:	51a9      	s32i.n	a10, a1, 20
420135e6:	201110        	or	a1, a1, a1
420135e9:	007965        	call8	42013d80 <__mcmp>
420135ec:	a198      	l32i.n	a9, a1, 40
420135ee:	041ae6        	bgei	a10, 1, 420135f6 <_dtoa_r+0xb02>
420135f1:	bacc      	bnez.n	a10, 42013600 <_dtoa_r+0xb0c>
420135f3:	096307        	bbci	a3, 0, 42013600 <_dtoa_r+0xb0c>
420135f6:	9a3c      	movi.n	a10, 57
420135f8:	1413a7        	beq	a3, a10, 42013610 <_dtoa_r+0xb1c>
420135fb:	8188      	l32i.n	a8, a1, 32
420135fd:	31c832        	addi	a3, a8, 49
42013600:	004932        	s8i	a3, a9, 0
42013603:	0040c6        	j	4201370a <_dtoa_r+0xc16>
42013606:	a60000        	ee.ldf.64.xp	f0, f10, a0, a0
42013609:	141c      	movi.n	a4, 17
4201360b:	9a3c      	movi.n	a10, 57
4201360d:	0793a7        	bne	a3, a10, 42013618 <_dtoa_r+0xb24>
42013610:	983c      	movi.n	a8, 57
42013612:	004982        	s8i	a8, a9, 0
42013615:	003246        	j	420136e2 <_dtoa_r+0xbee>
42013618:	831b      	addi.n	a8, a3, 1
4201361a:	004982        	s8i	a8, a9, 0
4201361d:	003a46        	j	4201370a <_dtoa_r+0xc16>
42013620:	e188      	l32i.n	a8, a1, 56
42013622:	004932        	s8i	a3, a9, 0
42013625:	029897        	bne	a8, a9, 4201362b <_dtoa_r+0xb37>
42013628:	002106        	j	420136b0 <_dtoa_r+0xbbc>
4201362b:	51b8      	l32i.n	a11, a1, 20
4201362d:	41a8      	l32i.n	a10, a1, 16
4201362f:	0d0c      	movi.n	a13, 0
42013631:	ac0c      	movi.n	a12, 10
42013633:	201110        	or	a1, a1, a1
42013636:	0021a5        	call8	42013850 <__multadd>
42013639:	51a9      	s32i.n	a10, a1, 20
4201363b:	0d0c      	movi.n	a13, 0
4201363d:	41a8      	l32i.n	a10, a1, 16
4201363f:	ac0c      	movi.n	a12, 10
42013641:	07bd      	mov.n	a11, a7
42013643:	0d9747        	bne	a7, a4, 42013654 <_dtoa_r+0xb60>
42013646:	201110        	or	a1, a1, a1
42013649:	002065        	call8	42013850 <__multadd>
4201364c:	0a7d      	mov.n	a7, a10
4201364e:	0a4d      	mov.n	a4, a10
42013650:	000606        	j	4201366c <_dtoa_r+0xb78>
42013653:	111000        	slli	a1, a0, 16
42013656:	20          	.byte	0x20
42013657:	001fa5        	call8	42013850 <__multadd>
4201365a:	0a7d      	mov.n	a7, a10
4201365c:	41a8      	l32i.n	a10, a1, 16
4201365e:	04bd      	mov.n	a11, a4
42013660:	0d0c      	movi.n	a13, 0
42013662:	ac0c      	movi.n	a12, 10
42013664:	201110        	or	a1, a1, a1
42013667:	001ea5        	call8	42013850 <__multadd>
4201366a:	0a4d      	mov.n	a4, a10
4201366c:	069d      	mov.n	a9, a6
4201366e:	ffb606        	j	4201354a <_dtoa_r+0xa56>
42013671:	060c      	movi.n	a6, 0
42013673:	61b8      	l32i.n	a11, a1, 24
42013675:	51a8      	l32i.n	a10, a1, 20
42013677:	ff3465        	call8	420129bc <quorem>
4201367a:	926a      	add.n	a9, a2, a6
4201367c:	30ca32        	addi	a3, a10, 48
4201367f:	b188      	l32i.n	a8, a1, 44
42013681:	004932        	s8i	a3, a9, 0
42013684:	661b      	addi.n	a6, a6, 1
42013686:	13a687        	bge	a6, a8, 4201369d <_dtoa_r+0xba9>
42013689:	51b8      	l32i.n	a11, a1, 20
4201368b:	41a8      	l32i.n	a10, a1, 16
4201368d:	0d0c      	movi.n	a13, 0
4201368f:	0aa0c2        	movi	a12, 10
42013692:	201110        	or	a1, a1, a1
42013695:	001ba5        	call8	42013850 <__multadd>
42013698:	51a9      	s32i.n	a10, a1, 20
4201369a:	fff546        	j	42013673 <_dtoa_r+0xb7f>
4201369d:	b188      	l32i.n	a8, a1, 44
4201369f:	090c      	movi.n	a9, 0
420136a1:	060c      	movi.n	a6, 0
420136a3:	01a987        	bge	a9, a8, 420136a8 <_dtoa_r+0xbb4>
420136a6:	680b      	addi.n	a6, a8, -1
420136a8:	921b      	addi.n	a9, a2, 1
420136aa:	074d      	mov.n	a4, a7
420136ac:	669a      	add.n	a6, a6, a9
420136ae:	070c      	movi.n	a7, 0
420136b0:	51b8      	l32i.n	a11, a1, 20
420136b2:	0421a2        	l32i	a10, a1, 16
420136b5:	01a0c2        	movi	a12, 1
420136b8:	201110        	or	a1, a1, a1
420136bb:	005be5        	call8	42013c78 <__lshift>
420136be:	61b8      	l32i.n	a11, a1, 24
420136c0:	51a9      	s32i.n	a10, a1, 20
420136c2:	201110        	or	a1, a1, a1
420136c5:	006ba5        	call8	42013d80 <__mcmp>
420136c8:	161ae6        	bgei	a10, 1, 420136e2 <_dtoa_r+0xbee>
420136cb:	daec      	bnez.n	a10, 420136fc <_dtoa_r+0xc08>
420136cd:	11e307        	bbsi	a3, 0, 420136e2 <_dtoa_r+0xbee>
420136d0:	000a06        	j	420136fc <_dtoa_r+0xc08>
420136d3:	aa0b00        	floor.s	a0, f11, 0
420136d6:	facc      	bnez.n	a10, 420136e9 <_dtoa_r+0xbf5>
420136d8:	183c      	movi.n	a8, 49
420136da:	551b      	addi.n	a5, a5, 1
420136dc:	004282        	s8i	a8, a2, 0
420136df:	0009c6        	j	4201370a <_dtoa_r+0xc16>
420136e2:	068d      	mov.n	a8, a6
420136e4:	9b3c      	movi.n	a11, 57
420136e6:	c0a620        	sub	a10, a6, a2
420136e9:	086d      	mov.n	a6, a8
420136eb:	880b      	addi.n	a8, a8, -1
420136ed:	000892        	l8ui	a9, a8, 0
420136f0:	e019b7        	beq	a9, a11, 420136d4 <_dtoa_r+0xbe0>
420136f3:	991b      	addi.n	a9, a9, 1
420136f5:	004892        	s8i	a9, a8, 0
420136f8:	000386        	j	4201370a <_dtoa_r+0xc16>
420136fb:	068d00        	ee.ldf.64.xp	f8, f0, a0, a13
420136fe:	093c      	movi.n	a9, 48
42013700:	086d      	mov.n	a6, a8
42013702:	880b      	addi.n	a8, a8, -1
42013704:	0008a2        	l8ui	a10, a8, 0
42013707:	f51a97        	beq	a10, a9, 42013700 <_dtoa_r+0xc0c>
4201370a:	61b8      	l32i.n	a11, a1, 24
4201370c:	41a8      	l32i.n	a10, a1, 16
4201370e:	201110        	or	a1, a1, a1
42013711:	000fe5        	call8	42013810 <_Bfree>
42013714:	849c      	beqz.n	a4, 42013730 <_dtoa_r+0xc3c>
42013716:	c78c      	beqz.n	a7, 42013726 <_dtoa_r+0xc32>
42013718:	0a1747        	beq	a7, a4, 42013726 <_dtoa_r+0xc32>
4201371b:	41a8      	l32i.n	a10, a1, 16
4201371d:	20b770        	or	a11, a7, a7
42013720:	201110        	or	a1, a1, a1
42013723:	000ee5        	call8	42013810 <_Bfree>
42013726:	41a8      	l32i.n	a10, a1, 16
42013728:	04bd      	mov.n	a11, a4
4201372a:	201110        	or	a1, a1, a1
4201372d:	000e25        	call8	42013810 <_Bfree>
42013730:	053d      	mov.n	a3, a5
42013732:	51b8      	l32i.n	a11, a1, 20
42013734:	41a8      	l32i.n	a10, a1, 16
42013736:	201110        	or	a1, a1, a1
42013739:	000d65        	call8	42013810 <_Bfree>
4201373c:	080c      	movi.n	a8, 0
4201373e:	242192        	l32i	a9, a1, 144
42013741:	004682        	s8i	a8, a6, 0
42013744:	831b      	addi.n	a8, a3, 1
42013746:	0989      	s32i.n	a8, a9, 0
42013748:	262182        	l32i	a8, a1, 152
4201374b:	68bc      	beqz.n	a8, 42013785 <_dtoa_r+0xc91>
4201374d:	0869      	s32i.n	a6, a8, 0
4201374f:	000c86        	j	42013785 <_dtoa_r+0xc91>
42013752:	00          	.byte	00
42013753:	219200        	srai	a9, a0, 2
42013756:	f12126        	beqi	a1, 2, 4201374b <_dtoa_r+0xc57>
42013759:	f181b5        	call12	42004f74 <esp_mprot_get_pms_area+0x128>
4201375c:	198cb5        	call12	4202d028 <_etext+0x138f2>
4201375f:	fd0c46        	j	42012b94 <_dtoa_r+0xa0>
42013762:	0007c6        	j	42013785 <_dtoa_r+0xc91>
42013765:	218200        	srai	a8, a0, 2
42013768:	ee2126        	beqi	a1, 2, 4201375a <_dtoa_r+0xc66>
4201376b:	188cb5        	call12	4202c034 <_etext+0x128fe>
4201376e:	fd07c6        	j	42012b91 <_dtoa_r+0x9d>
42013771:	000406        	j	42013785 <_dtoa_r+0xc91>
42013774:	c188      	l32i.n	a8, a1, 48
42013776:	0228e6        	bgei	a8, 2, 4201377c <_dtoa_r+0xc88>
42013779:	ff0506        	j	42013391 <_dtoa_r+0x89d>
4201377c:	080c      	movi.n	a8, 0
4201377e:	e189      	s32i.n	a8, a1, 56
42013780:	1a0c      	movi.n	a10, 1
42013782:	ff1446        	j	420133d7 <_dtoa_r+0x8e3>
42013785:	f01d      	retw.n
	...

42013788 <_Balloc>:
42013788:	004136        	entry	a1, 32
4201378b:	9278      	l32i.n	a7, a2, 36
4201378d:	026d      	mov.n	a6, a2
4201378f:	77ec      	bnez.n	a7, 420137ba <_Balloc+0x32>
42013791:	0a1c      	movi.n	a10, 16
42013793:	b40a81        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
42013796:	0008e0        	callx8	a8
42013799:	92a9      	s32i.n	a10, a2, 36
4201379b:	0a7d      	mov.n	a7, a10
4201379d:	facc      	bnez.n	a10, 420137b0 <_Balloc+0x28>
4201379f:	b5f7d1        	l32r	a13, 42000f7c <_stext+0xf5c> (3c028725 <blanks$1+0x51>)
420137a2:	b5f7a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
420137a5:	0c0c      	movi.n	a12, 0
420137a7:	6ba0b2        	movi	a11, 107
420137aa:	b25781        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420137ad:	0008e0        	callx8	a8
420137b0:	080c      	movi.n	a8, 0
420137b2:	1a89      	s32i.n	a8, a10, 4
420137b4:	2a89      	s32i.n	a8, a10, 8
420137b6:	0a89      	s32i.n	a8, a10, 0
420137b8:	3a89      	s32i.n	a8, a10, 12
420137ba:	3788      	l32i.n	a8, a7, 12
420137bc:	88dc      	bnez.n	a8, 420137d8 <_Balloc+0x50>
420137be:	1c2c      	movi.n	a12, 33
420137c0:	4b0c      	movi.n	a11, 4
420137c2:	06ad      	mov.n	a10, a6
420137c4:	b5f081        	l32r	a8, 42000f84 <_stext+0xf64> (4037fef4 <_calloc_r>)
420137c7:	0008e0        	callx8	a8
420137ca:	9688      	l32i.n	a8, a6, 36
420137cc:	37a9      	s32i.n	a10, a7, 12
420137ce:	3888      	l32i.n	a8, a8, 12
420137d0:	48cc      	bnez.n	a8, 420137d8 <_Balloc+0x50>
420137d2:	020c      	movi.n	a2, 0
420137d4:	000d06        	j	4201380c <_Balloc+0x84>
420137d7:	838000        	moveqz	a8, a0, a0
420137da:	0828a0        	lsx	f2, a8, a10
420137dd:	528c      	beqz.n	a2, 420137e6 <_Balloc+0x5e>
420137df:	0298      	l32i.n	a9, a2, 0
420137e1:	0899      	s32i.n	a9, a8, 0
420137e3:	0007c6        	j	42013806 <_Balloc+0x7e>
420137e6:	170c      	movi.n	a7, 1
420137e8:	401300        	ssl	a3
420137eb:	a17700        	sll	a7, a7
420137ee:	c75b      	addi.n	a12, a7, 5
420137f0:	11cce0        	slli	a12, a12, 2
420137f3:	1b0c      	movi.n	a11, 1
420137f5:	06ad      	mov.n	a10, a6
420137f7:	b5e381        	l32r	a8, 42000f84 <_stext+0xf64> (4037fef4 <_calloc_r>)
420137fa:	0008e0        	callx8	a8
420137fd:	0a2d      	mov.n	a2, a10
420137ff:	fcfa16        	beqz	a10, 420137d2 <_Balloc+0x4a>
42013802:	1a39      	s32i.n	a3, a10, 4
42013804:	2a79      	s32i.n	a7, a10, 8
42013806:	080c      	movi.n	a8, 0
42013808:	4289      	s32i.n	a8, a2, 16
4201380a:	3289      	s32i.n	a8, a2, 12
4201380c:	f01d      	retw.n
	...

42013810 <_Bfree>:
42013810:	004136        	entry	a1, 32
42013813:	9278      	l32i.n	a7, a2, 36
42013815:	47ec      	bnez.n	a7, 4201383d <_Bfree+0x2d>
42013817:	10a0a2        	movi	a10, 16
4201381a:	b3e881        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
4201381d:	0008e0        	callx8	a8
42013820:	92a9      	s32i.n	a10, a2, 36
42013822:	facc      	bnez.n	a10, 42013835 <_Bfree+0x25>
42013824:	b5d6d1        	l32r	a13, 42000f7c <_stext+0xf5c> (3c028725 <blanks$1+0x51>)
42013827:	b5d6a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
4201382a:	0c0c      	movi.n	a12, 0
4201382c:	8fa0b2        	movi	a11, 143
4201382f:	b23681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013832:	0008e0        	callx8	a8
42013835:	1a79      	s32i.n	a7, a10, 4
42013837:	2a79      	s32i.n	a7, a10, 8
42013839:	0a79      	s32i.n	a7, a10, 0
4201383b:	3a79      	s32i.n	a7, a10, 12
4201383d:	d38c      	beqz.n	a3, 4201384e <_Bfree+0x3e>
4201383f:	9298      	l32i.n	a9, a2, 36
42013841:	1388      	l32i.n	a8, a3, 4
42013843:	3998      	l32i.n	a9, a9, 12
42013845:	a08890        	addx4	a8, a8, a9
42013848:	0898      	l32i.n	a9, a8, 0
4201384a:	0399      	s32i.n	a9, a3, 0
4201384c:	0839      	s32i.n	a3, a8, 0
4201384e:	f01d      	retw.n

42013850 <__multadd>:
42013850:	004136        	entry	a1, 32
42013853:	4368      	l32i.n	a6, a3, 16
42013855:	1a0c      	movi.n	a10, 1
42013857:	027d      	mov.n	a7, a2
42013859:	14c3b2        	addi	a11, a3, 20
4201385c:	032d      	mov.n	a2, a3
4201385e:	53aa60        	max	a10, a10, a6
42013861:	238a76        	loop	a10, 42013888 <__multadd+0x38>
42013864:	0b88      	l32i.n	a8, a11, 0
42013866:	f49080        	extui	a9, a8, 0, 16
42013869:	829940        	mull	a9, a9, a4
4201386c:	f58080        	extui	a8, a8, 16, 16
4201386f:	995a      	add.n	a9, a9, a5
42013871:	828840        	mull	a8, a8, a4
42013874:	f5c090        	extui	a12, a9, 16, 16
42013877:	88ca      	add.n	a8, a8, a12
42013879:	f55080        	extui	a5, a8, 16, 16
4201387c:	f49090        	extui	a9, a9, 0, 16
4201387f:	118800        	slli	a8, a8, 16
42013882:	889a      	add.n	a8, a8, a9
42013884:	0b89      	s32i.n	a8, a11, 0
42013886:	bb4b      	addi.n	a11, a11, 4
42013888:	049516        	beqz	a5, 420138d5 <__multadd+0x85>
4201388b:	2288      	l32i.n	a8, a2, 8
4201388d:	3b2687        	blt	a6, a8, 420138cc <__multadd+0x7c>
42013890:	12b8      	l32i.n	a11, a2, 4
42013892:	07ad      	mov.n	a10, a7
42013894:	bb1b      	addi.n	a11, a11, 1
42013896:	ffef25        	call8	42013788 <_Balloc>
42013899:	0a4d      	mov.n	a4, a10
4201389b:	facc      	bnez.n	a10, 420138ae <__multadd+0x5e>
4201389d:	b5bad1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
420138a0:	b5b8a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
420138a3:	0c0c      	movi.n	a12, 0
420138a5:	baa0b2        	movi	a11, 186
420138a8:	b21881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420138ab:	0008e0        	callx8	a8
420138ae:	42c8      	l32i.n	a12, a2, 16
420138b0:	0cc2b2        	addi	a11, a2, 12
420138b3:	02ccc2        	addi	a12, a12, 2
420138b6:	11cce0        	slli	a12, a12, 2
420138b9:	0ccaa2        	addi	a10, a10, 12
420138bc:	b1db81        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
420138bf:	0008e0        	callx8	a8
420138c2:	02bd      	mov.n	a11, a2
420138c4:	20a770        	or	a10, a7, a7
420138c7:	fff4a5        	call8	42013810 <_Bfree>
420138ca:	042d      	mov.n	a2, a4
420138cc:	a08620        	addx4	a8, a6, a2
420138cf:	5859      	s32i.n	a5, a8, 20
420138d1:	661b      	addi.n	a6, a6, 1
420138d3:	4269      	s32i.n	a6, a2, 16
420138d5:	f01d      	retw.n
	...

420138d8 <__s2b>:
420138d8:	004136        	entry	a1, 32
420138db:	b5ac81        	l32r	a8, 42000f8c <_stext+0xf6c> (38e38e39 <UserFrameTotalSize+0x38e38d39>)
420138de:	958b      	addi.n	a9, a5, 8
420138e0:	b28980        	mulsh	a8, a9, a8
420138e3:	319f90        	srai	a9, a9, 31
420138e6:	218180        	srai	a8, a8, 1
420138e9:	c08890        	sub	a8, a8, a9
420138ec:	0b0c      	movi.n	a11, 0
420138ee:	190c      	movi.n	a9, 1
420138f0:	000106        	j	420138f8 <__s2b+0x20>
420138f3:	00          	.byte	00
420138f4:	999a      	add.n	a9, a9, a9
420138f6:	bb1b      	addi.n	a11, a11, 1
420138f8:	f82987        	blt	a9, a8, 420138f4 <__s2b+0x1c>
420138fb:	02ad      	mov.n	a10, a2
420138fd:	ffe8a5        	call8	42013788 <_Balloc>
42013900:	0abd      	mov.n	a11, a10
42013902:	facc      	bnez.n	a10, 42013915 <__s2b+0x3d>
42013904:	b5a1d1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013907:	b59ea1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
4201390a:	0c0c      	movi.n	a12, 0
4201390c:	d3a0b2        	movi	a11, 211
4201390f:	b1fe81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013912:	0008e0        	callx8	a8
42013915:	180c      	movi.n	a8, 1
42013917:	4a89      	s32i.n	a8, a10, 16
42013919:	5a69      	s32i.n	a6, a10, 20
4201391b:	980c      	movi.n	a8, 9
4201391d:	23a847        	bge	a8, a4, 42013944 <__s2b+0x6c>
42013920:	09c372        	addi	a7, a3, 9
42013923:	076d      	mov.n	a6, a7
42013925:	803340        	add	a3, a3, a4
42013928:	0006d2        	l8ui	a13, a6, 0
4201392b:	ac0c      	movi.n	a12, 10
4201392d:	d0cdd2        	addi	a13, a13, -48
42013930:	02ad      	mov.n	a10, a2
42013932:	fff1e5        	call8	42013850 <__multadd>
42013935:	661b      	addi.n	a6, a6, 1
42013937:	0abd      	mov.n	a11, a10
42013939:	eb9637        	bne	a6, a3, 42013928 <__s2b+0x50>
4201393c:	774a      	add.n	a7, a7, a4
4201393e:	f8c732        	addi	a3, a7, -8
42013941:	0000c6        	j	42013948 <__s2b+0x70>
42013944:	33ab      	addi.n	a3, a3, 10
42013946:	940c      	movi.n	a4, 9
42013948:	047d      	mov.n	a7, a4
4201394a:	000586        	j	42013964 <__s2b+0x8c>
4201394d:	c08740        	sub	a8, a7, a4
42013950:	838a      	add.n	a8, a3, a8
42013952:	0008d2        	l8ui	a13, a8, 0
42013955:	ac0c      	movi.n	a12, 10
42013957:	d0cdd2        	addi	a13, a13, -48
4201395a:	20a220        	or	a10, a2, a2
4201395d:	ffef25        	call8	42013850 <__multadd>
42013960:	0abd      	mov.n	a11, a10
42013962:	771b      	addi.n	a7, a7, 1
42013964:	e52757        	blt	a7, a5, 4201394d <__s2b+0x75>
42013967:	0b2d      	mov.n	a2, a11
42013969:	f01d      	retw.n
	...

4201396c <__hi0bits>:
4201396c:	004136        	entry	a1, 32
4201396f:	f97c      	movi.n	a9, -1
42013971:	028d      	mov.n	a8, a2
42013973:	f59090        	extui	a9, a9, 16, 16
42013976:	020c      	movi.n	a2, 0
42013978:	043987        	bltu	a9, a8, 42013980 <__hi0bits+0x14>
4201397b:	118800        	slli	a8, a8, 16
4201397e:	021c      	movi.n	a2, 16
42013980:	f97c      	movi.n	a9, -1
42013982:	419890        	srli	a9, a9, 8
42013985:	043987        	bltu	a9, a8, 4201398d <__hi0bits+0x21>
42013988:	228b      	addi.n	a2, a2, 8
4201398a:	118880        	slli	a8, a8, 8
4201398d:	f97c      	movi.n	a9, -1
4201398f:	419490        	srli	a9, a9, 4
42013992:	043987        	bltu	a9, a8, 4201399a <__hi0bits+0x2e>
42013995:	224b      	addi.n	a2, a2, 4
42013997:	1188c0        	slli	a8, a8, 4
4201399a:	f97c      	movi.n	a9, -1
4201399c:	419290        	srli	a9, a9, 2
4201399f:	053987        	bltu	a9, a8, 420139a8 <__hi0bits+0x3c>
420139a2:	02c222        	addi	a2, a2, 2
420139a5:	1188e0        	slli	a8, a8, 2
420139a8:	00c896        	bltz	a8, 420139b8 <__hi0bits+0x4c>
420139ab:	058e80        	extui	a8, a8, 30, 1
420139ae:	221b      	addi.n	a2, a2, 1
420139b0:	018820        	slli	a8, a8, 30
420139b3:	092c      	movi.n	a9, 32
420139b5:	832980        	moveqz	a2, a9, a8
420139b8:	f01d      	retw.n
	...

420139bc <__lo0bits>:
420139bc:	004136        	entry	a1, 32
420139bf:	0288      	l32i.n	a8, a2, 0
420139c1:	029d      	mov.n	a9, a2
420139c3:	24a080        	extui	a10, a8, 0, 3
420139c6:	aa9c      	beqz.n	a10, 420139e4 <__lo0bits+0x28>
420139c8:	020c      	movi.n	a2, 0
420139ca:	58e807        	bbsi	a8, 0, 42013a26 <__lo0bits+0x6a>
420139cd:	096817        	bbci	a8, 1, 420139da <__lo0bits+0x1e>
420139d0:	418180        	srli	a8, a8, 1
420139d3:	0989      	s32i.n	a8, a9, 0
420139d5:	120c      	movi.n	a2, 1
420139d7:	0012c6        	j	42013a26 <__lo0bits+0x6a>
420139da:	418280        	srli	a8, a8, 2
420139dd:	0989      	s32i.n	a8, a9, 0
420139df:	220c      	movi.n	a2, 2
420139e1:	001046        	j	42013a26 <__lo0bits+0x6a>
420139e4:	f4a080        	extui	a10, a8, 0, 16
420139e7:	020c      	movi.n	a2, 0
420139e9:	3acc      	bnez.n	a10, 420139f0 <__lo0bits+0x34>
420139eb:	f58080        	extui	a8, a8, 16, 16
420139ee:	021c      	movi.n	a2, 16
420139f0:	74a080        	extui	a10, a8, 0, 8
420139f3:	005a56        	bnez	a10, 420139fc <__lo0bits+0x40>
420139f6:	08c222        	addi	a2, a2, 8
420139f9:	418880        	srli	a8, a8, 8
420139fc:	34a080        	extui	a10, a8, 0, 4
420139ff:	005a56        	bnez	a10, 42013a08 <__lo0bits+0x4c>
42013a02:	04c222        	addi	a2, a2, 4
42013a05:	418480        	srli	a8, a8, 4
42013a08:	14a080        	extui	a10, a8, 0, 2
42013a0b:	005a56        	bnez	a10, 42013a14 <__lo0bits+0x58>
42013a0e:	02c222        	addi	a2, a2, 2
42013a11:	418280        	srli	a8, a8, 2
42013a14:	06e807        	bbsi	a8, 0, 42013a1e <__lo0bits+0x62>
42013a17:	418180        	srli	a8, a8, 1
42013a1a:	221b      	addi.n	a2, a2, 1
42013a1c:	488c      	beqz.n	a8, 42013a24 <__lo0bits+0x68>
42013a1e:	0989      	s32i.n	a8, a9, 0
42013a20:	000086        	j	42013a26 <__lo0bits+0x6a>
42013a23:	022c00        	andb	b2, b12, b0
42013a26:	f01d      	retw.n

42013a28 <__i2b>:
42013a28:	004136        	entry	a1, 32
42013a2b:	02ad      	mov.n	a10, a2
42013a2d:	1b0c      	movi.n	a11, 1
42013a2f:	ffd5a5        	call8	42013788 <_Balloc>
42013a32:	0a2d      	mov.n	a2, a10
42013a34:	0adc      	bnez.n	a10, 42013a48 <__i2b+0x20>
42013a36:	b554d1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013a39:	b551a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
42013a3c:	00a0c2        	movi	a12, 0
42013a3f:	45a1b2        	movi	a11, 0x145
42013a42:	b1b181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013a45:	0008e0        	callx8	a8
42013a48:	180c      	movi.n	a8, 1
42013a4a:	5a39      	s32i.n	a3, a10, 20
42013a4c:	4a89      	s32i.n	a8, a10, 16
42013a4e:	f01d      	retw.n

42013a50 <__multiply>:
42013a50:	006136        	entry	a1, 48
42013a53:	4368      	l32i.n	a6, a3, 16
42013a55:	4458      	l32i.n	a5, a4, 16
42013a57:	02ad      	mov.n	a10, a2
42013a59:	0d2657        	blt	a6, a5, 42013a6a <__multiply+0x1a>
42013a5c:	058d      	mov.n	a8, a5
42013a5e:	065d      	mov.n	a5, a6
42013a60:	086d      	mov.n	a6, a8
42013a62:	048d      	mov.n	a8, a4
42013a64:	204330        	or	a4, a3, a3
42013a67:	203880        	or	a3, a8, a8
42013a6a:	2488      	l32i.n	a8, a4, 8
42013a6c:	756a      	add.n	a7, a5, a6
42013a6e:	14b8      	l32i.n	a11, a4, 4
42013a70:	01a877        	bge	a8, a7, 42013a75 <__multiply+0x25>
42013a73:	bb1b      	addi.n	a11, a11, 1
42013a75:	ffd125        	call8	42013788 <_Balloc>
42013a78:	01a9      	s32i.n	a10, a1, 0
42013a7a:	facc      	bnez.n	a10, 42013a8d <__multiply+0x3d>
42013a7c:	b543d1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013a7f:	b540a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
42013a82:	0c0c      	movi.n	a12, 0
42013a84:	62a1b2        	movi	a11, 0x162
42013a87:	b1a081        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013a8a:	0008e0        	callx8	a8
42013a8d:	0188      	l32i.n	a8, a1, 0
42013a8f:	090c      	movi.n	a9, 0
42013a91:	14c8b2        	addi	a11, a8, 20
42013a94:	a027b0        	addx4	a2, a7, a11
42013a97:	0b8d      	mov.n	a8, a11
42013a99:	0000c6        	j	42013aa0 <__multiply+0x50>
42013a9c:	0899      	s32i.n	a9, a8, 0
42013a9e:	884b      	addi.n	a8, a8, 4
42013aa0:	f83827        	bltu	a8, a2, 42013a9c <__multiply+0x4c>
42013aa3:	14c332        	addi	a3, a3, 20
42013aa6:	a09630        	addx4	a9, a6, a3
42013aa9:	14c4c2        	addi	a12, a4, 20
42013aac:	a085c0        	addx4	a8, a5, a12
42013aaf:	3199      	s32i.n	a9, a1, 12
42013ab1:	15c492        	addi	a9, a4, 21
42013ab4:	629890        	saltu	a9, a8, a9
42013ab7:	990b      	addi.n	a9, a9, -1
42013ab9:	609090        	neg	a9, a9
42013abc:	0a0c      	movi.n	a10, 0
42013abe:	749090        	extui	a9, a9, 0, 8
42013ac1:	11a9      	s32i.n	a10, a1, 4
42013ac3:	0e2916        	beqz	a9, 42013ba9 <__multiply+0x159>
42013ac6:	15c442        	addi	a4, a4, 21
42013ac9:	604040        	neg	a4, a4
42013acc:	448a      	add.n	a4, a4, a8
42013ace:	414240        	srli	a4, a4, 2
42013ad1:	1194e0        	slli	a9, a4, 2
42013ad4:	1199      	s32i.n	a9, a1, 4
42013ad6:	0033c6        	j	42013ba9 <__multiply+0x159>
42013ad9:	00          	.byte	00
42013ada:	0358      	l32i.n	a5, a3, 0
42013adc:	f49050        	extui	a9, a5, 0, 16
42013adf:	05a916        	beqz	a9, 42013b3d <__multiply+0xed>
42013ae2:	f97c      	movi.n	a9, -1
42013ae4:	309c90        	xor	a9, a12, a9
42013ae7:	989a      	add.n	a9, a8, a9
42013ae9:	419290        	srli	a9, a9, 2
42013aec:	ac4b      	addi.n	a10, a12, 4
42013aee:	d83b      	addi.n	a13, a8, 3
42013af0:	0bfd      	mov.n	a15, a11
42013af2:	0c4d      	mov.n	a4, a12
42013af4:	060c      	movi.n	a6, 0
42013af6:	991b      	addi.n	a9, a9, 1
42013af8:	023da7        	bltu	a13, a10, 42013afe <__multiply+0xae>
42013afb:	001856        	bnez	a8, 42013b00 <__multiply+0xb0>
42013afe:	190c      	movi.n	a9, 1
42013b00:	f03d      	nop.n
42013b02:	318976        	loop	a9, 42013b37 <__multiply+0xe7>
42013b05:	04e8      	l32i.n	a14, a4, 0
42013b07:	0fd8      	l32i.n	a13, a15, 0
42013b09:	c1ae50        	mul16u	a10, a14, a5
42013b0c:	f4d0d0        	extui	a13, a13, 0, 16
42013b0f:	aada      	add.n	a10, a10, a13
42013b11:	f5e0e0        	extui	a14, a14, 16, 16
42013b14:	0fd8      	l32i.n	a13, a15, 0
42013b16:	c1ee50        	mul16u	a14, a14, a5
42013b19:	aa6a      	add.n	a10, a10, a6
42013b1b:	f5d0d0        	extui	a13, a13, 16, 16
42013b1e:	deda      	add.n	a13, a14, a13
42013b20:	f5e0a0        	extui	a14, a10, 16, 16
42013b23:	ddea      	add.n	a13, a13, a14
42013b25:	f560d0        	extui	a6, a13, 16, 16
42013b28:	f4a0a0        	extui	a10, a10, 0, 16
42013b2b:	11dd00        	slli	a13, a13, 16
42013b2e:	20dda0        	or	a13, a13, a10
42013b31:	0fd9      	s32i.n	a13, a15, 0
42013b33:	444b      	addi.n	a4, a4, 4
42013b35:	ff4b      	addi.n	a15, a15, 4
42013b37:	1198      	l32i.n	a9, a1, 4
42013b39:	9b9a      	add.n	a9, a11, a9
42013b3b:	1969      	s32i.n	a6, a9, 4
42013b3d:	011362        	l16ui	a6, a3, 2
42013b40:	061616        	beqz	a6, 42013ba5 <__multiply+0x155>
42013b43:	f97c      	movi.n	a9, -1
42013b45:	309c90        	xor	a9, a12, a9
42013b48:	989a      	add.n	a9, a8, a9
42013b4a:	419290        	srli	a9, a9, 2
42013b4d:	991b      	addi.n	a9, a9, 1
42013b4f:	0ba8      	l32i.n	a10, a11, 0
42013b51:	2199      	s32i.n	a9, a1, 8
42013b53:	5c4b      	addi.n	a5, a12, 4
42013b55:	983b      	addi.n	a9, a8, 3
42013b57:	0cfd      	mov.n	a15, a12
42013b59:	0bed      	mov.n	a14, a11
42013b5b:	0add      	mov.n	a13, a10
42013b5d:	040c      	movi.n	a4, 0
42013b5f:	013957        	bltu	a9, a5, 42013b64 <__multiply+0x114>
42013b62:	28cc      	bnez.n	a8, 42013b68 <__multiply+0x118>
42013b64:	190c      	movi.n	a9, 1
42013b66:	2199      	s32i.n	a9, a1, 8
42013b68:	0f58      	l32i.n	a5, a15, 0
42013b6a:	f5d0d0        	extui	a13, a13, 16, 16
42013b6d:	c15560        	mul16u	a5, a5, a6
42013b70:	f4a0a0        	extui	a10, a10, 0, 16
42013b73:	554a      	add.n	a5, a5, a4
42013b75:	55da      	add.n	a5, a5, a13
42013b77:	11d500        	slli	a13, a5, 16
42013b7a:	20dda0        	or	a13, a13, a10
42013b7d:	0ed9      	s32i.n	a13, a14, 0
42013b7f:	011f42        	l16ui	a4, a15, 2
42013b82:	1ed8      	l32i.n	a13, a14, 4
42013b84:	c14460        	mul16u	a4, a4, a6
42013b87:	f4a0d0        	extui	a10, a13, 0, 16
42013b8a:	a4aa      	add.n	a10, a4, a10
42013b8c:	f55050        	extui	a5, a5, 16, 16
42013b8f:	2198      	l32i.n	a9, a1, 8
42013b91:	aa5a      	add.n	a10, a10, a5
42013b93:	f540a0        	extui	a4, a10, 16, 16
42013b96:	ff4b      	addi.n	a15, a15, 4
42013b98:	ee4b      	addi.n	a14, a14, 4
42013b9a:	990b      	addi.n	a9, a9, -1
42013b9c:	fc6956        	bnez	a9, 42013b66 <__multiply+0x116>
42013b9f:	1198      	l32i.n	a9, a1, 4
42013ba1:	9b9a      	add.n	a9, a11, a9
42013ba3:	19a9      	s32i.n	a10, a9, 4
42013ba5:	334b      	addi.n	a3, a3, 4
42013ba7:	bb4b      	addi.n	a11, a11, 4
42013ba9:	3198      	l32i.n	a9, a1, 12
42013bab:	02b397        	bgeu	a3, a9, 42013bb1 <__multiply+0x161>
42013bae:	ffca06        	j	42013ada <__multiply+0x8a>
42013bb1:	000046        	j	42013bb6 <__multiply+0x166>
42013bb4:	770b      	addi.n	a7, a7, -1
42013bb6:	0717a6        	blti	a7, 1, 42013bc1 <__multiply+0x171>
42013bb9:	fcc222        	addi	a2, a2, -4
42013bbc:	0288      	l32i.n	a8, a2, 0
42013bbe:	ff2816        	beqz	a8, 42013bb4 <__multiply+0x164>
42013bc1:	0188      	l32i.n	a8, a1, 0
42013bc3:	4879      	s32i.n	a7, a8, 16
42013bc5:	082d      	mov.n	a2, a8
42013bc7:	f01d      	retw.n
42013bc9:	000000        	ill

42013bcc <__pow5mult>:
42013bcc:	004136        	entry	a1, 32
42013bcf:	148040        	extui	a8, a4, 0, 2
42013bd2:	026d      	mov.n	a6, a2
42013bd4:	032d      	mov.n	a2, a3
42013bd6:	689c      	beqz.n	a8, 42013bf0 <__pow5mult+0x24>
42013bd8:	b4ee91        	l32r	a9, 42000f90 <_stext+0xf70> (3c028a40 <p05$0>)
42013bdb:	880b      	addi.n	a8, a8, -1
42013bdd:	a08890        	addx4	a8, a8, a9
42013be0:	08c8      	l32i.n	a12, a8, 0
42013be2:	00a0d2        	movi	a13, 0
42013be5:	20b330        	or	a11, a3, a3
42013be8:	20a660        	or	a10, a6, a6
42013beb:	ffc665        	call8	42013850 <__multadd>
42013bee:	0a2d      	mov.n	a2, a10
42013bf0:	214240        	srai	a4, a4, 2
42013bf3:	07e416        	beqz	a4, 42013c75 <__pow5mult+0xa9>
42013bf6:	9658      	l32i.n	a5, a6, 36
42013bf8:	85ec      	bnez.n	a5, 42013c24 <__pow5mult+0x58>
42013bfa:	0a1c      	movi.n	a10, 16
42013bfc:	b2f081        	l32r	a8, 420007bc <_stext+0x79c> (4037fe84 <malloc>)
42013bff:	0008e0        	callx8	a8
42013c02:	96a9      	s32i.n	a10, a6, 36
42013c04:	0a5d      	mov.n	a5, a10
42013c06:	0adc      	bnez.n	a10, 42013c1a <__pow5mult+0x4e>
42013c08:	b4ddd1        	l32r	a13, 42000f7c <_stext+0xf5c> (3c028725 <blanks$1+0x51>)
42013c0b:	b4dda1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
42013c0e:	00a0c2        	movi	a12, 0
42013c11:	b3a1b2        	movi	a11, 0x1b3
42013c14:	b13d81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013c17:	0008e0        	callx8	a8
42013c1a:	080c      	movi.n	a8, 0
42013c1c:	1a89      	s32i.n	a8, a10, 4
42013c1e:	2a89      	s32i.n	a8, a10, 8
42013c20:	0a89      	s32i.n	a8, a10, 0
42013c22:	3a89      	s32i.n	a8, a10, 12
42013c24:	2578      	l32i.n	a7, a5, 8
42013c26:	e7cc      	bnez.n	a7, 42013c38 <__pow5mult+0x6c>
42013c28:	71a2b2        	movi	a11, 0x271
42013c2b:	06ad      	mov.n	a10, a6
42013c2d:	ffdfa5        	call8	42013a28 <__i2b>
42013c30:	25a9      	s32i.n	a10, a5, 8
42013c32:	080c      	movi.n	a8, 0
42013c34:	0a7d      	mov.n	a7, a10
42013c36:	0a89      	s32i.n	a8, a10, 0
42013c38:	023d      	mov.n	a3, a2
42013c3a:	050c      	movi.n	a5, 0
42013c3c:	000106        	j	42013c44 <__pow5mult+0x78>
42013c3f:	0a7d00        	add.s	f7, f13, f0
42013c42:	023d      	mov.n	a3, a2
42013c44:	048040        	extui	a8, a4, 0, 1
42013c47:	214140        	srai	a4, a4, 1
42013c4a:	289c      	beqz.n	a8, 42013c60 <__pow5mult+0x94>
42013c4c:	02bd      	mov.n	a11, a2
42013c4e:	07cd      	mov.n	a12, a7
42013c50:	06ad      	mov.n	a10, a6
42013c52:	ffdfe5        	call8	42013a50 <__multiply>
42013c55:	0a2d      	mov.n	a2, a10
42013c57:	03bd      	mov.n	a11, a3
42013c59:	06ad      	mov.n	a10, a6
42013c5b:	ffbb65        	call8	42013810 <_Bfree>
42013c5e:	349c      	beqz.n	a4, 42013c75 <__pow5mult+0xa9>
42013c60:	07a8      	l32i.n	a10, a7, 0
42013c62:	fdaa56        	bnez	a10, 42013c40 <__pow5mult+0x74>
42013c65:	07cd      	mov.n	a12, a7
42013c67:	07bd      	mov.n	a11, a7
42013c69:	06ad      	mov.n	a10, a6
42013c6b:	ffde65        	call8	42013a50 <__multiply>
42013c6e:	07a9      	s32i.n	a10, a7, 0
42013c70:	0a59      	s32i.n	a5, a10, 0
42013c72:	fff286        	j	42013c40 <__pow5mult+0x74>
42013c75:	f01d      	retw.n
	...

42013c78 <__lshift>:
42013c78:	006136        	entry	a1, 48
42013c7b:	4368      	l32i.n	a6, a3, 16
42013c7d:	04dd      	mov.n	a13, a4
42013c7f:	214540        	srai	a4, a4, 5
42013c82:	646a      	add.n	a6, a4, a6
42013c84:	13b8      	l32i.n	a11, a3, 4
42013c86:	2388      	l32i.n	a8, a3, 8
42013c88:	027d      	mov.n	a7, a2
42013c8a:	561b      	addi.n	a5, a6, 1
42013c8c:	000106        	j	42013c94 <__lshift+0x1c>
42013c8f:	bb1b00        	movgez.s	f1, f11, a0
42013c92:	888a      	add.n	a8, a8, a8
42013c94:	f82857        	blt	a8, a5, 42013c90 <__lshift+0x18>
42013c97:	07ad      	mov.n	a10, a7
42013c99:	01d9      	s32i.n	a13, a1, 0
42013c9b:	ffaee5        	call8	42013788 <_Balloc>
42013c9e:	0a2d      	mov.n	a2, a10
42013ca0:	14caa2        	addi	a10, a10, 20
42013ca3:	01d8      	l32i.n	a13, a1, 0
42013ca5:	0a9d      	mov.n	a9, a10
42013ca7:	080c      	movi.n	a8, 0
42013ca9:	0b0c      	movi.n	a11, 0
42013cab:	62dc      	bnez.n	a2, 42013cc5 <__lshift+0x4d>
42013cad:	b4b6d1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013cb0:	b4b4a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
42013cb3:	0c0c      	movi.n	a12, 0
42013cb5:	dea1b2        	movi	a11, 0x1de
42013cb8:	b11481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013cbb:	0008e0        	callx8	a8
42013cbe:	09b9      	s32i.n	a11, a9, 0
42013cc0:	881b      	addi.n	a8, a8, 1
42013cc2:	04c992        	addi	a9, a9, 4
42013cc5:	f52847        	blt	a8, a4, 42013cbe <__lshift+0x46>
42013cc8:	080c      	movi.n	a8, 0
42013cca:	539480        	max	a9, a4, a8
42013ccd:	43c8      	l32i.n	a12, a3, 16
42013ccf:	a099a0        	addx4	a9, a9, a10
42013cd2:	14c382        	addi	a8, a3, 20
42013cd5:	0199      	s32i.n	a9, a1, 0
42013cd7:	4440d0        	extui	a4, a13, 0, 5
42013cda:	a0cc80        	addx4	a12, a12, a8
42013cdd:	06b416        	beqz	a4, 42013d4c <__lshift+0xd4>
42013ce0:	fb7c      	movi.n	a11, -1
42013ce2:	30b8b0        	xor	a11, a8, a11
42013ce5:	bcba      	add.n	a11, a12, a11
42013ce7:	e0c4a2        	addi	a10, a4, -32
42013cea:	41b2b0        	srli	a11, a11, 2
42013ced:	18c3e2        	addi	a14, a3, 24
42013cf0:	fc3b      	addi.n	a15, a12, 3
42013cf2:	60a0a0        	neg	a10, a10
42013cf5:	0d0c      	movi.n	a13, 0
42013cf7:	bb1b      	addi.n	a11, a11, 1
42013cf9:	013fe7        	bltu	a15, a14, 42013cfe <__lshift+0x86>
42013cfc:	0ccc      	bnez.n	a12, 42013d00 <__lshift+0x88>
42013cfe:	1b0c      	movi.n	a11, 1
42013d00:	f03d      	nop.n
42013d02:	1a8b76        	loop	a11, 42013d20 <__lshift+0xa8>
42013d05:	08e8      	l32i.n	a14, a8, 0
42013d07:	09fd      	mov.n	a15, a9
42013d09:	401400        	ssl	a4
42013d0c:	a1ee00        	sll	a14, a14
42013d0f:	20eed0        	or	a14, a14, a13
42013d12:	0fe9      	s32i.n	a14, a15, 0
42013d14:	08d8      	l32i.n	a13, a8, 0
42013d16:	994b      	addi.n	a9, a9, 4
42013d18:	400a00        	ssr	a10
42013d1b:	91d0d0        	srl	a13, a13
42013d1e:	884b      	addi.n	a8, a8, 4
42013d20:	15c382        	addi	a8, a3, 21
42013d23:	628c80        	saltu	a8, a12, a8
42013d26:	880b      	addi.n	a8, a8, -1
42013d28:	608080        	neg	a8, a8
42013d2b:	749080        	extui	a9, a8, 0, 8
42013d2e:	080c      	movi.n	a8, 0
42013d30:	c98c      	beqz.n	a9, 42013d40 <__lshift+0xc8>
42013d32:	15c382        	addi	a8, a3, 21
42013d35:	608080        	neg	a8, a8
42013d38:	88ca      	add.n	a8, a8, a12
42013d3a:	418280        	srli	a8, a8, 2
42013d3d:	1188e0        	slli	a8, a8, 2
42013d40:	0198      	l32i.n	a9, a1, 0
42013d42:	898a      	add.n	a8, a9, a8
42013d44:	18d9      	s32i.n	a13, a8, 4
42013d46:	adec      	bnez.n	a13, 42013d74 <__lshift+0xfc>
42013d48:	000946        	j	42013d71 <__lshift+0xf9>
42013d4b:	fa7c00        	mov.s	f7, f12
42013d4e:	30a8a0        	xor	a10, a8, a10
42013d51:	acaa      	add.n	a10, a12, a10
42013d53:	41a2a0        	srli	a10, a10, 2
42013d56:	18c3b2        	addi	a11, a3, 24
42013d59:	dc3b      	addi.n	a13, a12, 3
42013d5b:	aa1b      	addi.n	a10, a10, 1
42013d5d:	013db7        	bltu	a13, a11, 42013d62 <__lshift+0xea>
42013d60:	0ccc      	bnez.n	a12, 42013d64 <__lshift+0xec>
42013d62:	1a0c      	movi.n	a10, 1
42013d64:	f03d      	nop.n
42013d66:	078a76        	loop	a10, 42013d71 <__lshift+0xf9>
42013d69:	08c8      	l32i.n	a12, a8, 0
42013d6b:	884b      	addi.n	a8, a8, 4
42013d6d:	09c9      	s32i.n	a12, a9, 0
42013d6f:	994b      	addi.n	a9, a9, 4
42013d71:	205660        	or	a5, a6, a6
42013d74:	4259      	s32i.n	a5, a2, 16
42013d76:	03bd      	mov.n	a11, a3
42013d78:	07ad      	mov.n	a10, a7
42013d7a:	ffa965        	call8	42013810 <_Bfree>
42013d7d:	f01d      	retw.n
	...

42013d80 <__mcmp>:
42013d80:	004136        	entry	a1, 32
42013d83:	43a8      	l32i.n	a10, a3, 16
42013d85:	028d      	mov.n	a8, a2
42013d87:	4228      	l32i.n	a2, a2, 16
42013d89:	c022a0        	sub	a2, a2, a10
42013d8c:	82ec      	bnez.n	a2, 42013db8 <__mcmp+0x38>
42013d8e:	14c892        	addi	a9, a8, 20
42013d91:	14c332        	addi	a3, a3, 20
42013d94:	118ae0        	slli	a8, a10, 2
42013d97:	a98a      	add.n	a10, a9, a8
42013d99:	808380        	add	a8, a3, a8
42013d9c:	fccaa2        	addi	a10, a10, -4
42013d9f:	fcc882        	addi	a8, a8, -4
42013da2:	0ac8      	l32i.n	a12, a10, 0
42013da4:	08b8      	l32i.n	a11, a8, 0
42013da6:	0b1cb7        	beq	a12, a11, 42013db5 <__mcmp+0x35>
42013da9:	120c      	movi.n	a2, 1
42013dab:	09bcb7        	bgeu	a12, a11, 42013db8 <__mcmp+0x38>
42013dae:	f27c      	movi.n	a2, -1
42013db0:	000106        	j	42013db8 <__mcmp+0x38>
42013db3:	a70000        	ee.stf.64.xp	f0, f10, a0, a0
42013db6:	e339      	s32i.n	a3, a3, 56
42013db8:	f01d      	retw.n
	...

42013dbc <__mdiff>:
42013dbc:	006136        	entry	a1, 48
42013dbf:	04bd      	mov.n	a11, a4
42013dc1:	03ad      	mov.n	a10, a3
42013dc3:	fffbe5        	call8	42013d80 <__mcmp>
42013dc6:	0a7d      	mov.n	a7, a10
42013dc8:	dadc      	bnez.n	a10, 42013de9 <__mdiff+0x2d>
42013dca:	02ad      	mov.n	a10, a2
42013dcc:	0b0c      	movi.n	a11, 0
42013dce:	ff9ba5        	call8	42013788 <_Balloc>
42013dd1:	0a2d      	mov.n	a2, a10
42013dd3:	9acc      	bnez.n	a10, 42013de0 <__mdiff+0x24>
42013dd5:	b46cd1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013dd8:	0c0c      	movi.n	a12, 0
42013dda:	37a2b2        	movi	a11, 0x237
42013ddd:	000a06        	j	42013e09 <__mdiff+0x4d>
42013de0:	180c      	movi.n	a8, 1
42013de2:	4a89      	s32i.n	a8, a10, 16
42013de4:	5a79      	s32i.n	a7, a10, 20
42013de6:	0046c6        	j	42013f05 <__mdiff+0x149>
42013de9:	060c      	movi.n	a6, 0
42013deb:	007ad6        	bgez	a10, 42013df6 <__mdiff+0x3a>
42013dee:	038d      	mov.n	a8, a3
42013df0:	160c      	movi.n	a6, 1
42013df2:	043d      	mov.n	a3, a4
42013df4:	084d      	mov.n	a4, a8
42013df6:	13b8      	l32i.n	a11, a3, 4
42013df8:	02ad      	mov.n	a10, a2
42013dfa:	ff98e5        	call8	42013788 <_Balloc>
42013dfd:	0a2d      	mov.n	a2, a10
42013dff:	facc      	bnez.n	a10, 42013e12 <__mdiff+0x56>
42013e01:	b461d1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013e04:	0c0c      	movi.n	a12, 0
42013e06:	45a2b2        	movi	a11, 0x245
42013e09:	b45da1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
42013e0c:	b0bf81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013e0f:	0008e0        	callx8	a8
42013e12:	3a69      	s32i.n	a6, a10, 12
42013e14:	44a8      	l32i.n	a10, a4, 16
42013e16:	14c482        	addi	a8, a4, 20
42013e19:	a0aa80        	addx4	a10, a10, a8
42013e1c:	ebca92        	addi	a9, a10, -21
42013e1f:	43f8      	l32i.n	a15, a3, 16
42013e21:	c09940        	sub	a9, a9, a4
42013e24:	14c3d2        	addi	a13, a3, 20
42013e27:	419290        	srli	a9, a9, 2
42013e2a:	18c482        	addi	a8, a4, 24
42013e2d:	ba3b      	addi.n	a11, a10, 3
42013e2f:	a0cfd0        	addx4	a12, a15, a13
42013e32:	14c252        	addi	a5, a2, 20
42013e35:	4e1c      	movi.n	a14, 20
42013e37:	070c      	movi.n	a7, 0
42013e39:	01c992        	addi	a9, a9, 1
42013e3c:	023b87        	bltu	a11, a8, 42013e42 <__mdiff+0x86>
42013e3f:	001a56        	bnez	a10, 42013e44 <__mdiff+0x88>
42013e42:	190c      	movi.n	a9, 1
42013e44:	f03d      	nop.n
42013e46:	368976        	loop	a9, 42013e80 <__mdiff+0xc4>
42013e49:	b4ea      	add.n	a11, a4, a14
42013e4b:	83ea      	add.n	a8, a3, a14
42013e4d:	0888      	l32i.n	a8, a8, 0
42013e4f:	0b68      	l32i.n	a6, a11, 0
42013e51:	0189      	s32i.n	a8, a1, 0
42013e53:	f4b060        	extui	a11, a6, 0, 16
42013e56:	f48080        	extui	a8, a8, 0, 16
42013e59:	c0b8b0        	sub	a11, a8, a11
42013e5c:	0188      	l32i.n	a8, a1, 0
42013e5e:	bb7a      	add.n	a11, a11, a7
42013e60:	f56060        	extui	a6, a6, 16, 16
42013e63:	f58080        	extui	a8, a8, 16, 16
42013e66:	3170b0        	srai	a7, a11, 16
42013e69:	c08860        	sub	a8, a8, a6
42013e6c:	887a      	add.n	a8, a8, a7
42013e6e:	317080        	srai	a7, a8, 16
42013e71:	f4b0b0        	extui	a11, a11, 0, 16
42013e74:	118800        	slli	a8, a8, 16
42013e77:	62ea      	add.n	a6, a2, a14
42013e79:	20bb80        	or	a11, a11, a8
42013e7c:	06b9      	s32i.n	a11, a6, 0
42013e7e:	ee4b      	addi.n	a14, a14, 4
42013e80:	15c482        	addi	a8, a4, 21
42013e83:	628a80        	saltu	a8, a10, a8
42013e86:	880b      	addi.n	a8, a8, -1
42013e88:	608080        	neg	a8, a8
42013e8b:	749080        	extui	a9, a8, 0, 8
42013e8e:	080c      	movi.n	a8, 0
42013e90:	c98c      	beqz.n	a9, 42013ea0 <__mdiff+0xe4>
42013e92:	15c442        	addi	a4, a4, 21
42013e95:	604040        	neg	a4, a4
42013e98:	44aa      	add.n	a4, a4, a10
42013e9a:	414240        	srli	a4, a4, 2
42013e9d:	1184e0        	slli	a8, a4, 2
42013ea0:	958a      	add.n	a9, a5, a8
42013ea2:	8d8a      	add.n	a8, a13, a8
42013ea4:	b84b      	addi.n	a11, a8, 4
42013ea6:	994b      	addi.n	a9, a9, 4
42013ea8:	0b6d      	mov.n	a6, a11
42013eaa:	c0d5d0        	sub	a13, a5, a13
42013ead:	000886        	j	42013ed3 <__mdiff+0x117>
42013eb0:	06a8      	l32i.n	a10, a6, 0
42013eb2:	074d      	mov.n	a4, a7
42013eb4:	f4e0a0        	extui	a14, a10, 0, 16
42013eb7:	ee7a      	add.n	a14, a14, a7
42013eb9:	31e0e0        	srai	a14, a14, 16
42013ebc:	f570a0        	extui	a7, a10, 16, 16
42013ebf:	ee7a      	add.n	a14, a14, a7
42013ec1:	aa4a      	add.n	a10, a10, a4
42013ec3:	3170e0        	srai	a7, a14, 16
42013ec6:	f4a0a0        	extui	a10, a10, 0, 16
42013ec9:	11ee00        	slli	a14, a14, 16
42013ecc:	20aae0        	or	a10, a10, a14
42013ecf:	664b      	addi.n	a6, a6, 4
42013ed1:	05a9      	s32i.n	a10, a5, 0
42013ed3:	56da      	add.n	a5, a6, a13
42013ed5:	d736c7        	bltu	a6, a12, 42013eb0 <__mdiff+0xf4>
42013ed8:	881b      	addi.n	a8, a8, 1
42013eda:	628c80        	saltu	a8, a12, a8
42013edd:	880b      	addi.n	a8, a8, -1
42013edf:	608080        	neg	a8, a8
42013ee2:	748080        	extui	a8, a8, 0, 8
42013ee5:	0a0c      	movi.n	a10, 0
42013ee7:	988c      	beqz.n	a8, 42013ef4 <__mdiff+0x138>
42013ee9:	cc3b      	addi.n	a12, a12, 3
42013eeb:	c0ccb0        	sub	a12, a12, a11
42013eee:	41c2c0        	srli	a12, a12, 2
42013ef1:	11ace0        	slli	a10, a12, 2
42013ef4:	8a9a      	add.n	a8, a10, a9
42013ef6:	000046        	j	42013efb <__mdiff+0x13f>
42013ef9:	ff0b      	addi.n	a15, a15, -1
42013efb:	fcc882        	addi	a8, a8, -4
42013efe:	0898      	l32i.n	a9, a8, 0
42013f00:	ff5916        	beqz	a9, 42013ef9 <__mdiff+0x13d>
42013f03:	42f9      	s32i.n	a15, a2, 16
42013f05:	f01d      	retw.n
	...

42013f08 <__ulp>:
42013f08:	004136        	entry	a1, 32
42013f0b:	a58430        	extui	a8, a3, 20, 11
42013f0e:	397c      	movi.n	a9, -13
42013f10:	0188c0        	slli	a8, a8, 20
42013f13:	0199a0        	slli	a9, a9, 22
42013f16:	889a      	add.n	a8, a8, a9
42013f18:	0a0c      	movi.n	a10, 0
42013f1a:	3018e6        	bgei	a8, 1, 42013f4e <__ulp+0x46>
42013f1d:	608080        	neg	a8, a8
42013f20:	319480        	srai	a9, a8, 20
42013f23:	381c      	movi.n	a8, 19
42013f25:	0d2897        	blt	a8, a9, 42013f36 <__ulp+0x2e>
42013f28:	180c      	movi.n	a8, 1
42013f2a:	0188d0        	slli	a8, a8, 19
42013f2d:	400900        	ssr	a9
42013f30:	b18080        	sra	a8, a8
42013f33:	0005c6        	j	42013f4e <__ulp+0x46>
42013f36:	ecc992        	addi	a9, a9, -20
42013f39:	e81c      	movi.n	a8, 30
42013f3b:	01a0a2        	movi	a10, 1
42013f3e:	0a2897        	blt	a8, a9, 42013f4c <__ulp+0x44>
42013f41:	fa7c      	movi.n	a10, -1
42013f43:	01aa10        	slli	a10, a10, 31
42013f46:	400900        	ssr	a9
42013f49:	91a0a0        	srl	a10, a10
42013f4c:	080c      	movi.n	a8, 0
42013f4e:	083d      	mov.n	a3, a8
42013f50:	0a2d      	mov.n	a2, a10
42013f52:	f01d      	retw.n

42013f54 <__b2d>:
42013f54:	004136        	entry	a1, 32
42013f57:	4258      	l32i.n	a5, a2, 16
42013f59:	14c242        	addi	a4, a2, 20
42013f5c:	a05540        	addx4	a5, a5, a4
42013f5f:	fcc572        	addi	a7, a5, -4
42013f62:	0768      	l32i.n	a6, a7, 0
42013f64:	06ad      	mov.n	a10, a6
42013f66:	ffa065        	call8	4201396c <__hi0bits>
42013f69:	e0ca82        	addi	a8, a10, -32
42013f6c:	608080        	neg	a8, a8
42013f6f:	0389      	s32i.n	a8, a3, 0
42013f71:	ffa392        	movi	a9, 0x3ff
42013f74:	a80c      	movi.n	a8, 10
42013f76:	0199c0        	slli	a9, a9, 20
42013f79:	2528a7        	blt	a8, a10, 42013fa2 <__b2d+0x4e>
42013f7c:	f5cab2        	addi	a11, a10, -11
42013f7f:	60b0b0        	neg	a11, a11
42013f82:	400b00        	ssr	a11
42013f85:	918060        	srl	a8, a6
42013f88:	203890        	or	a3, a8, a9
42013f8b:	090c      	movi.n	a9, 0
42013f8d:	04b477        	bgeu	a4, a7, 42013f95 <__b2d+0x41>
42013f90:	f8c552        	addi	a5, a5, -8
42013f93:	0598      	l32i.n	a9, a5, 0
42013f95:	15ca82        	addi	a8, a10, 21
42013f98:	401800        	ssl	a8
42013f9b:	a18600        	sll	a8, a6
42013f9e:	000c46        	j	42013fd3 <__b2d+0x7f>
42013fa1:	080c00        	lsx	f0, a12, a0
42013fa4:	04b477        	bgeu	a4, a7, 42013fac <__b2d+0x58>
42013fa7:	f8c572        	addi	a7, a5, -8
42013faa:	0788      	l32i.n	a8, a7, 0
42013fac:	f5caa2        	addi	a10, a10, -11
42013faf:	203690        	or	a3, a6, a9
42013fb2:	6aac      	beqz.n	a10, 42013fdc <__b2d+0x88>
42013fb4:	e0cab2        	addi	a11, a10, -32
42013fb7:	401a00        	ssl	a10
42013fba:	816680        	src	a6, a6, a8
42013fbd:	203690        	or	a3, a6, a9
42013fc0:	60b0b0        	neg	a11, a11
42013fc3:	090c      	movi.n	a9, 0
42013fc5:	04b477        	bgeu	a4, a7, 42013fcd <__b2d+0x79>
42013fc8:	fcc772        	addi	a7, a7, -4
42013fcb:	0798      	l32i.n	a9, a7, 0
42013fcd:	401a00        	ssl	a10
42013fd0:	a18800        	sll	a8, a8
42013fd3:	400b00        	ssr	a11
42013fd6:	919090        	srl	a9, a9
42013fd9:	208890        	or	a8, a8, a9
42013fdc:	082d      	mov.n	a2, a8
42013fde:	f01d      	retw.n

42013fe0 <__d2b>:
42013fe0:	006136        	entry	a1, 48
42013fe3:	02ad      	mov.n	a10, a2
42013fe5:	1b0c      	movi.n	a11, 1
42013fe7:	ff7a25        	call8	42013788 <_Balloc>
42013fea:	0a2d      	mov.n	a2, a10
42013fec:	011a56        	bnez	a10, 42014001 <__d2b+0x21>
42013fef:	b3e6d1        	l32r	a13, 42000f88 <_stext+0xf68> (3c028790 <blanks$1+0xbc>)
42013ff2:	b3e3a1        	l32r	a10, 42000f80 <_stext+0xf60> (3c0287a1 <blanks$1+0xcd>)
42013ff5:	00a0c2        	movi	a12, 0
42013ff8:	0fa3b2        	movi	a11, 0x30f
42013ffb:	b04381        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42013ffe:	0008e0        	callx8	a8
42014001:	118540        	slli	a8, a5, 12
42014004:	a53450        	extui	a3, a5, 20, 11
42014007:	418c80        	srli	a8, a8, 12
4201400a:	738c      	beqz.n	a3, 42014015 <__d2b+0x35>
4201400c:	01a092        	movi	a9, 1
4201400f:	0199c0        	slli	a9, a9, 20
42014012:	208890        	or	a8, a8, a9
42014015:	0189      	s32i.n	a8, a1, 0
42014017:	74bc      	beqz.n	a4, 42014052 <__d2b+0x72>
42014019:	a14b      	addi.n	a10, a1, 4
4201401b:	1149      	s32i.n	a4, a1, 4
4201401d:	ff99e5        	call8	420139bc <__lo0bits>
42014020:	11b8      	l32i.n	a11, a1, 4
42014022:	ca9c      	beqz.n	a10, 42014042 <__d2b+0x62>
42014024:	0198      	l32i.n	a9, a1, 0
42014026:	e0ca82        	addi	a8, a10, -32
42014029:	608080        	neg	a8, a8
4201402c:	401800        	ssl	a8
4201402f:	a18900        	sll	a8, a9
42014032:	2088b0        	or	a8, a8, a11
42014035:	400a00        	ssr	a10
42014038:	919090        	srl	a9, a9
4201403b:	5289      	s32i.n	a8, a2, 20
4201403d:	0199      	s32i.n	a9, a1, 0
4201403f:	000046        	j	42014044 <__d2b+0x64>
42014042:	52b9      	s32i.n	a11, a2, 20
42014044:	0188      	l32i.n	a8, a1, 0
42014046:	150c      	movi.n	a5, 1
42014048:	290c      	movi.n	a9, 2
4201404a:	6289      	s32i.n	a8, a2, 24
4201404c:	935980        	movnez	a5, a9, a8
4201404f:	000346        	j	42014060 <__d2b+0x80>
42014052:	01ad      	mov.n	a10, a1
42014054:	ff9665        	call8	420139bc <__lo0bits>
42014057:	0188      	l32i.n	a8, a1, 0
42014059:	20caa2        	addi	a10, a10, 32
4201405c:	5289      	s32i.n	a8, a2, 20
4201405e:	150c      	movi.n	a5, 1
42014060:	4259      	s32i.n	a5, a2, 16
42014062:	239c      	beqz.n	a3, 42014078 <__d2b+0x98>
42014064:	cdab82        	movi	a8, 0xfffffbcd
42014067:	338a      	add.n	a3, a3, a8
42014069:	33aa      	add.n	a3, a3, a10
4201406b:	cbca52        	addi	a5, a10, -53
4201406e:	0639      	s32i.n	a3, a6, 0
42014070:	605050        	neg	a5, a5
42014073:	000706        	j	42014093 <__d2b+0xb3>
42014076:	820000        	mull	a0, a0, a0
42014079:	ceab      	addi.n	a12, a14, 10
4201407b:	8a8a      	add.n	a8, a10, a8
4201407d:	0689      	s32i.n	a8, a6, 0
4201407f:	c87c      	movi.n	a8, -4
42014081:	a08580        	addx4	a8, a5, a8
42014084:	808280        	add	a8, a2, a8
42014087:	0528a2        	l32i	a10, a8, 20
4201408a:	1155b0        	slli	a5, a5, 5
4201408d:	ff8de5        	call8	4201396c <__hi0bits>
42014090:	c055a0        	sub	a5, a5, a10
42014093:	0759      	s32i.n	a5, a7, 0
42014095:	f01d      	retw.n
	...

42014098 <__ratio>:
42014098:	006136        	entry	a1, 48
4201409b:	b14b      	addi.n	a11, a1, 4
4201409d:	02ad      	mov.n	a10, a2
4201409f:	ffeb65        	call8	42013f54 <__b2d>
420140a2:	0a4d      	mov.n	a4, a10
420140a4:	0b5d      	mov.n	a5, a11
420140a6:	0a6d      	mov.n	a6, a10
420140a8:	0b7d      	mov.n	a7, a11
420140aa:	03ad      	mov.n	a10, a3
420140ac:	01bd      	mov.n	a11, a1
420140ae:	ffea65        	call8	42013f54 <__b2d>
420140b1:	0acd      	mov.n	a12, a10
420140b3:	0b9d      	mov.n	a9, a11
420140b5:	42a8      	l32i.n	a10, a2, 16
420140b7:	0bdd      	mov.n	a13, a11
420140b9:	43b8      	l32i.n	a11, a3, 16
420140bb:	01e8      	l32i.n	a14, a1, 0
420140bd:	c0aab0        	sub	a10, a10, a11
420140c0:	11b8      	l32i.n	a11, a1, 4
420140c2:	11aab0        	slli	a10, a10, 5
420140c5:	c0bbe0        	sub	a11, a11, a14
420140c8:	aaba      	add.n	a10, a10, a11
420140ca:	071aa6        	blti	a10, 1, 420140d5 <__ratio+0x3d>
420140cd:	01aac0        	slli	a10, a10, 20
420140d0:	7a5a      	add.n	a7, a10, a5
420140d2:	000146        	j	420140db <__ratio+0x43>
420140d5:	01aac0        	slli	a10, a10, 20
420140d8:	c0d9a0        	sub	a13, a9, a10
420140db:	06ad      	mov.n	a10, a6
420140dd:	07bd      	mov.n	a11, a7
420140df:	b3a681        	l32r	a8, 42000f78 <_stext+0xf58> (40002250 <__divdf3>)
420140e2:	0008e0        	callx8	a8
420140e5:	0a2d      	mov.n	a2, a10
420140e7:	0b3d      	mov.n	a3, a11
420140e9:	f01d      	retw.n
	...

420140ec <_mprec_log10>:
420140ec:	004136        	entry	a1, 32
420140ef:	ffa3b2        	movi	a11, 0x3ff
420140f2:	781c      	movi.n	a8, 23
420140f4:	0a0c      	movi.n	a10, 0
420140f6:	01bbc0        	slli	a11, a11, 20
420140f9:	0c2827        	blt	a8, a2, 42014109 <_mprec_log10+0x1d>
420140fc:	b39181        	l32r	a8, 42000f40 <_stext+0xf20> (3c028aa0 <__mprec_tens>)
420140ff:	b07280        	addx8	a7, a2, a8
42014102:	07a8      	l32i.n	a10, a7, 0
42014104:	17b8      	l32i.n	a11, a7, 4
42014106:	000446        	j	4201411b <_mprec_log10+0x2f>
42014109:	b390d1        	l32r	a13, 42000f4c <_stext+0xf2c> (40240000 <rom_rx_gain_force+0x239bd4>)
4201410c:	00a0c2        	movi	a12, 0
4201410f:	ffc222        	addi	a2, a2, -1
42014112:	b37081        	l32r	a8, 42000ed4 <_stext+0xeb4> (40002418 <__muldf3>)
42014115:	0008e0        	callx8	a8
42014118:	fed256        	bnez	a2, 42014109 <_mprec_log10+0x1d>
4201411b:	0a2d      	mov.n	a2, a10
4201411d:	0b3d      	mov.n	a3, a11
4201411f:	f01d      	retw.n
42014121:	000000        	ill

42014124 <__copybits>:
42014124:	004136        	entry	a1, 32
42014127:	330b      	addi.n	a3, a3, -1
42014129:	4498      	l32i.n	a9, a4, 16
4201412b:	213530        	srai	a3, a3, 5
4201412e:	331b      	addi.n	a3, a3, 1
42014130:	14c482        	addi	a8, a4, 20
42014133:	a03320        	addx4	a3, a3, a2
42014136:	a09980        	addx4	a9, a9, a8
42014139:	02ad      	mov.n	a10, a2
4201413b:	0001c6        	j	42014146 <__copybits+0x22>
4201413e:	08b8      	l32i.n	a11, a8, 0
42014140:	884b      	addi.n	a8, a8, 4
42014142:	0ab9      	s32i.n	a11, a10, 0
42014144:	aa4b      	addi.n	a10, a10, 4
42014146:	f43897        	bltu	a8, a9, 4201413e <__copybits+0x1a>
42014149:	11c482        	addi	a8, a4, 17
4201414c:	628980        	saltu	a8, a9, a8
4201414f:	880b      	addi.n	a8, a8, -1
42014151:	608080        	neg	a8, a8
42014154:	748080        	extui	a8, a8, 0, 8
42014157:	0a0c      	movi.n	a10, 0
42014159:	c88c      	beqz.n	a8, 42014169 <__copybits+0x45>
4201415b:	11c442        	addi	a4, a4, 17
4201415e:	604040        	neg	a4, a4
42014161:	449a      	add.n	a4, a4, a9
42014163:	414240        	srli	a4, a4, 2
42014166:	11a4e0        	slli	a10, a4, 2
42014169:	22aa      	add.n	a2, a2, a10
4201416b:	080c      	movi.n	a8, 0
4201416d:	0000c6        	j	42014174 <__copybits+0x50>
42014170:	0289      	s32i.n	a8, a2, 0
42014172:	224b      	addi.n	a2, a2, 4
42014174:	f83237        	bltu	a2, a3, 42014170 <__copybits+0x4c>
42014177:	f01d      	retw.n
42014179:	000000        	ill

4201417c <__any_on>:
4201417c:	004136        	entry	a1, 32
4201417f:	42a8      	l32i.n	a10, a2, 16
42014181:	218530        	srai	a8, a3, 5
42014184:	14c292        	addi	a9, a2, 20
42014187:	232a87        	blt	a10, a8, 420141ae <__any_on+0x32>
4201418a:	22a8a7        	bge	a8, a10, 420141b0 <__any_on+0x34>
4201418d:	443030        	extui	a3, a3, 0, 5
42014190:	c39c      	beqz.n	a3, 420141b0 <__any_on+0x34>
42014192:	a0a890        	addx4	a10, a8, a9
42014195:	0ab8      	l32i.n	a11, a10, 0
42014197:	120c      	movi.n	a2, 1
42014199:	400300        	ssr	a3
4201419c:	91a0b0        	srl	a10, a11
4201419f:	401300        	ssl	a3
420141a2:	a1aa00        	sll	a10, a10
420141a5:	219ba7        	bne	a11, a10, 420141ca <__any_on+0x4e>
420141a8:	000106        	j	420141b0 <__any_on+0x34>
420141ab:	000000        	ill
420141ae:	0a8d      	mov.n	a8, a10
420141b0:	a08890        	addx4	a8, a8, a9
420141b3:	000206        	j	420141bf <__any_on+0x43>
420141b6:	820000        	mull	a0, a0, a0
420141b9:	fcc8      	l32i.n	a12, a12, 60
420141bb:	08a8      	l32i.n	a10, a8, 0
420141bd:	7acc      	bnez.n	a10, 420141c8 <__any_on+0x4c>
420141bf:	f53987        	bltu	a9, a8, 420141b8 <__any_on+0x3c>
420141c2:	020c      	movi.n	a2, 0
420141c4:	000086        	j	420141ca <__any_on+0x4e>
420141c7:	120c00        	andbc	b0, b12, b0
420141ca:	f01d      	retw.n

420141cc <get_arg$isra$0>:
420141cc:	008136        	entry	a1, 64
420141cf:	102182        	l32i	a8, a1, 64
420141d2:	1179      	s32i.n	a7, a1, 4
420141d4:	0878      	l32i.n	a7, a8, 0
420141d6:	2129      	s32i.n	a2, a1, 8
420141d8:	21e8      	l32i.n	a14, a1, 8
420141da:	0528      	l32i.n	a2, a5, 0
420141dc:	4159      	s32i.n	a5, a1, 16
420141de:	0169      	s32i.n	a6, a1, 0
420141e0:	837370        	moveqz	a7, a3, a7
420141e3:	00e306        	j	42014573 <get_arg$isra$0+0x3a7>
420141e6:	771b      	addi.n	a7, a7, 1
420141e8:	000782        	l8ui	a8, a7, 0
420141eb:	42f816        	beqz	a8, 4201461e <get_arg$isra$0+0x452>
420141ee:	dbc8a2        	addi	a10, a8, -37
420141f1:	ff1a56        	bnez	a10, 420141e6 <get_arg$isra$0+0x1a>
420141f4:	426816        	beqz	a8, 4201461e <get_arg$isra$0+0x452>
420141f7:	080c      	movi.n	a8, 0
420141f9:	a71b      	addi.n	a10, a7, 1
420141fb:	050c      	movi.n	a5, 0
420141fd:	0d0c      	movi.n	a13, 0
420141ff:	f37c      	movi.n	a3, -1
42014201:	060c      	movi.n	a6, 0
42014203:	3189      	s32i.n	a8, a1, 12
42014205:	000046        	j	4201420a <get_arg$isra$0+0x3e>
42014208:	07ad      	mov.n	a10, a7
4201420a:	b31b91        	l32r	a9, 42000e78 <_stext+0xe58> (3c028e7c <__chclass>)
4201420d:	000a82        	l8ui	a8, a10, 0
42014210:	7a1b      	addi.n	a7, a10, 1
42014212:	b98a      	add.n	a11, a9, a8
42014214:	3198      	l32i.n	a9, a1, 12
42014216:	000bc2        	l8ui	a12, a11, 0
42014219:	b318b1        	l32r	a11, 42000e7c <_stext+0xe5c> (3c028e10 <__state_table>)
4201421c:	b0f990        	addx8	a15, a9, a9
4201421f:	bbfa      	add.n	a11, a11, a15
42014221:	bbca      	add.n	a11, a11, a12
42014223:	000b92        	l8ui	a9, a11, 0
42014226:	b316b1        	l32r	a11, 42000e80 <_stext+0xe60> (3c028da4 <__action_table>)
42014229:	3199      	s32i.n	a9, a1, 12
4201422b:	bbfa      	add.n	a11, a11, a15
4201422d:	bbca      	add.n	a11, a11, a12
4201422f:	000bb2        	l8ui	a11, a11, 0
42014232:	bb0b      	addi.n	a11, a11, -1
42014234:	74b0b0        	extui	a11, a11, 0, 8
42014237:	028bb6        	bltui	a11, 8, 4201423d <get_arg$isra$0+0x71>
4201423a:	00cac6        	j	42014569 <get_arg$isra$0+0x39d>
4201423d:	b355c1        	l32r	a12, 42000f94 <_stext+0xf74> (3c028b68 <__mprec_tens+0xc8>)
42014240:	a0bbc0        	addx4	a11, a11, a12
42014243:	0bb8      	l32i.n	a11, a11, 0
42014245:	000ba0        	jx	a11
42014248:	00          	.byte	00
42014249:	9a0c00        	trunc.s	a0, f12, 0
4201424c:	00c206        	j	42014558 <get_arg$isra$0+0x38c>
4201424f:	07ad      	mov.n	a10, a7
42014251:	00ac46        	j	42014506 <get_arg$isra$0+0x33a>
42014254:	6aa0b2        	movi	a11, 106
42014257:	3318b7        	beq	a8, a11, 4201428e <get_arg$isra$0+0xc2>
4201425a:	0a3b87        	bltu	a11, a8, 42014268 <get_arg$isra$0+0x9c>
4201425d:	cb4c      	movi.n	a11, 76
4201425f:	2618b7        	beq	a8, a11, 42014289 <get_arg$isra$0+0xbd>
42014262:	68a0b2        	movi	a11, 104
42014265:	0005c6        	j	42014280 <get_arg$isra$0+0xb4>
42014268:	71a0b2        	movi	a11, 113
4201426b:	1f18b7        	beq	a8, a11, 4201428e <get_arg$isra$0+0xc2>
4201426e:	70a0b2        	movi	a11, 112
42014271:	23bb87        	bgeu	a11, a8, 42014298 <get_arg$isra$0+0xcc>
42014274:	74a0b2        	movi	a11, 116
42014277:	0298b7        	bne	a8, a11, 4201427d <get_arg$isra$0+0xb1>
4201427a:	00bac6        	j	42014569 <get_arg$isra$0+0x39d>
4201427d:	7aa0b2        	movi	a11, 122
42014280:	0298b7        	bne	a8, a11, 42014286 <get_arg$isra$0+0xba>
42014283:	00b886        	j	42014569 <get_arg$isra$0+0x39d>
42014286:	000386        	j	42014298 <get_arg$isra$0+0xcc>
42014289:	880c      	movi.n	a8, 8
4201428b:	000046        	j	42014290 <get_arg$isra$0+0xc4>
4201428e:	082c      	movi.n	a8, 32
42014290:	206680        	or	a6, a6, a8
42014293:	00b486        	j	42014569 <get_arg$isra$0+0x39d>
42014296:	b20000        	mulsh	a0, a0, a0
42014299:	010a      	add.n	a0, a1, a0
4201429b:	6ca082        	movi	a8, 108
4201429e:	0a9b87        	bne	a11, a8, 420142ac <get_arg$isra$0+0xe0>
420142a1:	082c      	movi.n	a8, 32
420142a3:	206680        	or	a6, a6, a8
420142a6:	7a2b      	addi.n	a7, a10, 2
420142a8:	00af46        	j	42014569 <get_arg$isra$0+0x39d>
420142ab:	081c00        	lsx	f1, a12, a0
420142ae:	fff786        	j	42014290 <get_arg$isra$0+0xc4>
420142b1:	61a0b2        	movi	a11, 97
420142b4:	44a020        	extui	a10, a2, 0, 5
420142b7:	0298b7        	bne	a8, a11, 420142bd <get_arg$isra$0+0xf1>
420142ba:	00e506        	j	42014652 <get_arg$isra$0+0x486>
420142bd:	3b3b87        	bltu	a11, a8, 420142fc <get_arg$isra$0+0x130>
420142c0:	bfc882        	addi	a8, a8, -65
420142c3:	748080        	extui	a8, a8, 0, 8
420142c6:	7b1c      	movi.n	a11, 23
420142c8:	24bb87        	bgeu	a11, a8, 420142f0 <get_arg$isra$0+0x124>
420142cb:	001686        	j	42014329 <get_arg$isra$0+0x15d>
420142ce:	180c      	movi.n	a8, 1
420142d0:	401b00        	ssl	a11
420142d3:	a18800        	sll	a8, a8
420142d6:	b2ecb1        	l32r	a11, 42000e88 <_stext+0xe68> (120821 <UserFrameTotalSize+0x120721>)
420142d9:	3388b7        	bany	a8, a11, 42014310 <get_arg$isra$0+0x144>
420142dc:	5b2c      	movi.n	a11, 37
420142de:	11bb60        	slli	a11, a11, 10
420142e1:	0208b7        	bnone	a8, a11, 420142e7 <get_arg$isra$0+0x11b>
420142e4:	00dd46        	j	4201465d <get_arg$isra$0+0x491>
420142e7:	248180        	extui	a8, a8, 1, 3
420142ea:	364856        	bnez	a8, 42014652 <get_arg$isra$0+0x486>
420142ed:	000e06        	j	42014329 <get_arg$isra$0+0x15d>
420142f0:	b32ab1        	l32r	a11, 42000f98 <_stext+0xf78> (3c028b88 <__mprec_tens+0xe8>)
420142f3:	a088b0        	addx4	a8, a8, a11
420142f6:	0888      	l32i.n	a8, a8, 0
420142f8:	0008a0        	jx	a8
420142fb:	a0b200        	addx4	a11, a2, a0
420142fe:	63          	.byte	0x63
420142ff:	1918b7        	beq	a8, a11, 4201431c <get_arg$isra$0+0x150>
42014302:	9cc882        	addi	a8, a8, -100
42014305:	74b080        	extui	a11, a8, 0, 8
42014308:	481c      	movi.n	a8, 20
4201430a:	c0b8b7        	bgeu	a8, a11, 420142ce <get_arg$isra$0+0x102>
4201430d:	000606        	j	42014329 <get_arg$isra$0+0x15d>
42014310:	045560        	extui	a5, a6, 5, 1
42014313:	555a      	add.n	a5, a5, a5
42014315:	106647        	bbci	a6, 4, 42014329 <get_arg$isra$0+0x15d>
42014318:	00d806        	j	4201467c <get_arg$isra$0+0x4b0>
4201431b:	051c00        	extui	a1, a0, 28, 1
4201431e:	105650        	and	a5, a6, a5
42014321:	34c556        	bnez	a5, 42014671 <get_arg$isra$0+0x4a5>
42014324:	00d006        	j	42014668 <get_arg$isra$0+0x49c>
42014327:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
4201432a:	880b03        	lsi	f0, a11, 0x220
4201432d:	0a2d11        	l32r	a1, 41fd6be4 <_iram_bss_end+0x1c547e4>
42014330:	a08380        	addx4	a8, a3, a8
42014333:	0859      	s32i.n	a5, a8, 0
42014335:	008c06        	j	42014569 <get_arg$isra$0+0x39d>
42014338:	b50b      	addi.n	a11, a5, -1
4201433a:	2488      	l32i.n	a8, a4, 8
4201433c:	2a1b      	addi.n	a2, a10, 1
4201433e:	026bb6        	bltui	a11, 6, 42014344 <get_arg$isra$0+0x178>
42014341:	002806        	j	420143e5 <get_arg$isra$0+0x219>
42014344:	b316c1        	l32r	a12, 42000f9c <_stext+0xf7c> (3c028be8 <__mprec_tens+0x148>)
42014347:	a0bbc0        	addx4	a11, a11, a12
4201434a:	0bc8      	l32i.n	a12, a11, 0
4201434c:	f4b0a0        	extui	a11, a10, 0, 16
4201434f:	000ca0        	jx	a12
42014352:	0188      	l32i.n	a8, a1, 0
42014354:	24b8      	l32i.n	a11, a4, 8
42014356:	2a1b      	addi.n	a2, a10, 1
42014358:	b0aa80        	addx8	a10, a10, a8
4201435b:	8b4b      	addi.n	a8, a11, 4
4201435d:	2489      	s32i.n	a8, a4, 8
4201435f:	8c1c      	movi.n	a12, 24
42014361:	042c87        	blt	a12, a8, 42014369 <get_arg$isra$0+0x19d>
42014364:	14b8      	l32i.n	a11, a4, 4
42014366:	000206        	j	42014372 <get_arg$isra$0+0x1a6>
42014369:	012cb7        	blt	a12, a11, 4201436e <get_arg$isra$0+0x1a2>
4201436c:	482c      	movi.n	a8, 36
4201436e:	04b8      	l32i.n	a11, a4, 0
42014370:	2489      	s32i.n	a8, a4, 8
42014372:	bb8a      	add.n	a11, a11, a8
42014374:	fccbb2        	addi	a11, a11, -4
42014377:	0b88      	l32i.n	a8, a11, 0
42014379:	f37c      	movi.n	a3, -1
4201437b:	0a89      	s32i.n	a8, a10, 0
4201437d:	150c      	movi.n	a5, 1
4201437f:	007986        	j	42014569 <get_arg$isra$0+0x39d>
42014382:	8a7c      	movi.n	a10, -8
42014384:	887b      	addi.n	a8, a8, 7
42014386:	1088a0        	and	a8, a8, a10
42014389:	0198      	l32i.n	a9, a1, 0
4201438b:	a88b      	addi.n	a10, a8, 8
4201438d:	24a9      	s32i.n	a10, a4, 8
4201438f:	8c1c      	movi.n	a12, 24
42014391:	b0bb90        	addx8	a11, a11, a9
42014394:	042ca7        	blt	a12, a10, 4201439c <get_arg$isra$0+0x1d0>
42014397:	1488      	l32i.n	a8, a4, 4
42014399:	000206        	j	420143a5 <get_arg$isra$0+0x1d9>
4201439c:	012c87        	blt	a12, a8, 420143a1 <get_arg$isra$0+0x1d5>
4201439f:	8a2c      	movi.n	a10, 40
420143a1:	0488      	l32i.n	a8, a4, 0
420143a3:	24a9      	s32i.n	a10, a4, 8
420143a5:	88aa      	add.n	a8, a8, a10
420143a7:	f8c882        	addi	a8, a8, -8
420143aa:	1898      	l32i.n	a9, a8, 4
420143ac:	0888      	l32i.n	a8, a8, 0
420143ae:	1b99      	s32i.n	a9, a11, 4
420143b0:	0b89      	s32i.n	a8, a11, 0
420143b2:	006cc6        	j	42014569 <get_arg$isra$0+0x39d>
420143b5:	0188      	l32i.n	a8, a1, 0
420143b7:	24b8      	l32i.n	a11, a4, 8
420143b9:	2a1b      	addi.n	a2, a10, 1
420143bb:	b0aa80        	addx8	a10, a10, a8
420143be:	8b4b      	addi.n	a8, a11, 4
420143c0:	2489      	s32i.n	a8, a4, 8
420143c2:	8c1c      	movi.n	a12, 24
420143c4:	042c87        	blt	a12, a8, 420143cc <get_arg$isra$0+0x200>
420143c7:	14b8      	l32i.n	a11, a4, 4
420143c9:	000206        	j	420143d5 <get_arg$isra$0+0x209>
420143cc:	012cb7        	blt	a12, a11, 420143d1 <get_arg$isra$0+0x205>
420143cf:	482c      	movi.n	a8, 36
420143d1:	04b8      	l32i.n	a11, a4, 0
420143d3:	2489      	s32i.n	a8, a4, 8
420143d5:	bb8a      	add.n	a11, a11, a8
420143d7:	fccbb2        	addi	a11, a11, -4
420143da:	0b88      	l32i.n	a8, a11, 0
420143dc:	f37c      	movi.n	a3, -1
420143de:	0a89      	s32i.n	a8, a10, 0
420143e0:	650c      	movi.n	a5, 6
420143e2:	0060c6        	j	42014569 <get_arg$isra$0+0x39d>
420143e5:	0188      	l32i.n	a8, a1, 0
420143e7:	24b8      	l32i.n	a11, a4, 8
420143e9:	2a1b      	addi.n	a2, a10, 1
420143eb:	b0aa80        	addx8	a10, a10, a8
420143ee:	8b4b      	addi.n	a8, a11, 4
420143f0:	2489      	s32i.n	a8, a4, 8
420143f2:	8c1c      	movi.n	a12, 24
420143f4:	042c87        	blt	a12, a8, 420143fc <get_arg$isra$0+0x230>
420143f7:	14b8      	l32i.n	a11, a4, 4
420143f9:	000206        	j	42014405 <get_arg$isra$0+0x239>
420143fc:	012cb7        	blt	a12, a11, 42014401 <get_arg$isra$0+0x235>
420143ff:	482c      	movi.n	a8, 36
42014401:	04b8      	l32i.n	a11, a4, 0
42014403:	2489      	s32i.n	a8, a4, 8
42014405:	bb8a      	add.n	a11, a11, a8
42014407:	fccbb2        	addi	a11, a11, -4
4201440a:	0b88      	l32i.n	a8, a11, 0
4201440c:	f37c      	movi.n	a3, -1
4201440e:	0a89      	s32i.n	a8, a10, 0
42014410:	050c      	movi.n	a5, 0
42014412:	0054c6        	j	42014569 <get_arg$isra$0+0x39d>
42014415:	0188      	l32i.n	a8, a1, 0
42014417:	24b8      	l32i.n	a11, a4, 8
42014419:	2a1b      	addi.n	a2, a10, 1
4201441b:	b0aa80        	addx8	a10, a10, a8
4201441e:	8b4b      	addi.n	a8, a11, 4
42014420:	2489      	s32i.n	a8, a4, 8
42014422:	8c1c      	movi.n	a12, 24
42014424:	042c87        	blt	a12, a8, 4201442c <get_arg$isra$0+0x260>
42014427:	14b8      	l32i.n	a11, a4, 4
42014429:	000206        	j	42014435 <get_arg$isra$0+0x269>
4201442c:	012cb7        	blt	a12, a11, 42014431 <get_arg$isra$0+0x265>
4201442f:	482c      	movi.n	a8, 36
42014431:	04b8      	l32i.n	a11, a4, 0
42014433:	2489      	s32i.n	a8, a4, 8
42014435:	bb8a      	add.n	a11, a11, a8
42014437:	fccbb2        	addi	a11, a11, -4
4201443a:	0b88      	l32i.n	a8, a11, 0
4201443c:	f37c      	movi.n	a3, -1
4201443e:	0a89      	s32i.n	a8, a10, 0
42014440:	350c      	movi.n	a5, 3
42014442:	0048c6        	j	42014569 <get_arg$isra$0+0x39d>
42014445:	0188      	l32i.n	a8, a1, 0
42014447:	2a1b      	addi.n	a2, a10, 1
42014449:	b0aa80        	addx8	a10, a10, a8
4201444c:	2488      	l32i.n	a8, a4, 8
4201444e:	8b7c      	movi.n	a11, -8
42014450:	887b      	addi.n	a8, a8, 7
42014452:	1088b0        	and	a8, a8, a11
42014455:	b88b      	addi.n	a11, a8, 8
42014457:	24b9      	s32i.n	a11, a4, 8
42014459:	8c1c      	movi.n	a12, 24
4201445b:	052cb7        	blt	a12, a11, 42014464 <get_arg$isra$0+0x298>
4201445e:	1488      	l32i.n	a8, a4, 4
42014460:	000246        	j	4201446d <get_arg$isra$0+0x2a1>
42014463:	00          	.byte	00
42014464:	012c87        	blt	a12, a8, 42014469 <get_arg$isra$0+0x29d>
42014467:	8b2c      	movi.n	a11, 40
42014469:	0488      	l32i.n	a8, a4, 0
4201446b:	24b9      	s32i.n	a11, a4, 8
4201446d:	88ba      	add.n	a8, a8, a11
4201446f:	f8c882        	addi	a8, a8, -8
42014472:	1898      	l32i.n	a9, a8, 4
42014474:	0888      	l32i.n	a8, a8, 0
42014476:	f37c      	movi.n	a3, -1
42014478:	0a89      	s32i.n	a8, a10, 0
4201447a:	1a99      	s32i.n	a9, a10, 4
4201447c:	450c      	movi.n	a5, 4
4201447e:	0039c6        	j	42014569 <get_arg$isra$0+0x39d>
42014481:	8a7c      	movi.n	a10, -8
42014483:	887b      	addi.n	a8, a8, 7
42014485:	1088a0        	and	a8, a8, a10
42014488:	0198      	l32i.n	a9, a1, 0
4201448a:	a88b      	addi.n	a10, a8, 8
4201448c:	24a9      	s32i.n	a10, a4, 8
4201448e:	8c1c      	movi.n	a12, 24
42014490:	b0bb90        	addx8	a11, a11, a9
42014493:	052ca7        	blt	a12, a10, 4201449c <get_arg$isra$0+0x2d0>
42014496:	1488      	l32i.n	a8, a4, 4
42014498:	000246        	j	420144a5 <get_arg$isra$0+0x2d9>
4201449b:	00          	.byte	00
4201449c:	012c87        	blt	a12, a8, 420144a1 <get_arg$isra$0+0x2d5>
4201449f:	8a2c      	movi.n	a10, 40
420144a1:	0488      	l32i.n	a8, a4, 0
420144a3:	24a9      	s32i.n	a10, a4, 8
420144a5:	88aa      	add.n	a8, a8, a10
420144a7:	f8c882        	addi	a8, a8, -8
420144aa:	1898      	l32i.n	a9, a8, 4
420144ac:	0888      	l32i.n	a8, a8, 0
420144ae:	1b99      	s32i.n	a9, a11, 4
420144b0:	0b89      	s32i.n	a8, a11, 0
420144b2:	002cc6        	j	42014569 <get_arg$isra$0+0x39d>
420144b5:	1188      	l32i.n	a8, a1, 4
420144b7:	0888      	l32i.n	a8, a8, 0
420144b9:	140866        	bnei	a8, -1, 420144d1 <get_arg$isra$0+0x305>
420144bc:	11a8      	l32i.n	a10, a1, 4
420144be:	80a0c2        	movi	a12, 128
420144c1:	0b0c      	movi.n	a11, 0
420144c3:	61d9      	s32i.n	a13, a1, 24
420144c5:	51e9      	s32i.n	a14, a1, 20
420144c7:	af8f81        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420144ca:	0008e0        	callx8	a8
420144cd:	61d8      	l32i.n	a13, a1, 24
420144cf:	51e8      	l32i.n	a14, a1, 20
420144d1:	3d0b      	addi.n	a3, a13, -1
420144d3:	53ee30        	max	a14, a14, a3
420144d6:	0023c6        	j	42014569 <get_arg$isra$0+0x39d>
420144d9:	1188      	l32i.n	a8, a1, 4
420144db:	0888      	l32i.n	a8, a8, 0
420144dd:	140866        	bnei	a8, -1, 420144f5 <get_arg$isra$0+0x329>
420144e0:	11a8      	l32i.n	a10, a1, 4
420144e2:	80a0c2        	movi	a12, 128
420144e5:	0b0c      	movi.n	a11, 0
420144e7:	61d9      	s32i.n	a13, a1, 24
420144e9:	51e9      	s32i.n	a14, a1, 20
420144eb:	af8681        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420144ee:	0008e0        	callx8	a8
420144f1:	61d8      	l32i.n	a13, a1, 24
420144f3:	51e8      	l32i.n	a14, a1, 20
420144f5:	1188      	l32i.n	a8, a1, 4
420144f7:	dd0b      	addi.n	a13, a13, -1
420144f9:	a08d80        	addx4	a8, a13, a8
420144fc:	0a0c      	movi.n	a10, 0
420144fe:	08a9      	s32i.n	a10, a8, 0
42014500:	53eed0        	max	a14, a14, a13
42014503:	001886        	j	42014569 <get_arg$isra$0+0x39d>
42014506:	0188      	l32i.n	a8, a1, 0
42014508:	24b8      	l32i.n	a11, a4, 8
4201450a:	f21b      	addi.n	a15, a2, 1
4201450c:	b02280        	addx8	a2, a2, a8
4201450f:	8b4b      	addi.n	a8, a11, 4
42014511:	2489      	s32i.n	a8, a4, 8
42014513:	8c1c      	movi.n	a12, 24
42014515:	042c87        	blt	a12, a8, 4201451d <get_arg$isra$0+0x351>
42014518:	14b8      	l32i.n	a11, a4, 4
4201451a:	000206        	j	42014526 <get_arg$isra$0+0x35a>
4201451d:	012cb7        	blt	a12, a11, 42014522 <get_arg$isra$0+0x356>
42014520:	482c      	movi.n	a8, 36
42014522:	04b8      	l32i.n	a11, a4, 0
42014524:	2489      	s32i.n	a8, a4, 8
42014526:	bb8a      	add.n	a11, a11, a8
42014528:	fccbb2        	addi	a11, a11, -4
4201452b:	0b88      	l32i.n	a8, a11, 0
4201452d:	0a7d      	mov.n	a7, a10
4201452f:	0289      	s32i.n	a8, a2, 0
42014531:	0f2d      	mov.n	a2, a15
42014533:	000c86        	j	42014569 <get_arg$isra$0+0x39d>
42014536:	d20000        	quos	a0, a0, a0
42014539:	d0c8      	l32i.n	a12, a0, 52
4201453b:	9a0c      	movi.n	a10, 9
4201453d:	0001c6        	j	42014548 <get_arg$isra$0+0x37c>
42014540:	a0ddd0        	addx4	a13, a13, a13
42014543:	90dd80        	addx2	a13, a13, a8
42014546:	771b      	addi.n	a7, a7, 1
42014548:	000782        	l8ui	a8, a7, 0
4201454b:	a89c      	beqz.n	a8, 42014569 <get_arg$isra$0+0x39d>
4201454d:	d0c882        	addi	a8, a8, -48
42014550:	ecba87        	bgeu	a10, a8, 42014540 <get_arg$isra$0+0x374>
42014553:	000486        	j	42014569 <get_arg$isra$0+0x39d>
42014556:	820000        	mull	a0, a0, a0
42014559:	820007        	bnone	a0, a0, 420144df <get_arg$isra$0+0x313>
4201455c:	d0c8      	l32i.n	a12, a0, 52
4201455e:	748080        	extui	a8, a8, 0, 8
42014561:	043a87        	bltu	a10, a8, 42014569 <get_arg$isra$0+0x39d>
42014564:	771b      	addi.n	a7, a7, 1
42014566:	fffb86        	j	42014558 <get_arg$isra$0+0x38c>
42014569:	3198      	l32i.n	a9, a1, 12
4201456b:	b80c      	movi.n	a8, 11
4201456d:	021987        	beq	a9, a8, 42014573 <get_arg$isra$0+0x3a7>
42014570:	ff2506        	j	42014208 <get_arg$isra$0+0x3c>
42014573:	0007a2        	l8ui	a10, a7, 0
42014576:	ea8c      	beqz.n	a10, 42014588 <get_arg$isra$0+0x3bc>
42014578:	2188      	l32i.n	a8, a1, 8
4201457a:	728820        	salt	a8, a8, a2
4201457d:	880b      	addi.n	a8, a8, -1
4201457f:	608080        	neg	a8, a8
42014582:	748080        	extui	a8, a8, 0, 8
42014585:	c5f856        	bnez	a8, 420141e8 <get_arg$isra$0+0x1c>
42014588:	2188      	l32i.n	a8, a1, 8
4201458a:	93e8a0        	movnez	a14, a8, a10
4201458d:	002346        	j	4201461e <get_arg$isra$0+0x452>
42014590:	1188      	l32i.n	a8, a1, 4
42014592:	a08d80        	addx4	a8, a13, a8
42014595:	08c8      	l32i.n	a12, a8, 0
42014597:	dd1b      	addi.n	a13, a13, 1
42014599:	cc0b      	addi.n	a12, a12, -1
4201459b:	2488      	l32i.n	a8, a4, 8
4201459d:	5c6cf6        	bgeui	a12, 6, 420145fd <get_arg$isra$0+0x431>
420145a0:	a0cc60        	addx4	a12, a12, a6
420145a3:	0cc8      	l32i.n	a12, a12, 0
420145a5:	000ca0        	jx	a12
420145a8:	887b      	addi.n	a8, a8, 7
420145aa:	1088f0        	and	a8, a8, a15
420145ad:	c88b      	addi.n	a12, a8, 8
420145af:	24c9      	s32i.n	a12, a4, 8
420145b1:	042ac7        	blt	a10, a12, 420145b9 <get_arg$isra$0+0x3ed>
420145b4:	1488      	l32i.n	a8, a4, 4
420145b6:	000206        	j	420145c2 <get_arg$isra$0+0x3f6>
420145b9:	012a87        	blt	a10, a8, 420145be <get_arg$isra$0+0x3f2>
420145bc:	8c2c      	movi.n	a12, 40
420145be:	0488      	l32i.n	a8, a4, 0
420145c0:	24c9      	s32i.n	a12, a4, 8
420145c2:	88ca      	add.n	a8, a8, a12
420145c4:	f8c882        	addi	a8, a8, -8
420145c7:	1898      	l32i.n	a9, a8, 4
420145c9:	0888      	l32i.n	a8, a8, 0
420145cb:	1b99      	s32i.n	a9, a11, 4
420145cd:	0b89      	s32i.n	a8, a11, 0
420145cf:	001706        	j	4201462f <get_arg$isra$0+0x463>
420145d2:	887b      	addi.n	a8, a8, 7
420145d4:	1088f0        	and	a8, a8, a15
420145d7:	c88b      	addi.n	a12, a8, 8
420145d9:	24c9      	s32i.n	a12, a4, 8
420145db:	052ac7        	blt	a10, a12, 420145e4 <get_arg$isra$0+0x418>
420145de:	1488      	l32i.n	a8, a4, 4
420145e0:	000246        	j	420145ed <get_arg$isra$0+0x421>
420145e3:	2a8700        	mul.s	f8, f7, f0
420145e6:	8c2c01        	l32r	a0, 41ff7698 <_iram_bss_end+0x1c75298>
420145e9:	0488      	l32i.n	a8, a4, 0
420145eb:	24c9      	s32i.n	a12, a4, 8
420145ed:	88ca      	add.n	a8, a8, a12
420145ef:	f8c882        	addi	a8, a8, -8
420145f2:	1898      	l32i.n	a9, a8, 4
420145f4:	0888      	l32i.n	a8, a8, 0
420145f6:	1b99      	s32i.n	a9, a11, 4
420145f8:	0b89      	s32i.n	a8, a11, 0
420145fa:	000c46        	j	4201462f <get_arg$isra$0+0x463>
420145fd:	c84b      	addi.n	a12, a8, 4
420145ff:	24c9      	s32i.n	a12, a4, 8
42014601:	042ac7        	blt	a10, a12, 42014609 <get_arg$isra$0+0x43d>
42014604:	1488      	l32i.n	a8, a4, 4
42014606:	000206        	j	42014612 <get_arg$isra$0+0x446>
42014609:	012a87        	blt	a10, a8, 4201460e <get_arg$isra$0+0x442>
4201460c:	4c2c      	movi.n	a12, 36
4201460e:	0488      	l32i.n	a8, a4, 0
42014610:	24c9      	s32i.n	a12, a4, 8
42014612:	88ca      	add.n	a8, a8, a12
42014614:	fcc882        	addi	a8, a8, -4
42014617:	0888      	l32i.n	a8, a8, 0
42014619:	0b89      	s32i.n	a8, a11, 0
4201461b:	000406        	j	4201462f <get_arg$isra$0+0x463>
4201461e:	0188      	l32i.n	a8, a1, 0
42014620:	b26061        	l32r	a6, 42000fa0 <_stext+0xf80> (3c028c00 <__mprec_tens+0x160>)
42014623:	b0b280        	addx8	a11, a2, a8
42014626:	02dd      	mov.n	a13, a2
42014628:	8a1c      	movi.n	a10, 24
4201462a:	8f7c      	movi.n	a15, -8
4201462c:	000046        	j	42014631 <get_arg$isra$0+0x465>
4201462f:	bb8b      	addi.n	a11, a11, 8
42014631:	022ed7        	blt	a14, a13, 42014637 <get_arg$isra$0+0x46b>
42014634:	ffd606        	j	42014590 <get_arg$isra$0+0x3c4>
42014637:	8e1b      	addi.n	a8, a14, 1
42014639:	728820        	salt	a8, a8, a2
4201463c:	880b      	addi.n	a8, a8, -1
4201463e:	608080        	neg	a8, a8
42014641:	748080        	extui	a8, a8, 0, 8
42014644:	0a0c      	movi.n	a10, 0
42014646:	d8bc      	beqz.n	a8, 42014687 <get_arg$isra$0+0x4bb>
42014648:	820b      	addi.n	a8, a2, -1
4201464a:	608080        	neg	a8, a8
4201464d:	a8ea      	add.n	a10, a8, a14
4201464f:	000d06        	j	42014687 <get_arg$isra$0+0x4bb>
42014652:	450c      	movi.n	a5, 4
42014654:	020326        	beqi	a3, -1, 4201465a <get_arg$isra$0+0x48e>
42014657:	ff3446        	j	4201432c <get_arg$isra$0+0x160>
4201465a:	ff79c6        	j	42014445 <get_arg$isra$0+0x279>
4201465d:	350c      	movi.n	a5, 3
4201465f:	020326        	beqi	a3, -1, 42014665 <get_arg$isra$0+0x499>
42014662:	ff3186        	j	4201432c <get_arg$isra$0+0x160>
42014665:	ff6b06        	j	42014415 <get_arg$isra$0+0x249>
42014668:	020326        	beqi	a3, -1, 4201466e <get_arg$isra$0+0x4a2>
4201466b:	ff2f46        	j	4201432c <get_arg$isra$0+0x160>
4201466e:	ff5cc6        	j	420143e5 <get_arg$isra$0+0x219>
42014671:	650c      	movi.n	a5, 6
42014673:	020326        	beqi	a3, -1, 42014679 <get_arg$isra$0+0x4ad>
42014676:	ff2c86        	j	4201432c <get_arg$isra$0+0x160>
42014679:	ff4e06        	j	420143b5 <get_arg$isra$0+0x1e9>
4201467c:	150c      	movi.n	a5, 1
4201467e:	020326        	beqi	a3, -1, 42014684 <get_arg$isra$0+0x4b8>
42014681:	ff29c6        	j	4201432c <get_arg$isra$0+0x160>
42014684:	ff3286        	j	42014352 <get_arg$isra$0+0x186>
42014687:	4198      	l32i.n	a9, a1, 16
42014689:	8a2a      	add.n	a8, a10, a2
4201468b:	0989      	s32i.n	a8, a9, 0
4201468d:	102182        	l32i	a8, a1, 64
42014690:	0198      	l32i.n	a9, a1, 0
42014692:	0879      	s32i.n	a7, a8, 0
42014694:	2188      	l32i.n	a8, a1, 8
42014696:	b02890        	addx8	a2, a8, a9
42014699:	f01d      	retw.n
	...

4201469c <__ssprint_r>:
4201469c:	006136        	entry	a1, 48
4201469f:	2498      	l32i.n	a9, a4, 8
420146a1:	0129      	s32i.n	a2, a1, 0
420146a3:	035d      	mov.n	a5, a3
420146a5:	398c      	beqz.n	a9, 420146ac <__ssprint_r+0x10>
420146a7:	0468      	l32i.n	a6, a4, 0
420146a9:	000106        	j	420146b1 <__ssprint_r+0x15>
420146ac:	020c      	movi.n	a2, 0
420146ae:	003b46        	j	4201479f <__ssprint_r+0x103>
420146b1:	0688      	l32i.n	a8, a6, 0
420146b3:	1638      	l32i.n	a3, a6, 4
420146b5:	1189      	s32i.n	a8, a1, 4
420146b7:	668b      	addi.n	a6, a6, 8
420146b9:	ff4316        	beqz	a3, 420146b1 <__ssprint_r+0x15>
420146bc:	25d8      	l32i.n	a13, a5, 8
420146be:	0d7d      	mov.n	a7, a13
420146c0:	02b3d7        	bgeu	a3, a13, 420146c6 <__ssprint_r+0x2a>
420146c3:	0024c6        	j	4201475a <__ssprint_r+0xbe>
420146c6:	0695f2        	l16si	a15, a5, 12
420146c9:	80a482        	movi	a8, 0x480
420146cc:	109f80        	and	a9, a15, a8
420146cf:	239980        	sext	a9, a9, 15
420146d2:	088916        	beqz	a9, 4201475e <__ssprint_r+0xc2>
420146d5:	55a8      	l32i.n	a10, a5, 20
420146d7:	45b8      	l32i.n	a11, a5, 16
420146d9:	0578      	l32i.n	a7, a5, 0
420146db:	90aaa0        	addx2	a10, a10, a10
420146de:	059fa0        	extui	a9, a10, 31, 1
420146e1:	c077b0        	sub	a7, a7, a11
420146e4:	99aa      	add.n	a9, a9, a10
420146e6:	a71b      	addi.n	a10, a7, 1
420146e8:	212190        	srai	a2, a9, 1
420146eb:	aa3a      	add.n	a10, a10, a3
420146ed:	20c220        	or	a12, a2, a2
420146f0:	04b2a7        	bgeu	a2, a10, 420146f8 <__ssprint_r+0x5c>
420146f3:	0a2d      	mov.n	a2, a10
420146f5:	20caa0        	or	a12, a10, a10
420146f8:	326fa7        	bbci	a15, 10, 4201472e <__ssprint_r+0x92>
420146fb:	01a8      	l32i.n	a10, a1, 0
420146fd:	0cbd      	mov.n	a11, a12
420146ff:	b1d581        	l32r	a8, 42000e54 <_stext+0xe34> (4037fee8 <_malloc_r>)
42014702:	0008e0        	callx8	a8
42014705:	07fa16        	beqz	a10, 42014788 <__ssprint_r+0xec>
42014708:	45b8      	l32i.n	a11, a5, 16
4201470a:	07cd      	mov.n	a12, a7
4201470c:	21a9      	s32i.n	a10, a1, 8
4201470e:	ae4681        	l32r	a8, 42000028 <_stext+0x8> (400011f4 <memcpy>)
42014711:	0008e0        	callx8	a8
42014714:	0615a2        	l16ui	a10, a5, 12
42014717:	7fabb2        	movi	a11, 0xfffffb7f
4201471a:	10aab0        	and	a10, a10, a11
4201471d:	80a0b2        	movi	a11, 128
42014720:	20aab0        	or	a10, a10, a11
42014723:	21d8      	l32i.n	a13, a1, 8
42014725:	0655a2        	s16i	a10, a5, 12
42014728:	000706        	j	42014748 <__ssprint_r+0xac>
4201472b:	000000        	ill
4201472e:	01a8      	l32i.n	a10, a1, 0
42014730:	b1ce81        	l32r	a8, 42000e68 <_stext+0xe48> (4037fed4 <_realloc_r>)
42014733:	0008e0        	callx8	a8
42014736:	0add      	mov.n	a13, a10
42014738:	cacc      	bnez.n	a10, 42014748 <__ssprint_r+0xac>
4201473a:	45b8      	l32i.n	a11, a5, 16
4201473c:	01a8      	l32i.n	a10, a1, 0
4201473e:	b1b481        	l32r	a8, 42000e10 <_stext+0xdf0> (4037fec8 <_free_r>)
42014741:	0008e0        	callx8	a8
42014744:	001006        	j	42014788 <__ssprint_r+0xec>
42014747:	45d900        	extui	a13, a0, 25, 5
4201474a:	c09270        	sub	a9, a2, a7
4201474d:	dd7a      	add.n	a13, a13, a7
4201474f:	05d9      	s32i.n	a13, a5, 0
42014751:	5529      	s32i.n	a2, a5, 20
42014753:	03dd      	mov.n	a13, a3
42014755:	2599      	s32i.n	a9, a5, 8
42014757:	000046        	j	4201475c <__ssprint_r+0xc0>
4201475a:	03dd      	mov.n	a13, a3
4201475c:	037d      	mov.n	a7, a3
4201475e:	11b8      	l32i.n	a11, a1, 4
42014760:	05a8      	l32i.n	a10, a5, 0
42014762:	07cd      	mov.n	a12, a7
42014764:	21d9      	s32i.n	a13, a1, 8
42014766:	b1c181        	l32r	a8, 42000e6c <_stext+0xe4c> (40001200 <memmove>)
42014769:	0008e0        	callx8	a8
4201476c:	2598      	l32i.n	a9, a5, 8
4201476e:	21d8      	l32i.n	a13, a1, 8
42014770:	c099d0        	sub	a9, a9, a13
42014773:	2599      	s32i.n	a9, a5, 8
42014775:	0598      	l32i.n	a9, a5, 0
42014777:	997a      	add.n	a9, a9, a7
42014779:	0599      	s32i.n	a9, a5, 0
4201477b:	2498      	l32i.n	a9, a4, 8
4201477d:	c09930        	sub	a9, a9, a3
42014780:	2499      	s32i.n	a9, a4, 8
42014782:	f2b956        	bnez	a9, 420146b1 <__ssprint_r+0x15>
42014785:	ffc8c6        	j	420146ac <__ssprint_r+0x10>
42014788:	0188      	l32i.n	a8, a1, 0
4201478a:	c90c      	movi.n	a9, 12
4201478c:	0899      	s32i.n	a9, a8, 0
4201478e:	061592        	l16ui	a9, a5, 12
42014791:	0a4c      	movi.n	a10, 64
42014793:	2099a0        	or	a9, a9, a10
42014796:	065592        	s16i	a9, a5, 12
42014799:	080c      	movi.n	a8, 0
4201479b:	2489      	s32i.n	a8, a4, 8
4201479d:	f27c      	movi.n	a2, -1
4201479f:	080c      	movi.n	a8, 0
420147a1:	1489      	s32i.n	a8, a4, 4
420147a3:	f01d      	retw.n
420147a5:	000000        	ill

420147a8 <_svfiprintf_r>:
420147a8:	058136        	entry	a1, 0x2c0
420147ab:	9a6142        	s32i	a4, a1, 0x268
420147ae:	061382        	l16ui	a8, a3, 12
420147b1:	9d6122        	s32i	a2, a1, 0x274
420147b4:	9c6132        	s32i	a3, a1, 0x270
420147b7:	946152        	s32i	a5, a1, 0x250
420147ba:	956162        	s32i	a6, a1, 0x254
420147bd:	966172        	s32i	a7, a1, 0x258
420147c0:	10c142        	addi	a4, a1, 16
420147c3:	296877        	bbci	a8, 7, 420147f0 <_svfiprintf_r+0x48>
420147c6:	4388      	l32i.n	a8, a3, 16
420147c8:	48ec      	bnez.n	a8, 420147f0 <_svfiprintf_r+0x48>
420147ca:	0b4c      	movi.n	a11, 64
420147cc:	02ad      	mov.n	a10, a2
420147ce:	b1a181        	l32r	a8, 42000e54 <_stext+0xe34> (4037fee8 <_malloc_r>)
420147d1:	0008e0        	callx8	a8
420147d4:	9c2182        	l32i	a8, a1, 0x270
420147d7:	08a9      	s32i.n	a10, a8, 0
420147d9:	48a9      	s32i.n	a10, a8, 16
420147db:	aacc      	bnez.n	a10, 420147e9 <_svfiprintf_r+0x41>
420147dd:	9d2192        	l32i	a9, a1, 0x274
420147e0:	c80c      	movi.n	a8, 12
420147e2:	0989      	s32i.n	a8, a9, 0
420147e4:	071346        	j	42016435 <_svfiprintf_r+0x1c8d>
420147e7:	00          	.byte	00
420147e8:	219200        	srai	a9, a0, 2
420147eb:	4c9c      	beqz.n	a12, 42014803 <_svfiprintf_r+0x5b>
420147ed:	8908      	l32i.n	a0, a9, 32
420147ef:	8259      	s32i.n	a5, a2, 32
420147f1:	8ae4a1        	l32r	a10, 41ff7384 <_iram_bss_end+0x1c74f84>
420147f4:	84          	.byte	0x84
420147f5:	090c      	movi.n	a9, 0
420147f7:	896482        	s32i	a8, a4, 0x224
420147fa:	986182        	s32i	a8, a1, 0x260
420147fd:	080c      	movi.n	a8, 0
420147ff:	906192        	s32i	a9, a1, 0x240
42014802:	916192        	s32i	a9, a1, 0x244
42014805:	976192        	s32i	a9, a1, 0x25c
42014808:	996192        	s32i	a9, a1, 0x264
4201480b:	a26182        	s32i	a8, a1, 0x288
4201480e:	a06182        	s32i	a8, a1, 0x280
42014811:	a16182        	s32i	a8, a1, 0x284
42014814:	a36182        	s32i	a8, a1, 0x28c
42014817:	9f6182        	s32i	a8, a1, 0x27c
4201481a:	10c192        	addi	a9, a1, 16
4201481d:	e4a182        	movi	a8, 0x1e4
42014820:	fa7c      	movi.n	a10, -1
42014822:	898a      	add.n	a8, a9, a8
42014824:	4064a2        	s32i	a10, a4, 0x100
42014827:	060c      	movi.n	a6, 0
42014829:	a56182        	s32i	a8, a1, 0x294
4201482c:	9a2172        	l32i	a7, a1, 0x268
4201482f:	000046        	j	42014834 <_svfiprintf_r+0x8c>
42014832:	771b      	addi.n	a7, a7, 1
42014834:	000782        	l8ui	a8, a7, 0
42014837:	005816        	beqz	a8, 42014840 <_svfiprintf_r+0x98>
4201483a:	dbc882        	addi	a8, a8, -37
4201483d:	ff1856        	bnez	a8, 42014832 <_svfiprintf_r+0x8a>
42014840:	9a2182        	l32i	a8, a1, 0x268
42014843:	c05780        	sub	a5, a7, a8
42014846:	066516        	beqz	a5, 420148b0 <_svfiprintf_r+0x108>
42014849:	982182        	l32i	a8, a1, 0x260
4201484c:	9a2192        	l32i	a9, a1, 0x268
4201484f:	1859      	s32i.n	a5, a8, 4
42014851:	0899      	s32i.n	a9, a8, 0
42014853:	972182        	l32i	a8, a1, 0x25c
42014856:	885a      	add.n	a8, a8, a5
42014858:	976182        	s32i	a8, a1, 0x25c
4201485b:	992182        	l32i	a8, a1, 0x264
4201485e:	881b      	addi.n	a8, a8, 1
42014860:	996182        	s32i	a8, a1, 0x264
42014863:	0788e6        	bgei	a8, 8, 4201486e <_svfiprintf_r+0xc6>
42014866:	982182        	l32i	a8, a1, 0x260
42014869:	888b      	addi.n	a8, a8, 8
4201486b:	000d86        	j	420148a5 <_svfiprintf_r+0xfd>
4201486e:	992182        	l32i	a8, a1, 0x264
42014871:	10c132        	addi	a3, a1, 16
42014874:	8e6182        	s32i	a8, a1, 0x238
42014877:	9c21b2        	l32i	a11, a1, 0x270
4201487a:	972182        	l32i	a8, a1, 0x25c
4201487d:	9d21a2        	l32i	a10, a1, 0x274
42014880:	24a2c2        	movi	a12, 0x224
42014883:	80c3c0        	add	a12, a3, a12
42014886:	8f6182        	s32i	a8, a1, 0x23c
42014889:	ffe125        	call8	4201469c <__ssprint_r>
4201488c:	8e2182        	l32i	a8, a1, 0x238
4201488f:	02d342        	addmi	a4, a3, 0x200
42014892:	996182        	s32i	a8, a1, 0x264
42014895:	8f2182        	l32i	a8, a1, 0x23c
42014898:	976182        	s32i	a8, a1, 0x25c
4201489b:	1a8c      	beqz.n	a10, 420148a0 <_svfiprintf_r+0xf8>
4201489d:	06e2c6        	j	4201642c <_svfiprintf_r+0x1c84>
420148a0:	e4a182        	movi	a8, 0x1e4
420148a3:	838a      	add.n	a8, a3, a8
420148a5:	986182        	s32i	a8, a1, 0x260
420148a8:	9f2182        	l32i	a8, a1, 0x27c
420148ab:	885a      	add.n	a8, a8, a5
420148ad:	9f6182        	s32i	a8, a1, 0x27c
420148b0:	000782        	l8ui	a8, a7, 0
420148b3:	18cc      	bnez.n	a8, 420148b8 <_svfiprintf_r+0x110>
420148b5:	06d3c6        	j	42016408 <_svfiprintf_r+0x1c60>
420148b8:	10c192        	addi	a9, a1, 16
420148bb:	02d992        	addmi	a9, a9, 0x200
420148be:	0a0c      	movi.n	a10, 0
420148c0:	3a49a2        	s8i	a10, a9, 58
420148c3:	f97c      	movi.n	a9, -1
420148c5:	9b6192        	s32i	a9, a1, 0x26c
420148c8:	090c      	movi.n	a9, 0
420148ca:	871b      	addi.n	a8, a7, 1
420148cc:	065d      	mov.n	a5, a6
420148ce:	9e6192        	s32i	a9, a1, 0x278
420148d1:	030c      	movi.n	a3, 0
420148d3:	020c      	movi.n	a2, 0
420148d5:	000206        	j	420148e1 <_svfiprintf_r+0x139>
420148d8:	00          	.byte	00
420148d9:	9a6192        	s32i	a9, a1, 0x268
420148dc:	030c      	movi.n	a3, 0
420148de:	9a2182        	l32i	a8, a1, 0x268
420148e1:	981b      	addi.n	a9, a8, 1
420148e3:	000842        	l8ui	a4, a8, 0
420148e6:	9a6192        	s32i	a9, a1, 0x268
420148e9:	aa5c      	movi.n	a10, 90
420148eb:	000106        	j	420148f3 <_svfiprintf_r+0x14b>
420148ee:	820000        	mull	a0, a0, a0
420148f1:	829e61        	l32r	a6, 41ff536c <_iram_bss_end+0x1c72f6c>
420148f4:	87e0c4        	ee.vmulas.s16.qacc.ldbc.incp	q3, a12, q0, q4
420148f7:	02ba      	add.n	a0, a2, a11
420148f9:	0587c6        	j	42015f1c <_svfiprintf_r+0x1774>
420148fc:	b1ac91        	l32r	a9, 42000fac <_stext+0xf8c> (3c028c18 <__mprec_tens+0x178>)
420148ff:	a08890        	addx4	a8, a8, a9
42014902:	0888      	l32i.n	a8, a8, 0
42014904:	0008a0        	jx	a8
42014907:	810000        	src	a0, a0, a0
4201490a:	c6b1a7        	bgeu	a1, a10, 420148d4 <_svfiprintf_r+0x12c>
4201490d:	a20457        	bnone	a4, a5, 420148b3 <_svfiprintf_r+0x10b>
42014910:	109d21        	l32r	a2, 41fd8b84 <_iram_bss_end+0x1c56784>
42014913:	652011        	l32r	a1, 41fedd94 <_iram_bss_end+0x1c6b994>
42014916:	88fe02        	s32ri	a0, a14, 0x220
42014919:	ad1a      	add.n	a10, a13, a1
4201491b:	8208      	l32i.n	a0, a2, 32
4201491d:	81a361        	l32r	a6, 41ff4fac <_iram_bss_end+0x1c72bac>
42014920:	e0ae71        	l32r	a7, 4200cbd8 <__sflush_r+0x118> (a22020c6 <_rtc_reserved_end+0x421020c6>)
42014923:	0008      	l32i.n	a0, a0, 0
42014925:	a161a2        	s32i	a10, a1, 0x284
42014928:	9d21a2        	l32i	a10, a1, 0x274
4201492b:	201110        	or	a1, a1, a1
4201492e:	fe00e5        	call8	4201293c <_localeconv_r>
42014931:	2a88      	l32i.n	a8, a10, 8
42014933:	a06182        	s32i	a8, a1, 0x280
42014936:	a12182        	l32i	a8, a1, 0x284
42014939:	fa1816        	beqz	a8, 420148de <_svfiprintf_r+0x136>
4201493c:	a02182        	l32i	a8, a1, 0x280
4201493f:	f9b816        	beqz	a8, 420148de <_svfiprintf_r+0x136>
42014942:	000882        	l8ui	a8, a8, 0
42014945:	f95816        	beqz	a8, 420148de <_svfiprintf_r+0x136>
42014948:	00a482        	movi	a8, 0x400
4201494b:	00b906        	j	42014c33 <_svfiprintf_r+0x48b>
4201494e:	10c182        	addi	a8, a1, 16
42014951:	02d882        	addmi	a8, a8, 0x200
42014954:	3a0892        	l8ui	a9, a8, 58
42014957:	f83956        	bnez	a9, 420148de <_svfiprintf_r+0x136>
4201495a:	092c      	movi.n	a9, 32
4201495c:	004686        	j	42014a7a <_svfiprintf_r+0x2d2>
4201495f:	180c      	movi.n	a8, 1
42014961:	00b386        	j	42014c33 <_svfiprintf_r+0x48b>
42014964:	9a2182        	l32i	a8, a1, 0x268
42014967:	9a0c      	movi.n	a10, 9
42014969:	000882        	l8ui	a8, a8, 0
4201496c:	d0c892        	addi	a9, a8, -48
4201496f:	3d3a97        	bltu	a10, a9, 420149b0 <_svfiprintf_r+0x208>
42014972:	9a2192        	l32i	a9, a1, 0x268
42014975:	0a0c      	movi.n	a10, 0
42014977:	491b      	addi.n	a4, a9, 1
42014979:	09a0b2        	movi	a11, 9
4201497c:	d0c882        	addi	a8, a8, -48
4201497f:	a0aaa0        	addx4	a10, a10, a10
42014982:	90aa80        	addx2	a10, a10, a8
42014985:	000482        	l8ui	a8, a4, 0
42014988:	441b      	addi.n	a4, a4, 1
4201498a:	d0c892        	addi	a9, a8, -48
4201498d:	ebbb97        	bgeu	a11, a9, 4201497c <_svfiprintf_r+0x1d4>
42014990:	492c      	movi.n	a9, 36
42014992:	021897        	beq	a8, a9, 42014998 <_svfiprintf_r+0x1f0>
42014995:	ffd0c6        	j	420148dc <_svfiprintf_r+0x134>
42014998:	082c      	movi.n	a8, 32
4201499a:	02a8a7        	bge	a8, a10, 420149a0 <_svfiprintf_r+0x1f8>
4201499d:	06a2c6        	j	4201642c <_svfiprintf_r+0x1c84>
420149a0:	912182        	l32i	a8, a1, 0x244
420149a3:	aa0b      	addi.n	a10, a10, -1
420149a5:	10c1e2        	addi	a14, a1, 16
420149a8:	142a87        	blt	a10, a8, 420149c0 <_svfiprintf_r+0x218>
420149ab:	000646        	j	420149c8 <_svfiprintf_r+0x220>
420149ae:	b20000        	mulsh	a0, a0, a0
420149b1:	1b9121        	l32r	a2, 41fdb7f8 <_iram_bss_end+0x1c593f8>
420149b4:	c18296        	bltz	a2, 420145d0 <get_arg$isra$0+0x404>
420149b7:	26b710        	ee.ldf.64.xp	f11, f2, a1, a7
420149ba:	0d4632        	s8i	a3, a6, 13
420149bd:	000000        	ill
420149c0:	b0eae0        	addx8	a14, a10, a14
420149c3:	0e88      	l32i.n	a8, a14, 0
420149c5:	000686        	j	420149e3 <_svfiprintf_r+0x23b>
420149c8:	30a282        	movi	a8, 0x230
420149cb:	8e8a      	add.n	a8, a14, a8
420149cd:	34a2d2        	movi	a13, 0x234
420149d0:	40a2c2        	movi	a12, 0x240
420149d3:	0189      	s32i.n	a8, a1, 0
420149d5:	01def2        	addmi	a15, a14, 0x100
420149d8:	deda      	add.n	a13, a14, a13
420149da:	ceca      	add.n	a12, a14, a12
420149dc:	07bd      	mov.n	a11, a7
420149de:	ff7ee5        	call8	420141cc <get_arg$isra$0>
420149e1:	0a88      	l32i.n	a8, a10, 0
420149e3:	9e6182        	s32i	a8, a1, 0x278
420149e6:	9a6142        	s32i	a4, a1, 0x268
420149e9:	069d      	mov.n	a9, a6
420149eb:	001c06        	j	42014a5f <_svfiprintf_r+0x2b7>
420149ee:	b08580        	addx8	a8, a5, a8
420149f1:	001946        	j	42014a5a <_svfiprintf_r+0x2b2>
420149f4:	9228a2        	l32i	a10, a8, 0x248
420149f7:	fd1c      	movi.n	a13, 31
420149f9:	02d882        	addmi	a8, a8, 0x200
420149fc:	ca4b      	addi.n	a12, a10, 4
420149fe:	322db7        	blt	a13, a11, 42014a34 <_svfiprintf_r+0x28c>
42014a01:	db1b      	addi.n	a13, a11, 1
42014a03:	9161d2        	s32i	a13, a1, 0x244
42014a06:	1268c2        	s32i	a12, a8, 72
42014a09:	8d1c      	movi.n	a13, 24
42014a0b:	052dc7        	blt	a13, a12, 42014a14 <_svfiprintf_r+0x26c>
42014a0e:	1128a2        	l32i	a10, a8, 68
42014a11:	000286        	j	42014a1f <_svfiprintf_r+0x277>
42014a14:	012da7        	blt	a13, a10, 42014a19 <_svfiprintf_r+0x271>
42014a17:	4c2c      	movi.n	a12, 36
42014a19:	9421a2        	l32i	a10, a1, 0x250
42014a1c:	9661c2        	s32i	a12, a1, 0x258
42014a1f:	aaca      	add.n	a10, a10, a12
42014a21:	fccaa2        	addi	a10, a10, -4
42014a24:	0a88      	l32i.n	a8, a10, 0
42014a26:	9e6182        	s32i	a8, a1, 0x278
42014a29:	9e21a2        	l32i	a10, a1, 0x278
42014a2c:	b08b10        	addx8	a8, a11, a1
42014a2f:	48a9      	s32i.n	a10, a8, 16
42014a31:	000a86        	j	42014a5f <_svfiprintf_r+0x2b7>
42014a34:	1268c2        	s32i	a12, a8, 72
42014a37:	8b1c      	movi.n	a11, 24
42014a39:	072bc7        	blt	a11, a12, 42014a44 <_svfiprintf_r+0x29c>
42014a3c:	112882        	l32i	a8, a8, 68
42014a3f:	000486        	j	42014a55 <_svfiprintf_r+0x2ad>
42014a42:	a70000        	ee.stf.64.xp	f0, f10, a0, a0
42014a45:	012b      	addi.n	a0, a1, 2
42014a47:	4c2c      	movi.n	a12, 36
42014a49:	10c182        	addi	a8, a1, 16
42014a4c:	02d882        	addmi	a8, a8, 0x200
42014a4f:	102882        	l32i	a8, a8, 64
42014a52:	9661c2        	s32i	a12, a1, 0x258
42014a55:	88ca      	add.n	a8, a8, a12
42014a57:	fcc882        	addi	a8, a8, -4
42014a5a:	0888      	l32i.n	a8, a8, 0
42014a5c:	9e6182        	s32i	a8, a1, 0x278
42014a5f:	9e2182        	l32i	a8, a1, 0x278
42014a62:	096d      	mov.n	a6, a9
42014a64:	e768d6        	bgez	a8, 420148de <_svfiprintf_r+0x136>
42014a67:	608080        	neg	a8, a8
42014a6a:	9e6182        	s32i	a8, a1, 0x278
42014a6d:	480c      	movi.n	a8, 4
42014a6f:	007006        	j	42014c33 <_svfiprintf_r+0x48b>
42014a72:	10c182        	addi	a8, a1, 16
42014a75:	02d882        	addmi	a8, a8, 0x200
42014a78:	b92c      	movi.n	a9, 43
42014a7a:	3a4892        	s8i	a9, a8, 58
42014a7d:	ff9746        	j	420148de <_svfiprintf_r+0x136>
42014a80:	9a2182        	l32i	a8, a1, 0x268
42014a83:	000842        	l8ui	a4, a8, 0
42014a86:	981b      	addi.n	a9, a8, 1
42014a88:	a82c      	movi.n	a8, 42
42014a8a:	061487        	beq	a4, a8, 42014a94 <_svfiprintf_r+0x2ec>
42014a8d:	080c      	movi.n	a8, 0
42014a8f:	9c0c      	movi.n	a12, 9
42014a91:	004386        	j	42014ba3 <_svfiprintf_r+0x3fb>
42014a94:	9a2182        	l32i	a8, a1, 0x268
42014a97:	9b0c      	movi.n	a11, 9
42014a99:	010882        	l8ui	a8, a8, 1
42014a9c:	d0c8a2        	addi	a10, a8, -48
42014a9f:	393ba7        	bltu	a11, a10, 42014adc <_svfiprintf_r+0x334>
42014aa2:	9a21a2        	l32i	a10, a1, 0x268
42014aa5:	4a2b      	addi.n	a4, a10, 2
42014aa7:	0a0c      	movi.n	a10, 0
42014aa9:	d0c882        	addi	a8, a8, -48
42014aac:	a0aaa0        	addx4	a10, a10, a10
42014aaf:	90aa80        	addx2	a10, a10, a8
42014ab2:	000482        	l8ui	a8, a4, 0
42014ab5:	441b      	addi.n	a4, a4, 1
42014ab7:	d0c8c2        	addi	a12, a8, -48
42014aba:	ebbbc7        	bgeu	a11, a12, 42014aa9 <_svfiprintf_r+0x301>
42014abd:	4b2c      	movi.n	a11, 36
42014abf:	0218b7        	beq	a8, a11, 42014ac5 <_svfiprintf_r+0x31d>
42014ac2:	ff84c6        	j	420148d9 <_svfiprintf_r+0x131>
42014ac5:	082c      	movi.n	a8, 32
42014ac7:	02a8a7        	bge	a8, a10, 42014acd <_svfiprintf_r+0x325>
42014aca:	065786        	j	4201642c <_svfiprintf_r+0x1c84>
42014acd:	912182        	l32i	a8, a1, 0x244
42014ad0:	aa0b      	addi.n	a10, a10, -1
42014ad2:	10c1e2        	addi	a14, a1, 16
42014ad5:	132a87        	blt	a10, a8, 42014aec <_svfiprintf_r+0x344>
42014ad8:	000606        	j	42014af4 <_svfiprintf_r+0x34c>
42014adb:	21a200        	srai	a10, a0, 2
42014ade:	c61b91        	l32r	a9, 4200634c <app_main+0x5c> (518107ad <_rtc_bss_end+0x18107ad>)
42014ae1:	10c182        	addi	a8, a1, 16
42014ae4:	2e26a7        	blt	a6, a10, 42014b16 <_svfiprintf_r+0x36e>
42014ae7:	000c46        	j	42014b1c <_svfiprintf_r+0x374>
42014aea:	e00000        	subx4	a0, a0, a0
42014aed:	b0ea      	add.n	a11, a0, a14
42014aef:	0e88      	l32i.n	a8, a14, 0
42014af1:	000686        	j	42014b0f <_svfiprintf_r+0x367>
42014af4:	30a282        	movi	a8, 0x230
42014af7:	8e8a      	add.n	a8, a14, a8
42014af9:	34a2d2        	movi	a13, 0x234
42014afc:	40a2c2        	movi	a12, 0x240
42014aff:	0189      	s32i.n	a8, a1, 0
42014b01:	01def2        	addmi	a15, a14, 0x100
42014b04:	deda      	add.n	a13, a14, a13
42014b06:	ceca      	add.n	a12, a14, a12
42014b08:	07bd      	mov.n	a11, a7
42014b0a:	ff6c25        	call8	420141cc <get_arg$isra$0>
42014b0d:	0a88      	l32i.n	a8, a10, 0
42014b0f:	049d      	mov.n	a9, a4
42014b11:	06cd      	mov.n	a12, a6
42014b13:	001c46        	j	42014b88 <_svfiprintf_r+0x3e0>
42014b16:	b08580        	addx8	a8, a5, a8
42014b19:	001a46        	j	42014b86 <_svfiprintf_r+0x3de>
42014b1c:	fb1c      	movi.n	a11, 31
42014b1e:	362ba7        	blt	a11, a10, 42014b58 <_svfiprintf_r+0x3b0>
42014b21:	9228e2        	l32i	a14, a8, 0x248
42014b24:	ba1b      	addi.n	a11, a10, 1
42014b26:	9161b2        	s32i	a11, a1, 0x244
42014b29:	be4b      	addi.n	a11, a14, 4
42014b2b:	9268b2        	s32i	a11, a8, 0x248
42014b2e:	8f1c      	movi.n	a15, 24
42014b30:	052fb7        	blt	a15, a11, 42014b39 <_svfiprintf_r+0x391>
42014b33:	912882        	l32i	a8, a8, 0x244
42014b36:	000346        	j	42014b47 <_svfiprintf_r+0x39f>
42014b39:	012fe7        	blt	a15, a14, 42014b3e <_svfiprintf_r+0x396>
42014b3c:	4b2c      	movi.n	a11, 36
42014b3e:	9268b2        	s32i	a11, a8, 0x248
42014b41:	02d882        	addmi	a8, a8, 0x200
42014b44:	102882        	l32i	a8, a8, 64
42014b47:	88ba      	add.n	a8, a8, a11
42014b49:	fcc882        	addi	a8, a8, -4
42014b4c:	0888      	l32i.n	a8, a8, 0
42014b4e:	b0aa10        	addx8	a10, a10, a1
42014b51:	4a89      	s32i.n	a8, a10, 16
42014b53:	000c46        	j	42014b88 <_svfiprintf_r+0x3e0>
42014b56:	b20000        	mulsh	a0, a0, a0
42014b59:	9228      	l32i.n	a2, a2, 36
42014b5b:	8d1c      	movi.n	a13, 24
42014b5d:	ab4b      	addi.n	a10, a11, 4
42014b5f:	9268a2        	s32i	a10, a8, 0x248
42014b62:	02d882        	addmi	a8, a8, 0x200
42014b65:	072da7        	blt	a13, a10, 42014b70 <_svfiprintf_r+0x3c8>
42014b68:	112882        	l32i	a8, a8, 68
42014b6b:	000486        	j	42014b81 <_svfiprintf_r+0x3d9>
42014b6e:	b70000        	ee.stf.64.xp	f0, f11, a0, a0
42014b71:	012d      	mov.n	a2, a1
42014b73:	4a2c      	movi.n	a10, 36
42014b75:	10c182        	addi	a8, a1, 16
42014b78:	02d882        	addmi	a8, a8, 0x200
42014b7b:	102882        	l32i	a8, a8, 64
42014b7e:	9661a2        	s32i	a10, a1, 0x258
42014b81:	88aa      	add.n	a8, a8, a10
42014b83:	fcc882        	addi	a8, a8, -4
42014b86:	0888      	l32i.n	a8, a8, 0
42014b88:	fa7c      	movi.n	a10, -1
42014b8a:	5388a0        	max	a8, a8, a10
42014b8d:	9b6182        	s32i	a8, a1, 0x26c
42014b90:	0c6d      	mov.n	a6, a12
42014b92:	9a6192        	s32i	a9, a1, 0x268
42014b95:	ff5146        	j	420148de <_svfiprintf_r+0x136>
42014b98:	a08880        	addx4	a8, a8, a8
42014b9b:	000942        	l8ui	a4, a9, 0
42014b9e:	9088b0        	addx2	a8, a8, a11
42014ba1:	991b      	addi.n	a9, a9, 1
42014ba3:	9a6192        	s32i	a9, a1, 0x268
42014ba6:	d0c4b2        	addi	a11, a4, -48
42014ba9:	ebbcb7        	bgeu	a12, a11, 42014b98 <_svfiprintf_r+0x3f0>
42014bac:	f97c      	movi.n	a9, -1
42014bae:	538890        	max	a8, a8, a9
42014bb1:	9b6182        	s32i	a8, a1, 0x26c
42014bb4:	9e2182        	l32i	a8, a1, 0x278
42014bb7:	ff4d46        	j	420148f0 <_svfiprintf_r+0x148>
42014bba:	80a082        	movi	a8, 128
42014bbd:	001c86        	j	42014c33 <_svfiprintf_r+0x48b>
42014bc0:	080c      	movi.n	a8, 0
42014bc2:	9b0c      	movi.n	a11, 9
42014bc4:	9a2192        	l32i	a9, a1, 0x268
42014bc7:	d0c442        	addi	a4, a4, -48
42014bca:	a08880        	addx4	a8, a8, a8
42014bcd:	908840        	addx2	a8, a8, a4
42014bd0:	000942        	l8ui	a4, a9, 0
42014bd3:	991b      	addi.n	a9, a9, 1
42014bd5:	9a6192        	s32i	a9, a1, 0x268
42014bd8:	d0c492        	addi	a9, a4, -48
42014bdb:	e5bb97        	bgeu	a11, a9, 42014bc4 <_svfiprintf_r+0x41c>
42014bde:	492c      	movi.n	a9, 36
42014be0:	021497        	beq	a4, a9, 42014be6 <_svfiprintf_r+0x43e>
42014be3:	ff4246        	j	420148f0 <_svfiprintf_r+0x148>
42014be6:	092c      	movi.n	a9, 32
42014be8:	02a987        	bge	a9, a8, 42014bee <_svfiprintf_r+0x446>
42014beb:	060f46        	j	4201642c <_svfiprintf_r+0x1c84>
42014bee:	580b      	addi.n	a5, a8, -1
42014bf0:	130c      	movi.n	a3, 1
42014bf2:	ff3a06        	j	420148de <_svfiprintf_r+0x136>
42014bf5:	218200        	srai	a8, a0, 2
42014bf8:	929a      	add.n	a9, a2, a9
42014bfa:	0008      	l32i.n	a0, a0, 0
42014bfc:	68a082        	movi	a8, 104
42014bff:	0d9987        	bne	a9, a8, 42014c10 <_svfiprintf_r+0x468>
42014c02:	9a2182        	l32i	a8, a1, 0x268
42014c05:	881b      	addi.n	a8, a8, 1
42014c07:	9a6182        	s32i	a8, a1, 0x268
42014c0a:	00a282        	movi	a8, 0x200
42014c0d:	000886        	j	42014c33 <_svfiprintf_r+0x48b>
42014c10:	084c      	movi.n	a8, 64
42014c12:	000746        	j	42014c33 <_svfiprintf_r+0x48b>
42014c15:	9a2182        	l32i	a8, a1, 0x268
42014c18:	000892        	l8ui	a9, a8, 0
42014c1b:	6ca082        	movi	a8, 108
42014c1e:	0a9987        	bne	a9, a8, 42014c2c <_svfiprintf_r+0x484>
42014c21:	9a2182        	l32i	a8, a1, 0x268
42014c24:	881b      	addi.n	a8, a8, 1
42014c26:	9a6182        	s32i	a8, a1, 0x268
42014c29:	000106        	j	42014c31 <_svfiprintf_r+0x489>
42014c2c:	081c      	movi.n	a8, 16
42014c2e:	000046        	j	42014c33 <_svfiprintf_r+0x48b>
42014c31:	082c      	movi.n	a8, 32
42014c33:	202280        	or	a2, a2, a8
42014c36:	ff2906        	j	420148de <_svfiprintf_r+0x136>
42014c39:	912182        	l32i	a8, a1, 0x244
42014c3c:	10c1e2        	addi	a14, a1, 16
42014c3f:	d3ac      	beqz.n	a3, 42014c70 <_svfiprintf_r+0x4c8>
42014c41:	08a587        	bge	a5, a8, 42014c4d <_svfiprintf_r+0x4a5>
42014c44:	b0e5e0        	addx8	a14, a5, a14
42014c47:	000e92        	l8ui	a9, a14, 0
42014c4a:	000746        	j	42014c6b <_svfiprintf_r+0x4c3>
42014c4d:	30a282        	movi	a8, 0x230
42014c50:	8e8a      	add.n	a8, a14, a8
42014c52:	34a2d2        	movi	a13, 0x234
42014c55:	40a2c2        	movi	a12, 0x240
42014c58:	0189      	s32i.n	a8, a1, 0
42014c5a:	01def2        	addmi	a15, a14, 0x100
42014c5d:	deda      	add.n	a13, a14, a13
42014c5f:	ceca      	add.n	a12, a14, a12
42014c61:	07bd      	mov.n	a11, a7
42014c63:	05ad      	mov.n	a10, a5
42014c65:	ff5665        	call8	420141cc <get_arg$isra$0>
42014c68:	000a92        	l8ui	a9, a10, 0
42014c6b:	067d      	mov.n	a7, a6
42014c6d:	001f06        	j	42014ced <_svfiprintf_r+0x545>
42014c70:	761b      	addi.n	a7, a6, 1
42014c72:	0aa687        	bge	a6, a8, 42014c80 <_svfiprintf_r+0x4d8>
42014c75:	b0e5e0        	addx8	a14, a5, a14
42014c78:	000e92        	l8ui	a9, a14, 0
42014c7b:	001b86        	j	42014ced <_svfiprintf_r+0x545>
42014c7e:	00          	.byte	00
42014c7f:	00          	.byte	00
42014c80:	922e92        	l32i	a9, a14, 0x248
42014c83:	fb1c      	movi.n	a11, 31
42014c85:	02dee2        	addmi	a14, a14, 0x200
42014c88:	a94b      	addi.n	a10, a9, 4
42014c8a:	362b87        	blt	a11, a8, 42014cc4 <_svfiprintf_r+0x51c>
42014c8d:	b81b      	addi.n	a11, a8, 1
42014c8f:	9161b2        	s32i	a11, a1, 0x244
42014c92:	126ea2        	s32i	a10, a14, 72
42014c95:	8b1c      	movi.n	a11, 24
42014c97:	052ba7        	blt	a11, a10, 42014ca0 <_svfiprintf_r+0x4f8>
42014c9a:	112e92        	l32i	a9, a14, 68
42014c9d:	000406        	j	42014cb1 <_svfiprintf_r+0x509>
42014ca0:	012b97        	blt	a11, a9, 42014ca5 <_svfiprintf_r+0x4fd>
42014ca3:	4a2c      	movi.n	a10, 36
42014ca5:	10c192        	addi	a9, a1, 16
42014ca8:	02d992        	addmi	a9, a9, 0x200
42014cab:	102992        	l32i	a9, a9, 64
42014cae:	9661a2        	s32i	a10, a1, 0x258
42014cb1:	99aa      	add.n	a9, a9, a10
42014cb3:	fcc992        	addi	a9, a9, -4
42014cb6:	0998      	l32i.n	a9, a9, 0
42014cb8:	b08810        	addx8	a8, a8, a1
42014cbb:	4899      	s32i.n	a9, a8, 16
42014cbd:	749090        	extui	a9, a9, 0, 8
42014cc0:	000a46        	j	42014ced <_svfiprintf_r+0x545>
42014cc3:	00          	.byte	00
42014cc4:	126ea2        	s32i	a10, a14, 72
42014cc7:	881c      	movi.n	a8, 24
42014cc9:	0728a7        	blt	a8, a10, 42014cd4 <_svfiprintf_r+0x52c>
42014ccc:	112e82        	l32i	a8, a14, 68
42014ccf:	000486        	j	42014ce5 <_svfiprintf_r+0x53d>
42014cd2:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42014cd5:	0128      	l32i.n	a2, a1, 0
42014cd7:	4a2c      	movi.n	a10, 36
42014cd9:	10c182        	addi	a8, a1, 16
42014cdc:	02d882        	addmi	a8, a8, 0x200
42014cdf:	102882        	l32i	a8, a8, 64
42014ce2:	9661a2        	s32i	a10, a1, 0x258
42014ce5:	88aa      	add.n	a8, a8, a10
42014ce7:	fcc882        	addi	a8, a8, -4
42014cea:	000892        	l8ui	a9, a8, 0
42014ced:	10c182        	addi	a8, a1, 16
42014cf0:	01d8a2        	addmi	a10, a8, 0x100
42014cf3:	804a92        	s8i	a9, a10, 128
42014cf6:	02d892        	addmi	a9, a8, 0x200
42014cf9:	0a0c      	movi.n	a10, 0
42014cfb:	3a49a2        	s8i	a10, a9, 58
42014cfe:	048c06        	j	42015f32 <_svfiprintf_r+0x178a>
42014d01:	081c      	movi.n	a8, 16
42014d03:	202280        	or	a2, a2, a8
42014d06:	912182        	l32i	a8, a1, 0x244
42014d09:	10c1e2        	addi	a14, a1, 16
42014d0c:	02e257        	bbsi	a2, 5, 42014d12 <_svfiprintf_r+0x56a>
42014d0f:	002f86        	j	42014dd1 <_svfiprintf_r+0x629>
42014d12:	f3ac      	beqz.n	a3, 42014d45 <_svfiprintf_r+0x59d>
42014d14:	09a587        	bge	a5, a8, 42014d21 <_svfiprintf_r+0x579>
42014d17:	b0e5e0        	addx8	a14, a5, a14
42014d1a:	0e58      	l32i.n	a5, a14, 0
42014d1c:	1e38      	l32i.n	a3, a14, 4
42014d1e:	000786        	j	42014d40 <_svfiprintf_r+0x598>
42014d21:	30a282        	movi	a8, 0x230
42014d24:	8e8a      	add.n	a8, a14, a8
42014d26:	34a2d2        	movi	a13, 0x234
42014d29:	40a2c2        	movi	a12, 0x240
42014d2c:	05ad      	mov.n	a10, a5
42014d2e:	0189      	s32i.n	a8, a1, 0
42014d30:	01def2        	addmi	a15, a14, 0x100
42014d33:	deda      	add.n	a13, a14, a13
42014d35:	ceca      	add.n	a12, a14, a12
42014d37:	07bd      	mov.n	a11, a7
42014d39:	ff4925        	call8	420141cc <get_arg$isra$0>
42014d3c:	0a58      	l32i.n	a5, a10, 0
42014d3e:	1a38      	l32i.n	a3, a10, 4
42014d40:	067d      	mov.n	a7, a6
42014d42:	00a946        	j	42014feb <_svfiprintf_r+0x843>
42014d45:	761b      	addi.n	a7, a6, 1
42014d47:	09a687        	bge	a6, a8, 42014d54 <_svfiprintf_r+0x5ac>
42014d4a:	b0e5e0        	addx8	a14, a5, a14
42014d4d:	0e58      	l32i.n	a5, a14, 0
42014d4f:	1e38      	l32i.n	a3, a14, 4
42014d51:	00a586        	j	42014feb <_svfiprintf_r+0x843>
42014d54:	922e92        	l32i	a9, a14, 0x248
42014d57:	8a7c      	movi.n	a10, -8
42014d59:	997b      	addi.n	a9, a9, 7
42014d5b:	1099a0        	and	a9, a9, a10
42014d5e:	fb1c      	movi.n	a11, 31
42014d60:	02dee2        	addmi	a14, a14, 0x200
42014d63:	a98b      	addi.n	a10, a9, 8
42014d65:	3b2b87        	blt	a11, a8, 42014da4 <_svfiprintf_r+0x5fc>
42014d68:	b81b      	addi.n	a11, a8, 1
42014d6a:	9161b2        	s32i	a11, a1, 0x244
42014d6d:	126ea2        	s32i	a10, a14, 72
42014d70:	8b1c      	movi.n	a11, 24
42014d72:	062ba7        	blt	a11, a10, 42014d7c <_svfiprintf_r+0x5d4>
42014d75:	112e92        	l32i	a9, a14, 68
42014d78:	000446        	j	42014d8d <_svfiprintf_r+0x5e5>
42014d7b:	2b9700        	oeq.s	b9, f7, f0
42014d7e:	8a2c01        	l32r	a0, 41ff7630 <_iram_bss_end+0x1c75230>
42014d81:	10c192        	addi	a9, a1, 16
42014d84:	02d992        	addmi	a9, a9, 0x200
42014d87:	102992        	l32i	a9, a9, 64
42014d8a:	9661a2        	s32i	a10, a1, 0x258
42014d8d:	99aa      	add.n	a9, a9, a10
42014d8f:	f8c992        	addi	a9, a9, -8
42014d92:	0958      	l32i.n	a5, a9, 0
42014d94:	1938      	l32i.n	a3, a9, 4
42014d96:	10c192        	addi	a9, a1, 16
42014d99:	b08890        	addx8	a8, a8, a9
42014d9c:	0859      	s32i.n	a5, a8, 0
42014d9e:	1839      	s32i.n	a3, a8, 4
42014da0:	0091c6        	j	42014feb <_svfiprintf_r+0x843>
42014da3:	00          	.byte	00
42014da4:	126ea2        	s32i	a10, a14, 72
42014da7:	881c      	movi.n	a8, 24
42014da9:	0728a7        	blt	a8, a10, 42014db4 <_svfiprintf_r+0x60c>
42014dac:	112e82        	l32i	a8, a14, 68
42014daf:	000486        	j	42014dc5 <_svfiprintf_r+0x61d>
42014db2:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42014db5:	0128      	l32i.n	a2, a1, 0
42014db7:	8a2c      	movi.n	a10, 40
42014db9:	10c182        	addi	a8, a1, 16
42014dbc:	02d882        	addmi	a8, a8, 0x200
42014dbf:	102882        	l32i	a8, a8, 64
42014dc2:	9661a2        	s32i	a10, a1, 0x258
42014dc5:	88aa      	add.n	a8, a8, a10
42014dc7:	f8c882        	addi	a8, a8, -8
42014dca:	0858      	l32i.n	a5, a8, 0
42014dcc:	1838      	l32i.n	a3, a8, 4
42014dce:	008646        	j	42014feb <_svfiprintf_r+0x843>
42014dd1:	036247        	bbci	a2, 4, 42014dd8 <_svfiprintf_r+0x630>
42014dd4:	005b06        	j	42014f44 <_svfiprintf_r+0x79c>
42014dd7:	e26700        	remu	a6, a7, a0
42014dda:	02          	.byte	0x2
42014ddb:	002a86        	j	42014e89 <_svfiprintf_r+0x6e1>
42014dde:	c3ac      	beqz.n	a3, 42014e0e <_svfiprintf_r+0x666>
42014de0:	09a587        	bge	a5, a8, 42014ded <_svfiprintf_r+0x645>
42014de3:	b0e5e0        	addx8	a14, a5, a14
42014de6:	009e52        	l16si	a5, a14, 0
42014de9:	006046        	j	42014f6e <_svfiprintf_r+0x7c6>
42014dec:	a28200        	muluh	a8, a2, a0
42014def:	30          	.byte	0x30
42014df0:	8e8a      	add.n	a8, a14, a8
42014df2:	34a2d2        	movi	a13, 0x234
42014df5:	40a2c2        	movi	a12, 0x240
42014df8:	05ad      	mov.n	a10, a5
42014dfa:	0189      	s32i.n	a8, a1, 0
42014dfc:	01def2        	addmi	a15, a14, 0x100
42014dff:	deda      	add.n	a13, a14, a13
42014e01:	ceca      	add.n	a12, a14, a12
42014e03:	07bd      	mov.n	a11, a7
42014e05:	ff3c65        	call8	420141cc <get_arg$isra$0>
42014e08:	009a52        	l16si	a5, a10, 0
42014e0b:	0057c6        	j	42014f6e <_svfiprintf_r+0x7c6>
42014e0e:	761b      	addi.n	a7, a6, 1
42014e10:	08a687        	bge	a6, a8, 42014e1c <_svfiprintf_r+0x674>
42014e13:	b0e5e0        	addx8	a14, a5, a14
42014e16:	009e52        	l16si	a5, a14, 0
42014e19:	0072c6        	j	42014fe8 <_svfiprintf_r+0x840>
42014e1c:	922e92        	l32i	a9, a14, 0x248
42014e1f:	fb1c      	movi.n	a11, 31
42014e21:	02dee2        	addmi	a14, a14, 0x200
42014e24:	a94b      	addi.n	a10, a9, 4
42014e26:	352b87        	blt	a11, a8, 42014e5f <_svfiprintf_r+0x6b7>
42014e29:	b81b      	addi.n	a11, a8, 1
42014e2b:	9161b2        	s32i	a11, a1, 0x244
42014e2e:	126ea2        	s32i	a10, a14, 72
42014e31:	8b1c      	movi.n	a11, 24
42014e33:	052ba7        	blt	a11, a10, 42014e3c <_svfiprintf_r+0x694>
42014e36:	112e92        	l32i	a9, a14, 68
42014e39:	000406        	j	42014e4d <_svfiprintf_r+0x6a5>
42014e3c:	012b97        	blt	a11, a9, 42014e41 <_svfiprintf_r+0x699>
42014e3f:	4a2c      	movi.n	a10, 36
42014e41:	10c192        	addi	a9, a1, 16
42014e44:	02d992        	addmi	a9, a9, 0x200
42014e47:	102992        	l32i	a9, a9, 64
42014e4a:	9661a2        	s32i	a10, a1, 0x258
42014e4d:	99aa      	add.n	a9, a9, a10
42014e4f:	fcc992        	addi	a9, a9, -4
42014e52:	0958      	l32i.n	a5, a9, 0
42014e54:	b08810        	addx8	a8, a8, a1
42014e57:	4859      	s32i.n	a5, a8, 16
42014e59:	235580        	sext	a5, a5, 15
42014e5c:	006206        	j	42014fe8 <_svfiprintf_r+0x840>
42014e5f:	126ea2        	s32i	a10, a14, 72
42014e62:	881c      	movi.n	a8, 24
42014e64:	0528a7        	blt	a8, a10, 42014e6d <_svfiprintf_r+0x6c5>
42014e67:	112e82        	l32i	a8, a14, 68
42014e6a:	000406        	j	42014e7e <_svfiprintf_r+0x6d6>
42014e6d:	012897        	blt	a8, a9, 42014e72 <_svfiprintf_r+0x6ca>
42014e70:	4a2c      	movi.n	a10, 36
42014e72:	10c182        	addi	a8, a1, 16
42014e75:	02d882        	addmi	a8, a8, 0x200
42014e78:	102882        	l32i	a8, a8, 64
42014e7b:	9661a2        	s32i	a10, a1, 0x258
42014e7e:	88aa      	add.n	a8, a8, a10
42014e80:	fcc882        	addi	a8, a8, -4
42014e83:	009852        	l16si	a5, a8, 0
42014e86:	005786        	j	42014fe8 <_svfiprintf_r+0x840>
42014e89:	02e297        	bbsi	a2, 9, 42014e8f <_svfiprintf_r+0x6e7>
42014e8c:	002d06        	j	42014f44 <_svfiprintf_r+0x79c>
42014e8f:	d3ac      	beqz.n	a3, 42014ec0 <_svfiprintf_r+0x718>
42014e91:	08a587        	bge	a5, a8, 42014e9d <_svfiprintf_r+0x6f5>
42014e94:	b0e5e0        	addx8	a14, a5, a14
42014e97:	000e52        	l8ui	a5, a14, 0
42014e9a:	000746        	j	42014ebb <_svfiprintf_r+0x713>
42014e9d:	30a282        	movi	a8, 0x230
42014ea0:	8e8a      	add.n	a8, a14, a8
42014ea2:	34a2d2        	movi	a13, 0x234
42014ea5:	40a2c2        	movi	a12, 0x240
42014ea8:	05ad      	mov.n	a10, a5
42014eaa:	0189      	s32i.n	a8, a1, 0
42014eac:	01def2        	addmi	a15, a14, 0x100
42014eaf:	deda      	add.n	a13, a14, a13
42014eb1:	ceca      	add.n	a12, a14, a12
42014eb3:	07bd      	mov.n	a11, a7
42014eb5:	ff3165        	call8	420141cc <get_arg$isra$0>
42014eb8:	000a52        	l8ui	a5, a10, 0
42014ebb:	067d      	mov.n	a7, a6
42014ebd:	001f06        	j	42014f3d <_svfiprintf_r+0x795>
42014ec0:	761b      	addi.n	a7, a6, 1
42014ec2:	0aa687        	bge	a6, a8, 42014ed0 <_svfiprintf_r+0x728>
42014ec5:	b0e5e0        	addx8	a14, a5, a14
42014ec8:	000e52        	l8ui	a5, a14, 0
42014ecb:	001b86        	j	42014f3d <_svfiprintf_r+0x795>
42014ece:	00          	.byte	00
42014ecf:	00          	.byte	00
42014ed0:	922e92        	l32i	a9, a14, 0x248
42014ed3:	fb1c      	movi.n	a11, 31
42014ed5:	02dee2        	addmi	a14, a14, 0x200
42014ed8:	a94b      	addi.n	a10, a9, 4
42014eda:	362b87        	blt	a11, a8, 42014f14 <_svfiprintf_r+0x76c>
42014edd:	b81b      	addi.n	a11, a8, 1
42014edf:	9161b2        	s32i	a11, a1, 0x244
42014ee2:	126ea2        	s32i	a10, a14, 72
42014ee5:	8b1c      	movi.n	a11, 24
42014ee7:	052ba7        	blt	a11, a10, 42014ef0 <_svfiprintf_r+0x748>
42014eea:	112e92        	l32i	a9, a14, 68
42014eed:	000406        	j	42014f01 <_svfiprintf_r+0x759>
42014ef0:	012b97        	blt	a11, a9, 42014ef5 <_svfiprintf_r+0x74d>
42014ef3:	4a2c      	movi.n	a10, 36
42014ef5:	10c192        	addi	a9, a1, 16
42014ef8:	02d992        	addmi	a9, a9, 0x200
42014efb:	102992        	l32i	a9, a9, 64
42014efe:	9661a2        	s32i	a10, a1, 0x258
42014f01:	99aa      	add.n	a9, a9, a10
42014f03:	fcc992        	addi	a9, a9, -4
42014f06:	0958      	l32i.n	a5, a9, 0
42014f08:	b08810        	addx8	a8, a8, a1
42014f0b:	4859      	s32i.n	a5, a8, 16
42014f0d:	745050        	extui	a5, a5, 0, 8
42014f10:	000a46        	j	42014f3d <_svfiprintf_r+0x795>
42014f13:	00          	.byte	00
42014f14:	126ea2        	s32i	a10, a14, 72
42014f17:	881c      	movi.n	a8, 24
42014f19:	0728a7        	blt	a8, a10, 42014f24 <_svfiprintf_r+0x77c>
42014f1c:	112e82        	l32i	a8, a14, 68
42014f1f:	000486        	j	42014f35 <_svfiprintf_r+0x78d>
42014f22:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42014f25:	0128      	l32i.n	a2, a1, 0
42014f27:	4a2c      	movi.n	a10, 36
42014f29:	10c182        	addi	a8, a1, 16
42014f2c:	02d882        	addmi	a8, a8, 0x200
42014f2f:	102882        	l32i	a8, a8, 64
42014f32:	9661a2        	s32i	a10, a1, 0x258
42014f35:	88aa      	add.n	a8, a8, a10
42014f37:	fcc882        	addi	a8, a8, -4
42014f3a:	000852        	l8ui	a5, a8, 0
42014f3d:	235500        	sext	a5, a5, 7
42014f40:	002906        	j	42014fe8 <_svfiprintf_r+0x840>
42014f43:	b3ac00        	movgez	a10, a12, a0
42014f46:	07a587        	bge	a5, a8, 42014f51 <_svfiprintf_r+0x7a9>
42014f49:	b0e5e0        	addx8	a14, a5, a14
42014f4c:	0e58      	l32i.n	a5, a14, 0
42014f4e:	000706        	j	42014f6e <_svfiprintf_r+0x7c6>
42014f51:	30a282        	movi	a8, 0x230
42014f54:	8e8a      	add.n	a8, a14, a8
42014f56:	34a2d2        	movi	a13, 0x234
42014f59:	40a2c2        	movi	a12, 0x240
42014f5c:	05ad      	mov.n	a10, a5
42014f5e:	0189      	s32i.n	a8, a1, 0
42014f60:	01def2        	addmi	a15, a14, 0x100
42014f63:	deda      	add.n	a13, a14, a13
42014f65:	ceca      	add.n	a12, a14, a12
42014f67:	07bd      	mov.n	a11, a7
42014f69:	ff2625        	call8	420141cc <get_arg$isra$0>
42014f6c:	0a58      	l32i.n	a5, a10, 0
42014f6e:	067d      	mov.n	a7, a6
42014f70:	001d06        	j	42014fe8 <_svfiprintf_r+0x840>
42014f73:	761b      	addi.n	a7, a6, 1
42014f75:	07a687        	bge	a6, a8, 42014f80 <_svfiprintf_r+0x7d8>
42014f78:	b0e5e0        	addx8	a14, a5, a14
42014f7b:	0e58      	l32i.n	a5, a14, 0
42014f7d:	0019c6        	j	42014fe8 <_svfiprintf_r+0x840>
42014f80:	922e92        	l32i	a9, a14, 0x248
42014f83:	fb1c      	movi.n	a11, 31
42014f85:	02dee2        	addmi	a14, a14, 0x200
42014f88:	a94b      	addi.n	a10, a9, 4
42014f8a:	322b87        	blt	a11, a8, 42014fc0 <_svfiprintf_r+0x818>
42014f8d:	b81b      	addi.n	a11, a8, 1
42014f8f:	9161b2        	s32i	a11, a1, 0x244
42014f92:	126ea2        	s32i	a10, a14, 72
42014f95:	8b1c      	movi.n	a11, 24
42014f97:	052ba7        	blt	a11, a10, 42014fa0 <_svfiprintf_r+0x7f8>
42014f9a:	112e92        	l32i	a9, a14, 68
42014f9d:	000406        	j	42014fb1 <_svfiprintf_r+0x809>
42014fa0:	012b97        	blt	a11, a9, 42014fa5 <_svfiprintf_r+0x7fd>
42014fa3:	4a2c      	movi.n	a10, 36
42014fa5:	10c192        	addi	a9, a1, 16
42014fa8:	02d992        	addmi	a9, a9, 0x200
42014fab:	102992        	l32i	a9, a9, 64
42014fae:	9661a2        	s32i	a10, a1, 0x258
42014fb1:	99aa      	add.n	a9, a9, a10
42014fb3:	fcc992        	addi	a9, a9, -4
42014fb6:	0958      	l32i.n	a5, a9, 0
42014fb8:	b08810        	addx8	a8, a8, a1
42014fbb:	4859      	s32i.n	a5, a8, 16
42014fbd:	0009c6        	j	42014fe8 <_svfiprintf_r+0x840>
42014fc0:	126ea2        	s32i	a10, a14, 72
42014fc3:	881c      	movi.n	a8, 24
42014fc5:	0728a7        	blt	a8, a10, 42014fd0 <_svfiprintf_r+0x828>
42014fc8:	112e82        	l32i	a8, a14, 68
42014fcb:	000486        	j	42014fe1 <_svfiprintf_r+0x839>
42014fce:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42014fd1:	0128      	l32i.n	a2, a1, 0
42014fd3:	4a2c      	movi.n	a10, 36
42014fd5:	10c182        	addi	a8, a1, 16
42014fd8:	02d882        	addmi	a8, a8, 0x200
42014fdb:	102882        	l32i	a8, a8, 64
42014fde:	9661a2        	s32i	a10, a1, 0x258
42014fe1:	88aa      	add.n	a8, a8, a10
42014fe3:	fcc882        	addi	a8, a8, -4
42014fe6:	0858      	l32i.n	a5, a8, 0
42014fe8:	313f50        	srai	a3, a5, 31
42014feb:	002396        	bltz	a3, 42014ff1 <_svfiprintf_r+0x849>
42014fee:	0512c6        	j	4201643d <_svfiprintf_r+0x1c95>
42014ff1:	603030        	neg	a3, a3
42014ff4:	058c      	beqz.n	a5, 42014ff8 <_svfiprintf_r+0x850>
42014ff6:	330b      	addi.n	a3, a3, -1
42014ff8:	605050        	neg	a5, a5
42014ffb:	d82c      	movi.n	a8, 45
42014ffd:	190c      	movi.n	a9, 1
42014fff:	036006        	j	42015d83 <_svfiprintf_r+0x15db>
42015002:	820000        	mull	a0, a0, a0
42015005:	e29121        	l32r	a2, 4200da4c <_vfprintf_r+0x108> (fa7c080c <_rtc_reserved_end+0x9a6c080c>)
42015008:	5710c1        	l32r	a12, 41feac48 <_iram_bss_end+0x1c68848>
4201500b:	c602e2        	l8ui	a14, a2, 198
4201500e:	002b      	addi.n	a0, a0, 2
42015010:	c3ac      	beqz.n	a3, 42015040 <_svfiprintf_r+0x898>
42015012:	07a587        	bge	a5, a8, 4201501d <_svfiprintf_r+0x875>
42015015:	b0e5e0        	addx8	a14, a5, a14
42015018:	0e98      	l32i.n	a9, a14, 0
4201501a:	000706        	j	4201503a <_svfiprintf_r+0x892>
4201501d:	30a282        	movi	a8, 0x230
42015020:	8e8a      	add.n	a8, a14, a8
42015022:	34a2d2        	movi	a13, 0x234
42015025:	40a2c2        	movi	a12, 0x240
42015028:	0189      	s32i.n	a8, a1, 0
4201502a:	01def2        	addmi	a15, a14, 0x100
4201502d:	deda      	add.n	a13, a14, a13
4201502f:	ceca      	add.n	a12, a14, a12
42015031:	07bd      	mov.n	a11, a7
42015033:	05ad      	mov.n	a10, a5
42015035:	ff1965        	call8	420141cc <get_arg$isra$0>
42015038:	0a98      	l32i.n	a9, a10, 0
4201503a:	06ad      	mov.n	a10, a6
4201503c:	001cc6        	j	420150b3 <_svfiprintf_r+0x90b>
4201503f:	a61b00        	ee.ldf.64.xp	f1, f10, a0, a11
42015042:	07a687        	bge	a6, a8, 4201504d <_svfiprintf_r+0x8a5>
42015045:	b0e5e0        	addx8	a14, a5, a14
42015048:	0e98      	l32i.n	a9, a14, 0
4201504a:	001946        	j	420150b3 <_svfiprintf_r+0x90b>
4201504d:	922e92        	l32i	a9, a14, 0x248
42015050:	fc1c      	movi.n	a12, 31
42015052:	02dee2        	addmi	a14, a14, 0x200
42015055:	b94b      	addi.n	a11, a9, 4
42015057:	322c87        	blt	a12, a8, 4201508d <_svfiprintf_r+0x8e5>
4201505a:	c81b      	addi.n	a12, a8, 1
4201505c:	9161c2        	s32i	a12, a1, 0x244
4201505f:	126eb2        	s32i	a11, a14, 72
42015062:	8c1c      	movi.n	a12, 24
42015064:	052cb7        	blt	a12, a11, 4201506d <_svfiprintf_r+0x8c5>
42015067:	112e92        	l32i	a9, a14, 68
4201506a:	000406        	j	4201507e <_svfiprintf_r+0x8d6>
4201506d:	012c97        	blt	a12, a9, 42015072 <_svfiprintf_r+0x8ca>
42015070:	4b2c      	movi.n	a11, 36
42015072:	10c192        	addi	a9, a1, 16
42015075:	02d992        	addmi	a9, a9, 0x200
42015078:	102992        	l32i	a9, a9, 64
4201507b:	9661b2        	s32i	a11, a1, 0x258
4201507e:	99ba      	add.n	a9, a9, a11
42015080:	fcc992        	addi	a9, a9, -4
42015083:	0998      	l32i.n	a9, a9, 0
42015085:	b08810        	addx8	a8, a8, a1
42015088:	4899      	s32i.n	a9, a8, 16
4201508a:	000946        	j	420150b3 <_svfiprintf_r+0x90b>
4201508d:	126eb2        	s32i	a11, a14, 72
42015090:	881c      	movi.n	a8, 24
42015092:	0528b7        	blt	a8, a11, 4201509b <_svfiprintf_r+0x8f3>
42015095:	112e82        	l32i	a8, a14, 68
42015098:	000406        	j	420150ac <_svfiprintf_r+0x904>
4201509b:	012897        	blt	a8, a9, 420150a0 <_svfiprintf_r+0x8f8>
4201509e:	4b2c      	movi.n	a11, 36
420150a0:	10c182        	addi	a8, a1, 16
420150a3:	02d882        	addmi	a8, a8, 0x200
420150a6:	102882        	l32i	a8, a8, 64
420150a9:	9661b2        	s32i	a11, a1, 0x258
420150ac:	88ba      	add.n	a8, a8, a11
420150ae:	fcc882        	addi	a8, a8, -4
420150b1:	0898      	l32i.n	a9, a8, 0
420150b3:	9f2182        	l32i	a8, a1, 0x27c
420150b6:	0989      	s32i.n	a8, a9, 0
420150b8:	318f80        	srai	a8, a8, 31
420150bb:	1989      	s32i.n	a8, a9, 4
420150bd:	0086c6        	j	420152dc <_svfiprintf_r+0xb34>
420150c0:	046247        	bbci	a2, 4, 420150c8 <_svfiprintf_r+0x920>
420150c3:	005a86        	j	42015231 <_svfiprintf_r+0xa89>
420150c6:	670000        	ee.stf.64.xp	f0, f6, a0, a0
420150c9:	8602e2        	l8ui	a14, a2, 134
420150cc:	002b      	addi.n	a0, a0, 2
420150ce:	e3ac      	beqz.n	a3, 42015100 <_svfiprintf_r+0x958>
420150d0:	09a587        	bge	a5, a8, 420150dd <_svfiprintf_r+0x935>
420150d3:	b0e5e0        	addx8	a14, a5, a14
420150d6:	0e98      	l32i.n	a9, a14, 0
420150d8:	000786        	j	420150fa <_svfiprintf_r+0x952>
420150db:	820000        	mull	a0, a0, a0
420150de:	a2          	.byte	0xa2
420150df:	30          	.byte	0x30
420150e0:	8e8a      	add.n	a8, a14, a8
420150e2:	34a2d2        	movi	a13, 0x234
420150e5:	40a2c2        	movi	a12, 0x240
420150e8:	0189      	s32i.n	a8, a1, 0
420150ea:	01def2        	addmi	a15, a14, 0x100
420150ed:	deda      	add.n	a13, a14, a13
420150ef:	ceca      	add.n	a12, a14, a12
420150f1:	07bd      	mov.n	a11, a7
420150f3:	05ad      	mov.n	a10, a5
420150f5:	ff0d65        	call8	420141cc <get_arg$isra$0>
420150f8:	0a98      	l32i.n	a9, a10, 0
420150fa:	06ad      	mov.n	a10, a6
420150fc:	001d06        	j	42015174 <_svfiprintf_r+0x9cc>
420150ff:	a61b00        	ee.ldf.64.xp	f1, f10, a0, a11
42015102:	07a687        	bge	a6, a8, 4201510d <_svfiprintf_r+0x965>
42015105:	b0e5e0        	addx8	a14, a5, a14
42015108:	0e98      	l32i.n	a9, a14, 0
4201510a:	001986        	j	42015174 <_svfiprintf_r+0x9cc>
4201510d:	922e92        	l32i	a9, a14, 0x248
42015110:	fc1c      	movi.n	a12, 31
42015112:	02dee2        	addmi	a14, a14, 0x200
42015115:	b94b      	addi.n	a11, a9, 4
42015117:	322c87        	blt	a12, a8, 4201514d <_svfiprintf_r+0x9a5>
4201511a:	c81b      	addi.n	a12, a8, 1
4201511c:	9161c2        	s32i	a12, a1, 0x244
4201511f:	126eb2        	s32i	a11, a14, 72
42015122:	8c1c      	movi.n	a12, 24
42015124:	052cb7        	blt	a12, a11, 4201512d <_svfiprintf_r+0x985>
42015127:	112e92        	l32i	a9, a14, 68
4201512a:	000406        	j	4201513e <_svfiprintf_r+0x996>
4201512d:	012c97        	blt	a12, a9, 42015132 <_svfiprintf_r+0x98a>
42015130:	4b2c      	movi.n	a11, 36
42015132:	10c192        	addi	a9, a1, 16
42015135:	02d992        	addmi	a9, a9, 0x200
42015138:	102992        	l32i	a9, a9, 64
4201513b:	9661b2        	s32i	a11, a1, 0x258
4201513e:	99ba      	add.n	a9, a9, a11
42015140:	fcc992        	addi	a9, a9, -4
42015143:	0998      	l32i.n	a9, a9, 0
42015145:	b08810        	addx8	a8, a8, a1
42015148:	4899      	s32i.n	a9, a8, 16
4201514a:	000986        	j	42015174 <_svfiprintf_r+0x9cc>
4201514d:	126eb2        	s32i	a11, a14, 72
42015150:	881c      	movi.n	a8, 24
42015152:	0628b7        	blt	a8, a11, 4201515c <_svfiprintf_r+0x9b4>
42015155:	112e82        	l32i	a8, a14, 68
42015158:	000446        	j	4201516d <_svfiprintf_r+0x9c5>
4201515b:	00          	.byte	00
4201515c:	012897        	blt	a8, a9, 42015161 <_svfiprintf_r+0x9b9>
4201515f:	4b2c      	movi.n	a11, 36
42015161:	10c182        	addi	a8, a1, 16
42015164:	02d882        	addmi	a8, a8, 0x200
42015167:	102882        	l32i	a8, a8, 64
4201516a:	9661b2        	s32i	a11, a1, 0x258
4201516d:	88ba      	add.n	a8, a8, a11
4201516f:	fcc882        	addi	a8, a8, -4
42015172:	0898      	l32i.n	a9, a8, 0
42015174:	9f2182        	l32i	a8, a1, 0x27c
42015177:	005982        	s16i	a8, a9, 0
4201517a:	005786        	j	420152dc <_svfiprintf_r+0xb34>
4201517d:	02e297        	bbsi	a2, 9, 42015183 <_svfiprintf_r+0x9db>
42015180:	002b46        	j	42015231 <_svfiprintf_r+0xa89>
42015183:	c3ac      	beqz.n	a3, 420151b3 <_svfiprintf_r+0xa0b>
42015185:	08a587        	bge	a5, a8, 42015191 <_svfiprintf_r+0x9e9>
42015188:	b0e5e0        	addx8	a14, a5, a14
4201518b:	0e98      	l32i.n	a9, a14, 0
4201518d:	000746        	j	420151ae <_svfiprintf_r+0xa06>
42015190:	a28200        	muluh	a8, a2, a0
42015193:	30          	.byte	0x30
42015194:	8e8a      	add.n	a8, a14, a8
42015196:	34a2d2        	movi	a13, 0x234
42015199:	40a2c2        	movi	a12, 0x240
4201519c:	0189      	s32i.n	a8, a1, 0
4201519e:	01def2        	addmi	a15, a14, 0x100
420151a1:	deda      	add.n	a13, a14, a13
420151a3:	ceca      	add.n	a12, a14, a12
420151a5:	07bd      	mov.n	a11, a7
420151a7:	05ad      	mov.n	a10, a5
420151a9:	ff0225        	call8	420141cc <get_arg$isra$0>
420151ac:	0a98      	l32i.n	a9, a10, 0
420151ae:	06ad      	mov.n	a10, a6
420151b0:	001d06        	j	42015228 <_svfiprintf_r+0xa80>
420151b3:	a61b      	addi.n	a10, a6, 1
420151b5:	07a687        	bge	a6, a8, 420151c0 <_svfiprintf_r+0xa18>
420151b8:	b0e5e0        	addx8	a14, a5, a14
420151bb:	0e98      	l32i.n	a9, a14, 0
420151bd:	0019c6        	j	42015228 <_svfiprintf_r+0xa80>
420151c0:	922e92        	l32i	a9, a14, 0x248
420151c3:	fc1c      	movi.n	a12, 31
420151c5:	02dee2        	addmi	a14, a14, 0x200
420151c8:	b94b      	addi.n	a11, a9, 4
420151ca:	322c87        	blt	a12, a8, 42015200 <_svfiprintf_r+0xa58>
420151cd:	c81b      	addi.n	a12, a8, 1
420151cf:	9161c2        	s32i	a12, a1, 0x244
420151d2:	126eb2        	s32i	a11, a14, 72
420151d5:	8c1c      	movi.n	a12, 24
420151d7:	052cb7        	blt	a12, a11, 420151e0 <_svfiprintf_r+0xa38>
420151da:	112e92        	l32i	a9, a14, 68
420151dd:	000406        	j	420151f1 <_svfiprintf_r+0xa49>
420151e0:	012c97        	blt	a12, a9, 420151e5 <_svfiprintf_r+0xa3d>
420151e3:	4b2c      	movi.n	a11, 36
420151e5:	10c192        	addi	a9, a1, 16
420151e8:	02d992        	addmi	a9, a9, 0x200
420151eb:	102992        	l32i	a9, a9, 64
420151ee:	9661b2        	s32i	a11, a1, 0x258
420151f1:	99ba      	add.n	a9, a9, a11
420151f3:	fcc992        	addi	a9, a9, -4
420151f6:	0998      	l32i.n	a9, a9, 0
420151f8:	b08810        	addx8	a8, a8, a1
420151fb:	4899      	s32i.n	a9, a8, 16
420151fd:	0009c6        	j	42015228 <_svfiprintf_r+0xa80>
42015200:	126eb2        	s32i	a11, a14, 72
42015203:	881c      	movi.n	a8, 24
42015205:	0728b7        	blt	a8, a11, 42015210 <_svfiprintf_r+0xa68>
42015208:	112e82        	l32i	a8, a14, 68
4201520b:	000486        	j	42015221 <_svfiprintf_r+0xa79>
4201520e:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015211:	0128      	l32i.n	a2, a1, 0
42015213:	4b2c      	movi.n	a11, 36
42015215:	10c182        	addi	a8, a1, 16
42015218:	02d882        	addmi	a8, a8, 0x200
4201521b:	102882        	l32i	a8, a8, 64
4201521e:	9661b2        	s32i	a11, a1, 0x258
42015221:	88ba      	add.n	a8, a8, a11
42015223:	fcc882        	addi	a8, a8, -4
42015226:	0898      	l32i.n	a9, a8, 0
42015228:	9f2182        	l32i	a8, a1, 0x27c
4201522b:	004982        	s8i	a8, a9, 0
4201522e:	002a86        	j	420152dc <_svfiprintf_r+0xb34>
42015231:	f3ac      	beqz.n	a3, 42015264 <_svfiprintf_r+0xabc>
42015233:	0aa587        	bge	a5, a8, 42015241 <_svfiprintf_r+0xa99>
42015236:	b0e5e0        	addx8	a14, a5, a14
42015239:	0e98      	l32i.n	a9, a14, 0
4201523b:	0007c6        	j	4201525e <_svfiprintf_r+0xab6>
4201523e:	000000        	ill
42015241:	30a282        	movi	a8, 0x230
42015244:	8e8a      	add.n	a8, a14, a8
42015246:	34a2d2        	movi	a13, 0x234
42015249:	40a2c2        	movi	a12, 0x240
4201524c:	0189      	s32i.n	a8, a1, 0
4201524e:	01def2        	addmi	a15, a14, 0x100
42015251:	deda      	add.n	a13, a14, a13
42015253:	ceca      	add.n	a12, a14, a12
42015255:	07bd      	mov.n	a11, a7
42015257:	05ad      	mov.n	a10, a5
42015259:	fef725        	call8	420141cc <get_arg$isra$0>
4201525c:	0a98      	l32i.n	a9, a10, 0
4201525e:	06ad      	mov.n	a10, a6
42015260:	001cc6        	j	420152d7 <_svfiprintf_r+0xb2f>
42015263:	a61b00        	ee.ldf.64.xp	f1, f10, a0, a11
42015266:	07a687        	bge	a6, a8, 42015271 <_svfiprintf_r+0xac9>
42015269:	b0e5e0        	addx8	a14, a5, a14
4201526c:	0e98      	l32i.n	a9, a14, 0
4201526e:	001946        	j	420152d7 <_svfiprintf_r+0xb2f>
42015271:	922e92        	l32i	a9, a14, 0x248
42015274:	fc1c      	movi.n	a12, 31
42015276:	02dee2        	addmi	a14, a14, 0x200
42015279:	b94b      	addi.n	a11, a9, 4
4201527b:	322c87        	blt	a12, a8, 420152b1 <_svfiprintf_r+0xb09>
4201527e:	c81b      	addi.n	a12, a8, 1
42015280:	9161c2        	s32i	a12, a1, 0x244
42015283:	126eb2        	s32i	a11, a14, 72
42015286:	8c1c      	movi.n	a12, 24
42015288:	052cb7        	blt	a12, a11, 42015291 <_svfiprintf_r+0xae9>
4201528b:	112e92        	l32i	a9, a14, 68
4201528e:	000406        	j	420152a2 <_svfiprintf_r+0xafa>
42015291:	012c97        	blt	a12, a9, 42015296 <_svfiprintf_r+0xaee>
42015294:	4b2c      	movi.n	a11, 36
42015296:	10c192        	addi	a9, a1, 16
42015299:	02d992        	addmi	a9, a9, 0x200
4201529c:	102992        	l32i	a9, a9, 64
4201529f:	9661b2        	s32i	a11, a1, 0x258
420152a2:	99ba      	add.n	a9, a9, a11
420152a4:	fcc992        	addi	a9, a9, -4
420152a7:	0998      	l32i.n	a9, a9, 0
420152a9:	b08810        	addx8	a8, a8, a1
420152ac:	4899      	s32i.n	a9, a8, 16
420152ae:	000946        	j	420152d7 <_svfiprintf_r+0xb2f>
420152b1:	126eb2        	s32i	a11, a14, 72
420152b4:	881c      	movi.n	a8, 24
420152b6:	0528b7        	blt	a8, a11, 420152bf <_svfiprintf_r+0xb17>
420152b9:	112e82        	l32i	a8, a14, 68
420152bc:	000406        	j	420152d0 <_svfiprintf_r+0xb28>
420152bf:	012897        	blt	a8, a9, 420152c4 <_svfiprintf_r+0xb1c>
420152c2:	4b2c      	movi.n	a11, 36
420152c4:	10c182        	addi	a8, a1, 16
420152c7:	02d882        	addmi	a8, a8, 0x200
420152ca:	102882        	l32i	a8, a8, 64
420152cd:	9661b2        	s32i	a11, a1, 0x258
420152d0:	88ba      	add.n	a8, a8, a11
420152d2:	fcc882        	addi	a8, a8, -4
420152d5:	0898      	l32i.n	a9, a8, 0
420152d7:	9f2182        	l32i	a8, a1, 0x27c
420152da:	0989      	s32i.n	a8, a9, 0
420152dc:	0a6d      	mov.n	a6, a10
420152de:	fd5286        	j	4201482c <_svfiprintf_r+0x84>
420152e1:	081c      	movi.n	a8, 16
420152e3:	202280        	or	a2, a2, a8
420152e6:	912182        	l32i	a8, a1, 0x244
420152e9:	10c1e2        	addi	a14, a1, 16
420152ec:	02e257        	bbsi	a2, 5, 420152f2 <_svfiprintf_r+0xb4a>
420152ef:	002f86        	j	420153b1 <_svfiprintf_r+0xc09>
420152f2:	f3ac      	beqz.n	a3, 42015325 <_svfiprintf_r+0xb7d>
420152f4:	09a587        	bge	a5, a8, 42015301 <_svfiprintf_r+0xb59>
420152f7:	b0e5e0        	addx8	a14, a5, a14
420152fa:	0e58      	l32i.n	a5, a14, 0
420152fc:	1e38      	l32i.n	a3, a14, 4
420152fe:	000786        	j	42015320 <_svfiprintf_r+0xb78>
42015301:	30a282        	movi	a8, 0x230
42015304:	8e8a      	add.n	a8, a14, a8
42015306:	34a2d2        	movi	a13, 0x234
42015309:	40a2c2        	movi	a12, 0x240
4201530c:	05ad      	mov.n	a10, a5
4201530e:	0189      	s32i.n	a8, a1, 0
42015310:	01def2        	addmi	a15, a14, 0x100
42015313:	deda      	add.n	a13, a14, a13
42015315:	ceca      	add.n	a12, a14, a12
42015317:	07bd      	mov.n	a11, a7
42015319:	feeb25        	call8	420141cc <get_arg$isra$0>
4201531c:	0a58      	l32i.n	a5, a10, 0
4201531e:	1a38      	l32i.n	a3, a10, 4
42015320:	067d      	mov.n	a7, a6
42015322:	00a806        	j	420155c6 <_svfiprintf_r+0xe1e>
42015325:	761b      	addi.n	a7, a6, 1
42015327:	09a687        	bge	a6, a8, 42015334 <_svfiprintf_r+0xb8c>
4201532a:	b0e5e0        	addx8	a14, a5, a14
4201532d:	0e58      	l32i.n	a5, a14, 0
4201532f:	1e38      	l32i.n	a3, a14, 4
42015331:	00a446        	j	420155c6 <_svfiprintf_r+0xe1e>
42015334:	922e92        	l32i	a9, a14, 0x248
42015337:	8a7c      	movi.n	a10, -8
42015339:	997b      	addi.n	a9, a9, 7
4201533b:	1099a0        	and	a9, a9, a10
4201533e:	fb1c      	movi.n	a11, 31
42015340:	02dee2        	addmi	a14, a14, 0x200
42015343:	a98b      	addi.n	a10, a9, 8
42015345:	3b2b87        	blt	a11, a8, 42015384 <_svfiprintf_r+0xbdc>
42015348:	b81b      	addi.n	a11, a8, 1
4201534a:	9161b2        	s32i	a11, a1, 0x244
4201534d:	126ea2        	s32i	a10, a14, 72
42015350:	8b1c      	movi.n	a11, 24
42015352:	062ba7        	blt	a11, a10, 4201535c <_svfiprintf_r+0xbb4>
42015355:	112e92        	l32i	a9, a14, 68
42015358:	000446        	j	4201536d <_svfiprintf_r+0xbc5>
4201535b:	2b9700        	oeq.s	b9, f7, f0
4201535e:	8a2c01        	l32r	a0, 41ff7c10 <_iram_bss_end+0x1c75810>
42015361:	10c192        	addi	a9, a1, 16
42015364:	02d992        	addmi	a9, a9, 0x200
42015367:	102992        	l32i	a9, a9, 64
4201536a:	9661a2        	s32i	a10, a1, 0x258
4201536d:	99aa      	add.n	a9, a9, a10
4201536f:	f8c992        	addi	a9, a9, -8
42015372:	0958      	l32i.n	a5, a9, 0
42015374:	1938      	l32i.n	a3, a9, 4
42015376:	10c192        	addi	a9, a1, 16
42015379:	b08890        	addx8	a8, a8, a9
4201537c:	0859      	s32i.n	a5, a8, 0
4201537e:	1839      	s32i.n	a3, a8, 4
42015380:	009086        	j	420155c6 <_svfiprintf_r+0xe1e>
42015383:	00          	.byte	00
42015384:	126ea2        	s32i	a10, a14, 72
42015387:	881c      	movi.n	a8, 24
42015389:	0728a7        	blt	a8, a10, 42015394 <_svfiprintf_r+0xbec>
4201538c:	112e82        	l32i	a8, a14, 68
4201538f:	000486        	j	420153a5 <_svfiprintf_r+0xbfd>
42015392:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015395:	0128      	l32i.n	a2, a1, 0
42015397:	8a2c      	movi.n	a10, 40
42015399:	10c182        	addi	a8, a1, 16
4201539c:	02d882        	addmi	a8, a8, 0x200
4201539f:	102882        	l32i	a8, a8, 64
420153a2:	9661a2        	s32i	a10, a1, 0x258
420153a5:	88aa      	add.n	a8, a8, a10
420153a7:	f8c882        	addi	a8, a8, -8
420153aa:	0858      	l32i.n	a5, a8, 0
420153ac:	1838      	l32i.n	a3, a8, 4
420153ae:	008506        	j	420155c6 <_svfiprintf_r+0xe1e>
420153b1:	036247        	bbci	a2, 4, 420153b8 <_svfiprintf_r+0xc10>
420153b4:	005a06        	j	42015520 <_svfiprintf_r+0xd78>
420153b7:	e26700        	remu	a6, a7, a0
420153ba:	2b4602        	s8i	a0, a6, 43
420153bd:	c3ac00        	movf	a10, a12, b0
420153c0:	09a587        	bge	a5, a8, 420153cd <_svfiprintf_r+0xc25>
420153c3:	b0e5e0        	addx8	a14, a5, a14
420153c6:	001e52        	l16ui	a5, a14, 0
420153c9:	005f46        	j	4201554a <_svfiprintf_r+0xda2>
420153cc:	a28200        	muluh	a8, a2, a0
420153cf:	30          	.byte	0x30
420153d0:	8e8a      	add.n	a8, a14, a8
420153d2:	34a2d2        	movi	a13, 0x234
420153d5:	40a2c2        	movi	a12, 0x240
420153d8:	05ad      	mov.n	a10, a5
420153da:	0189      	s32i.n	a8, a1, 0
420153dc:	01def2        	addmi	a15, a14, 0x100
420153df:	deda      	add.n	a13, a14, a13
420153e1:	ceca      	add.n	a12, a14, a12
420153e3:	07bd      	mov.n	a11, a7
420153e5:	fede65        	call8	420141cc <get_arg$isra$0>
420153e8:	001a52        	l16ui	a5, a10, 0
420153eb:	0056c6        	j	4201554a <_svfiprintf_r+0xda2>
420153ee:	761b      	addi.n	a7, a6, 1
420153f0:	08a687        	bge	a6, a8, 420153fc <_svfiprintf_r+0xc54>
420153f3:	b0e5e0        	addx8	a14, a5, a14
420153f6:	001e52        	l16ui	a5, a14, 0
420153f9:	0071c6        	j	420155c4 <_svfiprintf_r+0xe1c>
420153fc:	922e92        	l32i	a9, a14, 0x248
420153ff:	fb1c      	movi.n	a11, 31
42015401:	02dee2        	addmi	a14, a14, 0x200
42015404:	a94b      	addi.n	a10, a9, 4
42015406:	362b87        	blt	a11, a8, 42015440 <_svfiprintf_r+0xc98>
42015409:	b81b      	addi.n	a11, a8, 1
4201540b:	9161b2        	s32i	a11, a1, 0x244
4201540e:	126ea2        	s32i	a10, a14, 72
42015411:	8b1c      	movi.n	a11, 24
42015413:	052ba7        	blt	a11, a10, 4201541c <_svfiprintf_r+0xc74>
42015416:	112e92        	l32i	a9, a14, 68
42015419:	000406        	j	4201542d <_svfiprintf_r+0xc85>
4201541c:	012b97        	blt	a11, a9, 42015421 <_svfiprintf_r+0xc79>
4201541f:	4a2c      	movi.n	a10, 36
42015421:	10c192        	addi	a9, a1, 16
42015424:	02d992        	addmi	a9, a9, 0x200
42015427:	102992        	l32i	a9, a9, 64
4201542a:	9661a2        	s32i	a10, a1, 0x258
4201542d:	99aa      	add.n	a9, a9, a10
4201542f:	fcc992        	addi	a9, a9, -4
42015432:	0958      	l32i.n	a5, a9, 0
42015434:	b08810        	addx8	a8, a8, a1
42015437:	4859      	s32i.n	a5, a8, 16
42015439:	f45050        	extui	a5, a5, 0, 16
4201543c:	006106        	j	420155c4 <_svfiprintf_r+0xe1c>
4201543f:	00          	.byte	00
42015440:	126ea2        	s32i	a10, a14, 72
42015443:	881c      	movi.n	a8, 24
42015445:	0728a7        	blt	a8, a10, 42015450 <_svfiprintf_r+0xca8>
42015448:	112e82        	l32i	a8, a14, 68
4201544b:	000486        	j	42015461 <_svfiprintf_r+0xcb9>
4201544e:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015451:	0128      	l32i.n	a2, a1, 0
42015453:	4a2c      	movi.n	a10, 36
42015455:	10c182        	addi	a8, a1, 16
42015458:	02d882        	addmi	a8, a8, 0x200
4201545b:	102882        	l32i	a8, a8, 64
4201545e:	9661a2        	s32i	a10, a1, 0x258
42015461:	88aa      	add.n	a8, a8, a10
42015463:	fcc882        	addi	a8, a8, -4
42015466:	001852        	l16ui	a5, a8, 0
42015469:	0055c6        	j	420155c4 <_svfiprintf_r+0xe1c>
4201546c:	02e297        	bbsi	a2, 9, 42015472 <_svfiprintf_r+0xcca>
4201546f:	002b46        	j	42015520 <_svfiprintf_r+0xd78>
42015472:	c3ac      	beqz.n	a3, 420154a2 <_svfiprintf_r+0xcfa>
42015474:	09a587        	bge	a5, a8, 42015481 <_svfiprintf_r+0xcd9>
42015477:	b0e5e0        	addx8	a14, a5, a14
4201547a:	000e52        	l8ui	a5, a14, 0
4201547d:	003246        	j	4201554a <_svfiprintf_r+0xda2>
42015480:	a28200        	muluh	a8, a2, a0
42015483:	30          	.byte	0x30
42015484:	8e8a      	add.n	a8, a14, a8
42015486:	34a2d2        	movi	a13, 0x234
42015489:	40a2c2        	movi	a12, 0x240
4201548c:	05ad      	mov.n	a10, a5
4201548e:	0189      	s32i.n	a8, a1, 0
42015490:	01def2        	addmi	a15, a14, 0x100
42015493:	deda      	add.n	a13, a14, a13
42015495:	ceca      	add.n	a12, a14, a12
42015497:	07bd      	mov.n	a11, a7
42015499:	fed325        	call8	420141cc <get_arg$isra$0>
4201549c:	000a52        	l8ui	a5, a10, 0
4201549f:	0029c6        	j	4201554a <_svfiprintf_r+0xda2>
420154a2:	761b      	addi.n	a7, a6, 1
420154a4:	08a687        	bge	a6, a8, 420154b0 <_svfiprintf_r+0xd08>
420154a7:	b0e5e0        	addx8	a14, a5, a14
420154aa:	000e52        	l8ui	a5, a14, 0
420154ad:	0044c6        	j	420155c4 <_svfiprintf_r+0xe1c>
420154b0:	922e92        	l32i	a9, a14, 0x248
420154b3:	fb1c      	movi.n	a11, 31
420154b5:	02dee2        	addmi	a14, a14, 0x200
420154b8:	a94b      	addi.n	a10, a9, 4
420154ba:	362b87        	blt	a11, a8, 420154f4 <_svfiprintf_r+0xd4c>
420154bd:	b81b      	addi.n	a11, a8, 1
420154bf:	9161b2        	s32i	a11, a1, 0x244
420154c2:	126ea2        	s32i	a10, a14, 72
420154c5:	8b1c      	movi.n	a11, 24
420154c7:	052ba7        	blt	a11, a10, 420154d0 <_svfiprintf_r+0xd28>
420154ca:	112e92        	l32i	a9, a14, 68
420154cd:	000406        	j	420154e1 <_svfiprintf_r+0xd39>
420154d0:	012b97        	blt	a11, a9, 420154d5 <_svfiprintf_r+0xd2d>
420154d3:	4a2c      	movi.n	a10, 36
420154d5:	10c192        	addi	a9, a1, 16
420154d8:	02d992        	addmi	a9, a9, 0x200
420154db:	102992        	l32i	a9, a9, 64
420154de:	9661a2        	s32i	a10, a1, 0x258
420154e1:	99aa      	add.n	a9, a9, a10
420154e3:	fcc992        	addi	a9, a9, -4
420154e6:	0958      	l32i.n	a5, a9, 0
420154e8:	b08810        	addx8	a8, a8, a1
420154eb:	4859      	s32i.n	a5, a8, 16
420154ed:	745050        	extui	a5, a5, 0, 8
420154f0:	003406        	j	420155c4 <_svfiprintf_r+0xe1c>
420154f3:	00          	.byte	00
420154f4:	126ea2        	s32i	a10, a14, 72
420154f7:	881c      	movi.n	a8, 24
420154f9:	0528a7        	blt	a8, a10, 42015502 <_svfiprintf_r+0xd5a>
420154fc:	112e82        	l32i	a8, a14, 68
420154ff:	000446        	j	42015514 <_svfiprintf_r+0xd6c>
42015502:	022897        	blt	a8, a9, 42015508 <_svfiprintf_r+0xd60>
42015505:	24a0a2        	movi	a10, 36
42015508:	10c182        	addi	a8, a1, 16
4201550b:	02d882        	addmi	a8, a8, 0x200
4201550e:	102882        	l32i	a8, a8, 64
42015511:	9661a2        	s32i	a10, a1, 0x258
42015514:	88aa      	add.n	a8, a8, a10
42015516:	fcc882        	addi	a8, a8, -4
42015519:	000852        	l8ui	a5, a8, 0
4201551c:	002906        	j	420155c4 <_svfiprintf_r+0xe1c>
4201551f:	c3ac00        	movf	a10, a12, b0
42015522:	07a587        	bge	a5, a8, 4201552d <_svfiprintf_r+0xd85>
42015525:	b0e5e0        	addx8	a14, a5, a14
42015528:	0e58      	l32i.n	a5, a14, 0
4201552a:	000706        	j	4201554a <_svfiprintf_r+0xda2>
4201552d:	30a282        	movi	a8, 0x230
42015530:	8e8a      	add.n	a8, a14, a8
42015532:	34a2d2        	movi	a13, 0x234
42015535:	40a2c2        	movi	a12, 0x240
42015538:	05ad      	mov.n	a10, a5
4201553a:	0189      	s32i.n	a8, a1, 0
4201553c:	01def2        	addmi	a15, a14, 0x100
4201553f:	deda      	add.n	a13, a14, a13
42015541:	ceca      	add.n	a12, a14, a12
42015543:	07bd      	mov.n	a11, a7
42015545:	fec865        	call8	420141cc <get_arg$isra$0>
42015548:	0a58      	l32i.n	a5, a10, 0
4201554a:	067d      	mov.n	a7, a6
4201554c:	001d06        	j	420155c4 <_svfiprintf_r+0xe1c>
4201554f:	761b00        	ee.ldf.64.xp	f1, f7, a0, a11
42015552:	07a687        	bge	a6, a8, 4201555d <_svfiprintf_r+0xdb5>
42015555:	b0e5e0        	addx8	a14, a5, a14
42015558:	0e58      	l32i.n	a5, a14, 0
4201555a:	001986        	j	420155c4 <_svfiprintf_r+0xe1c>
4201555d:	922e92        	l32i	a9, a14, 0x248
42015560:	fb1c      	movi.n	a11, 31
42015562:	02dee2        	addmi	a14, a14, 0x200
42015565:	a94b      	addi.n	a10, a9, 4
42015567:	322b87        	blt	a11, a8, 4201559d <_svfiprintf_r+0xdf5>
4201556a:	b81b      	addi.n	a11, a8, 1
4201556c:	9161b2        	s32i	a11, a1, 0x244
4201556f:	126ea2        	s32i	a10, a14, 72
42015572:	8b1c      	movi.n	a11, 24
42015574:	052ba7        	blt	a11, a10, 4201557d <_svfiprintf_r+0xdd5>
42015577:	112e92        	l32i	a9, a14, 68
4201557a:	000406        	j	4201558e <_svfiprintf_r+0xde6>
4201557d:	012b97        	blt	a11, a9, 42015582 <_svfiprintf_r+0xdda>
42015580:	4a2c      	movi.n	a10, 36
42015582:	10c192        	addi	a9, a1, 16
42015585:	02d992        	addmi	a9, a9, 0x200
42015588:	102992        	l32i	a9, a9, 64
4201558b:	9661a2        	s32i	a10, a1, 0x258
4201558e:	99aa      	add.n	a9, a9, a10
42015590:	fcc992        	addi	a9, a9, -4
42015593:	0958      	l32i.n	a5, a9, 0
42015595:	b08810        	addx8	a8, a8, a1
42015598:	4859      	s32i.n	a5, a8, 16
4201559a:	000986        	j	420155c4 <_svfiprintf_r+0xe1c>
4201559d:	126ea2        	s32i	a10, a14, 72
420155a0:	881c      	movi.n	a8, 24
420155a2:	0628a7        	blt	a8, a10, 420155ac <_svfiprintf_r+0xe04>
420155a5:	112e82        	l32i	a8, a14, 68
420155a8:	000446        	j	420155bd <_svfiprintf_r+0xe15>
420155ab:	00          	.byte	00
420155ac:	012897        	blt	a8, a9, 420155b1 <_svfiprintf_r+0xe09>
420155af:	4a2c      	movi.n	a10, 36
420155b1:	10c182        	addi	a8, a1, 16
420155b4:	02d882        	addmi	a8, a8, 0x200
420155b7:	102882        	l32i	a8, a8, 64
420155ba:	9661a2        	s32i	a10, a1, 0x258
420155bd:	88aa      	add.n	a8, a8, a10
420155bf:	fcc882        	addi	a8, a8, -4
420155c2:	0858      	l32i.n	a5, a8, 0
420155c4:	030c      	movi.n	a3, 0
420155c6:	ffab82        	movi	a8, 0xfffffbff
420155c9:	102280        	and	a2, a2, a8
420155cc:	090c      	movi.n	a9, 0
420155ce:	01ebc6        	j	42015d81 <_svfiprintf_r+0x15d9>
420155d1:	218200        	srai	a8, a0, 2
420155d4:	c1e291        	l32r	a9, 42005d5c <esp_clk_tree_rc_fast_d256_get_freq_hz+0x3c> (8e0e9 <UserFrameTotalSize+0x8dfe9>)
420155d7:	c3ac10        	movf	a10, a12, b1
420155da:	07a587        	bge	a5, a8, 420155e5 <_svfiprintf_r+0xe3d>
420155dd:	b0e5e0        	addx8	a14, a5, a14
420155e0:	0e58      	l32i.n	a5, a14, 0
420155e2:	000706        	j	42015602 <_svfiprintf_r+0xe5a>
420155e5:	30a282        	movi	a8, 0x230
420155e8:	8e8a      	add.n	a8, a14, a8
420155ea:	34a2d2        	movi	a13, 0x234
420155ed:	40a2c2        	movi	a12, 0x240
420155f0:	05ad      	mov.n	a10, a5
420155f2:	0189      	s32i.n	a8, a1, 0
420155f4:	01def2        	addmi	a15, a14, 0x100
420155f7:	deda      	add.n	a13, a14, a13
420155f9:	ceca      	add.n	a12, a14, a12
420155fb:	07bd      	mov.n	a11, a7
420155fd:	febce5        	call8	420141cc <get_arg$isra$0>
42015600:	0a58      	l32i.n	a5, a10, 0
42015602:	067d      	mov.n	a7, a6
42015604:	001d06        	j	4201567c <_svfiprintf_r+0xed4>
42015607:	761b00        	ee.ldf.64.xp	f1, f7, a0, a11
4201560a:	07a687        	bge	a6, a8, 42015615 <_svfiprintf_r+0xe6d>
4201560d:	b0e5e0        	addx8	a14, a5, a14
42015610:	0e58      	l32i.n	a5, a14, 0
42015612:	001986        	j	4201567c <_svfiprintf_r+0xed4>
42015615:	922e92        	l32i	a9, a14, 0x248
42015618:	fb1c      	movi.n	a11, 31
4201561a:	02dee2        	addmi	a14, a14, 0x200
4201561d:	a94b      	addi.n	a10, a9, 4
4201561f:	322b87        	blt	a11, a8, 42015655 <_svfiprintf_r+0xead>
42015622:	b81b      	addi.n	a11, a8, 1
42015624:	9161b2        	s32i	a11, a1, 0x244
42015627:	126ea2        	s32i	a10, a14, 72
4201562a:	8b1c      	movi.n	a11, 24
4201562c:	052ba7        	blt	a11, a10, 42015635 <_svfiprintf_r+0xe8d>
4201562f:	112e92        	l32i	a9, a14, 68
42015632:	000406        	j	42015646 <_svfiprintf_r+0xe9e>
42015635:	012b97        	blt	a11, a9, 4201563a <_svfiprintf_r+0xe92>
42015638:	4a2c      	movi.n	a10, 36
4201563a:	10c192        	addi	a9, a1, 16
4201563d:	02d992        	addmi	a9, a9, 0x200
42015640:	102992        	l32i	a9, a9, 64
42015643:	9661a2        	s32i	a10, a1, 0x258
42015646:	99aa      	add.n	a9, a9, a10
42015648:	fcc992        	addi	a9, a9, -4
4201564b:	0958      	l32i.n	a5, a9, 0
4201564d:	b08810        	addx8	a8, a8, a1
42015650:	4859      	s32i.n	a5, a8, 16
42015652:	000986        	j	4201567c <_svfiprintf_r+0xed4>
42015655:	126ea2        	s32i	a10, a14, 72
42015658:	881c      	movi.n	a8, 24
4201565a:	0628a7        	blt	a8, a10, 42015664 <_svfiprintf_r+0xebc>
4201565d:	112e82        	l32i	a8, a14, 68
42015660:	000446        	j	42015675 <_svfiprintf_r+0xecd>
42015663:	00          	.byte	00
42015664:	012897        	blt	a8, a9, 42015669 <_svfiprintf_r+0xec1>
42015667:	4a2c      	movi.n	a10, 36
42015669:	10c182        	addi	a8, a1, 16
4201566c:	02d882        	addmi	a8, a8, 0x200
4201566f:	102882        	l32i	a8, a8, 64
42015672:	9661a2        	s32i	a10, a1, 0x258
42015675:	88aa      	add.n	a8, a8, a10
42015677:	fcc882        	addi	a8, a8, -4
4201567a:	0858      	l32i.n	a5, a8, 0
4201567c:	280c      	movi.n	a8, 2
4201567e:	202280        	or	a2, a2, a8
42015681:	10c182        	addi	a8, a1, 16
42015684:	02d882        	addmi	a8, a8, 0x200
42015687:	093c      	movi.n	a9, 48
42015689:	384892        	s8i	a9, a8, 56
4201568c:	78a092        	movi	a9, 120
4201568f:	394892        	s8i	a9, a8, 57
42015692:	ae4581        	l32r	a8, 42000fa8 <_stext+0xf88> (3c0286f4 <blanks$1+0x20>)
42015695:	030c      	movi.n	a3, 0
42015697:	a26182        	s32i	a8, a1, 0x288
4201569a:	01b846        	j	42015d7f <_svfiprintf_r+0x15d7>
4201569d:	219200        	srai	a9, a0, 2
420156a0:	c1e291        	l32r	a9, 42005e28 <esp_clk_tree_rc_fast_get_freq_hz+0xc> (146112a <UserFrameTotalSize+0x146102a>)
420156a3:	c3ac10        	movf	a10, a12, b1
420156a6:	07a597        	bge	a5, a9, 420156b1 <_svfiprintf_r+0xf09>
420156a9:	b0e5e0        	addx8	a14, a5, a14
420156ac:	0e48      	l32i.n	a4, a14, 0
420156ae:	000706        	j	420156ce <_svfiprintf_r+0xf26>
420156b1:	30a282        	movi	a8, 0x230
420156b4:	8e8a      	add.n	a8, a14, a8
420156b6:	34a2d2        	movi	a13, 0x234
420156b9:	40a2c2        	movi	a12, 0x240
420156bc:	0189      	s32i.n	a8, a1, 0
420156be:	01def2        	addmi	a15, a14, 0x100
420156c1:	deda      	add.n	a13, a14, a13
420156c3:	ceca      	add.n	a12, a14, a12
420156c5:	07bd      	mov.n	a11, a7
420156c7:	05ad      	mov.n	a10, a5
420156c9:	feb025        	call8	420141cc <get_arg$isra$0>
420156cc:	0a48      	l32i.n	a4, a10, 0
420156ce:	067d      	mov.n	a7, a6
420156d0:	001d06        	j	42015748 <_svfiprintf_r+0xfa0>
420156d3:	761b00        	ee.ldf.64.xp	f1, f7, a0, a11
420156d6:	07a697        	bge	a6, a9, 420156e1 <_svfiprintf_r+0xf39>
420156d9:	b0e5e0        	addx8	a14, a5, a14
420156dc:	0e48      	l32i.n	a4, a14, 0
420156de:	001986        	j	42015748 <_svfiprintf_r+0xfa0>
420156e1:	922e82        	l32i	a8, a14, 0x248
420156e4:	fb1c      	movi.n	a11, 31
420156e6:	02dee2        	addmi	a14, a14, 0x200
420156e9:	a84b      	addi.n	a10, a8, 4
420156eb:	322b97        	blt	a11, a9, 42015721 <_svfiprintf_r+0xf79>
420156ee:	b91b      	addi.n	a11, a9, 1
420156f0:	9161b2        	s32i	a11, a1, 0x244
420156f3:	126ea2        	s32i	a10, a14, 72
420156f6:	8b1c      	movi.n	a11, 24
420156f8:	052ba7        	blt	a11, a10, 42015701 <_svfiprintf_r+0xf59>
420156fb:	112e82        	l32i	a8, a14, 68
420156fe:	000406        	j	42015712 <_svfiprintf_r+0xf6a>
42015701:	012b87        	blt	a11, a8, 42015706 <_svfiprintf_r+0xf5e>
42015704:	4a2c      	movi.n	a10, 36
42015706:	10c182        	addi	a8, a1, 16
42015709:	02d882        	addmi	a8, a8, 0x200
4201570c:	102882        	l32i	a8, a8, 64
4201570f:	9661a2        	s32i	a10, a1, 0x258
42015712:	88aa      	add.n	a8, a8, a10
42015714:	fcc882        	addi	a8, a8, -4
42015717:	0848      	l32i.n	a4, a8, 0
42015719:	b09910        	addx8	a9, a9, a1
4201571c:	4949      	s32i.n	a4, a9, 16
4201571e:	000986        	j	42015748 <_svfiprintf_r+0xfa0>
42015721:	126ea2        	s32i	a10, a14, 72
42015724:	891c      	movi.n	a9, 24
42015726:	0629a7        	blt	a9, a10, 42015730 <_svfiprintf_r+0xf88>
42015729:	112e82        	l32i	a8, a14, 68
4201572c:	000446        	j	42015741 <_svfiprintf_r+0xf99>
4201572f:	00          	.byte	00
42015730:	012987        	blt	a9, a8, 42015735 <_svfiprintf_r+0xf8d>
42015733:	4a2c      	movi.n	a10, 36
42015735:	10c182        	addi	a8, a1, 16
42015738:	02d882        	addmi	a8, a8, 0x200
4201573b:	102882        	l32i	a8, a8, 64
4201573e:	9661a2        	s32i	a10, a1, 0x258
42015741:	88aa      	add.n	a8, a8, a10
42015743:	fcc882        	addi	a8, a8, -4
42015746:	0848      	l32i.n	a4, a8, 0
42015748:	10c192        	addi	a9, a1, 16
4201574b:	02d992        	addmi	a9, a9, 0x200
4201574e:	0a0c      	movi.n	a10, 0
42015750:	9b2182        	l32i	a8, a1, 0x26c
42015753:	3a49a2        	s8i	a10, a9, 58
42015756:	016896        	bltz	a8, 42015770 <_svfiprintf_r+0xfc8>
42015759:	08cd      	mov.n	a12, a8
4201575b:	0b0c      	movi.n	a11, 0
4201575d:	04ad      	mov.n	a10, a4
4201575f:	adc481        	l32r	a8, 42000e70 <_stext+0xe50> (40001344 <memchr>)
42015762:	0008e0        	callx8	a8
42015765:	060c      	movi.n	a6, 0
42015767:	c08a40        	sub	a8, a10, a4
4201576a:	7a7a56        	bnez	a10, 42015f15 <_svfiprintf_r+0x176d>
4201576d:	01f346        	j	42015f3e <_svfiprintf_r+0x1796>
42015770:	04ad      	mov.n	a10, a4
42015772:	aadc81        	l32r	a8, 420002e4 <_stext+0x2c4> (40001248 <strlen>)
42015775:	0008e0        	callx8	a8
42015778:	9b61a2        	s32i	a10, a1, 0x26c
4201577b:	060c      	movi.n	a6, 0
4201577d:	01ef46        	j	42015f3e <_svfiprintf_r+0x1796>
42015780:	081c00        	lsx	f1, a12, a0
42015783:	202280        	or	a2, a2, a8
42015786:	912182        	l32i	a8, a1, 0x244
42015789:	10c1e2        	addi	a14, a1, 16
4201578c:	02e257        	bbsi	a2, 5, 42015792 <_svfiprintf_r+0xfea>
4201578f:	002f86        	j	42015851 <_svfiprintf_r+0x10a9>
42015792:	f3ac      	beqz.n	a3, 420157c5 <_svfiprintf_r+0x101d>
42015794:	09a587        	bge	a5, a8, 420157a1 <_svfiprintf_r+0xff9>
42015797:	b0e5e0        	addx8	a14, a5, a14
4201579a:	0e58      	l32i.n	a5, a14, 0
4201579c:	1e38      	l32i.n	a3, a14, 4
4201579e:	000786        	j	420157c0 <_svfiprintf_r+0x1018>
420157a1:	30a282        	movi	a8, 0x230
420157a4:	8e8a      	add.n	a8, a14, a8
420157a6:	34a2d2        	movi	a13, 0x234
420157a9:	40a2c2        	movi	a12, 0x240
420157ac:	05ad      	mov.n	a10, a5
420157ae:	0189      	s32i.n	a8, a1, 0
420157b0:	01def2        	addmi	a15, a14, 0x100
420157b3:	deda      	add.n	a13, a14, a13
420157b5:	ceca      	add.n	a12, a14, a12
420157b7:	07bd      	mov.n	a11, a7
420157b9:	fea125        	call8	420141cc <get_arg$isra$0>
420157bc:	0a58      	l32i.n	a5, a10, 0
420157be:	1a38      	l32i.n	a3, a10, 4
420157c0:	067d      	mov.n	a7, a6
420157c2:	007e06        	j	420159be <_svfiprintf_r+0x1216>
420157c5:	761b      	addi.n	a7, a6, 1
420157c7:	09a687        	bge	a6, a8, 420157d4 <_svfiprintf_r+0x102c>
420157ca:	b0e5e0        	addx8	a14, a5, a14
420157cd:	0e58      	l32i.n	a5, a14, 0
420157cf:	1e38      	l32i.n	a3, a14, 4
420157d1:	007a46        	j	420159be <_svfiprintf_r+0x1216>
420157d4:	922e92        	l32i	a9, a14, 0x248
420157d7:	8a7c      	movi.n	a10, -8
420157d9:	997b      	addi.n	a9, a9, 7
420157db:	1099a0        	and	a9, a9, a10
420157de:	fb1c      	movi.n	a11, 31
420157e0:	02dee2        	addmi	a14, a14, 0x200
420157e3:	a98b      	addi.n	a10, a9, 8
420157e5:	3b2b87        	blt	a11, a8, 42015824 <_svfiprintf_r+0x107c>
420157e8:	b81b      	addi.n	a11, a8, 1
420157ea:	9161b2        	s32i	a11, a1, 0x244
420157ed:	126ea2        	s32i	a10, a14, 72
420157f0:	8b1c      	movi.n	a11, 24
420157f2:	062ba7        	blt	a11, a10, 420157fc <_svfiprintf_r+0x1054>
420157f5:	112e92        	l32i	a9, a14, 68
420157f8:	000446        	j	4201580d <_svfiprintf_r+0x1065>
420157fb:	2b9700        	oeq.s	b9, f7, f0
420157fe:	8a2c01        	l32r	a0, 41ff80b0 <_iram_bss_end+0x1c75cb0>
42015801:	10c192        	addi	a9, a1, 16
42015804:	02d992        	addmi	a9, a9, 0x200
42015807:	102992        	l32i	a9, a9, 64
4201580a:	9661a2        	s32i	a10, a1, 0x258
4201580d:	99aa      	add.n	a9, a9, a10
4201580f:	f8c992        	addi	a9, a9, -8
42015812:	0958      	l32i.n	a5, a9, 0
42015814:	1938      	l32i.n	a3, a9, 4
42015816:	10c192        	addi	a9, a1, 16
42015819:	b08890        	addx8	a8, a8, a9
4201581c:	0859      	s32i.n	a5, a8, 0
4201581e:	1839      	s32i.n	a3, a8, 4
42015820:	006686        	j	420159be <_svfiprintf_r+0x1216>
42015823:	00          	.byte	00
42015824:	126ea2        	s32i	a10, a14, 72
42015827:	881c      	movi.n	a8, 24
42015829:	0728a7        	blt	a8, a10, 42015834 <_svfiprintf_r+0x108c>
4201582c:	112e82        	l32i	a8, a14, 68
4201582f:	000486        	j	42015845 <_svfiprintf_r+0x109d>
42015832:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015835:	0128      	l32i.n	a2, a1, 0
42015837:	8a2c      	movi.n	a10, 40
42015839:	10c182        	addi	a8, a1, 16
4201583c:	02d882        	addmi	a8, a8, 0x200
4201583f:	102882        	l32i	a8, a8, 64
42015842:	9661a2        	s32i	a10, a1, 0x258
42015845:	88aa      	add.n	a8, a8, a10
42015847:	f8c882        	addi	a8, a8, -8
4201584a:	0858      	l32i.n	a5, a8, 0
4201584c:	1838      	l32i.n	a3, a8, 4
4201584e:	005b06        	j	420159be <_svfiprintf_r+0x1216>
42015851:	036247        	bbci	a2, 4, 42015858 <_svfiprintf_r+0x10b0>
42015854:	005b06        	j	420159c4 <_svfiprintf_r+0x121c>
42015857:	e26700        	remu	a6, a7, a0
4201585a:	2b4602        	s8i	a0, a6, 43
4201585d:	c3ac00        	movf	a10, a12, b0
42015860:	09a587        	bge	a5, a8, 4201586d <_svfiprintf_r+0x10c5>
42015863:	b0e5e0        	addx8	a14, a5, a14
42015866:	001e52        	l16ui	a5, a14, 0
42015869:	006046        	j	420159ee <_svfiprintf_r+0x1246>
4201586c:	a28200        	muluh	a8, a2, a0
4201586f:	30          	.byte	0x30
42015870:	8e8a      	add.n	a8, a14, a8
42015872:	34a2d2        	movi	a13, 0x234
42015875:	40a2c2        	movi	a12, 0x240
42015878:	05ad      	mov.n	a10, a5
4201587a:	0189      	s32i.n	a8, a1, 0
4201587c:	01def2        	addmi	a15, a14, 0x100
4201587f:	deda      	add.n	a13, a14, a13
42015881:	ceca      	add.n	a12, a14, a12
42015883:	07bd      	mov.n	a11, a7
42015885:	fe9465        	call8	420141cc <get_arg$isra$0>
42015888:	001a52        	l16ui	a5, a10, 0
4201588b:	0057c6        	j	420159ee <_svfiprintf_r+0x1246>
4201588e:	761b      	addi.n	a7, a6, 1
42015890:	08a687        	bge	a6, a8, 4201589c <_svfiprintf_r+0x10f4>
42015893:	b0e5e0        	addx8	a14, a5, a14
42015896:	001e52        	l16ui	a5, a14, 0
42015899:	0047c6        	j	420159bc <_svfiprintf_r+0x1214>
4201589c:	922e92        	l32i	a9, a14, 0x248
4201589f:	fb1c      	movi.n	a11, 31
420158a1:	02dee2        	addmi	a14, a14, 0x200
420158a4:	a94b      	addi.n	a10, a9, 4
420158a6:	362b87        	blt	a11, a8, 420158e0 <_svfiprintf_r+0x1138>
420158a9:	b81b      	addi.n	a11, a8, 1
420158ab:	9161b2        	s32i	a11, a1, 0x244
420158ae:	126ea2        	s32i	a10, a14, 72
420158b1:	8b1c      	movi.n	a11, 24
420158b3:	052ba7        	blt	a11, a10, 420158bc <_svfiprintf_r+0x1114>
420158b6:	112e92        	l32i	a9, a14, 68
420158b9:	000406        	j	420158cd <_svfiprintf_r+0x1125>
420158bc:	012b97        	blt	a11, a9, 420158c1 <_svfiprintf_r+0x1119>
420158bf:	4a2c      	movi.n	a10, 36
420158c1:	10c192        	addi	a9, a1, 16
420158c4:	02d992        	addmi	a9, a9, 0x200
420158c7:	102992        	l32i	a9, a9, 64
420158ca:	9661a2        	s32i	a10, a1, 0x258
420158cd:	99aa      	add.n	a9, a9, a10
420158cf:	fcc992        	addi	a9, a9, -4
420158d2:	0958      	l32i.n	a5, a9, 0
420158d4:	b08810        	addx8	a8, a8, a1
420158d7:	4859      	s32i.n	a5, a8, 16
420158d9:	f45050        	extui	a5, a5, 0, 16
420158dc:	003706        	j	420159bc <_svfiprintf_r+0x1214>
420158df:	00          	.byte	00
420158e0:	126ea2        	s32i	a10, a14, 72
420158e3:	881c      	movi.n	a8, 24
420158e5:	0728a7        	blt	a8, a10, 420158f0 <_svfiprintf_r+0x1148>
420158e8:	112e82        	l32i	a8, a14, 68
420158eb:	000486        	j	42015901 <_svfiprintf_r+0x1159>
420158ee:	970000        	ee.stf.64.xp	f0, f9, a0, a0
420158f1:	0128      	l32i.n	a2, a1, 0
420158f3:	4a2c      	movi.n	a10, 36
420158f5:	10c182        	addi	a8, a1, 16
420158f8:	02d882        	addmi	a8, a8, 0x200
420158fb:	102882        	l32i	a8, a8, 64
420158fe:	9661a2        	s32i	a10, a1, 0x258
42015901:	88aa      	add.n	a8, a8, a10
42015903:	fcc882        	addi	a8, a8, -4
42015906:	001852        	l16ui	a5, a8, 0
42015909:	002bc6        	j	420159bc <_svfiprintf_r+0x1214>
4201590c:	02e297        	bbsi	a2, 9, 42015912 <_svfiprintf_r+0x116a>
4201590f:	002c46        	j	420159c4 <_svfiprintf_r+0x121c>
42015912:	c3ac      	beqz.n	a3, 42015942 <_svfiprintf_r+0x119a>
42015914:	09a587        	bge	a5, a8, 42015921 <_svfiprintf_r+0x1179>
42015917:	b0e5e0        	addx8	a14, a5, a14
4201591a:	000e52        	l8ui	a5, a14, 0
4201591d:	003346        	j	420159ee <_svfiprintf_r+0x1246>
42015920:	a28200        	muluh	a8, a2, a0
42015923:	30          	.byte	0x30
42015924:	8e8a      	add.n	a8, a14, a8
42015926:	34a2d2        	movi	a13, 0x234
42015929:	40a2c2        	movi	a12, 0x240
4201592c:	05ad      	mov.n	a10, a5
4201592e:	0189      	s32i.n	a8, a1, 0
42015930:	01def2        	addmi	a15, a14, 0x100
42015933:	deda      	add.n	a13, a14, a13
42015935:	ceca      	add.n	a12, a14, a12
42015937:	07bd      	mov.n	a11, a7
42015939:	fe8925        	call8	420141cc <get_arg$isra$0>
4201593c:	000a52        	l8ui	a5, a10, 0
4201593f:	002ac6        	j	420159ee <_svfiprintf_r+0x1246>
42015942:	761b      	addi.n	a7, a6, 1
42015944:	08a687        	bge	a6, a8, 42015950 <_svfiprintf_r+0x11a8>
42015947:	b0e5e0        	addx8	a14, a5, a14
4201594a:	000e52        	l8ui	a5, a14, 0
4201594d:	001ac6        	j	420159bc <_svfiprintf_r+0x1214>
42015950:	922e92        	l32i	a9, a14, 0x248
42015953:	fb1c      	movi.n	a11, 31
42015955:	02dee2        	addmi	a14, a14, 0x200
42015958:	a94b      	addi.n	a10, a9, 4
4201595a:	362b87        	blt	a11, a8, 42015994 <_svfiprintf_r+0x11ec>
4201595d:	b81b      	addi.n	a11, a8, 1
4201595f:	9161b2        	s32i	a11, a1, 0x244
42015962:	126ea2        	s32i	a10, a14, 72
42015965:	8b1c      	movi.n	a11, 24
42015967:	052ba7        	blt	a11, a10, 42015970 <_svfiprintf_r+0x11c8>
4201596a:	112e92        	l32i	a9, a14, 68
4201596d:	000406        	j	42015981 <_svfiprintf_r+0x11d9>
42015970:	012b97        	blt	a11, a9, 42015975 <_svfiprintf_r+0x11cd>
42015973:	4a2c      	movi.n	a10, 36
42015975:	10c192        	addi	a9, a1, 16
42015978:	02d992        	addmi	a9, a9, 0x200
4201597b:	102992        	l32i	a9, a9, 64
4201597e:	9661a2        	s32i	a10, a1, 0x258
42015981:	99aa      	add.n	a9, a9, a10
42015983:	fcc992        	addi	a9, a9, -4
42015986:	0958      	l32i.n	a5, a9, 0
42015988:	b08810        	addx8	a8, a8, a1
4201598b:	4859      	s32i.n	a5, a8, 16
4201598d:	745050        	extui	a5, a5, 0, 8
42015990:	000a06        	j	420159bc <_svfiprintf_r+0x1214>
42015993:	00          	.byte	00
42015994:	126ea2        	s32i	a10, a14, 72
42015997:	881c      	movi.n	a8, 24
42015999:	0528a7        	blt	a8, a10, 420159a2 <_svfiprintf_r+0x11fa>
4201599c:	112e82        	l32i	a8, a14, 68
4201599f:	000446        	j	420159b4 <_svfiprintf_r+0x120c>
420159a2:	022897        	blt	a8, a9, 420159a8 <_svfiprintf_r+0x1200>
420159a5:	24a0a2        	movi	a10, 36
420159a8:	10c182        	addi	a8, a1, 16
420159ab:	02d882        	addmi	a8, a8, 0x200
420159ae:	102882        	l32i	a8, a8, 64
420159b1:	9661a2        	s32i	a10, a1, 0x258
420159b4:	88aa      	add.n	a8, a8, a10
420159b6:	fcc882        	addi	a8, a8, -4
420159b9:	000852        	l8ui	a5, a8, 0
420159bc:	030c      	movi.n	a3, 0
420159be:	190c      	movi.n	a9, 1
420159c0:	00ef46        	j	42015d81 <_svfiprintf_r+0x15d9>
420159c3:	c3ac00        	movf	a10, a12, b0
420159c6:	07a587        	bge	a5, a8, 420159d1 <_svfiprintf_r+0x1229>
420159c9:	b0e5e0        	addx8	a14, a5, a14
420159cc:	0e58      	l32i.n	a5, a14, 0
420159ce:	000706        	j	420159ee <_svfiprintf_r+0x1246>
420159d1:	30a282        	movi	a8, 0x230
420159d4:	8e8a      	add.n	a8, a14, a8
420159d6:	34a2d2        	movi	a13, 0x234
420159d9:	40a2c2        	movi	a12, 0x240
420159dc:	05ad      	mov.n	a10, a5
420159de:	0189      	s32i.n	a8, a1, 0
420159e0:	01def2        	addmi	a15, a14, 0x100
420159e3:	deda      	add.n	a13, a14, a13
420159e5:	ceca      	add.n	a12, a14, a12
420159e7:	07bd      	mov.n	a11, a7
420159e9:	fe7e25        	call8	420141cc <get_arg$isra$0>
420159ec:	0a58      	l32i.n	a5, a10, 0
420159ee:	067d      	mov.n	a7, a6
420159f0:	fff206        	j	420159bc <_svfiprintf_r+0x1214>
420159f3:	761b00        	ee.ldf.64.xp	f1, f7, a0, a11
420159f6:	07a687        	bge	a6, a8, 42015a01 <_svfiprintf_r+0x1259>
420159f9:	b0e5e0        	addx8	a14, a5, a14
420159fc:	0e58      	l32i.n	a5, a14, 0
420159fe:	ffee86        	j	420159bc <_svfiprintf_r+0x1214>
42015a01:	922e92        	l32i	a9, a14, 0x248
42015a04:	fb1c      	movi.n	a11, 31
42015a06:	02dee2        	addmi	a14, a14, 0x200
42015a09:	a94b      	addi.n	a10, a9, 4
42015a0b:	322b87        	blt	a11, a8, 42015a41 <_svfiprintf_r+0x1299>
42015a0e:	b81b      	addi.n	a11, a8, 1
42015a10:	9161b2        	s32i	a11, a1, 0x244
42015a13:	126ea2        	s32i	a10, a14, 72
42015a16:	8b1c      	movi.n	a11, 24
42015a18:	052ba7        	blt	a11, a10, 42015a21 <_svfiprintf_r+0x1279>
42015a1b:	112e92        	l32i	a9, a14, 68
42015a1e:	000406        	j	42015a32 <_svfiprintf_r+0x128a>
42015a21:	012b97        	blt	a11, a9, 42015a26 <_svfiprintf_r+0x127e>
42015a24:	4a2c      	movi.n	a10, 36
42015a26:	10c192        	addi	a9, a1, 16
42015a29:	02d992        	addmi	a9, a9, 0x200
42015a2c:	102992        	l32i	a9, a9, 64
42015a2f:	9661a2        	s32i	a10, a1, 0x258
42015a32:	99aa      	add.n	a9, a9, a10
42015a34:	fcc992        	addi	a9, a9, -4
42015a37:	0958      	l32i.n	a5, a9, 0
42015a39:	b08810        	addx8	a8, a8, a1
42015a3c:	4859      	s32i.n	a5, a8, 16
42015a3e:	ffde86        	j	420159bc <_svfiprintf_r+0x1214>
42015a41:	126ea2        	s32i	a10, a14, 72
42015a44:	881c      	movi.n	a8, 24
42015a46:	0628a7        	blt	a8, a10, 42015a50 <_svfiprintf_r+0x12a8>
42015a49:	112e82        	l32i	a8, a14, 68
42015a4c:	000446        	j	42015a61 <_svfiprintf_r+0x12b9>
42015a4f:	00          	.byte	00
42015a50:	012897        	blt	a8, a9, 42015a55 <_svfiprintf_r+0x12ad>
42015a53:	4a2c      	movi.n	a10, 36
42015a55:	10c182        	addi	a8, a1, 16
42015a58:	02d882        	addmi	a8, a8, 0x200
42015a5b:	102882        	l32i	a8, a8, 64
42015a5e:	9661a2        	s32i	a10, a1, 0x258
42015a61:	88aa      	add.n	a8, a8, a10
42015a63:	fcc882        	addi	a8, a8, -4
42015a66:	0858      	l32i.n	a5, a8, 0
42015a68:	ffd406        	j	420159bc <_svfiprintf_r+0x1214>
42015a6b:	00          	.byte	00
42015a6c:	ad4e81        	l32r	a8, 42000fa4 <_stext+0xf84> (3c028705 <blanks$1+0x31>)
42015a6f:	a26182        	s32i	a8, a1, 0x288
42015a72:	10c1e2        	addi	a14, a1, 16
42015a75:	912182        	l32i	a8, a1, 0x244
42015a78:	02e257        	bbsi	a2, 5, 42015a7e <_svfiprintf_r+0x12d6>
42015a7b:	002f86        	j	42015b3d <_svfiprintf_r+0x1395>
42015a7e:	f3ac      	beqz.n	a3, 42015ab1 <_svfiprintf_r+0x1309>
42015a80:	09a587        	bge	a5, a8, 42015a8d <_svfiprintf_r+0x12e5>
42015a83:	b0e5e0        	addx8	a14, a5, a14
42015a86:	0e58      	l32i.n	a5, a14, 0
42015a88:	1e38      	l32i.n	a3, a14, 4
42015a8a:	000786        	j	42015aac <_svfiprintf_r+0x1304>
42015a8d:	30a282        	movi	a8, 0x230
42015a90:	8e8a      	add.n	a8, a14, a8
42015a92:	34a2d2        	movi	a13, 0x234
42015a95:	40a2c2        	movi	a12, 0x240
42015a98:	05ad      	mov.n	a10, a5
42015a9a:	0189      	s32i.n	a8, a1, 0
42015a9c:	01def2        	addmi	a15, a14, 0x100
42015a9f:	deda      	add.n	a13, a14, a13
42015aa1:	ceca      	add.n	a12, a14, a12
42015aa3:	07bd      	mov.n	a11, a7
42015aa5:	fe7265        	call8	420141cc <get_arg$isra$0>
42015aa8:	0a58      	l32i.n	a5, a10, 0
42015aaa:	1a38      	l32i.n	a3, a10, 4
42015aac:	067d      	mov.n	a7, a6
42015aae:	00ab06        	j	42015d5e <_svfiprintf_r+0x15b6>
42015ab1:	761b      	addi.n	a7, a6, 1
42015ab3:	09a687        	bge	a6, a8, 42015ac0 <_svfiprintf_r+0x1318>
42015ab6:	b0e5e0        	addx8	a14, a5, a14
42015ab9:	0e58      	l32i.n	a5, a14, 0
42015abb:	1e38      	l32i.n	a3, a14, 4
42015abd:	00a746        	j	42015d5e <_svfiprintf_r+0x15b6>
42015ac0:	922e92        	l32i	a9, a14, 0x248
42015ac3:	8a7c      	movi.n	a10, -8
42015ac5:	997b      	addi.n	a9, a9, 7
42015ac7:	1099a0        	and	a9, a9, a10
42015aca:	fb1c      	movi.n	a11, 31
42015acc:	02dee2        	addmi	a14, a14, 0x200
42015acf:	a98b      	addi.n	a10, a9, 8
42015ad1:	3b2b87        	blt	a11, a8, 42015b10 <_svfiprintf_r+0x1368>
42015ad4:	b81b      	addi.n	a11, a8, 1
42015ad6:	9161b2        	s32i	a11, a1, 0x244
42015ad9:	126ea2        	s32i	a10, a14, 72
42015adc:	8b1c      	movi.n	a11, 24
42015ade:	062ba7        	blt	a11, a10, 42015ae8 <_svfiprintf_r+0x1340>
42015ae1:	112e92        	l32i	a9, a14, 68
42015ae4:	000446        	j	42015af9 <_svfiprintf_r+0x1351>
42015ae7:	2b9700        	oeq.s	b9, f7, f0
42015aea:	8a2c01        	l32r	a0, 41ff839c <_iram_bss_end+0x1c75f9c>
42015aed:	10c192        	addi	a9, a1, 16
42015af0:	02d992        	addmi	a9, a9, 0x200
42015af3:	102992        	l32i	a9, a9, 64
42015af6:	9661a2        	s32i	a10, a1, 0x258
42015af9:	99aa      	add.n	a9, a9, a10
42015afb:	f8c992        	addi	a9, a9, -8
42015afe:	0958      	l32i.n	a5, a9, 0
42015b00:	1938      	l32i.n	a3, a9, 4
42015b02:	10c192        	addi	a9, a1, 16
42015b05:	b08890        	addx8	a8, a8, a9
42015b08:	0859      	s32i.n	a5, a8, 0
42015b0a:	1839      	s32i.n	a3, a8, 4
42015b0c:	009386        	j	42015d5e <_svfiprintf_r+0x15b6>
42015b0f:	00          	.byte	00
42015b10:	126ea2        	s32i	a10, a14, 72
42015b13:	881c      	movi.n	a8, 24
42015b15:	0728a7        	blt	a8, a10, 42015b20 <_svfiprintf_r+0x1378>
42015b18:	112e82        	l32i	a8, a14, 68
42015b1b:	000486        	j	42015b31 <_svfiprintf_r+0x1389>
42015b1e:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015b21:	0128      	l32i.n	a2, a1, 0
42015b23:	8a2c      	movi.n	a10, 40
42015b25:	10c182        	addi	a8, a1, 16
42015b28:	02d882        	addmi	a8, a8, 0x200
42015b2b:	102882        	l32i	a8, a8, 64
42015b2e:	9661a2        	s32i	a10, a1, 0x258
42015b31:	88aa      	add.n	a8, a8, a10
42015b33:	f8c882        	addi	a8, a8, -8
42015b36:	0858      	l32i.n	a5, a8, 0
42015b38:	1838      	l32i.n	a3, a8, 4
42015b3a:	008806        	j	42015d5e <_svfiprintf_r+0x15b6>
42015b3d:	146247        	bbci	a2, 4, 42015b55 <_svfiprintf_r+0x13ad>
42015b40:	138c      	beqz.n	a3, 42015b45 <_svfiprintf_r+0x139d>
42015b42:	005d06        	j	42015cba <_svfiprintf_r+0x1512>
42015b45:	761b      	addi.n	a7, a6, 1
42015b47:	022687        	blt	a6, a8, 42015b4d <_svfiprintf_r+0x13a5>
42015b4a:	006986        	j	42015cf4 <_svfiprintf_r+0x154c>
42015b4d:	b0e5e0        	addx8	a14, a5, a14
42015b50:	0e58      	l32i.n	a5, a14, 0
42015b52:	008186        	j	42015d5c <_svfiprintf_r+0x15b4>
42015b55:	02e267        	bbsi	a2, 6, 42015b5b <_svfiprintf_r+0x13b3>
42015b58:	002a46        	j	42015c05 <_svfiprintf_r+0x145d>
42015b5b:	b3ac      	beqz.n	a3, 42015b8a <_svfiprintf_r+0x13e2>
42015b5d:	08a587        	bge	a5, a8, 42015b69 <_svfiprintf_r+0x13c1>
42015b60:	b0e5e0        	addx8	a14, a5, a14
42015b63:	001e52        	l16ui	a5, a14, 0
42015b66:	005e06        	j	42015ce2 <_svfiprintf_r+0x153a>
42015b69:	30a282        	movi	a8, 0x230
42015b6c:	8e8a      	add.n	a8, a14, a8
42015b6e:	34a2d2        	movi	a13, 0x234
42015b71:	40a2c2        	movi	a12, 0x240
42015b74:	05ad      	mov.n	a10, a5
42015b76:	0189      	s32i.n	a8, a1, 0
42015b78:	01def2        	addmi	a15, a14, 0x100
42015b7b:	deda      	add.n	a13, a14, a13
42015b7d:	ceca      	add.n	a12, a14, a12
42015b7f:	07bd      	mov.n	a11, a7
42015b81:	fe64a5        	call8	420141cc <get_arg$isra$0>
42015b84:	001a52        	l16ui	a5, a10, 0
42015b87:	0055c6        	j	42015ce2 <_svfiprintf_r+0x153a>
42015b8a:	761b      	addi.n	a7, a6, 1
42015b8c:	08a687        	bge	a6, a8, 42015b98 <_svfiprintf_r+0x13f0>
42015b8f:	b0e5e0        	addx8	a14, a5, a14
42015b92:	001e52        	l16ui	a5, a14, 0
42015b95:	0070c6        	j	42015d5c <_svfiprintf_r+0x15b4>
42015b98:	922e92        	l32i	a9, a14, 0x248
42015b9b:	fb1c      	movi.n	a11, 31
42015b9d:	02dee2        	addmi	a14, a14, 0x200
42015ba0:	a94b      	addi.n	a10, a9, 4
42015ba2:	352b87        	blt	a11, a8, 42015bdb <_svfiprintf_r+0x1433>
42015ba5:	b81b      	addi.n	a11, a8, 1
42015ba7:	9161b2        	s32i	a11, a1, 0x244
42015baa:	126ea2        	s32i	a10, a14, 72
42015bad:	8b1c      	movi.n	a11, 24
42015baf:	052ba7        	blt	a11, a10, 42015bb8 <_svfiprintf_r+0x1410>
42015bb2:	112e92        	l32i	a9, a14, 68
42015bb5:	000406        	j	42015bc9 <_svfiprintf_r+0x1421>
42015bb8:	012b97        	blt	a11, a9, 42015bbd <_svfiprintf_r+0x1415>
42015bbb:	4a2c      	movi.n	a10, 36
42015bbd:	10c192        	addi	a9, a1, 16
42015bc0:	02d992        	addmi	a9, a9, 0x200
42015bc3:	102992        	l32i	a9, a9, 64
42015bc6:	9661a2        	s32i	a10, a1, 0x258
42015bc9:	99aa      	add.n	a9, a9, a10
42015bcb:	fcc992        	addi	a9, a9, -4
42015bce:	0958      	l32i.n	a5, a9, 0
42015bd0:	b08810        	addx8	a8, a8, a1
42015bd3:	4859      	s32i.n	a5, a8, 16
42015bd5:	f45050        	extui	a5, a5, 0, 16
42015bd8:	006006        	j	42015d5c <_svfiprintf_r+0x15b4>
42015bdb:	126ea2        	s32i	a10, a14, 72
42015bde:	881c      	movi.n	a8, 24
42015be0:	0528a7        	blt	a8, a10, 42015be9 <_svfiprintf_r+0x1441>
42015be3:	112e82        	l32i	a8, a14, 68
42015be6:	000406        	j	42015bfa <_svfiprintf_r+0x1452>
42015be9:	012897        	blt	a8, a9, 42015bee <_svfiprintf_r+0x1446>
42015bec:	4a2c      	movi.n	a10, 36
42015bee:	10c182        	addi	a8, a1, 16
42015bf1:	02d882        	addmi	a8, a8, 0x200
42015bf4:	102882        	l32i	a8, a8, 64
42015bf7:	9661a2        	s32i	a10, a1, 0x258
42015bfa:	88aa      	add.n	a8, a8, a10
42015bfc:	fcc882        	addi	a8, a8, -4
42015bff:	001852        	l16ui	a5, a8, 0
42015c02:	005586        	j	42015d5c <_svfiprintf_r+0x15b4>
42015c05:	02e297        	bbsi	a2, 9, 42015c0b <_svfiprintf_r+0x1463>
42015c08:	002b06        	j	42015cb8 <_svfiprintf_r+0x1510>
42015c0b:	b3ac      	beqz.n	a3, 42015c3a <_svfiprintf_r+0x1492>
42015c0d:	08a587        	bge	a5, a8, 42015c19 <_svfiprintf_r+0x1471>
42015c10:	b0e5e0        	addx8	a14, a5, a14
42015c13:	000e52        	l8ui	a5, a14, 0
42015c16:	003206        	j	42015ce2 <_svfiprintf_r+0x153a>
42015c19:	30a282        	movi	a8, 0x230
42015c1c:	8e8a      	add.n	a8, a14, a8
42015c1e:	34a2d2        	movi	a13, 0x234
42015c21:	40a2c2        	movi	a12, 0x240
42015c24:	05ad      	mov.n	a10, a5
42015c26:	0189      	s32i.n	a8, a1, 0
42015c28:	01def2        	addmi	a15, a14, 0x100
42015c2b:	deda      	add.n	a13, a14, a13
42015c2d:	ceca      	add.n	a12, a14, a12
42015c2f:	07bd      	mov.n	a11, a7
42015c31:	fe59a5        	call8	420141cc <get_arg$isra$0>
42015c34:	000a52        	l8ui	a5, a10, 0
42015c37:	0029c6        	j	42015ce2 <_svfiprintf_r+0x153a>
42015c3a:	761b      	addi.n	a7, a6, 1
42015c3c:	08a687        	bge	a6, a8, 42015c48 <_svfiprintf_r+0x14a0>
42015c3f:	b0e5e0        	addx8	a14, a5, a14
42015c42:	000e52        	l8ui	a5, a14, 0
42015c45:	0044c6        	j	42015d5c <_svfiprintf_r+0x15b4>
42015c48:	922e92        	l32i	a9, a14, 0x248
42015c4b:	fb1c      	movi.n	a11, 31
42015c4d:	02dee2        	addmi	a14, a14, 0x200
42015c50:	a94b      	addi.n	a10, a9, 4
42015c52:	362b87        	blt	a11, a8, 42015c8c <_svfiprintf_r+0x14e4>
42015c55:	b81b      	addi.n	a11, a8, 1
42015c57:	9161b2        	s32i	a11, a1, 0x244
42015c5a:	126ea2        	s32i	a10, a14, 72
42015c5d:	8b1c      	movi.n	a11, 24
42015c5f:	052ba7        	blt	a11, a10, 42015c68 <_svfiprintf_r+0x14c0>
42015c62:	112e92        	l32i	a9, a14, 68
42015c65:	000406        	j	42015c79 <_svfiprintf_r+0x14d1>
42015c68:	012b97        	blt	a11, a9, 42015c6d <_svfiprintf_r+0x14c5>
42015c6b:	4a2c      	movi.n	a10, 36
42015c6d:	10c192        	addi	a9, a1, 16
42015c70:	02d992        	addmi	a9, a9, 0x200
42015c73:	102992        	l32i	a9, a9, 64
42015c76:	9661a2        	s32i	a10, a1, 0x258
42015c79:	99aa      	add.n	a9, a9, a10
42015c7b:	fcc992        	addi	a9, a9, -4
42015c7e:	0958      	l32i.n	a5, a9, 0
42015c80:	b08810        	addx8	a8, a8, a1
42015c83:	4859      	s32i.n	a5, a8, 16
42015c85:	745050        	extui	a5, a5, 0, 8
42015c88:	003406        	j	42015d5c <_svfiprintf_r+0x15b4>
42015c8b:	00          	.byte	00
42015c8c:	126ea2        	s32i	a10, a14, 72
42015c8f:	881c      	movi.n	a8, 24
42015c91:	0728a7        	blt	a8, a10, 42015c9c <_svfiprintf_r+0x14f4>
42015c94:	112e82        	l32i	a8, a14, 68
42015c97:	000486        	j	42015cad <_svfiprintf_r+0x1505>
42015c9a:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015c9d:	0128      	l32i.n	a2, a1, 0
42015c9f:	4a2c      	movi.n	a10, 36
42015ca1:	10c182        	addi	a8, a1, 16
42015ca4:	02d882        	addmi	a8, a8, 0x200
42015ca7:	102882        	l32i	a8, a8, 64
42015caa:	9661a2        	s32i	a10, a1, 0x258
42015cad:	88aa      	add.n	a8, a8, a10
42015caf:	fcc882        	addi	a8, a8, -4
42015cb2:	000852        	l8ui	a5, a8, 0
42015cb5:	0028c6        	j	42015d5c <_svfiprintf_r+0x15b4>
42015cb8:	b3ac      	beqz.n	a3, 42015ce7 <_svfiprintf_r+0x153f>
42015cba:	07a587        	bge	a5, a8, 42015cc5 <_svfiprintf_r+0x151d>
42015cbd:	b0e5e0        	addx8	a14, a5, a14
42015cc0:	0e58      	l32i.n	a5, a14, 0
42015cc2:	000706        	j	42015ce2 <_svfiprintf_r+0x153a>
42015cc5:	30a282        	movi	a8, 0x230
42015cc8:	8e8a      	add.n	a8, a14, a8
42015cca:	34a2d2        	movi	a13, 0x234
42015ccd:	40a2c2        	movi	a12, 0x240
42015cd0:	05ad      	mov.n	a10, a5
42015cd2:	0189      	s32i.n	a8, a1, 0
42015cd4:	01def2        	addmi	a15, a14, 0x100
42015cd7:	deda      	add.n	a13, a14, a13
42015cd9:	ceca      	add.n	a12, a14, a12
42015cdb:	07bd      	mov.n	a11, a7
42015cdd:	fe4ee5        	call8	420141cc <get_arg$isra$0>
42015ce0:	0a58      	l32i.n	a5, a10, 0
42015ce2:	067d      	mov.n	a7, a6
42015ce4:	001d06        	j	42015d5c <_svfiprintf_r+0x15b4>
42015ce7:	761b      	addi.n	a7, a6, 1
42015ce9:	07a687        	bge	a6, a8, 42015cf4 <_svfiprintf_r+0x154c>
42015cec:	b055e0        	addx8	a5, a5, a14
42015cef:	0558      	l32i.n	a5, a5, 0
42015cf1:	0019c6        	j	42015d5c <_svfiprintf_r+0x15b4>
42015cf4:	922e92        	l32i	a9, a14, 0x248
42015cf7:	fb1c      	movi.n	a11, 31
42015cf9:	02dee2        	addmi	a14, a14, 0x200
42015cfc:	a94b      	addi.n	a10, a9, 4
42015cfe:	322b87        	blt	a11, a8, 42015d34 <_svfiprintf_r+0x158c>
42015d01:	b81b      	addi.n	a11, a8, 1
42015d03:	9161b2        	s32i	a11, a1, 0x244
42015d06:	126ea2        	s32i	a10, a14, 72
42015d09:	8b1c      	movi.n	a11, 24
42015d0b:	052ba7        	blt	a11, a10, 42015d14 <_svfiprintf_r+0x156c>
42015d0e:	112e92        	l32i	a9, a14, 68
42015d11:	000406        	j	42015d25 <_svfiprintf_r+0x157d>
42015d14:	012b97        	blt	a11, a9, 42015d19 <_svfiprintf_r+0x1571>
42015d17:	4a2c      	movi.n	a10, 36
42015d19:	10c192        	addi	a9, a1, 16
42015d1c:	02d992        	addmi	a9, a9, 0x200
42015d1f:	102992        	l32i	a9, a9, 64
42015d22:	9661a2        	s32i	a10, a1, 0x258
42015d25:	99aa      	add.n	a9, a9, a10
42015d27:	fcc992        	addi	a9, a9, -4
42015d2a:	0958      	l32i.n	a5, a9, 0
42015d2c:	b08810        	addx8	a8, a8, a1
42015d2f:	4859      	s32i.n	a5, a8, 16
42015d31:	0009c6        	j	42015d5c <_svfiprintf_r+0x15b4>
42015d34:	126ea2        	s32i	a10, a14, 72
42015d37:	881c      	movi.n	a8, 24
42015d39:	0728a7        	blt	a8, a10, 42015d44 <_svfiprintf_r+0x159c>
42015d3c:	112e82        	l32i	a8, a14, 68
42015d3f:	000486        	j	42015d55 <_svfiprintf_r+0x15ad>
42015d42:	970000        	ee.stf.64.xp	f0, f9, a0, a0
42015d45:	0128      	l32i.n	a2, a1, 0
42015d47:	4a2c      	movi.n	a10, 36
42015d49:	10c182        	addi	a8, a1, 16
42015d4c:	02d882        	addmi	a8, a8, 0x200
42015d4f:	102882        	l32i	a8, a8, 64
42015d52:	9661a2        	s32i	a10, a1, 0x258
42015d55:	88aa      	add.n	a8, a8, a10
42015d57:	fcc882        	addi	a8, a8, -4
42015d5a:	0858      	l32i.n	a5, a8, 0
42015d5c:	030c      	movi.n	a3, 0
42015d5e:	208530        	or	a8, a5, a3
42015d61:	489c      	beqz.n	a8, 42015d79 <_svfiprintf_r+0x15d1>
42015d63:	126207        	bbci	a2, 0, 42015d79 <_svfiprintf_r+0x15d1>
42015d66:	10c182        	addi	a8, a1, 16
42015d69:	02d882        	addmi	a8, a8, 0x200
42015d6c:	093c      	movi.n	a9, 48
42015d6e:	384892        	s8i	a9, a8, 56
42015d71:	394842        	s8i	a4, a8, 57
42015d74:	280c      	movi.n	a8, 2
42015d76:	202280        	or	a2, a2, a8
42015d79:	ffab82        	movi	a8, 0xfffffbff
42015d7c:	102280        	and	a2, a2, a8
42015d7f:	290c      	movi.n	a9, 2
42015d81:	080c      	movi.n	a8, 0
42015d83:	10c1a2        	addi	a10, a1, 16
42015d86:	02daa2        	addmi	a10, a10, 0x200
42015d89:	3a4a82        	s8i	a8, a10, 58
42015d8c:	9b2182        	l32i	a8, a1, 0x26c
42015d8f:	01d896        	bltz	a8, 42015db0 <_svfiprintf_r+0x1608>
42015d92:	20a220        	or	a10, a2, a2
42015d95:	7faf82        	movi	a8, -129
42015d98:	102280        	and	a2, a2, a8
42015d9b:	1b0c      	movi.n	a11, 1
42015d9d:	208530        	or	a8, a5, a3
42015da0:	83b880        	moveqz	a11, a8, a8
42015da3:	98cc      	bnez.n	a8, 42015db0 <_svfiprintf_r+0x1608>
42015da5:	9b21c2        	l32i	a12, a1, 0x26c
42015da8:	180c      	movi.n	a8, 1
42015daa:	838bc0        	moveqz	a8, a11, a12
42015dad:	12d816        	beqz	a8, 42015ede <_svfiprintf_r+0x1736>
42015db0:	421926        	beqi	a9, 1, 42015df6 <_svfiprintf_r+0x164e>
42015db3:	e4a182        	movi	a8, 0x1e4
42015db6:	022966        	bnei	a9, 2, 42015dbc <_svfiprintf_r+0x1614>
42015db9:	003dc6        	j	42015eb4 <_svfiprintf_r+0x170c>
42015dbc:	10c192        	addi	a9, a1, 16
42015dbf:	498a      	add.n	a4, a9, a8
42015dc1:	249050        	extui	a9, a5, 0, 3
42015dc4:	04ad      	mov.n	a10, a4
42015dc6:	404300        	ssai	3
42015dc9:	815350        	src	a5, a3, a5
42015dcc:	440b      	addi.n	a4, a4, -1
42015dce:	30c992        	addi	a9, a9, 48
42015dd1:	413330        	srli	a3, a3, 3
42015dd4:	004492        	s8i	a9, a4, 0
42015dd7:	20b530        	or	a11, a5, a3
42015dda:	fe3b56        	bnez	a11, 42015dc1 <_svfiprintf_r+0x1619>
42015ddd:	d0c992        	addi	a9, a9, -48
42015de0:	128916        	beqz	a9, 42015f0c <_svfiprintf_r+0x1764>
42015de3:	02e207        	bbsi	a2, 0, 42015de9 <_svfiprintf_r+0x1641>
42015de6:	004886        	j	42015f0c <_svfiprintf_r+0x1764>
42015de9:	840b      	addi.n	a8, a4, -1
42015deb:	093c      	movi.n	a9, 48
42015ded:	004892        	s8i	a9, a8, 0
42015df0:	feca42        	addi	a4, a10, -2
42015df3:	004546        	j	42015f0c <_svfiprintf_r+0x1764>
42015df6:	63dc      	bnez.n	a3, 42015e10 <_svfiprintf_r+0x1668>
42015df8:	980c      	movi.n	a8, 9
42015dfa:	123857        	bltu	a8, a5, 42015e10 <_svfiprintf_r+0x1668>
42015dfd:	10c182        	addi	a8, a1, 16
42015e00:	01d892        	addmi	a9, a8, 0x100
42015e03:	30c552        	addi	a5, a5, 48
42015e06:	e34952        	s8i	a5, a9, 227
42015e09:	e3a192        	movi	a9, 0x1e3
42015e0c:	003e86        	j	42015f0a <_svfiprintf_r+0x1762>
42015e0f:	a18200        	sll	a8, a2
42015e12:	a462f4        	ee.vst.l.64.ip	q4, a15, 0x310
42015e15:	00          	.byte	00
42015e16:	0e0c      	movi.n	a14, 0
42015e18:	818a      	add.n	a8, a1, a8
42015e1a:	106260        	and	a6, a2, a6
42015e1d:	a461e2        	s32i	a14, a1, 0x290
42015e20:	ac0c      	movi.n	a12, 10
42015e22:	0d0c      	movi.n	a13, 0
42015e24:	05ad      	mov.n	a10, a5
42015e26:	03bd      	mov.n	a11, a3
42015e28:	480b      	addi.n	a4, a8, -1
42015e2a:	aa5881        	l32r	a8, 4200078c <_stext+0x76c> (40002574 <__umoddi3>)
42015e2d:	0008e0        	callx8	a8
42015e30:	a421e2        	l32i	a14, a1, 0x290
42015e33:	30caa2        	addi	a10, a10, 48
42015e36:	0044a2        	s8i	a10, a4, 0
42015e39:	ee1b      	addi.n	a14, a14, 1
42015e3b:	04e616        	beqz	a6, 42015e8d <_svfiprintf_r+0x16e5>
42015e3e:	a02182        	l32i	a8, a1, 0x280
42015e41:	01af92        	movi	a9, -255
42015e44:	0008a2        	l8ui	a10, a8, 0
42015e47:	9a9a      	add.n	a9, a10, a9
42015e49:	040916        	beqz	a9, 42015e8d <_svfiprintf_r+0x16e5>
42015e4c:	3d9ae7        	bne	a10, a14, 42015e8d <_svfiprintf_r+0x16e5>
42015e4f:	63cc      	bnez.n	a3, 42015e59 <_svfiprintf_r+0x16b1>
42015e51:	990c      	movi.n	a9, 9
42015e53:	023957        	bltu	a9, a5, 42015e59 <_svfiprintf_r+0x16b1>
42015e56:	002c86        	j	42015f0c <_svfiprintf_r+0x1764>
42015e59:	a12182        	l32i	a8, a1, 0x284
42015e5c:	a321b2        	l32i	a11, a1, 0x28c
42015e5f:	c04480        	sub	a4, a4, a8
42015e62:	08cd      	mov.n	a12, a8
42015e64:	20a440        	or	a10, a4, a4
42015e67:	abd881        	l32r	a8, 42000dc8 <_stext+0xda8> (40001224 <strncpy>)
42015e6a:	0008e0        	callx8	a8
42015e6d:	a02182        	l32i	a8, a1, 0x280
42015e70:	010892        	l8ui	a9, a8, 1
42015e73:	398c      	beqz.n	a9, 42015e7a <_svfiprintf_r+0x16d2>
42015e75:	881b      	addi.n	a8, a8, 1
42015e77:	a06182        	s32i	a8, a1, 0x280
42015e7a:	ac0c      	movi.n	a12, 10
42015e7c:	0d0c      	movi.n	a13, 0
42015e7e:	05ad      	mov.n	a10, a5
42015e80:	03bd      	mov.n	a11, a3
42015e82:	a8c881        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42015e85:	0008e0        	callx8	a8
42015e88:	0e0c      	movi.n	a14, 0
42015e8a:	000706        	j	42015eaa <_svfiprintf_r+0x1702>
42015e8d:	a461e2        	s32i	a14, a1, 0x290
42015e90:	ac0c      	movi.n	a12, 10
42015e92:	0d0c      	movi.n	a13, 0
42015e94:	20a550        	or	a10, a5, a5
42015e97:	20b330        	or	a11, a3, a3
42015e9a:	a8c281        	l32r	a8, 420001a4 <_stext+0x184> (40002544 <__udivdi3>)
42015e9d:	0008e0        	callx8	a8
42015ea0:	a421e2        	l32i	a14, a1, 0x290
42015ea3:	33cc      	bnez.n	a3, 42015eaa <_svfiprintf_r+0x1702>
42015ea5:	990c      	movi.n	a9, 9
42015ea7:	61b957        	bgeu	a9, a5, 42015f0c <_svfiprintf_r+0x1764>
42015eaa:	0a5d      	mov.n	a5, a10
42015eac:	0b3d      	mov.n	a3, a11
42015eae:	048d      	mov.n	a8, a4
42015eb0:	ffda46        	j	42015e1d <_svfiprintf_r+0x1675>
42015eb3:	c19200        	mul16u	a9, a2, a0
42015eb6:	498a10        	s32e	a1, a10, -32
42015eb9:	a22182        	l32i	a8, a1, 0x288
42015ebc:	349050        	extui	a9, a5, 0, 4
42015ebf:	989a      	add.n	a9, a8, a9
42015ec1:	000992        	l8ui	a9, a9, 0
42015ec4:	404400        	ssai	4
42015ec7:	815350        	src	a5, a3, a5
42015eca:	440b      	addi.n	a4, a4, -1
42015ecc:	413430        	srli	a3, a3, 4
42015ecf:	004492        	s8i	a9, a4, 0
42015ed2:	209530        	or	a9, a5, a3
42015ed5:	fe0956        	bnez	a9, 42015eb9 <_svfiprintf_r+0x1711>
42015ed8:	000c06        	j	42015f0c <_svfiprintf_r+0x1764>
42015edb:	000000        	ill
42015ede:	080c      	movi.n	a8, 0
42015ee0:	9b6182        	s32i	a8, a1, 0x26c
42015ee3:	10c1b2        	addi	a11, a1, 16
42015ee6:	e4a182        	movi	a8, 0x1e4
42015ee9:	4b8a      	add.n	a4, a11, a8
42015eeb:	d9dc      	bnez.n	a9, 42015f0c <_svfiprintf_r+0x1764>
42015eed:	0480a0        	extui	a8, a10, 0, 1
42015ef0:	9b6182        	s32i	a8, a1, 0x26c
42015ef3:	9b2182        	l32i	a8, a1, 0x26c
42015ef6:	289c      	beqz.n	a8, 42015f0c <_svfiprintf_r+0x1764>
42015ef8:	01db82        	addmi	a8, a11, 0x100
42015efb:	093c      	movi.n	a9, 48
42015efd:	e34892        	s8i	a9, a8, 227
42015f00:	080c      	movi.n	a8, 0
42015f02:	9b6182        	s32i	a8, a1, 0x26c
42015f05:	0b9d      	mov.n	a9, a11
42015f07:	e3a182        	movi	a8, 0x1e3
42015f0a:	498a      	add.n	a4, a9, a8
42015f0c:	a52182        	l32i	a8, a1, 0x294
42015f0f:	9b2162        	l32i	a6, a1, 0x26c
42015f12:	c08840        	sub	a8, a8, a4
42015f15:	9b6182        	s32i	a8, a1, 0x26c
42015f18:	000886        	j	42015f3e <_svfiprintf_r+0x1796>
42015f1b:	841600        	extui	a1, a0, 6, 9
42015f1e:	10c1824e 	ee.vmulas.s16.qacc.ld.ip.qup	q0, a4, 32, q2, q1, q4, q1
42015f22:	01d892        	addmi	a9, a8, 0x100
42015f25:	804942        	s8i	a4, a9, 128
42015f28:	0a0c      	movi.n	a10, 0
42015f2a:	02d892        	addmi	a9, a8, 0x200
42015f2d:	3a49a2        	s8i	a10, a9, 58
42015f30:	067d      	mov.n	a7, a6
42015f32:	190c      	movi.n	a9, 1
42015f34:	9b6192        	s32i	a9, a1, 0x26c
42015f37:	80a192        	movi	a9, 0x180
42015f3a:	060c      	movi.n	a6, 0
42015f3c:	489a      	add.n	a4, a8, a9
42015f3e:	9b2182        	l32i	a8, a1, 0x26c
42015f41:	535680        	max	a5, a6, a8
42015f44:	10c182        	addi	a8, a1, 16
42015f47:	02d892        	addmi	a9, a8, 0x200
42015f4a:	3a0992        	l8ui	a9, a9, 58
42015f4d:	098c      	beqz.n	a9, 42015f51 <_svfiprintf_r+0x17a9>
42015f4f:	551b      	addi.n	a5, a5, 1
42015f51:	230c      	movi.n	a3, 2
42015f53:	103230        	and	a3, a2, a3
42015f56:	002316        	beqz	a3, 42015f5c <_svfiprintf_r+0x17b4>
42015f59:	02c552        	addi	a5, a5, 2
42015f5c:	84a082        	movi	a8, 132
42015f5f:	108280        	and	a8, a2, a8
42015f62:	a46182        	s32i	a8, a1, 0x290
42015f65:	0d5856        	bnez	a8, 4201603e <_svfiprintf_r+0x1896>
42015f68:	9e2182        	l32i	a8, a1, 0x278
42015f6b:	10c1e2        	addi	a14, a1, 16
42015f6e:	24a2c2        	movi	a12, 0x224
42015f71:	c09850        	sub	a9, a8, a5
42015f74:	ceca      	add.n	a12, a14, a12
42015f76:	5819e6        	bgei	a9, 1, 42015fd2 <_svfiprintf_r+0x182a>
42015f79:	003046        	j	4201603e <_svfiprintf_r+0x1896>
42015f7c:	982182        	l32i	a8, a1, 0x260
42015f7f:	ac0cf1        	l32r	a15, 42000fb0 <_stext+0xf90> (3c028d94 <blanks$1>)
42015f82:	0168d2        	s32i	a13, a8, 4
42015f85:	0068f2        	s32i	a15, a8, 0
42015f88:	972182        	l32i	a8, a1, 0x25c
42015f8b:	10c882        	addi	a8, a8, 16
42015f8e:	976182        	s32i	a8, a1, 0x25c
42015f91:	348ba6        	blti	a11, 8, 42015fc9 <_svfiprintf_r+0x1821>
42015f94:	8a6eb2        	s32i	a11, a14, 0x228
42015f97:	9d21a2        	l32i	a10, a1, 0x274
42015f9a:	9c21b2        	l32i	a11, a1, 0x270
42015f9d:	02ded2        	addmi	a13, a14, 0x200
42015fa0:	8b6e82        	s32i	a8, a14, 0x22c
42015fa3:	9761d2        	s32i	a13, a1, 0x25c
42015fa6:	986192        	s32i	a9, a1, 0x260
42015fa9:	fe6f25        	call8	4201469c <__ssprint_r>
42015fac:	9721d2        	l32i	a13, a1, 0x25c
42015faf:	bd88      	l32i.n	a8, a13, 44
42015fb1:	adb8      	l32i.n	a11, a13, 40
42015fb3:	976182        	s32i	a8, a1, 0x25c
42015fb6:	472a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42015fb9:	e4a1a2        	movi	a10, 0x1e4
42015fbc:	10c1e2        	addi	a14, a1, 16
42015fbf:	34a2c2        	movi	a12, 0x234
42015fc2:	982192        	l32i	a9, a1, 0x260
42015fc5:	aeaa      	add.n	a10, a14, a10
42015fc7:	cc1a      	add.n	a12, a12, a1
42015fc9:	f0c992        	addi	a9, a9, -16
42015fcc:	9961b2        	s32i	a11, a1, 0x264
42015fcf:	9861a2        	s32i	a10, a1, 0x260
42015fd2:	992182        	l32i	a8, a1, 0x264
42015fd5:	0d1c      	movi.n	a13, 16
42015fd7:	b81b      	addi.n	a11, a8, 1
42015fd9:	982182        	l32i	a8, a1, 0x260
42015fdc:	a88b      	addi.n	a10, a8, 8
42015fde:	9a2d97        	blt	a13, a9, 42015f7c <_svfiprintf_r+0x17d4>
42015fe1:	abf3c1        	l32r	a12, 42000fb0 <_stext+0xf90> (3c028d94 <blanks$1>)
42015fe4:	1899      	s32i.n	a9, a8, 4
42015fe6:	08c9      	s32i.n	a12, a8, 0
42015fe8:	972182        	l32i	a8, a1, 0x25c
42015feb:	808890        	add	a8, a8, a9
42015fee:	976182        	s32i	a8, a1, 0x25c
42015ff1:	992182        	l32i	a8, a1, 0x264
42015ff4:	4078a6        	blti	a8, 7, 42016038 <_svfiprintf_r+0x1890>
42015ff7:	9721a2        	l32i	a10, a1, 0x25c
42015ffa:	10c192        	addi	a9, a1, 16
42015ffd:	8e61b2        	s32i	a11, a1, 0x238
42016000:	8f61a2        	s32i	a10, a1, 0x23c
42016003:	9c21b2        	l32i	a11, a1, 0x270
42016006:	9d21a2        	l32i	a10, a1, 0x274
42016009:	24a2c2        	movi	a12, 0x224
4201600c:	02d982        	addmi	a8, a9, 0x200
4201600f:	80c9c0        	add	a12, a9, a12
42016012:	976182        	s32i	a8, a1, 0x25c
42016015:	fe6865        	call8	4201469c <__ssprint_r>
42016018:	972182        	l32i	a8, a1, 0x25c
4201601b:	a898      	l32i.n	a9, a8, 40
4201601d:	b888      	l32i.n	a8, a8, 44
4201601f:	996192        	s32i	a9, a1, 0x264
42016022:	976182        	s32i	a8, a1, 0x25c
42016025:	403a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42016028:	e4a1a2        	movi	a10, 0x1e4
4201602b:	10c192        	addi	a9, a1, 16
4201602e:	89aa      	add.n	a8, a9, a10
42016030:	986182        	s32i	a8, a1, 0x260
42016033:	0001c6        	j	4201603e <_svfiprintf_r+0x1896>
42016036:	b20000        	mulsh	a0, a0, a0
42016039:	a29961        	l32r	a6, 41ffeaa0 <_iram_bss_end+0x1c7c6a0>
4201603c:	829861        	l32r	a6, 41ff6a9c <_iram_bss_end+0x1c7469c>
4201603f:	8210c1        	l32r	a12, 41ff6880 <_iram_bss_end+0x1c74480>
42016042:	02d8      	l32i.n	a13, a2, 0
42016044:	3a0892        	l8ui	a9, a8, 58
42016047:	065916        	beqz	a9, 420160b0 <_svfiprintf_r+0x1908>
4201604a:	992192        	l32i	a9, a1, 0x264
4201604d:	10c1b2        	addi	a11, a1, 16
42016050:	a91b      	addi.n	a10, a9, 1
42016052:	3aa292        	movi	a9, 0x23a
42016055:	9b9a      	add.n	a9, a11, a9
42016057:	9821b2        	l32i	a11, a1, 0x260
4201605a:	0b99      	s32i.n	a9, a11, 0
4201605c:	190c      	movi.n	a9, 1
4201605e:	1b99      	s32i.n	a9, a11, 4
42016060:	972192        	l32i	a9, a1, 0x25c
42016063:	991b      	addi.n	a9, a9, 1
42016065:	976192        	s32i	a9, a1, 0x25c
42016068:	992192        	l32i	a9, a1, 0x264
4201606b:	0a79e6        	bgei	a9, 7, 42016079 <_svfiprintf_r+0x18d1>
4201606e:	8b8b      	addi.n	a8, a11, 8
42016070:	986182        	s32i	a8, a1, 0x260
42016073:	9961a2        	s32i	a10, a1, 0x264
42016076:	000d86        	j	420160b0 <_svfiprintf_r+0x1908>
42016079:	972192        	l32i	a9, a1, 0x25c
4201607c:	a8a9      	s32i.n	a10, a8, 40
4201607e:	b899      	s32i.n	a9, a8, 44
42016080:	976182        	s32i	a8, a1, 0x25c
42016083:	9c21b2        	l32i	a11, a1, 0x270
42016086:	10c182        	addi	a8, a1, 16
42016089:	9d21a2        	l32i	a10, a1, 0x274
4201608c:	24a2c2        	movi	a12, 0x224
4201608f:	80c8c0        	add	a12, a8, a12
42016092:	fe60a5        	call8	4201469c <__ssprint_r>
42016095:	972182        	l32i	a8, a1, 0x25c
42016098:	a898      	l32i.n	a9, a8, 40
4201609a:	b888      	l32i.n	a8, a8, 44
4201609c:	996192        	s32i	a9, a1, 0x264
4201609f:	976182        	s32i	a8, a1, 0x25c
420160a2:	386a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
420160a5:	e4a192        	movi	a9, 0x1e4
420160a8:	10c182        	addi	a8, a1, 16
420160ab:	889a      	add.n	a8, a8, a9
420160ad:	986182        	s32i	a8, a1, 0x260
420160b0:	068316        	beqz	a3, 4201611c <_svfiprintf_r+0x1974>
420160b3:	992182        	l32i	a8, a1, 0x264
420160b6:	38a292        	movi	a9, 0x238
420160b9:	a81b      	addi.n	a10, a8, 1
420160bb:	10c182        	addi	a8, a1, 16
420160be:	989a      	add.n	a9, a8, a9
420160c0:	982182        	l32i	a8, a1, 0x260
420160c3:	0899      	s32i.n	a9, a8, 0
420160c5:	290c      	movi.n	a9, 2
420160c7:	1899      	s32i.n	a9, a8, 4
420160c9:	972182        	l32i	a8, a1, 0x25c
420160cc:	882b      	addi.n	a8, a8, 2
420160ce:	976182        	s32i	a8, a1, 0x25c
420160d1:	992182        	l32i	a8, a1, 0x264
420160d4:	0d78e6        	bgei	a8, 7, 420160e5 <_svfiprintf_r+0x193d>
420160d7:	982182        	l32i	a8, a1, 0x260
420160da:	9961a2        	s32i	a10, a1, 0x264
420160dd:	888b      	addi.n	a8, a8, 8
420160df:	986182        	s32i	a8, a1, 0x260
420160e2:	000d86        	j	4201611c <_svfiprintf_r+0x1974>
420160e5:	10c182        	addi	a8, a1, 16
420160e8:	02d832        	addmi	a3, a8, 0x200
420160eb:	972182        	l32i	a8, a1, 0x25c
420160ee:	8e61a2        	s32i	a10, a1, 0x238
420160f1:	b389      	s32i.n	a8, a3, 44
420160f3:	9c21b2        	l32i	a11, a1, 0x270
420160f6:	10c182        	addi	a8, a1, 16
420160f9:	9d21a2        	l32i	a10, a1, 0x274
420160fc:	24a2c2        	movi	a12, 0x224
420160ff:	c8ca      	add.n	a12, a8, a12
42016101:	fe59a5        	call8	4201469c <__ssprint_r>
42016104:	a388      	l32i.n	a8, a3, 40
42016106:	996182        	s32i	a8, a1, 0x264
42016109:	b388      	l32i.n	a8, a3, 44
4201610b:	976182        	s32i	a8, a1, 0x25c
4201610e:	31aa56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42016111:	e4a192        	movi	a9, 0x1e4
42016114:	10c182        	addi	a8, a1, 16
42016117:	889a      	add.n	a8, a8, a9
42016119:	986182        	s32i	a8, a1, 0x260
4201611c:	a42182        	l32i	a8, a1, 0x290
4201611f:	02e826        	beqi	a8, 128, 42016125 <_svfiprintf_r+0x197d>
42016122:	003406        	j	420161f6 <_svfiprintf_r+0x1a4e>
42016125:	9e2182        	l32i	a8, a1, 0x278
42016128:	c08850        	sub	a8, a8, a5
4201612b:	0218e6        	bgei	a8, 1, 42016131 <_svfiprintf_r+0x1989>
4201612e:	003106        	j	420161f6 <_svfiprintf_r+0x1a4e>
42016131:	10c192        	addi	a9, a1, 16
42016134:	24a232        	movi	a3, 0x224
42016137:	a93a      	add.n	a10, a9, a3
42016139:	a461a2        	s32i	a10, a1, 0x290
4201613c:	001346        	j	4201618d <_svfiprintf_r+0x19e5>
4201613f:	21d200        	srai	a13, a0, 2
42016142:	e198      	l32i.n	a9, a1, 56
42016144:	ab9c      	beqz.n	a11, 42016162 <_svfiprintf_r+0x19ba>
42016146:	1dc9      	s32i.n	a12, a13, 4
42016148:	9721c2        	l32i	a12, a1, 0x25c
4201614b:	0de9      	s32i.n	a14, a13, 0
4201614d:	10ccc2        	addi	a12, a12, 16
42016150:	9761c2        	s32i	a12, a1, 0x25c
42016153:	2d8ba6        	blti	a11, 8, 42016184 <_svfiprintf_r+0x19dc>
42016156:	8a69b2        	s32i	a11, a9, 0x228
42016159:	8b69c2        	s32i	a12, a9, 0x22c
4201615c:	9c21b2        	l32i	a11, a1, 0x270
4201615f:	a421c2        	l32i	a12, a1, 0x290
42016162:	9d21a2        	l32i	a10, a1, 0x274
42016165:	02d932        	addmi	a3, a9, 0x200
42016168:	986182        	s32i	a8, a1, 0x260
4201616b:	fe5325        	call8	4201469c <__ssprint_r>
4201616e:	b388      	l32i.n	a8, a3, 44
42016170:	a3b8      	l32i.n	a11, a3, 40
42016172:	976182        	s32i	a8, a1, 0x25c
42016175:	2b3a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42016178:	e4a1a2        	movi	a10, 0x1e4
4201617b:	10c192        	addi	a9, a1, 16
4201617e:	982182        	l32i	a8, a1, 0x260
42016181:	80a9a0        	add	a10, a9, a10
42016184:	f0c882        	addi	a8, a8, -16
42016187:	9961b2        	s32i	a11, a1, 0x264
4201618a:	9861a2        	s32i	a10, a1, 0x260
4201618d:	9921a2        	l32i	a10, a1, 0x264
42016190:	0c1c      	movi.n	a12, 16
42016192:	ba1b      	addi.n	a11, a10, 1
42016194:	9821a2        	l32i	a10, a1, 0x260
42016197:	aa8b      	addi.n	a10, a10, 8
42016199:	a32c87        	blt	a12, a8, 42016140 <_svfiprintf_r+0x1998>
4201619c:	982192        	l32i	a9, a1, 0x260
4201619f:	ab85c1        	l32r	a12, 42000fb4 <_stext+0xf94> (3c028d84 <zeroes$0>)
420161a2:	1989      	s32i.n	a8, a9, 4
420161a4:	09c9      	s32i.n	a12, a9, 0
420161a6:	972192        	l32i	a9, a1, 0x25c
420161a9:	898a      	add.n	a8, a9, a8
420161ab:	976182        	s32i	a8, a1, 0x25c
420161ae:	992182        	l32i	a8, a1, 0x264
420161b1:	3b78a6        	blti	a8, 7, 420161f0 <_svfiprintf_r+0x1a48>
420161b4:	972192        	l32i	a9, a1, 0x25c
420161b7:	10c132        	addi	a3, a1, 16
420161ba:	8e61b2        	s32i	a11, a1, 0x238
420161bd:	9d21a2        	l32i	a10, a1, 0x274
420161c0:	9c21b2        	l32i	a11, a1, 0x270
420161c3:	24a2c2        	movi	a12, 0x224
420161c6:	02d382        	addmi	a8, a3, 0x200
420161c9:	c3ca      	add.n	a12, a3, a12
420161cb:	8f6192        	s32i	a9, a1, 0x23c
420161ce:	976182        	s32i	a8, a1, 0x25c
420161d1:	fe4ca5        	call8	4201469c <__ssprint_r>
420161d4:	972182        	l32i	a8, a1, 0x25c
420161d7:	a898      	l32i.n	a9, a8, 40
420161d9:	b888      	l32i.n	a8, a8, 44
420161db:	996192        	s32i	a9, a1, 0x264
420161de:	976182        	s32i	a8, a1, 0x25c
420161e1:	247a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
420161e4:	e4a192        	movi	a9, 0x1e4
420161e7:	839a      	add.n	a8, a3, a9
420161e9:	986182        	s32i	a8, a1, 0x260
420161ec:	000186        	j	420161f6 <_svfiprintf_r+0x1a4e>
420161ef:	61b200        	xsr.epc2	a0
420161f2:	a299      	s32i.n	a9, a2, 40
420161f4:	829861        	l32r	a6, 41ff6c54 <_iram_bss_end+0x1c74854>
420161f7:	809b21        	l32r	a2, 41ff6464 <_iram_bss_end+0x1c74064>
420161fa:	e6c066        	bnei	a0, 32, 420161e4 <_svfiprintf_r+0x1a3c>
420161fd:	060216        	beqz	a2, 42016261 <_svfiprintf_r+0x1ab9>
42016200:	a232002f 	ee.fft.ams.s16.st.incp	q3, q4, a2, a0, q2, q4, q0, 0
42016204:	c18224        	ee.ld.128.usar.ip	q1, a2, 0xfffff820
42016207:	10          	.byte	0x10
42016208:	c83a      	add.n	a12, a8, a3
4201620a:	0013c6        	j	4201625d <_svfiprintf_r+0x1ab5>
4201620d:	982182        	l32i	a8, a1, 0x260
42016210:	ab69d1        	l32r	a13, 42000fb4 <_stext+0xf94> (3c028d84 <zeroes$0>)
42016213:	18a9      	s32i.n	a10, a8, 4
42016215:	08d9      	s32i.n	a13, a8, 0
42016217:	972182        	l32i	a8, a1, 0x25c
4201621a:	10c882        	addi	a8, a8, 16
4201621d:	976182        	s32i	a8, a1, 0x25c
42016220:	308ba6        	blti	a11, 8, 42016254 <_svfiprintf_r+0x1aac>
42016223:	10c182        	addi	a8, a1, 16
42016226:	02d832        	addmi	a3, a8, 0x200
42016229:	972182        	l32i	a8, a1, 0x25c
4201622c:	8e61b2        	s32i	a11, a1, 0x238
4201622f:	9d21a2        	l32i	a10, a1, 0x274
42016232:	9c21b2        	l32i	a11, a1, 0x270
42016235:	0b6382        	s32i	a8, a3, 44
42016238:	9861c2        	s32i	a12, a1, 0x260
4201623b:	fe4625        	call8	4201469c <__ssprint_r>
4201623e:	b388      	l32i.n	a8, a3, 44
42016240:	a3b8      	l32i.n	a11, a3, 40
42016242:	976182        	s32i	a8, a1, 0x25c
42016245:	1e3a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42016248:	e4a192        	movi	a9, 0x1e4
4201624b:	10c182        	addi	a8, a1, 16
4201624e:	9821c2        	l32i	a12, a1, 0x260
42016251:	809890        	add	a9, a8, a9
42016254:	f0c662        	addi	a6, a6, -16
42016257:	9961b2        	s32i	a11, a1, 0x264
4201625a:	986192        	s32i	a9, a1, 0x260
4201625d:	992182        	l32i	a8, a1, 0x264
42016260:	0a1c      	movi.n	a10, 16
42016262:	b81b      	addi.n	a11, a8, 1
42016264:	982182        	l32i	a8, a1, 0x260
42016267:	988b      	addi.n	a9, a8, 8
42016269:	a02a67        	blt	a10, a6, 4201620d <_svfiprintf_r+0x1a65>
4201626c:	ab52a1        	l32r	a10, 42000fb4 <_stext+0xf94> (3c028d84 <zeroes$0>)
4201626f:	1869      	s32i.n	a6, a8, 4
42016271:	08a9      	s32i.n	a10, a8, 0
42016273:	972182        	l32i	a8, a1, 0x25c
42016276:	886a      	add.n	a8, a8, a6
42016278:	976182        	s32i	a8, a1, 0x25c
4201627b:	992182        	l32i	a8, a1, 0x264
4201627e:	3778a6        	blti	a8, 7, 420162b9 <_svfiprintf_r+0x1b11>
42016281:	972182        	l32i	a8, a1, 0x25c
42016284:	10c132        	addi	a3, a1, 16
42016287:	8e61b2        	s32i	a11, a1, 0x238
4201628a:	9d21a2        	l32i	a10, a1, 0x274
4201628d:	9c21b2        	l32i	a11, a1, 0x270
42016290:	24a2c2        	movi	a12, 0x224
42016293:	80c3c0        	add	a12, a3, a12
42016296:	8f6182        	s32i	a8, a1, 0x23c
42016299:	fe4025        	call8	4201469c <__ssprint_r>
4201629c:	8e2182        	l32i	a8, a1, 0x238
4201629f:	02d362        	addmi	a6, a3, 0x200
420162a2:	996182        	s32i	a8, a1, 0x264
420162a5:	8f2182        	l32i	a8, a1, 0x23c
420162a8:	976182        	s32i	a8, a1, 0x25c
420162ab:	17da56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
420162ae:	e4a192        	movi	a9, 0x1e4
420162b1:	839a      	add.n	a8, a3, a9
420162b3:	986182        	s32i	a8, a1, 0x260
420162b6:	000146        	j	420162bf <_svfiprintf_r+0x1b17>
420162b9:	9961b2        	s32i	a11, a1, 0x264
420162bc:	986192        	s32i	a9, a1, 0x260
420162bf:	982182        	l32i	a8, a1, 0x260
420162c2:	9b2192        	l32i	a9, a1, 0x26c
420162c5:	0849      	s32i.n	a4, a8, 0
420162c7:	1899      	s32i.n	a9, a8, 4
420162c9:	972182        	l32i	a8, a1, 0x25c
420162cc:	889a      	add.n	a8, a8, a9
420162ce:	976182        	s32i	a8, a1, 0x25c
420162d1:	992182        	l32i	a8, a1, 0x264
420162d4:	981b      	addi.n	a9, a8, 1
420162d6:	982182        	l32i	a8, a1, 0x260
420162d9:	888b      	addi.n	a8, a8, 8
420162db:	3189a6        	blti	a9, 8, 42016310 <_svfiprintf_r+0x1b68>
420162de:	10c182        	addi	a8, a1, 16
420162e1:	02d862        	addmi	a6, a8, 0x200
420162e4:	972182        	l32i	a8, a1, 0x25c
420162e7:	9c21b2        	l32i	a11, a1, 0x270
420162ea:	b689      	s32i.n	a8, a6, 44
420162ec:	9d21a2        	l32i	a10, a1, 0x274
420162ef:	10c182        	addi	a8, a1, 16
420162f2:	24a2c2        	movi	a12, 0x224
420162f5:	80c8c0        	add	a12, a8, a12
420162f8:	8e6192        	s32i	a9, a1, 0x238
420162fb:	fe3a25        	call8	4201469c <__ssprint_r>
420162fe:	b688      	l32i.n	a8, a6, 44
42016300:	a698      	l32i.n	a9, a6, 40
42016302:	976182        	s32i	a8, a1, 0x25c
42016305:	123a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42016308:	e4a182        	movi	a8, 0x1e4
4201630b:	10c1a2        	addi	a10, a1, 16
4201630e:	8a8a      	add.n	a8, a10, a8
42016310:	02e227        	bbsi	a2, 2, 42016316 <_svfiprintf_r+0x1b6e>
42016313:	002846        	j	420163b8 <_svfiprintf_r+0x1c10>
42016316:	9e21a2        	l32i	a10, a1, 0x278
42016319:	c03a50        	sub	a3, a10, a5
4201631c:	0213e6        	bgei	a3, 1, 42016322 <_svfiprintf_r+0x1b7a>
4201631f:	002546        	j	420163b8 <_svfiprintf_r+0x1c10>
42016322:	10c122        	addi	a2, a1, 16
42016325:	24a242        	movi	a4, 0x224
42016328:	424a      	add.n	a4, a2, a4
4201632a:	001106        	j	42016372 <_svfiprintf_r+0x1bca>
4201632d:	ab2091        	l32r	a9, 42000fb0 <_stext+0xf90> (3c028d94 <blanks$1>)
42016330:	18a9      	s32i.n	a10, a8, 4
42016332:	0899      	s32i.n	a9, a8, 0
42016334:	972192        	l32i	a9, a1, 0x25c
42016337:	08c882        	addi	a8, a8, 8
4201633a:	10c992        	addi	a9, a9, 16
4201633d:	976192        	s32i	a9, a1, 0x25c
42016340:	298ba6        	blti	a11, 8, 4201636d <_svfiprintf_r+0x1bc5>
42016343:	972182        	l32i	a8, a1, 0x25c
42016346:	8a62b2        	s32i	a11, a2, 0x228
42016349:	9d21a2        	l32i	a10, a1, 0x274
4201634c:	9c21b2        	l32i	a11, a1, 0x270
4201634f:	8b6282        	s32i	a8, a2, 0x22c
42016352:	20c440        	or	a12, a4, a4
42016355:	fe3465        	call8	4201469c <__ssprint_r>
42016358:	8b2282        	l32i	a8, a2, 0x22c
4201635b:	8a22b2        	l32i	a11, a2, 0x228
4201635e:	976182        	s32i	a8, a1, 0x25c
42016361:	02d262        	addmi	a6, a2, 0x200
42016364:	0c4a56        	bnez	a10, 4201642c <_svfiprintf_r+0x1c84>
42016367:	e4a182        	movi	a8, 0x1e4
4201636a:	808280        	add	a8, a2, a8
4201636d:	f0c332        	addi	a3, a3, -16
42016370:	0b9d      	mov.n	a9, a11
42016372:	0a1c      	movi.n	a10, 16
42016374:	b91b      	addi.n	a11, a9, 1
42016376:	b32a37        	blt	a10, a3, 4201632d <_svfiprintf_r+0x1b85>
42016379:	ab0da1        	l32r	a10, 42000fb0 <_stext+0xf90> (3c028d94 <blanks$1>)
4201637c:	1839      	s32i.n	a3, a8, 4
4201637e:	08a9      	s32i.n	a10, a8, 0
42016380:	972182        	l32i	a8, a1, 0x25c
42016383:	883a      	add.n	a8, a8, a3
42016385:	976182        	s32i	a8, a1, 0x25c
42016388:	2a79a6        	blti	a9, 7, 420163b6 <_svfiprintf_r+0x1c0e>
4201638b:	10c182        	addi	a8, a1, 16
4201638e:	972192        	l32i	a9, a1, 0x25c
42016391:	8e61b2        	s32i	a11, a1, 0x238
42016394:	9d21a2        	l32i	a10, a1, 0x274
42016397:	9c21b2        	l32i	a11, a1, 0x270
4201639a:	24a2c2        	movi	a12, 0x224
4201639d:	c8ca      	add.n	a12, a8, a12
4201639f:	02d862        	addmi	a6, a8, 0x200
420163a2:	8f6192        	s32i	a9, a1, 0x23c
420163a5:	fe2f65        	call8	4201469c <__ssprint_r>
420163a8:	b688      	l32i.n	a8, a6, 44
420163aa:	a698      	l32i.n	a9, a6, 40
420163ac:	976182        	s32i	a8, a1, 0x25c
420163af:	5a8c      	beqz.n	a10, 420163b8 <_svfiprintf_r+0x1c10>
420163b1:	001dc6        	j	4201642c <_svfiprintf_r+0x1c84>
420163b4:	00          	.byte	00
420163b5:	00          	.byte	00
420163b6:	0b9d      	mov.n	a9, a11
420163b8:	9e2182        	l32i	a8, a1, 0x278
420163bb:	535850        	max	a5, a8, a5
420163be:	9f2182        	l32i	a8, a1, 0x27c
420163c1:	885a      	add.n	a8, a8, a5
420163c3:	9f6182        	s32i	a8, a1, 0x27c
420163c6:	972182        	l32i	a8, a1, 0x25c
420163c9:	48ac      	beqz.n	a8, 420163f1 <_svfiprintf_r+0x1c49>
420163cb:	10c182        	addi	a8, a1, 16
420163ce:	02d862        	addmi	a6, a8, 0x200
420163d1:	972182        	l32i	a8, a1, 0x25c
420163d4:	9c21b2        	l32i	a11, a1, 0x270
420163d7:	b689      	s32i.n	a8, a6, 44
420163d9:	9d21a2        	l32i	a10, a1, 0x274
420163dc:	10c182        	addi	a8, a1, 16
420163df:	24a2c2        	movi	a12, 0x224
420163e2:	c8ca      	add.n	a12, a8, a12
420163e4:	8e6192        	s32i	a9, a1, 0x238
420163e7:	fe2b65        	call8	4201469c <__ssprint_r>
420163ea:	b688      	l32i.n	a8, a6, 44
420163ec:	976182        	s32i	a8, a1, 0x25c
420163ef:	9afc      	bnez.n	a10, 4201642c <_svfiprintf_r+0x1c84>
420163f1:	080c      	movi.n	a8, 0
420163f3:	996182        	s32i	a8, a1, 0x264
420163f6:	10c192        	addi	a9, a1, 16
420163f9:	e4a182        	movi	a8, 0x1e4
420163fc:	898a      	add.n	a8, a9, a8
420163fe:	076d      	mov.n	a6, a7
42016400:	986182        	s32i	a8, a1, 0x260
42016403:	f90946        	j	4201482c <_svfiprintf_r+0x84>
42016406:	820000        	mull	a0, a0, a0
42016409:	169721        	l32r	a2, 41fdbe68 <_iram_bss_end+0x1c59a68>
4201640c:	01d8      	l32i.n	a13, a1, 0
4201640e:	9921a2        	l32i	a10, a1, 0x264
42016411:	10c182        	addi	a8, a1, 16
42016414:	8e61a2        	s32i	a10, a1, 0x238
42016417:	9721a2        	l32i	a10, a1, 0x25c
4201641a:	24a2c2        	movi	a12, 0x224
4201641d:	8f61a2        	s32i	a10, a1, 0x23c
42016420:	9c21b2        	l32i	a11, a1, 0x270
42016423:	9d21a2        	l32i	a10, a1, 0x274
42016426:	80c8c0        	add	a12, a8, a12
42016429:	fe2725        	call8	4201469c <__ssprint_r>
4201642c:	9c2182        	l32i	a8, a1, 0x270
4201642f:	061882        	l16ui	a8, a8, 12
42016432:	166867        	bbci	a8, 6, 4201644c <_svfiprintf_r+0x1ca4>
42016435:	f87c      	movi.n	a8, -1
42016437:	9f6182        	s32i	a8, a1, 0x27c
4201643a:	000386        	j	4201644c <_svfiprintf_r+0x1ca4>
4201643d:	9b2182        	l32i	a8, a1, 0x26c
42016440:	02ad      	mov.n	a10, a2
42016442:	190c      	movi.n	a9, 1
42016444:	94d8d6        	bgez	a8, 42015d95 <_svfiprintf_r+0x15ed>
42016447:	fe6ac6        	j	42015df6 <_svfiprintf_r+0x164e>
4201644a:	220000        	orb	b0, b0, b0
4201644d:	1d9f21        	l32r	a2, 41fddacc <_iram_bss_end+0x1c5b6cc>
42016450:	0000f0        	callx12	a0
	...

42016454 <_mbtowc_r>:
42016454:	004136        	entry	a1, 32
42016457:	aaaf81        	l32r	a8, 42000f14 <_stext+0xef4> (3fc92ba4 <__global_locale_ptr>)
4201645a:	02ad      	mov.n	a10, a2
4201645c:	0888      	l32i.n	a8, a8, 0
4201645e:	03bd      	mov.n	a11, a3
42016460:	392882        	l32i	a8, a8, 228
42016463:	04cd      	mov.n	a12, a4
42016465:	05dd      	mov.n	a13, a5
42016467:	06ed      	mov.n	a14, a6
42016469:	0008e0        	callx8	a8
4201646c:	0a2d      	mov.n	a2, a10
4201646e:	f01d      	retw.n

42016470 <__ascii_mbtowc>:
42016470:	006136        	entry	a1, 48
42016473:	038d      	mov.n	a8, a3
42016475:	838130        	moveqz	a8, a1, a3
42016478:	020c      	movi.n	a2, 0
4201647a:	049c      	beqz.n	a4, 4201648e <__ascii_mbtowc+0x1e>
4201647c:	e27c      	movi.n	a2, -2
4201647e:	c58c      	beqz.n	a5, 4201648e <__ascii_mbtowc+0x1e>
42016480:	000492        	l8ui	a9, a4, 0
42016483:	120c      	movi.n	a2, 1
42016485:	005892        	s16i	a9, a8, 0
42016488:	000482        	l8ui	a8, a4, 0
4201648b:	832880        	moveqz	a2, a8, a8
4201648e:	f01d      	retw.n

42016490 <_wctomb_r>:
42016490:	004136        	entry	a1, 32
42016493:	aaa081        	l32r	a8, 42000f14 <_stext+0xef4> (3fc92ba4 <__global_locale_ptr>)
42016496:	02ad      	mov.n	a10, a2
42016498:	0888      	l32i.n	a8, a8, 0
4201649a:	03bd      	mov.n	a11, a3
4201649c:	382882        	l32i	a8, a8, 224
4201649f:	20d550        	or	a13, a5, a5
420164a2:	f4c040        	extui	a12, a4, 0, 16
420164a5:	0008e0        	callx8	a8
420164a8:	0a2d      	mov.n	a2, a10
420164aa:	f01d      	retw.n

420164ac <__ascii_wctomb>:
420164ac:	004136        	entry	a1, 32
420164af:	028d      	mov.n	a8, a2
420164b1:	f44040        	extui	a4, a4, 0, 16
420164b4:	020c      	movi.n	a2, 0
420164b6:	339c      	beqz.n	a3, 420164cd <__ascii_wctomb+0x21>
420164b8:	ffa092        	movi	a9, 255
420164bb:	09b947        	bgeu	a9, a4, 420164c8 <__ascii_wctomb+0x1c>
420164be:	8aa092        	movi	a9, 138
420164c1:	0899      	s32i.n	a9, a8, 0
420164c3:	f27c      	movi.n	a2, -1
420164c5:	000106        	j	420164cd <__ascii_wctomb+0x21>
420164c8:	004342        	s8i	a4, a3, 0
420164cb:	120c      	movi.n	a2, 1
420164cd:	f01d      	retw.n
	...

420164d0 <init_efuse_secure>:
{
420164d0:	004136        	entry	a1, 32
}
420164d3:	020c      	movi.n	a2, 0
420164d5:	f01d      	retw.n
	...

420164d8 <esp_efuse_startup_include_func>:

void esp_efuse_startup_include_func(void)
{
420164d8:	004136        	entry	a1, 32
    // Hook to force the linker to include this file
}
420164db:	f01d      	retw.n
420164dd:	000000        	ill

420164e0 <esp_efuse_utility_check_errors>:
    efuse_hal_read();
    efuse_hal_clear_program_registers();
}

esp_err_t esp_efuse_utility_check_errors(void)
{
420164e0:	004136        	entry	a1, 32
    return ESP_OK;
}
420164e3:	020c      	movi.n	a2, 0
420164e5:	f01d      	retw.n
	...

420164e8 <esp_timer_init_include_func>:

void esp_timer_init_include_func(void)
{
420164e8:	004136        	entry	a1, 32
    // Hook to force the linker to include this file
}
420164eb:	f01d      	retw.n
420164ed:	000000        	ill

420164f0 <esp_system_include_startup_funcs>:
{
420164f0:	004136        	entry	a1, 32
}
420164f3:	f01d      	retw.n
420164f5:	000000        	ill

420164f8 <get_cache_error>:
{
420164f8:	004136        	entry	a1, 32
    for (int i = 0; i < size; i++) {
420164fb:	090c      	movi.n	a9, 0
420164fd:	000a86        	j	4201652b <get_cache_error+0x33>
42016500:	00          	.byte	00
        const uint32_t bit = reg_bits[i].bit;
42016501:	1189c0        	slli	a8, a9, 4
42016504:	838a      	add.n	a8, a3, a8
42016506:	08a8      	l32i.n	a10, a8, 0
        if ((status & bit) == bit) {
42016508:	1dc2a7        	bnall	a2, a10, 42016529 <get_cache_error+0x31>
            err_info->err_str = reg_bits[i].msg;
4201650b:	1898      	l32i.n	a9, a8, 4
4201650d:	0599      	s32i.n	a9, a5, 0
            err_info->vaddr = reg_bits[i].fault_addr_reg ? REG_READ(reg_bits[i].fault_addr_reg) : 0;
4201650f:	2898      	l32i.n	a9, a8, 8
42016511:	498c      	beqz.n	a9, 42016519 <get_cache_error+0x21>
42016513:	0020c0        	memw
42016516:	002992        	l32i	a9, a9, 0
42016519:	1599      	s32i.n	a9, a5, 4
            err_info->size = reg_bits[i].fault_size_reg ? REG_READ(reg_bits[i].fault_size_reg) : 0;
4201651b:	3888      	l32i.n	a8, a8, 12
4201651d:	388c      	beqz.n	a8, 42016524 <get_cache_error+0x2c>
4201651f:	0020c0        	memw
42016522:	0888      	l32i.n	a8, a8, 0
42016524:	2589      	s32i.n	a8, a5, 8
            return;
42016526:	000106        	j	4201652e <get_cache_error+0x36>
    for (int i = 0; i < size; i++) {
42016529:	991b      	addi.n	a9, a9, 1
4201652b:	d23947        	bltu	a9, a4, 42016501 <get_cache_error+0x9>
}
4201652e:	f01d      	retw.n

42016530 <panic_soc_check_pseudo_cause>:
{
42016530:	004136        	entry	a1, 32
}
42016533:	020c      	movi.n	a2, 0
42016535:	f01d      	retw.n
	...

42016538 <panic_get_address>:
{
42016538:	004136        	entry	a1, 32
}
4201653b:	1228      	l32i.n	a2, a2, 4
4201653d:	f01d      	retw.n
	...

42016540 <panic_get_cause>:
{
42016540:	004136        	entry	a1, 32
}
42016543:	142222        	l32i	a2, a2, 80
42016546:	f01d      	retw.n

42016548 <panic_set_address>:
{
42016548:	004136        	entry	a1, 32
    ((XtExcFrame *)f)->pc = addr;
4201654b:	1239      	s32i.n	a3, a2, 4
}
4201654d:	f01d      	retw.n
	...

42016550 <uart_hal_write_txfifo>:
{
    uart_ll_tx_break(hal->dev, break_num);
}

void uart_hal_write_txfifo(uart_hal_context_t *hal, const uint8_t *buf, uint32_t data_size, uint32_t *write_size)
{
42016550:	004136        	entry	a1, 32
    uint16_t fill_len = uart_ll_get_txfifo_len(hal->dev);
42016553:	0288      	l32i.n	a8, a2, 0
42016555:	0020c0        	memw
42016558:	072882        	l32i	a8, a8, 28
4201655b:	958080        	extui	a8, a8, 16, 10
4201655e:	80c882        	addi	a8, a8, -128
42016561:	608080        	neg	a8, a8
42016564:	f4a080        	extui	a10, a8, 0, 16
    if (fill_len > data_size) {
42016567:	f48080        	extui	a8, a8, 0, 16
4201656a:	02b487        	bgeu	a4, a8, 42016570 <uart_hal_write_txfifo+0x20>
        fill_len = data_size;
4201656d:	f4a040        	extui	a10, a4, 0, 16
    }
    *write_size = fill_len;
42016570:	05a9      	s32i.n	a10, a5, 0
    uart_ll_write_txfifo(hal->dev, buf, fill_len);
42016572:	02b8      	l32i.n	a11, a2, 0
    for (int i = 0; i < (int)wr_len; i++) {
42016574:	080c      	movi.n	a8, 0
42016576:	0002c6        	j	42016585 <uart_hal_write_txfifo+0x35>
        hw->fifo.val = (int)buf[i];
42016579:	938a      	add.n	a9, a3, a8
4201657b:	000992        	l8ui	a9, a9, 0
4201657e:	0020c0        	memw
42016581:	0b99      	s32i.n	a9, a11, 0
    for (int i = 0; i < (int)wr_len; i++) {
42016583:	881b      	addi.n	a8, a8, 1
42016585:	f028a7        	blt	a8, a10, 42016579 <uart_hal_write_txfifo+0x29>
}
42016588:	f01d      	retw.n
	...

4201658c <heap_caps_match>:
{
4201658c:	004136        	entry	a1, 32
    return heap->heap != NULL && ((get_all_caps(heap) & caps) == caps);
4201658f:	7288      	l32i.n	a8, a2, 28
42016591:	c89c      	beqz.n	a8, 420165b1 <heap_caps_match+0x25>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
42016593:	080c      	movi.n	a8, 0
    uint32_t all_caps = 0;
42016595:	089d      	mov.n	a9, a8
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
42016597:	0002c6        	j	420165a6 <heap_caps_match+0x1a>
4201659a:	200000        	or	a0, a0, a0
        all_caps |= caps[prio];
4201659d:	a0a8      	l32i.n	a10, a0, 40
4201659f:	0aa8      	l32i.n	a10, a10, 0
420165a1:	2099a0        	or	a9, a9, a10
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
420165a4:	881b      	addi.n	a8, a8, 1
420165a6:	f238a6        	blti	a8, 3, 4201659c <heap_caps_match+0x10>
420165a9:	09c937        	bnall	a9, a3, 420165b6 <heap_caps_match+0x2a>
420165ac:	120c      	movi.n	a2, 1
420165ae:	000186        	j	420165b8 <heap_caps_match+0x2c>
420165b1:	020c      	movi.n	a2, 0
420165b3:	000046        	j	420165b8 <heap_caps_match+0x2c>
420165b6:	020c      	movi.n	a2, 0
}
420165b8:	f01d      	retw.n
	...

420165bc <s_compare_reserved_regions>:
{
420165bc:	004136        	entry	a1, 32
    return (int)r_a->start - (int)r_b->start;
420165bf:	0228      	l32i.n	a2, a2, 0
420165c1:	0388      	l32i.n	a8, a3, 0
}
420165c3:	c02280        	sub	a2, a2, a8
420165c6:	f01d      	retw.n

420165c8 <__esp_system_init_fn_esp_security_init>:
    };
#endif /* SOC_KEY_MANAGER_ECDSA_KEY_DEPLOY || SOC_KEY_MANAGER_FE_KEY_DEPLOY */
}

ESP_SYSTEM_INIT_FN(esp_security_init, SECONDARY, BIT(0), 103)
{
420165c8:	004136        	entry	a1, 32
        return err;
    }
#endif

    return ESP_OK;
}
420165cb:	020c      	movi.n	a2, 0
420165cd:	f01d      	retw.n
	...

420165d0 <esp_security_init_include_impl>:

void esp_security_init_include_impl(void)
{
420165d0:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
420165d3:	f01d      	retw.n
420165d5:	000000        	ill

420165d8 <esp_intr_get_cpu>:
{
420165d8:	004136        	entry	a1, 32
    if (handle == NULL || handle->vector_desc == NULL) {
420165db:	a28c      	beqz.n	a2, 420165e9 <esp_intr_get_cpu+0x11>
420165dd:	0288      	l32i.n	a8, a2, 0
420165df:	b88c      	beqz.n	a8, 420165ee <esp_intr_get_cpu+0x16>
    return handle->vector_desc->cpu;
420165e1:	0828      	l32i.n	a2, a8, 0
420165e3:	052020        	extui	a2, a2, 16, 1
420165e6:	000186        	j	420165f0 <esp_intr_get_cpu+0x18>
        return -1;
420165e9:	f27c      	movi.n	a2, -1
420165eb:	000046        	j	420165f0 <esp_intr_get_cpu+0x18>
420165ee:	f27c      	movi.n	a2, -1
}
420165f0:	f01d      	retw.n
	...

420165f4 <esp_sleep_gpio_include>:

void esp_sleep_gpio_include(void)
{
420165f4:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
420165f7:	f01d      	retw.n
420165f9:	000000        	ill

420165fc <esp_libc_init_funcs>:

// Hook to force the linker to include this file
void esp_libc_init_funcs(void)
{
420165fc:	004136        	entry	a1, 32
}
420165ff:	f01d      	retw.n
42016601:	000000        	ill

42016604 <esp_libc_include_pthread_impl>:
    }
    return 0;
}

void esp_libc_include_pthread_impl(void)
{
42016604:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
42016607:	f01d      	retw.n
42016609:	000000        	ill

4201660c <esp_libc_include_getentropy_impl>:

    return 0;
}

void esp_libc_include_getentropy_impl(void)
{
4201660c:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
4201660f:	f01d      	retw.n
42016611:	000000        	ill

42016614 <esp_libc_include_syscalls_impl>:
{
    return _system_r(__getreent(), str);
}

void esp_libc_include_syscalls_impl(void)
{
42016614:	004136        	entry	a1, 32
}
42016617:	f01d      	retw.n
42016619:	000000        	ill

4201661c <_getpid_r>:
{
4201661c:	004136        	entry	a1, 32
    __errno_r(r) = ENOSYS;
4201661f:	885c      	movi.n	a8, 88
42016621:	0289      	s32i.n	a8, a2, 0
}
42016623:	f27c      	movi.n	a2, -1
42016625:	f01d      	retw.n
	...

42016628 <esp_libc_include_reent_syscalls_impl>:

/* No-op function, used to force linking this file,
   instead of the syscalls implementation from libgloss.
 */
void esp_libc_include_reent_syscalls_impl(void)
{
42016628:	004136        	entry	a1, 32
}
4201662b:	f01d      	retw.n
4201662d:	000000        	ill

42016630 <esp_libc_include_init_funcs>:
#endif /* CONFIG_VFS_SUPPORT_IO */

// Hook to force the linker to include this file
void esp_libc_include_init_funcs(void)
{
42016630:	004136        	entry	a1, 32
}
42016633:	f01d      	retw.n
42016635:	000000        	ill

42016638 <pthread_include_pthread_impl>:
    return configMAX_PRIORITIES - 1;
}

/* Hook function to force linking this file */
void pthread_include_pthread_impl(void)
{
42016638:	004136        	entry	a1, 32
}
4201663b:	f01d      	retw.n
4201663d:	000000        	ill

42016640 <pthread_include_pthread_cond_var_impl>:
    return ret;
}

/* Hook function to force linking this file */
void pthread_include_pthread_cond_var_impl(void)
{
42016640:	004136        	entry	a1, 32
}
42016643:	f01d      	retw.n
42016645:	000000        	ill

42016648 <pthread_include_pthread_local_storage_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_local_storage_impl(void)
{
42016648:	004136        	entry	a1, 32
}
4201664b:	f01d      	retw.n
4201664d:	000000        	ill

42016650 <pthread_include_pthread_rwlock_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_rwlock_impl(void)
{
42016650:	004136        	entry	a1, 32
}
42016653:	f01d      	retw.n
42016655:	000000        	ill

42016658 <pthread_include_pthread_semaphore_impl>:
    *sval = uxSemaphoreGetCount(freertos_semaphore);
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_semaphore_impl(void) { }
42016658:	004136        	entry	a1, 32
4201665b:	f01d      	retw.n
4201665d:	000000        	ill

42016660 <__cxa_guard_dummy>:
/**
 * Dummy function used to force linking this file instead of the same one in libstdc++.
 * This works via -u __cxa_guard_dummy flag in component.mk
 */
extern "C" void __cxa_guard_dummy(void)
{
42016660:	004136        	entry	a1, 32
}
42016663:	f01d      	retw.n
42016665:	000000        	ill

42016668 <__cxx_init_dummy>:
/**
 * Dummy function used to force linking this file.
 * This works via -u __cxx_init_dummy flag in CMakeLists.txt
 */
extern "C" void __cxx_init_dummy(void)
{
42016668:	004136        	entry	a1, 32
}
4201666b:	f01d      	retw.n
4201666d:	000000        	ill

42016670 <usb_serial_jtag_connection_monitor_include>:

void usb_serial_jtag_connection_monitor_include(void)
{
42016670:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this file
}
42016673:	f01d      	retw.n
42016675:	000000        	ill

42016678 <scalar_add_scalar_f32>:
vector_status_t scalar_add_scalar_f32(const vector_t *vec1, const float scalar, vector_t *result) { 
42016678:	004136        	entry	a1, 32
4201667b:	fa1350        	wfr	f1, a3
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
4201667e:	2298      	l32i.n	a9, a2, 8
42016680:	2488      	l32i.n	a8, a4, 8
42016682:	309987        	bne	a9, a8, 420166b6 <scalar_add_scalar_f32+0x3e>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
42016685:	1288      	l32i.n	a8, a2, 4
42016687:	1498      	l32i.n	a9, a4, 4
42016689:	2f9897        	bne	a8, a9, 420166bc <scalar_add_scalar_f32+0x44>
    switch (vec1->type) {
4201668c:	3138b6        	bltui	a8, 3, 420166c1 <scalar_add_scalar_f32+0x49>
4201668f:	333866        	bnei	a8, 3, 420166c6 <scalar_add_scalar_f32+0x4e>
            float* vec1_data = (float*)(vec1->data); 
42016692:	02b8      	l32i.n	a11, a2, 0
            float* result_data = (float*)(result->data); 
42016694:	04a8      	l32i.n	a10, a4, 0
            for (int i = 0; i < vec1->size; i++){ 
42016696:	080c      	movi.n	a8, 0
42016698:	000406        	j	420166ac <scalar_add_scalar_f32+0x34>
                result_data[i] = vec1_data[i] + scalar;
4201669b:	a098b0        	addx4	a9, a8, a11
4201669e:	000903        	lsi	f0, a9, 0
420166a1:	a098a0        	addx4	a9, a8, a10
420166a4:	0a0010        	add.s	f0, f0, f1
420166a7:	004903        	ssi	f0, a9, 0
            for (int i = 0; i < vec1->size; i++){ 
420166aa:	881b      	addi.n	a8, a8, 1
420166ac:	2298      	l32i.n	a9, a2, 8
420166ae:	e93897        	bltu	a8, a9, 4201669b <scalar_add_scalar_f32+0x23>
            return VECTOR_SUCCESS;
420166b1:	020c      	movi.n	a2, 0
420166b3:	000446        	j	420166c8 <scalar_add_scalar_f32+0x50>
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;} 
420166b6:	720c      	movi.n	a2, 7
420166b8:	000306        	j	420166c8 <scalar_add_scalar_f32+0x50>
420166bb:	820c00        	mull	a0, a12, a0
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}
420166be:	000186        	j	420166c8 <scalar_add_scalar_f32+0x50>
    switch (vec1->type) {
420166c1:	420c      	movi.n	a2, 4
420166c3:	000046        	j	420166c8 <scalar_add_scalar_f32+0x50>
            return VECTOR_ERROR; 
420166c6:	320c      	movi.n	a2, 3
}
420166c8:	f01d      	retw.n
	...

420166cc <scalar_mul>:
vector_status_t scalar_mul(const vector_t *vec1, const vector_t *vec2, vector_t *result, const unsigned int shift_amount) { 
420166cc:	004136        	entry	a1, 32
420166cf:	028d      	mov.n	a8, a2
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
420166d1:	2298      	l32i.n	a9, a2, 8
420166d3:	23a8      	l32i.n	a10, a3, 8
420166d5:	0219a7        	beq	a9, a10, 420166db <scalar_mul+0xf>
420166d8:	005046        	j	4201681d <scalar_mul+0x151>
420166db:	24a8      	l32i.n	a10, a4, 8
420166dd:	0219a7        	beq	a9, a10, 420166e3 <scalar_mul+0x17>
420166e0:	004f86        	j	42016822 <scalar_mul+0x156>
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
420166e3:	1228      	l32i.n	a2, a2, 4
420166e5:	1398      	l32i.n	a9, a3, 4
420166e7:	021297        	beq	a2, a9, 420166ed <scalar_mul+0x21>
420166ea:	004e86        	j	42016828 <scalar_mul+0x15c>
420166ed:	1498      	l32i.n	a9, a4, 4
420166ef:	021297        	beq	a2, a9, 420166f5 <scalar_mul+0x29>
420166f2:	004dc6        	j	4201682d <scalar_mul+0x161>
    switch (vec1->type) {
420166f5:	022266        	bnei	a2, 2, 420166fb <scalar_mul+0x2f>
420166f8:	0022c6        	j	42016787 <scalar_mul+0xbb>
420166fb:	0932f6        	bgeui	a2, 3, 42016708 <scalar_mul+0x3c>
420166fe:	229c      	beqz.n	a2, 42016714 <scalar_mul+0x48>
42016700:	491226        	beqi	a2, 1, 4201674d <scalar_mul+0x81>
42016703:	320c      	movi.n	a2, 3
42016705:	004c46        	j	4201683a <scalar_mul+0x16e>
42016708:	023266        	bnei	a2, 3, 4201670e <scalar_mul+0x42>
4201670b:	003886        	j	420167f1 <scalar_mul+0x125>
4201670e:	320c      	movi.n	a2, 3
42016710:	004986        	j	4201683a <scalar_mul+0x16e>
42016713:	85b600        	extui	a11, a0, 22, 9
            if (shift_amount > 7) { return VECTOR_INVALID_ARGUMENT;}
42016716:	45c602        	addi	a0, a6, 69
42016719:	08c800        	lsx	f12, a8, a0
            int8_t* vec2_data = (int8_t*)(vec2->data);
4201671c:	03d8      	l32i.n	a13, a3, 0
            int8_t* result_data = (int8_t*)(result->data);
4201671e:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
42016720:	0a0c      	movi.n	a10, 0
42016722:	0007c6        	j	42016745 <scalar_mul+0x79>
                int a = vec1_data[i];
42016725:	9caa      	add.n	a9, a12, a10
42016727:	000992        	l8ui	a9, a9, 0
4201672a:	239900        	sext	a9, a9, 7
                int b = vec2_data[i];
4201672d:	bdaa      	add.n	a11, a13, a10
4201672f:	000bb2        	l8ui	a11, a11, 0
42016732:	23bb00        	sext	a11, a11, 7
                int intermediate = a * b;
42016735:	8299b0        	mull	a9, a9, a11
                intermediate = intermediate >> shift_amount;
42016738:	400500        	ssr	a5
4201673b:	b19090        	sra	a9, a9
                result_data[i] = (int8_t)intermediate;
4201673e:	beaa      	add.n	a11, a14, a10
42016740:	004b92        	s8i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++){
42016743:	aa1b      	addi.n	a10, a10, 1
42016745:	2898      	l32i.n	a9, a8, 8
42016747:	da3a97        	bltu	a10, a9, 42016725 <scalar_mul+0x59>
4201674a:	003b06        	j	4201683a <scalar_mul+0x16e>
            if (shift_amount > 15) { return VECTOR_INVALID_ARGUMENT;}
4201674d:	f90c      	movi.n	a9, 15
4201674f:	02b957        	bgeu	a9, a5, 42016755 <scalar_mul+0x89>
42016752:	003886        	j	42016838 <scalar_mul+0x16c>
            int16_t* vec1_data = (int16_t*)(vec1->data);
42016755:	08c8      	l32i.n	a12, a8, 0
            int16_t* vec2_data = (int16_t*)(vec2->data);
42016757:	03d8      	l32i.n	a13, a3, 0
            int16_t* result_data = (int16_t*)(result->data);
42016759:	04e8      	l32i.n	a14, a4, 0
            for (int i = 0; i < vec1->size; i++){
4201675b:	090c      	movi.n	a9, 0
4201675d:	000706        	j	4201677d <scalar_mul+0xb1>
                int a = vec1_data[i];
42016760:	90a9c0        	addx2	a10, a9, a12
42016763:	009aa2        	l16si	a10, a10, 0
                int b = vec2_data[i];
42016766:	90b9d0        	addx2	a11, a9, a13
42016769:	009bb2        	l16si	a11, a11, 0
                int intermediate = a * b;
4201676c:	82aab0        	mull	a10, a10, a11
                intermediate = intermediate >> shift_amount;
4201676f:	400500        	ssr	a5
42016772:	b1a0a0        	sra	a10, a10
                result_data[i] = (int16_t)intermediate;
42016775:	90b9e0        	addx2	a11, a9, a14
42016778:	005ba2        	s16i	a10, a11, 0
            for (int i = 0; i < vec1->size; i++){
4201677b:	991b      	addi.n	a9, a9, 1
4201677d:	28a8      	l32i.n	a10, a8, 8
4201677f:	dd39a7        	bltu	a9, a10, 42016760 <scalar_mul+0x94>
            return VECTOR_SUCCESS;
42016782:	020c      	movi.n	a2, 0
42016784:	002c86        	j	4201683a <scalar_mul+0x16e>
            if (shift_amount > 31) { return VECTOR_INVALID_ARGUMENT;}
42016787:	f91c      	movi.n	a9, 31
42016789:	02b957        	bgeu	a9, a5, 4201678f <scalar_mul+0xc3>
4201678c:	002a86        	j	4201683a <scalar_mul+0x16e>
            int32_t* vec1_data = (int32_t*)(vec1->data);
4201678f:	08d8      	l32i.n	a13, a8, 0
            int32_t* vec2_data = (int32_t*)(vec2->data);
42016791:	03e8      	l32i.n	a14, a3, 0
            int32_t* result_data = (int32_t*)(result->data);
42016793:	04f8      	l32i.n	a15, a4, 0
            for (int i = 0; i < vec1->size; i++){
42016795:	0c0c      	movi.n	a12, 0
42016797:	001306        	j	420167e7 <scalar_mul+0x11b>
4201679a:	d00000        	subx2	a0, a0, a0
                int64_t a = (int64_t)vec1_data[i];
4201679d:	a09c      	beqz.n	a0, 420167bb <scalar_mul+0xef>
4201679f:	09b8      	l32i.n	a11, a9, 0
420167a1:	319fb0        	srai	a9, a11, 31
                int64_t b = (int64_t)vec2_data[i];
420167a4:	a0ace0        	addx4	a10, a12, a14
420167a7:	0a48      	l32i.n	a4, a10, 0
420167a9:	31af40        	srai	a10, a4, 31
                int64_t intermediate = a * b;
420167ac:	829940        	mull	a9, a9, a4
420167af:	82aab0        	mull	a10, a10, a11
420167b2:	99aa      	add.n	a9, a9, a10
420167b4:	82ab40        	mull	a10, a11, a4
420167b7:	a2bb40        	muluh	a11, a11, a4
420167ba:	99ba      	add.n	a9, a9, a11
                intermediate = intermediate >> shift_amount;
420167bc:	0b2c      	movi.n	a11, 32
420167be:	10b5b0        	and	a11, a5, a11
420167c1:	499a      	add.n	a4, a9, a9
420167c3:	f37c      	movi.n	a3, -1
420167c5:	303530        	xor	a3, a5, a3
420167c8:	401300        	ssl	a3
420167cb:	a14400        	sll	a4, a4
420167ce:	400500        	ssr	a5
420167d1:	91a0a0        	srl	a10, a10
420167d4:	20a4a0        	or	a10, a4, a10
420167d7:	400500        	ssr	a5
420167da:	b19090        	sra	a9, a9
420167dd:	93a9b0        	movnez	a10, a9, a11
                result_data[i] = (int32_t)intermediate;
420167e0:	a09cf0        	addx4	a9, a12, a15
420167e3:	09a9      	s32i.n	a10, a9, 0
            for (int i = 0; i < vec1->size; i++){
420167e5:	cc1b      	addi.n	a12, a12, 1
420167e7:	2898      	l32i.n	a9, a8, 8
420167e9:	af3c97        	bltu	a12, a9, 4201679c <scalar_mul+0xd0>
            return VECTOR_SUCCESS;
420167ec:	020c      	movi.n	a2, 0
420167ee:	001206        	j	4201683a <scalar_mul+0x16e>
            float* vec1_data = (float*)(vec1->data);
420167f1:	08d8      	l32i.n	a13, a8, 0
            float* vec2_data = (float*)(vec2->data);
420167f3:	03c8      	l32i.n	a12, a3, 0
            float* result_data = (float*)(result->data);
420167f5:	04b8      	l32i.n	a11, a4, 0
            for (int i = 0; i < vec1->size; i++){
420167f7:	090c      	movi.n	a9, 0
420167f9:	000586        	j	42016813 <scalar_mul+0x147>
                float a = vec1_data[i];
420167fc:	a0a9d0        	addx4	a10, a9, a13
420167ff:	000a03        	lsi	f0, a10, 0
                float b = vec2_data[i]; 
42016802:	a0a9c0        	addx4	a10, a9, a12
42016805:	000a13        	lsi	f1, a10, 0
                result_data[i] = a * b;
42016808:	a0a9b0        	addx4	a10, a9, a11
4201680b:	2a0010        	mul.s	f0, f0, f1
4201680e:	004a03        	ssi	f0, a10, 0
            for (int i = 0; i < vec1->size; i++){
42016811:	991b      	addi.n	a9, a9, 1
42016813:	28a8      	l32i.n	a10, a8, 8
42016815:	e339a7        	bltu	a9, a10, 420167fc <scalar_mul+0x130>
            return VECTOR_SUCCESS;
42016818:	020c      	movi.n	a2, 0
4201681a:	000706        	j	4201683a <scalar_mul+0x16e>
    if (vec1->size != vec2->size || vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
4201681d:	720c      	movi.n	a2, 7
4201681f:	0005c6        	j	4201683a <scalar_mul+0x16e>
42016822:	720c      	movi.n	a2, 7
42016824:	000486        	j	4201683a <scalar_mul+0x16e>
42016827:	820c00        	mull	a0, a12, a0
    if (vec1->type != vec2->type || vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
4201682a:	000306        	j	4201683a <scalar_mul+0x16e>
4201682d:	820c      	movi.n	a2, 8
4201682f:	0001c6        	j	4201683a <scalar_mul+0x16e>
            if (shift_amount > 7) { return VECTOR_INVALID_ARGUMENT;}
42016832:	220c      	movi.n	a2, 2
42016834:	000086        	j	4201683a <scalar_mul+0x16e>
42016837:	220c00        	orb	b0, b12, b0
}
4201683a:	f01d      	retw.n

4201683c <scalar_mul_scalar>:
vector_status_t scalar_mul_scalar(const vector_t *vec1, const int val, vector_t *result, const unsigned int shift_amount) {
4201683c:	004136        	entry	a1, 32
4201683f:	028d      	mov.n	a8, a2
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
42016841:	22a8      	l32i.n	a10, a2, 8
42016843:	2498      	l32i.n	a9, a4, 8
42016845:	021a97        	beq	a10, a9, 4201684b <scalar_mul_scalar+0xf>
42016848:	003b46        	j	42016939 <scalar_mul_scalar+0xfd>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
4201684b:	1228      	l32i.n	a2, a2, 4
4201684d:	1498      	l32i.n	a9, a4, 4
4201684f:	021297        	beq	a2, a9, 42016855 <scalar_mul_scalar+0x19>
42016852:	003a06        	j	4201693e <scalar_mul_scalar+0x102>
    switch (vec1->type) {
42016855:	7d2226        	beqi	a2, 2, 420168d6 <scalar_mul_scalar+0x9a>
42016858:	0932f6        	bgeui	a2, 3, 42016865 <scalar_mul_scalar+0x29>
4201685b:	129c      	beqz.n	a2, 42016870 <scalar_mul_scalar+0x34>
4201685d:	431226        	beqi	a2, 1, 420168a4 <scalar_mul_scalar+0x68>
            return VECTOR_UNSUPPORTED_OPERATION;
42016860:	420c      	movi.n	a2, 4
42016862:	003a86        	j	42016950 <scalar_mul_scalar+0x114>
    switch (vec1->type) {
42016865:	023226        	beqi	a2, 3, 4201686b <scalar_mul_scalar+0x2f>
42016868:	003606        	j	42016944 <scalar_mul_scalar+0x108>
4201686b:	520c      	movi.n	a2, 5
4201686d:	0037c6        	j	42016950 <scalar_mul_scalar+0x114>
            if (shift_amount > 7) { return VECTOR_INVALID_ARGUMENT;}
42016870:	0285b6        	bltui	a5, 8, 42016876 <scalar_mul_scalar+0x3a>
42016873:	003486        	j	42016949 <scalar_mul_scalar+0x10d>
            int8_t *vec1_data = (int8_t *)vec1->data;
42016876:	08c8      	l32i.n	a12, a8, 0
            int8_t *result_data = (int8_t *)result->data;
42016878:	04d8      	l32i.n	a13, a4, 0
            for (int i = 0; i < vec1->size; i++) {
4201687a:	0a0c      	movi.n	a10, 0
4201687c:	0006c6        	j	4201689b <scalar_mul_scalar+0x5f>
4201687f:	00          	.byte	00
                int16_t intermediate = (int16_t)(vec1_data[i] * val_i8);
42016880:	9caa      	add.n	a9, a12, a10
42016882:	000992        	l8ui	a9, a9, 0
42016885:	239900        	sext	a9, a9, 7
42016888:	c19390        	mul16u	a9, a3, a9
4201688b:	239980        	sext	a9, a9, 15
                result_data[i] = (int8_t)(intermediate >> shift_amount);
4201688e:	400500        	ssr	a5
42016891:	b19090        	sra	a9, a9
42016894:	bdaa      	add.n	a11, a13, a10
42016896:	004b92        	s8i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++) {
42016899:	aa1b      	addi.n	a10, a10, 1
4201689b:	2898      	l32i.n	a9, a8, 8
4201689d:	df3a97        	bltu	a10, a9, 42016880 <scalar_mul_scalar+0x44>
420168a0:	002b06        	j	42016950 <scalar_mul_scalar+0x114>
420168a3:	00          	.byte	00
            if (shift_amount > 15) { return VECTOR_INVALID_ARGUMENT;}
420168a4:	f90c      	movi.n	a9, 15
420168a6:	02b957        	bgeu	a9, a5, 420168ac <scalar_mul_scalar+0x70>
420168a9:	002846        	j	4201694e <scalar_mul_scalar+0x112>
            int16_t *vec1_data = (int16_t *)vec1->data;
420168ac:	08d8      	l32i.n	a13, a8, 0
            int16_t *result_data = (int16_t *)result->data;
420168ae:	04c8      	l32i.n	a12, a4, 0
            for (int i = 0; i < vec1->size; i++) {
420168b0:	0a0c      	movi.n	a10, 0
420168b2:	000586        	j	420168cc <scalar_mul_scalar+0x90>
                int32_t intermediate = (int32_t)(vec1_data[i] * val_i16);
420168b5:	909ad0        	addx2	a9, a10, a13
420168b8:	009992        	l16si	a9, a9, 0
420168bb:	829930        	mull	a9, a9, a3
                result_data[i] = (int16_t)(intermediate >> shift_amount);
420168be:	400500        	ssr	a5
420168c1:	b19090        	sra	a9, a9
420168c4:	90bac0        	addx2	a11, a10, a12
420168c7:	005b92        	s16i	a9, a11, 0
            for (int i = 0; i < vec1->size; i++) {
420168ca:	aa1b      	addi.n	a10, a10, 1
420168cc:	2898      	l32i.n	a9, a8, 8
420168ce:	e33a97        	bltu	a10, a9, 420168b5 <scalar_mul_scalar+0x79>
            return VECTOR_SUCCESS;
420168d1:	020c      	movi.n	a2, 0
420168d3:	001e46        	j	42016950 <scalar_mul_scalar+0x114>
            if (shift_amount > 31) { return VECTOR_INVALID_ARGUMENT;}
420168d6:	f91c      	movi.n	a9, 31
420168d8:	743957        	bltu	a9, a5, 42016950 <scalar_mul_scalar+0x114>
            int32_t *vec1_data = (int32_t *)vec1->data;
420168db:	08e8      	l32i.n	a14, a8, 0
            int32_t *result_data = (int32_t *)result->data;
420168dd:	04f8      	l32i.n	a15, a4, 0
            int64_t val_i32 = (int64_t)val;
420168df:	400900        	ssr	a9
420168e2:	b1d030        	sra	a13, a3
            for (int i = 0; i < vec1->size; i++) {
420168e5:	0c0c      	movi.n	a12, 0
420168e7:	001106        	j	4201692f <scalar_mul_scalar+0xf3>
420168ea:	e00000        	subx4	a0, a0, a0
                int64_t intermediate = (int64_t)(vec1_data[i]) * val_i32;
420168ed:	a09c      	beqz.n	a0, 4201690b <scalar_mul_scalar+0xcf>
420168ef:	09b8      	l32i.n	a11, a9, 0
420168f1:	319fb0        	srai	a9, a11, 31
420168f4:	829930        	mull	a9, a9, a3
420168f7:	82adb0        	mull	a10, a13, a11
420168fa:	99aa      	add.n	a9, a9, a10
420168fc:	82ab30        	mull	a10, a11, a3
420168ff:	a2bb30        	muluh	a11, a11, a3
42016902:	99ba      	add.n	a9, a9, a11
                result_data[i] = (int32_t)(intermediate >> shift_amount);
42016904:	0b2c      	movi.n	a11, 32
42016906:	10b5b0        	and	a11, a5, a11
42016909:	499a      	add.n	a4, a9, a9
4201690b:	f77c      	movi.n	a7, -1
4201690d:	307570        	xor	a7, a5, a7
42016910:	401700        	ssl	a7
42016913:	a14400        	sll	a4, a4
42016916:	400500        	ssr	a5
42016919:	91a0a0        	srl	a10, a10
4201691c:	20a4a0        	or	a10, a4, a10
4201691f:	400500        	ssr	a5
42016922:	b19090        	sra	a9, a9
42016925:	93a9b0        	movnez	a10, a9, a11
42016928:	a09cf0        	addx4	a9, a12, a15
4201692b:	09a9      	s32i.n	a10, a9, 0
            for (int i = 0; i < vec1->size; i++) {
4201692d:	cc1b      	addi.n	a12, a12, 1
4201692f:	2898      	l32i.n	a9, a8, 8
42016931:	b73c97        	bltu	a12, a9, 420168ec <scalar_mul_scalar+0xb0>
            return VECTOR_SUCCESS;
42016934:	020c      	movi.n	a2, 0
42016936:	000586        	j	42016950 <scalar_mul_scalar+0x114>
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
42016939:	720c      	movi.n	a2, 7
4201693b:	000446        	j	42016950 <scalar_mul_scalar+0x114>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
4201693e:	820c      	movi.n	a2, 8
42016940:	000306        	j	42016950 <scalar_mul_scalar+0x114>
42016943:	420c00        	xorb	b0, b12, b0
            return VECTOR_UNSUPPORTED_OPERATION;
42016946:	000186        	j	42016950 <scalar_mul_scalar+0x114>
            if (shift_amount > 7) { return VECTOR_INVALID_ARGUMENT;}
42016949:	220c      	movi.n	a2, 2
4201694b:	000046        	j	42016950 <scalar_mul_scalar+0x114>
            if (shift_amount > 15) { return VECTOR_INVALID_ARGUMENT;}
4201694e:	220c      	movi.n	a2, 2
}   
42016950:	f01d      	retw.n
	...

42016954 <scalar_mul_scalar_f32>:
vector_status_t scalar_mul_scalar_f32(const vector_t *vec1, const float val, vector_t *result) {
42016954:	004136        	entry	a1, 32
42016957:	fa1350        	wfr	f1, a3
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
4201695a:	2298      	l32i.n	a9, a2, 8
4201695c:	2488      	l32i.n	a8, a4, 8
4201695e:	2e9987        	bne	a9, a8, 42016990 <scalar_mul_scalar_f32+0x3c>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
42016961:	1288      	l32i.n	a8, a2, 4
42016963:	1498      	l32i.n	a9, a4, 4
42016965:	2c9897        	bne	a8, a9, 42016995 <scalar_mul_scalar_f32+0x41>
    switch (vec1->type) {
42016968:	2e3866        	bnei	a8, 3, 4201699a <scalar_mul_scalar_f32+0x46>
            float* vec1_data = (float*)(vec1->data);
4201696b:	02b8      	l32i.n	a11, a2, 0
            float* result_data = (float*)(result->data);
4201696d:	04a8      	l32i.n	a10, a4, 0
            for (int i = 0; i < vec1->size; i++){ 
4201696f:	080c      	movi.n	a8, 0
42016971:	000406        	j	42016985 <scalar_mul_scalar_f32+0x31>
                result_data[i] = vec1_data[i] * val;
42016974:	a098b0        	addx4	a9, a8, a11
42016977:	000903        	lsi	f0, a9, 0
4201697a:	a098a0        	addx4	a9, a8, a10
4201697d:	2a0010        	mul.s	f0, f0, f1
42016980:	004903        	ssi	f0, a9, 0
            for (int i = 0; i < vec1->size; i++){ 
42016983:	881b      	addi.n	a8, a8, 1
42016985:	2298      	l32i.n	a9, a2, 8
42016987:	e93897        	bltu	a8, a9, 42016974 <scalar_mul_scalar_f32+0x20>
            return VECTOR_SUCCESS;
4201698a:	020c      	movi.n	a2, 0
4201698c:	000306        	j	4201699c <scalar_mul_scalar_f32+0x48>
4201698f:	720c00        	salt	a0, a12, a0
    if (vec1->size != result->size){ return VECTOR_SIZE_MISMATCH;}  
42016992:	000186        	j	4201699c <scalar_mul_scalar_f32+0x48>
    if (vec1->type != result->type){ return VECTOR_TYPE_MISMATCH;}  
42016995:	820c      	movi.n	a2, 8
42016997:	000046        	j	4201699c <scalar_mul_scalar_f32+0x48>
        case DTYPE_INT8:  return VECTOR_UNSUPPORTED_OPERATION;
4201699a:	420c      	movi.n	a2, 4
}   
4201699c:	f01d      	retw.n
	...

420169a0 <scalar_dotp>:
vector_status_t scalar_dotp(const vector_t *vec1, const vector_t *vec2, int32_t* result) {
420169a0:	004136        	entry	a1, 32
420169a3:	028d      	mov.n	a8, a2
    if (vec1->size != vec2->size){ return VECTOR_SIZE_MISMATCH;} 
420169a5:	2298      	l32i.n	a9, a2, 8
420169a7:	23a8      	l32i.n	a10, a3, 8
420169a9:	0219a7        	beq	a9, a10, 420169af <scalar_dotp+0xf>
420169ac:	002806        	j	42016a50 <scalar_dotp+0xb0>
    if (vec1->type != vec2->type){ return VECTOR_TYPE_MISMATCH;}
420169af:	1228      	l32i.n	a2, a2, 4
420169b1:	13a8      	l32i.n	a10, a3, 4
420169b3:	0212a7        	beq	a2, a10, 420169b9 <scalar_dotp+0x19>
420169b6:	0026c6        	j	42016a55 <scalar_dotp+0xb5>
    switch (vec1->type){
420169b9:	6b2226        	beqi	a2, 2, 42016a28 <scalar_dotp+0x88>
420169bc:	0932f6        	bgeui	a2, 3, 420169c9 <scalar_dotp+0x29>
420169bf:	129c      	beqz.n	a2, 420169d4 <scalar_dotp+0x34>
420169c1:	3b1226        	beqi	a2, 1, 42016a00 <scalar_dotp+0x60>
        default: return VECTOR_ERROR; 
420169c4:	320c      	movi.n	a2, 3
420169c6:	002486        	j	42016a5c <scalar_dotp+0xbc>
    switch (vec1->type){
420169c9:	023226        	beqi	a2, 3, 420169cf <scalar_dotp+0x2f>
420169cc:	002286        	j	42016a5a <scalar_dotp+0xba>
420169cf:	420c      	movi.n	a2, 4
420169d1:	0021c6        	j	42016a5c <scalar_dotp+0xbc>
            int8_t *vec1_data = (int8_t*)vec1->data;
420169d4:	08d8      	l32i.n	a13, a8, 0
            int8_t *vec2_data = (int8_t*)vec2->data;
420169d6:	03e8      	l32i.n	a14, a3, 0
            for (int i = 0; i < vec1->size; i++){
420169d8:	0a0c      	movi.n	a10, 0
            int32_t output = 0;
420169da:	0acd      	mov.n	a12, a10
            for (int i = 0; i < vec1->size; i++){
420169dc:	0005c6        	j	420169f7 <scalar_dotp+0x57>
420169df:	00          	.byte	00
                int a = (int)vec1_data[i];
420169e0:	8daa      	add.n	a8, a13, a10
420169e2:	000882        	l8ui	a8, a8, 0
420169e5:	238800        	sext	a8, a8, 7
                int b = (int)vec2_data[i];
420169e8:	beaa      	add.n	a11, a14, a10
420169ea:	000bb2        	l8ui	a11, a11, 0
420169ed:	23bb00        	sext	a11, a11, 7
                output +=  a * b;
420169f0:	8288b0        	mull	a8, a8, a11
420169f3:	cc8a      	add.n	a12, a12, a8
            for (int i = 0; i < vec1->size; i++){
420169f5:	aa1b      	addi.n	a10, a10, 1
420169f7:	e53a97        	bltu	a10, a9, 420169e0 <scalar_dotp+0x40>
            *result = output;
420169fa:	04c9      	s32i.n	a12, a4, 0
            return VECTOR_SUCCESS;
420169fc:	001706        	j	42016a5c <scalar_dotp+0xbc>
420169ff:	08e800        	lsx	f14, a8, a0
            int16_t *vec2_data = (int16_t*)vec2->data;
42016a02:	03d8      	l32i.n	a13, a3, 0
            for (int i = 0; i < vec1->size; i++){
42016a04:	080c      	movi.n	a8, 0
            int32_t output = 0;
42016a06:	08bd      	mov.n	a11, a8
            for (int i = 0; i < vec1->size; i++){
42016a08:	000486        	j	42016a1e <scalar_dotp+0x7e>
                int a = (int)vec1_data[i];
42016a0b:	90a8e0        	addx2	a10, a8, a14
42016a0e:	009aa2        	l16si	a10, a10, 0
                int b = (int)vec2_data[i];
42016a11:	90c8d0        	addx2	a12, a8, a13
42016a14:	009cc2        	l16si	a12, a12, 0
                output +=  a * b;
42016a17:	82aac0        	mull	a10, a10, a12
42016a1a:	bbaa      	add.n	a11, a11, a10
            for (int i = 0; i < vec1->size; i++){
42016a1c:	881b      	addi.n	a8, a8, 1
42016a1e:	e93897        	bltu	a8, a9, 42016a0b <scalar_dotp+0x6b>
            *result = output;
42016a21:	04b9      	s32i.n	a11, a4, 0
            return VECTOR_SUCCESS;
42016a23:	020c      	movi.n	a2, 0
42016a25:	000cc6        	j	42016a5c <scalar_dotp+0xbc>
            int32_t *vec1_data = (int32_t*)vec1->data;
42016a28:	08e8      	l32i.n	a14, a8, 0
            int32_t *vec2_data = (int32_t*)vec2->data;
42016a2a:	03d8      	l32i.n	a13, a3, 0
            for (int i = 0; i < vec1->size; i++){
42016a2c:	080c      	movi.n	a8, 0
            int32_t output = 0;
42016a2e:	08bd      	mov.n	a11, a8
            for (int i = 0; i < vec1->size; i++){
42016a30:	000446        	j	42016a45 <scalar_dotp+0xa5>
42016a33:	00          	.byte	00
                int64_t a = (int64_t)vec1_data[i];
42016a34:	a0a8e0        	addx4	a10, a8, a14
42016a37:	0aa8      	l32i.n	a10, a10, 0
                int64_t b = (int64_t)vec2_data[i];
42016a39:	a0c8d0        	addx4	a12, a8, a13
42016a3c:	0cc8      	l32i.n	a12, a12, 0
                output +=  (int32_t)(a * b);
42016a3e:	82aac0        	mull	a10, a10, a12
42016a41:	bbaa      	add.n	a11, a11, a10
            for (int i = 0; i < vec1->size; i++){
42016a43:	881b      	addi.n	a8, a8, 1
42016a45:	eb3897        	bltu	a8, a9, 42016a34 <scalar_dotp+0x94>
            *result = output;
42016a48:	04b9      	s32i.n	a11, a4, 0
            return VECTOR_SUCCESS;
42016a4a:	020c      	movi.n	a2, 0
42016a4c:	000306        	j	42016a5c <scalar_dotp+0xbc>
42016a4f:	720c00        	salt	a0, a12, a0
    if (vec1->size != vec2->size){ return VECTOR_SIZE_MISMATCH;} 
42016a52:	000186        	j	42016a5c <scalar_dotp+0xbc>
    if (vec1->type != vec2->type){ return VECTOR_TYPE_MISMATCH;}
42016a55:	820c      	movi.n	a2, 8
42016a57:	000046        	j	42016a5c <scalar_dotp+0xbc>
        default: return VECTOR_ERROR; 
42016a5a:	320c      	movi.n	a2, 3
}
42016a5c:	f01d      	retw.n
	...

42016a60 <scalar_dotp_f32>:
vector_status_t scalar_dotp_f32(const vector_t *vec1, const vector_t *vec2, float* result) {
42016a60:	004136        	entry	a1, 32
    if (vec1->size != vec2->size ) { return VECTOR_SIZE_MISMATCH;}  
42016a63:	2298      	l32i.n	a9, a2, 8
42016a65:	2388      	l32i.n	a8, a3, 8
42016a67:	219987        	bne	a9, a8, 42016a8c <scalar_dotp_f32+0x2c>
    if (vec1->type != vec2->type) { return VECTOR_TYPE_MISMATCH;}   
42016a6a:	1288      	l32i.n	a8, a2, 4
42016a6c:	13a8      	l32i.n	a10, a3, 4
42016a6e:	1f98a7        	bne	a8, a10, 42016a91 <scalar_dotp_f32+0x31>
    switch (vec1->type){
42016a71:	2138b6        	bltui	a8, 3, 42016a96 <scalar_dotp_f32+0x36>
42016a74:	093826        	beqi	a8, 3, 42016a81 <scalar_dotp_f32+0x21>
            return VECTOR_ERROR;  
42016a77:	320c      	movi.n	a2, 3
42016a79:	0006c6        	j	42016a98 <scalar_dotp_f32+0x38>
            for (int i = 0 ; i < vec1->size; i++){
42016a7c:	881b      	addi.n	a8, a8, 1
42016a7e:	000046        	j	42016a83 <scalar_dotp_f32+0x23>
    switch (vec1->type){
42016a81:	080c      	movi.n	a8, 0
            for (int i = 0 ; i < vec1->size; i++){
42016a83:	f53897        	bltu	a8, a9, 42016a7c <scalar_dotp_f32+0x1c>
            return VECTOR_SUCCESS;
42016a86:	020c      	movi.n	a2, 0
42016a88:	000306        	j	42016a98 <scalar_dotp_f32+0x38>
42016a8b:	720c00        	salt	a0, a12, a0
    if (vec1->size != vec2->size ) { return VECTOR_SIZE_MISMATCH;}  
42016a8e:	000186        	j	42016a98 <scalar_dotp_f32+0x38>
    if (vec1->type != vec2->type) { return VECTOR_TYPE_MISMATCH;}   
42016a91:	820c      	movi.n	a2, 8
42016a93:	000046        	j	42016a98 <scalar_dotp_f32+0x38>
    switch (vec1->type){
42016a96:	420c      	movi.n	a2, 4
}
42016a98:	f01d      	retw.n
	...

42016a9c <scalar_ceil_f32>:

vector_status_t scalar_ceil_f32(const vector_t *vec1, vector_t* result, const float ceiling){ 
42016a9c:	004136        	entry	a1, 32
42016a9f:	fa0450        	wfr	f0, a4
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42016aa2:	2298      	l32i.n	a9, a2, 8
42016aa4:	2388      	l32i.n	a8, a3, 8
42016aa6:	3a9987        	bne	a9, a8, 42016ae4 <scalar_ceil_f32+0x48>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
42016aa9:	1288      	l32i.n	a8, a2, 4
42016aab:	1398      	l32i.n	a9, a3, 4
42016aad:	389897        	bne	a8, a9, 42016ae9 <scalar_ceil_f32+0x4d>
    switch (vec1->type){
42016ab0:	3a38b6        	bltui	a8, 3, 42016aee <scalar_ceil_f32+0x52>
42016ab3:	3d3866        	bnei	a8, 3, 42016af4 <scalar_ceil_f32+0x58>
        case (DTYPE_INT8):   return VECTOR_UNSUPPORTED_OPERATION;
        case (DTYPE_INT16):  return VECTOR_UNSUPPORTED_OPERATION;
        case (DTYPE_INT32):  return VECTOR_UNSUPPORTED_OPERATION;
        case (DTYPE_FLOAT32): { 
            float ceil = (float)ceiling; 
            float *vec1_data = (float*)(vec1->data);    
42016ab6:	02c8      	l32i.n	a12, a2, 0
            float *result_data = (float*)(result->data);                                   
42016ab8:	03b8      	l32i.n	a11, a3, 0
            for (int i = 0; i < vec1->size; i++){
42016aba:	080c      	movi.n	a8, 0
42016abc:	000646        	j	42016ad9 <scalar_ceil_f32+0x3d>
42016abf:	00          	.byte	00
                float cur_val = vec1_data[i];
42016ac0:	1198e0        	slli	a9, a8, 2
42016ac3:	a0a8c0        	addx4	a10, a8, a12
42016ac6:	000a13        	lsi	f1, a10, 0
                result_data[i] = cur_val > ceil ? ceil : cur_val;
42016ac9:	4b0010        	olt.s	b0, f0, f1
42016acc:	020076        	bf	b0, 42016ad2 <scalar_ceil_f32+0x36>
42016acf:	fa1000        	mov.s	f1, f0
42016ad2:	9b9a      	add.n	a9, a11, a9
42016ad4:	004913        	ssi	f1, a9, 0
            for (int i = 0; i < vec1->size; i++){
42016ad7:	881b      	addi.n	a8, a8, 1
42016ad9:	2298      	l32i.n	a9, a2, 8
42016adb:	e13897        	bltu	a8, a9, 42016ac0 <scalar_ceil_f32+0x24>
            }
            return VECTOR_SUCCESS;
42016ade:	020c      	movi.n	a2, 0
42016ae0:	000486        	j	42016af6 <scalar_ceil_f32+0x5a>
42016ae3:	720c00        	salt	a0, a12, a0
    if (vec1->size != result->size ) { return VECTOR_SIZE_MISMATCH;}  
42016ae6:	000306        	j	42016af6 <scalar_ceil_f32+0x5a>
    if (vec1->type != result->type) { return VECTOR_TYPE_MISMATCH;}  
42016ae9:	820c      	movi.n	a2, 8
42016aeb:	0001c6        	j	42016af6 <scalar_ceil_f32+0x5a>
    switch (vec1->type){
42016aee:	420c      	movi.n	a2, 4
42016af0:	000086        	j	42016af6 <scalar_ceil_f32+0x5a>
42016af3:	320c00        	orbc	b0, b12, b0
        }
        default:        
            return VECTOR_ERROR;
    }
}
42016af6:	f01d      	retw.n

42016af8 <sizeof_dtype>:
    DTYPE_INT16,
    DTYPE_INT32,
    DTYPE_FLOAT32,
} dtype;
 
static inline size_t sizeof_dtype(dtype t) {
42016af8:	004136        	entry	a1, 32
    switch (t) {
42016afb:	152226        	beqi	a2, 2, 42016b14 <sizeof_dtype+0x1c>
42016afe:	0a32f6        	bgeui	a2, 3, 42016b0c <sizeof_dtype+0x14>
42016b01:	429c      	beqz.n	a2, 42016b19 <sizeof_dtype+0x21>
42016b03:	171266        	bnei	a2, 1, 42016b1e <sizeof_dtype+0x26>
        case DTYPE_INT8:    return sizeof(int8_t);
        case DTYPE_INT16:   return sizeof(int16_t);
42016b06:	220c      	movi.n	a2, 2
42016b08:	000686        	j	42016b26 <sizeof_dtype+0x2e>
42016b0b:	326600        	orbc	b6, b6, b0
    switch (t) {
42016b0e:	420c14        	ee.st.accx.ip	a1, 0xfffffc60
        case DTYPE_INT32:   return sizeof(int32_t);
        case DTYPE_FLOAT32: return sizeof(float);
42016b11:	000446        	j	42016b26 <sizeof_dtype+0x2e>
        case DTYPE_INT32:   return sizeof(int32_t);
42016b14:	420c      	movi.n	a2, 4
42016b16:	000306        	j	42016b26 <sizeof_dtype+0x2e>
    switch (t) {
42016b19:	120c      	movi.n	a2, 1
42016b1b:	0001c6        	j	42016b26 <sizeof_dtype+0x2e>
        default:            return 0;
42016b1e:	020c      	movi.n	a2, 0
42016b20:	000086        	j	42016b26 <sizeof_dtype+0x2e>
42016b23:	020c00        	andb	b0, b12, b0
    }
}
42016b26:	f01d      	retw.n

42016b28 <sizeof_dtype>:
static inline size_t sizeof_dtype(dtype t) {
42016b28:	004136        	entry	a1, 32
    switch (t) {
42016b2b:	152226        	beqi	a2, 2, 42016b44 <sizeof_dtype+0x1c>
42016b2e:	0a32f6        	bgeui	a2, 3, 42016b3c <sizeof_dtype+0x14>
42016b31:	429c      	beqz.n	a2, 42016b49 <sizeof_dtype+0x21>
42016b33:	171266        	bnei	a2, 1, 42016b4e <sizeof_dtype+0x26>
        case DTYPE_INT16:   return sizeof(int16_t);
42016b36:	220c      	movi.n	a2, 2
42016b38:	000686        	j	42016b56 <sizeof_dtype+0x2e>
42016b3b:	326600        	orbc	b6, b6, b0
    switch (t) {
42016b3e:	420c14        	ee.st.accx.ip	a1, 0xfffffc60
        case DTYPE_FLOAT32: return sizeof(float);
42016b41:	000446        	j	42016b56 <sizeof_dtype+0x2e>
        case DTYPE_INT32:   return sizeof(int32_t);
42016b44:	420c      	movi.n	a2, 4
42016b46:	000306        	j	42016b56 <sizeof_dtype+0x2e>
    switch (t) {
42016b49:	120c      	movi.n	a2, 1
42016b4b:	0001c6        	j	42016b56 <sizeof_dtype+0x2e>
        default:            return 0;
42016b4e:	020c      	movi.n	a2, 0
42016b50:	000086        	j	42016b56 <sizeof_dtype+0x2e>
42016b53:	020c00        	andb	b0, b12, b0
}
42016b56:	f01d      	retw.n

42016b58 <simd_add_f32>:
 * @pre arr points must be 128-bit aligned
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_f32:
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016b58:	002136        	entry	a1, 16
    extui a6, a5, 0, 2                          // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016b5b:	146050        	extui	a6, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4)
42016b5e:	415250        	srli	a5, a5, 2
   
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42016b61:	179576        	loopnez	a5, 42016b7c <simd_add_f32+0x24>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, increment a2
42016b64:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        ee.ldf.128.ip f7, f6, f5, f4, a3, 16    // load 4 elements from vec2, increment a3
42016b68:	834b513e 	ee.ldf.128.ip	f7, f6, f5, f4, a3, 16
        add.s f3, f3, f7 
42016b6c:	0a3370        	add.s	f3, f3, f7
        add.s f2, f2, f6 
42016b6f:	0a2260        	add.s	f2, f2, f6
        add.s f1, f1, f5 
42016b72:	0a1150        	add.s	f1, f1, f5
        add.s f0, f0, f4 
42016b75:	0a0040        	add.s	f0, f0, f4
        ee.stf.128.ip f3, f2, f1, f0, a4, 16    // store result
42016b78:	9109114e 	ee.stf.128.ip	f3, f2, f1, f0, a4, 16
42016b7c:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a6, .Ltail_loop
42016b7e:	0b9676        	loopnez	a6, 42016b8d <simd_add_f32+0x35>
        lsip f0, a2, 4                          // load the first element, increment a2
42016b81:	018203        	lsip	f0, a2, 4
        lsip f1, a3, 4                          // load the second element, increment a3
42016b84:	018313        	lsip	f1, a3, 4
        add.s f0, f0, f1                        // performs f32 addition
42016b87:	0a0010        	add.s	f0, f0, f1
        ssip f0, a4, 4                          // stores the result, increments a4
42016b8a:	01c403        	ssip	f0, a4, 4
    .Ltail_loop:
 
    movi.n a2, 0                                // return exit code 0 (success)
42016b8d:	020c      	movi.n	a2, 0
    retw.n
42016b8f:	f01d      	retw.n
42016b91:	000000        	ill

42016b94 <simd_add_scalar_f32>:
 * @pre The size in a5 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_scalar_f32:
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016b94:	002136        	entry	a1, 16
    extui a6, a5, 0, 2                          // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016b97:	146050        	extui	a6, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4)
42016b9a:	415250        	srli	a5, a5, 2
   
    lsip f4, a3, 0
42016b9d:	008343        	lsip	f4, a3, 0
42016ba0:	0020f0        	nop
42016ba3:	f03d      	nop.n
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42016ba5:	139576        	loopnez	a5, 42016bbc <simd_add_scalar_f32+0x28>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, increment a2 
42016ba8:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        add.s f3, f3, f7 
42016bac:	0a3370        	add.s	f3, f3, f7
        add.s f2, f2, f6 
42016baf:	0a2260        	add.s	f2, f2, f6
        add.s f1, f1, f5 
42016bb2:	0a1150        	add.s	f1, f1, f5
        add.s f0, f0, f4 
42016bb5:	0a0040        	add.s	f0, f0, f4
        ee.stf.128.ip f3, f2, f1, f0, a4, 16    // store result
42016bb8:	9109114e 	ee.stf.128.ip	f3, f2, f1, f0, a4, 16
42016bbc:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a6, .Ltail_loop
42016bbe:	089676        	loopnez	a6, 42016bca <simd_add_scalar_f32+0x36>
        lsip f0, a2, 4                          // load the first element, increment a2 
42016bc1:	018203        	lsip	f0, a2, 4
        add.s f0, f0, f1                        // performs f32 addition
42016bc4:	0a0010        	add.s	f0, f0, f1
        ssip f0, a4, 4                          // stores the result, increments a4
42016bc7:	01c403        	ssip	f0, a4, 4
    .Ltail_loop:
 
    movi.n a2, 0                                // return exit code 0 (success)
42016bca:	020c      	movi.n	a2, 0
42016bcc:	f01d      	retw.n
	...

42016bd0 <simd_copy_i32>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_copy_i32:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016bd0:	002136        	entry	a1, 16
    extui a5, a4, 0, 2                              // extracts the lowest 2 bits of a4 into a5 (a4 % 4), for tail processing
42016bd3:	145040        	extui	a5, a4, 0, 2
    srli a4, a4, 2                                  // shift a4 right by 2 to get the number of 16-byte blocks (a4 / 4) 
42016bd6:	414240        	srli	a4, a4, 2
 
    loopnez a4, .Lsimd_loop                         // loop until a4 == 0
42016bd9:	059476        	loopnez	a4, 42016be2 <simd_copy_i32+0x12>
        ee.vld.128.ip     q1, a2, 16                // loads 16 bytes from a2 into q1, increment a32 by 16 
42016bdc:	838124        	ee.vld.128.ip	q1, a2, 16
        ee.vst.128.ip     q1, a3, 16                // stores 16 bytes from q1 to address at a3, increment a3 by 16
42016bdf:	8a8134        	ee.vst.128.ip	q1, a3, 16
    .Lsimd_loop: 
    
    loopnez a5, .Ltail_loop                         // Handle remaining elements that are not a multiple of 4
42016be2:	079576        	loopnez	a5, 42016bed <simd_copy_i32+0x1d>
        l32i a7, a2, 0   
42016be5:	0278      	l32i.n	a7, a2, 0
        addi.n a2, a2, 4                            // increment pointers
42016be7:	224b      	addi.n	a2, a2, 4
        s32i a7, a3, 0                              // store the saturated result in address at a3 
42016be9:	0379      	s32i.n	a7, a3, 0
        addi.n a3, a3, 4                            // increment pointers 
42016beb:	334b      	addi.n	a3, a3, 4
    .Ltail_loop:  

    movi.n a2, 0                                    // return exit code 0 (success)
42016bed:	020c      	movi.n	a2, 0
    retw.n
42016bef:	f01d      	retw.n
42016bf1:	000000        	ill

42016bf4 <simd_dotp_f32>:
 * @pre The size in a5 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_dotp_f32: 
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016bf4:	002136        	entry	a1, 16
    extui a6, a5, 0, 2                          // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016bf7:	146050        	extui	a6, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4)
42016bfa:	415250        	srli	a5, a5, 2
   
    sub.s f8, f8, f8                            // zeros f8 for accumulator
42016bfd:	1a8880        	sub.s	f8, f8, f8
42016c00:	0020f0        	nop
42016c03:	f03d      	nop.n
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42016c05:	139576        	loopnez	a5, 42016c1c <simd_dotp_f32+0x28>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, increment a2
42016c08:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        ee.ldf.128.ip f7, f6, f5, f4, a3, 16    // load 4 elements from vec2, increment a3
42016c0c:	834b513e 	ee.ldf.128.ip	f7, f6, f5, f4, a3, 16
        madd.s f8, f3, f7                       // multiply elements
42016c10:	4a8370        	madd.s	f8, f3, f7
        madd.s f8, f2, f6 
42016c13:	4a8260        	madd.s	f8, f2, f6
        madd.s f8, f1, f5 
42016c16:	4a8150        	madd.s	f8, f1, f5
        madd.s f8, f0, f4                       // accumulate
42016c19:	4a8040        	madd.s	f8, f0, f4
42016c1c:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a6, .Ltail_loop
42016c1e:	089676        	loopnez	a6, 42016c2a <simd_dotp_f32+0x36>
        lsip f0, a2, 4                          // load the first element, increment a2
42016c21:	018203        	lsip	f0, a2, 4
        lsip f1, a3, 4                          // load the second element, increment a3
42016c24:	018313        	lsip	f1, a3, 4
        madd.s f8, f0, f1                        // performs f32 multiplication 
42016c27:	4a8010        	madd.s	f8, f0, f1
    .Ltail_loop:
    ssi f8, a4, 0
42016c2a:	004483        	ssi	f8, a4, 0
 
    movi.n a2, 0                                // return VECTOR_SUCCESS
42016c2d:	020c      	movi.n	a2, 0
42016c2f:	f01d      	retw.n
42016c31:	000000        	ill

42016c34 <simd_mul_scalar_f32>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_mul_scalar_f32: 
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016c34:	002136        	entry	a1, 16
    extui a7, a5, 0, 2                          // extracts the lowest 2 bits of a5 into a7 (a5 % 4), for tail processing
42016c37:	147050        	extui	a7, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4)
42016c3a:	415250        	srli	a5, a5, 2
   
    lsip f4, a3, 0
42016c3d:	008343        	lsip	f4, a3, 0
42016c40:	0020f0        	nop
42016c43:	f03d      	nop.n
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42016c45:	139576        	loopnez	a5, 42016c5c <simd_mul_scalar_f32+0x28>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, post increment a2 by 16
42016c48:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        mul.s f3, f3, f4  
42016c4c:	2a3340        	mul.s	f3, f3, f4
        mul.s f2, f2, f4  
42016c4f:	2a2240        	mul.s	f2, f2, f4
        mul.s f1, f1, f4  
42016c52:	2a1140        	mul.s	f1, f1, f4
        mul.s f0, f0, f4     
42016c55:	2a0040        	mul.s	f0, f0, f4
        ee.stf.128.ip f3, f2, f1, f0, a4, 16    // store result, post increment a4 by 16
42016c58:	9109114e 	ee.stf.128.ip	f3, f2, f1, f0, a4, 16
42016c5c:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a7, .Ltail_loop
42016c5e:	089776        	loopnez	a7, 42016c6a <simd_mul_scalar_f32+0x36>
        lsip f0, a2, 4                          // load the first element, increment a2 
42016c61:	018203        	lsip	f0, a2, 4
        mul.s f0, f0, f4                        // performs f32 multiplication
42016c64:	2a0040        	mul.s	f0, f0, f4
        ssip f0, a4, 4                          // stores the result, increments a4
42016c67:	01c403        	ssip	f0, a4, 4
    .Ltail_loop:
 
    movi.n a2, 0                                // return VECTOR_SUCCESS
42016c6a:	020c      	movi.n	a2, 0
42016c6c:	f01d      	retw.n
	...

42016c70 <simd_mul_shift_f32>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_mul_shift_f32: 
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016c70:	002136        	entry	a1, 16
    extui a7, a6, 0, 2                          // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016c73:	147060        	extui	a7, a6, 0, 2
    srli a6, a6, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4)
42016c76:	416260        	srli	a6, a6, 2
   
    loopnez a6, .Lsimd_loop                     // loop until a5 == 0
42016c79:	179676        	loopnez	a6, 42016c94 <simd_mul_shift_f32+0x24>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, increment a2
42016c7c:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        ee.ldf.128.ip f7, f6, f5, f4, a3, 16    // load 4 elements from vec2, increment a3
42016c80:	834b513e 	ee.ldf.128.ip	f7, f6, f5, f4, a3, 16
        mul.s f3, f3, f7 
42016c84:	2a3370        	mul.s	f3, f3, f7
        mul.s f2, f2, f6 
42016c87:	2a2260        	mul.s	f2, f2, f6
        mul.s f1, f1, f5 
42016c8a:	2a1150        	mul.s	f1, f1, f5
        mul.s f0, f0, f4 
42016c8d:	2a0040        	mul.s	f0, f0, f4
        ee.stf.128.ip f3, f2, f1, f0, a4, 16    // store result
42016c90:	9109114e 	ee.stf.128.ip	f3, f2, f1, f0, a4, 16
42016c94:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a7, .Ltail_loop
42016c96:	0b9776        	loopnez	a7, 42016ca5 <simd_mul_shift_f32+0x35>
        lsip f0, a2, 4                          // load the first element, increment a2
42016c99:	018203        	lsip	f0, a2, 4
        lsip f1, a3, 4                          // load the second element, increment a3
42016c9c:	018313        	lsip	f1, a3, 4
        mul.s f0, f0, f1                        // performs f32 multiplication
42016c9f:	2a0010        	mul.s	f0, f0, f1
        ssip f0, a4, 4                          // stores the result, increments a4
42016ca2:	01c403        	ssip	f0, a4, 4
    .Ltail_loop:
 
    movi.n a2, 0                                // return VECTOR_SUCCESS
42016ca5:	020c      	movi.n	a2, 0
42016ca7:	f01d      	retw.n
42016ca9:	000000        	ill

42016cac <simd_sub_f32>:
 * @pre arr points must be 128-bit aligned
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_sub_f32:
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016cac:	002136        	entry	a1, 16
    extui a6, a5, 0, 2                          // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016caf:	146050        	extui	a6, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4)
42016cb2:	415250        	srli	a5, a5, 2
   
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42016cb5:	179576        	loopnez	a5, 42016cd0 <simd_sub_f32+0x24>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, increment a2
42016cb8:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        ee.ldf.128.ip f7, f6, f5, f4, a3, 16    // load 4 elements from vec2, increment a3
42016cbc:	834b513e 	ee.ldf.128.ip	f7, f6, f5, f4, a3, 16
        sub.s f3, f3, f7 
42016cc0:	1a3370        	sub.s	f3, f3, f7
        sub.s f2, f2, f6 
42016cc3:	1a2260        	sub.s	f2, f2, f6
        sub.s f1, f1, f5 
42016cc6:	1a1150        	sub.s	f1, f1, f5
        sub.s f0, f0, f4 
42016cc9:	1a0040        	sub.s	f0, f0, f4
        ee.stf.128.ip f3, f2, f1, f0, a4, 16    // store result
42016ccc:	9109114e 	ee.stf.128.ip	f3, f2, f1, f0, a4, 16
42016cd0:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a6, .Ltail_loop
42016cd2:	0b9676        	loopnez	a6, 42016ce1 <simd_sub_f32+0x35>
        lsip f0, a2, 4                          // load the first element, increment a2
42016cd5:	018203        	lsip	f0, a2, 4
        lsip f1, a3, 4                          // load the second element, increment a3
42016cd8:	018313        	lsip	f1, a3, 4
        sub.s f0, f0, f1                        // performs f32 subtraction
42016cdb:	1a0010        	sub.s	f0, f0, f1
        ssip f0, a4, 4                          // stores the result, increments a4
42016cde:	01c403        	ssip	f0, a4, 4
    .Ltail_loop:
 
    movi.n a2, 0                                // return exit code 0 (success)
42016ce1:	020c      	movi.n	a2, 0
    retw.n
42016ce3:	f01d      	retw.n
42016ce5:	000000        	ill

42016ce8 <simd_sum_f32>:
 * @pre The size in a4 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions. 
 */
simd_sum_f32: 
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016ce8:	002136        	entry	a1, 16
    extui a5, a4, 0, 2                          // extracts the lowest 2 bits of a4 into a5 (a4 % 4), for tail processing
42016ceb:	145040        	extui	a5, a4, 0, 2
    srli a4, a4, 2                              // shift a4 right by 2 to get the number of 16-byte blocks a4 = (a4 / 4)
42016cee:	414240        	srli	a4, a4, 2
    
    sub.s f4, f4,f4 
42016cf1:	1a4440        	sub.s	f4, f4, f4
42016cf4:	0020f0        	nop
42016cf7:	f03d      	nop.n
    loopnez a4, .Lsimd_loop                     // loop until a4 == 0
42016cf9:	0f9476        	loopnez	a4, 42016d0c <simd_sum_f32+0x24>
        ee.ldf.128.ip f3, f2, f1, f0, a2, 16    // load 4 elements from vec1, increment a2 
42016cfc:	8109112e 	ee.ldf.128.ip	f3, f2, f1, f0, a2, 16
        add.s f0, f0, f1
42016d00:	0a0010        	add.s	f0, f0, f1
        add.s f2, f2, f3
42016d03:	0a2230        	add.s	f2, f2, f3
        add.s f4, f4, f0
42016d06:	0a4400        	add.s	f4, f4, f0
        add.s f4, f4, f2 
42016d09:	0a4420        	add.s	f4, f4, f2
42016d0c:	f03d      	nop.n
    .Lsimd_loop:
 
    loopnez a5, .Ltail_loop
42016d0e:	059576        	loopnez	a5, 42016d17 <simd_sum_f32+0x2f>
        lsip f0, a2, 4                          // load the first element, increment a2 
42016d11:	018203        	lsip	f0, a2, 4
        add.s f4, f0, f4                        // performs f32 addition
42016d14:	0a4040        	add.s	f4, f0, f4
    .Ltail_loop:

    ssi f4, a3, 0                              // stores the result, 
42016d17:	004343        	ssi	f4, a3, 0
 
    movi.n a2, 0                                // return exit code 0 (success)
42016d1a:	020c      	movi.n	a2, 0
    retw.n
42016d1c:	f01d      	retw.n
	...

42016d20 <simd_ceil_i16>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_ceil_i16:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42016d20:	002136        	entry	a1, 16
    extui a6, a5, 0, 3                          // a6 = a5 % 8 (remaining tail elements)
42016d23:	246050        	extui	a6, a5, 0, 3
    srli a5, a5, 3                              // a5 = a5 / 8 (number of 8-byte SIMD blocks) 
42016d26:	415350        	srli	a5, a5, 3
    beqz a5, .Ltail_start                       // if no full blocks, skip SIMD loop
42016d29:	159c      	beqz.n	a5, 42016d3e <simd_ceil_i16+0x1e>

    // SIMD loop for 16-byte blocks  
    ee.vld.128.ip   q0, a2, 16                  // load 16 bytes from [a2] into q0, post-increment a2 by 16 
42016d2b:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.16.ip   q1, a4, 0                  // broadcast-load a4 into all lanes of q1
42016d2e:	858044        	ee.vldbc.16.ip	q1, a4, 0
    loopnez a5, .Lsimd_loop                     // repeat loop a5 times (zero-overhead loop counter)
42016d31:	069576        	loopnez	a5, 42016d3b <simd_ceil_i16+0x1b>
        ee.vmin.s16.ld.incp  q0, a2, q2, q0, q1 // q2 = min(q0, q1); applies the ceiling to q0, load next 16 bytes into q0, post-increment a2 
42016d34:	e0a20e2e 	ee.vmin.s16.ld.incp	q0, a2, q2, q0, q1
        ee.vst.128.ip  q2, a3, 16               // store result q2 to [a3], post-increment a3 by 16
42016d38:	9a0134        	ee.vst.128.ip	q2, a3, 16
    .Lsimd_loop:

    addi a2, a2, -16 // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42016d3b:	f0c222        	addi	a2, a2, -16

    .Ltail_start:  
    l16si a7, a4, 0                              // loads the ceiling into a7 
42016d3e:	009472        	l16si	a7, a4, 0

    // Handle remaining elements that are not in 16-byte blocks
    loopnez a6, .Ltail_loop
42016d41:	0c9676        	loopnez	a6, 42016d51 <simd_ceil_i16+0x31>
        l16si a8, a2, 0                         // loads and sign-extends the element into a8 
42016d44:	009282        	l16si	a8, a2, 0
        min a8, a8, a7                          // applies the ceiling to a8 
42016d47:	438870        	min	a8, a8, a7
        s16i a8, a3, 0                          // store the result in address at a3 
42016d4a:	005382        	s16i	a8, a3, 0
        addi.n a2, a2, 2                        // increment pointers 
42016d4d:	222b      	addi.n	a2, a2, 2
        addi.n a3, a3, 2 
42016d4f:	332b      	addi.n	a3, a3, 2
    .Ltail_loop:  

    movi.n a2, 0                                // return exit code 0 (success)
42016d51:	020c      	movi.n	a2, 0
    retw.n
42016d53:	f01d      	retw.n
42016d55:	000000        	ill

42016d58 <simd_copy_i16>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_copy_i16:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016d58:	002136        	entry	a1, 16
    extui a5, a4, 0, 3                              // extracts the lowest 3 bits of a4 into a5 (a4 % 8), for tail processing
42016d5b:	245040        	extui	a5, a4, 0, 3
    srli a4, a4, 3                                  // shift a4 right by 3 to get the number of 16-byte blocks (a4 / 8) 
42016d5e:	414340        	srli	a4, a4, 3
 
    loopnez a4, .Lsimd_loop                         // loop until a4 == 0
42016d61:	059476        	loopnez	a4, 42016d6a <simd_copy_i16+0x12>
        ee.vld.128.ip     q1, a2, 16                // loads 16 bytes from a2 into q1, increment a32 by 16 
42016d64:	838124        	ee.vld.128.ip	q1, a2, 16
        ee.vst.128.ip     q1, a3, 16                // stores 16 bytes from q1 to address at a3, increment a3 by 16
42016d67:	8a8134        	ee.vst.128.ip	q1, a3, 16
    .Lsimd_loop: 
    
    loopnez a5, .Ltail_loop                         // Handle remaining elements that are not a multiple of 8
42016d6a:	099576        	loopnez	a5, 42016d77 <simd_copy_i16+0x1f>
        l16ui a7, a2, 0   
42016d6d:	001272        	l16ui	a7, a2, 0
        addi.n a2, a2, 2                            // increment pointers
42016d70:	222b      	addi.n	a2, a2, 2
        s16i a7, a3, 0                              // store the saturated result in address at a3 
42016d72:	005372        	s16i	a7, a3, 0
        addi.n a3, a3, 2                            // increment pointers 
42016d75:	332b      	addi.n	a3, a3, 2
    .Ltail_loop:  

    movi.n a2, 0                                    // return exit code 0 (success)
42016d77:	020c      	movi.n	a2, 0
    retw.n
42016d79:	f01d      	retw.n
	...

42016d7c <simd_dotp_i16>:
 * @pre The size in a5 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_dotp_i16:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016d7c:	002136        	entry	a1, 16
    extui a6, a5, 0, 3                              // extracts the lowest 3 bits of a5 into a6 (a5 % 8), for tail processing
42016d7f:	246050        	extui	a6, a5, 0, 3
    srli a5, a5, 3                                  // shift a5 right by 3 to get the number of 16-byte blocks (a5 / 8)
42016d82:	415350        	srli	a5, a5, 3
    xor a7, a7, a7                                  // zeros a7
42016d85:	307770        	xor	a7, a7, a7
    beqz a5, .Ltail_start                           // if no full blocks (a5 == 0), skip SIMD and go to scalar tail
42016d88:	015516        	beqz	a5, 42016da1 <simd_dotp_i16+0x25>

    // SIMD addition loop for 16-byte blocks 
    ee.zero.accx                                    // clears the QACC register
42016d8b:	250804        	ee.zero.accx
    ee.vld.128.ip     q0, a2, 16                    // loads 16 bytes from a2 into q0, then increment a2 by 16
42016d8e:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a5, .Lsimd_loop                         // loop until a5 == 0
42016d91:	069576        	loopnez	a5, 42016d9b <simd_dotp_i16+0x1f>
        ee.vld.128.ip     q1, a3, 16                // loads 16 bytes from a3 into q1, then increments a3 by 16
42016d94:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vmulas.s16.accx.ld.ip q0, a2, 16, q0, q1 // multiply-accumulates q0 and q1, stores result in QACC, increments a2, updates q0
42016d97:	f080012e 	ee.vmulas.s16.accx.ld.ip	q0, a2, 16, q0, q1
    .Lsimd_loop:

    rur.accx_0 a7                                   // write the lower 32 bits of QACC into a7
42016d9b:	e37000        	rur.accx_0	a7
    addi a2, a2, -16                                // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42016d9e:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    // Handle remaining elements that were not part of a full 16-byte block 
 
    loopnez a6, .Ltail_loop 
42016da1:	0e9676        	loopnez	a6, 42016db3 <simd_dotp_i16+0x37>
        l16si a8, a2, 0
42016da4:	009282        	l16si	a8, a2, 0
        l16si a9, a3, 0 
42016da7:	009392        	l16si	a9, a3, 0
        mull a8, a8, a9
42016daa:	828890        	mull	a8, a8, a9
        add a7, a7, a8
42016dad:	778a      	add.n	a7, a7, a8
        addi a2, a2, 2
42016daf:	222b      	addi.n	a2, a2, 2
        addi a3, a3, 2
42016db1:	332b      	addi.n	a3, a3, 2
    .Ltail_loop:
        
    s32i.n a7, a4, 0
42016db3:	0479      	s32i.n	a7, a4, 0
    movi.n a2,  0                                   //return exit code 0 (success)
42016db5:	020c      	movi.n	a2, 0
    retw.n
42016db7:	f01d      	retw.n
42016db9:	000000        	ill

42016dbc <simd_mul_scalar_i16>:
    *   a5 - The shift value
    *   a6 - number of elements in the vector
    * Returns: 0 on success
*/
simd_mul_scalar_i16:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016dbc:	002136        	entry	a1, 16

    extui a7, a5, 28, 4                             // if shift_amount >15 return VECTOR_INVALID ARGUMENT
42016dbf:	357c50        	extui	a7, a5, 28, 4
    bnez  a7, .Lbad_shift
42016dc2:	67fc      	bnez.n	a7, 42016dfc <simd_mul_scalar_i16+0x40>

    extui a7, a6, 0, 3                              // moves the last 4 bits (i.e. number of elements that are not a multiple of 16) into a7
42016dc4:	247060        	extui	a7, a6, 0, 3
    srli a6, a6, 3                                  // bit shift to convert number of 8-bit elements to number of 128-bit blocks
42016dc7:	416360        	srli	a6, a6, 3
    wsr a5, SAR                                     // set the Shift Amount Register (SAR) to the value in a5
42016dca:	130350        	wsr.sar	a5
    beqz a6, .Ltail_start                           // if a6 is zero, skip the SIMD addition loop
42016dcd:	169c      	beqz.n	a6, 42016de2 <simd_mul_scalar_i16+0x26>

    // SIMD addition loop for 16 byte blocks
    ee.vld.128.ip     q0, a2, 16                    // loads 16 bytes from a2 into q0 (128-bit vector load), increments a2
42016dcf:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.16.ip     q1, a3, 0                    // load the 16-bit scalar value at the address of a3 and broadcasts it into q1,
42016dd2:	858034        	ee.vldbc.16.ip	q1, a3, 0
    loopnez a6, .Lsimd_end
42016dd5:	069676        	loopnez	a6, 42016ddf <simd_mul_scalar_i16+0x23>
        ee.vmul.s16.ld.incp q0, a2, q4, q0, q1      // adds q0 and q1, stores result in q4, increments a2, updates q0
42016dd8:	e0b40f2e 	ee.vmul.s16.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16                // stores result from q4 into a4, increments a4
42016ddc:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_end:

    addi a2, a2, -16                                // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42016ddf:	f0c222        	addi	a2, a2, -16

    .Ltail_start:

    // After processing all full 16-byte blocks, we handle the remaining elements
    l16si a9, a3, 0                                 // Load the scalar value to be added, sign-extended to 32 bit 
42016de2:	009392        	l16si	a9, a3, 0

    loopnez a7, .Ltail_end
42016de5:	0f9776        	loopnez	a7, 42016df8 <simd_mul_scalar_i16+0x3c>
        l16si a8, a2, 0                             // Loads and sign-extends the elements of the scalar tail 
42016de8:	009282        	l16si	a8, a2, 0

        mull a8, a8, a9                             // perform signed multiplication
42016deb:	828890        	mull	a8, a8, a9
        srl a8, a8                                  // apply the bit shift from SAR
42016dee:	918080        	srl	a8, a8
        s16i a8, a4, 0                              // store the shifted result in address at a4
42016df1:	005482        	s16i	a8, a4, 0

        addi a2, a2, 2                              // increment pointers
42016df4:	222b      	addi.n	a2, a2, 2
        addi a4, a4, 2
42016df6:	442b      	addi.n	a4, a4, 2
    .Ltail_end:

    movi.n a2, 0                                    // return VECTOR_SUCCESS
42016df8:	020c      	movi.n	a2, 0
    retw.n
42016dfa:	f01d      	retw.n

    .Lbad_shift:
    movi.n a2, 2                                    // return VECTOR_INVALID_ARGUMENT
42016dfc:	220c      	movi.n	a2, 2
    retw.n
42016dfe:	f01d      	retw.n

42016e00 <simd_mul_shift_i16>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_mul_shift_i16:
    entry a1, 16                                // reserve 16 bytes for the stack  
42016e00:	002136        	entry	a1, 16
    extui a7, a5, 28, 4                         // if shift_amount >15 return VECTOR_INVALID ARGUMENT
42016e03:	357c50        	extui	a7, a5, 28, 4
    bnez  a7, .Lbad_shift
42016e06:	87fc      	bnez.n	a7, 42016e42 <simd_mul_shift_i16+0x42>
    extui a7, a6, 0, 3                          // extracts the lowest 3 bits of a6 into a7 (a6 % 8), for tail processing
42016e08:	247060        	extui	a7, a6, 0, 3
    srli a6, a6, 3                              // shift a6 right by 3 to get the number of 16-byte blocks (a6 / 8)
42016e0b:	416360        	srli	a6, a6, 3
    wsr a5, sar                                 // store the bit shift value in SAR (Shift Amount Register)
42016e0e:	130350        	wsr.sar	a5
    beqz a6, .Ltail_start                       // if no full blocks (a6 == 0), skip SIMD and go to scalar tail
42016e11:	169c      	beqz.n	a6, 42016e26 <simd_mul_shift_i16+0x26>

    // SIMD multiplication loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0, then increment a2 by 16
42016e13:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a6, .Lsimd_loop                     // loop until a6 == 0
42016e16:	099676        	loopnez	a6, 42016e23 <simd_mul_shift_i16+0x23>
        ee.vld.128.ip     q1, a3, 16            // loads 16 bytes from a3 into q1, increment a3 by 16
42016e19:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vmul.s16.ld.incp q0, a2, q4, q0, q1  // multiplies q0 and q1, stores result in q4, increments a2, updates q0
42016e1c:	e0b40f2e 	ee.vmul.s16.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores 16 bytes from q4 to address at a4, increment a4 by 16
42016e20:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42016e23:	f0c222        	addi	a2, a2, -16

    .Ltail_start: 
    loopnez a7, .Ltail_loop                     // Handle remaining elements that were not part of a full 16-byte block 
42016e26:	149776        	loopnez	a7, 42016e3e <simd_mul_shift_i16+0x3e>
        l16si a8, a2, 0                         // loads and sign-extends the elements of the two vectors
42016e29:	009282        	l16si	a8, a2, 0
        l16si a9, a3, 0 
42016e2c:	009392        	l16si	a9, a3, 0

        mull a8, a8, a9                         // perform signed multiplication
42016e2f:	828890        	mull	a8, a8, a9
        srl a8, a8                              // apply the bit shift from SAR
42016e32:	918080        	srl	a8, a8
        s16i a8, a4, 0                          // store the shifted result in address at a4
42016e35:	005482        	s16i	a8, a4, 0

        addi a2, a2, 2                          // increment pointers
42016e38:	222b      	addi.n	a2, a2, 2
        addi a3, a3, 2
42016e3a:	332b      	addi.n	a3, a3, 2
        addi a4, a4, 2
42016e3c:	442b      	addi.n	a4, a4, 2
    .Ltail_loop:

    movi.n a2, 0                                // return VECTOR_SUCCESS
42016e3e:	020c      	movi.n	a2, 0
    retw.n
42016e40:	f01d      	retw.n

    .Lbad_shift:
    movi.n a2, 2                                // return VECTOR_INVALID_ARGUMENT
42016e42:	220c      	movi.n	a2, 2
    retw.n
42016e44:	f01d      	retw.n
	...

42016e48 <simd_sum_i16>:
 * @pre The size in a4 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_sum_i16:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016e48:	002136        	entry	a1, 16
    extui a5, a4, 0, 3                              // extracts the lowest 3 bits of a4 into a5 (a4 % 8), for tail processing
42016e4b:	245040        	extui	a5, a4, 0, 3
    srli a4, a4, 3                                  // shift a4 right by 3 to get the number of 16-byte blocks (a4 / 8)
42016e4e:	414340        	srli	a4, a4, 3
    movi.n a6, 0                                    // zeros a6 in case we go straight to the scalar tail
42016e51:	00a062        	movi	a6, 0
    beqz a4, .Ltail_start                           // if no full blocks (a4 == 0), skip SIMD and go to scalar tail
42016e54:	a49c      	beqz.n	a4, 42016e72 <simd_sum_i16+0x2a>

    // SIMD addition loop for 16-byte blocks 
    movi.n a7, 1                                    // sets a7 to 0x01
42016e56:	01a072        	movi	a7, 1
    s16i a7, a1, 0                                  // stores 0x01 on the stack
42016e59:	005172        	s16i	a7, a1, 0
    ee.zero.accx                                    // clears the QACC register
42016e5c:	250804        	ee.zero.accx
    ee.vld.128.ip     q0, a2, 16                    // loads 16 bytes from a2 into q0, then increment a2 by 16
42016e5f:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.16.ip     q1, a1, 0                    // broadcast loads the ones vector into q1
42016e62:	858014        	ee.vldbc.16.ip	q1, a1, 0
    loopnez a4, .Lsimd_loop                         // loop until a4 == 0
42016e65:	039476        	loopnez	a4, 42016e6c <simd_sum_i16+0x24>
        ee.vmulas.s16.accx.ld.ip q0, a2, 16, q0, q1 // multiply-accumulates q0 and q1, stores result in QACC, increments a2, updates q0
42016e68:	f080012e 	ee.vmulas.s16.accx.ld.ip	q0, a2, 16, q0, q1
    .Lsimd_loop:

    rur.accx_0 a6                                   // write the lower 32 bits of QACC into a6
42016e6c:	e36000        	rur.accx_0	a6
    addi a2, a2, -16                                // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42016e6f:	f0c222        	addi	a2, a2, -16

    
    // Handle remaining elements that were not part of a full 16-byte block 
    .Ltail_start:
    loopnez a5, .Ltail_loop 
42016e72:	069576        	loopnez	a5, 42016e7c <simd_sum_i16+0x34>
        l16si a7, a2, 0 
42016e75:	009272        	l16si	a7, a2, 0
        add a6, a7, a6 
42016e78:	676a      	add.n	a6, a7, a6
        addi a2, a2, 2
42016e7a:	222b      	addi.n	a2, a2, 2
    .Ltail_loop:  
        
    s32i.n a6, a3, 0
42016e7c:	0369      	s32i.n	a6, a3, 0
    movi.n a2,  0                                   //return exit code 0 (success)
42016e7e:	020c      	movi.n	a2, 0
    retw.n
42016e80:	f01d      	retw.n
	...

42016e84 <simd_abs_i32>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_abs_i32:
    entry a1, 16                                 // reserve 16 bytes for the stack frame 
42016e84:	002136        	entry	a1, 16
    extui a5, a4, 0, 2                           // extracts the lowest 2 bits of a5 into a5 (a4 % 4), for tail processing
42016e87:	145040        	extui	a5, a4, 0, 2
    srli a4, a4, 2                               // shift a5 right by 2 to get the number of 16-byte blocks a4 = (a4 / 4)
42016e8a:	414240        	srli	a4, a4, 2

    // Processes 16 byte chunnks
    loopnez a4, .Lsimd_loop                     
42016e8d:	219476        	loopnez	a4, 42016eb2 <simd_abs_i32+0x2e>
        l32i.n a6, a2, 0                         // loads and sign-extends the elements of the two vectors
42016e90:	0268      	l32i.n	a6, a2, 0
        l32i.n a7, a2, 4  
42016e92:	1278      	l32i.n	a7, a2, 4
        l32i.n a8, a2, 8  
42016e94:	2288      	l32i.n	a8, a2, 8
        l32i.n a9, a2, 12   
42016e96:	3298      	l32i.n	a9, a2, 12
        
        abs a6, a6                                // perform absolute value
42016e98:	606160        	abs	a6, a6
        abs a7, a7 
42016e9b:	607170        	abs	a7, a7
        abs a8, a8
42016e9e:	608180        	abs	a8, a8
        abs a9, a9
42016ea1:	609190        	abs	a9, a9
 
        s32i.n a6, a3, 0                          // store the result in address at a4
42016ea4:	0369      	s32i.n	a6, a3, 0
        s32i.n a7, a3, 4                          // store the result in address at a4
42016ea6:	1379      	s32i.n	a7, a3, 4
        s32i.n a8, a3, 8                          // store the result in address at a4
42016ea8:	2389      	s32i.n	a8, a3, 8
        s32i.n a9, a3, 12                         // store the result in address at a4
42016eaa:	3399      	s32i.n	a9, a3, 12
 
        addi.n a2, a2, 16                         // increment pointers
42016eac:	10c222        	addi	a2, a2, 16
        addi.n a3, a3, 16 
42016eaf:	10c332        	addi	a3, a3, 16
    .Lsimd_loop:  

    loopnez a5, .Ltail_loop
42016eb2:	0a9576        	loopnez	a5, 42016ec0 <simd_abs_i32+0x3c>
        l32i.n a6, a2, 0                          // loads and sign-extends the elements of the two vectors 
42016eb5:	0268      	l32i.n	a6, a2, 0
        abs a6, a6                                // performs abs
42016eb7:	606160        	abs	a6, a6
        s32i.n a6, a3, 0                          // store the result in address at a4
42016eba:	0369      	s32i.n	a6, a3, 0
        addi a2, a2, 4                            // increment pointers
42016ebc:	224b      	addi.n	a2, a2, 4
        addi a3, a3, 4
42016ebe:	334b      	addi.n	a3, a3, 4
    .Ltail_loop:

    movi.n a2, 0                                  // return exit code 0 (success)
42016ec0:	020c      	movi.n	a2, 0
    retw.n
42016ec2:	f01d      	retw.n

42016ec4 <simd_add_i32>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_i32:
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016ec4:	002136        	entry	a1, 16
    extui a14, a5, 0, 2                         // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016ec7:	14e050        	extui	a14, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4) 
42016eca:	415250        	srli	a5, a5, 2
 
    // SIMD addition loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0, then increment a2 by 16
42016ecd:	830124        	ee.vld.128.ip	q0, a2, 16
42016ed0:	f03d      	nop.n
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
42016ed2:	099576        	loopnez	a5, 42016edf <simd_add_i32+0x1b>
        ee.vld.128.ip     q1, a3, 16            // loads 16 bytes from a3 into q1, increment a3 by 16
42016ed5:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vadds.s32.ld.incp q0, a2, q4, q0, q1 // adds q0 and q1, stores result in q4, increments a2, updates q0
42016ed8:	e0b40d2e 	ee.vadds.s32.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores 16 bytes from q4 to address at a4, increment a4 by 16
42016edc:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:
 
    // Scalar tail                              // q0 is loaded either from .Lsimd_loop or the load before it
    ee.vld.128.ip     q1, a3, 0                 // loads 16 bytes from a3 into q1
42016edf:	838034        	ee.vld.128.ip	q1, a3, 0
    ee.vadds.s32      q0, q0, q1                // performs saturated int32 addition on q0 and q1 into q0
42016ee2:	8e0874        	ee.vadds.s32	q0, q0, q1

    beqz a14, .func_end                          // ends if no scalar tail
42016ee5:	7e9c      	beqz.n	a14, 42016f00 <.func_end>
    ee.movi.32.a q0, a6, 0                      
42016ee7:	cd7164        	ee.movi.32.a	q0, a6, 0
    s32i.n a6, a4, 0 
42016eea:	0469      	s32i.n	a6, a4, 0
    addi a14, a14, -1
42016eec:	ee0b      	addi.n	a14, a14, -1

    beqz a14, .func_end
42016eee:	ee8c      	beqz.n	a14, 42016f00 <.func_end>
    ee.movi.32.a q0, a6, 1
42016ef0:	cd7564        	ee.movi.32.a	q0, a6, 1
    s32i.n a6, a4, 4 
42016ef3:	1469      	s32i.n	a6, a4, 4
    addi a14, a14, -1
42016ef5:	ee0b      	addi.n	a14, a14, -1

    beqz a14, .func_end
42016ef7:	5e8c      	beqz.n	a14, 42016f00 <.func_end>
    ee.movi.32.a q0, a6, 2
42016ef9:	cd7964        	ee.movi.32.a	q0, a6, 2
    s32i.n a6, a4, 8 
42016efc:	2469      	s32i.n	a6, a4, 8
    addi a14, a14, -1
42016efe:	ee0b      	addi.n	a14, a14, -1

42016f00 <.func_end>:
     
    .func_end:
    movi.n a2, 0                                // return exit code 0 (success)
42016f00:	020c      	movi.n	a2, 0
    retw.n
42016f02:	f01d      	retw.n

42016f04 <simd_add_scalar_i32>:
 * @pre arrs need to be 128 bit aligned
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_scalar_i32:
    entry a1, 16                                // reserve 16 bytes for the stack frame 
42016f04:	002136        	entry	a1, 16
    extui a14, a5, 0, 2                         // extracts the lowest 2 bits of a5 into a14 (a5 % 4), for tail processing
42016f07:	14e050        	extui	a14, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks a5 = (a5 / 4) 
42016f0a:	415250        	srli	a5, a5, 2

    // Processes 16 byte chunks 
    ee.vld.128.ip      q0, a2, 16               // loads 16 bytes from a2 into q0 (128-bit vector load), increments a2
42016f0d:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.32.ip     q1, a3, 0                // load the 32-bit scalar value at the address of a3 and broadcasts it into q1,
42016f10:	828034        	ee.vldbc.32.ip	q1, a3, 0
42016f13:	f03d      	nop.n
    loopnez a5, .Lsimd_end  
42016f15:	069576        	loopnez	a5, 42016f1f <simd_add_scalar_i32+0x1b>
        ee.vadds.s32.ld.incp q0, a2, q4, q0, q1 // adds q0 and q1, stores result in q4, increments a2, updates q0
42016f18:	e0b40d2e 	ee.vadds.s32.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores result from q4 into a4, increments a4
42016f1c:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_end:

    // Scalar tail                              // q0 is loaded either from .Lsimd_loop or the load before it 
    ee.vadds.s32      q0, q0, q1                // performs saturated int32 addition on q0 and q1 into q0
42016f1f:	8e0874        	ee.vadds.s32	q0, q0, q1

    beqz a14, .func_end                         // ends if no scalar tail
42016f22:	7e9c      	beqz.n	a14, 42016f3d <.func_end>
    ee.movi.32.a q0, a6, 0                      
42016f24:	cd7164        	ee.movi.32.a	q0, a6, 0
    s32i.n a6, a4, 0 
42016f27:	0469      	s32i.n	a6, a4, 0
    addi a14, a14, -1
42016f29:	ee0b      	addi.n	a14, a14, -1

    beqz a14, .func_end
42016f2b:	ee8c      	beqz.n	a14, 42016f3d <.func_end>
    ee.movi.32.a q0, a6, 1
42016f2d:	cd7564        	ee.movi.32.a	q0, a6, 1
    s32i.n a6, a4, 4 
42016f30:	1469      	s32i.n	a6, a4, 4
    addi a14, a14, -1
42016f32:	ee0b      	addi.n	a14, a14, -1

    beqz a14, .func_end
42016f34:	5e8c      	beqz.n	a14, 42016f3d <.func_end>
    ee.movi.32.a q0, a6, 2
42016f36:	cd7964        	ee.movi.32.a	q0, a6, 2
    s32i.n a6, a4, 8 
42016f39:	2469      	s32i.n	a6, a4, 8
    addi a14, a14, -1
42016f3b:	ee0b      	addi.n	a14, a14, -1

42016f3d <.func_end>:

    .func_end:
    movi.n a2, 0                                // return exit code 0 (success)
42016f3d:	020c      	movi.n	a2, 0
    retw.n
42016f3f:	f01d      	retw.n
42016f41:	000000        	ill

42016f44 <simd_ceil_i32>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_ceil_i32:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42016f44:	002136        	entry	a1, 16
    extui a6, a5, 0, 2                          // a6 = a5 % 2 (remaining tail elements)
42016f47:	146050        	extui	a6, a5, 0, 2
    srli a5, a5, 2                              // a5 = a5 / 2 (number of 8-byte blocks)   
42016f4a:	415250        	srli	a5, a5, 2
    beqz a5, .Ltail_start
42016f4d:	159c      	beqz.n	a5, 42016f62 <simd_ceil_i32+0x1e>

    ee.vld.128.ip           q0, a2, 16          // load 16 bytes from [a2] into q0, post-increment a2 by 16 
42016f4f:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.32.ip          q1, a4, 0           // broadcast-load a4 into all lanes of q1
42016f52:	828044        	ee.vldbc.32.ip	q1, a4, 0
    loopnez a5, .Lsimd_loop                     // repeat loop a5 times (zero-overhead loop counter)
42016f55:	069576        	loopnez	a5, 42016f5f <simd_ceil_i32+0x1b>
        ee.vmin.s32.ld.incp q0, a2, q2, q0, q1  // q2 = min(q0, q1); applies the ceiling to q0, load next 16 bytes into q0, post-increment a2 
42016f58:	e0b20e2e 	ee.vmin.s32.ld.incp	q0, a2, q2, q0, q1
        ee.vst.128.ip       q2, a3, 16          // store result q2 to [a3], post-increment a3 by 16
42016f5c:	9a0134        	ee.vst.128.ip	q2, a3, 16
    .Lsimd_loop:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42016f5f:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    l32i.n a4, a4, 0                            // loads max_val into a4 
42016f62:	0448      	l32i.n	a4, a4, 0
42016f64:	f03d      	nop.n
    // Handle remaining elements that are not in 16 byte blocks
    loopnez a6, .Ltail_loop
42016f66:	0a9676        	loopnez	a6, 42016f74 <simd_ceil_i32+0x30>
        l32i.n a7, a2, 0                        // loads and sign-extends the element into a7 
42016f69:	0278      	l32i.n	a7, a2, 0
        addi.n a2, a2, 4                        // increment pointers 
42016f6b:	224b      	addi.n	a2, a2, 4
        min a7, a7, a4                          // applies the ceiling to a7
42016f6d:	437740        	min	a7, a7, a4
        s32i.n a7, a3, 0                        // store the result in address at a3 
42016f70:	0379      	s32i.n	a7, a3, 0
        addi.n a3, a3, 4 
42016f72:	334b      	addi.n	a3, a3, 4
    .Ltail_loop:  

    movi.n a2, 0                                // return exit code 0 (success)
42016f74:	020c      	movi.n	a2, 0
    retw.n
42016f76:	f01d      	retw.n

42016f78 <simd_dotp_i32>:
 * @pre The size in a5 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_dotp_i32:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016f78:	002136        	entry	a1, 16
    extui a6, a5, 0, 2                              // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
42016f7b:	146050        	extui	a6, a5, 0, 2
    srli a5, a5, 2                                  // shift a5 right by 2 to get the number of 16-byte blocks (a5 / 4)  
42016f7e:	415250        	srli	a5, a5, 2
    movi.n a11, 0                                   // 
42016f81:	0b0c      	movi.n	a11, 0


    // SIMD addition loop for 16-byte blocks  
    loopnez a5, .Lsimd_loop
42016f83:	299576        	loopnez	a5, 42016fb0 <simd_dotp_i32+0x38>
        l32i.n a7, a2, 0
42016f86:	0278      	l32i.n	a7, a2, 0
        l32i.n a8, a3, 0
42016f88:	0388      	l32i.n	a8, a3, 0
        mull a7, a7, a8
42016f8a:	827780        	mull	a7, a7, a8
        l32i.n a9, a2, 4
42016f8d:	1298      	l32i.n	a9, a2, 4
        l32i.n a10, a3, 4
42016f8f:	13a8      	l32i.n	a10, a3, 4
        add.n a11, a7, a11
42016f91:	b7ba      	add.n	a11, a7, a11
        mull a9, a9, a10
42016f93:	8299a0        	mull	a9, a9, a10
        l32i.n a7, a2, 8
42016f96:	2278      	l32i.n	a7, a2, 8
        l32i.n a8, a3, 8
42016f98:	2388      	l32i.n	a8, a3, 8
        add.n a11, a9, a11
42016f9a:	b9ba      	add.n	a11, a9, a11
        mull a7, a7, a8
42016f9c:	827780        	mull	a7, a7, a8
        l32i.n a9, a2, 12
42016f9f:	3298      	l32i.n	a9, a2, 12
        l32i.n a10, a3, 12
42016fa1:	33a8      	l32i.n	a10, a3, 12
        add.n a11, a7, a11
42016fa3:	b7ba      	add.n	a11, a7, a11
        mull a9, a9, a10
42016fa5:	8299a0        	mull	a9, a9, a10
        addi a2, a2, 16
42016fa8:	10c222        	addi	a2, a2, 16
        addi a3, a3, 16
42016fab:	10c332        	addi	a3, a3, 16
        add.n a11, a9, a11 
42016fae:	b9ba      	add.n	a11, a9, a11
42016fb0:	f03d      	nop.n
        addi    a2, a2, 16
        addi    a3, a3, 16 */
     
    // Handle remaining elements that were not part of a full 16-byte block 
 
    loopnez a6, .Ltail_loop 
42016fb2:	0c9676        	loopnez	a6, 42016fc2 <simd_dotp_i32+0x4a>
        l32i.n a8, a2, 0
42016fb5:	0288      	l32i.n	a8, a2, 0
        l32i.n a9, a3, 0 
42016fb7:	0398      	l32i.n	a9, a3, 0
        mull a8, a8, a9
42016fb9:	828890        	mull	a8, a8, a9
        addi.n a2, a2, 4
42016fbc:	224b      	addi.n	a2, a2, 4
        addi.n a3, a3, 4
42016fbe:	334b      	addi.n	a3, a3, 4
        add.n a11, a11, a8
42016fc0:	bb8a      	add.n	a11, a11, a8
    .Ltail_loop:
    
    s32i.n a11, a4, 0
42016fc2:	04b9      	s32i.n	a11, a4, 0
    movi.n a2,  0                                   //return exit code 0 (success)
42016fc4:	020c      	movi.n	a2, 0
    retw.n
42016fc6:	f01d      	retw.n

42016fc8 <simd_mul_scalar_i32>:
    *   a5 - The shift value
    *   a6 - number of elements in the vector
    * Returns: 0 on success
*/
simd_mul_scalar_i32:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42016fc8:	002136        	entry	a1, 16

    extui a7, a5, 27, 5                             // if shift_amount >31 return VECTOR_INVALID ARGUMENT
42016fcb:	457b50        	extui	a7, a5, 27, 5
    bnez  a7, .Lbad_shift
42016fce:	060756        	bnez	a7, 42017032 <simd_mul_scalar_i32+0x6a>

    extui a7, a6, 0, 2                              // moves the last 2 bits (i.e. number of elements that are not a multiple of 16)  
42016fd1:	147060        	extui	a7, a6, 0, 2
    srli a6, a6, 2                                  // bit shift to convert number of 32-bit elements to number of 128-bit blocks
42016fd4:	416260        	srli	a6, a6, 2
    
    
    l32i a8, a3, 0                                  // Load scalar value
42016fd7:	002382        	l32i	a8, a3, 0
    wsr a5, sar                                      // Load shift amount register
42016fda:	130350        	wsr.sar	a5
    loopnez a6, .Lhead_end                          // 4x loop unrolling
42016fdd:	399676        	loopnez	a6, 4201701a <simd_mul_scalar_i32+0x52>
        l32i.n   a9,  a2, 0                         // Load first two values
42016fe0:	0298      	l32i.n	a9, a2, 0
        l32i.n   a10, a2, 4 
42016fe2:	12a8      	l32i.n	a10, a2, 4
        mulsh     a11, a9,  a8                       // multiply into int64
42016fe4:	b2b980        	mulsh	a11, a9, a8
        mull     a9,  a9,  a8
42016fe7:	829980        	mull	a9, a9, a8
        mulsh     a12, a10, a8           
42016fea:	b2ca80        	mulsh	a12, a10, a8
        mull     a10, a10, a8
42016fed:	82aa80        	mull	a10, a10, a8
        src      a9, a11, a9                        // right funnel shift (a11||a9) >> SAR 
42016ff0:	819b90        	src	a9, a11, a9
        src      a10, a12, a10
42016ff3:	81aca0        	src	a10, a12, a10
        s32i.n      a9,  a4, 0
42016ff6:	0499      	s32i.n	a9, a4, 0
        s32i.n      a10, a4, 4  
42016ff8:	14a9      	s32i.n	a10, a4, 4
        l32i.n   a9,  a2, 8
42016ffa:	2298      	l32i.n	a9, a2, 8
        l32i.n   a10, a2, 12 
42016ffc:	32a8      	l32i.n	a10, a2, 12
        mulsh     a11, a9,  a8
42016ffe:	b2b980        	mulsh	a11, a9, a8
        mull     a9,  a9,  a8 
42017001:	829980        	mull	a9, a9, a8
        mulsh     a12, a10, a8
42017004:	b2ca80        	mulsh	a12, a10, a8
        mull     a10, a10, a8
42017007:	82aa80        	mull	a10, a10, a8
        src      a9,  a11, a9
4201700a:	819b90        	src	a9, a11, a9
        src      a10, a12, a10 
4201700d:	81aca0        	src	a10, a12, a10
        s32i.n      a9,  a4, 8
42017010:	2499      	s32i.n	a9, a4, 8
        s32i.n      a10, a4, 12 
42017012:	34a9      	s32i.n	a10, a4, 12
        addi     a2,  a2, 16                        // increment pointers
42017014:	10c222        	addi	a2, a2, 16
        addi     a4,  a4, 16
42017017:	10c442        	addi	a4, a4, 16
    .Lhead_end:
  
    // After processing all full 16-byte blocks, we handle the remaining elements 
    loopnez a7, .Ltail_end 
4201701a:	109776        	loopnez	a7, 4201702e <simd_mul_scalar_i32+0x66>
        l32i.n a9, a2, 0
4201701d:	0298      	l32i.n	a9, a2, 0
        mull a10, a9, a8
4201701f:	82a980        	mull	a10, a9, a8
        mulsh a11, a9, a8
42017022:	b2b980        	mulsh	a11, a9, a8
        addi.n  a2, a2, 4                              
42017025:	224b      	addi.n	a2, a2, 4
        src a9, a11, a10
42017027:	819ba0        	src	a9, a11, a10
        s32i.n a9, a4, 0 
4201702a:	0499      	s32i.n	a9, a4, 0
        addi.n  a4, a4, 4
4201702c:	444b      	addi.n	a4, a4, 4
    .Ltail_end:

    movi.n a2, 0                                    // return VECTOR_SUCCESS
4201702e:	020c      	movi.n	a2, 0
    retw.n
42017030:	f01d      	retw.n

    .Lbad_shift:
    movi.n a2, 2                                    // return VECTOR_INVALID_ARGUMENT
42017032:	220c      	movi.n	a2, 2
42017034:	f01d      	retw.n
	...

42017038 <simd_mul_shift_i32>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_mul_shift_i32:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42017038:	002136        	entry	a1, 16
    extui a7, a5, 27, 5                             // if shift_amount >31 return VECTOR_INVALID ARGUMENT
4201703b:	457b50        	extui	a7, a5, 27, 5
    bnez  a7, .Lbad_shift
4201703e:	06c756        	bnez	a7, 420170ae <simd_mul_shift_i32+0x76>
    extui a7, a6, 0, 2                          // extracts the lowest 2 bits of a6 into a7 (a6 % 4), for tail processing
42017041:	147060        	extui	a7, a6, 0, 2
    srli a6, a6, 2                              // shift a6 right by 2 to get the number of 16-byte blocks (a6 / 4)
42017044:	416260        	srli	a6, a6, 2
    wsr a5, sar                                 // store the bit shift value in SAR (Shift Amount Register)
42017047:	130350        	wsr.sar	a5

    // 4x loop unrolling
    loopnez a6, .Lsimd_loop                     // loop until a6 == 0
4201704a:	449676        	loopnez	a6, 42017092 <simd_mul_shift_i32+0x5a>
        l32i.n a8, a2, 0                        // load a[i] and b[i] into a8, a9 
4201704d:	0288      	l32i.n	a8, a2, 0
        l32i.n a9, a3, 0                        // load a[i+1] and b[i+1] into a10, a11
4201704f:	0398      	l32i.n	a9, a3, 0
        l32i.n a10, a2, 4
42017051:	12a8      	l32i.n	a10, a2, 4
        l32i.n a11, a3, 4
42017053:	13b8      	l32i.n	a11, a3, 4

        mulsh a12, a8, a9                       // mulh a8, a9 to a12
42017055:	b2c890        	mulsh	a12, a8, a9
        mull a8, a8, a9                         // mull a8, a9 to a8
42017058:	828890        	mull	a8, a8, a9
        src a8, a12, a8                         // shift by SAR
4201705b:	818c80        	src	a8, a12, a8
        s32i.n a8, a4, 0                        // store valye
4201705e:	0489      	s32i.n	a8, a4, 0

        mulsh a12, a10, a11                     // repeat for a[i+1] and b[i+1]
42017060:	b2cab0        	mulsh	a12, a10, a11
        mull a8, a10, a11
42017063:	828ab0        	mull	a8, a10, a11
        src a9, a12, a8
42017066:	819c80        	src	a9, a12, a8
        s32i.n a9, a4, 4                        // store with offset 4
42017069:	1499      	s32i.n	a9, a4, 4

        l32i.n a8, a2, 8                        // repeat for a[i+2] and b[i+2]
4201706b:	2288      	l32i.n	a8, a2, 8
        l32i.n a9, a3, 8
4201706d:	2398      	l32i.n	a9, a3, 8
        l32i.n a10, a2, 12                      // repeat for a[i+3] and b[i+3]
4201706f:	32a8      	l32i.n	a10, a2, 12
        l32i.n a11, a3, 12
42017071:	33b8      	l32i.n	a11, a3, 12

        mulsh a12, a8, a9 
42017073:	b2c890        	mulsh	a12, a8, a9
        mull a8, a8, a9
42017076:	828890        	mull	a8, a8, a9
        src a8, a12, a8
42017079:	818c80        	src	a8, a12, a8
        s32i.n a8, a4, 8
4201707c:	2489      	s32i.n	a8, a4, 8

        mulsh a12, a10, a11 
4201707e:	b2cab0        	mulsh	a12, a10, a11
        mull a8, a10, a11
42017081:	828ab0        	mull	a8, a10, a11
        src a9, a12, a8
42017084:	819c80        	src	a9, a12, a8
        s32i.n a9, a4, 12 
42017087:	3499      	s32i.n	a9, a4, 12

        addi a2, a2, 16
42017089:	10c222        	addi	a2, a2, 16
        addi a3, a3, 16
4201708c:	10c332        	addi	a3, a3, 16
        addi a4, a4, 16
4201708f:	10c442        	addi	a4, a4, 16
    .Lsimd_loop:

    // Handle remaining elements that are not a multiple of 4
    loopnez a7, .Ltail_loop
42017092:	149776        	loopnez	a7, 420170aa <simd_mul_shift_i32+0x72>
        l32i.n a8, a2, 0                         // loads and sign-extends the elements of the two vectors
42017095:	0288      	l32i.n	a8, a2, 0
        l32i.n a9, a3, 0
42017097:	0398      	l32i.n	a9, a3, 0
        mulsh a10, a8, a9
42017099:	b2a890        	mulsh	a10, a8, a9
        mull a11, a8, a9
4201709c:	82b890        	mull	a11, a8, a9
        addi.n a2, a2, 4                         // increment pointers
4201709f:	224b      	addi.n	a2, a2, 4
        addi.n a3, a3, 4
420170a1:	334b      	addi.n	a3, a3, 4
        src a10, a10, a11
420170a3:	81aab0        	src	a10, a10, a11
        s32i.n a10, a4, 0
420170a6:	04a9      	s32i.n	a10, a4, 0
        addi.n a4, a4, 4
420170a8:	444b      	addi.n	a4, a4, 4
    .Ltail_loop:

    movi.n a2, 0                                // return VECTOR_SUCCESS
420170aa:	020c      	movi.n	a2, 0
    retw.n
420170ac:	f01d      	retw.n

    .Lbad_shift:
    movi.n a2, 2                                // return VECTOR_INVALID_ARGUMENT
420170ae:	220c      	movi.n	a2, 2
420170b0:	f01d      	retw.n
	...

420170b4 <simd_sub_i32>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_sub_i32:
    entry a1, 16                                // reserve 16 bytes for the stack frame
420170b4:	002136        	entry	a1, 16
    extui a14, a5, 0, 2                         // extracts the lowest 2 bits of a5 into a6 (a5 % 4), for tail processing
420170b7:	14e050        	extui	a14, a5, 0, 2
    srli a5, a5, 2                              // shift a5 right by 2 to get the number of 16-byte blocks (a5 / 4)  
420170ba:	415250        	srli	a5, a5, 2

    // SIMD subtraction loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0, then increment a2 by 16
420170bd:	830124        	ee.vld.128.ip	q0, a2, 16
420170c0:	f03d      	nop.n
    loopnez a5, .Lsimd_loop                     // loop until a5 == 0
420170c2:	099576        	loopnez	a5, 420170cf <simd_sub_i32+0x1b>
        ee.vld.128.ip     q1, a3, 16            // loads 16 bytes from a3 into q1, increment a3 by 16
420170c5:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vsubs.s32.ld.incp q0, a2, q4, q0, q1 // subtracts q1 from q0, stores result in q4, increments a2, updates q0
420170c8:	e0d40d2e 	ee.vsubs.s32.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores 16 bytes from q4 to address at a4, increment a4 by 16
420170cc:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:
 
    // Scalar tail                              // q0 is loaded either from .Lsimd_loop or the load before it
    ee.vld.128.ip     q1, a3, 0                 // loads 16 bytes from a3 into q1
420170cf:	838034        	ee.vld.128.ip	q1, a3, 0
    ee.vsubs.s32      q0, q0, q1                // performs saturated int32 addition on q0 and q1 into q0
420170d2:	8e28e4        	ee.vsubs.s32	q0, q0, q1

    beqz a14, .func_end                         // ends if no scalar tail
420170d5:	7e9c      	beqz.n	a14, 420170f0 <.func_end>
    ee.movi.32.a    q0, a6, 0                      
420170d7:	cd7164        	ee.movi.32.a	q0, a6, 0
    s32i.n          a6, a4, 0 
420170da:	0469      	s32i.n	a6, a4, 0
    addi            a14, a14, -1
420170dc:	ee0b      	addi.n	a14, a14, -1

    beqz a14, .func_end
420170de:	ee8c      	beqz.n	a14, 420170f0 <.func_end>
    ee.movi.32.a    q0, a6, 1
420170e0:	cd7564        	ee.movi.32.a	q0, a6, 1
    s32i.n          a6, a4, 4 
420170e3:	1469      	s32i.n	a6, a4, 4
    addi            a14, a14, -1
420170e5:	ee0b      	addi.n	a14, a14, -1

    beqz a14, .func_end
420170e7:	5e8c      	beqz.n	a14, 420170f0 <.func_end>
    ee.movi.32.a    q0, a6, 2
420170e9:	cd7964        	ee.movi.32.a	q0, a6, 2
    s32i.n          a6, a4, 8 
420170ec:	2469      	s32i.n	a6, a4, 8
    addi            a14, a14, -1
420170ee:	ee0b      	addi.n	a14, a14, -1

420170f0 <.func_end>:

    .func_end:
    movi.n a2, 0                                // return exit code 0 (success)
420170f0:	020c      	movi.n	a2, 0
    retw.n
420170f2:	f01d      	retw.n

420170f4 <simd_sum_i32>:
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 * @warning Signed integer overflow is undefined behavior. If the sum of the input elements exceeds
 *          the range of int32_t ([-2,147,483,648, 2,147,483,647]), the result is unpredictable.
 */
simd_sum_i32:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
420170f4:	002136        	entry	a1, 16
    extui a5, a4, 0, 2                              // extracts the lowest 2 bits of a4 into a5 (a4 % 4), for tail processing
420170f7:	145040        	extui	a5, a4, 0, 2
    srli a4, a4, 2                                  // shift a4 right by 2 to get the number of 16-byte blocks (a4 / 4)
420170fa:	414240        	srli	a4, a4, 2
    movi.n a6, 0                                    // zeros a6 in case we go straight to the scalar tail 
420170fd:	060c      	movi.n	a6, 0
    beqz a4, .Ltail_start                           // if no full blocks, skip SIMD loop
420170ff:	24ac      	beqz.n	a4, 42017125 <simd_sum_i32+0x31>
    
    ee.xorq q0, q0, q0                              // clears q0 to use for accumulation
42017101:	cd3104        	ee.xorq	q0, q0, q0
    ee.vld.128.ip q1, a2, 16                        // loads elements of vector, increments pointer by 16
42017104:	838124        	ee.vld.128.ip	q1, a2, 16
42017107:	f03d      	nop.n
    loopnez a4, .Lsimd_loop                         // loop until a4 == 0 
42017109:	039476        	loopnez	a4, 42017110 <simd_sum_i32+0x1c>
        ee.vadds.s32.ld.incp q1, a2, q0, q1, q0     // adds elements to q0, addition saturates 32 bit lanes
4201710c:	e0384d2e 	ee.vadds.s32.ld.incp	q1, a2, q0, q1, q0
    .Lsimd_loop: 
    
    ee.movi.32.a q0, a6, 0                          // horizontal sum of q0 into a6
42017110:	cd7164        	ee.movi.32.a	q0, a6, 0
    ee.movi.32.a q0, a7, 1
42017113:	cd7574        	ee.movi.32.a	q0, a7, 1
    ee.movi.32.a q0, a8, 2
42017116:	cd7984        	ee.movi.32.a	q0, a8, 2
    ee.movi.32.a q0, a9, 3
42017119:	cd7d94        	ee.movi.32.a	q0, a9, 3
    add.n a6, a6, a7
4201711c:	667a      	add.n	a6, a6, a7
    add.n a6, a6, a8
4201711e:	668a      	add.n	a6, a6, a8
    add.n a6, a6, a9 
42017120:	669a      	add.n	a6, a6, a9

    addi a2, a2, -16                                // moves a2 back (it goes 16 bytes to far in the loop)
42017122:	f0c222        	addi	a2, a2, -16

    .Ltail_start:

    loopnez a5, .Ltail_loop 
42017125:	059576        	loopnez	a5, 4201712e <simd_sum_i32+0x3a>
        l32i.n a7, a2, 0 
42017128:	0278      	l32i.n	a7, a2, 0
        add.n a6, a7, a6 
4201712a:	676a      	add.n	a6, a7, a6
        addi.n a2, a2, 4
4201712c:	224b      	addi.n	a2, a2, 4
    .Ltail_loop:  
        
    s32i.n a6, a3, 0
4201712e:	0369      	s32i.n	a6, a3, 0
    movi.n a2,  0                                   //return exit code 0 (success)
42017130:	020c      	movi.n	a2, 0
    retw.n
42017132:	f01d      	retw.n

42017134 <simd_abs_i8>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_abs_i8:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42017134:	002136        	entry	a1, 16
    extui a5, a4, 0, 4                          // a5 = a4 % 16 (remaining tail elements)
42017137:	345040        	extui	a5, a4, 0, 4
    srli a4, a4, 4                              // a4 = a4 / 16 (number of 16-byte SIMD blocks)
4201713a:	414440        	srli	a4, a4, 4
    movi a7, -127                               // a7 = -127, for replacing -128 edge cases
4201713d:	81af72        	movi	a7, -127
    beqz a4, .Ltail_start                       // if no full blocks, skip SIMD loop
42017140:	04ac      	beqz.n	a4, 42017164 <simd_abs_i8+0x30>

    // SIMD loop for 16-byte blocks 
    ssai 0                                      // Clears Shift Amount Register
42017142:	404000        	ssai	0
    s8i a7, a1, 0                               // store -127 to stack (for broadcast loading)
42017145:	004172        	s8i	a7, a1, 0
    ee.vld.128.ip   q0, a2, 16                  // load 16 bytes from [a2] into q0, post-increment a2 by 16
42017148:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vcmp.eq.s8   q1, q1, q1                  // fill q1 with all 0xFF (-1), used as multiplier for negation
4201714b:	8e89b4        	ee.vcmp.eq.s8	q1, q1, q1
    ee.vldbc.8.ip   q2, a1, 0                   // broadcast-load -127 from stack into all lanes of q2
4201714e:	d50014        	ee.vldbc.8.ip	q2, a1, 0
    loopnez a4, .Lsimd_loop                     // repeat loop a4 times (zero-overhead loop counter)
42017151:	0c9476        	loopnez	a4, 42017161 <simd_abs_i8+0x2d>
        ee.vmax.s8.ld.incp  q0, a2, q4, q0, q2  // q4 = max(q0, -127); replace -128 with -127, load next 16 bytes into q0, post-increment a2
42017154:	e0141f2e 	ee.vmax.s8.ld.incp	q0, a2, q4, q0, q2
        ee.vmul.s8 q3, q4, q1                   // q3 = q4 * -1; negates all q4 values
42017158:	9eac94        	ee.vmul.s8	q3, q4, q1
        ee.vmax.s8 q4, q4, q3                   // q4 = max(q4, q3); effectively performs abs(q4)
4201715b:	ae3c44        	ee.vmax.s8	q4, q4, q3
        ee.vst.128.ip  q4, a3, 16               // store result q4 to [a3], post-increment a3 by 16
4201715e:	aa0134        	ee.vst.128.ip	q4, a3, 16
    .Lsimd_loop:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element  
42017161:	f0c222        	addi	a2, a2, -16

    .Ltail_start:  
    sext a7, a7, 7                              // sign extends a7 to 32 bits
42017164:	237700        	sext	a7, a7, 7
42017167:	f03d      	nop.n

    // Handle remaining elements that are not a multiple of 16
    loopnez a5, .Ltail_loop
42017169:	129576        	loopnez	a5, 4201717f <simd_abs_i8+0x4b>
        l8ui a8, a2, 0                          // loads and sign-extends the element into a8
4201716c:	000282        	l8ui	a8, a2, 0
        sext a8, a8, 7  
4201716f:	238800        	sext	a8, a8, 7
        max a8, a8, a7                          // sets a8 to -127 if it is -128
42017172:	538870        	max	a8, a8, a7
        abs a8, a8                              // takes the abs of a8
42017175:	608180        	abs	a8, a8
 
        s8i a8, a3, 0                           // store the saturated result in address at a4
42017178:	004382        	s8i	a8, a3, 0

        addi.n a2, a2, 1                        // increment pointers 
4201717b:	221b      	addi.n	a2, a2, 1
        addi.n a3, a3, 1 
4201717d:	331b      	addi.n	a3, a3, 1
    .Ltail_loop:  

    movi.n a2, 0                                //return exit code 0 (success)
4201717f:	020c      	movi.n	a2, 0
    retw.n
42017181:	f01d      	retw.n
	...

42017184 <simd_add_i8>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_i8:
    entry a1, 16 // reserve 16 bytes for the stack frame
42017184:	002136        	entry	a1, 16
    extui a6, a5, 0, 4 // extracts the lowest 4 bits of a5 into a6 (a5 % 16), for tail processing
42017187:	346050        	extui	a6, a5, 0, 4
    srli a5, a5, 4 // shift a5 right by 4 to get the number of 16-byte blocks (a5 / 16)
4201718a:	415450        	srli	a5, a5, 4
    beqz a5, .Ltail_start // if no full blocks (a5 == 0), skip SIMD and go to scalar tail
4201718d:	159c      	beqz.n	a5, 420171a2 <simd_add_i8+0x1e>

    // SIMD addition loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16 // loads 16 bytes from a2 into q0, then increment a2 by 16
4201718f:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a5, .Lsimd_loop  // loop until a5 == 0
42017192:	099576        	loopnez	a5, 4201719f <simd_add_i8+0x1b>
        ee.vld.128.ip     q1, a3, 16 // loads 16 bytes from a3 into q1, increment a3 by 16
42017195:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vadds.s8.ld.incp q0, a2, q4, q0, q1 //adds q0 and q1, stores result in q4, increments a2, updates q0
42017198:	e0940c2e 	ee.vadds.s8.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16 // stores 16 bytes from q4 to address at a4, increment a4 by 16
4201719c:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:

    addi a2, a2, -16 // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
4201719f:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    // Handle remaining elements that were not part of a full 16-byte block
    movi a9, 127 // loads upper saturation limit int8_t
420171a2:	7fa092        	movi	a9, 127
    movi a10, -128 // loads lower saturation limit int8_t
420171a5:	80afa2        	movi	a10, -128
420171a8:	f03d      	nop.n

    // Handle remaining elements that are not a multiple of 16
    loopnez a6, .Ltail_loop
420171aa:	229676        	loopnez	a6, 420171d0 <simd_add_i8+0x4c>
        l8ui a7, a2, 0 // loads and sign-extends the elements of the two vectors
420171ad:	000272        	l8ui	a7, a2, 0
        l8ui a8, a3, 0 
420171b0:	000382        	l8ui	a8, a3, 0
        sext a7, a7, 7
420171b3:	237700        	sext	a7, a7, 7
        sext a8, a8, 7
420171b6:	238800        	sext	a8, a8, 7
        
        add a7, a7, a8 // perform signed addition
420171b9:	778a      	add.n	a7, a7, a8

        // Saturation logic
        salt a11, a7, a10 // sets a11 to 1 if a7 is less than -128
420171bb:	72b7a0        	salt	a11, a7, a10
        movnez a7, a10, a11 // conditional move if non-zero sets a7 to -128 if a11 is non-zero
420171be:	937ab0        	movnez	a7, a10, a11
        salt a11, a9, a7 // sets a11 to 1 if a7 is greater than 127
420171c1:	72b970        	salt	a11, a9, a7
        movnez a7, a9, a11 // conditional move if non-zero sets a7 to 127 if a11 is non-zero
420171c4:	9379b0        	movnez	a7, a9, a11

        s8i a7, a4, 0 // store the saturated result in address at a4
420171c7:	004472        	s8i	a7, a4, 0

        addi.n a2, a2, 1 // increment pointers
420171ca:	221b      	addi.n	a2, a2, 1
        addi.n a3, a3, 1
420171cc:	331b      	addi.n	a3, a3, 1
        addi.n a4, a4, 1 
420171ce:	441b      	addi.n	a4, a4, 1
    .Ltail_loop:  

    movi.n a2, 0 //return exit code 0 (success)
420171d0:	020c      	movi.n	a2, 0
    retw.n
420171d2:	f01d      	retw.n

420171d4 <simd_add_scalar_i8>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_add_scalar_i8:
    entry a1, 16                                // reserve 16 bytes for the stack frame
420171d4:	002136        	entry	a1, 16
    extui a6, a5, 0, 4                          // moves the last 4 bits (i.e. number of elements that are not a multiple of 16) into a6
420171d7:	346050        	extui	a6, a5, 0, 4
    srli a5, a5, 4                              // bit shift to convert number of 8-bit elements to number of 128-bit blocks
420171da:	415450        	srli	a5, a5, 4
    beqz a5, .Ltail_start                       // if a5 is zero, skip the SIMD addition loop
420171dd:	159c      	beqz.n	a5, 420171f2 <simd_add_scalar_i8+0x1e>

    // SIMD addition loop for 16 byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0 (128-bit vector load), increments a2
420171df:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.8.ip     q1, a3, 0                 // load the 8-bit scalar value at the address of a3 and broadcasts it into q1,
420171e2:	c58034        	ee.vldbc.8.ip	q1, a3, 0
    loopnez a5, .Lsimd_end  
420171e5:	069576        	loopnez	a5, 420171ef <simd_add_scalar_i8+0x1b>
        ee.vadds.s8.ld.incp q0, a2, q4, q0, q1  // adds q0 and q1, stores result in q4, increments a2, updates q0
420171e8:	e0940c2e 	ee.vadds.s8.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores result from q4 into a4, increments a4
420171ec:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_end:

    addi a2, a2, -16                            // adjust a2 pointer back to the last processed element 
420171ef:	f0c222        	addi	a2, a2, -16

    .Ltail_start:

    // After processing all full 16-byte blocks, we handle the remaining elements
    movi.n a9, 127                              // Load saturation limit for positive values
420171f2:	7fa092        	movi	a9, 127
    movi a10, -128                              // Load saturation limit for negative values  
420171f5:	80afa2        	movi	a10, -128

    l8ui a8, a3, 0                              // Load the scalar value to be added, sign-extended to 32 bits
420171f8:	000382        	l8ui	a8, a3, 0
    sext a8, a8, 7
420171fb:	238800        	sext	a8, a8, 7

    loopnez a6, .Ltail_end
420171fe:	1a9676        	loopnez	a6, 4201721c <simd_add_scalar_i8+0x48>
        l8ui a7, a2, 0                          // Loads and sign-extends the elements of the two vectors
42017201:	000272        	l8ui	a7, a2, 0
        addi a2, a2, 1                          // increment pointers 
42017204:	221b      	addi.n	a2, a2, 1
        sext a7, a7, 7
42017206:	237700        	sext	a7, a7, 7
        
        add a7, a7, a8                          // Adds the two signed 8-bit integers
42017209:	778a      	add.n	a7, a7, a8

        // Saturation logic
        salt a11, a7, a10                       // sets a11 to 1 if a7 is less than -128
4201720b:	72b7a0        	salt	a11, a7, a10
        movnez a7, a10, a11                     // Conditional move if non-zero sets a7 to -128 if a11 is non-zero
4201720e:	937ab0        	movnez	a7, a10, a11
        salt a11, a9, a7                        // sets a11 to 1 if a7 is greater than 127 
42017211:	72b970        	salt	a11, a9, a7
        movnez a7, a9, a11                      // Conditional move if non-zero sets a7 to 127 if a11 is non-zero
42017214:	9379b0        	movnez	a7, a9, a11
        s8i a7, a4, 0                           // store the result in the result vector
42017217:	004472        	s8i	a7, a4, 0

        addi a4, a4, 1                          // increment pointers 
4201721a:	441b      	addi.n	a4, a4, 1
    .Ltail_end:  

    movi.n a2, 0                                // return VECTOR_SUCCESS
4201721c:	020c      	movi.n	a2, 0
    retw.n
4201721e:	f01d      	retw.n

42017220 <simd_ceil_i8>:
 * @pre The size in a4 must match the number of elements in each arr.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_ceil_i8:
    entry a1, 16                                // reserve 16 bytes for the stack frame
42017220:	002136        	entry	a1, 16
    extui a6, a5, 0, 4                          // a6 = a5 % 16 (remaining tail elements)
42017223:	346050        	extui	a6, a5, 0, 4
    srli a5, a5, 4                              // a5 = a5 / 16 (number of 16-byte SIMD blocks) 
42017226:	415450        	srli	a5, a5, 4
    beqz a5, .Ltail_start                       // if no full blocks, skip SIMD loop
42017229:	159c      	beqz.n	a5, 4201723e <simd_ceil_i8+0x1e>

    // SIMD loop for 16-byte blocks  
    ee.vld.128.ip   q0, a2, 16                  // load 16 bytes from [a2] into q0, post-increment a2 by 16 
4201722b:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.8.ip   q1, a4, 0                   // broadcast-load a4 into all lanes of q1
4201722e:	c58044        	ee.vldbc.8.ip	q1, a4, 0
    loopnez a5, .Lsimd_loop                     // repeat loop a5 times (zero-overhead loop counter)
42017231:	069576        	loopnez	a5, 4201723b <simd_ceil_i8+0x1b>
        ee.vmin.s8.ld.incp  q0, a2, q2, q0, q1  // q2 = min(q0, q1); applies the ceiling to q0, load next 16 bytes into q0, post-increment a2 
42017234:	e0a20f2e 	ee.vmin.s8.ld.incp	q0, a2, q2, q0, q1
        ee.vst.128.ip  q2, a3, 16               // store result q2 to [a3], post-increment a3 by 16
42017238:	9a0134        	ee.vst.128.ip	q2, a3, 16
    .Lsimd_loop:

    addi a2, a2, -16 // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
4201723b:	f0c222        	addi	a2, a2, -16

    .Ltail_start: 

    l8ui a7, a4, 0                              // loads the ceiling into a7
4201723e:	000472        	l8ui	a7, a4, 0
    sext a7, a7, 7
42017241:	237700        	sext	a7, a7, 7
42017244:	f03d      	nop.n

    // Handle remaining elements that are not a multiple of 16
    loopnez a6, .Ltail_loop
42017246:	0f9676        	loopnez	a6, 42017259 <simd_ceil_i8+0x39>
        l8ui a8, a2, 0                          // loads and sign-extends the element into a8
42017249:	000282        	l8ui	a8, a2, 0
        sext a8, a8, 7
4201724c:	238800        	sext	a8, a8, 7
        
        min a8, a8, a7                          // applies the ceiling to a8
4201724f:	438870        	min	a8, a8, a7
 
        s8i a8, a3, 0                           // store the result in address at a3
42017252:	004382        	s8i	a8, a3, 0

        addi.n a2, a2, 1 // increment pointers 
42017255:	221b      	addi.n	a2, a2, 1
        addi.n a3, a3, 1 
42017257:	331b      	addi.n	a3, a3, 1
    .Ltail_loop:  

    movi.n a2, 0 //return exit code 0 (success)
42017259:	020c      	movi.n	a2, 0
    retw.n
4201725b:	f01d      	retw.n
4201725d:	000000        	ill

42017260 <simd_copy_i8>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_copy_i8:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42017260:	002136        	entry	a1, 16
    extui a5, a4, 0, 4                              // extracts the lowest 4 bits of a4 into a5 (a4 % 16), for tail processing
42017263:	345040        	extui	a5, a4, 0, 4
    srli a4, a4, 4                                  // shift a4 right by 4 to get the number of 16-byte blocks (a4 / 16) 
42017266:	414440        	srli	a4, a4, 4
 
    loopnez a4, .Lsimd_loop                         // loop until a4 == 0
42017269:	059476        	loopnez	a4, 42017272 <simd_copy_i8+0x12>
        ee.vld.128.ip     q1, a2, 16                // loads 16 bytes from a2 into q1, increment a32 by 16 
4201726c:	838124        	ee.vld.128.ip	q1, a2, 16
        ee.vst.128.ip     q1, a3, 16                // stores 16 bytes from q1 to address at a3, increment a3 by 16
4201726f:	8a8134        	ee.vst.128.ip	q1, a3, 16
    .Lsimd_loop: 
    
    loopnez a5, .Ltail_loop                         // Handle remaining elements that are not a multiple of 16
42017272:	099576        	loopnez	a5, 4201727f <simd_copy_i8+0x1f>
        l8ui a7, a2, 0   
42017275:	000272        	l8ui	a7, a2, 0
        addi.n a2, a2, 1                            // increment pointers
42017278:	221b      	addi.n	a2, a2, 1
        s8i a7, a3, 0                               // store the saturated result in address at a3 
4201727a:	004372        	s8i	a7, a3, 0
        addi.n a3, a3, 1                            // increment pointers 
4201727d:	331b      	addi.n	a3, a3, 1
    .Ltail_loop:  

    movi.n a2, 0                                    // return exit code 0 (success)
4201727f:	020c      	movi.n	a2, 0
    retw.n
42017281:	f01d      	retw.n
	...

42017284 <simd_dotp_i8>:
 * @pre The size in a5 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_dotp_i8:
    entry a1, 16                                    // reserve 16 bytes for the stack frame
42017284:	002136        	entry	a1, 16
    extui a6, a5, 0, 4                              // extracts the lowest 4 bits of a5 into a6 (a5 % 16), for tail processing
42017287:	346050        	extui	a6, a5, 0, 4
    srli a5, a5, 4                                  // shift a5 right by 4 to get the number of 16-byte blocks (a5 / 16)
4201728a:	415450        	srli	a5, a5, 4
    movi.n a7, 0                                    // zeros a7
4201728d:	00a072        	movi	a7, 0
    beqz a5, .Ltail_start                           // if no full blocks (a5 == 0), skip SIMD and go to scalar tail
42017290:	015516        	beqz	a5, 420172a9 <simd_dotp_i8+0x25>

    // SIMD addition loop for 16-byte blocks 
    ee.zero.accx                                    // clears the QACC register
42017293:	250804        	ee.zero.accx
    ee.vld.128.ip     q0, a2, 16                    // loads 16 bytes from a2 into q0, then increment a2 by 16
42017296:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a5, .Lsimd_loop                         // loop until a5 == 0
42017299:	069576        	loopnez	a5, 420172a3 <simd_dotp_i8+0x1f>
        ee.vld.128.ip     q1, a3, 16                // loads 16 bytes from a3 into q1, then increments a3 by 16 
4201729c:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vmulas.s8.accx.ld.ip q0, a2, 16, q0, q1  // multiply-accumulates q0 and q1, stores result in QACC, increments a2, updates q0 
4201729f:	f082012e 	ee.vmulas.s8.accx.ld.ip	q0, a2, 16, q0, q1
    .Lsimd_loop:

    rur.accx_0 a7                                   // write the lower 32 bits of QACC into a7
420172a3:	e37000        	rur.accx_0	a7
    addi a2, a2, -16                                // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
420172a6:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    // Handle remaining elements that were not part of a full 16-byte block 
 
    loopnez a6, .Ltail_loop 
420172a9:	149676        	loopnez	a6, 420172c1 <simd_dotp_i8+0x3d>
        l8ui a8, a2, 0
420172ac:	000282        	l8ui	a8, a2, 0
        sext a8, a8, 7
420172af:	238800        	sext	a8, a8, 7
        l8ui a9, a3, 0
420172b2:	000392        	l8ui	a9, a3, 0
        sext a9, a9, 7
420172b5:	239900        	sext	a9, a9, 7
        mull a8, a8, a9
420172b8:	828890        	mull	a8, a8, a9
        add a7, a7, a8 
420172bb:	778a      	add.n	a7, a7, a8
        addi a2, a2, 1
420172bd:	221b      	addi.n	a2, a2, 1
        addi a3, a3, 1
420172bf:	331b      	addi.n	a3, a3, 1
    .Ltail_loop:  
        
    s32i.n a7, a4, 0
420172c1:	0479      	s32i.n	a7, a4, 0
    movi.n a2,  0                                   //return exit code 0 (success)
420172c3:	020c      	movi.n	a2, 0
    retw.n
420172c5:	f01d      	retw.n
	...

420172c8 <simd_mul_scalar_i8>:
    *   a5 - The shift value
    *   a6 - number of elements in the vector
    * Returns: 0 on success
*/
simd_mul_scalar_i8:
    entry a1, 16                                        // reserve 16 bytes for the stack frame
420172c8:	002136        	entry	a1, 16
    
    extui a7, a5, 29, 3                                 // if shift_amount >7 return VECTOR_INVALID ARGUMENT
420172cb:	257d50        	extui	a7, a5, 29, 3
    bnez  a7, .Lbad_shift
420172ce:	e7fc      	bnez.n	a7, 42017310 <simd_mul_scalar_i8+0x48>

    extui a7, a6, 0, 4                                  // moves the last 4 bits (i.e. number of elements that are not a multiple of 16) into a7
420172d0:	347060        	extui	a7, a6, 0, 4
    srli a6, a6, 4                                      // bit shift to convert number of 8-bit elements to number of 128-bit blocks
420172d3:	416460        	srli	a6, a6, 4
    wsr a5, SAR                                         // set the Shift Amount Register (SAR) to the value in a5
420172d6:	130350        	wsr.sar	a5
    beqz a6, .Ltail_start                               // if a6 is zero, skip the SIMD addition loop
420172d9:	169c      	beqz.n	a6, 420172ee <simd_mul_scalar_i8+0x26>

    // SIMD addition loop for 16 byte blocks
    ee.vld.128.ip     q0, a2, 16                        // loads 16 bytes from a2 into q0 (128-bit vector load), increments a2
420172db:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.8.ip     q1, a3, 0                         // load the 8-bit scalar value at the address of a3 and broadcasts it into q1,
420172de:	c58034        	ee.vldbc.8.ip	q1, a3, 0
    loopnez a6, .Lsimd_end  
420172e1:	069676        	loopnez	a6, 420172eb <simd_mul_scalar_i8+0x23>
        ee.vmul.s8.ld.incp q0, a2, q4, q0, q1           // adds q0 and q1, stores result in q4, increments a2, updates q0
420172e4:	e0c40c2e 	ee.vmul.s8.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16                    // stores result from q4 into a4, increments a4
420172e8:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_end:

    addi a2, a2, -16                                    // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
420172eb:	f0c222        	addi	a2, a2, -16

    .Ltail_start:                                       // After processing all full 16-byte blocks, we handle the remaining elements  
    l8ui a9, a3, 0                                      // Load the scalar value to be added, sign-extended to 32 bits
420172ee:	000392        	l8ui	a9, a3, 0
    sext a9, a9, 7
420172f1:	239900        	sext	a9, a9, 7
420172f4:	f03d      	nop.n

    loopnez a7, .Ltail_end
420172f6:	129776        	loopnez	a7, 4201730c <simd_mul_scalar_i8+0x44>
        l8ui a8, a2, 0                                  // Loads and sign-extends the elements of the scalar tail 
420172f9:	000282        	l8ui	a8, a2, 0
        sext a8, a8, 7
420172fc:	238800        	sext	a8, a8, 7
        
        mull a8, a8, a9                                 // perform signed multiplication
420172ff:	828890        	mull	a8, a8, a9
        srl a8, a8                                      // apply the bit shift from SAR
42017302:	918080        	srl	a8, a8
        s8i a8, a4, 0                                   // store the shifted result in address at a4
42017305:	004482        	s8i	a8, a4, 0
 
        addi a2, a2, 1                                  // increment pointers 
42017308:	221b      	addi.n	a2, a2, 1
        addi a4, a4, 1 
4201730a:	441b      	addi.n	a4, a4, 1
    .Ltail_end:  

    movi.n a2, 0                                        // return VECTOR_SUCCESS
4201730c:	020c      	movi.n	a2, 0
    retw.n
4201730e:	f01d      	retw.n

    .Lbad_shift:
    movi.n a2, 2                                        // return VECTOR_INVALID_ARGUMENT
42017310:	220c      	movi.n	a2, 2
    retw.n
42017312:	f01d      	retw.n

42017314 <simd_mul_shift_i8>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_mul_shift_i8:
    entry a1, 16                            // reserve 16 bytes for the stack frame
42017314:	002136        	entry	a1, 16
    extui a7, a5, 29, 3                     // if shift_amount >7 return VECTOR_INVALID ARGUMENT
42017317:	257d50        	extui	a7, a5, 29, 3
    bnez  a7, .Lbad_shift
4201731a:	e7fc      	bnez.n	a7, 4201735c <simd_mul_shift_i8+0x48>
    extui a7, a6, 0, 4                      // extracts the lowest 4 bits of a6 into a7 (a6 % 16), for tail processing
4201731c:	347060        	extui	a7, a6, 0, 4
    srli a6, a6, 4                          // shift a6 right by 4 to get the number of 16-byte blocks (a6 / 16)
4201731f:	416460        	srli	a6, a6, 4
    wsr a5, sar                             // store the bit shift value in SAR (Shift Amount Register)
42017322:	130350        	wsr.sar	a5
    beqz a6, .Ltail_start                   // if no full blocks (a6 == 0), skip SIMD and go to scalar tail
42017325:	169c      	beqz.n	a6, 4201733a <simd_mul_shift_i8+0x26>

    // SIMD multiplication loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16                // loads 16 bytes from a2 into q0, then increment a2 by 16
42017327:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a6, .Lsimd_loop                     // loop until a6 == 0
4201732a:	099676        	loopnez	a6, 42017337 <simd_mul_shift_i8+0x23>
        ee.vld.128.ip     q1, a3, 16            // loads 16 bytes from a3 into q1, increment a3 by 16
4201732d:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vmul.s8.ld.incp q0, a2, q4, q0, q1   // multiplies q0 and q1, stores result in q4, increments a2, updates q0
42017330:	e0c40c2e 	ee.vmul.s8.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16            // stores 16 bytes from q4 to address at a4, increment a4 by 16
42017334:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:

    addi a2, a2, -16 // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
42017337:	f0c222        	addi	a2, a2, -16

    .Ltail_start:                       // Handle remaining elements that are not a multiple of 16 
    loopnez a7, .Ltail_loop
4201733a:	1a9776        	loopnez	a7, 42017358 <simd_mul_shift_i8+0x44>
        l8ui a8, a2, 0                  // loads and sign-extends the elements of the two vectors
4201733d:	000282        	l8ui	a8, a2, 0
        l8ui a9, a3, 0 
42017340:	000392        	l8ui	a9, a3, 0
        sext a8, a8, 7
42017343:	238800        	sext	a8, a8, 7
        sext a9, a9, 7
42017346:	239900        	sext	a9, a9, 7

        mull a8, a8, a9                 // perform signed multiplication
42017349:	828890        	mull	a8, a8, a9
        srl a8, a8                      // apply the bit shift from SAR
4201734c:	918080        	srl	a8, a8
        s8i a8, a4, 0                   // store the shifted result in address at a4
4201734f:	004482        	s8i	a8, a4, 0

        addi a2, a2, 1                  // increment pointers
42017352:	221b      	addi.n	a2, a2, 1
        addi a3, a3, 1
42017354:	331b      	addi.n	a3, a3, 1
        addi a4, a4, 1 
42017356:	441b      	addi.n	a4, a4, 1
    .Ltail_loop:  

    movi.n a2, 0                        // return VECTOR_SUCCESS
42017358:	020c      	movi.n	a2, 0
    retw.n
4201735a:	f01d      	retw.n

    .Lbad_shift:
    movi.n a2, 2                        // return VECTOR_INVALID_ARGUMENT
4201735c:	220c      	movi.n	a2, 2
    retw.n
4201735e:	f01d      	retw.n

42017360 <simd_sub_i8>:
 * @pre The size in a5 must match the number of elements in each vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_sub_i8:
    entry a1, 16 // reserve 16 bytes for the stack frame
42017360:	002136        	entry	a1, 16
    extui a6, a5, 0, 4 // extracts the lowest 4 bits of a5 into a6 (a5 % 16), for tail processing
42017363:	346050        	extui	a6, a5, 0, 4
    srli a5, a5, 4 // shift a5 right by 4 to get the number of 16-byte blocks (a5 / 16)
42017366:	415450        	srli	a5, a5, 4
    beqz a5, .Ltail_start // if no full blocks (a5 == 0), skip SIMD and go to scalar tail
42017369:	159c      	beqz.n	a5, 4201737e <simd_sub_i8+0x1e>

    // SIMD subtraction loop for 16-byte blocks
    ee.vld.128.ip     q0, a2, 16 // loads 16 bytes from a2 into q0, then increment a2 by 16
4201736b:	830124        	ee.vld.128.ip	q0, a2, 16
    loopnez a5, .Lsimd_loop  // loop until a5 == 0
4201736e:	099576        	loopnez	a5, 4201737b <simd_sub_i8+0x1b>
        ee.vld.128.ip     q1, a3, 16 // loads 16 bytes from a3 into q1, increment a3 by 16
42017371:	838134        	ee.vld.128.ip	q1, a3, 16
        ee.vsubs.s8.ld.incp q0, a2, q4, q0, q1 //subtracts q1 from q0, stores result in q4, increments a2, updates q0
42017374:	e0e40d2e 	ee.vsubs.s8.ld.incp	q0, a2, q4, q0, q1
        ee.vst.128.ip     q4, a4, 16 // stores 16 bytes from q4 to address at a4, increment a4 by 16
42017378:	aa0144        	ee.vst.128.ip	q4, a4, 16
    .Lsimd_loop:

    addi a2, a2, -16 // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
4201737b:	f0c222        	addi	a2, a2, -16

    .Ltail_start:
    // Handle remaining elements that were not part of a full 16-byte block
    movi a9, 127 // loads upper saturation limit int8_t
4201737e:	7fa092        	movi	a9, 127
    movi a10, -128 // loads lower saturation limit int8_t
42017381:	80afa2        	movi	a10, -128
42017384:	f03d      	nop.n

    // Handle remaining elements that are not a multiple of 16
    loopnez a6, .Ltail_loop
42017386:	239676        	loopnez	a6, 420173ad <simd_sub_i8+0x4d>
        l8ui a7, a2, 0 // loads and sign-extends the elements of the two vectors
42017389:	000272        	l8ui	a7, a2, 0
        l8ui a8, a3, 0 
4201738c:	000382        	l8ui	a8, a3, 0
        sext a7, a7, 7
4201738f:	237700        	sext	a7, a7, 7
        sext a8, a8, 7
42017392:	238800        	sext	a8, a8, 7

        sub a7, a7, a8 // perform signed subtraction
42017395:	c07780        	sub	a7, a7, a8

        // Saturation logic
        salt a11, a7, a10 // sets a11 to 1 if a7 is less than -128
42017398:	72b7a0        	salt	a11, a7, a10
        movnez a7, a10, a11 // conditional move if non-zero sets a7 to -128 if a11 is non-zero
4201739b:	937ab0        	movnez	a7, a10, a11
        salt a11, a9, a7 // sets a11 to 1 if a7 is greater than 127
4201739e:	72b970        	salt	a11, a9, a7
        movnez a7, a9, a11 // conditional move if non-zero sets a7 to 127 if a11 is non-zero
420173a1:	9379b0        	movnez	a7, a9, a11

        s8i a7, a4, 0 // store the saturated result in address at a4
420173a4:	004472        	s8i	a7, a4, 0

        addi.n a2, a2, 1 // increment pointers
420173a7:	221b      	addi.n	a2, a2, 1
        addi.n a3, a3, 1
420173a9:	331b      	addi.n	a3, a3, 1
        addi.n a4, a4, 1 
420173ab:	441b      	addi.n	a4, a4, 1
    .Ltail_loop:  

    movi.n a2, 0 //return exit code 0 (success)
420173ad:	020c      	movi.n	a2, 0
    retw.n
420173af:	f01d      	retw.n
420173b1:	000000        	ill

420173b4 <simd_sum_i8>:
 * @pre The size in a4 must match the number of elements in the input vector.
 *
 * @warning Misaligned data or incorrect element count may result in undefined behavior or hardware exceptions.
 */
simd_sum_i8:
    entry a1, 16                                    // reserve 16 bytes for the stack frame 
420173b4:	002136        	entry	a1, 16
    extui a5, a4, 0, 4                              // extracts the lowest 4 bits of a4 into a5 (a4 % 16), for tail processing
420173b7:	345040        	extui	a5, a4, 0, 4
    srli a4, a4, 4                                  // shift a4 right by 4 to get the number of 16-byte blocks (a4 / 16)
420173ba:	414440        	srli	a4, a4, 4
    movi.n a6, 0                                    // zeros a6 in case we go straight to the scalar tail
420173bd:	00a062        	movi	a6, 0
    beqz a4, .Ltail_start                           // if no full blocks (a4 == 0), skip SIMD and go to scalar tail
420173c0:	a49c      	beqz.n	a4, 420173de <simd_sum_i8+0x2a>

    // SIMD addition loop for 16-byte blocks 
    movi.n a7, 1                                    // sets a7 to 0x01
420173c2:	01a072        	movi	a7, 1
    s8i a7, a1, 0                                   // stores 0x01 on the stack
420173c5:	004172        	s8i	a7, a1, 0
    ee.zero.accx                                    // clears the QACC register
420173c8:	250804        	ee.zero.accx
    ee.vld.128.ip     q0, a2, 16                    // loads 16 bytes from a2 into q0, then increment a2 by 16
420173cb:	830124        	ee.vld.128.ip	q0, a2, 16
    ee.vldbc.8.ip     q1, a1, 0                     // broadcast loads the ones vector into q1
420173ce:	c58014        	ee.vldbc.8.ip	q1, a1, 0
    loopnez a4, .Lsimd_loop                         // loop until a4 == 0
420173d1:	039476        	loopnez	a4, 420173d8 <simd_sum_i8+0x24>
        ee.vmulas.s8.accx.ld.ip q0, a2, 16, q0, q1  // multiply-accumulates q0 and q1, stores result in QACC, increments a2, updates q0 
420173d4:	f082012e 	ee.vmulas.s8.accx.ld.ip	q0, a2, 16, q0, q1
    .Lsimd_loop:

    rur.accx_0 a6                                   // write the lower 32 bits of QACC into a6
420173d8:	e36000        	rur.accx_0	a6
    addi a2, a2, -16                                // adjust a2 pointer back to the last processed element (it goes too far due to the last increment in the loop)
420173db:	f0c222        	addi	a2, a2, -16

    
    // Handle remaining elements that were not part of a full 16-byte block 
    .Ltail_start:
    loopnez a5, .Ltail_loop 
420173de:	099576        	loopnez	a5, 420173eb <simd_sum_i8+0x37>
        l8ui a7, a2, 0
420173e1:	000272        	l8ui	a7, a2, 0
        sext a7, a7, 7
420173e4:	237700        	sext	a7, a7, 7
        add a6, a7, a6 
420173e7:	676a      	add.n	a6, a7, a6
        addi a2, a2, 1
420173e9:	221b      	addi.n	a2, a2, 1
    .Ltail_loop:  
        
    s32i.n a6, a3, 0
420173eb:	0369      	s32i.n	a6, a3, 0
    movi.n a2,  0                                   //return exit code 0 (success)
420173ed:	020c      	movi.n	a2, 0
    retw.n
420173ef:	f01d      	retw.n
420173f1:	000000        	ill

420173f4 <s_mem_caps_check>:
{
420173f4:	004136        	entry	a1, 32
    if (caps & MMU_MEM_CAP_EXEC) {
420173f7:	096207        	bbci	a2, 0, 42017404 <s_mem_caps_check+0x10>
        if ((caps & MMU_MEM_CAP_8BIT) || (caps & MMU_MEM_CAP_WRITE)) {
420173fa:	481c      	movi.n	a8, 20
420173fc:	098287        	bany	a2, a8, 42017409 <s_mem_caps_check+0x15>
    return ESP_OK;
420173ff:	020c      	movi.n	a2, 0
42017401:	0001c6        	j	4201740c <s_mem_caps_check+0x18>
42017404:	020c      	movi.n	a2, 0
42017406:	000086        	j	4201740c <s_mem_caps_check+0x18>
            return ESP_ERR_INVALID_ARG;
42017409:	02a122        	movi	a2, 0x102
}
4201740c:	f01d      	retw.n
	...

42017410 <s_find_available_region>:
{
42017410:	004136        	entry	a1, 32
42017413:	02ad      	mov.n	a10, a2
    for (int i = 0; i < region_nums; i++) {
42017415:	020c      	movi.n	a2, 0
42017417:	000606        	j	42017433 <s_find_available_region+0x23>
4201741a:	200000        	or	a0, a0, a0
        if (((mem_regions[i].caps & caps) == caps) && ((mem_regions[i].targets & target) == target)) {
4201741d:	a0a082        	movi	a8, 160
42017420:	b088      	l32i.n	a8, a0, 44
42017422:	6898      	l32i.n	a9, a8, 24
42017424:	09c957        	bnall	a9, a5, 42017431 <s_find_available_region+0x21>
42017427:	7898      	l32i.n	a9, a8, 28
42017429:	04c967        	bnall	a9, a6, 42017431 <s_find_available_region+0x21>
            if (mem_regions[i].max_slot_size >= size) {
4201742c:	5888      	l32i.n	a8, a8, 20
4201742e:	06b847        	bgeu	a8, a4, 42017438 <s_find_available_region+0x28>
    for (int i = 0; i < region_nums; i++) {
42017431:	221b      	addi.n	a2, a2, 1
42017433:	e53237        	bltu	a2, a3, 4201741c <s_find_available_region+0xc>
    int32_t found_region_id = -1;
42017436:	f27c      	movi.n	a2, -1
}
42017438:	f01d      	retw.n
	...

4201743c <s_is_enclosed>:
 * @param new_block_size  New block size
 *
 * @return True: new block is enclosed; False: new block is not enclosed
 */
static bool s_is_enclosed(uint32_t block_start, uint32_t block_end, uint32_t new_block_start, uint32_t new_block_size)
{
4201743c:	004136        	entry	a1, 32
    bool is_enclosed = false;
    uint32_t new_block_end = new_block_start + new_block_size;
4201743f:	545a      	add.n	a5, a4, a5

    if ((new_block_start >= block_start) && (new_block_end <= block_end)) {
42017441:	622420        	saltu	a2, a4, a2
42017444:	220b      	addi.n	a2, a2, -1
42017446:	602020        	neg	a2, a2
42017449:	623350        	saltu	a3, a3, a5
4201744c:	330b      	addi.n	a3, a3, -1
4201744e:	603030        	neg	a3, a3
42017451:	743030        	extui	a3, a3, 0, 8
    } else {
        is_enclosed = false;
    }

    return is_enclosed;
}
42017454:	102230        	and	a2, a2, a3
42017457:	f01d      	retw.n
42017459:	000000        	ill

4201745c <s_is_overlapped>:
 * @param new_block_size  New block size
 *
 * @return True: new block is overlapped; False: new block is not overlapped
 */
static bool s_is_overlapped(uint32_t block_start, uint32_t block_end, uint32_t new_block_start, uint32_t new_block_size)
{
4201745c:	004136        	entry	a1, 32
    bool is_overlapped = false;
    uint32_t new_block_end = new_block_start + new_block_size;
4201745f:	545a      	add.n	a5, a4, a5

    if (((new_block_start < block_start) && (new_block_end > block_start)) ||
42017461:	629420        	saltu	a9, a4, a2
42017464:	628250        	saltu	a8, a2, a5
42017467:	102980        	and	a2, a9, a8
4201746a:	088987        	bany	a9, a8, 42017476 <s_is_overlapped+0x1a>
            ((new_block_start < block_end) && (new_block_end > block_end))) {
4201746d:	624430        	saltu	a4, a4, a3
42017470:	623350        	saltu	a3, a3, a5
42017473:	102430        	and	a2, a4, a3
    } else {
        is_overlapped = false;
    }

    return is_overlapped;
}
42017476:	f01d      	retw.n

42017478 <spi_flash_chip_list_check>:
    NULL,
};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waddress"
void spi_flash_chip_list_check(esp_flash_t *chip, uint32_t device_id) {
42017478:	004136        	entry	a1, 32
        }
        break;
    default:
        break;
    }
}
4201747b:	f01d      	retw.n
4201747d:	000000        	ill

42017480 <esp_clk_tree_enable_src>:

esp_err_t esp_clk_tree_enable_src(soc_module_clk_t clk_src, bool enable)
{
42017480:	004136        	entry	a1, 32
    (void)clk_src; (void)enable;
    return ESP_OK;
}
42017483:	020c      	movi.n	a2, 0
42017485:	f01d      	retw.n
	...

42017488 <esp_pm_lock_delete>:
{
42017488:	004136        	entry	a1, 32
}
4201748b:	06a122        	movi	a2, 0x106
4201748e:	f01d      	retw.n

42017490 <mpu_hal_set_region_access>:
#include "hal/mpu_types.h"

#include "soc/soc_caps.h"

void mpu_hal_set_region_access(int id, mpu_access_t access)
{
42017490:	004136        	entry	a1, 32
    // 0x60000000 = 3
    // 0x80000000 = 4
    // 0xa0000000 = 5
    // 0xc0000000 = 6
    // 0xe0000000 = 7
    return id * SOC_MPU_MIN_REGION_SIZE;
42017493:	012230        	slli	a2, a2, 29
    uint32_t addr = mpu_ll_id_to_addr(id);

    switch (access)
42017496:	1b2326        	beqi	a3, 2, 420174b5 <mpu_hal_set_region_access+0x25>
42017499:	0733f6        	bgeui	a3, 3, 420174a4 <mpu_hal_set_region_access+0x14>
4201749c:	c3ac      	beqz.n	a3, 420174cc <mpu_hal_set_region_access+0x3c>
4201749e:	081326        	beqi	a3, 1, 420174aa <mpu_hal_set_region_access+0x1a>
420174a1:	000d46        	j	420174da <mpu_hal_set_region_access+0x4a>
420174a4:	183326        	beqi	a3, 3, 420174c0 <mpu_hal_set_region_access+0x30>
420174a7:	000bc6        	j	420174da <mpu_hal_set_region_access+0x4a>
}

static inline void mpu_ll_set_region_rw(uint32_t addr)
{
    WDTLB(0x0, addr); // cached, no allocate
420174aa:	080c      	movi.n	a8, 0
420174ac:	50e280        	wdtlb	a8, a2
420174af:	002030        	dsync
}
420174b2:	000906        	j	420174da <mpu_hal_set_region_access+0x4a>
    WDTLB(0x2, addr); // bypass cache
}

static inline void mpu_ll_set_region_x(uint32_t addr)
{
    WITLB(0x3, addr); // cached
420174b5:	380c      	movi.n	a8, 3
420174b7:	506280        	witlb	a8, a2
420174ba:	002000        	isync
}
420174bd:	000646        	j	420174da <mpu_hal_set_region_access+0x4a>
    WDTLB(0x2, addr); // bypass cache
420174c0:	280c      	movi.n	a8, 2
420174c2:	50e280        	wdtlb	a8, a2
420174c5:	002030        	dsync
}
420174c8:	000386        	j	420174da <mpu_hal_set_region_access+0x4a>
420174cb:	00          	.byte	00

static inline void mpu_ll_set_region_illegal(uint32_t addr)
{
    WITLB(0xF, addr);
420174cc:	f80c      	movi.n	a8, 15
420174ce:	506280        	witlb	a8, a2
420174d1:	002000        	isync
    WDTLB(0xF, addr);
420174d4:	50e280        	wdtlb	a8, a2
420174d7:	002030        	dsync
            mpu_ll_set_region_illegal(addr);
            break;
        default:
            break;
    }
}
420174da:	f01d      	retw.n

420174dc <_fwalk_sglue>:
420174dc:	004136        	entry	a1, 32
420174df:	026d      	mov.n	a6, a2
420174e1:	00a022        	movi	a2, 0
420174e4:	2478      	l32i.n	a7, a4, 8
420174e6:	1458      	l32i.n	a5, a4, 4
420174e8:	0006c6        	j	42017507 <_fwalk_sglue+0x2b>
420174eb:	820000        	mull	a0, a0, a0
420174ee:	b60617        	bnone	a6, a1, 420174a8 <mpu_hal_set_region_access+0x18>
420174f1:	1028      	l32i.n	a2, a0, 4
420174f3:	079782        	l16si	a8, a7, 14
420174f6:	0a0826        	beqi	a8, -1, 42017504 <_fwalk_sglue+0x28>
420174f9:	07bd      	mov.n	a11, a7
420174fb:	20a660        	or	a10, a6, a6
420174fe:	0003e0        	callx8	a3
42017501:	2022a0        	or	a2, a2, a10
42017504:	68c772        	addi	a7, a7, 104
42017507:	550b      	addi.n	a5, a5, -1
42017509:	fe05d6        	bgez	a5, 420174ed <_fwalk_sglue+0x11>
4201750c:	0448      	l32i.n	a4, a4, 0
4201750e:	fd2456        	bnez	a4, 420174e4 <_fwalk_sglue+0x8>
42017511:	f01d      	retw.n
	...

42017514 <gptimer_register_to_group>:
    }
}
#endif // GPTIMER_USE_RETENTION_LINK

static esp_err_t gptimer_register_to_group(gptimer_t *timer)
{
42017514:	006136        	entry	a1, 48
    gptimer_group_t *group = NULL;
    int timer_id = -1;
    for (int i = 0; i < SOC_TIMER_GROUPS; i++) {
42017517:	060c      	movi.n	a6, 0
    int timer_id = -1;
42017519:	f47c      	movi.n	a4, -1
    for (int i = 0; i < SOC_TIMER_GROUPS; i++) {
4201751b:	001e86        	j	42017599 <gptimer_register_to_group+0x85>
        group = gptimer_acquire_group_handle(i);
4201751e:	20a660        	or	a10, a6, a6
42017521:	f27725        	call8	42009c94 <gptimer_acquire_group_handle>
42017524:	207aa0        	or	a7, a10, a10
        ESP_RETURN_ON_FALSE(group, ESP_ERR_NO_MEM, TAG, "no mem for group (%d)", i);
42017527:	027a56        	bnez	a10, 42017552 <gptimer_register_to_group+0x3e>
4201752a:	a2cd81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4201752d:	0008e0        	callx8	a8
42017530:	a6a3b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017533:	016162        	s32i	a6, a1, 4
42017536:	e82c      	movi.n	a8, 46
42017538:	0189      	s32i.n	a8, a1, 0
4201753a:	a69ff1        	l32r	a15, 42000fb8 <_stext+0xf98> (3c02763c <__FUNCTION__$6>)
4201753d:	0bed      	mov.n	a14, a11
4201753f:	0add      	mov.n	a13, a10
42017541:	a69fc1        	l32r	a12, 42000fc0 <_stext+0xfa0> (3c02477c <_flash_rodata_start+0x465c>)
42017544:	1a0c      	movi.n	a10, 1
42017546:	a2d381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017549:	0008e0        	callx8	a8
4201754c:	01a122        	movi	a2, 0x101
4201754f:	001d46        	j	420175c8 <gptimer_register_to_group+0xb4>
        // loop to search free timer in the group
        portENTER_CRITICAL(&group->spinlock);
42017552:	5a4b      	addi.n	a5, a10, 4
42017554:	fb7c      	movi.n	a11, -1
42017556:	05ad      	mov.n	a10, a5
42017558:	a3b681        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
4201755b:	0008e0        	callx8	a8
        for (int j = 0; j < SOC_TIMER_GROUP_TIMERS_PER_GROUP; j++) {
4201755e:	080c      	movi.n	a8, 0
42017560:	000506        	j	42017578 <gptimer_register_to_group+0x64>
42017563:	00          	.byte	00
            if (!group->timers[j]) {
42017564:	a09870        	addx4	a9, a8, a7
42017567:	3998      	l32i.n	a9, a9, 12
42017569:	89cc      	bnez.n	a9, 42017575 <gptimer_register_to_group+0x61>
                timer_id = j;
                group->timers[j] = timer;
4201756b:	a09870        	addx4	a9, a8, a7
4201756e:	3929      	s32i.n	a2, a9, 12
                timer_id = j;
42017570:	084d      	mov.n	a4, a8
                break;
42017572:	000146        	j	4201757b <gptimer_register_to_group+0x67>
        for (int j = 0; j < SOC_TIMER_GROUP_TIMERS_PER_GROUP; j++) {
42017575:	01c882        	addi	a8, a8, 1
42017578:	e828a6        	blti	a8, 2, 42017564 <gptimer_register_to_group+0x50>
            }
        }
        portEXIT_CRITICAL(&group->spinlock);
4201757b:	20a550        	or	a10, a5, a5
4201757e:	a3ad81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42017581:	0008e0        	callx8	a8
        if (timer_id < 0) {
42017584:	00a4d6        	bgez	a4, 42017592 <gptimer_register_to_group+0x7e>
            gptimer_release_group_handle(group);
42017587:	20a770        	or	a10, a7, a7
4201758a:	f28325        	call8	42009dbc <gptimer_release_group_handle>
    for (int i = 0; i < SOC_TIMER_GROUPS; i++) {
4201758d:	661b      	addi.n	a6, a6, 1
4201758f:	000186        	j	42017599 <gptimer_register_to_group+0x85>
        } else {
            timer->timer_id = timer_id;
42017592:	1249      	s32i.n	a4, a2, 4
            timer->group = group;
42017594:	0279      	s32i.n	a7, a2, 0
            break;
42017596:	000086        	j	4201759c <gptimer_register_to_group+0x88>
    for (int i = 0; i < SOC_TIMER_GROUPS; i++) {
42017599:	8126a6        	blti	a6, 2, 4201751e <gptimer_register_to_group+0xa>
        }
    }
    ESP_RETURN_ON_FALSE(timer_id != -1, ESP_ERR_NOT_FOUND, TAG, "no free timer");
4201759c:	260466        	bnei	a4, -1, 420175c6 <gptimer_register_to_group+0xb2>
4201759f:	a2b081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420175a2:	0008e0        	callx8	a8
420175a5:	a685b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
420175a8:	184c      	movi.n	a8, 65
420175aa:	0189      	s32i.n	a8, a1, 0
420175ac:	a683f1        	l32r	a15, 42000fb8 <_stext+0xf98> (3c02763c <__FUNCTION__$6>)
420175af:	0bed      	mov.n	a14, a11
420175b1:	20daa0        	or	a13, a10, a10
420175b4:	a684c1        	l32r	a12, 42000fc4 <_stext+0xfa4> (3c0247a8 <_flash_rodata_start+0x4688>)
420175b7:	01a0a2        	movi	a10, 1
420175ba:	a2b681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420175bd:	0008e0        	callx8	a8
420175c0:	05a122        	movi	a2, 0x105
420175c3:	000046        	j	420175c8 <gptimer_register_to_group+0xb4>
        // even though the sleep retention module init failed, RMT driver should still work, so just warning here
        ESP_LOGW(TAG, "init sleep retention failed on TimerGroup%d Timer%d, power domain may be turned off during sleep", group->group_id, timer_id);
    }
#endif // GPTIMER_USE_RETENTION_LINK

    return ESP_OK;
420175c6:	020c      	movi.n	a2, 0
}
420175c8:	f01d      	retw.n
	...

420175cc <gptimer_unregister_from_group>:

static void gptimer_unregister_from_group(gptimer_t *timer)
{
420175cc:	004136        	entry	a1, 32
    gptimer_group_t *group = timer->group;
420175cf:	0278      	l32i.n	a7, a2, 0
    int timer_id = timer->timer_id;
420175d1:	1228      	l32i.n	a2, a2, 4
    portENTER_CRITICAL(&group->spinlock);
420175d3:	674b      	addi.n	a6, a7, 4
420175d5:	fb7c      	movi.n	a11, -1
420175d7:	20a660        	or	a10, a6, a6
420175da:	a39581        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
420175dd:	0008e0        	callx8	a8
    group->timers[timer_id] = NULL;
420175e0:	a02270        	addx4	a2, a2, a7
420175e3:	080c      	movi.n	a8, 0
420175e5:	3289      	s32i.n	a8, a2, 12
    portEXIT_CRITICAL(&group->spinlock);
420175e7:	06ad      	mov.n	a10, a6
420175e9:	a39281        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
420175ec:	0008e0        	callx8	a8
        sleep_retention_module_deinit(module);
    }
#endif

    // timer has a reference on group, release it now
    gptimer_release_group_handle(group);
420175ef:	07ad      	mov.n	a10, a7
420175f1:	f27ca5        	call8	42009dbc <gptimer_release_group_handle>
}
420175f4:	f01d      	retw.n
	...

420175f8 <gptimer_destroy>:

static esp_err_t gptimer_destroy(gptimer_t *timer)
{
420175f8:	006136        	entry	a1, 48
420175fb:	027d      	mov.n	a7, a2
    if (timer->pm_lock) {
420175fd:	1322a2        	l32i	a10, a2, 76
42017600:	caac      	beqz.n	a10, 42017630 <gptimer_destroy+0x38>
        ESP_RETURN_ON_ERROR(esp_pm_lock_delete(timer->pm_lock), TAG, "delete pm_lock failed");
42017602:	ffe865        	call8	42017488 <esp_pm_lock_delete>
42017605:	0a2d      	mov.n	a2, a10
42017607:	025a16        	beqz	a10, 42017630 <gptimer_destroy+0x38>
4201760a:	a29581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4201760d:	0008e0        	callx8	a8
42017610:	a66bb1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017613:	70a082        	movi	a8, 112
42017616:	0189      	s32i.n	a8, a1, 0
42017618:	a66cf1        	l32r	a15, 42000fc8 <_stext+0xfa8> (3c02762c <__FUNCTION__$5>)
4201761b:	0bed      	mov.n	a14, a11
4201761d:	20daa0        	or	a13, a10, a10
42017620:	a66bc1        	l32r	a12, 42000fcc <_stext+0xfac> (3c0247cc <_flash_rodata_start+0x46ac>)
42017623:	01a0a2        	movi	a10, 1
42017626:	a29b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017629:	0008e0        	callx8	a8
4201762c:	001086        	j	42017672 <gptimer_destroy+0x7a>
4201762f:	d7a800        	ee.stf.64.xp	f10, f13, a0, a8
    }
    if (timer->intr) {
42017632:	9aac      	beqz.n	a10, 4201765f <gptimer_destroy+0x67>
        ESP_RETURN_ON_ERROR(esp_intr_free(timer->intr), TAG, "delete interrupt service failed");
42017634:	ec4ea5        	call8	42003b20 <esp_intr_free>
42017637:	0a2d      	mov.n	a2, a10
42017639:	2aac      	beqz.n	a10, 4201765f <gptimer_destroy+0x67>
4201763b:	a28981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4201763e:	0008e0        	callx8	a8
42017641:	a65eb1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017644:	73a082        	movi	a8, 115
42017647:	0189      	s32i.n	a8, a1, 0
42017649:	a65ff1        	l32r	a15, 42000fc8 <_stext+0xfa8> (3c02762c <__FUNCTION__$5>)
4201764c:	0bed      	mov.n	a14, a11
4201764e:	0add      	mov.n	a13, a10
42017650:	a660c1        	l32r	a12, 42000fd0 <_stext+0xfb0> (3c0247f8 <_flash_rodata_start+0x46d8>)
42017653:	01a0a2        	movi	a10, 1
42017656:	a28f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017659:	0008e0        	callx8	a8
4201765c:	000486        	j	42017672 <gptimer_destroy+0x7a>
    }
    if (timer->group) {
4201765f:	0788      	l32i.n	a8, a7, 0
42017661:	388c      	beqz.n	a8, 42017668 <gptimer_destroy+0x70>
        gptimer_unregister_from_group(timer);
42017663:	07ad      	mov.n	a10, a7
42017665:	fff665        	call8	420175cc <gptimer_unregister_from_group>
    }
    free(timer);
42017668:	07ad      	mov.n	a10, a7
4201766a:	a3c081        	l32r	a8, 4200056c <_stext+0x54c> (4037fe90 <cfree>)
4201766d:	0008e0        	callx8	a8
    return ESP_OK;
42017670:	020c      	movi.n	a2, 0
}
42017672:	f01d      	retw.n

42017674 <gptimer_new_timer>:

esp_err_t gptimer_new_timer(const gptimer_config_t *config, gptimer_handle_t *ret_timer)
{
42017674:	008136        	entry	a1, 64
42017677:	027d      	mov.n	a7, a2
    esp_err_t ret = ESP_OK;
    gptimer_t *timer = NULL;
    ESP_RETURN_ON_FALSE(config && ret_timer, ESP_ERR_INVALID_ARG, TAG, "invalid argument");
42017679:	40f280        	nsau	a8, a2
4201767c:	418580        	srli	a8, a8, 5
4201767f:	40f390        	nsau	a9, a3
42017682:	419590        	srli	a9, a9, 5
42017685:	208890        	or	a8, a8, a9
42017688:	68ac      	beqz.n	a8, 420176b2 <gptimer_new_timer+0x3e>
4201768a:	a27581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4201768d:	0008e0        	callx8	a8
42017690:	a64bb1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017693:	80a082        	movi	a8, 128
42017696:	0189      	s32i.n	a8, a1, 0
42017698:	a64ff1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
4201769b:	0bed      	mov.n	a14, a11
4201769d:	20daa0        	or	a13, a10, a10
420176a0:	a64ec1        	l32r	a12, 42000fd8 <_stext+0xfb8> (3c024830 <_flash_rodata_start+0x4710>)
420176a3:	01a0a2        	movi	a10, 1
420176a6:	a27b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420176a9:	0008e0        	callx8	a8
420176ac:	02a122        	movi	a2, 0x102
420176af:	0079c6        	j	4201789a <gptimer_new_timer+0x226>
    ESP_RETURN_ON_FALSE(config->resolution_hz, ESP_ERR_INVALID_ARG, TAG, "invalid timer resolution:%"PRIu32, config->resolution_hz);
420176b2:	2288      	l32i.n	a8, a2, 8
420176b4:	a8ec      	bnez.n	a8, 420176e2 <gptimer_new_timer+0x6e>
420176b6:	a26a81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420176b9:	0008e0        	callx8	a8
420176bc:	2288      	l32i.n	a8, a2, 8
420176be:	a63fb1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
420176c1:	1189      	s32i.n	a8, a1, 4
420176c3:	81a082        	movi	a8, 129
420176c6:	0189      	s32i.n	a8, a1, 0
420176c8:	a643f1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
420176cb:	0bed      	mov.n	a14, a11
420176cd:	20daa0        	or	a13, a10, a10
420176d0:	a643c1        	l32r	a12, 42000fdc <_stext+0xfbc> (3c024858 <_flash_rodata_start+0x4738>)
420176d3:	01a0a2        	movi	a10, 1
420176d6:	a26f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420176d9:	0008e0        	callx8	a8
420176dc:	02a122        	movi	a2, 0x102
420176df:	006dc6        	j	4201789a <gptimer_new_timer+0x226>
    if (config->intr_priority) {
420176e2:	3288      	l32i.n	a8, a2, 12
420176e4:	e8ac      	beqz.n	a8, 42017716 <gptimer_new_timer+0xa2>
        ESP_RETURN_ON_FALSE(1 << (config->intr_priority) & GPTIMER_ALLOW_INTR_PRIORITY_MASK, ESP_ERR_INVALID_ARG,
420176e6:	0ea092        	movi	a9, 14
420176e9:	29d987        	bbs	a9, a8, 42017716 <gptimer_new_timer+0xa2>
420176ec:	a25d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420176ef:	0008e0        	callx8	a8
420176f2:	3288      	l32i.n	a8, a2, 12
420176f4:	a632b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
420176f7:	1189      	s32i.n	a8, a1, 4
420176f9:	83a082        	movi	a8, 131
420176fc:	0189      	s32i.n	a8, a1, 0
420176fe:	a635f1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
42017701:	0bed      	mov.n	a14, a11
42017703:	0add      	mov.n	a13, a10
42017705:	a636c1        	l32r	a12, 42000fe0 <_stext+0xfc0> (3c02488c <_flash_rodata_start+0x476c>)
42017708:	1a0c      	movi.n	a10, 1
4201770a:	a26281        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4201770d:	0008e0        	callx8	a8
42017710:	02a122        	movi	a2, 0x102
42017713:	0060c6        	j	4201789a <gptimer_new_timer+0x226>
                            TAG, "invalid interrupt priority:%d", config->intr_priority);
    }

    bool allow_pd = (config->flags.allow_pd == 1) || (config->flags.backup_before_sleep == 1);
42017716:	4788      	l32i.n	a8, a7, 16
#if !SOC_TIMER_SUPPORT_SLEEP_RETENTION
    ESP_RETURN_ON_FALSE(allow_pd == false, ESP_ERR_NOT_SUPPORTED, TAG, "not able to power down in light sleep");
42017718:	148180        	extui	a8, a8, 1, 2
4201771b:	02a816        	beqz	a8, 42017749 <gptimer_new_timer+0xd5>
4201771e:	a25081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017721:	0008e0        	callx8	a8
42017724:	a626b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017727:	89a082        	movi	a8, 137
4201772a:	0189      	s32i.n	a8, a1, 0
4201772c:	a62af1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
4201772f:	0bed      	mov.n	a14, a11
42017731:	20daa0        	or	a13, a10, a10
42017734:	a62cc1        	l32r	a12, 42000fe4 <_stext+0xfc4> (3c0248c0 <_flash_rodata_start+0x47a0>)
42017737:	01a0a2        	movi	a10, 1
4201773a:	a25681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
4201773d:	0008e0        	callx8	a8
42017740:	06a122        	movi	a2, 0x106
42017743:	0054c6        	j	4201789a <gptimer_new_timer+0x226>
42017746:	000000        	ill
#endif // SOC_TIMER_SUPPORT_SLEEP_RETENTION

    // always allocate memory from internal memory because the driver object contains atomic variable
    timer = heap_caps_calloc(1, sizeof(gptimer_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42017749:	a35bc1        	l32r	a12, 420004b8 <_stext+0x498> (804 <UserFrameTotalSize+0x704>)
4201774c:	8b5c      	movi.n	a11, 88
4201774e:	1a0c      	movi.n	a10, 1
42017750:	a4af81        	l32r	a8, 42000a0c <_stext+0x9ec> (40375ff8 <heap_caps_calloc>)
42017753:	0008e0        	callx8	a8
42017756:	0a6d      	mov.n	a6, a10
    ESP_GOTO_ON_FALSE(timer, ESP_ERR_NO_MEM, err, TAG, "no mem for gptimer");
42017758:	8aec      	bnez.n	a10, 42017784 <gptimer_new_timer+0x110>
4201775a:	a24181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4201775d:	0008e0        	callx8	a8
42017760:	a617b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017763:	8ea082        	movi	a8, 142
42017766:	0189      	s32i.n	a8, a1, 0
42017768:	a61bf1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
4201776b:	0bed      	mov.n	a14, a11
4201776d:	20daa0        	or	a13, a10, a10
42017770:	a61ec1        	l32r	a12, 42000fe8 <_stext+0xfc8> (3c0248fc <_flash_rodata_start+0x47dc>)
42017773:	01a0a2        	movi	a10, 1
42017776:	a24781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017779:	0008e0        	callx8	a8
4201777c:	01a122        	movi	a2, 0x101
4201777f:	004346        	j	42017890 <gptimer_new_timer+0x21c>
42017782:	e50000        	extui	a0, a0, 16, 15
    // register timer to the group (because one group can have several timers)
    ESP_GOTO_ON_ERROR(gptimer_register_to_group(timer), err, TAG, "register timer failed");
42017785:	ffd8      	l32i.n	a13, a15, 60
42017787:	0a2d      	mov.n	a2, a10
42017789:	3aac      	beqz.n	a10, 420177b0 <gptimer_new_timer+0x13c>
4201778b:	a23581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
4201778e:	0008e0        	callx8	a8
42017791:	a60ab1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017794:	90a082        	movi	a8, 144
42017797:	0189      	s32i.n	a8, a1, 0
42017799:	a60ef1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
4201779c:	0bed      	mov.n	a14, a11
4201779e:	0add      	mov.n	a13, a10
420177a0:	a613c1        	l32r	a12, 42000fec <_stext+0xfcc> (3c024924 <_flash_rodata_start+0x4804>)
420177a3:	01a0a2        	movi	a10, 1
420177a6:	a23b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420177a9:	0008e0        	callx8	a8
420177ac:	003806        	j	42017890 <gptimer_new_timer+0x21c>
420177af:	068800        	ee.ldf.64.xp	f8, f0, a0, a8
    gptimer_group_t *group = timer->group;
420177b2:	4189      	s32i.n	a8, a1, 16
    int group_id = group->group_id;
    int timer_id = timer->timer_id;
420177b4:	1658      	l32i.n	a5, a6, 4
        gptimer_create_retention_module(timer);
#endif // GPTIMER_USE_RETENTION_LINK
    }

    // initialize HAL layer
    timer_hal_init(&timer->hal, group_id, timer_id);
420177b6:	24c642        	addi	a4, a6, 36
420177b9:	05cd      	mov.n	a12, a5
420177bb:	08b8      	l32i.n	a11, a8, 0
420177bd:	04ad      	mov.n	a10, a4
420177bf:	017a25        	call8	42018f60 <timer_hal_init>
    // select clock source, set clock resolution
    ESP_GOTO_ON_ERROR(gptimer_select_periph_clock(timer, config->clk_src, config->resolution_hz), err, TAG, "set periph clock failed");
420177c2:	27c8      	l32i.n	a12, a7, 8
420177c4:	07b8      	l32i.n	a11, a7, 0
420177c6:	06ad      	mov.n	a10, a6
420177c8:	f26b25        	call8	42009e7c <gptimer_select_periph_clock>
420177cb:	0a2d      	mov.n	a2, a10
420177cd:	3aac      	beqz.n	a10, 420177f4 <gptimer_new_timer+0x180>
420177cf:	a22481        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420177d2:	0008e0        	callx8	a8
420177d5:	a5f9b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
420177d8:	9ea082        	movi	a8, 158
420177db:	0189      	s32i.n	a8, a1, 0
420177dd:	a5fdf1        	l32r	a15, 42000fd4 <_stext+0xfb4> (3c027658 <__FUNCTION__$7>)
420177e0:	0bed      	mov.n	a14, a11
420177e2:	0add      	mov.n	a13, a10
420177e4:	a603c1        	l32r	a12, 42000ff0 <_stext+0xfd0> (3c024950 <_flash_rodata_start+0x4830>)
420177e7:	01a0a2        	movi	a10, 1
420177ea:	a22a81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420177ed:	0008e0        	callx8	a8
420177f0:	002706        	j	42017890 <gptimer_new_timer+0x21c>
420177f3:	00          	.byte	00
    // initialize counter value to zero
    timer_hal_set_counter_value(&timer->hal, 0);
420177f4:	0c0c      	movi.n	a12, 0
420177f6:	0cdd      	mov.n	a13, a12
420177f8:	04ad      	mov.n	a10, a4
420177fa:	0181a5        	call8	42019014 <timer_hal_set_counter_value>
    // set counting direction
    timer_ll_set_count_direction(timer->hal.dev, timer_id, config->direction);
420177fd:	9698      	l32i.n	a9, a6, 36
420177ff:	1788      	l32i.n	a8, a7, 4
    hw->hw_timer[timer_num].config.tn_increase = (direction == GPTIMER_COUNT_UP);
42017801:	880b      	addi.n	a8, a8, -1
42017803:	040c      	movi.n	a4, 0
42017805:	b0a550        	addx8	a10, a5, a5
42017808:	a0aa90        	addx4	a10, a10, a9
4201780b:	0020c0        	memw
4201780e:	0a98      	l32i.n	a9, a10, 0
42017810:	40f880        	nsau	a8, a8
42017813:	418580        	srli	a8, a8, 5
42017816:	018820        	slli	a8, a8, 30
42017819:	a555b1        	l32r	a11, 42000d70 <_stext+0xd50> (bfffffff <_rtc_reserved_end+0x5fefffff>)
4201781c:	1099b0        	and	a9, a9, a11
4201781f:	208980        	or	a8, a9, a8
42017822:	0020c0        	memw
42017825:	0a89      	s32i.n	a8, a10, 0

    // interrupt register is shared by all timers in the same group
    portENTER_CRITICAL(&group->spinlock);
42017827:	4188      	l32i.n	a8, a1, 16
42017829:	884b      	addi.n	a8, a8, 4
4201782b:	fb7c      	movi.n	a11, -1
4201782d:	4189      	s32i.n	a8, a1, 16
4201782f:	08ad      	mov.n	a10, a8
42017831:	a2ff81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017834:	0008e0        	callx8	a8
    timer_ll_enable_intr(timer->hal.dev, TIMER_LL_EVENT_ALARM(timer_id), false); // disable interrupt
42017837:	96a8      	l32i.n	a10, a6, 36
42017839:	180c      	movi.n	a8, 1
4201783b:	401500        	ssl	a5
4201783e:	a18800        	sll	a8, a8
static inline void timer_ll_enable_intr(timg_dev_t *hw, uint32_t mask, bool en)
{
    if (en) {
        hw->int_ena_timers.val |= mask;
    } else {
        hw->int_ena_timers.val &= ~mask;
42017841:	0020c0        	memw
42017844:	1c2ab2        	l32i	a11, a10, 112
42017847:	1098b0        	and	a9, a8, a11
4201784a:	3099b0        	xor	a9, a9, a11
4201784d:	0020c0        	memw
42017850:	1c6a92        	s32i	a9, a10, 112
    timer_ll_clear_intr_status(timer->hal.dev, TIMER_LL_EVENT_ALARM(timer_id)); // clear pending interrupt event
42017853:	9698      	l32i.n	a9, a6, 36
 * @param mask Interrupt events mask
 */
__attribute__((always_inline))
static inline void timer_ll_clear_intr_status(timg_dev_t *hw, uint32_t mask)
{
    hw->int_clr_timers.val = mask;
42017855:	0020c0        	memw
42017858:	1f6982        	s32i	a8, a9, 124
    portEXIT_CRITICAL(&group->spinlock);
4201785b:	0421a2        	l32i	a10, a1, 16
4201785e:	a2f581        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42017861:	0008e0        	callx8	a8
    // initialize other members of timer
    timer->spinlock = (portMUX_TYPE)portMUX_INITIALIZER_UNLOCKED;
42017864:	a31181        	l32r	a8, 420004a8 <_stext+0x488> (b33fffff <_rtc_reserved_end+0x532fffff>)
42017867:	e689      	s32i.n	a8, a6, 56
42017869:	f649      	s32i.n	a4, a6, 60
    // put the timer driver to the init state
    atomic_init(&timer->fsm, GPTIMER_FSM_INIT);
4201786b:	0020c0        	memw
4201786e:	b649      	s32i.n	a4, a6, 44
    timer->direction = config->direction;
42017870:	1788      	l32i.n	a8, a7, 4
42017872:	8689      	s32i.n	a8, a6, 32
    timer->intr_priority = config->intr_priority;
42017874:	3788      	l32i.n	a8, a7, 12
42017876:	c689      	s32i.n	a8, a6, 48
    timer->flags.intr_shared = config->flags.intr_shared;
42017878:	4798      	l32i.n	a9, a7, 16
4201787a:	049090        	extui	a9, a9, 0, 1
4201787d:	500682        	l8ui	a8, a6, 80
42017880:	ea7c      	movi.n	a10, -2
42017882:	1088a0        	and	a8, a8, a10
42017885:	208890        	or	a8, a8, a9
42017888:	504682        	s8i	a8, a6, 80
    ESP_LOGD(TAG, "new gptimer (%d,%d) at %p, %zu bytes used", group_id, timer_id, timer, heap_caps_get_allocated_size(timer));
    *ret_timer = timer;
4201788b:	0369      	s32i.n	a6, a3, 0
    return ESP_OK;
4201788d:	000246        	j	4201789a <gptimer_new_timer+0x226>

err:
    if (timer) {
42017890:	668c      	beqz.n	a6, 4201789a <gptimer_new_timer+0x226>
        gptimer_destroy(timer);
42017892:	06ad      	mov.n	a10, a6
42017894:	201110        	or	a1, a1, a1
42017897:	ffd625        	call8	420175f8 <gptimer_destroy>
    }
    return ret;
}
4201789a:	f01d      	retw.n

4201789c <gptimer_del_timer>:

esp_err_t gptimer_del_timer(gptimer_handle_t timer)
{
4201789c:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(timer, ESP_ERR_INVALID_ARG, TAG, "invalid argument");
4201789f:	02a256        	bnez	a2, 420178cd <gptimer_del_timer+0x31>
420178a2:	a1ef81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420178a5:	0008e0        	callx8	a8
420178a8:	a5c5b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
420178ab:	bda082        	movi	a8, 189
420178ae:	0189      	s32i.n	a8, a1, 0
420178b0:	a5d1f1        	l32r	a15, 42000ff4 <_stext+0xfd4> (3c027618 <__FUNCTION__$4>)
420178b3:	0bed      	mov.n	a14, a11
420178b5:	20daa0        	or	a13, a10, a10
420178b8:	a5c8c1        	l32r	a12, 42000fd8 <_stext+0xfb8> (3c024830 <_flash_rodata_start+0x4710>)
420178bb:	01a0a2        	movi	a10, 1
420178be:	a1f581        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420178c1:	0008e0        	callx8	a8
420178c4:	02a122        	movi	a2, 0x102
420178c7:	001ac6        	j	42017936 <gptimer_del_timer+0x9a>
420178ca:	000000        	ill
    ESP_RETURN_ON_FALSE(atomic_load(&timer->fsm) == GPTIMER_FSM_INIT, ESP_ERR_INVALID_STATE, TAG, "timer not in init state");
420178cd:	0020c0        	memw
420178d0:	0020c0        	memw
420178d3:	b288      	l32i.n	a8, a2, 44
420178d5:	0020c0        	memw
420178d8:	98ac      	beqz.n	a8, 42017905 <gptimer_del_timer+0x69>
420178da:	a1e181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420178dd:	0008e0        	callx8	a8
420178e0:	a5b7b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
420178e3:	bea082        	movi	a8, 190
420178e6:	0189      	s32i.n	a8, a1, 0
420178e8:	a5c3f1        	l32r	a15, 42000ff4 <_stext+0xfd4> (3c027618 <__FUNCTION__$4>)
420178eb:	0bed      	mov.n	a14, a11
420178ed:	20daa0        	or	a13, a10, a10
420178f0:	a5c2c1        	l32r	a12, 42000ff8 <_stext+0xfd8> (3c024980 <_flash_rodata_start+0x4860>)
420178f3:	01a0a2        	movi	a10, 1
420178f6:	a1e781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
420178f9:	0008e0        	callx8	a8
420178fc:	03a122        	movi	a2, 0x103
420178ff:	000cc6        	j	42017936 <gptimer_del_timer+0x9a>
42017902:	000000        	ill
    ESP_LOGD(TAG, "del timer (%d,%d)", group_id, timer_id);
    // disable the source clock
    GPTIMER_CLOCK_SRC_ATOMIC() {
        timer_ll_enable_clock(group_id, hal->timer_id, false);
    }
    timer_hal_deinit(hal);
42017905:	24c2a2        	addi	a10, a2, 36
42017908:	016b25        	call8	42018fbc <timer_hal_deinit>
    // recycle memory resource
    ESP_RETURN_ON_ERROR(gptimer_destroy(timer), TAG, "destroy gptimer failed");
4201790b:	20a220        	or	a10, a2, a2
4201790e:	ffcea5        	call8	420175f8 <gptimer_destroy>
42017911:	202aa0        	or	a2, a10, a10
42017914:	ea9c      	beqz.n	a10, 42017936 <gptimer_del_timer+0x9a>
42017916:	a1d281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017919:	0008e0        	callx8	a8
4201791c:	a5a8b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
4201791f:	cba082        	movi	a8, 203
42017922:	0189      	s32i.n	a8, a1, 0
42017924:	a5b4f1        	l32r	a15, 42000ff4 <_stext+0xfd4> (3c027618 <__FUNCTION__$4>)
42017927:	0bed      	mov.n	a14, a11
42017929:	0add      	mov.n	a13, a10
4201792b:	a5b4c1        	l32r	a12, 42000ffc <_stext+0xfdc> (3c0249b0 <_flash_rodata_start+0x4890>)
4201792e:	1a0c      	movi.n	a10, 1
42017930:	a1d981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017933:	0008e0        	callx8	a8
#endif // SOC_TIMER_GROUP_SUPPORT_RC_FAST
    default:
        break;
    }
    return ESP_OK;
}
42017936:	f01d      	retw.n

42017938 <gptimer_set_raw_count>:

esp_err_t gptimer_set_raw_count(gptimer_handle_t timer, unsigned long long value)
{
42017938:	004136        	entry	a1, 32
    if (timer == NULL) {
4201793b:	051216        	beqz	a2, 42017990 <gptimer_set_raw_count+0x58>
        return ESP_ERR_INVALID_ARG;
    }

    portENTER_CRITICAL_SAFE(&timer->spinlock);
4201793e:	38c272        	addi	a7, a2, 56
    if (xPortInIsrContext()) {
42017941:	a2b681        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42017944:	0008e0        	callx8	a8
42017947:	fa8c      	beqz.n	a10, 4201795a <gptimer_set_raw_count+0x22>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42017949:	fb7c      	movi.n	a11, -1
4201794b:	20a770        	or	a10, a7, a7
4201794e:	a2b881        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017951:	0008e0        	callx8	a8
42017954:	000306        	j	42017964 <gptimer_set_raw_count+0x2c>
42017957:	000000        	ill
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4201795a:	fb7c      	movi.n	a11, -1
4201795c:	07ad      	mov.n	a10, a7
4201795e:	a2b481        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017961:	0008e0        	callx8	a8
    timer_hal_set_counter_value(&timer->hal, value);
42017964:	04cd      	mov.n	a12, a4
42017966:	05dd      	mov.n	a13, a5
42017968:	24c2a2        	addi	a10, a2, 36
4201796b:	016aa5        	call8	42019014 <timer_hal_set_counter_value>
    if (xPortInIsrContext()) {
4201796e:	a2ab81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42017971:	0008e0        	callx8	a8
42017974:	0a2d      	mov.n	a2, a10
42017976:	ba8c      	beqz.n	a10, 42017985 <gptimer_set_raw_count+0x4d>
        portEXIT_CRITICAL_ISR(mux);
42017978:	07ad      	mov.n	a10, a7
4201797a:	a2ae81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4201797d:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&timer->spinlock);
    return ESP_OK;
42017980:	020c      	movi.n	a2, 0
42017982:	000346        	j	42017993 <gptimer_set_raw_count+0x5b>
        portEXIT_CRITICAL(mux);
42017985:	07ad      	mov.n	a10, a7
42017987:	a2ab81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
4201798a:	0008e0        	callx8	a8
4201798d:	000086        	j	42017993 <gptimer_set_raw_count+0x5b>
        return ESP_ERR_INVALID_ARG;
42017990:	02a122        	movi	a2, 0x102
}
42017993:	f01d      	retw.n
42017995:	000000        	ill

42017998 <gptimer_get_raw_count>:

esp_err_t gptimer_get_raw_count(gptimer_handle_t timer, unsigned long long *value)
{
42017998:	004136        	entry	a1, 32
    if (timer == NULL || value == NULL) {
4201799b:	40f280        	nsau	a8, a2
4201799e:	418580        	srli	a8, a8, 5
420179a1:	40f390        	nsau	a9, a3
420179a4:	419590        	srli	a9, a9, 5
420179a7:	208890        	or	a8, a8, a9
420179aa:	056856        	bnez	a8, 42017a04 <gptimer_get_raw_count+0x6c>
        return ESP_ERR_INVALID_ARG;
    }

    portENTER_CRITICAL_SAFE(&timer->spinlock);
420179ad:	38c272        	addi	a7, a2, 56
    if (xPortInIsrContext()) {
420179b0:	a29b81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
420179b3:	0008e0        	callx8	a8
420179b6:	0a9c      	beqz.n	a10, 420179ca <gptimer_get_raw_count+0x32>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
420179b8:	ffafb2        	movi	a11, -1
420179bb:	20a770        	or	a10, a7, a7
420179be:	a29c81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
420179c1:	0008e0        	callx8	a8
420179c4:	000346        	j	420179d5 <gptimer_get_raw_count+0x3d>
420179c7:	000000        	ill
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
420179ca:	fb7c      	movi.n	a11, -1
420179cc:	20a770        	or	a10, a7, a7
420179cf:	a29881        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
420179d2:	0008e0        	callx8	a8
    *value = timer_hal_capture_and_get_counter_value(&timer->hal);
420179d5:	24c2a2        	addi	a10, a2, 36
420179d8:	a58a81        	l32r	a8, 42001000 <_stext+0xfe0> (4037e564 <timer_hal_capture_and_get_counter_value>)
420179db:	0008e0        	callx8	a8
420179de:	03a9      	s32i.n	a10, a3, 0
420179e0:	13b9      	s32i.n	a11, a3, 4
    if (xPortInIsrContext()) {
420179e2:	a28e81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
420179e5:	0008e0        	callx8	a8
420179e8:	0a2d      	mov.n	a2, a10
420179ea:	ba8c      	beqz.n	a10, 420179f9 <gptimer_get_raw_count+0x61>
        portEXIT_CRITICAL_ISR(mux);
420179ec:	07ad      	mov.n	a10, a7
420179ee:	a29181        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
420179f1:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&timer->spinlock);
    return ESP_OK;
420179f4:	020c      	movi.n	a2, 0
420179f6:	000346        	j	42017a07 <gptimer_get_raw_count+0x6f>
        portEXIT_CRITICAL(mux);
420179f9:	07ad      	mov.n	a10, a7
420179fb:	a28e81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
420179fe:	0008e0        	callx8	a8
42017a01:	000086        	j	42017a07 <gptimer_get_raw_count+0x6f>
        return ESP_ERR_INVALID_ARG;
42017a04:	02a122        	movi	a2, 0x102
}
42017a07:	f01d      	retw.n
42017a09:	000000        	ill

42017a0c <gptimer_enable>:
    portEXIT_CRITICAL_SAFE(&timer->spinlock);
    return ESP_OK;
}

esp_err_t gptimer_enable(gptimer_handle_t timer)
{
42017a0c:	006136        	entry	a1, 48
42017a0f:	027d      	mov.n	a7, a2
    ESP_RETURN_ON_FALSE(timer, ESP_ERR_INVALID_ARG, TAG, "invalid argument");
42017a11:	72ec      	bnez.n	a2, 42017a3c <gptimer_enable+0x30>
42017a13:	a19381        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017a16:	0008e0        	callx8	a8
42017a19:	a568b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017a1c:	58a182        	movi	a8, 0x158
42017a1f:	0189      	s32i.n	a8, a1, 0
42017a21:	a578f1        	l32r	a15, 42001004 <_stext+0xfe4> (3c027608 <__FUNCTION__$1>)
42017a24:	0bed      	mov.n	a14, a11
42017a26:	0add      	mov.n	a13, a10
42017a28:	a56cc1        	l32r	a12, 42000fd8 <_stext+0xfb8> (3c024830 <_flash_rodata_start+0x4710>)
42017a2b:	01a0a2        	movi	a10, 1
42017a2e:	a19981        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017a31:	0008e0        	callx8	a8
42017a34:	02a122        	movi	a2, 0x102
42017a37:	0029c6        	j	42017ae2 <gptimer_enable+0xd6>
42017a3a:	820000        	mull	a0, a0, a0
    // the only acceptable FSM change: init->enable
    gptimer_fsm_t expected_fsm = GPTIMER_FSM_INIT;
    ESP_RETURN_ON_FALSE(atomic_compare_exchange_strong(&timer->fsm, &expected_fsm, GPTIMER_FSM_ENABLE),
42017a3d:	0c2cc2        	l32i	a12, a12, 48
42017a40:	0c0a      	add.n	a0, a12, a0
42017a42:	a019      	s32i.n	a1, a0, 40
42017a44:	130c      	movi.n	a3, 1
42017a46:	00e892        	s32c1i	a9, a8, 0
42017a49:	89ac      	beqz.n	a9, 42017a75 <gptimer_enable+0x69>
42017a4b:	a18581        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017a4e:	0008e0        	callx8	a8
42017a51:	a55ab1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017a54:	5ba182        	movi	a8, 0x15b
42017a57:	0189      	s32i.n	a8, a1, 0
42017a59:	a56af1        	l32r	a15, 42001004 <_stext+0xfe4> (3c027608 <__FUNCTION__$1>)
42017a5c:	0bed      	mov.n	a14, a11
42017a5e:	0add      	mov.n	a13, a10
42017a60:	a566c1        	l32r	a12, 42000ff8 <_stext+0xfd8> (3c024980 <_flash_rodata_start+0x4860>)
42017a63:	01a0a2        	movi	a10, 1
42017a66:	a18b81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017a69:	0008e0        	callx8	a8
42017a6c:	03a122        	movi	a2, 0x103
42017a6f:	001bc6        	j	42017ae2 <gptimer_enable+0xd6>
42017a72:	000000        	ill
                        ESP_ERR_INVALID_STATE, TAG, "timer not in init state");

    // acquire power manager lock
    if (timer->pm_lock) {
42017a75:	1322a2        	l32i	a10, a2, 76
42017a78:	0abc      	beqz.n	a10, 42017aac <gptimer_enable+0xa0>
        ESP_RETURN_ON_ERROR(esp_pm_lock_acquire(timer->pm_lock), TAG, "acquire pm_lock failed");
42017a7a:	a56581        	l32r	a8, 42001010 <_stext+0xff0> (40377d08 <esp_pm_lock_acquire>)
42017a7d:	0008e0        	callx8	a8
42017a80:	202aa0        	or	a2, a10, a10
42017a83:	025a16        	beqz	a10, 42017aac <gptimer_enable+0xa0>
42017a86:	a17681        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017a89:	0008e0        	callx8	a8
42017a8c:	a54cb1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017a8f:	60a182        	movi	a8, 0x160
42017a92:	0189      	s32i.n	a8, a1, 0
42017a94:	a55cf1        	l32r	a15, 42001004 <_stext+0xfe4> (3c027608 <__FUNCTION__$1>)
42017a97:	0bed      	mov.n	a14, a11
42017a99:	20daa0        	or	a13, a10, a10
42017a9c:	a55bc1        	l32r	a12, 42001008 <_stext+0xfe8> (3c0249dc <_flash_rodata_start+0x48bc>)
42017a9f:	01a0a2        	movi	a10, 1
42017aa2:	a17c81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017aa5:	0008e0        	callx8	a8
42017aa8:	000d86        	j	42017ae2 <gptimer_enable+0xd6>
42017aab:	d7a800        	ee.stf.64.xp	f10, f13, a0, a8
    }

    // enable interrupt service
    if (timer->intr) {
42017aae:	eaac      	beqz.n	a10, 42017ae0 <gptimer_enable+0xd4>
        ESP_RETURN_ON_ERROR(esp_intr_enable(timer->intr), TAG, "enable interrupt service failed");
42017ab0:	a55981        	l32r	a8, 42001014 <_stext+0xff4> (40376588 <esp_intr_enable>)
42017ab3:	0008e0        	callx8	a8
42017ab6:	0a2d      	mov.n	a2, a10
42017ab8:	6aac      	beqz.n	a10, 42017ae2 <gptimer_enable+0xd6>
42017aba:	a16981        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017abd:	0008e0        	callx8	a8
42017ac0:	a53fb1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017ac3:	65a182        	movi	a8, 0x165
42017ac6:	0189      	s32i.n	a8, a1, 0
42017ac8:	a54ff1        	l32r	a15, 42001004 <_stext+0xfe4> (3c027608 <__FUNCTION__$1>)
42017acb:	0bed      	mov.n	a14, a11
42017acd:	20daa0        	or	a13, a10, a10
42017ad0:	a54fc1        	l32r	a12, 4200100c <_stext+0xfec> (3c024a08 <_flash_rodata_start+0x48e8>)
42017ad3:	01a0a2        	movi	a10, 1
42017ad6:	a16f81        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017ad9:	0008e0        	callx8	a8
42017adc:	000086        	j	42017ae2 <gptimer_enable+0xd6>
42017adf:	020c00        	andb	b0, b12, b0
    }

    return ESP_OK;
}
42017ae2:	f01d      	retw.n

42017ae4 <gptimer_disable>:

esp_err_t gptimer_disable(gptimer_handle_t timer)
{
42017ae4:	006136        	entry	a1, 48
42017ae7:	027d      	mov.n	a7, a2
    ESP_RETURN_ON_FALSE(timer, ESP_ERR_INVALID_ARG, TAG, "invalid argument");
42017ae9:	72ec      	bnez.n	a2, 42017b14 <gptimer_disable+0x30>
42017aeb:	a15d81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017aee:	0008e0        	callx8	a8
42017af1:	a532b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017af4:	6da182        	movi	a8, 0x16d
42017af7:	0189      	s32i.n	a8, a1, 0
42017af9:	a547f1        	l32r	a15, 42001018 <_stext+0xff8> (3c0275f8 <__FUNCTION__$0>)
42017afc:	0bed      	mov.n	a14, a11
42017afe:	0add      	mov.n	a13, a10
42017b00:	a536c1        	l32r	a12, 42000fd8 <_stext+0xfb8> (3c024830 <_flash_rodata_start+0x4710>)
42017b03:	01a0a2        	movi	a10, 1
42017b06:	a16381        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017b09:	0008e0        	callx8	a8
42017b0c:	02a122        	movi	a2, 0x102
42017b0f:	002ac6        	j	42017bbe <gptimer_disable+0xda>
42017b12:	820000        	mull	a0, a0, a0
    // the only acceptable FSM change: enable->init
    gptimer_fsm_t expected_fsm = GPTIMER_FSM_ENABLE;
    ESP_RETURN_ON_FALSE(atomic_compare_exchange_strong(&timer->fsm, &expected_fsm, GPTIMER_FSM_INIT),
42017b15:	a22cc2        	l32i	a12, a12, 0x288
42017b18:	a0          	.byte	0xa0
42017b19:	a09201        	l32r	a0, 41fffd64 <_iram_bss_end+0x1c7d964>
42017b1c:	00          	.byte	00
42017b1d:	130ca0        	wsr.scompare1	a10
42017b20:	00e892        	s32c1i	a9, a8, 0
42017b23:	271926        	beqi	a9, 1, 42017b4e <gptimer_disable+0x6a>
42017b26:	a14e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017b29:	0008e0        	callx8	a8
42017b2c:	a524b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017b2f:	70a182        	movi	a8, 0x170
42017b32:	0189      	s32i.n	a8, a1, 0
42017b34:	a539f1        	l32r	a15, 42001018 <_stext+0xff8> (3c0275f8 <__FUNCTION__$0>)
42017b37:	0bed      	mov.n	a14, a11
42017b39:	20daa0        	or	a13, a10, a10
42017b3c:	a538c1        	l32r	a12, 4200101c <_stext+0xffc> (3c024a40 <_flash_rodata_start+0x4920>)
42017b3f:	01a0a2        	movi	a10, 1
42017b42:	a15481        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017b45:	0008e0        	callx8	a8
42017b48:	03a122        	movi	a2, 0x103
42017b4b:	001bc6        	j	42017bbe <gptimer_disable+0xda>
                        ESP_ERR_INVALID_STATE, TAG, "timer not in enable state");

    // disable interrupt service
    if (timer->intr) {
42017b4e:	d2a8      	l32i.n	a10, a2, 52
42017b50:	1abc      	beqz.n	a10, 42017b85 <gptimer_disable+0xa1>
        ESP_RETURN_ON_ERROR(esp_intr_disable(timer->intr), TAG, "disable interrupt service failed");
42017b52:	a28881        	l32r	a8, 42000574 <_stext+0x554> (40376654 <esp_intr_disable>)
42017b55:	0008e0        	callx8	a8
42017b58:	202aa0        	or	a2, a10, a10
42017b5b:	026a16        	beqz	a10, 42017b85 <gptimer_disable+0xa1>
42017b5e:	a14081        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017b61:	0008e0        	callx8	a8
42017b64:	a516b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017b67:	75a182        	movi	a8, 0x175
42017b6a:	0189      	s32i.n	a8, a1, 0
42017b6c:	a52bf1        	l32r	a15, 42001018 <_stext+0xff8> (3c0275f8 <__FUNCTION__$0>)
42017b6f:	0bed      	mov.n	a14, a11
42017b71:	20daa0        	or	a13, a10, a10
42017b74:	a52bc1        	l32r	a12, 42001020 <_stext+0x1000> (3c024a70 <_flash_rodata_start+0x4950>)
42017b77:	01a0a2        	movi	a10, 1
42017b7a:	a14681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017b7d:	0008e0        	callx8	a8
42017b80:	000e86        	j	42017bbe <gptimer_disable+0xda>
42017b83:	a20000        	muluh	a0, a0, a0
    }

    // release power manager lock
    if (timer->pm_lock) {
42017b86:	bc1327        	beq	a3, a2, 42017b46 <gptimer_disable+0x62>
42017b89:	810a      	add.n	a8, a1, a0
        ESP_RETURN_ON_ERROR(esp_pm_lock_release(timer->pm_lock), TAG, "release pm_lock failed");
42017b8b:	e0a527        	bge	a5, a2, 42017b6f <gptimer_disable+0x8b>
42017b8e:	0008      	l32i.n	a0, a0, 0
42017b90:	202aa0        	or	a2, a10, a10
42017b93:	027a16        	beqz	a10, 42017bbe <gptimer_disable+0xda>
42017b96:	a13281        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42017b99:	0008e0        	callx8	a8
42017b9c:	a508b1        	l32r	a11, 42000fbc <_stext+0xf9c> (3c024774 <_flash_rodata_start+0x4654>)
42017b9f:	7aa182        	movi	a8, 0x17a
42017ba2:	0189      	s32i.n	a8, a1, 0
42017ba4:	a51df1        	l32r	a15, 42001018 <_stext+0xff8> (3c0275f8 <__FUNCTION__$0>)
42017ba7:	0bed      	mov.n	a14, a11
42017ba9:	20daa0        	or	a13, a10, a10
42017bac:	a51ec1        	l32r	a12, 42001024 <_stext+0x1004> (3c024aa8 <_flash_rodata_start+0x4988>)
42017baf:	01a0a2        	movi	a10, 1
42017bb2:	a13881        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42017bb5:	0008e0        	callx8	a8
42017bb8:	000086        	j	42017bbe <gptimer_disable+0xda>
42017bbb:	020c00        	andb	b0, b12, b0
    }

    return ESP_OK;
}
42017bbe:	f01d      	retw.n

42017bc0 <gptimer_start>:

esp_err_t gptimer_start(gptimer_handle_t timer)
{
42017bc0:	004136        	entry	a1, 32
    if (timer == NULL) {
42017bc3:	0b5216        	beqz	a2, 42017c7c <gptimer_start+0xbc>
        return ESP_ERR_INVALID_ARG;
    }

    // if the timer is already started, do nothing
    if (atomic_load(&timer->fsm) == GPTIMER_FSM_RUN) {
42017bc6:	2cc282        	addi	a8, a2, 44
42017bc9:	0020c0        	memw
42017bcc:	0020c0        	memw
42017bcf:	b298      	l32i.n	a9, a2, 44
42017bd1:	0020c0        	memw
42017bd4:	022966        	bnei	a9, 2, 42017bda <gptimer_start+0x1a>
42017bd7:	0029c6        	j	42017c82 <gptimer_start+0xc2>
        return ESP_OK;
    }

    gptimer_fsm_t expected_fsm = GPTIMER_FSM_ENABLE;
    if (atomic_compare_exchange_strong(&timer->fsm, &expected_fsm, GPTIMER_FSM_WAIT)) {
42017bda:	1a0c      	movi.n	a10, 1
42017bdc:	03a092        	movi	a9, 3
42017bdf:	130ca0        	wsr.scompare1	a10
42017be2:	00e892        	s32c1i	a9, a8, 0
42017be5:	021926        	beqi	a9, 1, 42017beb <gptimer_start+0x2b>
42017be8:	002706        	j	42017c88 <gptimer_start+0xc8>
        // the register used by the following LL functions are shared with other API,
        // which is possible to run along with this function, so we need to protect
        portENTER_CRITICAL_SAFE(&timer->spinlock);
42017beb:	38c272        	addi	a7, a2, 56
    if (xPortInIsrContext()) {
42017bee:	a20b81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42017bf1:	0008e0        	callx8	a8
42017bf4:	ba8c      	beqz.n	a10, 42017c03 <gptimer_start+0x43>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42017bf6:	fb7c      	movi.n	a11, -1
42017bf8:	07ad      	mov.n	a10, a7
42017bfa:	a20d81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017bfd:	0008e0        	callx8	a8
42017c00:	000246        	j	42017c0d <gptimer_start+0x4d>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42017c03:	fb7c      	movi.n	a11, -1
42017c05:	07ad      	mov.n	a10, a7
42017c07:	a20a81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017c0a:	0008e0        	callx8	a8
        timer_ll_enable_alarm(timer->hal.dev, timer->timer_id, timer->flags.alarm_en);
42017c0d:	9298      	l32i.n	a9, a2, 36
42017c0f:	1288      	l32i.n	a8, a2, 4
42017c11:	1422a2        	l32i	a10, a2, 80
    hw->hw_timer[timer_num].config.tn_alarm_en = en;
42017c14:	b08880        	addx8	a8, a8, a8
42017c17:	a08890        	addx4	a8, a8, a9
42017c1a:	0020c0        	memw
42017c1d:	0898      	l32i.n	a9, a8, 0
42017c1f:	04a2a0        	extui	a10, a10, 2, 1
42017c22:	11aa60        	slli	a10, a10, 10
42017c25:	ffabb2        	movi	a11, 0xfffffbff
42017c28:	1099b0        	and	a9, a9, a11
42017c2b:	2099a0        	or	a9, a9, a10
42017c2e:	0020c0        	memw
42017c31:	0899      	s32i.n	a9, a8, 0
        // Note here, if the alarm target is set very close to the current counter value
        // an alarm interrupt may be triggered very quickly after we start the timer
        timer_ll_enable_counter(timer->hal.dev, timer->timer_id, true);
42017c33:	9298      	l32i.n	a9, a2, 36
42017c35:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].config.tn_en = en;
42017c37:	b08880        	addx8	a8, a8, a8
42017c3a:	a08890        	addx4	a8, a8, a9
42017c3d:	0020c0        	memw
42017c40:	0898      	l32i.n	a9, a8, 0
42017c42:	a308a1        	l32r	a10, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
42017c45:	2099a0        	or	a9, a9, a10
42017c48:	0020c0        	memw
42017c4b:	0899      	s32i.n	a9, a8, 0
        atomic_store(&timer->fsm, GPTIMER_FSM_RUN);
42017c4d:	0020c0        	memw
42017c50:	280c      	movi.n	a8, 2
42017c52:	0020c0        	memw
42017c55:	b289      	s32i.n	a8, a2, 44
42017c57:	0020c0        	memw
    if (xPortInIsrContext()) {
42017c5a:	a1f081        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42017c5d:	0008e0        	callx8	a8
42017c60:	0a2d      	mov.n	a2, a10
42017c62:	ba8c      	beqz.n	a10, 42017c71 <gptimer_start+0xb1>
        portEXIT_CRITICAL_ISR(mux);
42017c64:	07ad      	mov.n	a10, a7
42017c66:	a1f381        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42017c69:	0008e0        	callx8	a8
    } else {
        // return error if the timer is not in the expected state
        return ESP_ERR_INVALID_STATE;
    }

    return ESP_OK;
42017c6c:	020c      	movi.n	a2, 0
42017c6e:	000646        	j	42017c8b <gptimer_start+0xcb>
        portEXIT_CRITICAL(mux);
42017c71:	07ad      	mov.n	a10, a7
42017c73:	a1f081        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42017c76:	0008e0        	callx8	a8
42017c79:	000386        	j	42017c8b <gptimer_start+0xcb>
        return ESP_ERR_INVALID_ARG;
42017c7c:	02a122        	movi	a2, 0x102
42017c7f:	000206        	j	42017c8b <gptimer_start+0xcb>
        return ESP_OK;
42017c82:	020c      	movi.n	a2, 0
42017c84:	0000c6        	j	42017c8b <gptimer_start+0xcb>
42017c87:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_STATE;
42017c8a:	03          	.byte	0x3
}
42017c8b:	f01d      	retw.n
42017c8d:	000000        	ill

42017c90 <gptimer_stop>:

esp_err_t gptimer_stop(gptimer_handle_t timer)
{
42017c90:	004136        	entry	a1, 32
    if (timer == NULL) {
42017c93:	0a9216        	beqz	a2, 42017d40 <gptimer_stop+0xb0>
        // not printing error message here because the return value already indicates the error well
        return ESP_ERR_INVALID_ARG;
    }

    // if the timer is not started, do nothing
    if (atomic_load(&timer->fsm) == GPTIMER_FSM_ENABLE) {
42017c96:	2cc282        	addi	a8, a2, 44
42017c99:	0020c0        	memw
42017c9c:	0020c0        	memw
42017c9f:	b298      	l32i.n	a9, a2, 44
42017ca1:	0020c0        	memw
42017ca4:	021966        	bnei	a9, 1, 42017caa <gptimer_stop+0x1a>
42017ca7:	0026c6        	j	42017d46 <gptimer_stop+0xb6>
        return ESP_OK;
    }

    gptimer_fsm_t expected_fsm = GPTIMER_FSM_RUN;
    if (atomic_compare_exchange_strong(&timer->fsm, &expected_fsm, GPTIMER_FSM_WAIT)) {
42017caa:	2a0c      	movi.n	a10, 2
42017cac:	03a092        	movi	a9, 3
42017caf:	130ca0        	wsr.scompare1	a10
42017cb2:	00e892        	s32c1i	a9, a8, 0
42017cb5:	022926        	beqi	a9, 2, 42017cbb <gptimer_stop+0x2b>
42017cb8:	002406        	j	42017d4c <gptimer_stop+0xbc>
        // disable counter, alarm, auto-reload
        portENTER_CRITICAL_SAFE(&timer->spinlock);
42017cbb:	38c272        	addi	a7, a2, 56
    if (xPortInIsrContext()) {
42017cbe:	a1d781        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42017cc1:	0008e0        	callx8	a8
42017cc4:	ca8c      	beqz.n	a10, 42017cd4 <gptimer_stop+0x44>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42017cc6:	fb7c      	movi.n	a11, -1
42017cc8:	07ad      	mov.n	a10, a7
42017cca:	a1d981        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017ccd:	0008e0        	callx8	a8
42017cd0:	000286        	j	42017cde <gptimer_stop+0x4e>
42017cd3:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42017cd4:	fb7c      	movi.n	a11, -1
42017cd6:	07ad      	mov.n	a10, a7
42017cd8:	a1d681        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42017cdb:	0008e0        	callx8	a8
        timer_ll_enable_counter(timer->hal.dev, timer->timer_id, false);
42017cde:	9298      	l32i.n	a9, a2, 36
42017ce0:	1288      	l32i.n	a8, a2, 4
42017ce2:	b08880        	addx8	a8, a8, a8
42017ce5:	a08890        	addx4	a8, a8, a9
42017ce8:	0020c0        	memw
42017ceb:	0898      	l32i.n	a9, a8, 0
42017ced:	999a      	add.n	a9, a9, a9
42017cef:	419190        	srli	a9, a9, 1
42017cf2:	0020c0        	memw
42017cf5:	0899      	s32i.n	a9, a8, 0
        timer_ll_enable_alarm(timer->hal.dev, timer->timer_id, false);
42017cf7:	9298      	l32i.n	a9, a2, 36
42017cf9:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].config.tn_alarm_en = en;
42017cfb:	b08880        	addx8	a8, a8, a8
42017cfe:	a08890        	addx4	a8, a8, a9
42017d01:	0020c0        	memw
42017d04:	0898      	l32i.n	a9, a8, 0
42017d06:	ffaba2        	movi	a10, 0xfffffbff
42017d09:	1099a0        	and	a9, a9, a10
42017d0c:	0020c0        	memw
42017d0f:	0899      	s32i.n	a9, a8, 0
        atomic_store(&timer->fsm, GPTIMER_FSM_ENABLE);
42017d11:	0020c0        	memw
42017d14:	180c      	movi.n	a8, 1
42017d16:	0020c0        	memw
42017d19:	b289      	s32i.n	a8, a2, 44
42017d1b:	0020c0        	memw
    if (xPortInIsrContext()) {
42017d1e:	a1bf81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42017d21:	0008e0        	callx8	a8
42017d24:	0a2d      	mov.n	a2, a10
42017d26:	ba8c      	beqz.n	a10, 42017d35 <gptimer_stop+0xa5>
        portEXIT_CRITICAL_ISR(mux);
42017d28:	07ad      	mov.n	a10, a7
42017d2a:	a1c281        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42017d2d:	0008e0        	callx8	a8
    } else {
        // return error if the timer is not in the expected state
        return ESP_ERR_INVALID_STATE;
    }

    return ESP_OK;
42017d30:	020c      	movi.n	a2, 0
42017d32:	000646        	j	42017d4f <gptimer_stop+0xbf>
        portEXIT_CRITICAL(mux);
42017d35:	07ad      	mov.n	a10, a7
42017d37:	a1bf81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42017d3a:	0008e0        	callx8	a8
42017d3d:	000386        	j	42017d4f <gptimer_stop+0xbf>
        return ESP_ERR_INVALID_ARG;
42017d40:	02a122        	movi	a2, 0x102
42017d43:	000206        	j	42017d4f <gptimer_stop+0xbf>
        return ESP_OK;
42017d46:	020c      	movi.n	a2, 0
42017d48:	0000c6        	j	42017d4f <gptimer_stop+0xbf>
42017d4b:	a12200        	sll	a2, a2
        return ESP_ERR_INVALID_STATE;
42017d4e:	03          	.byte	0x3
}
42017d4f:	f01d      	retw.n
42017d51:	000000        	ill

42017d54 <esp_cpu_set_breakpoint>:
{
42017d54:	004136        	entry	a1, 32
    if (bp_num == 1) {
42017d57:	051266        	bnei	a2, 1, 42017d60 <esp_cpu_set_breakpoint+0xc>
        WSR(IBREAKA_1, bp_addr);
42017d5a:	138130        	wsr.ibreaka1	a3
42017d5d:	000086        	j	42017d63 <esp_cpu_set_breakpoint+0xf>
        WSR(IBREAKA_0, bp_addr);
42017d60:	138030        	wsr.ibreaka0	a3
    RSR(IBREAKENABLE, brk_ena_reg);
42017d63:	036080        	rsr.ibreakenable	a8
    brk_ena_reg |= BIT(bp_num);
42017d66:	190c      	movi.n	a9, 1
42017d68:	401200        	ssl	a2
42017d6b:	a19900        	sll	a9, a9
42017d6e:	208890        	or	a8, a8, a9
    WSR(IBREAKENABLE, brk_ena_reg);
42017d71:	136080        	wsr.ibreakenable	a8
}
42017d74:	020c      	movi.n	a2, 0
42017d76:	f01d      	retw.n

42017d78 <periph_ll_get_clk_en_mask>:
#include "soc/syscon_reg.h"
#include "soc/dport_access.h"
#include "soc/soc_caps.h"

static inline uint32_t periph_ll_get_clk_en_mask(periph_module_t periph)
{
42017d78:	004136        	entry	a1, 32
    switch (periph) {
42017d7b:	581c      	movi.n	a8, 21
42017d7d:	029287        	bne	a2, a8, 42017d83 <periph_ll_get_clk_en_mask+0xb>
42017d80:	006506        	j	42017f18 <periph_ll_get_clk_en_mask+0x1a0>
42017d83:	02b827        	bgeu	a8, a2, 42017d89 <periph_ll_get_clk_en_mask+0x11>
42017d86:	003106        	j	42017e4e <periph_ll_get_clk_en_mask+0xd6>
42017d89:	980c      	movi.n	a8, 9
42017d8b:	029287        	bne	a2, a8, 42017d91 <periph_ll_get_clk_en_mask+0x19>
42017d8e:	0062c6        	j	42017f1d <periph_ll_get_clk_en_mask+0x1a5>
42017d91:	533827        	bltu	a8, a2, 42017de8 <periph_ll_get_clk_en_mask+0x70>
42017d94:	024266        	bnei	a2, 4, 42017d9a <periph_ll_get_clk_en_mask+0x22>
42017d97:	006246        	j	42017f24 <periph_ll_get_clk_en_mask+0x1ac>
42017d9a:	2252f6        	bgeui	a2, 5, 42017dc0 <periph_ll_get_clk_en_mask+0x48>
42017d9d:	022266        	bnei	a2, 2, 42017da3 <periph_ll_get_clk_en_mask+0x2b>
42017da0:	006186        	j	42017f2a <periph_ll_get_clk_en_mask+0x1b2>
42017da3:	0d32f6        	bgeui	a2, 3, 42017db4 <periph_ll_get_clk_en_mask+0x3c>
42017da6:	186216        	beqz	a2, 42017f30 <periph_ll_get_clk_en_mask+0x1b8>
42017da9:	021226        	beqi	a2, 1, 42017daf <periph_ll_get_clk_en_mask+0x37>
42017dac:	006186        	j	42017f36 <periph_ll_get_clk_en_mask+0x1be>
    case PERIPH_RMT_MODULE:
        return SYSTEM_RMT_CLK_EN;
    case PERIPH_LEDC_MODULE:
        return SYSTEM_LEDC_CLK_EN;
    case PERIPH_UART0_MODULE:
        return SYSTEM_UART_CLK_EN;
42017daf:	420c      	movi.n	a2, 4
42017db1:	0090c6        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017db4:	023226        	beqi	a2, 3, 42017dba <periph_ll_get_clk_en_mask+0x42>
42017db7:	006046        	j	42017f3c <periph_ll_get_clk_en_mask+0x1c4>
    case PERIPH_UART1_MODULE:
        return SYSTEM_UART1_CLK_EN;
    case PERIPH_UART2_MODULE:
        return SYSTEM_UART2_CLK_EN;
42017dba:	00a222        	movi	a2, 0x200
42017dbd:	008dc6        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017dc0:	027266        	bnei	a2, 7, 42017dc6 <periph_ll_get_clk_en_mask+0x4e>
42017dc3:	005e86        	j	42017f41 <periph_ll_get_clk_en_mask+0x1c9>
42017dc6:	1282f6        	bgeui	a2, 8, 42017ddc <periph_ll_get_clk_en_mask+0x64>
42017dc9:	025266        	bnei	a2, 5, 42017dcf <periph_ll_get_clk_en_mask+0x57>
42017dcc:	005e06        	j	42017f48 <periph_ll_get_clk_en_mask+0x1d0>
42017dcf:	026226        	beqi	a2, 6, 42017dd5 <periph_ll_get_clk_en_mask+0x5d>
42017dd2:	005e06        	j	42017f4e <periph_ll_get_clk_en_mask+0x1d6>
    case PERIPH_USB_MODULE:
        return SYSTEM_USB_CLK_EN;
    case PERIPH_I2C0_MODULE:
        return SYSTEM_I2C_EXT0_CLK_EN;
    case PERIPH_I2C1_MODULE:
        return SYSTEM_I2C_EXT1_CLK_EN;
42017dd5:	a49721        	l32r	a2, 42001034 <_stext+0x1014> (40000 <UserFrameTotalSize+0x3ff00>)
42017dd8:	008706        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017ddb:	822600        	mull	a2, a6, a0
    switch (periph) {
42017dde:	5c4602        	s8i	a0, a6, 92
42017de1:	952100        	extui	a2, a0, 17, 10
    case PERIPH_I2S0_MODULE:
        return SYSTEM_I2S0_CLK_EN;
    case PERIPH_I2S1_MODULE:
        return SYSTEM_I2S1_CLK_EN;
42017de4:	83c6a4        	ee.vld.128.ip	q1, a10, 0x460
42017de7:	b26600        	mulsh	a6, a6, a0
    switch (periph) {
42017dea:	02          	.byte	0x2
42017deb:	005a86        	j	42017f59 <periph_ll_get_clk_en_mask+0x1e1>
42017dee:	081c      	movi.n	a8, 16
42017df0:	2c3827        	bltu	a8, a2, 42017e20 <periph_ll_get_clk_en_mask+0xa8>
42017df3:	02a266        	bnei	a2, 12, 42017df9 <periph_ll_get_clk_en_mask+0x81>
42017df6:	005986        	j	42017f60 <periph_ll_get_clk_en_mask+0x1e8>
42017df9:	c80c      	movi.n	a8, 12
42017dfb:	133827        	bltu	a8, a2, 42017e12 <periph_ll_get_clk_en_mask+0x9a>
42017dfe:	029266        	bnei	a2, 10, 42017e04 <periph_ll_get_clk_en_mask+0x8c>
42017e01:	0058c6        	j	42017f68 <periph_ll_get_clk_en_mask+0x1f0>
42017e04:	b80c      	movi.n	a8, 11
42017e06:	021287        	beq	a2, a8, 42017e0c <periph_ll_get_clk_en_mask+0x94>
42017e09:	005846        	j	42017f6e <periph_ll_get_clk_en_mask+0x1f6>
    case PERIPH_LCD_CAM_MODULE:
        return SYSTEM_LCD_CAM_CLK_EN;
    case PERIPH_TIMG0_MODULE:
        return SYSTEM_TIMERGROUP_CLK_EN;
    case PERIPH_TIMG1_MODULE:
        return SYSTEM_TIMERGROUP1_CLK_EN;
42017e0c:	a11321        	l32r	a2, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
42017e0f:	007946        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017e12:	d80c      	movi.n	a8, 13
42017e14:	021287        	beq	a2, a8, 42017e1a <periph_ll_get_clk_en_mask+0xa2>
42017e17:	005646        	j	42017f74 <periph_ll_get_clk_en_mask+0x1fc>
    case PERIPH_PWM0_MODULE:
        return SYSTEM_PWM0_CLK_EN;
    case PERIPH_PWM1_MODULE:
        return SYSTEM_PWM1_CLK_EN;
42017e1a:	a48921        	l32r	a2, 42001040 <_stext+0x1020> (100000 <UserFrameTotalSize+0xfff00>)
42017e1d:	0075c6        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017e20:	381c      	movi.n	a8, 19
42017e22:	029287        	bne	a2, a8, 42017e28 <periph_ll_get_clk_en_mask+0xb0>
42017e25:	005406        	j	42017f79 <periph_ll_get_clk_en_mask+0x201>
42017e28:	153827        	bltu	a8, a2, 42017e41 <periph_ll_get_clk_en_mask+0xc9>
42017e2b:	181c      	movi.n	a8, 17
42017e2d:	029287        	bne	a2, a8, 42017e33 <periph_ll_get_clk_en_mask+0xbb>
42017e30:	005306        	j	42017f80 <periph_ll_get_clk_en_mask+0x208>
42017e33:	281c      	movi.n	a8, 18
42017e35:	021287        	beq	a2, a8, 42017e3b <periph_ll_get_clk_en_mask+0xc3>
42017e38:	005286        	j	42017f86 <periph_ll_get_clk_en_mask+0x20e>
        return SYSTEM_RMT_CLK_EN;
42017e3b:	00a222        	movi	a2, 0x200
42017e3e:	006d86        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017e41:	481c      	movi.n	a8, 20
42017e43:	021287        	beq	a2, a8, 42017e49 <periph_ll_get_clk_en_mask+0xd1>
42017e46:	005086        	j	42017f8c <periph_ll_get_clk_en_mask+0x214>
    case PERIPH_UHCI1_MODULE:
        return SYSTEM_UHCI1_CLK_EN;
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_CLK_EN;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_CLK_EN;
42017e49:	220c      	movi.n	a2, 2
42017e4b:	006a46        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017e4e:	f81c      	movi.n	a8, 31
42017e50:	029287        	bne	a2, a8, 42017e56 <periph_ll_get_clk_en_mask+0xde>
42017e53:	004e86        	j	42017f91 <periph_ll_get_clk_en_mask+0x219>
42017e56:	6a3827        	bltu	a8, a2, 42017ec4 <periph_ll_get_clk_en_mask+0x14c>
42017e59:	a81c      	movi.n	a8, 26
42017e5b:	029287        	bne	a2, a8, 42017e61 <periph_ll_get_clk_en_mask+0xe9>
42017e5e:	004d06        	j	42017f96 <periph_ll_get_clk_en_mask+0x21e>
42017e61:	2f3827        	bltu	a8, a2, 42017e94 <periph_ll_get_clk_en_mask+0x11c>
42017e64:	881c      	movi.n	a8, 24
42017e66:	029287        	bne	a2, a8, 42017e6c <periph_ll_get_clk_en_mask+0xf4>
42017e69:	004bc6        	j	42017f9c <periph_ll_get_clk_en_mask+0x224>
42017e6c:	153827        	bltu	a8, a2, 42017e85 <periph_ll_get_clk_en_mask+0x10d>
42017e6f:	681c      	movi.n	a8, 22
42017e71:	029287        	bne	a2, a8, 42017e77 <periph_ll_get_clk_en_mask+0xff>
42017e74:	004b06        	j	42017fa4 <periph_ll_get_clk_en_mask+0x22c>
42017e77:	781c      	movi.n	a8, 23
42017e79:	021287        	beq	a2, a8, 42017e7f <periph_ll_get_clk_en_mask+0x107>
42017e7c:	004a86        	j	42017faa <periph_ll_get_clk_en_mask+0x232>
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_CLK_EN;
    case PERIPH_SPI3_MODULE:
        return SYSTEM_SPI3_CLK_EN;
    case PERIPH_SDMMC_MODULE:
        return SYSTEM_SDIO_HOST_CLK_EN;
42017e7f:	80a022        	movi	a2, 128
42017e82:	005c86        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017e85:	981c      	movi.n	a8, 25
42017e87:	021287        	beq	a2, a8, 42017e8d <periph_ll_get_clk_en_mask+0x115>
42017e8a:	004886        	j	42017fb0 <periph_ll_get_clk_en_mask+0x238>
    case PERIPH_TWAI_MODULE:
        return SYSTEM_TWAI_CLK_EN;
    case PERIPH_RNG_MODULE:
        return SYSTEM_WIFI_CLK_RNG_EN;
42017e8d:	a0f221        	l32r	a2, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
42017e90:	005906        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017e93:	00          	.byte	00
    switch (periph) {
42017e94:	d81c      	movi.n	a8, 29
42017e96:	029287        	bne	a2, a8, 42017e9c <periph_ll_get_clk_en_mask+0x124>
42017e99:	004606        	j	42017fb5 <periph_ll_get_clk_en_mask+0x23d>
42017e9c:	153827        	bltu	a8, a2, 42017eb5 <periph_ll_get_clk_en_mask+0x13d>
42017e9f:	b81c      	movi.n	a8, 27
42017ea1:	029287        	bne	a2, a8, 42017ea7 <periph_ll_get_clk_en_mask+0x12f>
42017ea4:	004506        	j	42017fbc <periph_ll_get_clk_en_mask+0x244>
42017ea7:	c81c      	movi.n	a8, 28
42017ea9:	021287        	beq	a2, a8, 42017eaf <periph_ll_get_clk_en_mask+0x137>
42017eac:	004446        	j	42017fc1 <periph_ll_get_clk_en_mask+0x249>
    case PERIPH_WIFI_MODULE:
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
    case PERIPH_BT_MODULE:
        return SYSTEM_WIFI_CLK_BT_EN_M;
    case PERIPH_WIFI_BT_COMMON_MODULE:
        return SYSTEM_WIFI_CLK_WIFI_BT_COMMON_M;
42017eaf:	a46721        	l32r	a2, 4200104c <_stext+0x102c> (78078f <UserFrameTotalSize+0x78068f>)
42017eb2:	005086        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017eb5:	e81c      	movi.n	a8, 30
42017eb7:	021287        	beq	a2, a8, 42017ebd <periph_ll_get_clk_en_mask+0x145>
42017eba:	004206        	j	42017fc6 <periph_ll_get_clk_en_mask+0x24e>
    case PERIPH_BT_BASEBAND_MODULE:
        return SYSTEM_BT_BASEBAND_EN;
    case PERIPH_BT_LC_MODULE:
        return SYSTEM_BT_LC_EN;
42017ebd:	a46421        	l32r	a2, 42001050 <_stext+0x1030> (30000 <UserFrameTotalSize+0x2ff00>)
42017ec0:	004d06        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017ec3:	482c00        	ssx	f2, a12, a0
    switch (periph) {
42017ec6:	029287        	bne	a2, a8, 42017ecc <periph_ll_get_clk_en_mask+0x154>
42017ec9:	003fc6        	j	42017fcc <periph_ll_get_clk_en_mask+0x254>
42017ecc:	2a3827        	bltu	a8, a2, 42017efa <periph_ll_get_clk_en_mask+0x182>
42017ecf:	282c      	movi.n	a8, 34
42017ed1:	029287        	bne	a2, a8, 42017ed7 <periph_ll_get_clk_en_mask+0x15f>
42017ed4:	003e86        	j	42017fd2 <periph_ll_get_clk_en_mask+0x25a>
42017ed7:	123827        	bltu	a8, a2, 42017eed <periph_ll_get_clk_en_mask+0x175>
42017eda:	02c266        	bnei	a2, 32, 42017ee0 <periph_ll_get_clk_en_mask+0x168>
42017edd:	003dc6        	j	42017fd8 <periph_ll_get_clk_en_mask+0x260>
42017ee0:	182c      	movi.n	a8, 33
42017ee2:	021287        	beq	a2, a8, 42017ee8 <periph_ll_get_clk_en_mask+0x170>
42017ee5:	003d06        	j	42017fdd <periph_ll_get_clk_en_mask+0x265>
    case PERIPH_SHA_MODULE:
        return SYSTEM_CRYPTO_SHA_CLK_EN;
    case PERIPH_RSA_MODULE:
        return SYSTEM_CRYPTO_RSA_CLK_EN;
    case PERIPH_HMAC_MODULE:
        return SYSTEM_CRYPTO_HMAC_CLK_EN;
42017ee8:	022c      	movi.n	a2, 32
42017eea:	004286        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017eed:	382c      	movi.n	a8, 35
42017eef:	021287        	beq	a2, a8, 42017ef5 <periph_ll_get_clk_en_mask+0x17d>
42017ef2:	003b06        	j	42017fe2 <periph_ll_get_clk_en_mask+0x26a>
        return SYSTEM_CRYPTO_RSA_CLK_EN;
42017ef5:	820c      	movi.n	a2, 8
42017ef7:	003f46        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    switch (periph) {
42017efa:	682c      	movi.n	a8, 38
42017efc:	029287        	bne	a2, a8, 42017f02 <periph_ll_get_clk_en_mask+0x18a>
42017eff:	003946        	j	42017fe8 <periph_ll_get_clk_en_mask+0x270>
42017f02:	782c      	movi.n	a8, 39
42017f04:	029287        	bne	a2, a8, 42017f0a <periph_ll_get_clk_en_mask+0x192>
42017f07:	003946        	j	42017ff0 <periph_ll_get_clk_en_mask+0x278>
42017f0a:	582c      	movi.n	a8, 37
42017f0c:	021287        	beq	a2, a8, 42017f12 <periph_ll_get_clk_en_mask+0x19a>
42017f0f:	0038c6        	j	42017ff6 <periph_ll_get_clk_en_mask+0x27e>
        return SYSTEM_DMA_CLK_EN;
42017f12:	024c      	movi.n	a2, 64
42017f14:	003806        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f17:	024c00        	andb	b4, b12, b0
        return SYSTEM_SPI2_CLK_EN;
42017f1a:	003686        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_LCD_CAM_CLK_EN;
42017f1d:	00a122        	movi	a2, 0x100
42017f20:	003506        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f23:	432100        	min	a2, a1, a0
        return SYSTEM_USB_CLK_EN;
42017f26:	a4          	.byte	0xa4
42017f27:	003346        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_UART1_CLK_EN;
42017f2a:	022c      	movi.n	a2, 32
42017f2c:	003206        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f2f:	00          	.byte	00
        return SYSTEM_LEDC_CLK_EN;
42017f30:	a19e21        	l32r	a2, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
42017f33:	003046        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_CLK_EN;
    default:
        return 0;
42017f36:	020c      	movi.n	a2, 0
42017f38:	002f06        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f3b:	020c00        	andb	b0, b12, b0
42017f3e:	002d86        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_I2S0_CLK_EN;
42017f41:	021c      	movi.n	a2, 16
42017f43:	002c46        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f46:	220000        	orb	b0, b0, b0
        return SYSTEM_I2C_EXT0_CLK_EN;
42017f49:	4680a0        	ee.ldf.64.xp	f8, f4, a10, a0
42017f4c:	002a      	add.n	a0, a0, a2
        return 0;
42017f4e:	020c      	movi.n	a2, 0
42017f50:	002906        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f53:	020c00        	andb	b0, b12, b0
42017f56:	002786        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_UHCI0_CLK_EN;
42017f59:	00a122        	movi	a2, 0x100
42017f5c:	002606        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f5f:	372100        	ee.stf.64.xp	f2, f3, a0, a1
        return SYSTEM_PWM0_CLK_EN;
42017f62:	a4          	.byte	0xa4
42017f63:	002446        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f66:	210000        	srai	a0, a0, 0
        return SYSTEM_TIMERGROUP_CLK_EN;
42017f69:	0d          	.byte	0xd
42017f6a:	2246a2        	s8i	a10, a6, 34
42017f6d:	020c00        	andb	b0, b12, b0
        return 0;
42017f70:	002106        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f73:	020c00        	andb	b0, b12, b0
42017f76:	001f86        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_PCNT_CLK_EN;
42017f79:	00a422        	movi	a2, 0x400
42017f7c:	001e06        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f7f:	862100        	ee.ldf.64.xp	f2, f8, a0, a1
        return SYSTEM_UHCI1_CLK_EN;
42017f82:	1c46a2        	s8i	a10, a6, 28
42017f85:	020c00        	andb	b0, b12, b0
        return 0;
42017f88:	001b06        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f8b:	020c00        	andb	b0, b12, b0
42017f8e:	001986        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_CRYPTO_AES_CLK_EN;
42017f91:	220c      	movi.n	a2, 2
42017f93:	001846        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
42017f96:	020c      	movi.n	a2, 0
42017f98:	001706        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017f9b:	2b2100        	oeq.s	b2, f1, f0
        return SYSTEM_TWAI_CLK_EN;
42017f9e:	1546a4        	ee.ldqa.u8.128.ip	a10, 0x460
42017fa1:	000000        	ill
        return SYSTEM_SPI3_CLK_EN;
42017fa4:	a42821        	l32r	a2, 42001044 <_stext+0x1024> (10000 <UserFrameTotalSize+0xff00>)
42017fa7:	001346        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42017faa:	020c      	movi.n	a2, 0
42017fac:	001206        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017faf:	020c00        	andb	b0, b12, b0
42017fb2:	001086        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return SYSTEM_BT_BASEBAND_EN;
42017fb5:	a17c21        	l32r	a2, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
42017fb8:	000f06        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017fbb:	020c00        	andb	b0, b12, b0
        return SYSTEM_WIFI_CLK_BT_EN_M;
42017fbe:	000d86        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42017fc1:	020c      	movi.n	a2, 0
42017fc3:	000c46        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017fc6:	020c      	movi.n	a2, 0
42017fc8:	000b06        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017fcb:	642100        	extui	a2, a0, 1, 7
        return SYSTEM_SYSTIMER_CLK_EN;
42017fce:	0946a3        	ssi	f10, a6, 36
42017fd1:	021c00        	andb	b1, b12, b0
        return SYSTEM_CRYPTO_DS_CLK_EN;
42017fd4:	000806        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017fd7:	420c00        	xorb	b0, b12, b0
        return SYSTEM_CRYPTO_SHA_CLK_EN;
42017fda:	000686        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42017fdd:	020c      	movi.n	a2, 0
42017fdf:	000546        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017fe2:	020c      	movi.n	a2, 0
42017fe4:	000406        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
42017fe7:	a02200        	addx4	a2, a2, a0
        return SYSTEM_CLK_EN_DEDICATED_GPIO;
42017fea:	024680        	andb	b4, b6, b8
42017fed:	000000        	ill
    switch (periph) {
42017ff0:	a40f21        	l32r	a2, 4200102c <_stext+0x100c> (10000000 <UserFrameTotalSize+0xfffff00>)
42017ff3:	000046        	j	42017ff8 <periph_ll_get_clk_en_mask+0x280>
        return 0;
42017ff6:	020c      	movi.n	a2, 0
    }
}
42017ff8:	f01d      	retw.n
	...

42017ffc <periph_ll_get_rst_en_mask>:

static inline uint32_t periph_ll_get_rst_en_mask(periph_module_t periph, bool enable)
{
42017ffc:	004136        	entry	a1, 32
    switch (periph) {
42017fff:	381c      	movi.n	a8, 19
42018001:	029287        	bne	a2, a8, 42018007 <periph_ll_get_rst_en_mask+0xb>
42018004:	005846        	j	42018169 <periph_ll_get_rst_en_mask+0x16d>
42018007:	02b827        	bgeu	a8, a2, 4201800d <periph_ll_get_rst_en_mask+0x11>
4201800a:	002886        	j	420180b0 <periph_ll_get_rst_en_mask+0xb4>
4201800d:	028266        	bnei	a2, 8, 42018013 <periph_ll_get_rst_en_mask+0x17>
42018010:	005706        	j	42018170 <periph_ll_get_rst_en_mask+0x174>
42018013:	880c      	movi.n	a8, 8
42018015:	433827        	bltu	a8, a2, 4201805c <periph_ll_get_rst_en_mask+0x60>
42018018:	024266        	bnei	a2, 4, 4201801e <periph_ll_get_rst_en_mask+0x22>
4201801b:	005646        	j	42018178 <periph_ll_get_rst_en_mask+0x17c>
4201801e:	2252f6        	bgeui	a2, 5, 42018044 <periph_ll_get_rst_en_mask+0x48>
42018021:	022266        	bnei	a2, 2, 42018027 <periph_ll_get_rst_en_mask+0x2b>
42018024:	005586        	j	4201817e <periph_ll_get_rst_en_mask+0x182>
42018027:	0d32f6        	bgeui	a2, 3, 42018038 <periph_ll_get_rst_en_mask+0x3c>
4201802a:	156216        	beqz	a2, 42018184 <periph_ll_get_rst_en_mask+0x188>
4201802d:	021226        	beqi	a2, 1, 42018033 <periph_ll_get_rst_en_mask+0x37>
42018030:	005586        	j	4201818a <periph_ll_get_rst_en_mask+0x18e>
    case PERIPH_WIFI_MODULE:
        return SYSTEM_WIFIMAC_RST;
    case PERIPH_BT_MODULE:
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    case PERIPH_UART0_MODULE:
        return SYSTEM_UART_RST;
42018033:	420c      	movi.n	a2, 4
42018035:	007ec6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42018038:	023226        	beqi	a2, 3, 4201803e <periph_ll_get_rst_en_mask+0x42>
4201803b:	005446        	j	42018190 <periph_ll_get_rst_en_mask+0x194>
    case PERIPH_UART1_MODULE:
        return SYSTEM_UART1_RST;
    case PERIPH_UART2_MODULE:
        return SYSTEM_UART2_RST;
4201803e:	00a222        	movi	a2, 0x200
42018041:	007bc6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42018044:	026266        	bnei	a2, 6, 4201804a <periph_ll_get_rst_en_mask+0x4e>
42018047:	005286        	j	42018195 <periph_ll_get_rst_en_mask+0x199>
4201804a:	027266        	bnei	a2, 7, 42018050 <periph_ll_get_rst_en_mask+0x54>
4201804d:	0052c6        	j	4201819c <periph_ll_get_rst_en_mask+0x1a0>
42018050:	025226        	beqi	a2, 5, 42018056 <periph_ll_get_rst_en_mask+0x5a>
42018053:	005286        	j	420181a1 <periph_ll_get_rst_en_mask+0x1a5>
    case PERIPH_USB_MODULE:
        return SYSTEM_USB_RST;
    case PERIPH_I2C0_MODULE:
        return SYSTEM_I2C_EXT0_RST;
42018056:	80a022        	movi	a2, 128
42018059:	0075c6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
4201805c:	d80c      	movi.n	a8, 13
4201805e:	029287        	bne	a2, a8, 42018064 <periph_ll_get_rst_en_mask+0x68>
42018061:	005046        	j	420181a6 <periph_ll_get_rst_en_mask+0x1aa>
42018064:	2c3827        	bltu	a8, a2, 42018094 <periph_ll_get_rst_en_mask+0x98>
42018067:	b80c      	movi.n	a8, 11
42018069:	029287        	bne	a2, a8, 4201806f <periph_ll_get_rst_en_mask+0x73>
4201806c:	004f06        	j	420181ac <periph_ll_get_rst_en_mask+0x1b0>
4201806f:	153827        	bltu	a8, a2, 42018088 <periph_ll_get_rst_en_mask+0x8c>
42018072:	980c      	movi.n	a8, 9
42018074:	029287        	bne	a2, a8, 4201807a <periph_ll_get_rst_en_mask+0x7e>
42018077:	004e46        	j	420181b4 <periph_ll_get_rst_en_mask+0x1b8>
4201807a:	029226        	beqi	a2, 10, 42018080 <periph_ll_get_rst_en_mask+0x84>
4201807d:	004e46        	j	420181ba <periph_ll_get_rst_en_mask+0x1be>
    case PERIPH_I2S1_MODULE:
        return SYSTEM_I2S1_RST;
    case PERIPH_LCD_CAM_MODULE:
        return SYSTEM_LCD_CAM_RST;
    case PERIPH_TIMG0_MODULE:
        return SYSTEM_TIMERGROUP_RST;
42018080:	a1c721        	l32r	a2, 4200079c <_stext+0x77c> (2000 <UserFrameTotalSize+0x1f00>)
42018083:	006b46        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
42018086:	260000        	ee.ldf.64.xp	f0, f2, a0, a0
    switch (periph) {
42018089:	4602a2        	l8ui	a10, a2, 70
4201808c:	004c      	movi.n	a0, 64
    case PERIPH_TIMG1_MODULE:
        return SYSTEM_TIMERGROUP1_RST;
    case PERIPH_PWM0_MODULE:
        return SYSTEM_PWM0_RST;
4201808e:	a3eb21        	l32r	a2, 4200103c <_stext+0x101c> (20000 <UserFrameTotalSize+0x1ff00>)
42018091:	0067c6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
42018094:	181c      	movi.n	a8, 17
42018096:	029287        	bne	a2, a8, 4201809c <periph_ll_get_rst_en_mask+0xa0>
42018099:	004a06        	j	420181c5 <periph_ll_get_rst_en_mask+0x1c9>
4201809c:	281c      	movi.n	a8, 18
4201809e:	029287        	bne	a2, a8, 420180a4 <periph_ll_get_rst_en_mask+0xa8>
420180a1:	0049c6        	j	420181cc <periph_ll_get_rst_en_mask+0x1d0>
420180a4:	02b226        	beqi	a2, 16, 420180aa <periph_ll_get_rst_en_mask+0xae>
420180a7:	0049c6        	j	420181d2 <periph_ll_get_rst_en_mask+0x1d6>
    case PERIPH_PWM1_MODULE:
        return SYSTEM_PWM1_RST;
    case PERIPH_UHCI0_MODULE:
        return SYSTEM_UHCI0_RST;
420180aa:	00a122        	movi	a2, 0x100
420180ad:	0060c6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
420180b0:	02c266        	bnei	a2, 32, 420180b6 <periph_ll_get_rst_en_mask+0xba>
420180b3:	002886        	j	42018159 <periph_ll_get_rst_en_mask+0x15d>
420180b6:	082c      	movi.n	a8, 32
420180b8:	523827        	bltu	a8, a2, 4201810e <periph_ll_get_rst_en_mask+0x112>
420180bb:	881c      	movi.n	a8, 24
420180bd:	029287        	bne	a2, a8, 420180c3 <periph_ll_get_rst_en_mask+0xc7>
420180c0:	004506        	j	420181d8 <periph_ll_get_rst_en_mask+0x1dc>
420180c3:	2d3827        	bltu	a8, a2, 420180f4 <periph_ll_get_rst_en_mask+0xf8>
420180c6:	681c      	movi.n	a8, 22
420180c8:	029287        	bne	a2, a8, 420180ce <periph_ll_get_rst_en_mask+0xd2>
420180cb:	004446        	j	420181e0 <periph_ll_get_rst_en_mask+0x1e4>
420180ce:	143827        	bltu	a8, a2, 420180e6 <periph_ll_get_rst_en_mask+0xea>
420180d1:	481c      	movi.n	a8, 20
420180d3:	029287        	bne	a2, a8, 420180d9 <periph_ll_get_rst_en_mask+0xdd>
420180d6:	004306        	j	420181e6 <periph_ll_get_rst_en_mask+0x1ea>
420180d9:	581c      	movi.n	a8, 21
420180db:	021287        	beq	a2, a8, 420180e1 <periph_ll_get_rst_en_mask+0xe5>
420180de:	004246        	j	420181eb <periph_ll_get_rst_en_mask+0x1ef>
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_RST;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_RST;
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_RST;
420180e1:	024c      	movi.n	a2, 64
420180e3:	005346        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
420180e6:	781c      	movi.n	a8, 23
420180e8:	021287        	beq	a2, a8, 420180ee <periph_ll_get_rst_en_mask+0xf2>
420180eb:	004046        	j	420181f0 <periph_ll_get_rst_en_mask+0x1f4>
    case PERIPH_SPI3_MODULE:
        return SYSTEM_SPI3_RST;
    case PERIPH_SDMMC_MODULE:
        return SYSTEM_SDIO_HOST_RST;
420180ee:	80a022        	movi	a2, 128
420180f1:	004fc6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
420180f4:	b81c      	movi.n	a8, 27
420180f6:	029287        	bne	a2, a8, 420180fc <periph_ll_get_rst_en_mask+0x100>
420180f9:	003e06        	j	420181f5 <periph_ll_get_rst_en_mask+0x1f9>
420180fc:	f81c      	movi.n	a8, 31
420180fe:	4f1287        	beq	a2, a8, 42018151 <periph_ll_get_rst_en_mask+0x155>
42018101:	a81c      	movi.n	a8, 26
42018103:	021287        	beq	a2, a8, 42018109 <periph_ll_get_rst_en_mask+0x10d>
42018106:	003c86        	j	420181fc <periph_ll_get_rst_en_mask+0x200>
        return SYSTEM_WIFIMAC_RST;
42018109:	420c      	movi.n	a2, 4
4201810b:	004946        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    switch (periph) {
4201810e:	482c      	movi.n	a8, 36
42018110:	029287        	bne	a2, a8, 42018116 <periph_ll_get_rst_en_mask+0x11a>
42018113:	003a86        	j	42018201 <periph_ll_get_rst_en_mask+0x205>
42018116:	1a3827        	bltu	a8, a2, 42018134 <periph_ll_get_rst_en_mask+0x138>
42018119:	282c      	movi.n	a8, 34
4201811b:	029287        	bne	a2, a8, 42018121 <periph_ll_get_rst_en_mask+0x125>
4201811e:	003986        	j	42018208 <periph_ll_get_rst_en_mask+0x20c>
42018121:	382c      	movi.n	a8, 35
42018123:	3a1287        	beq	a2, a8, 42018161 <periph_ll_get_rst_en_mask+0x165>
42018126:	182c      	movi.n	a8, 33
42018128:	021287        	beq	a2, a8, 4201812e <periph_ll_get_rst_en_mask+0x132>
4201812b:	003786        	j	4201820d <periph_ll_get_rst_en_mask+0x211>
    case PERIPH_DEDIC_GPIO_MODULE:
        return SYSTEM_RST_EN_DEDICATED_GPIO;
    case PERIPH_GDMA_MODULE:
        return SYSTEM_DMA_RST;
    case PERIPH_HMAC_MODULE:
        return SYSTEM_CRYPTO_HMAC_RST;
4201812e:	022c      	movi.n	a2, 32
42018130:	004006        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
42018133:	00          	.byte	00
    switch (periph) {
42018134:	682c      	movi.n	a8, 38
42018136:	029287        	bne	a2, a8, 4201813c <periph_ll_get_rst_en_mask+0x140>
42018139:	0035c6        	j	42018214 <periph_ll_get_rst_en_mask+0x218>
4201813c:	782c      	movi.n	a8, 39
4201813e:	029287        	bne	a2, a8, 42018144 <periph_ll_get_rst_en_mask+0x148>
42018141:	0035c6        	j	4201821c <periph_ll_get_rst_en_mask+0x220>
42018144:	582c      	movi.n	a8, 37
42018146:	021287        	beq	a2, a8, 4201814c <periph_ll_get_rst_en_mask+0x150>
42018149:	003546        	j	42018222 <periph_ll_get_rst_en_mask+0x226>
        return SYSTEM_DMA_RST;
4201814c:	024c      	movi.n	a2, 64
4201814e:	003886        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_RST;
    case PERIPH_AES_MODULE:
        if (enable == true) {
42018151:	0d3316        	beqz	a3, 42018228 <periph_ll_get_rst_en_mask+0x22c>
            // Clear reset on digital signature, otherwise AES unit is held in reset also.
            return (SYSTEM_CRYPTO_AES_RST | SYSTEM_CRYPTO_DS_RST);
42018154:	221c      	movi.n	a2, 18
42018156:	003686        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        } else {
            //Don't return other units to reset, as this pulls reset on RSA & SHA units, respectively.
            return SYSTEM_CRYPTO_AES_RST;
        }
    case PERIPH_SHA_MODULE:
        if (enable == true) {
42018159:	0d0316        	beqz	a3, 4201822d <periph_ll_get_rst_en_mask+0x231>
            // Clear reset on digital signature and HMAC, otherwise SHA is held in reset
            return (SYSTEM_CRYPTO_SHA_RST | SYSTEM_CRYPTO_DS_RST | SYSTEM_CRYPTO_HMAC_RST) ;
4201815c:	423c      	movi.n	a2, 52
4201815e:	003486        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        } else {
            // Don't assert reset on secure boot, otherwise AES is held in reset
            return SYSTEM_CRYPTO_SHA_RST;
        }
    case PERIPH_RSA_MODULE:
        if (enable == true) {
42018161:	0cd316        	beqz	a3, 42018232 <periph_ll_get_rst_en_mask+0x236>
            /* also clear reset on digital signature, otherwise RSA is held in reset */
            return (SYSTEM_CRYPTO_RSA_RST | SYSTEM_CRYPTO_DS_RST);
42018164:	821c      	movi.n	a2, 24
42018166:	003286        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_PCNT_RST;
42018169:	00a422        	movi	a2, 0x400
4201816c:	003106        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
4201816f:	b22100        	mulsh	a2, a1, a0
        return SYSTEM_I2S1_RST;
42018172:	2f46a3        	ssi	f10, a6, 188
42018175:	000000        	ill
        return SYSTEM_USB_RST;
42018178:	a3ae21        	l32r	a2, 42001030 <_stext+0x1010> (800000 <UserFrameTotalSize+0x7fff00>)
4201817b:	002d46        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_UART1_RST;
4201817e:	022c      	movi.n	a2, 32
42018180:	002c06        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
42018183:	092100        	l32e	a0, a1, -56
        return SYSTEM_LEDC_RST;
42018186:	2a46a1        	l32r	a10, 41fe2aa0 <_iram_bss_end+0x1c606a0>
42018189:	020c00        	andb	b0, b12, b0
        } else {
            /* don't reset digital signature unit, as this resets AES also */
            return SYSTEM_CRYPTO_RSA_RST;
        }
    default:
        return 0;
4201818c:	002906        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
4201818f:	020c00        	andb	b0, b12, b0
42018192:	002786        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_I2C_EXT1_RST;
42018195:	a3a721        	l32r	a2, 42001034 <_stext+0x1014> (40000 <UserFrameTotalSize+0x3ff00>)
42018198:	002606        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
4201819b:	021c00        	andb	b1, b12, b0
        return SYSTEM_I2S0_RST;
4201819e:	002486        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return 0;
420181a1:	020c      	movi.n	a2, 0
420181a3:	002346        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_PWM1_RST;
420181a6:	a3a621        	l32r	a2, 42001040 <_stext+0x1020> (100000 <UserFrameTotalSize+0xfff00>)
420181a9:	0021c6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_TIMERGROUP1_RST;
420181ac:	a02b21        	l32r	a2, 42000258 <_stext+0x238> (8000 <UserFrameTotalSize+0x7f00>)
420181af:	002046        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181b2:	220000        	orb	b0, b0, b0
        return SYSTEM_LCD_CAM_RST;
420181b5:	4600a1        	l32r	a10, 41fe99b8 <_iram_bss_end+0x1c675b8>
420181b8:	020c001e 	ee.vmulas.s16.accx.ld.ip.qup	q5, a1, 0, q0, q0, q0, q4
        return 0;
420181bc:	001d06        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181bf:	020c00        	andb	b0, b12, b0
420181c2:	001b86        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_UHCI1_RST;
420181c5:	a1f421        	l32r	a2, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
420181c8:	001a06        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181cb:	a22200        	muluh	a2, a2, a0
        return SYSTEM_RMT_RST;
420181ce:	184600        	lsxp	f4, a6, a0
420181d1:	020c00        	andb	b0, b12, b0
        return 0;
420181d4:	001706        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181d7:	00          	.byte	00
        return SYSTEM_TWAI_RST;
420181d8:	a39c21        	l32r	a2, 42001048 <_stext+0x1028> (80000 <UserFrameTotalSize+0x7ff00>)
420181db:	001546        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181de:	210000        	srai	a0, a0, 0
        return SYSTEM_SPI3_RST;
420181e1:	a399      	s32i.n	a9, a3, 40
420181e3:	001346        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_SPI01_RST;
420181e6:	220c      	movi.n	a2, 2
420181e8:	001206        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return 0;
420181eb:	020c      	movi.n	a2, 0
420181ed:	0010c6        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181f0:	020c      	movi.n	a2, 0
420181f2:	000f86        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
420181f5:	a39721        	l32r	a2, 42001054 <_stext+0x1034> (3e08 <UserFrameTotalSize+0x3d08>)
420181f8:	000e06        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
420181fb:	020c00        	andb	b0, b12, b0
        return 0;
420181fe:	000c86        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return SYSTEM_SYSTIMER_RST;
42018201:	a2d621        	l32r	a2, 42000d5c <_stext+0xd3c> (20000000 <UserFrameTotalSize+0x1fffff00>)
42018204:	000b06        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
42018207:	021c00        	andb	b1, b12, b0
        return SYSTEM_CRYPTO_DS_RST;
4201820a:	000986        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
        return 0;
4201820d:	020c      	movi.n	a2, 0
4201820f:	000846        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
42018212:	220000        	orb	b0, b0, b0
        return SYSTEM_RST_EN_DEDICATED_GPIO;
42018215:	4680a0        	ee.ldf.64.xp	f8, f4, a10, a0
42018218:	000006        	j	4201821c <periph_ll_get_rst_en_mask+0x220>
4201821b:	842100        	extui	a2, a0, 1, 9
    switch (periph) {
4201821e:	0446a3        	ssi	f10, a6, 16
42018221:	020c00        	andb	b0, b12, b0
        return 0;
42018224:	000306        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
42018227:	220c00        	orb	b0, b12, b0
            return SYSTEM_CRYPTO_AES_RST;
4201822a:	000186        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
            return SYSTEM_CRYPTO_SHA_RST;
4201822d:	420c      	movi.n	a2, 4
4201822f:	000046        	j	42018234 <periph_ll_get_rst_en_mask+0x238>
            return SYSTEM_CRYPTO_RSA_RST;
42018232:	820c      	movi.n	a2, 8
    }
}
42018234:	f01d      	retw.n
	...

42018238 <periph_ll_get_clk_en_reg>:

static inline uint32_t periph_ll_get_clk_en_reg(periph_module_t periph)
{
42018238:	004136        	entry	a1, 32
    switch (periph) {
4201823b:	2d3226        	beqi	a2, 3, 4201826c <periph_ll_get_clk_en_reg+0x34>
4201823e:	3232b6        	bltui	a2, 3, 42018274 <periph_ll_get_clk_en_reg+0x3c>
42018241:	682c      	movi.n	a8, 38
42018243:	353827        	bltu	a8, a2, 4201827c <periph_ll_get_clk_en_reg+0x44>
42018246:	980c      	movi.n	a8, 9
42018248:	383287        	bltu	a2, a8, 42018284 <periph_ll_get_clk_en_reg+0x4c>
4201824b:	f7c222        	addi	a2, a2, -9
4201824e:	180c      	movi.n	a8, 1
42018250:	401200        	ssl	a2
42018253:	a18800        	sll	a8, a8
42018256:	a38191        	l32r	a9, 4200105c <_stext+0x103c> (17c04001 <UserFrameTotalSize+0x17c03f01>)
42018259:	2f8897        	bany	a8, a9, 4201828c <periph_ll_get_clk_en_reg+0x54>
4201825c:	559080        	extui	a9, a8, 16, 6
4201825f:	19fc      	bnez.n	a9, 42018294 <periph_ll_get_clk_en_reg+0x5c>
42018261:	3778d7        	bbci	a8, 29, 4201829c <periph_ll_get_clk_en_reg+0x64>
42018264:	a37d21        	l32r	a2, 42001058 <_stext+0x1038> (600c0008 <SYSTEM+0x8>)
42018267:	000d06        	j	4201829f <periph_ll_get_clk_en_reg+0x67>
4201826a:	210000        	srai	a0, a0, 0
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_CLK_EN1_REG;
4201826d:	9fd8      	l32i.n	a13, a15, 36
4201826f:	000b06        	j	4201829f <periph_ll_get_clk_en_reg+0x67>
42018272:	210000        	srai	a0, a0, 0
    default:
        return SYSTEM_PERIP_CLK_EN0_REG;
42018275:	069fd5        	call4	4201ec74 <_etext+0x553e>
42018278:	0009      	s32i.n	a0, a0, 0
4201827a:	210000        	srai	a0, a0, 0
4201827d:	d3          	.byte	0xd3
4201827e:	0007069f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a9, 96, q4, q0, q0, q7
42018282:	210000        	srai	a0, a0, 0
42018285:	069fd1        	l32r	a13, 41fd9d04 <_iram_bss_end+0x1c57904>
42018288:	000005        	call0	4201828c <periph_ll_get_clk_en_reg+0x54>
4201828b:	d02100        	subx2	a2, a1, a0
        return SYSTEM_PERIP_CLK_EN1_REG;
4201828e:	0003069f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a9, 96, q4, q0, q0, q3
42018292:	210000        	srai	a0, a0, 0
        return SYSTEM_WIFI_CLK_EN_REG ;
42018295:	01069fcf 	ee.vmulas.s16.accx.ld.ip.qup	q2, a12, 240, q6, q2, q0, q6
42018299:	000000        	ill
        return SYSTEM_PERIP_CLK_EN0_REG;
4201829c:	9fcb21        	l32r	a2, 420001c8 <_stext+0x1a8> (600c0018 <SYSTEM+0x18>)
    }
}
4201829f:	f01d      	retw.n
420182a1:	000000        	ill

420182a4 <periph_ll_get_rst_en_reg>:

static inline uint32_t periph_ll_get_rst_en_reg(periph_module_t periph)
{
420182a4:	004136        	entry	a1, 32
    switch (periph) {
420182a7:	2b3226        	beqi	a2, 3, 420182d6 <periph_ll_get_rst_en_reg+0x32>
420182aa:	2e32b6        	bltui	a2, 3, 420182dc <periph_ll_get_rst_en_reg+0x38>
420182ad:	682c      	movi.n	a8, 38
420182af:	313827        	bltu	a8, a2, 420182e4 <periph_ll_get_rst_en_reg+0x40>
420182b2:	980c      	movi.n	a8, 9
420182b4:	343287        	bltu	a2, a8, 420182ec <periph_ll_get_rst_en_reg+0x48>
420182b7:	f7c222        	addi	a2, a2, -9
420182ba:	180c      	movi.n	a8, 1
420182bc:	401200        	ssl	a2
420182bf:	a18800        	sll	a8, a8
420182c2:	a36691        	l32r	a9, 4200105c <_stext+0x103c> (17c04001 <UserFrameTotalSize+0x17c03f01>)
420182c5:	2b8897        	bany	a8, a9, 420182f4 <periph_ll_get_rst_en_reg+0x50>
420182c8:	559080        	extui	a9, a8, 16, 6
420182cb:	d9ec      	bnez.n	a9, 420182fc <periph_ll_get_rst_en_reg+0x58>
420182cd:	3378d7        	bbci	a8, 29, 42018304 <periph_ll_get_rst_en_reg+0x60>
420182d0:	a36521        	l32r	a2, 42001064 <_stext+0x1044> (600c000c <SYSTEM+0xc>)
420182d3:	000c06        	j	42018307 <periph_ll_get_rst_en_reg+0x63>
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_RST_EN1_REG;
420182d6:	9fc121        	l32r	a2, 420001dc <_stext+0x1bc> (600c0024 <SYSTEM+0x24>)
420182d9:	000a86        	j	42018307 <periph_ll_get_rst_en_reg+0x63>
    default:
        return SYSTEM_PERIP_RST_EN0_REG;
420182dc:	9fbf21        	l32r	a2, 420001d8 <_stext+0x1b8> (600c0020 <SYSTEM+0x20>)
420182df:	000906        	j	42018307 <periph_ll_get_rst_en_reg+0x63>
420182e2:	210000        	srai	a0, a0, 0
420182e5:	bd          	.byte	0xbd
420182e6:	0007069f 	ee.vmulas.s16.accx.ld.ip.qup	q0, a9, 96, q4, q0, q0, q7
420182ea:	210000        	srai	a0, a0, 0
420182ed:	9fbb      	addi.n	a9, a15, 11
420182ef:	000506        	j	42018307 <periph_ll_get_rst_en_reg+0x63>
420182f2:	210000        	srai	a0, a0, 0
        return SYSTEM_PERIP_RST_EN1_REG;
420182f5:	9fba      	add.n	a9, a15, a11
420182f7:	000306        	j	42018307 <periph_ll_get_rst_en_reg+0x63>
420182fa:	210000        	srai	a0, a0, 0
        return SYSTEM_CORE_RST_EN_REG;
420182fd:	a359      	s32i.n	a5, a3, 40
420182ff:	000106        	j	42018307 <periph_ll_get_rst_en_reg+0x63>
42018302:	210000        	srai	a0, a0, 0
        return SYSTEM_PERIP_RST_EN0_REG;
42018305:	1d9fb5        	call12	42035d00 <_etext+0x1c5ca>
    }
}
42018308:	0000f0        	callx12	a0
	...

4201830c <periph_ll_enable_clk_clear_rst>:

static inline void periph_ll_enable_clk_clear_rst(periph_module_t periph)
{
4201830c:	004136        	entry	a1, 32
    DPORT_SET_PERI_REG_MASK(periph_ll_get_clk_en_reg(periph), periph_ll_get_clk_en_mask(periph));
4201830f:	20a220        	or	a10, a2, a2
42018312:	fff265        	call8	42018238 <periph_ll_get_clk_en_reg>
42018315:	0a7d      	mov.n	a7, a10
42018317:	0020c0        	memw
4201831a:	0a68      	l32i.n	a6, a10, 0
4201831c:	20a220        	or	a10, a2, a2
4201831f:	ffa5a5        	call8	42017d78 <periph_ll_get_clk_en_mask>
42018322:	2066a0        	or	a6, a6, a10
42018325:	0020c0        	memw
42018328:	0769      	s32i.n	a6, a7, 0
    DPORT_CLEAR_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, true));
4201832a:	02ad      	mov.n	a10, a2
4201832c:	fff765        	call8	420182a4 <periph_ll_get_rst_en_reg>
4201832f:	0a7d      	mov.n	a7, a10
42018331:	0020c0        	memw
42018334:	0a68      	l32i.n	a6, a10, 0
42018336:	1b0c      	movi.n	a11, 1
42018338:	02ad      	mov.n	a10, a2
4201833a:	ffcc25        	call8	42017ffc <periph_ll_get_rst_en_mask>
4201833d:	108a60        	and	a8, a10, a6
42018340:	308860        	xor	a8, a8, a6
42018343:	0020c0        	memw
42018346:	0789      	s32i.n	a8, a7, 0
}
42018348:	f01d      	retw.n
	...

4201834c <periph_module_enable>:

void periph_module_enable(periph_module_t periph)
{
4201834c:	004136        	entry	a1, 32
#ifdef __PERIPH_CTRL_ALLOW_LEGACY_API
    assert(periph < PERIPH_MODULE_MAX);
4201834f:	882c      	movi.n	a8, 40
42018351:	10b827        	bgeu	a8, a2, 42018365 <periph_module_enable+0x19>
42018354:	a345d1        	l32r	a13, 42001068 <_stext+0x1048> (3c022358 <_flash_rodata_start+0x2238>)
42018357:	a345c1        	l32r	a12, 4200106c <_stext+0x104c> (3c026c24 <__func__$2>)
4201835a:	db3c      	movi.n	a11, 61
4201835c:	a345a1        	l32r	a10, 42001070 <_stext+0x1050> (3c022394 <_flash_rodata_start+0x2274>)
4201835f:	9f6a81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42018362:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
42018365:	a02d81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42018368:	0008e0        	callx8	a8
4201836b:	ea8c      	beqz.n	a10, 4201837d <periph_module_enable+0x31>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4201836d:	fb7c      	movi.n	a11, -1
4201836f:	a341a1        	l32r	a10, 42001074 <_stext+0x1054> (3fc92454 <periph_spinlock>)
42018372:	a02f81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42018375:	0008e0        	callx8	a8
42018378:	000306        	j	42018388 <periph_module_enable+0x3c>
4201837b:	00          	.byte	00
4201837c:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
4201837d:	fb7c      	movi.n	a11, -1
4201837f:	a33da1        	l32r	a10, 42001074 <_stext+0x1054> (3fc92454 <periph_spinlock>)
42018382:	a02b81        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42018385:	0008e0        	callx8	a8
    portENTER_CRITICAL_SAFE(&periph_spinlock);
    if (ref_counts[periph] == 0) {
42018388:	a33c81        	l32r	a8, 42001078 <_stext+0x1058> (3fc94f54 <ref_counts>)
4201838b:	882a      	add.n	a8, a8, a2
4201838d:	000882        	l8ui	a8, a8, 0
42018390:	005856        	bnez	a8, 42018399 <periph_module_enable+0x4d>
        periph_ll_enable_clk_clear_rst(periph);
42018393:	20a220        	or	a10, a2, a2
42018396:	fff765        	call8	4201830c <periph_ll_enable_clk_clear_rst>
    }
    ref_counts[periph]++;
42018399:	a33781        	l32r	a8, 42001078 <_stext+0x1058> (3fc94f54 <ref_counts>)
4201839c:	882a      	add.n	a8, a8, a2
4201839e:	000892        	l8ui	a9, a8, 0
420183a1:	01c992        	addi	a9, a9, 1
420183a4:	004892        	s8i	a9, a8, 0
    if (xPortInIsrContext()) {
420183a7:	a01d81        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
420183aa:	0008e0        	callx8	a8
420183ad:	ba8c      	beqz.n	a10, 420183bc <periph_module_enable+0x70>
        portEXIT_CRITICAL_ISR(mux);
420183af:	a331a1        	l32r	a10, 42001074 <_stext+0x1054> (3fc92454 <periph_spinlock>)
420183b2:	a02081        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
420183b5:	0008e0        	callx8	a8
420183b8:	000246        	j	420183c5 <periph_module_enable+0x79>
420183bb:	00          	.byte	00
        portEXIT_CRITICAL(mux);
420183bc:	a32ea1        	l32r	a10, 42001074 <_stext+0x1054> (3fc92454 <periph_spinlock>)
420183bf:	a01d81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
420183c2:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
#endif
}
420183c5:	f01d      	retw.n
	...

420183c8 <set_ocode_by_efuse>:
    val |= RTC_CNTL_SDIO_PD_EN;
    REG_WRITE(RTC_CNTL_SDIO_CONF_REG, val);
}

static void set_ocode_by_efuse(int calib_version)
{
420183c8:	004136        	entry	a1, 32
    assert(calib_version == 1);
420183cb:	111226        	beqi	a2, 1, 420183e0 <set_ocode_by_efuse+0x18>
420183ce:	a32bd1        	l32r	a13, 4200107c <_stext+0x105c> (3c022440 <_flash_rodata_start+0x2320>)
420183d1:	a32bc1        	l32r	a12, 42001080 <_stext+0x1060> (3c026ca0 <__func__$3>)
420183d4:	fca0b2        	movi	a11, 252
420183d7:	a32ba1        	l32r	a10, 42001084 <_stext+0x1064> (3c022481 <_flash_rodata_start+0x2361>)
420183da:	9f4b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420183dd:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_ocode(void)
{
    // EFUSE_BLK2,  141,    8,     ADC OCode
    return EFUSE.rd_sys_part1_data4.ocode;
420183e0:	a32a81        	l32r	a8, 42001088 <_stext+0x1068> (60007000 <EFUSE>)
420183e3:	0020c0        	memw
420183e6:	1b28f2        	l32i	a15, a8, 108
    // use efuse ocode.
    uint32_t ocode = efuse_ll_get_ocode();
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_EXT_CODE, ocode);
420183e9:	74fdf0        	extui	a15, a15, 13, 8
420183ec:	0e0c      	movi.n	a14, 0
420183ee:	7d0c      	movi.n	a13, 7
420183f0:	6c0c      	movi.n	a12, 6
420183f2:	1b0c      	movi.n	a11, 1
420183f4:	61a0a2        	movi	a10, 97
420183f7:	a25681        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
420183fa:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_FORCE_CODE, 1);
420183fd:	1f0c      	movi.n	a15, 1
420183ff:	6e0c      	movi.n	a14, 6
42018401:	0edd      	mov.n	a13, a14
42018403:	5c0c      	movi.n	a12, 5
42018405:	0fbd      	mov.n	a11, a15
42018407:	61a0a2        	movi	a10, 97
4201840a:	a25181        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
4201840d:	0008e0        	callx8	a8
}
42018410:	f01d      	retw.n
	...

42018414 <get_dig1v3_dbias_by_efuse>:
    }
    return rtc_dbias;
}

static uint32_t get_dig1v3_dbias_by_efuse(uint8_t pvt_scheme_ver)
{
42018414:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
42018417:	111226        	beqi	a2, 1, 4201842c <get_dig1v3_dbias_by_efuse+0x18>
4201841a:	a31cd1        	l32r	a13, 4200108c <_stext+0x106c> (3c02248c <_flash_rodata_start+0x236c>)
4201841d:	a31cc1        	l32r	a12, 42001090 <_stext+0x1070> (3c026c84 <__func__$2>)
42018420:	6ca1b2        	movi	a11, 0x16c
42018423:	a318a1        	l32r	a10, 42001084 <_stext+0x1064> (3c022481 <_flash_rodata_start+0x2361>)
42018426:	9f3881        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42018429:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_k_dig_ldo(void)
{
    // EFUSE_BLK1,  148,    7,     BLOCK1 K_DIG_LDO
    return EFUSE.rd_mac_spi_sys_4.k_dig_ldo;
4201842c:	a31781        	l32r	a8, 42001088 <_stext+0x1068> (60007000 <EFUSE>)
4201842f:	0020c0        	memw
42018432:	1528a2        	l32i	a10, a8, 84
42018435:	65a4a0        	extui	a10, a10, 20, 7
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_v_dig_dbias20(void)
{
    // EFUSE_BLK1,  163,    8,     BLOCK1 voltage of digital dbias20
    return EFUSE.rd_mac_spi_sys_5.v_dig_dbias20;
42018438:	0020c0        	memw
4201843b:	162892        	l32i	a9, a8, 88
4201843e:	748390        	extui	a8, a9, 3, 8
42018441:	209880        	or	a9, a8, a8
    signed int k_dig_ldo = efuse_ll_get_k_dig_ldo();
    signed int v_dig_bias20 = efuse_ll_get_v_dig_dbias20();
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
42018444:	3fa0b2        	movi	a11, 63
42018447:	05bba7        	bgeu	a11, a10, 42018450 <get_dig1v3_dbias_by_efuse+0x3c>
4201844a:	10aab0        	and	a10, a10, a11
4201844d:	60a0a0        	neg	a10, a10
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
42018450:	056877        	bbci	a8, 7, 42018459 <get_dig1v3_dbias_by_efuse+0x45>
42018453:	649090        	extui	a9, a9, 0, 7
42018456:	609090        	neg	a9, a9

    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
42018459:	a09990        	addx4	a9, a9, a9
4201845c:	a30e81        	l32r	a8, 42001094 <_stext+0x1074> (2a59 <UserFrameTotalSize+0x2959>)
4201845f:	a09980        	addx4	a9, a9, a8
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
42018462:	d3a082        	movi	a8, 211
42018465:	aa8a      	add.n	a10, a10, a8
    uint32_t dig_dbias =15;
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
42018467:	f20c      	movi.n	a2, 15
42018469:	0003c6        	j	4201847c <get_dig1v3_dbias_by_efuse+0x68>
        uint32_t v_dig_nearest_1v3_mul10000 = 0;
        v_dig_nearest_1v3_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
4201846c:	ecc282        	addi	a8, a2, -20
4201846f:	828a80        	mull	a8, a10, a8
42018472:	889a      	add.n	a8, a8, a9
        if (v_dig_nearest_1v3_mul10000 >= 13000) {
42018474:	a309b1        	l32r	a11, 42001098 <_stext+0x1078> (32c7 <UserFrameTotalSize+0x31c7>)
42018477:	063b87        	bltu	a11, a8, 42018481 <get_dig1v3_dbias_by_efuse+0x6d>
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
4201847a:	221b      	addi.n	a2, a2, 1
4201847c:	e81c      	movi.n	a8, 30
4201847e:	eab827        	bgeu	a8, a2, 4201846c <get_dig1v3_dbias_by_efuse+0x58>
            break;
        }
    }
    return dig_dbias;
}
42018481:	f01d      	retw.n
	...

42018484 <get_dig_dbias_by_efuse>:
{
42018484:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
42018487:	111226        	beqi	a2, 1, 4201849c <get_dig_dbias_by_efuse+0x18>
4201848a:	a300d1        	l32r	a13, 4200108c <_stext+0x106c> (3c02248c <_flash_rodata_start+0x236c>)
4201848d:	a303c1        	l32r	a12, 4200109c <_stext+0x107c> (3c026c6c <__func__$1>)
42018490:	4aa1b2        	movi	a11, 0x14a
42018493:	a2fca1        	l32r	a10, 42001084 <_stext+0x1064> (3c022481 <_flash_rodata_start+0x2361>)
42018496:	9f1c81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42018499:	0008e0        	callx8	a8
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_dig_dbias_hvt(void)
{
    // EFUSE_BLK1,  171,    5,     BLOCK1 digital dbias when hvt
    return EFUSE.rd_mac_spi_sys_5.dig_dbias_hvt;
4201849c:	a2fb81        	l32r	a8, 42001088 <_stext+0x1068> (60007000 <EFUSE>)
4201849f:	0020c0        	memw
420184a2:	162822        	l32i	a2, a8, 88
}
420184a5:	442b20        	extui	a2, a2, 11, 5
420184a8:	f01d      	retw.n
	...

420184ac <get_rtc_dbias_by_efuse>:
{
420184ac:	004136        	entry	a1, 32
    assert(pvt_scheme_ver == 1);
420184af:	111226        	beqi	a2, 1, 420184c4 <get_rtc_dbias_by_efuse+0x18>
420184b2:	a2f6d1        	l32r	a13, 4200108c <_stext+0x106c> (3c02248c <_flash_rodata_start+0x236c>)
420184b5:	a2fac1        	l32r	a12, 420010a0 <_stext+0x1080> (3c026c54 <__func__$0>)
420184b8:	50a1b2        	movi	a11, 0x150
420184bb:	a2f2a1        	l32r	a10, 42001084 <_stext+0x1064> (3c022481 <_flash_rodata_start+0x2361>)
420184be:	9f1281        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420184c1:	0008e0        	callx8	a8
    return EFUSE.rd_mac_spi_sys_4.k_rtc_ldo;
420184c4:	a2f181        	l32r	a8, 42001088 <_stext+0x1068> (60007000 <EFUSE>)
420184c7:	0020c0        	memw
420184ca:	1528c2        	l32i	a12, a8, 84
420184cd:	64cdc0        	extui	a12, a12, 13, 7
    return EFUSE.rd_mac_spi_sys_4.k_dig_ldo;
420184d0:	0020c0        	memw
420184d3:	1528b2        	l32i	a11, a8, 84
420184d6:	65b4b0        	extui	a11, a11, 20, 7
    return (EFUSE.rd_mac_spi_sys_5.v_rtc_dbias20_1 << 5) + EFUSE.rd_mac_spi_sys_4.v_rtc_dbias20;
420184d9:	0020c0        	memw
420184dc:	1628a2        	l32i	a10, a8, 88
420184df:	24a0a0        	extui	a10, a10, 0, 3
420184e2:	11aab0        	slli	a10, a10, 5
420184e5:	0020c0        	memw
420184e8:	152892        	l32i	a9, a8, 84
420184eb:	459b90        	extui	a9, a9, 27, 5
420184ee:	aa9a      	add.n	a10, a10, a9
    return EFUSE.rd_mac_spi_sys_5.v_dig_dbias20;
420184f0:	0020c0        	memw
420184f3:	162882        	l32i	a8, a8, 88
420184f6:	749380        	extui	a9, a8, 3, 8
420184f9:	098d      	mov.n	a8, a9
    k_rtc_ldo =  ((k_rtc_ldo & BIT(6)) != 0)? -(k_rtc_ldo & 0x3f): (uint8_t)k_rtc_ldo;
420184fb:	fd3c      	movi.n	a13, 63
420184fd:	05bdc7        	bgeu	a13, a12, 42018506 <get_rtc_dbias_by_efuse+0x5a>
42018500:	10ccd0        	and	a12, a12, a13
42018503:	60c0c0        	neg	a12, a12
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
42018506:	fd3c      	movi.n	a13, 63
42018508:	05bdb7        	bgeu	a13, a11, 42018511 <get_rtc_dbias_by_efuse+0x65>
4201850b:	10bbd0        	and	a11, a11, a13
4201850e:	60b0b0        	neg	a11, a11
    v_rtc_bias20 =  ((v_rtc_bias20 & BIT(7)) != 0)? -(v_rtc_bias20 & 0x7f): (uint8_t)v_rtc_bias20;
42018511:	086a77        	bbci	a10, 7, 4201851d <get_rtc_dbias_by_efuse+0x71>
42018514:	64a0a0        	extui	a10, a10, 0, 7
42018517:	60a0a0        	neg	a10, a10
4201851a:	000086        	j	42018520 <get_rtc_dbias_by_efuse+0x74>
4201851d:	74a0a0        	extui	a10, a10, 0, 8
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
42018520:	056977        	bbci	a9, 7, 42018529 <get_rtc_dbias_by_efuse+0x7d>
42018523:	648080        	extui	a8, a8, 0, 7
42018526:	608080        	neg	a8, a8
    uint32_t v_rtc_dbias20_real_mul10000 = V_RTC_MID_MUL10000 + v_rtc_bias20 * 10000 / 500;
42018529:	a0aaa0        	addx4	a10, a10, a10
4201852c:	a2de91        	l32r	a9, 420010a4 <_stext+0x1084> (27c5 <UserFrameTotalSize+0x26c5>)
4201852f:	a0aa90        	addx4	a10, a10, a9
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
42018532:	a08880        	addx4	a8, a8, a8
42018535:	a2d791        	l32r	a9, 42001094 <_stext+0x1074> (2a59 <UserFrameTotalSize+0x2959>)
42018538:	a08890        	addx4	a8, a8, a9
    signed int k_rtc_ldo_real_mul10000 = K_RTC_MID_MUL10000 + k_rtc_ldo;
4201853b:	c6a092        	movi	a9, 198
4201853e:	cc9a      	add.n	a12, a12, a9
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
42018540:	d3a092        	movi	a9, 211
42018543:	bb9a      	add.n	a11, a11, a9
    uint32_t v_dig_nearest_1v15_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
42018545:	ecc332        	addi	a3, a3, -20
42018548:	82bb30        	mull	a11, a11, a3
4201854b:	bb8a      	add.n	a11, a11, a8
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
4201854d:	f20c      	movi.n	a2, 15
4201854f:	000506        	j	42018567 <get_rtc_dbias_by_efuse+0xbb>
42018552:	000000        	ill
        v_rtc_nearest_1v15_mul10000 = v_rtc_dbias20_real_mul10000 + k_rtc_ldo_real_mul10000 * (rtc_dbias - 20);
42018555:	ecc282        	addi	a8, a2, -20
42018558:	828c80        	mull	a8, a12, a8
4201855b:	88aa      	add.n	a8, a8, a10
        if (v_rtc_nearest_1v15_mul10000 >= v_dig_nearest_1v15_mul10000 - 250) {
4201855d:	06af92        	movi	a9, -250
42018560:	9b9a      	add.n	a9, a11, a9
42018562:	06b897        	bgeu	a8, a9, 4201856c <get_rtc_dbias_by_efuse+0xc0>
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
42018565:	221b      	addi.n	a2, a2, 1
42018567:	e81c      	movi.n	a8, 30
42018569:	e8b827        	bgeu	a8, a2, 42018555 <get_rtc_dbias_by_efuse+0xa9>
}
4201856c:	f01d      	retw.n
	...

42018570 <rtc_set_stored_dbias>:

static void rtc_set_stored_dbias(void)
{
42018570:	004136        	entry	a1, 32
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
42018573:	a2c581        	l32r	a8, 42001088 <_stext+0x1068> (60007000 <EFUSE>)
42018576:	0020c0        	memw
42018579:	1428b2        	l32i	a11, a8, 80
4201857c:	25b8b0        	extui	a11, a11, 24, 3
    return EFUSE.rd_sys_part1_data4.blk_version_major;
4201857f:	0020c0        	memw
42018582:	1b2892        	l32i	a9, a8, 108
42018585:	149090        	extui	a9, a9, 0, 2
    4. save these values for reuse
    */
    uint8_t blk_minor = efuse_ll_get_blk_version_minor();
    uint8_t blk_major = efuse_ll_get_blk_version_major();
    uint8_t pvt_scheme_ver = 0;
    if ( (blk_major <= 1 && blk_minor == 1) || blk_major > 1 || (blk_major == 1 && blk_minor >= 2) ) {
42018588:	180c      	movi.n	a8, 1
4201858a:	628890        	saltu	a8, a8, a9
4201858d:	880b      	addi.n	a8, a8, -1
4201858f:	608080        	neg	a8, a8
42018592:	ab0b      	addi.n	a10, a11, -1
42018594:	40faa0        	nsau	a10, a10
42018597:	41a5a0        	srli	a10, a10, 5
4201859a:	1288a7        	bany	a8, a10, 420185b0 <rtc_set_stored_dbias+0x40>
4201859d:	0f29f6        	bgeui	a9, 2, 420185b0 <rtc_set_stored_dbias+0x40>
420185a0:	990b      	addi.n	a9, a9, -1
420185a2:	40f990        	nsau	a9, a9
420185a5:	419590        	srli	a9, a9, 5
420185a8:	180c      	movi.n	a8, 1
420185aa:	6288b0        	saltu	a8, a8, a11
420185ad:	380987        	bnone	a9, a8, 420185e9 <rtc_set_stored_dbias+0x79>
        /* PVT supported after blk_ver 1.2 */
        pvt_scheme_ver = 1;
    }

    if (pvt_scheme_ver == 1) {
        uint32_t dig1v3_dbias = get_dig1v3_dbias_by_efuse(pvt_scheme_ver);
420185b0:	1a0c      	movi.n	a10, 1
420185b2:	ffe625        	call8	42018414 <get_dig1v3_dbias_by_efuse>
420185b5:	0a7d      	mov.n	a7, a10
        uint32_t dig_dbias = get_dig_dbias_by_efuse(pvt_scheme_ver);
420185b7:	1a0c      	movi.n	a10, 1
420185b9:	ffeca5        	call8	42018484 <get_dig_dbias_by_efuse>
        if (dig_dbias != 0) {
420185bc:	9aac      	beqz.n	a10, 420185e9 <rtc_set_stored_dbias+0x79>
            g_dig_dbias_pvt_240m = MIN(dig1v3_dbias, dig_dbias + 3);
420185be:	ba3b      	addi.n	a11, a10, 3
420185c0:	63bb70        	minu	a11, a11, a7
420185c3:	a2b981        	l32r	a8, 420010a8 <_stext+0x1088> (3fc92468 <g_dig_dbias_pvt_240m>)
420185c6:	08b9      	s32i.n	a11, a8, 0
            g_dig_dbias_pvt_non_240m = MIN(dig1v3_dbias, dig_dbias + 2);
420185c8:	8a2b      	addi.n	a8, a10, 2
420185ca:	63a870        	minu	a10, a8, a7
420185cd:	a2b771        	l32r	a7, 420010ac <_stext+0x108c> (3fc92460 <g_dig_dbias_pvt_non_240m>)
420185d0:	07a9      	s32i.n	a10, a7, 0
            g_rtc_dbias_pvt_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_240m);
420185d2:	01a0a2        	movi	a10, 1
420185d5:	ffed65        	call8	420184ac <get_rtc_dbias_by_efuse>
420185d8:	a2b681        	l32r	a8, 420010b0 <_stext+0x1090> (3fc92464 <g_rtc_dbias_pvt_240m>)
420185db:	08a9      	s32i.n	a10, a8, 0
            g_rtc_dbias_pvt_non_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_non_240m);
420185dd:	07b8      	l32i.n	a11, a7, 0
420185df:	1a0c      	movi.n	a10, 1
420185e1:	ffeca5        	call8	420184ac <get_rtc_dbias_by_efuse>
420185e4:	a2b481        	l32r	a8, 420010b4 <_stext+0x1094> (3fc9245c <g_rtc_dbias_pvt_non_240m>)
420185e7:	08a9      	s32i.n	a10, a8, 0
            ESP_HW_LOGD(TAG, "not burn core voltage in efuse or burn wrong voltage value in blk version: 0%d\n", pvt_scheme_ver);
        }
    } else {
        ESP_HW_LOGD(TAG, "core voltage not decided in efuse, use default value.");
    }
}
420185e9:	f01d      	retw.n
	...

420185ec <calibrate_ocode>:
{
420185ec:	006136        	entry	a1, 48
    mspi_timing_change_speed_mode_cache_safe(true);
420185ef:	01a0a2        	movi	a10, 1
420185f2:	a2b381        	l32r	a8, 420010c0 <_stext+0x10a0> (40378154 <mspi_timing_change_speed_mode_cache_safe>)
420185f5:	0008e0        	callx8	a8
    soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
420185f8:	a2b381        	l32r	a8, 420010c4 <_stext+0x10a4> (40378890 <rtc_clk_slow_src_get>)
420185fb:	0008e0        	callx8	a8
    if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
420185fe:	071a26        	beqi	a10, 1, 42018609 <calibrate_ocode+0x1d>
    } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42018601:	092a26        	beqi	a10, 2, 4201860e <calibrate_ocode+0x22>
    rtc_cal_sel_t cal_clk = RTC_CAL_RTC_MUX;
42018604:	0a0c      	movi.n	a10, 0
42018606:	000186        	j	42018610 <calibrate_ocode+0x24>
        cal_clk = RTC_CAL_32K_XTAL;
42018609:	2a0c      	movi.n	a10, 2
4201860b:	000046        	j	42018610 <calibrate_ocode+0x24>
        cal_clk  = RTC_CAL_8MD256;
4201860e:	1a0c      	movi.n	a10, 1
    uint32_t slow_clk_period = rtc_clk_cal(cal_clk, 100);
42018610:	64a0b2        	movi	a11, 100
42018613:	9ed281        	l32r	a8, 4200015c <_stext+0x13c> (40379184 <rtc_clk_cal>)
42018616:	0008e0        	callx8	a8
    uint64_t max_delay_cycle = rtc_time_us_to_slowclk(max_delay_time_us, slow_clk_period);
42018619:	0acd      	mov.n	a12, a10
4201861b:	9f15a1        	l32r	a10, 42000270 <_stext+0x250> (2710 <UserFrameTotalSize+0x2610>)
4201861e:	0b0c      	movi.n	a11, 0
42018620:	a2aa81        	l32r	a8, 420010c8 <_stext+0x10a8> (4037924c <rtc_time_us_to_slowclk>)
42018623:	0008e0        	callx8	a8
42018626:	0a4d      	mov.n	a4, a10
42018628:	0b5d      	mov.n	a5, a11
    uint64_t cycle0 = rtc_time_get();
4201862a:	a2a881        	l32r	a8, 420010cc <_stext+0x10ac> (403792d4 <rtc_time_get>)
4201862d:	0008e0        	callx8	a8
    uint64_t timeout_cycle = cycle0 + max_delay_cycle;
42018630:	55ba      	add.n	a5, a5, a11
42018632:	44aa      	add.n	a4, a4, a10
42018634:	01b4a7        	bgeu	a4, a10, 42018639 <calibrate_ocode+0x4d>
42018637:	551b      	addi.n	a5, a5, 1
    rtc_clk_cpu_freq_get_config(&old_config);
42018639:	01ad      	mov.n	a10, a1
4201863b:	9edd81        	l32r	a8, 420001b0 <_stext+0x190> (403789d4 <rtc_clk_cpu_freq_get_config>)
4201863e:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_xtal();
42018641:	a2a381        	l32r	a8, 420010d0 <_stext+0x10b0> (40378da0 <rtc_clk_cpu_freq_set_xtal>)
42018644:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 0);
42018647:	0f0c      	movi.n	a15, 0
42018649:	0fed      	mov.n	a14, a15
4201864b:	0fdd      	mov.n	a13, a15
4201864d:	0fcd      	mov.n	a12, a15
4201864f:	1b0c      	movi.n	a11, 1
42018651:	61a0a2        	movi	a10, 97
42018654:	a1bf81        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
42018657:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 1);
4201865a:	1f0c      	movi.n	a15, 1
4201865c:	0e0c      	movi.n	a14, 0
4201865e:	0edd      	mov.n	a13, a14
42018660:	0ecd      	mov.n	a12, a14
42018662:	0fbd      	mov.n	a11, a15
42018664:	61a0a2        	movi	a10, 97
42018667:	a1ba81        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
4201866a:	0008e0        	callx8	a8
        odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_O_DONE_FLAG);
4201866d:	0e0c      	movi.n	a14, 0
4201866f:	0edd      	mov.n	a13, a14
42018671:	3c0c      	movi.n	a12, 3
42018673:	1b0c      	movi.n	a11, 1
42018675:	61a0a2        	movi	a10, 97
42018678:	a29781        	l32r	a8, 420010d4 <_stext+0x10b4> (4037827c <regi2c_ctrl_read_reg_mask>)
4201867b:	0008e0        	callx8	a8
4201867e:	160c      	movi.n	a6, 1
42018680:	836aa0        	moveqz	a6, a10, a10
        bg_odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_BG_O_DONE_FLAG);
42018683:	3e0c      	movi.n	a14, 3
42018685:	0edd      	mov.n	a13, a14
42018687:	0ecd      	mov.n	a12, a14
42018689:	01a0b2        	movi	a11, 1
4201868c:	61a0a2        	movi	a10, 97
4201868f:	a29181        	l32r	a8, 420010d4 <_stext+0x10b4> (4037827c <regi2c_ctrl_read_reg_mask>)
42018692:	0008e0        	callx8	a8
42018695:	170c      	movi.n	a7, 1
42018697:	837aa0        	moveqz	a7, a10, a10
        cycle1 = rtc_time_get();
4201869a:	a28c81        	l32r	a8, 420010cc <_stext+0x10ac> (403792d4 <rtc_time_get>)
4201869d:	0008e0        	callx8	a8
        if (odone_flag && bg_odone_flag) {
420186a0:	248677        	bany	a6, a7, 420186c8 <calibrate_ocode+0xdc>
        if (cycle1 >= timeout_cycle) {
420186a3:	c63b57        	bltu	a11, a5, 4201866d <calibrate_ocode+0x81>
420186a6:	0295b7        	bne	a5, a11, 420186ac <calibrate_ocode+0xc0>
420186a9:	c03a47        	bltu	a10, a4, 4201866d <calibrate_ocode+0x81>
420186ac:	9e6081        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420186af:	0888      	l32i.n	a8, a8, 0
            ESP_HW_LOGW(TAG, "o_code calibration fail\n");
420186b1:	1328b6        	bltui	a8, 2, 420186c8 <calibrate_ocode+0xdc>
420186b4:	9e6b81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
420186b7:	0008e0        	callx8	a8
420186ba:	a27fc1        	l32r	a12, 420010b8 <_stext+0x1098> (3c0224a0 <_flash_rodata_start+0x2380>)
420186bd:	0abd      	mov.n	a11, a10
420186bf:	a27fa1        	l32r	a10, 420010bc <_stext+0x109c> (3c0224a8 <_flash_rodata_start+0x2388>)
420186c2:	9e6881        	l32r	a8, 42000064 <_stext+0x44> (400005d0 <esp_rom_printf>)
420186c5:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_config(&old_config);
420186c8:	01ad      	mov.n	a10, a1
420186ca:	9ebc81        	l32r	a8, 420001bc <_stext+0x19c> (40378d30 <rtc_clk_cpu_freq_set_config>)
420186cd:	0008e0        	callx8	a8
    mspi_timing_change_speed_mode_cache_safe(false);
420186d0:	0a0c      	movi.n	a10, 0
420186d2:	a27b81        	l32r	a8, 420010c0 <_stext+0x10a0> (40378154 <mspi_timing_change_speed_mode_cache_safe>)
420186d5:	0008e0        	callx8	a8
}
420186d8:	f01d      	retw.n
	...

420186dc <rtc_init>:
{
420186dc:	006136        	entry	a1, 48
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
420186df:	a27e91        	l32r	a9, 420010d8 <_stext+0x10b8> (60008090 <RTCCNTL+0x90>)
420186e2:	0020c0        	memw
420186e5:	0988      	l32i.n	a8, a9, 0
420186e7:	a27da1        	l32r	a10, 420010dc <_stext+0x10bc> (fffdffff <_rtc_reserved_end+0x9fedffff>)
420186ea:	1088a0        	and	a8, a8, a10
420186ed:	0020c0        	memw
420186f0:	0989      	s32i.n	a8, a9, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
420186f2:	a27b91        	l32r	a9, 420010e0 <_stext+0x10c0> (60008094 <RTCCNTL+0x94>)
420186f5:	0020c0        	memw
420186f8:	0988      	l32i.n	a8, a9, 0
420186fa:	a196a1        	l32r	a10, 42000d54 <_stext+0xd34> (efffffff <_rtc_reserved_end+0x8fefffff>)
420186fd:	1088a0        	and	a8, a8, a10
42018700:	0020c0        	memw
42018703:	0989      	s32i.n	a8, a9, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_RTC_REG, 0);
42018705:	0f0c      	movi.n	a15, 0
42018707:	2e0c      	movi.n	a14, 2
42018709:	0edd      	mov.n	a13, a14
4201870b:	dc0c      	movi.n	a12, 13
4201870d:	1b0c      	movi.n	a11, 1
4201870f:	6da0a2        	movi	a10, 109
42018712:	a18f81        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
42018715:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_DIG_REG, 0);
42018718:	0f0c      	movi.n	a15, 0
4201871a:	3e0c      	movi.n	a14, 3
4201871c:	0edd      	mov.n	a13, a14
4201871e:	dc0c      	movi.n	a12, 13
42018720:	01a0b2        	movi	a11, 1
42018723:	6da0a2        	movi	a10, 109
42018726:	a18a81        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
42018729:	0008e0        	callx8	a8
    CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_PVTMON_PU);
4201872c:	a26e91        	l32r	a9, 420010e4 <_stext+0x10c4> (60008034 <RTCCNTL+0x34>)
4201872f:	0020c0        	memw
42018732:	0988      	l32i.n	a8, a9, 0
42018734:	a18da1        	l32r	a10, 42000d68 <_stext+0xd48> (fbffffff <_rtc_reserved_end+0x9befffff>)
42018737:	1088a0        	and	a8, a8, a10
4201873a:	0020c0        	memw
4201873d:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_PLL_BUF_WAIT, cfg.pll_wait);
4201873f:	a26a91        	l32r	a9, 420010e8 <_stext+0x10c8> (6000801c <RTCCNTL+0x1c>)
42018742:	0020c0        	memw
42018745:	0988      	l32i.n	a8, a9, 0
42018747:	118880        	slli	a8, a8, 8
4201874a:	418880        	srli	a8, a8, 8
4201874d:	75a020        	extui	a10, a2, 16, 8
42018750:	01aa80        	slli	a10, a10, 24
42018753:	2088a0        	or	a8, a8, a10
42018756:	0020c0        	memw
42018759:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, cfg.ck8m_wait);
4201875b:	0020c0        	memw
4201875e:	0988      	l32i.n	a8, a9, 0
42018760:	a263a1        	l32r	a10, 420010ec <_stext+0x10cc> (ffffc03f <_rtc_reserved_end+0x9fefc03f>)
42018763:	1088a0        	and	a8, a8, a10
42018766:	74a020        	extui	a10, a2, 0, 8
42018769:	11aaa0        	slli	a10, a10, 6
4201876c:	2088a0        	or	a8, a8, a10
4201876f:	0020c0        	memw
42018772:	0989      	s32i.n	a8, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER5_REG, RTC_CNTL_MIN_SLP_VAL, RTC_CNTL_MIN_SLP_VAL_MIN);
42018774:	a25f91        	l32r	a9, 420010f0 <_stext+0x10d0> (6000802c <RTCCNTL+0x2c>)
42018777:	0020c0        	memw
4201877a:	0988      	l32i.n	a8, a9, 0
4201877c:	a25ea1        	l32r	a10, 420010f4 <_stext+0x10d4> (ffff00ff <_rtc_reserved_end+0x9fef00ff>)
4201877f:	1088a0        	and	a8, a8, a10
42018782:	00a2a2        	movi	a10, 0x200
42018785:	2088a0        	or	a8, a8, a10
42018788:	0020c0        	memw
4201878b:	0989      	s32i.n	a8, a9, 0
    rtc_init_config_t rtc_init_cfg = RTC_INIT_CONFIG_DEFAULT();
4201878d:	a25a81        	l32r	a8, 420010f8 <_stext+0x10d8> (3c026c44 <__func__$2+0x20>)
42018790:	0898      	l32i.n	a9, a8, 0
42018792:	18b8      	l32i.n	a11, a8, 4
42018794:	0199      	s32i.n	a9, a1, 0
42018796:	28a8      	l32i.n	a10, a8, 8
42018798:	11b9      	s32i.n	a11, a1, 4
4201879a:	061882        	l16ui	a8, a8, 12
4201879d:	21a9      	s32i.n	a10, a1, 8
4201879f:	065182        	s16i	a8, a1, 12
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_POWERUP_TIMER, rtc_init_cfg.wifi_powerup_cycles);
420187a2:	a25681        	l32r	a8, 420010fc <_stext+0x10dc> (60008024 <RTCCNTL+0x24>)
420187a5:	0020c0        	memw
420187a8:	08a8      	l32i.n	a10, a8, 0
420187aa:	a255c1        	l32r	a12, 42001100 <_stext+0x10e0> (ffff01ff <_rtc_reserved_end+0x9fef01ff>)
420187ad:	10aac0        	and	a10, a10, a12
420187b0:	649090        	extui	a9, a9, 0, 7
420187b3:	119970        	slli	a9, a9, 9
420187b6:	209a90        	or	a9, a10, a9
420187b9:	0020c0        	memw
420187bc:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_WAIT_TIMER, rtc_init_cfg.wifi_wait_cycles);
420187be:	0020c0        	memw
420187c1:	0898      	l32i.n	a9, a8, 0
420187c3:	00aee2        	movi	a14, 0xfffffe00
420187c6:	1099e0        	and	a9, a9, a14
420187c9:	01a8      	l32i.n	a10, a1, 0
420187cb:	84a7a0        	extui	a10, a10, 7, 9
420187ce:	2099a0        	or	a9, a9, a10
420187d1:	0020c0        	memw
420187d4:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_POWERUP_TIMER, rtc_init_cfg.bt_powerup_cycles);
420187d6:	0020c0        	memw
420187d9:	0898      	l32i.n	a9, a8, 0
420187db:	a0a1d1        	l32r	a13, 42000a60 <_stext+0xa40> (1ffffff <UserFrameTotalSize+0x1fffeff>)
420187de:	1099d0        	and	a9, a9, a13
420187e1:	01a8      	l32i.n	a10, a1, 0
420187e3:	65a0a0        	extui	a10, a10, 16, 7
420187e6:	01aa70        	slli	a10, a10, 25
420187e9:	2099a0        	or	a9, a9, a10
420187ec:	0020c0        	memw
420187ef:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_WAIT_TIMER, rtc_init_cfg.bt_wait_cycles);
420187f1:	0020c0        	memw
420187f4:	0898      	l32i.n	a9, a8, 0
420187f6:	a243b1        	l32r	a11, 42001104 <_stext+0x10e4> (fe00ffff <_rtc_reserved_end+0x9df0ffff>)
420187f9:	1099b0        	and	a9, a9, a11
420187fc:	01a8      	l32i.n	a10, a1, 0
420187fe:	85a7a0        	extui	a10, a10, 23, 9
42018801:	11aa00        	slli	a10, a10, 16
42018804:	2099a0        	or	a9, a9, a10
42018807:	0020c0        	memw
4201880a:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_POWERUP_TIMER, rtc_init_cfg.cpu_top_powerup_cycles);
4201880c:	a23f81        	l32r	a8, 42001108 <_stext+0x10e8> (60008030 <RTCCNTL+0x30>)
4201880f:	0020c0        	memw
42018812:	0898      	l32i.n	a9, a8, 0
42018814:	1099c0        	and	a9, a9, a12
42018817:	11a8      	l32i.n	a10, a1, 4
42018819:	65a0a0        	extui	a10, a10, 16, 7
4201881c:	11aa70        	slli	a10, a10, 9
4201881f:	2099a0        	or	a9, a9, a10
42018822:	0020c0        	memw
42018825:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_WAIT_TIMER, rtc_init_cfg.cpu_top_wait_cycles);
42018827:	0020c0        	memw
4201882a:	0898      	l32i.n	a9, a8, 0
4201882c:	1099e0        	and	a9, a9, a14
4201882f:	11a8      	l32i.n	a10, a1, 4
42018831:	85a7a0        	extui	a10, a10, 23, 9
42018834:	2099a0        	or	a9, a9, a10
42018837:	0020c0        	memw
4201883a:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_POWERUP_TIMER, rtc_init_cfg.rtc_powerup_cycles);
4201883c:	a23491        	l32r	a9, 4200110c <_stext+0x10ec> (60008028 <RTCCNTL+0x28>)
4201883f:	0020c0        	memw
42018842:	09a8      	l32i.n	a10, a9, 0
42018844:	10aac0        	and	a10, a10, a12
42018847:	11c8      	l32i.n	a12, a1, 4
42018849:	64c0c0        	extui	a12, a12, 0, 7
4201884c:	11cc70        	slli	a12, a12, 9
4201884f:	20aac0        	or	a10, a10, a12
42018852:	0020c0        	memw
42018855:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_WAIT_TIMER, rtc_init_cfg.rtc_wait_cycles);
42018857:	0020c0        	memw
4201885a:	09a8      	l32i.n	a10, a9, 0
4201885c:	10aae0        	and	a10, a10, a14
4201885f:	11c8      	l32i.n	a12, a1, 4
42018861:	84c7c0        	extui	a12, a12, 7, 9
42018864:	20aac0        	or	a10, a10, a12
42018867:	0020c0        	memw
4201886a:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_POWERUP_TIMER, rtc_init_cfg.dg_wrap_powerup_cycles);
4201886c:	0020c0        	memw
4201886f:	09a8      	l32i.n	a10, a9, 0
42018871:	10aad0        	and	a10, a10, a13
42018874:	21c8      	l32i.n	a12, a1, 8
42018876:	01cc70        	slli	a12, a12, 25
42018879:	20aac0        	or	a10, a10, a12
4201887c:	0020c0        	memw
4201887f:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_WAIT_TIMER, rtc_init_cfg.dg_wrap_wait_cycles);
42018881:	0020c0        	memw
42018884:	09a8      	l32i.n	a10, a9, 0
42018886:	10aab0        	and	a10, a10, a11
42018889:	21c8      	l32i.n	a12, a1, 8
4201888b:	84c7c0        	extui	a12, a12, 7, 9
4201888e:	11cc00        	slli	a12, a12, 16
42018891:	20aac0        	or	a10, a10, a12
42018894:	0020c0        	memw
42018897:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_POWERUP_TIMER, rtc_init_cfg.dg_peri_powerup_cycles);
42018899:	0020c0        	memw
4201889c:	0898      	l32i.n	a9, a8, 0
4201889e:	1099d0        	and	a9, a9, a13
420188a1:	21a8      	l32i.n	a10, a1, 8
420188a3:	65a0a0        	extui	a10, a10, 16, 7
420188a6:	01aa70        	slli	a10, a10, 25
420188a9:	2099a0        	or	a9, a9, a10
420188ac:	0020c0        	memw
420188af:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_WAIT_TIMER, rtc_init_cfg.dg_peri_wait_cycles);
420188b1:	0020c0        	memw
420188b4:	0898      	l32i.n	a9, a8, 0
420188b6:	1099b0        	and	a9, a9, a11
420188b9:	21a8      	l32i.n	a10, a1, 8
420188bb:	85a7a0        	extui	a10, a10, 23, 9
420188be:	11aa00        	slli	a10, a10, 16
420188c1:	2099a0        	or	a9, a9, a10
420188c4:	0020c0        	memw
420188c7:	0899      	s32i.n	a9, a8, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
420188c9:	7f1c      	movi.n	a15, 23
420188cb:	0e0c      	movi.n	a14, 0
420188cd:	4d0c      	movi.n	a13, 4
420188cf:	5c0c      	movi.n	a12, 5
420188d1:	1b0c      	movi.n	a11, 1
420188d3:	6da0a2        	movi	a10, 109
420188d6:	a11e81        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
420188d9:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, RTC_CNTL_DBIAS_1V10);
420188dc:	7f1c      	movi.n	a15, 23
420188de:	0e0c      	movi.n	a14, 0
420188e0:	4d0c      	movi.n	a13, 4
420188e2:	0dcd      	mov.n	a12, a13
420188e4:	1b0c      	movi.n	a11, 1
420188e6:	6da0a2        	movi	a10, 109
420188e9:	a11981        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
420188ec:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_TIMER2_REG, RTC_CNTL_ULPCP_TOUCH_START_WAIT, RTC_CNTL_ULPCP_TOUCH_START_WAIT_DEFAULT);
420188ef:	a20891        	l32r	a9, 42001110 <_stext+0x10f0> (60008020 <RTCCNTL+0x20>)
420188f2:	0020c0        	memw
420188f5:	0988      	l32i.n	a8, a9, 0
420188f7:	a207a1        	l32r	a10, 42001114 <_stext+0x10f4> (ff007fff <_rtc_reserved_end+0x9ef07fff>)
420188fa:	1088a0        	and	a8, a8, a10
420188fd:	a1d2a1        	l32r	a10, 42001048 <_stext+0x1028> (80000 <UserFrameTotalSize+0x7ff00>)
42018900:	2088a0        	or	a8, a8, a10
42018903:	0020c0        	memw
42018906:	0989      	s32i.n	a8, a9, 0
    if (cfg.cali_ocode) {
42018908:	1872e7        	bbci	a2, 30, 42018924 <rtc_init+0x248>
4201890b:	a1df81        	l32r	a8, 42001088 <_stext+0x1068> (60007000 <EFUSE>)
4201890e:	0020c0        	memw
42018911:	1b28a2        	l32i	a10, a8, 108
42018914:	14a0a0        	extui	a10, a10, 0, 2
        if (ocode_efuse_cali) {
42018917:	061a66        	bnei	a10, 1, 42018921 <rtc_init+0x245>
            set_ocode_by_efuse(blk_ver_major);
4201891a:	ffaae5        	call8	420183c8 <set_ocode_by_efuse>
4201891d:	0000c6        	j	42018924 <rtc_init+0x248>
42018920:	00          	.byte	00
            calibrate_ocode();
42018921:	ffcca5        	call8	420185ec <calibrate_ocode>
    rtc_set_stored_dbias();
42018924:	ffc4a5        	call8	42018570 <rtc_set_stored_dbias>
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
42018927:	a1e381        	l32r	a8, 420010b4 <_stext+0x1094> (3fc9245c <g_rtc_dbias_pvt_non_240m>)
4201892a:	0008f2        	l8ui	a15, a8, 0
4201892d:	0e0c      	movi.n	a14, 0
4201892f:	4d0c      	movi.n	a13, 4
42018931:	0dcd      	mov.n	a12, a13
42018933:	1b0c      	movi.n	a11, 1
42018935:	6da0a2        	movi	a10, 109
42018938:	a10681        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
4201893b:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
4201893e:	a1db81        	l32r	a8, 420010ac <_stext+0x108c> (3fc92460 <g_dig_dbias_pvt_non_240m>)
42018941:	0008f2        	l8ui	a15, a8, 0
42018944:	0e0c      	movi.n	a14, 0
42018946:	4d0c      	movi.n	a13, 4
42018948:	6c0c      	movi.n	a12, 6
4201894a:	1b0c      	movi.n	a11, 1
4201894c:	6da0a2        	movi	a10, 109
4201894f:	a10081        	l32r	a8, 42000d50 <_stext+0xd30> (40378324 <regi2c_ctrl_write_reg_mask>)
42018952:	0008e0        	callx8	a8
    if (cfg.clkctl_init) {
42018955:	5b7287        	bbci	a2, 24, 420189b4 <rtc_init+0x2d8>
        CLEAR_PERI_REG_MASK(EXTMEM_CACHE_MMU_POWER_CTRL_REG, EXTMEM_CACHE_MMU_MEM_FORCE_ON);
42018958:	a1f0a1        	l32r	a10, 42001118 <_stext+0x10f8> (600c412c <SYSTEM+0x412c>)
4201895b:	0020c0        	memw
4201895e:	0a98      	l32i.n	a9, a10, 0
42018960:	e87c      	movi.n	a8, -2
42018962:	109980        	and	a9, a9, a8
42018965:	0020c0        	memw
42018968:	0a99      	s32i.n	a9, a10, 0
        REG_WRITE(SYSCON_CLKGATE_FORCE_ON_REG, 0);
4201896a:	a1ec91        	l32r	a9, 4200111c <_stext+0x10fc> (600260a8 <SYSCON+0xa8>)
4201896d:	0a0c      	movi.n	a10, 0
4201896f:	0020c0        	memw
42018972:	09a9      	s32i.n	a10, a9, 0
        CLEAR_PERI_REG_MASK(EXTMEM_DCACHE_TAG_POWER_CTRL_REG, EXTMEM_DCACHE_TAG_MEM_FORCE_ON);
42018974:	a1eba1        	l32r	a10, 42001120 <_stext+0x1100> (600c4008 <SYSTEM+0x4008>)
42018977:	0020c0        	memw
4201897a:	0a98      	l32i.n	a9, a10, 0
4201897c:	109980        	and	a9, a9, a8
4201897f:	0020c0        	memw
42018982:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(EXTMEM_ICACHE_TAG_POWER_CTRL_REG, EXTMEM_ICACHE_TAG_MEM_FORCE_ON);
42018984:	a1e8a1        	l32r	a10, 42001124 <_stext+0x1104> (600c4068 <SYSTEM+0x4068>)
42018987:	0020c0        	memw
4201898a:	0a98      	l32i.n	a9, a10, 0
4201898c:	109980        	and	a9, a9, a8
4201898f:	0020c0        	memw
42018992:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(0), SPI_MEM_CLK_EN);
42018994:	a1e5a1        	l32r	a10, 42001128 <_stext+0x1108> (600030e8 <SPIMEM0+0xe8>)
42018997:	0020c0        	memw
4201899a:	0a98      	l32i.n	a9, a10, 0
4201899c:	109980        	and	a9, a9, a8
4201899f:	0020c0        	memw
420189a2:	0a99      	s32i.n	a9, a10, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(1), SPI_MEM_CLK_EN);
420189a4:	a1e2a1        	l32r	a10, 4200112c <_stext+0x110c> (600020e8 <SPIMEM1+0xe8>)
420189a7:	0020c0        	memw
420189aa:	0a98      	l32i.n	a9, a10, 0
420189ac:	108980        	and	a8, a9, a8
420189af:	0020c0        	memw
420189b2:	0a89      	s32i.n	a8, a10, 0
    if (cfg.pwrctl_init) {
420189b4:	02f297        	bbsi	a2, 25, 420189ba <rtc_init+0x2de>
420189b7:	00a206        	j	42018c43 <rtc_init+0x567>
        CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_CK8M_FORCE_PU);
420189ba:	9f6191        	l32r	a9, 42000740 <_stext+0x720> (60008074 <RTCCNTL+0x74>)
420189bd:	0020c0        	memw
420189c0:	0988      	l32i.n	a8, a9, 0
420189c2:	a0e9a1        	l32r	a10, 42000d68 <_stext+0xd48> (fbffffff <_rtc_reserved_end+0x9befffff>)
420189c5:	1088a0        	and	a8, a8, a10
420189c8:	0020c0        	memw
420189cb:	0989      	s32i.n	a8, a9, 0
        if (!(cfg.xtal_fpu | cfg.bbpll_fpu)) {
420189cd:	058b20        	extui	a8, a2, 27, 1
420189d0:	059c20        	extui	a9, a2, 28, 1
420189d3:	208890        	or	a8, a8, a9
420189d6:	68dc      	bnez.n	a8, 420189f0 <rtc_init+0x314>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
420189d8:	a1d691        	l32r	a9, 42001130 <_stext+0x1110> (60008000 <RTCCNTL>)
420189db:	0020c0        	memw
420189de:	0988      	l32i.n	a8, a9, 0
420189e0:	a009a1        	l32r	a10, 42000a04 <_stext+0x9e4> (ffffdfff <_rtc_reserved_end+0x9fefdfff>)
420189e3:	1088a0        	and	a8, a8, a10
420189e6:	0020c0        	memw
420189e9:	0989      	s32i.n	a8, a9, 0
420189eb:	000506        	j	42018a03 <rtc_init+0x327>
420189ee:	910000        	srl	a0, a0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
420189f1:	c0a1d0        	sub	a10, a1, a13
420189f4:	20          	.byte	0x20
420189f5:	098800        	l32e	a0, a8, -32
420189f8:	9f69a1        	l32r	a10, 4200079c <_stext+0x77c> (2000 <UserFrameTotalSize+0x1f00>)
420189fb:	2088a0        	or	a8, a8, a10
420189fe:	0020c0        	memw
42018a01:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
42018a03:	a1b891        	l32r	a9, 420010e4 <_stext+0x10c4> (60008034 <RTCCNTL+0x34>)
42018a06:	0020c0        	memw
42018a09:	0988      	l32i.n	a8, a9, 0
42018a0b:	a1caa1        	l32r	a10, 42001134 <_stext+0x1114> (fffbffff <_rtc_reserved_end+0x9febffff>)
42018a0e:	1088a0        	and	a8, a8, a10
42018a11:	0020c0        	memw
42018a14:	0989      	s32i.n	a8, a9, 0
        if (!cfg.bbpll_fpu) {
42018a16:	36f2c7        	bbsi	a2, 28, 42018a50 <rtc_init+0x374>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
42018a19:	a1c581        	l32r	a8, 42001130 <_stext+0x1110> (60008000 <RTCCNTL>)
42018a1c:	0020c0        	memw
42018a1f:	0898      	l32i.n	a9, a8, 0
42018a21:	a1c5a1        	l32r	a10, 42001138 <_stext+0x1118> (fffff7ff <_rtc_reserved_end+0x9feff7ff>)
42018a24:	1099a0        	and	a9, a9, a10
42018a27:	0020c0        	memw
42018a2a:	0899      	s32i.n	a9, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
42018a2c:	0020c0        	memw
42018a2f:	0898      	l32i.n	a9, a8, 0
42018a31:	ffada2        	movi	a10, 0xfffffdff
42018a34:	1099a0        	and	a9, a9, a10
42018a37:	0020c0        	memw
42018a3a:	0899      	s32i.n	a9, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
42018a3c:	0020c0        	memw
42018a3f:	0898      	l32i.n	a9, a8, 0
42018a41:	7fafa2        	movi	a10, -129
42018a44:	1099a0        	and	a9, a9, a10
42018a47:	0020c0        	memw
42018a4a:	0899      	s32i.n	a9, a8, 0
42018a4c:	000cc6        	j	42018a83 <rtc_init+0x3a7>
42018a4f:	00          	.byte	00
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
42018a50:	a1b881        	l32r	a8, 42001130 <_stext+0x1110> (60008000 <RTCCNTL>)
42018a53:	0020c0        	memw
42018a56:	0898      	l32i.n	a9, a8, 0
42018a58:	9ed4a1        	l32r	a10, 420005a8 <_stext+0x588> (800 <UserFrameTotalSize+0x700>)
42018a5b:	2099a0        	or	a9, a9, a10
42018a5e:	0020c0        	memw
42018a61:	0899      	s32i.n	a9, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
42018a63:	0020c0        	memw
42018a66:	0898      	l32i.n	a9, a8, 0
42018a68:	00a2a2        	movi	a10, 0x200
42018a6b:	2099a0        	or	a9, a9, a10
42018a6e:	0020c0        	memw
42018a71:	0899      	s32i.n	a9, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
42018a73:	0020c0        	memw
42018a76:	0898      	l32i.n	a9, a8, 0
42018a78:	80a0a2        	movi	a10, 128
42018a7b:	2099a0        	or	a9, a9, a10
42018a7e:	0020c0        	memw
42018a81:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42018a83:	a1ae91        	l32r	a9, 4200113c <_stext+0x111c> (60008088 <RTCCNTL+0x88>)
42018a86:	0020c0        	memw
42018a89:	0988      	l32i.n	a8, a9, 0
42018a8b:	a1ada1        	l32r	a10, 42001140 <_stext+0x1120> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
42018a8e:	1088a0        	and	a8, a8, a10
42018a91:	0020c0        	memw
42018a94:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_REGULATOR_FORCE_PU);
42018a96:	a1aba1        	l32r	a10, 42001144 <_stext+0x1124> (60008084 <RTCCNTL+0x84>)
42018a99:	0020c0        	memw
42018a9c:	0a88      	l32i.n	a8, a10, 0
42018a9e:	888a      	add.n	a8, a8, a8
42018aa0:	418180        	srli	a8, a8, 1
42018aa3:	0020c0        	memw
42018aa6:	0a89      	s32i.n	a8, a10, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PU);
42018aa8:	0020c0        	memw
42018aab:	0a88      	l32i.n	a8, a10, 0
42018aad:	a0acb1        	l32r	a11, 42000d60 <_stext+0xd40> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42018ab0:	1088b0        	and	a8, a8, a11
42018ab3:	0020c0        	memw
42018ab6:	0a89      	s32i.n	a8, a10, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_NOISO | RTC_CNTL_FASTMEM_FORCE_NOISO);
42018ab8:	0020c0        	memw
42018abb:	0988      	l32i.n	a8, a9, 0
42018abd:	aa7c      	movi.n	a10, -6
42018abf:	1088a0        	and	a8, a8, a10
42018ac2:	0020c0        	memw
42018ac5:	0989      	s32i.n	a8, a9, 0
        if (cfg.rtc_dboost_fpd) {
42018ac7:	1572a7        	bbci	a2, 26, 42018ae0 <rtc_init+0x404>
            SET_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42018aca:	a19e91        	l32r	a9, 42001144 <_stext+0x1124> (60008084 <RTCCNTL+0x84>)
42018acd:	0020c0        	memw
42018ad0:	0988      	l32i.n	a8, a9, 0
42018ad2:	a156a1        	l32r	a10, 4200102c <_stext+0x100c> (10000000 <UserFrameTotalSize+0xfffff00>)
42018ad5:	2088a0        	or	a8, a8, a10
42018ad8:	0020c0        	memw
42018adb:	0989      	s32i.n	a8, a9, 0
42018add:	000486        	j	42018af3 <rtc_init+0x417>
            CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42018ae0:	a19991        	l32r	a9, 42001144 <_stext+0x1124> (60008084 <RTCCNTL+0x84>)
42018ae3:	0020c0        	memw
42018ae6:	0988      	l32i.n	a8, a9, 0
42018ae8:	a09ba1        	l32r	a10, 42000d54 <_stext+0xd34> (efffffff <_rtc_reserved_end+0x8fefffff>)
42018aeb:	1088a0        	and	a8, a8, a10
42018aee:	0020c0        	memw
42018af1:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
42018af3:	a17c91        	l32r	a9, 420010e4 <_stext+0x10c4> (60008034 <RTCCNTL+0x34>)
42018af6:	0020c0        	memw
42018af9:	0988      	l32i.n	a8, a9, 0
42018afb:	a18e71        	l32r	a7, 42001134 <_stext+0x1114> (fffbffff <_rtc_reserved_end+0x9febffff>)
42018afe:	108870        	and	a8, a8, a7
42018b01:	0020c0        	memw
42018b04:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(SYSTEM_MEM_PD_MASK_REG, SYSTEM_LSLP_MEM_PD_MASK);
42018b06:	a19091        	l32r	a9, 42001148 <_stext+0x1128> (600c0014 <SYSTEM+0x14>)
42018b09:	0020c0        	memw
42018b0c:	0988      	l32i.n	a8, a9, 0
42018b0e:	ea7c      	movi.n	a10, -2
42018b10:	1088a0        	and	a8, a8, a10
42018b13:	0020c0        	memw
42018b16:	0989      	s32i.n	a8, a9, 0
        rtc_sleep_pu(pu_cfg);
42018b18:	0a0c      	movi.n	a10, 0
42018b1a:	a19381        	l32r	a8, 42001168 <_stext+0x1148> (40378dac <rtc_sleep_pu>)
42018b1d:	0008e0        	callx8	a8
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_WRAP_FORCE_PU);
42018b20:	a16e81        	l32r	a8, 420010d8 <_stext+0x10b8> (60008090 <RTCCNTL+0x90>)
42018b23:	0020c0        	memw
42018b26:	0898      	l32i.n	a9, a8, 0
42018b28:	a189a1        	l32r	a10, 4200114c <_stext+0x112c> (ffefffff <_rtc_reserved_end+0x9fdfffff>)
42018b2b:	1099a0        	and	a9, a9, a10
42018b2e:	0020c0        	memw
42018b31:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_WRAP_FORCE_NOISO | RTC_CNTL_DG_WRAP_FORCE_ISO);
42018b33:	a16b91        	l32r	a9, 420010e0 <_stext+0x10c0> (60008094 <RTCCNTL+0x94>)
42018b36:	0020c0        	memw
42018b39:	09a8      	l32i.n	a10, a9, 0
42018b3b:	11aae0        	slli	a10, a10, 2
42018b3e:	41a2a0        	srli	a10, a10, 2
42018b41:	0020c0        	memw
42018b44:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_NOISO | RTC_CNTL_WIFI_FORCE_ISO);
42018b46:	0020c0        	memw
42018b49:	09a8      	l32i.n	a10, a9, 0
42018b4b:	a181b1        	l32r	a11, 42001150 <_stext+0x1130> (cfffffff <_rtc_reserved_end+0x6fefffff>)
42018b4e:	10aab0        	and	a10, a10, a11
42018b51:	0020c0        	memw
42018b54:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PU);
42018b56:	0020c0        	memw
42018b59:	08a8      	l32i.n	a10, a8, 0
42018b5b:	10aa70        	and	a10, a10, a7
42018b5e:	0020c0        	memw
42018b61:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_BT_FORCE_NOISO | RTC_CNTL_BT_FORCE_ISO);
42018b63:	0020c0        	memw
42018b66:	09a8      	l32i.n	a10, a9, 0
42018b68:	a17bb1        	l32r	a11, 42001154 <_stext+0x1134> (ff3fffff <_rtc_reserved_end+0x9f2fffff>)
42018b6b:	10aab0        	and	a10, a10, a11
42018b6e:	0020c0        	memw
42018b71:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_BT_FORCE_PU);
42018b73:	0020c0        	memw
42018b76:	08a8      	l32i.n	a10, a8, 0
42018b78:	a178b1        	l32r	a11, 42001158 <_stext+0x1138> (ffffefff <_rtc_reserved_end+0x9fefefff>)
42018b7b:	10aab0        	and	a10, a10, a11
42018b7e:	0020c0        	memw
42018b81:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_CPU_TOP_FORCE_NOISO | RTC_CNTL_CPU_TOP_FORCE_ISO);
42018b83:	0020c0        	memw
42018b86:	09a8      	l32i.n	a10, a9, 0
42018b88:	a175b1        	l32r	a11, 4200115c <_stext+0x113c> (f3ffffff <_rtc_reserved_end+0x93efffff>)
42018b8b:	10aab0        	and	a10, a10, a11
42018b8e:	0020c0        	memw
42018b91:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_CPU_TOP_FORCE_PU);
42018b93:	0020c0        	memw
42018b96:	08a8      	l32i.n	a10, a8, 0
42018b98:	a172b1        	l32r	a11, 42001160 <_stext+0x1140> (ffbfffff <_rtc_reserved_end+0x9fafffff>)
42018b9b:	10aab0        	and	a10, a10, a11
42018b9e:	0020c0        	memw
42018ba1:	08a9      	s32i.n	a10, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PERI_FORCE_NOISO | RTC_CNTL_DG_PERI_FORCE_ISO);
42018ba3:	0020c0        	memw
42018ba6:	09a8      	l32i.n	a10, a9, 0
42018ba8:	a16fb1        	l32r	a11, 42001164 <_stext+0x1144> (fcffffff <_rtc_reserved_end+0x9cefffff>)
42018bab:	10aab0        	and	a10, a10, a11
42018bae:	0020c0        	memw
42018bb1:	09a9      	s32i.n	a10, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_PERI_FORCE_PU);
42018bb3:	0020c0        	memw
42018bb6:	0898      	l32i.n	a9, a8, 0
42018bb8:	9daba1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42018bbb:	1099a0        	and	a9, a9, a10
42018bbe:	0020c0        	memw
42018bc1:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_NOISO);
42018bc3:	a15e81        	l32r	a8, 4200113c <_stext+0x111c> (60008088 <RTCCNTL+0x88>)
42018bc6:	0020c0        	memw
42018bc9:	0898      	l32i.n	a9, a8, 0
42018bcb:	dfafa2        	movi	a10, -33
42018bce:	1099a0        	and	a9, a9, a10
42018bd1:	0020c0        	memw
42018bd4:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_ISO);
42018bd6:	0020c0        	memw
42018bd9:	0898      	l32i.n	a9, a8, 0
42018bdb:	fa6c      	movi.n	a10, -17
42018bdd:	1099a0        	and	a9, a9, a10
42018be0:	0020c0        	memw
42018be3:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42018be5:	0020c0        	memw
42018be8:	0898      	l32i.n	a9, a8, 0
42018bea:	a155a1        	l32r	a10, 42001140 <_stext+0x1120> (fff7ffff <_rtc_reserved_end+0x9fe7ffff>)
42018bed:	1099a0        	and	a9, a9, a10
42018bf0:	0020c0        	memw
42018bf3:	0899      	s32i.n	a9, a8, 0
        if (cfg.cpu_waiti_clk_gate) {
42018bf5:	1472d7        	bbci	a2, 29, 42018c0d <rtc_init+0x531>
            CLEAR_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42018bf8:	a05191        	l32r	a9, 42000d3c <_stext+0xd1c> (600c0010 <SYSTEM+0x10>)
42018bfb:	0020c0        	memw
42018bfe:	0988      	l32i.n	a8, a9, 0
42018c00:	7a7c      	movi.n	a10, -9
42018c02:	1088a0        	and	a8, a8, a10
42018c05:	0020c0        	memw
42018c08:	0989      	s32i.n	a8, a9, 0
42018c0a:	000446        	j	42018c1f <rtc_init+0x543>
            SET_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42018c0d:	a04b91        	l32r	a9, 42000d3c <_stext+0xd1c> (600c0010 <SYSTEM+0x10>)
42018c10:	0020c0        	memw
42018c13:	0988      	l32i.n	a8, a9, 0
42018c15:	8a0c      	movi.n	a10, 8
42018c17:	2088a0        	or	a8, a8, a10
42018c1a:	0020c0        	memw
42018c1d:	0989      	s32i.n	a8, a9, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_UNHOLD);
42018c1f:	a13081        	l32r	a8, 420010e0 <_stext+0x10c0> (60008094 <RTCCNTL+0x94>)
42018c22:	0020c0        	memw
42018c25:	0898      	l32i.n	a9, a8, 0
42018c27:	9d8fa1        	l32r	a10, 42000264 <_stext+0x244> (ffffbfff <_rtc_reserved_end+0x9fefbfff>)
42018c2a:	1099a0        	and	a9, a9, a10
42018c2d:	0020c0        	memw
42018c30:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_NOISO);
42018c32:	0020c0        	memw
42018c35:	0898      	l32i.n	a9, a8, 0
42018c37:	a148a1        	l32r	a10, 42001158 <_stext+0x1138> (ffffefff <_rtc_reserved_end+0x9fefefff>)
42018c3a:	1099a0        	and	a9, a9, a10
42018c3d:	0020c0        	memw
42018c40:	006892        	s32i	a9, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
42018c43:	a12791        	l32r	a9, 420010e0 <_stext+0x10c0> (60008094 <RTCCNTL+0x94>)
42018c46:	0020c0        	memw
42018c49:	0988      	l32i.n	a8, a9, 0
42018c4b:	a0f8a1        	l32r	a10, 4200102c <_stext+0x100c> (10000000 <UserFrameTotalSize+0xfffff00>)
42018c4e:	2088a0        	or	a8, a8, a10
42018c51:	0020c0        	memw
42018c54:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42018c56:	a12091        	l32r	a9, 420010d8 <_stext+0x10b8> (60008090 <RTCCNTL+0x90>)
42018c59:	0020c0        	memw
42018c5c:	0988      	l32i.n	a8, a9, 0
42018c5e:	a0f7a1        	l32r	a10, 4200103c <_stext+0x101c> (20000 <UserFrameTotalSize+0x1ff00>)
42018c61:	2088a0        	or	a8, a8, a10
42018c64:	0020c0        	memw
42018c67:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
42018c69:	9e4b81        	l32r	a8, 42000598 <_stext+0x578> (60008040 <RTCCNTL+0x40>)
42018c6c:	090c      	movi.n	a9, 0
42018c6e:	0020c0        	memw
42018c71:	0899      	s32i.n	a9, a8, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
42018c73:	9e4a81        	l32r	a8, 4200059c <_stext+0x57c> (6000804c <RTCCNTL+0x4c>)
42018c76:	f97c      	movi.n	a9, -1
42018c78:	0020c0        	memw
42018c7b:	0899      	s32i.n	a9, a8, 0
    sar_periph_ctrl_init();
42018c7d:	000065        	call8	42018c84 <sar_periph_ctrl_init>
}
42018c80:	f01d      	retw.n
	...

42018c84 <sar_periph_ctrl_init>:
static const char *TAG = "sar_periph_ctrl";
extern portMUX_TYPE rtc_spinlock;


void sar_periph_ctrl_init(void)
{
42018c84:	004136        	entry	a1, 32
 */
__attribute__((always_inline))
static inline void sar_ctrl_ll_set_power_mode(sar_ctrl_ll_power_t mode)
{
    if (mode == SAR_CTRL_LL_POWER_FSM) {
        SENS.sar_peri_clk_gate_conf.saradc_clk_en = 1;
42018c87:	a13981        	l32r	a8, 4200116c <_stext+0x114c> (60008800 <SENS>)
42018c8a:	0020c0        	memw
42018c8d:	4128a2        	l32i	a10, a8, 0x104
42018c90:	9d3991        	l32r	a9, 42000174 <_stext+0x154> (40000000 <_heap_end>)
42018c93:	209a90        	or	a9, a10, a9
42018c96:	0020c0        	memw
42018c99:	416892        	s32i	a9, a8, 0x104
        SENS.sar_power_xpd_sar.force_xpd_sar = 0x0;
42018c9c:	0020c0        	memw
42018c9f:	f8a8      	l32i.n	a10, a8, 60
42018ca1:	a13391        	l32r	a9, 42001170 <_stext+0x1150> (9fffffff <_rtc_reserved_end+0x3fefffff>)
42018ca4:	109a90        	and	a9, a10, a9
42018ca7:	0020c0        	memw
42018caa:	f899      	s32i.n	a9, a8, 60
    //Put SAR control mux to FSM state
    sar_ctrl_ll_set_power_mode(SAR_CTRL_LL_POWER_FSM);

    //Add other periph power control initialisation here
}
42018cac:	f01d      	retw.n
	...

42018cb0 <esp_sleep_sub_mode_config>:
    assert(refs >= 0);
    return ESP_OK;
}

esp_err_t esp_sleep_sub_mode_config(esp_sleep_sub_mode_t mode, bool activate)
{
42018cb0:	004136        	entry	a1, 32
42018cb3:	743030        	extui	a3, a3, 0, 8
    if (mode >= ESP_SLEEP_MODE_MAX) {
42018cb6:	0282b6        	bltui	a2, 8, 42018cbc <esp_sleep_sub_mode_config+0xc>
42018cb9:	002106        	j	42018d41 <esp_sleep_sub_mode_config+0x91>
    if (xPortInIsrContext()) {
42018cbc:	9dd881        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42018cbf:	0008e0        	callx8	a8
42018cc2:	fa8c      	beqz.n	a10, 42018cd5 <esp_sleep_sub_mode_config+0x25>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42018cc4:	ffafb2        	movi	a11, -1
42018cc7:	a12ba1        	l32r	a10, 42001174 <_stext+0x1154> (3fc924c0 <s_config+0x30>)
42018cca:	9dd981        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42018ccd:	0008e0        	callx8	a8
42018cd0:	000306        	j	42018ce0 <esp_sleep_sub_mode_config+0x30>
42018cd3:	00          	.byte	00
42018cd4:	00          	.byte	00
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42018cd5:	fb7c      	movi.n	a11, -1
42018cd7:	a127a1        	l32r	a10, 42001174 <_stext+0x1154> (3fc924c0 <s_config+0x30>)
42018cda:	9dd581        	l32r	a8, 42000430 <_stext+0x410> (4037a014 <xPortEnterCriticalTimeout>)
42018cdd:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_ARG;
    }

    portENTER_CRITICAL_SAFE(&s_config.lock);
    if (activate) {
42018ce0:	d38c      	beqz.n	a3, 42018cf1 <esp_sleep_sub_mode_config+0x41>
        s_sleep_sub_mode_ref_cnt[mode]++;
42018ce2:	a12581        	l32r	a8, 42001178 <_stext+0x1158> (600fe000 <s_sleep_sub_mode_ref_cnt>)
42018ce5:	a08280        	addx4	a8, a2, a8
42018ce8:	0898      	l32i.n	a9, a8, 0
42018cea:	991b      	addi.n	a9, a9, 1
42018cec:	0899      	s32i.n	a9, a8, 0
42018cee:	000306        	j	42018cfe <esp_sleep_sub_mode_config+0x4e>
    } else {
        s_sleep_sub_mode_ref_cnt[mode]--;
42018cf1:	a12181        	l32r	a8, 42001178 <_stext+0x1158> (600fe000 <s_sleep_sub_mode_ref_cnt>)
42018cf4:	a08280        	addx4	a8, a2, a8
42018cf7:	0898      	l32i.n	a9, a8, 0
42018cf9:	990b      	addi.n	a9, a9, -1
42018cfb:	006892        	s32i	a9, a8, 0
    }
    assert(s_sleep_sub_mode_ref_cnt[mode] >= 0);
42018cfe:	a11e81        	l32r	a8, 42001178 <_stext+0x1158> (600fe000 <s_sleep_sub_mode_ref_cnt>)
42018d01:	a02280        	addx4	a2, a2, a8
42018d04:	002282        	l32i	a8, a2, 0
42018d07:	0118d6        	bgez	a8, 42018d1c <esp_sleep_sub_mode_config+0x6c>
42018d0a:	a11cd1        	l32r	a13, 4200117c <_stext+0x115c> (3c022e30 <_flash_rodata_start+0x2d10>)
42018d0d:	a11cc1        	l32r	a12, 42001180 <_stext+0x1160> (3c026f28 <__func__$5>)
42018d10:	a11db1        	l32r	a11, 42001184 <_stext+0x1164> (93b <UserFrameTotalSize+0x83b>)
42018d13:	a11da1        	l32r	a10, 42001188 <_stext+0x1168> (3c022df4 <_flash_rodata_start+0x2cd4>)
42018d16:	9cfc81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42018d19:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
42018d1c:	9dc081        	l32r	a8, 4200041c <_stext+0x3fc> (40379ff0 <xPortInIsrContext>)
42018d1f:	0008e0        	callx8	a8
42018d22:	0a2d      	mov.n	a2, a10
42018d24:	00da16        	beqz	a10, 42018d35 <esp_sleep_sub_mode_config+0x85>
        portEXIT_CRITICAL_ISR(mux);
42018d27:	a113a1        	l32r	a10, 42001174 <_stext+0x1154> (3fc924c0 <s_config+0x30>)
42018d2a:	9dc281        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42018d2d:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&s_config.lock);
    return ESP_OK;
42018d30:	020c      	movi.n	a2, 0
42018d32:	000386        	j	42018d44 <esp_sleep_sub_mode_config+0x94>
        portEXIT_CRITICAL(mux);
42018d35:	a10fa1        	l32r	a10, 42001174 <_stext+0x1154> (3fc924c0 <s_config+0x30>)
42018d38:	9dbf81        	l32r	a8, 42000434 <_stext+0x414> (4037a164 <vPortExitCritical>)
42018d3b:	0008e0        	callx8	a8
42018d3e:	000086        	j	42018d44 <esp_sleep_sub_mode_config+0x94>
        return ESP_ERR_INVALID_ARG;
42018d41:	02a122        	movi	a2, 0x102
}
42018d44:	f01d      	retw.n
	...

42018d48 <esp_timer_impl_early_init>:
    systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER, time_diff_us);
    portEXIT_CRITICAL_SAFE(&s_time_update_lock);
}

esp_err_t esp_timer_impl_early_init(void)
{
42018d48:	006136        	entry	a1, 48
    PERIPH_RCC_ACQUIRE_ATOMIC(PERIPH_SYSTIMER_MODULE, ref_count) {
42018d4b:	170c      	movi.n	a7, 1
42018d4d:	000f46        	j	42018d8e <esp_timer_impl_early_init+0x46>
    SYSTEM.perip_clk_en0.systimer_clk_en = enable;
42018d50:	9d4181        	l32r	a8, 42000254 <_stext+0x234> (600c0000 <SYSTEM>)
42018d53:	0020c0        	memw
42018d56:	6898      	l32i.n	a9, a8, 24
42018d58:	a001a1        	l32r	a10, 42000d5c <_stext+0xd3c> (20000000 <UserFrameTotalSize+0x1fffff00>)
42018d5b:	2099a0        	or	a9, a9, a10
42018d5e:	0020c0        	memw
42018d61:	6899      	s32i.n	a9, a8, 24
    SYSTEM.perip_rst_en0.systimer_rst = 1;
42018d63:	0020c0        	memw
42018d66:	8898      	l32i.n	a9, a8, 32
42018d68:	2099a0        	or	a9, a9, a10
42018d6b:	0020c0        	memw
42018d6e:	8899      	s32i.n	a9, a8, 32
    SYSTEM.perip_rst_en0.systimer_rst = 0;
42018d70:	0020c0        	memw
42018d73:	8898      	l32i.n	a9, a8, 32
42018d75:	9ffaa1        	l32r	a10, 42000d60 <_stext+0xd40> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42018d78:	1099a0        	and	a9, a9, a10
42018d7b:	0020c0        	memw
42018d7e:	8899      	s32i.n	a9, a8, 32
42018d80:	24a0a2        	movi	a10, 36
42018d83:	9d3c81        	l32r	a8, 42000274 <_stext+0x254> (40378200 <periph_rcc_acquire_exit>)
42018d86:	0008e0        	callx8	a8
42018d89:	770b      	addi.n	a7, a7, -1
42018d8b:	747070        	extui	a7, a7, 0, 8
42018d8e:	e78c      	beqz.n	a7, 42018da0 <esp_timer_impl_early_init+0x58>
42018d90:	4a2c      	movi.n	a10, 36
42018d92:	9d3981        	l32r	a8, 42000278 <_stext+0x258> (403781f0 <periph_rcc_acquire_enter>)
42018d95:	0008e0        	callx8	a8
42018d98:	0abd      	mov.n	a11, a10
        if (ref_count == 0) {
42018d9a:	fb2a16        	beqz	a10, 42018d50 <esp_timer_impl_early_init+0x8>
42018d9d:	fff7c6        	j	42018d80 <esp_timer_impl_early_init+0x38>
            systimer_ll_enable_bus_clock(true);
            systimer_ll_reset_register();
        }
    }
    systimer_hal_tick_rate_ops_t ops = {
42018da0:	a0fb81        	l32r	a8, 4200118c <_stext+0x116c> (3c0263d4 <__FUNCTION__$0+0x20>)
42018da3:	0898      	l32i.n	a9, a8, 0
42018da5:	1888      	l32i.n	a8, a8, 4
42018da7:	0199      	s32i.n	a9, a1, 0
42018da9:	1189      	s32i.n	a8, a1, 4
        .ticks_to_us = systimer_ticks_to_us,
        .us_to_ticks = systimer_us_to_ticks,
    };
    systimer_hal_init(&systimer_hal);
42018dab:	a0f971        	l32r	a7, 42001190 <_stext+0x1170> (3fc94ce0 <systimer_hal>)
42018dae:	07ad      	mov.n	a10, a7
42018db0:	a0f981        	l32r	a8, 42001194 <_stext+0x1174> (4037e318 <systimer_hal_init>)
42018db3:	0008e0        	callx8	a8
    systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
42018db6:	01bd      	mov.n	a11, a1
42018db8:	07ad      	mov.n	a10, a7
42018dba:	a0f781        	l32r	a8, 42001198 <_stext+0x1178> (4037e49c <systimer_hal_set_tick_rate_ops>)
42018dbd:	0008e0        	callx8	a8
           "update the step for xtal to support other XTAL:APB frequency ratios");
    systimer_hal_set_steps_per_tick(&systimer_hal, 0, 2); // for xtal
    systimer_hal_set_steps_per_tick(&systimer_hal, 1, 1); // for pll
#endif

    systimer_hal_enable_counter(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER);
42018dc0:	0b0c      	movi.n	a11, 0
42018dc2:	07ad      	mov.n	a10, a7
42018dc4:	a0f681        	l32r	a8, 4200119c <_stext+0x117c> (4037e4cc <systimer_hal_enable_counter>)
42018dc7:	0008e0        	callx8	a8
    systimer_hal_select_alarm_mode(&systimer_hal, SYSTIMER_ALARM_ESPTIMER, SYSTIMER_ALARM_MODE_ONESHOT);
42018dca:	0c0c      	movi.n	a12, 0
42018dcc:	2b0c      	movi.n	a11, 2
42018dce:	07ad      	mov.n	a10, a7
42018dd0:	a0f481        	l32r	a8, 420011a0 <_stext+0x1180> (4037e45c <systimer_hal_select_alarm_mode>)
42018dd3:	0008e0        	callx8	a8
    systimer_hal_connect_alarm_counter(&systimer_hal, SYSTIMER_ALARM_ESPTIMER, SYSTIMER_COUNTER_ESPTIMER);
42018dd6:	0c0c      	movi.n	a12, 0
42018dd8:	2b0c      	movi.n	a11, 2
42018dda:	07ad      	mov.n	a10, a7
42018ddc:	a0f281        	l32r	a8, 420011a4 <_stext+0x1184> (4037e4f0 <systimer_hal_connect_alarm_counter>)
42018ddf:	0008e0        	callx8	a8

    for (unsigned cpuid = 0; cpuid < SOC_CPU_CORES_NUM; ++cpuid) {
42018de2:	070c      	movi.n	a7, 0
42018de4:	000486        	j	42018dfa <esp_timer_impl_early_init+0xb2>
42018de7:	00          	.byte	00
42018de8:	00          	.byte	00
        bool can_stall = (cpuid < portNUM_PROCESSORS);
        systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_COUNTER_ESPTIMER, cpuid, can_stall);
42018de9:	1d0c      	movi.n	a13, 1
42018deb:	07cd      	mov.n	a12, a7
42018ded:	0b0c      	movi.n	a11, 0
42018def:	a0e8a1        	l32r	a10, 42001190 <_stext+0x1170> (3fc94ce0 <systimer_hal>)
42018df2:	a0ed81        	l32r	a8, 420011a8 <_stext+0x1188> (4037e514 <systimer_hal_counter_can_stall_by_cpu>)
42018df5:	0008e0        	callx8	a8
    for (unsigned cpuid = 0; cpuid < SOC_CPU_CORES_NUM; ++cpuid) {
42018df8:	771b      	addi.n	a7, a7, 1
42018dfa:	eb27b6        	bltui	a7, 2, 42018de9 <esp_timer_impl_early_init+0xa1>
    }

    return ESP_OK;
}
42018dfd:	020c      	movi.n	a2, 0
42018dff:	f01d      	retw.n
42018e01:	000000        	ill

42018e04 <other_cpu_startup_idle_hook_cb>:
static const char* MAIN_TAG = "main_task";

#if !CONFIG_FREERTOS_UNICORE
static volatile bool s_other_cpu_startup_done = false;
static bool other_cpu_startup_idle_hook_cb(void)
{
42018e04:	004136        	entry	a1, 32
    s_other_cpu_startup_done = true;
42018e07:	a0e981        	l32r	a8, 420011ac <_stext+0x118c> (3fc94f9c <s_other_cpu_startup_done>)
42018e0a:	190c      	movi.n	a9, 1
42018e0c:	0020c0        	memw
42018e0f:	004892        	s8i	a9, a8, 0
    return true;
}
42018e12:	120c      	movi.n	a2, 1
42018e14:	f01d      	retw.n
	...

42018e18 <main_task>:
#endif

static void main_task(void* args)
{
42018e18:	006136        	entry	a1, 48
    ESP_LOGI(MAIN_TAG, "Started on CPU%d", (int)xPortGetCoreID());
42018e1b:	9c9181        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42018e1e:	0008e0        	callx8	a8
42018e21:	20daa0        	or	a13, a10, a10
    asm volatile (
42018e24:	03ebf0        	rsr.prid	a15
42018e27:	04fdf0        	extui	a15, a15, 13, 1
42018e2a:	a0e1b1        	l32r	a11, 420011b0 <_stext+0x1190> (3c022eac <_flash_rodata_start+0x2d8c>)
42018e2d:	20ebb0        	or	a14, a11, a11
42018e30:	a0e1c1        	l32r	a12, 420011b4 <_stext+0x1194> (3c022eb8 <_flash_rodata_start+0x2d98>)
42018e33:	03a0a2        	movi	a10, 3
42018e36:	9c9781        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42018e39:	0008e0        	callx8	a8
42018e3c:	03ebb0        	rsr.prid	a11
42018e3f:	04bdb0        	extui	a11, a11, 13, 1
#if !CONFIG_FREERTOS_UNICORE
    // Wait for FreeRTOS initialization to finish on other core, before replacing its startup stack
    esp_register_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42018e42:	40fbb0        	nsau	a11, a11
42018e45:	41b5b0        	srli	a11, a11, 5
42018e48:	a0dca1        	l32r	a10, 420011b8 <_stext+0x1198> (42018e04 <other_cpu_startup_idle_hook_cb>)
42018e4b:	e9be25        	call8	42002a2c <esp_register_freertos_idle_hook_for_cpu>
    while (!s_other_cpu_startup_done) {
42018e4e:	a0d781        	l32r	a8, 420011ac <_stext+0x118c> (3fc94f9c <s_other_cpu_startup_done>)
42018e51:	0020c0        	memw
42018e54:	000882        	l8ui	a8, a8, 0
42018e57:	748080        	extui	a8, a8, 0, 8
42018e5a:	ff0816        	beqz	a8, 42018e4e <main_task+0x36>
42018e5d:	03ebb0        	rsr.prid	a11
42018e60:	04bdb0        	extui	a11, a11, 13, 1
        ;
    }
    esp_deregister_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42018e63:	40fbb0        	nsau	a11, a11
42018e66:	41b5b0        	srli	a11, a11, 5
42018e69:	a0d3a1        	l32r	a10, 420011b8 <_stext+0x1198> (42018e04 <other_cpu_startup_idle_hook_cb>)
42018e6c:	e9c8a5        	call8	42002af8 <esp_deregister_freertos_idle_hook_for_cpu>
#endif

    // [refactor-todo] check if there is a way to move the following block to esp_system startup
    heap_caps_enable_nonos_stack_heaps();
42018e6f:	e9ff25        	call8	42002e60 <heap_caps_enable_nonos_stack_heaps>
    }
#endif

    // Initialize TWDT if configured to do so
#if CONFIG_ESP_TASK_WDT_INIT
    esp_task_wdt_config_t twdt_config = {
42018e72:	cc0c      	movi.n	a12, 12
42018e74:	0b0c      	movi.n	a11, 0
42018e76:	01ad      	mov.n	a10, a1
42018e78:	9d2381        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
42018e7b:	0008e0        	callx8	a8
42018e7e:	a0cf81        	l32r	a8, 420011bc <_stext+0x119c> (1388 <UserFrameTotalSize+0x1288>)
42018e81:	0189      	s32i.n	a8, a1, 0
#if CONFIG_ESP_TASK_WDT_PANIC
        .trigger_panic = true,
#endif
    };
#if CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0
    twdt_config.idle_core_mask |= (1 << 0);
42018e83:	180c      	movi.n	a8, 1
42018e85:	1189      	s32i.n	a8, a1, 4
#endif
#if CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1
    twdt_config.idle_core_mask |= (1 << 1);
42018e87:	380c      	movi.n	a8, 3
42018e89:	1189      	s32i.n	a8, a1, 4
#endif
    ESP_ERROR_CHECK(esp_task_wdt_init(&twdt_config));
42018e8b:	01ad      	mov.n	a10, a1
42018e8d:	f297a5        	call8	4200b808 <esp_task_wdt_init>
42018e90:	0a9c      	beqz.n	a10, 42018ea4 <main_task+0x8c>
42018e92:	a0cbe1        	l32r	a14, 420011c0 <_stext+0x11a0> (3c022ed8 <_flash_rodata_start+0x2db8>)
42018e95:	a0cbd1        	l32r	a13, 420011c4 <_stext+0x11a4> (3c026f88 <__func__$0>)
42018e98:	c7a0c2        	movi	a12, 199
42018e9b:	a0cbb1        	l32r	a11, 420011c8 <_stext+0x11a8> (3c022ef8 <_flash_rodata_start+0x2dd8>)
42018e9e:	9e6581        	l32r	a8, 42000834 <_stext+0x814> (4037967c <_esp_error_check_failed>)
42018ea1:	0008e0        	callx8	a8

    /*
    Note: Be careful when changing the "Calling app_main()" log below as multiple pytest scripts expect this log as a
    start-of-application marker.
    */
    ESP_LOGI(MAIN_TAG, "Calling app_main()");
42018ea4:	360c      	movi.n	a6, 3
42018ea6:	9c6e81        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42018ea9:	0008e0        	callx8	a8
42018eac:	a0c171        	l32r	a7, 420011b0 <_stext+0x1190> (3c022eac <_flash_rodata_start+0x2d8c>)
42018eaf:	07ed      	mov.n	a14, a7
42018eb1:	0add      	mov.n	a13, a10
42018eb3:	a0c6c1        	l32r	a12, 420011cc <_stext+0x11ac> (3c022f20 <_flash_rodata_start+0x2e00>)
42018eb6:	07bd      	mov.n	a11, a7
42018eb8:	06ad      	mov.n	a10, a6
42018eba:	9c7681        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42018ebd:	0008e0        	callx8	a8
    extern void app_main(void);
    app_main();
42018ec0:	ed42e5        	call8	420062f0 <app_main>
    ESP_LOGI(MAIN_TAG, "Returned from app_main()");
42018ec3:	9c6781        	l32r	a8, 42000060 <_stext+0x40> (4037fc04 <esp_log_timestamp>)
42018ec6:	0008e0        	callx8	a8
42018ec9:	07ed      	mov.n	a14, a7
42018ecb:	0add      	mov.n	a13, a10
42018ecd:	a0c0c1        	l32r	a12, 420011d0 <_stext+0x11b0> (3c022f40 <_flash_rodata_start+0x2e20>)
42018ed0:	07bd      	mov.n	a11, a7
42018ed2:	06ad      	mov.n	a10, a6
42018ed4:	9c7081        	l32r	a8, 42000094 <_stext+0x74> (4037fb28 <esp_log>)
42018ed7:	0008e0        	callx8	a8
    vTaskDelete(NULL);
42018eda:	0a0c      	movi.n	a10, 0
42018edc:	a0be81        	l32r	a8, 420011d4 <_stext+0x11b4> (4037b96c <vTaskDelete>)
42018edf:	0008e0        	callx8	a8
}
42018ee2:	f01d      	retw.n

42018ee4 <esp_startup_start_app>:
{
42018ee4:	006136        	entry	a1, 48
    esp_int_wdt_init();
42018ee7:	e8f665        	call8	42001e4c <esp_int_wdt_init>
    esp_int_wdt_cpu_init();
42018eea:	e901a5        	call8	42001f04 <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42018eed:	f23865        	call8	4200b274 <esp_crosscore_int_init>
    BaseType_t res = xTaskCreatePinnedToCore(main_task, "main",
42018ef0:	00a0d2        	movi	a13, 0
42018ef3:	01d9      	s32i.n	a13, a1, 0
42018ef5:	0dfd      	mov.n	a15, a13
42018ef7:	01a0e2        	movi	a14, 1
42018efa:	9ea7c1        	l32r	a12, 42000998 <_stext+0x978> (1000 <UserFrameTotalSize+0xf00>)
42018efd:	a0b6b1        	l32r	a11, 420011d8 <_stext+0x11b8> (3c022f68 <_flash_rodata_start+0x2e48>)
42018f00:	a0b7a1        	l32r	a10, 420011dc <_stext+0x11bc> (42018e18 <main_task>)
42018f03:	9d4181        	l32r	a8, 42000408 <_stext+0x3e8> (4037c4ac <xTaskCreatePinnedToCore>)
42018f06:	0008e0        	callx8	a8
    assert(res == pdTRUE);
42018f09:	101a26        	beqi	a10, 1, 42018f1d <esp_startup_start_app+0x39>
42018f0c:	a0b5d1        	l32r	a13, 420011e0 <_stext+0x11c0> (3c020f98 <_flash_rodata_start+0xe78>)
42018f0f:	a0b5c1        	l32r	a12, 420011e4 <_stext+0x11c4> (3c026f94 <__func__$1>)
42018f12:	6b5c      	movi.n	a11, 86
42018f14:	a0b5a1        	l32r	a10, 420011e8 <_stext+0x11c8> (3c022f8a <_flash_rodata_start+0x2e6a>)
42018f17:	9c7c81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42018f1a:	0008e0        	callx8	a8
    if (port_start_app_hook != NULL) {
42018f1d:	a0b381        	l32r	a8, 420011ec <_stext+0x11cc> (0 <IDF_TARGET_ESP32S3>)
42018f20:	488c      	beqz.n	a8, 42018f28 <esp_startup_start_app+0x44>
        port_start_app_hook();
42018f22:	a0b281        	l32r	a8, 420011ec <_stext+0x11cc> (0 <IDF_TARGET_ESP32S3>)
42018f25:	0008e0        	callx8	a8
    vTaskStartScheduler();
42018f28:	a0b281        	l32r	a8, 420011f0 <_stext+0x11d0> (4037c6b0 <vTaskStartScheduler>)
42018f2b:	0008e0        	callx8	a8
}
42018f2e:	f01d      	retw.n

42018f30 <esp_startup_start_app_other_cores>:
{
42018f30:	004136        	entry	a1, 32
42018f33:	03eb80        	rsr.prid	a8
42018f36:	048d80        	extui	a8, a8, 13, 1
    if (xPortGetCoreID() >= 2) {
42018f39:	0528a6        	blti	a8, 2, 42018f42 <esp_startup_start_app_other_cores+0x12>
        abort();
42018f3c:	9c6881        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42018f3f:	0008e0        	callx8	a8
    while (port_xSchedulerRunning[0] == 0) {
42018f42:	a0ac81        	l32r	a8, 420011f4 <_stext+0x11d4> (3fc95278 <port_xSchedulerRunning>)
42018f45:	0020c0        	memw
42018f48:	0888      	l32i.n	a8, a8, 0
42018f4a:	ff4816        	beqz	a8, 42018f42 <esp_startup_start_app_other_cores+0x12>
    esp_int_wdt_cpu_init();
42018f4d:	e8fb65        	call8	42001f04 <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42018f50:	f23225        	call8	4200b274 <esp_crosscore_int_init>
    xPortStartScheduler();
42018f53:	a0a981        	l32r	a8, 420011f8 <_stext+0x11d8> (40379f2c <xPortStartScheduler>)
42018f56:	0008e0        	callx8	a8
    abort(); // Only get to here if FreeRTOS somehow very broken
42018f59:	9c6081        	l32r	a8, 420000dc <_stext+0xbc> (4037fc6c <abort>)
42018f5c:	0008e0        	callx8	a8
	...

42018f60 <timer_hal_init>:
{
42018f60:	004136        	entry	a1, 32
    hal->dev = TIMER_LL_GET_HW(group_num);
42018f63:	53cc      	bnez.n	a3, 42018f6c <timer_hal_init+0xc>
42018f65:	9e9e81        	l32r	a8, 420009e0 <_stext+0x9c0> (6001f000 <TIMERG0>)
42018f68:	0000c6        	j	42018f6f <timer_hal_init+0xf>
42018f6b:	00          	.byte	00
42018f6c:	9cbd81        	l32r	a8, 42000260 <_stext+0x240> (60020000 <TIMERG1>)
42018f6f:	0289      	s32i.n	a8, a2, 0
    hal->timer_id = timer_num;
42018f71:	1249      	s32i.n	a4, a2, 4
    hw->hw_timer[timer_num].config.tn_en = en;
42018f73:	b09440        	addx8	a9, a4, a4
42018f76:	a09980        	addx4	a9, a9, a8
42018f79:	0020c0        	memw
42018f7c:	0988      	l32i.n	a8, a9, 0
42018f7e:	888a      	add.n	a8, a8, a8
42018f80:	418180        	srli	a8, a8, 1
42018f83:	0020c0        	memw
42018f86:	0989      	s32i.n	a8, a9, 0
    timer_ll_enable_auto_reload(hal->dev, timer_num, false);
42018f88:	0298      	l32i.n	a9, a2, 0
    hw->hw_timer[timer_num].config.tn_autoreload = en;
42018f8a:	b08440        	addx8	a8, a4, a4
42018f8d:	a08890        	addx4	a8, a8, a9
42018f90:	0020c0        	memw
42018f93:	0898      	l32i.n	a9, a8, 0
42018f95:	9f72a1        	l32r	a10, 42000d60 <_stext+0xd40> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42018f98:	1099a0        	and	a9, a9, a10
42018f9b:	0020c0        	memw
42018f9e:	0899      	s32i.n	a9, a8, 0
    timer_ll_enable_alarm(hal->dev, timer_num, false);
42018fa0:	0288      	l32i.n	a8, a2, 0
    hw->hw_timer[timer_num].config.tn_alarm_en = en;
42018fa2:	b04440        	addx8	a4, a4, a4
42018fa5:	a04480        	addx4	a4, a4, a8
42018fa8:	0020c0        	memw
42018fab:	0488      	l32i.n	a8, a4, 0
42018fad:	ffab92        	movi	a9, 0xfffffbff
42018fb0:	108890        	and	a8, a8, a9
42018fb3:	0020c0        	memw
42018fb6:	0489      	s32i.n	a8, a4, 0
}
42018fb8:	f01d      	retw.n
	...

42018fbc <timer_hal_deinit>:
{
42018fbc:	004136        	entry	a1, 32
    timer_ll_enable_counter(hal->dev, hal->timer_id, false);
42018fbf:	0298      	l32i.n	a9, a2, 0
42018fc1:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].config.tn_en = en;
42018fc3:	b08880        	addx8	a8, a8, a8
42018fc6:	a08890        	addx4	a8, a8, a9
42018fc9:	0020c0        	memw
42018fcc:	0898      	l32i.n	a9, a8, 0
42018fce:	999a      	add.n	a9, a9, a9
42018fd0:	419190        	srli	a9, a9, 1
42018fd3:	0020c0        	memw
42018fd6:	0899      	s32i.n	a9, a8, 0
    timer_ll_enable_auto_reload(hal->dev, hal->timer_id, false);
42018fd8:	0298      	l32i.n	a9, a2, 0
42018fda:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].config.tn_autoreload = en;
42018fdc:	b08880        	addx8	a8, a8, a8
42018fdf:	a08890        	addx4	a8, a8, a9
42018fe2:	0020c0        	memw
42018fe5:	0898      	l32i.n	a9, a8, 0
42018fe7:	9f5ea1        	l32r	a10, 42000d60 <_stext+0xd40> (dfffffff <_rtc_reserved_end+0x7fefffff>)
42018fea:	1099a0        	and	a9, a9, a10
42018fed:	0020c0        	memw
42018ff0:	0899      	s32i.n	a9, a8, 0
    timer_ll_enable_alarm(hal->dev, hal->timer_id, false);
42018ff2:	0298      	l32i.n	a9, a2, 0
42018ff4:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].config.tn_alarm_en = en;
42018ff6:	b08880        	addx8	a8, a8, a8
42018ff9:	a08890        	addx4	a8, a8, a9
42018ffc:	0020c0        	memw
42018fff:	0898      	l32i.n	a9, a8, 0
42019001:	ffaba2        	movi	a10, 0xfffffbff
42019004:	1099a0        	and	a9, a9, a10
42019007:	0020c0        	memw
4201900a:	0899      	s32i.n	a9, a8, 0
    hal->dev = NULL;
4201900c:	080c      	movi.n	a8, 0
4201900e:	0289      	s32i.n	a8, a2, 0
}
42019010:	f01d      	retw.n
	...

42019014 <timer_hal_set_counter_value>:
{
42019014:	004136        	entry	a1, 32
    uint64_t old_reload = timer_ll_get_reload_value(hal->dev, hal->timer_id);
42019017:	02b8      	l32i.n	a11, a2, 0
42019019:	1288      	l32i.n	a8, a2, 4
    return ((uint64_t)hw->hw_timer[timer_num].loadhi.tn_load_hi << 32) | (hw->hw_timer[timer_num].loadlo.tn_load_lo);
4201901b:	b09880        	addx8	a9, a8, a8
4201901e:	a099b0        	addx4	a9, a9, a11
42019021:	10c9e2        	addi	a14, a9, 16
42019024:	0020c0        	memw
42019027:	79d8      	l32i.n	a13, a9, 28
42019029:	0020c0        	memw
4201902c:	69a8      	l32i.n	a10, a9, 24
    hw->hw_timer[timer_num].loadhi.tn_load_hi = (uint32_t)(reload_val >> 32);
4201902e:	0020c0        	memw
42019031:	7998      	l32i.n	a9, a9, 28
42019033:	115560        	slli	a5, a5, 10
42019036:	415a50        	srli	a5, a5, 10
42019039:	a070c1        	l32r	a12, 420011fc <_stext+0x11dc> (ffc00000 <_rtc_reserved_end+0x9fb00000>)
4201903c:	1099c0        	and	a9, a9, a12
4201903f:	209950        	or	a9, a9, a5
42019042:	0020c0        	memw
42019045:	3e99      	s32i.n	a9, a14, 12
    hw->hw_timer[timer_num].loadlo.tn_load_lo = (uint32_t)reload_val;
42019047:	b08880        	addx8	a8, a8, a8
4201904a:	a088b0        	addx4	a8, a8, a11
4201904d:	0020c0        	memw
42019050:	6849      	s32i.n	a4, a8, 24
    timer_ll_trigger_soft_reload(hal->dev, hal->timer_id);
42019052:	0298      	l32i.n	a9, a2, 0
42019054:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].load.tn_load = 1;
42019056:	b08880        	addx8	a8, a8, a8
42019059:	a08890        	addx4	a8, a8, a9
4201905c:	190c      	movi.n	a9, 1
4201905e:	0020c0        	memw
42019061:	8899      	s32i.n	a9, a8, 32
    timer_ll_set_reload_value(hal->dev, hal->timer_id, old_reload);
42019063:	02e8      	l32i.n	a14, a2, 0
42019065:	1288      	l32i.n	a8, a2, 4
    hw->hw_timer[timer_num].loadhi.tn_load_hi = (uint32_t)(reload_val >> 32);
42019067:	11dd60        	slli	a13, a13, 10
4201906a:	41dad0        	srli	a13, a13, 10
4201906d:	b09880        	addx8	a9, a8, a8
42019070:	a099e0        	addx4	a9, a9, a14
42019073:	0020c0        	memw
42019076:	79b8      	l32i.n	a11, a9, 28
42019078:	10bbc0        	and	a11, a11, a12
4201907b:	20bbd0        	or	a11, a11, a13
4201907e:	0020c0        	memw
42019081:	79b9      	s32i.n	a11, a9, 28
    hw->hw_timer[timer_num].loadlo.tn_load_lo = (uint32_t)reload_val;
42019083:	b08880        	addx8	a8, a8, a8
42019086:	a088e0        	addx4	a8, a8, a14
42019089:	0020c0        	memw
4201908c:	68a9      	s32i.n	a10, a8, 24
}
4201908e:	f01d      	retw.n

42019090 <multi_heap_register>:
{
42019090:	004136        	entry	a1, 32
42019093:	027d      	mov.n	a7, a2
    assert(start_ptr);
42019095:	02dc      	bnez.n	a2, 420190a9 <multi_heap_register+0x19>
42019097:	a05ad1        	l32r	a13, 42001200 <_stext+0x11e0> (3c021790 <_flash_rodata_start+0x1670>)
4201909a:	a05ac1        	l32r	a12, 42001204 <_stext+0x11e4> (3c0268ac <__func__$0>)
4201909d:	8ca0b2        	movi	a11, 140
420190a0:	a05aa1        	l32r	a10, 42001208 <_stext+0x11e8> (3c0217b2 <_flash_rodata_start+0x1692>)
420190a3:	9c1981        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420190a6:	0008e0        	callx8	a8
    if(size < (sizeof(heap_t))) {
420190a9:	381c      	movi.n	a8, 19
420190ab:	2bb837        	bgeu	a8, a3, 420190da <multi_heap_register+0x4a>
    size -= sizeof(heap_t);
420190ae:	ecc332        	addi	a3, a3, -20
    result->heap_data = tlsf_create_with_pool(start_ptr + sizeof(heap_t), size, max_bytes);
420190b1:	0c0c      	movi.n	a12, 0
420190b3:	03bd      	mov.n	a11, a3
420190b5:	14c2a2        	addi	a10, a2, 20
420190b8:	004d65        	call8	42019590 <tlsf_create_with_pool>
420190bb:	0a2d      	mov.n	a2, a10
420190bd:	47a9      	s32i.n	a10, a7, 16
    if(!result->heap_data) {
420190bf:	9a9c      	beqz.n	a10, 420190dc <multi_heap_register+0x4c>
    result->lock = NULL;
420190c1:	080c      	movi.n	a8, 0
420190c3:	006782        	s32i	a8, a7, 0
    result->free_bytes = size - tlsf_size(result->heap_data);
420190c6:	a05181        	l32r	a8, 4200120c <_stext+0x11ec> (4037fb18 <tlsf_size>)
420190c9:	0008e0        	callx8	a8
420190cc:	c0a3a0        	sub	a10, a3, a10
420190cf:	17a9      	s32i.n	a10, a7, 4
    result->pool_size = size;
420190d1:	3739      	s32i.n	a3, a7, 12
    result->minimum_free_bytes = result->free_bytes;
420190d3:	27a9      	s32i.n	a10, a7, 8
    return result;
420190d5:	072d      	mov.n	a2, a7
420190d7:	000046        	j	420190dc <multi_heap_register+0x4c>
        return NULL;
420190da:	020c      	movi.n	a2, 0
}
420190dc:	f01d      	retw.n
	...

420190e0 <multi_heap_get_info>:
    info->total_blocks++;
    return true;
}

void multi_heap_get_info_impl(multi_heap_handle_t heap, multi_heap_info_t *info)
{
420190e0:	004136        	entry	a1, 32
    uint32_t overhead;

    memset(info, 0, sizeof(multi_heap_info_t));
420190e3:	cc1c      	movi.n	a12, 28
420190e5:	0b0c      	movi.n	a11, 0
420190e7:	03ad      	mov.n	a10, a3
420190e9:	9c8681        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420190ec:	0008e0        	callx8	a8

    if (heap == NULL) {
420190ef:	053216        	beqz	a2, 42019146 <multi_heap_get_info+0x66>
        return;
    }

    multi_heap_internal_lock(heap);
420190f2:	20a220        	or	a10, a2, a2
420190f5:	a04781        	l32r	a8, 42001214 <_stext+0x11f4> (4037e6a0 <multi_heap_internal_lock>)
420190f8:	0008e0        	callx8	a8
    tlsf_walk_pool(tlsf_get_pool(heap->heap_data), multi_heap_get_info_tlsf, info);
420190fb:	42a8      	l32i.n	a10, a2, 16
420190fd:	a04681        	l32r	a8, 42001218 <_stext+0x11f8> (4037ebb0 <tlsf_get_pool>)
42019100:	0008e0        	callx8	a8
42019103:	03cd      	mov.n	a12, a3
42019105:	a042b1        	l32r	a11, 42001210 <_stext+0x11f0> (42019148 <multi_heap_get_info_tlsf>)
42019108:	001fa5        	call8	42019304 <tlsf_walk_pool>
    /* TLSF has an overhead per block. Calculate the total amount of overhead, it shall not be
     * part of the allocated bytes */
    overhead = info->allocated_blocks * tlsf_alloc_overhead();
4201910b:	4368      	l32i.n	a6, a3, 16
4201910d:	a04381        	l32r	a8, 4200121c <_stext+0x11fc> (4037e7ac <tlsf_alloc_overhead>)
42019110:	0008e0        	callx8	a8
42019113:	8266a0        	mull	a6, a6, a10
    info->total_allocated_bytes = (heap->pool_size - tlsf_size(heap->heap_data)) - heap->free_bytes - overhead;
42019116:	3278      	l32i.n	a7, a2, 12
42019118:	42a8      	l32i.n	a10, a2, 16
4201911a:	a03c81        	l32r	a8, 4200120c <_stext+0x11ec> (4037fb18 <tlsf_size>)
4201911d:	0008e0        	callx8	a8
42019120:	c0a7a0        	sub	a10, a7, a10
42019123:	1288      	l32i.n	a8, a2, 4
42019125:	c0aa80        	sub	a10, a10, a8
42019128:	c0aa60        	sub	a10, a10, a6
4201912b:	13a9      	s32i.n	a10, a3, 4
    info->minimum_free_bytes = heap->minimum_free_bytes;
4201912d:	2288      	l32i.n	a8, a2, 8
4201912f:	3389      	s32i.n	a8, a3, 12
    info->total_free_bytes = heap->free_bytes;
42019131:	1288      	l32i.n	a8, a2, 4
42019133:	0389      	s32i.n	a8, a3, 0
    info->largest_free_block = tlsf_fit_size(heap->heap_data, info->largest_free_block);
42019135:	23b8      	l32i.n	a11, a3, 8
42019137:	42a8      	l32i.n	a10, a2, 16
42019139:	002225        	call8	4201935c <tlsf_fit_size>
4201913c:	23a9      	s32i.n	a10, a3, 8
    multi_heap_internal_unlock(heap);
4201913e:	02ad      	mov.n	a10, a2
42019140:	a03881        	l32r	a8, 42001220 <_stext+0x1200> (4037e6c4 <multi_heap_internal_unlock>)
42019143:	0008e0        	callx8	a8
}
42019146:	f01d      	retw.n

42019148 <multi_heap_get_info_tlsf>:
{
42019148:	004136        	entry	a1, 32
    if(used) {
4201914b:	748c      	beqz.n	a4, 42019156 <multi_heap_get_info_tlsf+0xe>
        info->allocated_blocks++;
4201914d:	4588      	l32i.n	a8, a5, 16
4201914f:	881b      	addi.n	a8, a8, 1
42019151:	4589      	s32i.n	a8, a5, 16
42019153:	000346        	j	42019164 <multi_heap_get_info_tlsf+0x1c>
        info->free_blocks++;
42019156:	5588      	l32i.n	a8, a5, 20
42019158:	881b      	addi.n	a8, a8, 1
4201915a:	5589      	s32i.n	a8, a5, 20
        if(size > info->largest_free_block ) {
4201915c:	2588      	l32i.n	a8, a5, 8
4201915e:	02b837        	bgeu	a8, a3, 42019164 <multi_heap_get_info_tlsf+0x1c>
            info->largest_free_block = size;
42019161:	026532        	s32i	a3, a5, 8
    info->total_blocks++;
42019164:	6588      	l32i.n	a8, a5, 24
42019166:	881b      	addi.n	a8, a8, 1
42019168:	6589      	s32i.n	a8, a5, 24
}
4201916a:	120c      	movi.n	a2, 1
4201916c:	f01d      	retw.n
	...

42019170 <control_construct>:
{
42019170:	004136        	entry	a1, 32
	if (bytes < sizeof(control_t))
42019173:	382c      	movi.n	a8, 35
42019175:	023837        	bltu	a8, a3, 4201917b <control_construct+0xb>
42019178:	005646        	j	420192d5 <control_construct+0x165>
	control->fl_index_max = 32 - __builtin_clz(bytes);
4201917b:	40f390        	nsau	a9, a3
4201917e:	e0c992        	addi	a9, a9, -32
42019181:	609090        	neg	a9, a9
42019184:	748090        	extui	a8, a9, 0, 8
42019187:	549090        	extui	a9, a9, 0, 6
4201918a:	119980        	slli	a9, a9, 8
4201918d:	42a8      	l32i.n	a10, a2, 16
4201918f:	a025b1        	l32r	a11, 42001224 <_stext+0x1204> (ffffc0ff <_rtc_reserved_end+0x9fefc0ff>)
42019192:	10aab0        	and	a10, a10, a11
42019195:	209a90        	or	a9, a10, a9
42019198:	4299      	s32i.n	a9, a2, 16
	if (bytes <= 16 * 1024) control->sl_index_count_log2 = 3;
4201919a:	9c2891        	l32r	a9, 4200023c <_stext+0x21c> (4000 <UserFrameTotalSize+0x3f00>)
4201919d:	133937        	bltu	a9, a3, 420191b4 <control_construct+0x44>
420191a0:	4298      	l32i.n	a9, a2, 16
420191a2:	a021a1        	l32r	a10, 42001228 <_stext+0x1208> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
420191a5:	1099a0        	and	a9, a9, a10
420191a8:	a021a1        	l32r	a10, 4200122c <_stext+0x120c> (300000 <UserFrameTotalSize+0x2fff00>)
420191ab:	2099a0        	or	a9, a9, a10
420191ae:	4299      	s32i.n	a9, a2, 16
420191b0:	000a46        	j	420191dd <control_construct+0x6d>
420191b3:	a09100        	addx4	a9, a1, a0
	else if (bytes <= 256 * 1024) control->sl_index_count_log2 = 4;
420191b6:	1239379f 	ee.vmulas.s16.qacc.ld.ip.qup	q5, a9, 112, q4, q6, q3, q1
420191ba:	4298      	l32i.n	a9, a2, 16
420191bc:	a01ba1        	l32r	a10, 42001228 <_stext+0x1208> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
420191bf:	1099a0        	and	a9, a9, a10
420191c2:	a01ba1        	l32r	a10, 42001230 <_stext+0x1210> (400000 <UserFrameTotalSize+0x3fff00>)
420191c5:	2099a0        	or	a9, a9, a10
420191c8:	4299      	s32i.n	a9, a2, 16
420191ca:	0003c6        	j	420191dd <control_construct+0x6d>
	else control->sl_index_count_log2 = 5;
420191cd:	4298      	l32i.n	a9, a2, 16
420191cf:	a016a1        	l32r	a10, 42001228 <_stext+0x1208> (ff8fffff <_rtc_reserved_end+0x9f7fffff>)
420191d2:	1099a0        	and	a9, a9, a10
420191d5:	a017a1        	l32r	a10, 42001234 <_stext+0x1214> (500000 <UserFrameTotalSize+0x4fff00>)
420191d8:	2099a0        	or	a9, a9, a10
420191db:	4299      	s32i.n	a9, a2, 16
	control->fl_index_shift = (control->sl_index_count_log2 + ALIGN_SIZE_LOG2);
420191dd:	4298      	l32i.n	a9, a2, 16
420191df:	25a490        	extui	a10, a9, 20, 3
420191e2:	ea2b      	addi.n	a14, a10, 2
420191e4:	24c0e0        	extui	a12, a14, 0, 3
420191e7:	11bcb0        	slli	a11, a12, 5
420191ea:	1fafd2        	movi	a13, -225
420191ed:	1099d0        	and	a9, a9, a13
420191f0:	2099b0        	or	a9, a9, a11
420191f3:	4299      	s32i.n	a9, a2, 16
	control->sl_index_count = 1 << control->sl_index_count_log2;
420191f5:	1b0c      	movi.n	a11, 1
420191f7:	401a00        	ssl	a10
420191fa:	a1ab00        	sll	a10, a11
420191fd:	54d0a0        	extui	a13, a10, 0, 6
42019200:	11fd20        	slli	a15, a13, 14
42019203:	a00d71        	l32r	a7, 42001238 <_stext+0x1218> (fff03fff <_rtc_reserved_end+0x9fe03fff>)
42019206:	109970        	and	a9, a9, a7
42019209:	2099f0        	or	a9, a9, a15
4201920c:	4299      	s32i.n	a9, a2, 16
	control->fl_index_count = control->fl_index_max - control->fl_index_shift + 1;
4201920e:	548080        	extui	a8, a8, 0, 6
42019211:	c088c0        	sub	a8, a8, a12
42019214:	748080        	extui	a8, a8, 0, 8
42019217:	88ba      	add.n	a8, a8, a11
42019219:	44e080        	extui	a14, a8, 0, 5
4201921c:	0f6c      	movi.n	a15, -32
4201921e:	1099f0        	and	a9, a9, a15
42019221:	2089e0        	or	a8, a9, a14
42019224:	4289      	s32i.n	a8, a2, 16
	control->small_block_size = 1 << control->fl_index_shift;
42019226:	401c00        	ssl	a12
42019229:	a1bb00        	sll	a11, a11
4201922c:	7490b0        	extui	a9, a11, 0, 8
4201922f:	019990        	slli	a9, a9, 23
42019232:	a002c1        	l32r	a12, 4200123c <_stext+0x121c> (807fffff <_rtc_reserved_end+0x206fffff>)
42019235:	1088c0        	and	a8, a8, a12
42019238:	208890        	or	a8, a8, a9
4201923b:	4289      	s32i.n	a8, a2, 16
										(sizeof(*control->blocks) * (control->fl_index_count * control->sl_index_count));
4201923d:	828ed0        	mull	a8, a14, a13
	control->size = sizeof(control_t) + (sizeof(*control->sl_bitmap) * control->fl_index_count) +
42019240:	88ea      	add.n	a8, a8, a14
42019242:	889b      	addi.n	a8, a8, 9
42019244:	1188e0        	slli	a8, a8, 2
42019247:	5289      	s32i.n	a8, a2, 20
	if (bytes < control->size + block_size_min)
42019249:	88cb      	addi.n	a8, a8, 12
4201924b:	02b387        	bgeu	a3, a8, 42019251 <control_construct+0xe1>
4201924e:	002206        	j	420192da <control_construct+0x16a>
	control->block_null.next_free = &control->block_null;
42019251:	02cd      	mov.n	a12, a2
42019253:	2229      	s32i.n	a2, a2, 8
	control->block_null.prev_free = &control->block_null;
42019255:	3229      	s32i.n	a2, a2, 12
	control->fl_bitmap = 0;
42019257:	080c      	movi.n	a8, 0
42019259:	6289      	s32i.n	a8, a2, 24
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4201925b:	27c282        	addi	a8, a2, 39
4201925e:	c97c      	movi.n	a9, -4
42019260:	108890        	and	a8, a8, a9
	control->sl_bitmap = align_ptr(control + 1, sizeof(*control->sl_bitmap));
42019263:	7289      	s32i.n	a8, a2, 28
	control->blocks = align_ptr(control->sl_bitmap + control->fl_index_count, sizeof(*control->blocks));
42019265:	a08e80        	addx4	a8, a14, a8
42019268:	883b      	addi.n	a8, a8, 3
4201926a:	108890        	and	a8, a8, a9
4201926d:	8289      	s32i.n	a8, a2, 32
	tlsf_assert(sizeof(unsigned int) * CHAR_BIT >= control->sl_index_count
4201926f:	082c      	movi.n	a8, 32
42019271:	10b8d7        	bgeu	a8, a13, 42019285 <control_construct+0x115>
42019274:	9ff3d1        	l32r	a13, 42001240 <_stext+0x1220> (3c0217d0 <_flash_rodata_start+0x16b0>)
42019277:	9ff3c1        	l32r	a12, 42001244 <_stext+0x1224> (3c02699c <__func__$13>)
4201927a:	bb4c      	movi.n	a11, 75
4201927c:	9ff3a1        	l32r	a10, 42001248 <_stext+0x1228> (3c02184f <_flash_rodata_start+0x172f>)
4201927f:	9ba281        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42019282:	0008e0        	callx8	a8
	tlsf_assert(ALIGN_SIZE == control->small_block_size / control->sl_index_count); //ALIGN_SIZE does not match");
42019285:	74b0b0        	extui	a11, a11, 0, 8
42019288:	d28bd0        	quos	a8, a11, a13
4201928b:	394826        	beqi	a8, 4, 420192c8 <control_construct+0x158>
4201928e:	9fefd1        	l32r	a13, 4200124c <_stext+0x122c> (3c021858 <_flash_rodata_start+0x1738>)
42019291:	9fecc1        	l32r	a12, 42001244 <_stext+0x1224> (3c02699c <__func__$13>)
42019294:	4fa0b2        	movi	a11, 79
42019297:	9feca1        	l32r	a10, 42001248 <_stext+0x1228> (3c02184f <_flash_rodata_start+0x172f>)
4201929a:	9b9b81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4201929d:	0008e0        	callx8	a8
		control->sl_bitmap[i] = 0;
420192a0:	7288      	l32i.n	a8, a2, 28
420192a2:	a08b80        	addx4	a8, a11, a8
420192a5:	090c      	movi.n	a9, 0
420192a7:	0899      	s32i.n	a9, a8, 0
		for (int j = 0; j < control->sl_index_count; ++j)
420192a9:	000346        	j	420192ba <control_construct+0x14a>
			control->blocks[i * control->sl_index_count + j] = &control->block_null;
420192ac:	82a8      	l32i.n	a10, a2, 32
420192ae:	8288b0        	mull	a8, a8, a11
420192b1:	889a      	add.n	a8, a8, a9
420192b3:	a088a0        	addx4	a8, a8, a10
420192b6:	08c9      	s32i.n	a12, a8, 0
		for (int j = 0; j < control->sl_index_count; ++j)
420192b8:	991b      	addi.n	a9, a9, 1
420192ba:	4288      	l32i.n	a8, a2, 16
420192bc:	548e80        	extui	a8, a8, 14, 6
420192bf:	e92987        	blt	a9, a8, 420192ac <control_construct+0x13c>
	for (int i = 0; i < control->fl_index_count; ++i)
420192c2:	bb1b      	addi.n	a11, a11, 1
420192c4:	000086        	j	420192ca <control_construct+0x15a>
420192c7:	00          	.byte	00
420192c8:	0b0c      	movi.n	a11, 0
420192ca:	4288      	l32i.n	a8, a2, 16
420192cc:	448080        	extui	a8, a8, 0, 5
420192cf:	cd2b87        	blt	a11, a8, 420192a0 <control_construct+0x130>
420192d2:	000186        	j	420192dc <control_construct+0x16c>
		return NULL;
420192d5:	020c      	movi.n	a2, 0
420192d7:	000046        	j	420192dc <control_construct+0x16c>
		return NULL;
420192da:	020c      	movi.n	a2, 0
}
420192dc:	f01d      	retw.n
	...

420192e0 <default_walker>:
{
420192e0:	004136        	entry	a1, 32
420192e3:	02bd      	mov.n	a11, a2
420192e5:	03dd      	mov.n	a13, a3
	printf("\t%p %s size: %x (%p)\n", ptr, used ? "used" : "free", (unsigned int)size, block_from_ptr(ptr));
420192e7:	648c      	beqz.n	a4, 420192f1 <default_walker+0x11>
420192e9:	9fd9c1        	l32r	a12, 42001250 <_stext+0x1230> (3c02189c <_flash_rodata_start+0x177c>)
420192ec:	000106        	j	420192f4 <default_walker+0x14>
420192ef:	c10000        	mul16u	a0, a0, a0
420192f2:	9fd8      	l32i.n	a13, a15, 36
420192f4:	f8cbe2        	addi	a14, a11, -8
420192f7:	9fd8a1        	l32r	a10, 42001258 <_stext+0x1238> (3c0218ac <_flash_rodata_start+0x178c>)
420192fa:	f3e8a5        	call8	4200d184 <printf>
}
420192fd:	120c      	movi.n	a2, 1
420192ff:	f01d      	retw.n
42019301:	000000        	ill

42019304 <tlsf_walk_pool>:
{
42019304:	004136        	entry	a1, 32
	tlsf_walker pool_walker = walker ? walker : default_walker;
42019307:	13cc      	bnez.n	a3, 4201930c <tlsf_walk_pool+0x8>
42019309:	9fd431        	l32r	a3, 4200125c <_stext+0x123c> (420192e0 <default_walker>)
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4201930c:	fcc272        	addi	a7, a2, -4
	bool ret_val = true;
4201930f:	1a0c      	movi.n	a10, 1
	while (block && !block_is_last(block) && ret_val == true)
42019311:	000ec6        	j	42019350 <tlsf_walk_pool+0x4c>
	return tlsf_cast(void*,
42019314:	678b      	addi.n	a6, a7, 8
		ret_val = pool_walker(
42019316:	04c080        	extui	a12, a8, 0, 1
42019319:	04dd      	mov.n	a13, a4
4201931b:	190c      	movi.n	a9, 1
4201931d:	30cc90        	xor	a12, a12, a9
42019320:	cb7c      	movi.n	a11, -4
42019322:	10b8b0        	and	a11, a8, a11
42019325:	06ad      	mov.n	a10, a6
42019327:	0003e0        	callx8	a3
		if (ret_val == true) {
4201932a:	2aac      	beqz.n	a10, 42019350 <tlsf_walk_pool+0x4c>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4201932c:	1788      	l32i.n	a8, a7, 4
4201932e:	c77c      	movi.n	a7, -4
42019330:	107870        	and	a7, a8, a7
	block_header_t* next = offset_to_block(block_to_ptr(block),
42019333:	fcc772        	addi	a7, a7, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42019336:	807760        	add	a7, a7, a6
	tlsf_assert(!block_is_last(block));
42019339:	390c      	movi.n	a9, 3
4201933b:	113987        	bltu	a9, a8, 42019350 <tlsf_walk_pool+0x4c>
4201933e:	9fc8d1        	l32r	a13, 42001260 <_stext+0x1240> (3c0218c4 <_flash_rodata_start+0x17a4>)
42019341:	9fc8c1        	l32r	a12, 42001264 <_stext+0x1244> (3c0269f0 <__func__$20>)
42019344:	a1a0b2        	movi	a11, 161
42019347:	9fc8a1        	l32r	a10, 42001268 <_stext+0x1248> (3c0218f7 <_flash_rodata_start+0x17d7>)
4201934a:	9b6f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
4201934d:	0008e0        	callx8	a8
	while (block && !block_is_last(block) && ret_val == true)
42019350:	678c      	beqz.n	a7, 4201935a <tlsf_walk_pool+0x56>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42019352:	1788      	l32i.n	a8, a7, 4
42019354:	0248b6        	bltui	a8, 4, 4201935a <tlsf_walk_pool+0x56>
42019357:	fb9a56        	bnez	a10, 42019314 <tlsf_walk_pool+0x10>
}
4201935a:	f01d      	retw.n

4201935c <tlsf_fit_size>:
{
4201935c:	004136        	entry	a1, 32
	if (size == 0 || tlsf == NULL) {
4201935f:	40f380        	nsau	a8, a3
42019362:	418580        	srli	a8, a8, 5
42019365:	40f290        	nsau	a9, a2
42019368:	419590        	srli	a9, a9, 5
4201936b:	208890        	or	a8, a8, a9
4201936e:	054856        	bnez	a8, 420193c6 <tlsf_fit_size+0x6a>
	if (size < control->small_block_size) {
42019371:	4288      	l32i.n	a8, a2, 16
42019373:	758780        	extui	a8, a8, 23, 8
42019376:	2fb387        	bgeu	a3, a8, 420193a9 <tlsf_fit_size+0x4d>
	if (size)
42019379:	73ac      	beqz.n	a3, 420193a4 <tlsf_fit_size+0x48>
	return (x + (align - 1)) & ~(align - 1);
4201937b:	333b      	addi.n	a3, a3, 3
4201937d:	c87c      	movi.n	a8, -4
4201937f:	103380        	and	a3, a3, a8
	if (control == NULL)
42019382:	629c      	beqz.n	a2, 4201939c <tlsf_fit_size+0x40>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
42019384:	4298      	l32i.n	a9, a2, 16
42019386:	549890        	extui	a9, a9, 8, 6
42019389:	180c      	movi.n	a8, 1
4201938b:	401900        	ssl	a9
4201938e:	a18800        	sll	a8, a8
		if (aligned < tlsf_block_size_max(control)) 
42019391:	0db387        	bgeu	a3, a8, 420193a2 <tlsf_fit_size+0x46>
			adjust = tlsf_max(aligned, block_size_min);
42019394:	c80c      	movi.n	a8, 12
42019396:	733380        	maxu	a3, a3, a8
42019399:	0001c6        	j	420193a4 <tlsf_fit_size+0x48>
	size_t adjust = 0;
4201939c:	030c      	movi.n	a3, 0
4201939e:	000086        	j	420193a4 <tlsf_fit_size+0x48>
420193a1:	030c00        	rsr.scompare1	a0
		return adjust_request_size(tlsf, size, ALIGN_SIZE);
420193a4:	032d      	mov.n	a2, a3
420193a6:	000786        	j	420193c8 <tlsf_fit_size+0x6c>
	sl_interval = (1 << (32 - __builtin_clz(size) - 1)) / control->sl_index_count;
420193a9:	40f390        	nsau	a9, a3
420193ac:	9d2e81        	l32r	a8, 42000864 <_stext+0x844> (80000000 <_rtc_reserved_end+0x1ff00000>)
420193af:	400900        	ssr	a9
420193b2:	918080        	srl	a8, a8
420193b5:	4298      	l32i.n	a9, a2, 16
420193b7:	549e90        	extui	a9, a9, 14, 6
420193ba:	d28890        	quos	a8, a8, a9
	return size & ~(sl_interval - 1);
420193bd:	608080        	neg	a8, a8
420193c0:	102830        	and	a2, a8, a3
420193c3:	000046        	j	420193c8 <tlsf_fit_size+0x6c>
		return 0;
420193c6:	020c      	movi.n	a2, 0
}
420193c8:	f01d      	retw.n
	...

420193cc <tlsf_add_pool>:
{
420193cc:	004136        	entry	a1, 32
	const size_t pool_overhead = tlsf_pool_overhead();
420193cf:	001ee5        	call8	420195bc <tlsf_pool_overhead>
	const size_t pool_bytes = align_down(bytes - pool_overhead, ALIGN_SIZE);
420193d2:	c044a0        	sub	a4, a4, a10
	return x - (x & (align - 1));
420193d5:	fcaf82        	movi	a8, -4
420193d8:	108480        	and	a8, a4, a8
	if (((ptrdiff_t)mem % ALIGN_SIZE) != 0)
420193db:	149030        	extui	a9, a3, 0, 2
420193de:	00c916        	beqz	a9, 420193ee <tlsf_add_pool+0x22>
		printf("tlsf_add_pool: Memory must be aligned by %u bytes.\n",
420193e1:	4b0c      	movi.n	a11, 4
420193e3:	9fa2a1        	l32r	a10, 4200126c <_stext+0x124c> (3c021910 <_flash_rodata_start+0x17f0>)
420193e6:	f3d9e5        	call8	4200d184 <printf>
		return 0;
420193e9:	020c      	movi.n	a2, 0
420193eb:	005bc6        	j	4201955e <tlsf_add_pool+0x192>
	if (pool_bytes < block_size_min || pool_bytes > tlsf_block_size_max(tlsf))
420193ee:	bb0c      	movi.n	a11, 11
420193f0:	16bb87        	bgeu	a11, a8, 4201940a <tlsf_add_pool+0x3e>
	if (control == NULL)
420193f3:	e28c      	beqz.n	a2, 42019405 <tlsf_add_pool+0x39>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
420193f5:	42c8      	l32i.n	a12, a2, 16
420193f7:	54c8c0        	extui	a12, a12, 8, 6
420193fa:	1b0c      	movi.n	a11, 1
420193fc:	401c00        	ssl	a12
420193ff:	a1bb00        	sll	a11, a11
42019402:	000046        	j	42019407 <tlsf_add_pool+0x3b>
		return 0;
42019405:	09bd      	mov.n	a11, a9
42019407:	1ebb87        	bgeu	a11, a8, 42019429 <tlsf_add_pool+0x5d>
			(unsigned int)(pool_overhead + block_size_min),
4201940a:	bacb      	addi.n	a11, a10, 12
	if (control == NULL)
4201940c:	c28c      	beqz.n	a2, 4201941c <tlsf_add_pool+0x50>
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4201940e:	4288      	l32i.n	a8, a2, 16
42019410:	548880        	extui	a8, a8, 8, 6
42019413:	01a092        	movi	a9, 1
42019416:	401800        	ssl	a8
42019419:	a19900        	sll	a9, a9
		printf("tlsf_add_pool: Memory size must be between %u and %u bytes.\n", 
4201941c:	ca9a      	add.n	a12, a10, a9
4201941e:	9f94a1        	l32r	a10, 42001270 <_stext+0x1250> (3c021944 <_flash_rodata_start+0x1824>)
42019421:	f3d625        	call8	4200d184 <printf>
		return 0;
42019424:	020c      	movi.n	a2, 0
42019426:	004d06        	j	4201955e <tlsf_add_pool+0x192>
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42019429:	fcc392        	addi	a9, a3, -4
	const size_t oldsize = block->size;
4201942c:	19a8      	l32i.n	a10, a9, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4201942e:	14a0a0        	extui	a10, a10, 0, 2
42019431:	2088a0        	or	a8, a8, a10
42019434:	1989      	s32i.n	a8, a9, 4
	block->size |= block_header_free_bit;
42019436:	1b0c      	movi.n	a11, 1
42019438:	20a8b0        	or	a10, a8, a11
4201943b:	19a9      	s32i.n	a10, a9, 4
	block->size &= ~block_header_prev_free_bit;
4201943d:	da7c      	movi.n	a10, -3
4201943f:	10a8a0        	and	a10, a8, a10
42019442:	20aab0        	or	a10, a10, a11
42019445:	19a9      	s32i.n	a10, a9, 4
	mapping_insert(control, block_size(block), &fl, &sl);
42019447:	ca7c      	movi.n	a10, -4
42019449:	1088a0        	and	a8, a8, a10
	if (size < control->small_block_size)
4201944c:	42a8      	l32i.n	a10, a2, 16
4201944e:	75a7a0        	extui	a10, a10, 23, 8
42019451:	0fb8a7        	bgeu	a8, a10, 42019464 <tlsf_add_pool+0x98>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
42019454:	42b8      	l32i.n	a11, a2, 16
42019456:	54beb0        	extui	a11, a11, 14, 6
42019459:	d2aab0        	quos	a10, a10, a11
4201945c:	d288a0        	quos	a8, a8, a10
		fl = 0;
4201945f:	0b0c      	movi.n	a11, 0
42019461:	000c06        	j	42019495 <tlsf_add_pool+0xc9>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
42019464:	a88c      	beqz.n	a8, 42019472 <tlsf_add_pool+0xa6>
42019466:	40f8b0        	nsau	a11, a8
42019469:	e0cbb2        	addi	a11, a11, -32
4201946c:	60b0b0        	neg	a11, a11
4201946f:	000046        	j	42019474 <tlsf_add_pool+0xa8>
42019472:	0b0c      	movi.n	a11, 0
	return bit - 1;
42019474:	cb0b      	addi.n	a12, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
42019476:	42a8      	l32i.n	a10, a2, 16
42019478:	25d4a0        	extui	a13, a10, 20, 3
4201947b:	c0ccd0        	sub	a12, a12, a13
4201947e:	400c00        	ssr	a12
42019481:	918080        	srl	a8, a8
42019484:	1c0c      	movi.n	a12, 1
42019486:	401d00        	ssl	a13
42019489:	a1cc00        	sll	a12, a12
4201948c:	3088c0        	xor	a8, a8, a12
		fl -= (control->fl_index_shift - 1);
4201948f:	24a5a0        	extui	a10, a10, 5, 3
42019492:	c0bba0        	sub	a11, a11, a10
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
42019495:	82c8      	l32i.n	a12, a2, 32
42019497:	42a8      	l32i.n	a10, a2, 16
42019499:	54aea0        	extui	a10, a10, 14, 6
4201949c:	82aab0        	mull	a10, a10, a11
4201949f:	80aa80        	add	a10, a10, a8
420194a2:	a0aac0        	addx4	a10, a10, a12
420194a5:	0aa8      	l32i.n	a10, a10, 0
	tlsf_assert(current && "free list cannot have a null entry");
420194a7:	011a56        	bnez	a10, 420194bc <tlsf_add_pool+0xf0>
420194aa:	9f72d1        	l32r	a13, 42001274 <_stext+0x1254> (3c021984 <_flash_rodata_start+0x1864>)
420194ad:	9f72c1        	l32r	a12, 42001278 <_stext+0x1258> (3c0269d0 <__func__$17>)
420194b0:	90a1b2        	movi	a11, 0x190
420194b3:	9f72a1        	l32r	a10, 4200127c <_stext+0x125c> (3c0219cf <_flash_rodata_start+0x18af>)
420194b6:	9b1481        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420194b9:	0008e0        	callx8	a8
	tlsf_assert(block && "cannot insert a null entry into the free list");
420194bc:	114366        	bnei	a3, 4, 420194d1 <tlsf_add_pool+0x105>
420194bf:	9f70d1        	l32r	a13, 42001280 <_stext+0x1260> (3c0219e8 <_flash_rodata_start+0x18c8>)
420194c2:	9f6dc1        	l32r	a12, 42001278 <_stext+0x1258> (3c0269d0 <__func__$17>)
420194c5:	91a1b2        	movi	a11, 0x191
420194c8:	9f6da1        	l32r	a10, 4200127c <_stext+0x125c> (3c0219cf <_flash_rodata_start+0x18af>)
420194cb:	9b0f81        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420194ce:	0008e0        	callx8	a8
	block->next_free = current;
420194d1:	29a9      	s32i.n	a10, a9, 8
	block->prev_free = &control->block_null;
420194d3:	3929      	s32i.n	a2, a9, 12
	current->prev_free = block;
420194d5:	3a99      	s32i.n	a9, a10, 12
	return tlsf_cast(void*,
420194d7:	c98b      	addi.n	a12, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
420194d9:	a9bb      	addi.n	a10, a9, 11
420194db:	cd7c      	movi.n	a13, -4
420194dd:	10aad0        	and	a10, a10, a13
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
420194e0:	111ca7        	beq	a12, a10, 420194f5 <tlsf_add_pool+0x129>
420194e3:	9f68d1        	l32r	a13, 42001284 <_stext+0x1264> (3c021a24 <_flash_rodata_start+0x1904>)
420194e6:	9f64c1        	l32r	a12, 42001278 <_stext+0x1258> (3c0269d0 <__func__$17>)
420194e9:	96a1b2        	movi	a11, 0x196
420194ec:	9f64a1        	l32r	a10, 4200127c <_stext+0x125c> (3c0219cf <_flash_rodata_start+0x18af>)
420194ef:	9b0681        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
420194f2:	0008e0        	callx8	a8
	control->blocks[fl * control->sl_index_count + sl] = block;
420194f5:	82d8      	l32i.n	a13, a2, 32
420194f7:	42a8      	l32i.n	a10, a2, 16
420194f9:	54aea0        	extui	a10, a10, 14, 6
420194fc:	82aba0        	mull	a10, a11, a10
420194ff:	a8aa      	add.n	a10, a8, a10
42019501:	a0aad0        	addx4	a10, a10, a13
42019504:	0a99      	s32i.n	a9, a10, 0
	control->fl_bitmap |= (1U << fl);
42019506:	62d8      	l32i.n	a13, a2, 24
42019508:	1a0c      	movi.n	a10, 1
4201950a:	401b00        	ssl	a11
4201950d:	a1ea00        	sll	a14, a10
42019510:	20dde0        	or	a13, a13, a14
42019513:	62d9      	s32i.n	a13, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
42019515:	72d8      	l32i.n	a13, a2, 28
42019517:	a0bbd0        	addx4	a11, a11, a13
4201951a:	0bd8      	l32i.n	a13, a11, 0
4201951c:	401800        	ssl	a8
4201951f:	a1aa00        	sll	a10, a10
42019522:	208da0        	or	a8, a13, a10
42019525:	0b89      	s32i.n	a8, a11, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42019527:	19a8      	l32i.n	a10, a9, 4
42019529:	c87c      	movi.n	a8, -4
4201952b:	108a80        	and	a8, a10, a8
	block_header_t* next = offset_to_block(block_to_ptr(block),
4201952e:	fcc882        	addi	a8, a8, -4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42019531:	88ca      	add.n	a8, a8, a12
	tlsf_assert(!block_is_last(block));
42019533:	3b0c      	movi.n	a11, 3
42019535:	113ba7        	bltu	a11, a10, 4201954a <tlsf_add_pool+0x17e>
42019538:	9f4ad1        	l32r	a13, 42001260 <_stext+0x1240> (3c0218c4 <_flash_rodata_start+0x17a4>)
4201953b:	9f4ac1        	l32r	a12, 42001264 <_stext+0x1244> (3c0269f0 <__func__$20>)
4201953e:	a1a0b2        	movi	a11, 161
42019541:	9f49a1        	l32r	a10, 42001268 <_stext+0x1248> (3c0218f7 <_flash_rodata_start+0x17d7>)
42019544:	9af181        	l32r	a8, 42000108 <_stext+0xe8> (4037fd28 <__assert_func>)
42019547:	0008e0        	callx8	a8
	next->prev_phys_block = block;
4201954a:	0899      	s32i.n	a9, a8, 0
	const size_t oldsize = block->size;
4201954c:	1898      	l32i.n	a9, a8, 4
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4201954e:	14a090        	extui	a10, a9, 0, 2
42019551:	18a9      	s32i.n	a10, a8, 4
	block->size &= ~block_header_free_bit;
42019553:	2a0c      	movi.n	a10, 2
42019555:	1099a0        	and	a9, a9, a10
42019558:	1899      	s32i.n	a9, a8, 4
	block->size |= block_header_prev_free_bit;
4201955a:	18a9      	s32i.n	a10, a8, 4
	return mem;
4201955c:	032d      	mov.n	a2, a3
}
4201955e:	f01d      	retw.n

42019560 <tlsf_create>:
{
42019560:	004136        	entry	a1, 32
42019563:	20a220        	or	a10, a2, a2
42019566:	20b330        	or	a11, a3, a3
	if (mem == NULL)
42019569:	01e216        	beqz	a2, 4201958b <tlsf_create+0x2b>
	if (((tlsfptr_t)mem % ALIGN_SIZE) != 0)
4201956c:	148020        	extui	a8, a2, 0, 2
4201956f:	d88c      	beqz.n	a8, 42019580 <tlsf_create+0x20>
		printf("tlsf_create: Memory must be aligned to %u bytes.\n",
42019571:	4b0c      	movi.n	a11, 4
42019573:	9f45a1        	l32r	a10, 42001288 <_stext+0x1268> (3c021ba0 <_flash_rodata_start+0x1a80>)
42019576:	f3c0e5        	call8	4200d184 <printf>
		return NULL;
42019579:	020c      	movi.n	a2, 0
4201957b:	000306        	j	4201958b <tlsf_create+0x2b>
4201957e:	e50000        	extui	a0, a0, 16, 15
	control_t* control_ptr = control_construct(tlsf_cast(control_t*, mem), max_bytes);
42019581:	0a2dffbe 	ee.vmulas.s16.accx.ld.ip.qup	q5, a11, 0xfffffef0, q3, q6, q2, q5
	return tlsf_cast(tlsf_t, control_ptr);
42019585:	000086        	j	4201958b <tlsf_create+0x2b>
42019588:	000000        	ill
}
4201958b:	f01d      	retw.n
4201958d:	000000        	ill

42019590 <tlsf_create_with_pool>:
{
42019590:	004136        	entry	a1, 32
42019593:	027d      	mov.n	a7, a2
42019595:	20b440        	or	a11, a4, a4
	tlsf_t tlsf = tlsf_create(mem, max_bytes ? max_bytes : pool_bytes);
42019598:	002456        	bnez	a4, 4201959e <tlsf_create_with_pool+0xe>
4201959b:	20b330        	or	a11, a3, a3
4201959e:	20a770        	or	a10, a7, a7
420195a1:	fffbe5        	call8	42019560 <tlsf_create>
420195a4:	202aa0        	or	a2, a10, a10
	if (tlsf != NULL)
420195a7:	ea8c      	beqz.n	a10, 420195b9 <tlsf_create_with_pool+0x29>
		tlsf_add_pool(tlsf, (char*)mem + tlsf_size(tlsf), pool_bytes - tlsf_size(tlsf));
420195a9:	9f1881        	l32r	a8, 4200120c <_stext+0x11ec> (4037fb18 <tlsf_size>)
420195ac:	0008e0        	callx8	a8
420195af:	c0c3a0        	sub	a12, a3, a10
420195b2:	b7aa      	add.n	a11, a7, a10
420195b4:	02ad      	mov.n	a10, a2
420195b6:	ffe165        	call8	420193cc <tlsf_add_pool>
}
420195b9:	f01d      	retw.n
	...

420195bc <tlsf_pool_overhead>:
{
420195bc:	004136        	entry	a1, 32
}
420195bf:	820c      	movi.n	a2, 8
420195c1:	f01d      	retw.n
	...

420195c4 <log_level_get>:
{
420195c4:	006136        	entry	a1, 48
420195c7:	027d      	mov.n	a7, a2
420195c9:	9a9881        	l32r	a8, 4200002c <_stext+0xc> (3fc92438 <esp_log_default_level>)
420195cc:	0828      	l32i.n	a2, a8, 0
    esp_log_level_t level_for_tag = esp_log_get_default_level();
420195ce:	0129      	s32i.n	a2, a1, 0
    if (tag == NULL) {
420195d0:	47bc      	beqz.n	a7, 42019608 <log_level_get+0x44>
    if (timeout) {
420195d2:	b38c      	beqz.n	a3, 420195e1 <log_level_get+0x1d>
        if (esp_log_impl_lock_timeout() == false) {
420195d4:	9f2e81        	l32r	a8, 4200128c <_stext+0x126c> (4037fb90 <esp_log_impl_lock_timeout>)
420195d7:	0008e0        	callx8	a8
420195da:	9acc      	bnez.n	a10, 420195e7 <log_level_get+0x23>
            return ESP_LOG_NONE;
420195dc:	020c      	movi.n	a2, 0
420195de:	000986        	j	42019608 <log_level_get+0x44>
        esp_log_impl_lock();
420195e1:	9f2b81        	l32r	a8, 42001290 <_stext+0x1270> (4037fb68 <esp_log_impl_lock>)
420195e4:	0008e0        	callx8	a8
    bool cache_miss = !esp_log_cache_get_level(tag, &level_for_tag);
420195e7:	20b110        	or	a11, a1, a1
420195ea:	20a770        	or	a10, a7, a7
420195ed:	e964e5        	call8	42002c3c <esp_log_cache_get_level>
    if (cache_miss) {
420195f0:	cacc      	bnez.n	a10, 42019600 <log_level_get+0x3c>
        esp_log_linked_list_get_level(tag, &level_for_tag);
420195f2:	01bd      	mov.n	a11, a1
420195f4:	07ad      	mov.n	a10, a7
420195f6:	e958e5        	call8	42002b84 <esp_log_linked_list_get_level>
        esp_log_cache_add(tag, level_for_tag);
420195f9:	01b8      	l32i.n	a11, a1, 0
420195fb:	07ad      	mov.n	a10, a7
420195fd:	e96ee5        	call8	42002cec <esp_log_cache_add>
    esp_log_impl_unlock();
42019600:	9f2581        	l32r	a8, 42001294 <_stext+0x1274> (4037fbc8 <esp_log_impl_unlock>)
42019603:	0008e0        	callx8	a8
    return level_for_tag;
42019606:	0128      	l32i.n	a2, a1, 0
}
42019608:	f01d      	retw.n
	...

4201960c <esp_time_impl_get_time_since_boot>:
{
4201960c:	004136        	entry	a1, 32
    microseconds = s_microseconds_offset + esp_system_get_time();
4201960f:	9f2381        	l32r	a8, 4200129c <_stext+0x127c> (403751cc <esp_system_get_time>)
42019612:	0008e0        	callx8	a8
42019615:	9f2091        	l32r	a9, 42001298 <_stext+0x1278> (3fc95358 <s_microseconds_offset>)
42019618:	0988      	l32i.n	a8, a9, 0
4201961a:	1998      	l32i.n	a9, a9, 4
4201961c:	3b9a      	add.n	a3, a11, a9
4201961e:	2a8a      	add.n	a2, a10, a8
42019620:	01b287        	bgeu	a2, a8, 42019625 <esp_time_impl_get_time_since_boot+0x19>
42019623:	331b      	addi.n	a3, a3, 1
}
42019625:	f01d      	retw.n
	...

42019628 <esp_sync_timekeeping_timers>:

void esp_sync_timekeeping_timers(void)
{
42019628:	006136        	entry	a1, 48
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    struct timeval tv;
    gettimeofday(&tv, NULL);
4201962b:	00a0b2        	movi	a11, 0
4201962e:	20a110        	or	a10, a1, a1
42019631:	f3e2a5        	call8	4200d45c <gettimeofday>
    settimeofday(&tv, NULL);
42019634:	00a0b2        	movi	a11, 0
42019637:	01ad      	mov.n	a10, a1
42019639:	ecaae5        	call8	420060e8 <settimeofday>
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
4201963c:	9a9c81        	l32r	a8, 420000ac <_stext+0x8c> (40377e30 <esp_rtc_get_time_us>)
4201963f:	0008e0        	callx8	a8
42019642:	0a7d      	mov.n	a7, a10
42019644:	0b6d      	mov.n	a6, a11
42019646:	9f1581        	l32r	a8, 4200129c <_stext+0x127c> (403751cc <esp_system_get_time>)
42019649:	0008e0        	callx8	a8
4201964c:	c066b0        	sub	a6, a6, a11
4201964f:	01b7a7        	bgeu	a7, a10, 42019654 <esp_sync_timekeeping_timers+0x2c>
42019652:	660b      	addi.n	a6, a6, -1
42019654:	c077a0        	sub	a7, a7, a10
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
42019657:	9c4881        	l32r	a8, 42000778 <_stext+0x758> (4037fe3c <esp_time_impl_get_boot_time>)
4201965a:	0008e0        	callx8	a8
4201965d:	9f0e91        	l32r	a9, 42001298 <_stext+0x1278> (3fc95358 <s_microseconds_offset>)
42019660:	0988      	l32i.n	a8, a9, 0
42019662:	1998      	l32i.n	a9, a9, 4
42019664:	c09960        	sub	a9, a9, a6
42019667:	01b877        	bgeu	a8, a7, 4201966c <esp_sync_timekeeping_timers+0x44>
4201966a:	990b      	addi.n	a9, a9, -1
4201966c:	c08870        	sub	a8, a8, a7
4201966f:	bb9a      	add.n	a11, a11, a9
42019671:	aa8a      	add.n	a10, a10, a8
42019673:	01ba87        	bgeu	a10, a8, 42019678 <esp_sync_timekeeping_timers+0x50>
42019676:	bb1b      	addi.n	a11, a11, 1
42019678:	9c4181        	l32r	a8, 4200077c <_stext+0x75c> (4037fe60 <esp_time_impl_set_boot_time>)
4201967b:	0008e0        	callx8	a8
#endif
}
4201967e:	f01d      	retw.n

42019680 <esp_flash_read_chip_id>:
{
42019680:	004136        	entry	a1, 32
42019683:	02ad      	mov.n	a10, a2
42019685:	03bd      	mov.n	a11, a3
    return read_id_core(chip, out_id, true);
42019687:	01a0c2        	movi	a12, 1
4201968a:	9f0581        	l32r	a8, 420012a0 <_stext+0x1280> (40377ab0 <read_id_core>)
4201968d:	0008e0        	callx8	a8
}
42019690:	0a2d      	mov.n	a2, a10
42019692:	f01d      	retw.n

42019694 <esp_flash_app_enable_os_functions>:
{
42019694:	004136        	entry	a1, 32
    main_flash_arg = (app_func_arg_t) {
42019697:	9f0381        	l32r	a8, 420012a4 <_stext+0x1284> (3c02843c <g_spi_lock_main_flash_dev>)
4201969a:	0868      	l32i.n	a6, a8, 0
4201969c:	9f0371        	l32r	a7, 420012a8 <_stext+0x1288> (3fc93a10 <main_flash_arg>)
4201969f:	0c1c      	movi.n	a12, 16
420196a1:	0b0c      	movi.n	a11, 0
420196a3:	20a770        	or	a10, a7, a7
420196a6:	9b1781        	l32r	a8, 42000304 <_stext+0x2e4> (400011e8 <memset>)
420196a9:	0008e0        	callx8	a8
420196ac:	0769      	s32i.n	a6, a7, 0
    chip->os_func = &esp_flash_spi1_default_os_functions;
420196ae:	9eff81        	l32r	a8, 420012ac <_stext+0x128c> (3fc939e8 <esp_flash_spi1_default_os_functions>)
420196b1:	2289      	s32i.n	a8, a2, 8
    chip->os_func_data = &main_flash_arg;
420196b3:	3279      	s32i.n	a7, a2, 12
}
420196b5:	020c      	movi.n	a2, 0
420196b7:	f01d      	retw.n
420196b9:	000000        	ill

420196bc <xt_int_has_handler>:

//Returns true if handler for interrupt is not the default unhandled interrupt handler
bool xt_int_has_handler(int intr, int cpu)
{
420196bc:	004136        	entry	a1, 32
    return (_xt_interrupt_table[intr*portNUM_PROCESSORS+cpu].handler != xt_unhandled_interrupt);
420196bf:	902230        	addx2	a2, a2, a3
420196c2:	9efb81        	l32r	a8, 420012b0 <_stext+0x1290> (3fc925c0 <_xt_interrupt_table>)
420196c5:	b02280        	addx8	a2, a2, a8
420196c8:	0228      	l32i.n	a2, a2, 0
420196ca:	9efa81        	l32r	a8, 420012b4 <_stext+0x1294> (40376c08 <xt_unhandled_interrupt>)
420196cd:	c02280        	sub	a2, a2, a8
}
420196d0:	180c      	movi.n	a8, 1
420196d2:	932820        	movnez	a2, a8, a2
420196d5:	f01d      	retw.n
	...

420196d8 <xt_set_interrupt_handler>:
  parameter specifies the argument to be passed to the handler when it is
  invoked. The function returns the address of the previous handler.
  On error, it returns 0.
*/
xt_handler xt_set_interrupt_handler(int n, xt_handler f, void * arg)
{
420196d8:	004136        	entry	a1, 32
    xt_handler_table_entry * entry;
    xt_handler               old;

    if( n < 0 || n >= XCHAL_NUM_INTERRUPTS )
420196db:	f81c      	movi.n	a8, 31
420196dd:	373827        	bltu	a8, a2, 42019718 <xt_set_interrupt_handler+0x40>
        return 0;       /* invalid interrupt number */
    if( Xthal_intlevel[n] > XCHAL_EXCM_LEVEL )
420196e0:	9ef681        	l32r	a8, 420012b8 <_stext+0x1298> (3c028488 <Xthal_intlevel>)
420196e3:	882a      	add.n	a8, a8, a2
420196e5:	000882        	l8ui	a8, a8, 0
420196e8:	3148f6        	bgeui	a8, 4, 4201971d <xt_set_interrupt_handler+0x45>
        return 0;       /* priority level too high to safely handle in C */

    /* Convert exception number to _xt_exception_table name */
    n = n * portNUM_PROCESSORS + xPortGetCoreID();
420196eb:	222a      	add.n	a2, a2, a2
420196ed:	03eb80        	rsr.prid	a8
420196f0:	048d80        	extui	a8, a8, 13, 1
420196f3:	828a      	add.n	a8, a2, a8

    entry = _xt_interrupt_table + n;
420196f5:	9eee91        	l32r	a9, 420012b0 <_stext+0x1290> (3fc925c0 <_xt_interrupt_table>)
420196f8:	b09890        	addx8	a9, a8, a9
    old   = entry->handler;
420196fb:	0928      	l32i.n	a2, a9, 0

    if (f) {
420196fd:	738c      	beqz.n	a3, 42019708 <xt_set_interrupt_handler+0x30>
        entry->handler = f;
420196ff:	0939      	s32i.n	a3, a9, 0
        entry->arg     = arg;
42019701:	1949      	s32i.n	a4, a9, 4
42019703:	000206        	j	4201970f <xt_set_interrupt_handler+0x37>
42019706:	a10000        	sll	a0, a0
    }
    else {
        entry->handler = &xt_unhandled_interrupt;
42019709:	9eeb      	addi.n	a9, a14, 14
4201970b:	09a9      	s32i.n	a10, a9, 0
        entry->arg     = (void*)n;
4201970d:	1989      	s32i.n	a8, a9, 4
    }

    return ((old == &xt_unhandled_interrupt) ? 0 : old);
4201970f:	9ee981        	l32r	a8, 420012b4 <_stext+0x1294> (40376c08 <xt_unhandled_interrupt>)
42019712:	0e9287        	bne	a2, a8, 42019724 <xt_set_interrupt_handler+0x4c>
42019715:	000246        	j	42019722 <xt_set_interrupt_handler+0x4a>
        return 0;       /* invalid interrupt number */
42019718:	020c      	movi.n	a2, 0
4201971a:	000186        	j	42019724 <xt_set_interrupt_handler+0x4c>
        return 0;       /* priority level too high to safely handle in C */
4201971d:	020c      	movi.n	a2, 0
4201971f:	000046        	j	42019724 <xt_set_interrupt_handler+0x4c>
    return ((old == &xt_unhandled_interrupt) ? 0 : old);
42019722:	020c      	movi.n	a2, 0
}
42019724:	f01d      	retw.n
	...
